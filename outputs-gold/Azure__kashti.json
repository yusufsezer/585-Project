'js' const { events , Job , Group } = require ( "s" ) ; const img = "s" ; const releaseTagRegex = "s" ; function tests ( ) { var job = new Job ( "s" , img ) ; job . env = { "s" : "s" } ; job . tasks = [ "s" , "s" ] ; return job ; } function 0 ( ) { var job = new Job ( "s" , img ) ; job . env = { "s" : "s" } ; job . tasks = [ "s" , "s" ] ; return job ; } function buildAndPublishImages ( project , version ) { let dockerRegistry = project . secrets . dockerhubRegistry || "s" ; let dockerOrg = project . secrets . dockerhubOrg || "s" ; var job = new Job ( "s" , "s" ) ; job . privileged = true ; job . tasks = [ "s" , "s" , "s" , "s" , `template` , `template` , `template` ] ; return job ; } function runSuite ( e , p ) { if ( e . revision . ref != "s" ) { return Promise . all ( [ runTests ( e , p , tests ) . catch ( ( err ) => { return err } ) , runTests ( e , p , 0 ) . catch ( ( err ) => { return err } ) , ] ) . then ( ( values ) => { values . forEach ( ( value ) => { if ( value instanceof Error ) throw value ; } ) ; } ) ; } } function runTests ( e , p , jobFunc ) { console . log ( "s" ) ; let job = jobFunc ( ) ; var note = new Notification ( job . name , e , p ) ; note . conclusion = "s" ; note . title = `template` ; note . summary = `template` ; return notificationWrap ( job , note ) ; } function runCheck ( e , p ) { payload = JSON . parse ( e . payload ) ; name = payload . body . check_run . name ; switch ( name ) { case "s" : return runTests ( e , p , tests ) ; case "s" : return runTests ( e , p , 0 ) ; default : throw new Error ( `template` ) ; } } function handleIssueComment ( e , p ) { console . log ( "s" ) payload = JSON . parse ( e . payload ) ; comment = payload . body . comment . body . trim ( ) ; switch ( comment ) { case "s" : return runSuite ( e , p ) ; default : console . log ( `template` ) ; } } class Notification { constructor ( name , e , p ) { this . proj = p ; this . payload = e . payload ; this . name = name ; this . externalID = e . buildID ; this . detailsURL = `template` ; this . title = "s" ; this . text = "s" ; this . summary = "s" ; this . count = 0 ; this . conclusion = "s" ; } run ( ) { this . count ++ ; var job = new Job ( `template` , "s" ) ; job . imageForcePull = true ; job . env = { "s" : this . conclusion , "s" : this . name , "s" : this . title , "s" : this . payload , "s" : this . summary , "s" : this . text , "s" : this . detailsURL , "s" : this . externalID } ; return job . run ( ) ; } } async function notificationWrap ( job , note ) { await note . run ( ) ; try { let res = await job . run ( ) ; const logs = await job . logs ( ) ; note . conclusion = "s" ; note . summary = `template` ; return await note . run ( ) ; } catch ( e ) { const logs = await job . logs ( ) ; note . conclusion = "s" ; note . summary = `template` ; try { await note . run ( ) ; } catch ( 0 ) { console . error ( "s" + 0 . toString ( ) ) ; console . error ( "s" + e . toString ( ) ) ; } throw e ; } } events . on ( "s" , ( e , p ) => { return Group . runAll ( [ tests ( ) , 0 ( ) , ] ) ; } ) ; events . on ( "s" , ( e , p ) => { let matchStr = e . revision . ref . match ( releaseTagRegex ) ; if ( matchStr ) { let matchTokens = Array . from ( matchStr ) ; let version = matchTokens [ 0 ] ; return buildAndPublishImages ( p , version ) . run ( ) ; } if ( e . revision . ref == "s" ) { return Group . runAll ( [ tests ( ) , 0 ( ) , ] ) . then ( ( ) => { buildAndPublishImages ( p , "s" ) . run ( ) ; } ) ; } } ) ; events . on ( "s" , runSuite ) ; events . on ( "s" , runSuite ) ; events . on ( "s" , runCheck ) ; events . on ( "s" , handleIssueComment ) ; events . on ( "s" , handleIssueComment ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element } from 's' ; export class AppPage { navigateTo ( url ) { return browser . get ( url ) ; } getCurrentUrl ( ) { return browser . getCurrentUrl ( ) ; } getParagraphText ( ) { return element ( by . css ( 's' ) ) . getText ( ) ; } getSidebar ( ) { return element ( by . id ( 's' ) ) ; } getHomePageLink ( ) { return this . getSidebar ( ) . element ( by . id ( 's' ) ) ; } getDocLink ( ) { return this . getSidebar ( ) . element ( by . id ( 's' ) ) ; } getIssuesLink ( ) { return this . getSidebar ( ) . element ( by . id ( 's' ) ) ; } getTitle ( ) { return browser . getTitle ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element } from 's' ; import { AppPage } from 's' ; describe ( 's' , ( ) => { let page ; beforeEach ( ( ) => { page = new AppPage ( ) ; page . navigateTo ( 's' ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( page . getCurrentUrl ( ) ) . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( page . getTitle ( ) ) . toEqual ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { let link ; it ( 's' , ( ) => { expect ( page . getSidebar ( ) . isPresent ( ) ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { link = page . getHomePageLink ( ) ; link . click ( ) ; expect ( page . getCurrentUrl ( ) ) . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { link = page . getDocLink ( ) ; expect ( link . getAttribute ( 's' ) ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { link = page . getIssuesLink ( ) ; expect ( link . getAttribute ( 's' ) ) . toEqual ( 's' ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppPage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { clearContext : false } , coverageIstanbulReporter : { dir : require ( 's' ) . join ( __dirname , 's' ) , reports : [ 's' , 's' ] , fixWebpackSourcePaths : true } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , browsers : [ 's' , 's' ] , customLaunchers : { ChromeHeadless : { base : 's' , flags : [ 's' , 's' , 's' , 's' ] } } , singleRun : true } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { SpecReporter } = require ( 's' ) ; exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , capabilities : { 's' : 's' , 's' : { 's' : [ 's' , 's' ] } } , directConnect : true , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : 's' } ) ; jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const BuildLogs = { message : 's' }	O O O O O O O O O
export enum JobStatus { Pending = 's' , Running = 's' , Succeeded = 's' , Failed = 's' , Unknown = 's' } export interface Job { id : string ; name : string ; image : string ; creation_time : string ; start_time : string ; end_time : string ; exit_code : number ; status : JobStatus ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { JobStatus } from 's' ; export interface BuildWorker { id : string ; build_id : string ; project_id : string ; start_time : string ; end_time : string ; exit_code : number ; status : JobStatus ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface Revision { commit : string ; ref : string ; }	O O O O O O O O O O O O O
import { BuildWorker } from 's' ; import { Revision } from 's' ; export interface Build { id : string ; project_id : string ; type : string ; provider : string ; revision : Revision ; payload ? : string ; script ? : string ; worker ? : BuildWorker ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Build } from 's' ; import { JobStatus } from 's' ; export const Builds : Build [ ] = [ { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , payload : 's' , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Failed } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , payload : 's' , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Failed } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Succeeded } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Running } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Failed } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Succeeded } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Pending } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Succeeded } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Succeeded } } , { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Succeeded } } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface BuildLog { message : string ; }	O O O O O O O O O
import { Observable } from 's' ; import { Build } from 's' ; import { BuildLog } from 's' ; export abstract class BuildService { abstract getBuilds ( projectId ) < Build [ ] > ; abstract getBuild ( buildId ) < Build > ; abstract getBuildLog ( buildId ) < BuildLog > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O $Observable$ O $string$ O O O O O O $Observable$ O $string$ O O O O O O
import 's' ; import { Observable } from 's' ; import { BuildLogs } from 's' ; import { Builds } from 's' ; import { Build } from 's' ; import { BuildLog } from 's' ; import { BuildService } from 's' ; export class MockBuildService implements BuildService { getBuilds ( projectId ) < Build [ ] > { const filteredList = Builds . filter ( ( build ) => build . project_id === projectId ) ; return Observable . of ( filteredList ) ; } getBuild ( buildId ) < Build > { const filteredList = Builds . filter ( ( build ) => build . id === buildId ) ; return Observable . of ( filteredList [ 0 ] ) . delay ( 0 ) ; } getBuildLog ( buildId ) < BuildLog > { return Observable . of ( BuildLogs ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O $Build$ O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O $Build$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O
import { Job , JobStatus } from 's' ; export const Jobs : Job [ ] = [ { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Failed } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Running } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Unknown } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Running } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Failed } , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable } from 's' ; import { Job } from 's' ; export abstract class JobService { abstract getJobs ( buildId ) < Job [ ] > ; abstract getJob ( jobId ) < Job > ; }	O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O $Observable$ O $string$ O O O O O O
import 's' ; import { Observable } from 's' ; import { Jobs } from 's' ; import { Job } from 's' ; import { JobService } from 's' ; export class MockJobService implements JobService { getJobs ( buildId ) < Job [ ] > { return Observable . of ( Jobs ) ; } getJob ( jobId ) < Job > { const filteredList = Jobs . filter ( ( job ) => job . id === jobId ) ; return Observable . of ( filteredList [ 0 ] ) . delay ( 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O $Job$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const LogData = { message : 's' }	O O O O O O O O O
export interface Log { message : string ; }	O O O O O O O O O
import { Observable } from 's' ; import { Log } from 's' ; export abstract class LogService { abstract getLog ( jobId ) < Log > ; }	O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O
import 's' ; import { Observable } from 's' ; import { LogData } from 's' ; import { Log } from 's' ; import { LogService } from 's' ; export class MockLogService implements LogService { getLog ( jobId ) < Log > { return Observable . of ( LogData ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O
export interface Kubernetes { namespace : string ; vcsSidecar : string ; buildStorageSize : string ; }	O O O O O O O O O O O O O O O O O
export interface Repo { name : string ; cloneURL : string ; }	O O O O O O O O O O O O O
export interface Worker { registry : string ; name : string ; tag : string ; pullPolicy : string ; }	O O O O O O O O O O O O O O O O O O O O O
import { Kubernetes } from 's' ; import { Repo } from 's' ; import { Worker } from 's' ; export interface Project { id : string ; name : string ; repo : Repo ; defaultScript : string ; kubernetes : Kubernetes ; github : any ; secrets : any ; worker : Worker ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Project } from 's' ; export const Projects : Project [ ] = [ { id : 's' , name : 's' , repo : { name : 's' , cloneURL : 's' } , defaultScript : 's' , kubernetes : { namespace : 's' , vcsSidecar : 's' , buildStorageSize : 's' } , github : { baseURL : 's' , uploadURL : 's' } , secrets : { } , worker : { registry : 's' , name : 's' , tag : 's' , pullPolicy : 's' } } , { id : 's' , name : 's' , repo : { name : 's' , cloneURL : 's' } , defaultScript : 's' , kubernetes : { namespace : 's' , vcsSidecar : 's' , buildStorageSize : 's' } , github : { baseURL : 's' , uploadURL : 's' } , secrets : { SLACK_WEBHOOK : 's' , dbPassword : 's' } , worker : { registry : 's' , name : 's' , tag : 's' , pullPolicy : 's' } } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BuildWorker } from 's' ; import { Revision } from 's' ; export interface LastBuild { id : string ; project_id : string ; type : string ; provider : string ; revision : Revision ; payload ? : string ; script ? : string ; worker ? : BuildWorker ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { LastBuild } from 's' ; import { Project } from 's' ; export interface ProjectsBuild { project : Project ; lastBuild ? : LastBuild ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ProjectsBuild } from 's' ; import { JobStatus } from 's' ; export const ProjectsBuilds : ProjectsBuild [ ] = [ { 's' : { 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : { 's' : 's' , 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : { } , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } } , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Failed } } } , { 's' : { 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : { 's' : 's' , 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } } , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : JobStatus . Succeeded } } } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable } from 's' ; import { Project } from 's' ; import { ProjectsBuild } from 's' ; export abstract class ProjectService { abstract getProjectBuilds ( ) < ProjectsBuild [ ] > ; abstract getProject ( projectId ) < Project > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O $Observable$ O $string$ O O O O O O
import { Injectable } from 's' ; import 's' ; import 's' ; import { Observable } from 's' ; import { Projects } from 's' ; import { ProjectsBuilds } from 's' ; import { Project } from 's' ; import { ProjectsBuild } from 's' ; import { ProjectService } from 's' ; @ Injectable ( ) export class MockProjectService implements ProjectService { getProjectBuilds ( ) < ProjectsBuild [ ] > { return Observable . of ( ProjectsBuilds ) . delay ( 0 ) ; } getProject ( projectId ) < Project > { const filteredList = Projects . filter ( ( project ) => project . id === projectId ) ; return Observable . of ( filteredList [ 0 ] ) . delay ( 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O $Project$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { MockBuildService } from 's' ; import { MockJobService } from 's' ; import { MockLogService } from 's' ; import { MockProjectService } from 's' ; export const environment = { production : false , routeDebugging : true , buildServiceType : MockBuildService , projectServiceType : MockProjectService , jobServiceType : MockJobService , logServiceType : MockLogService } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Location } from 's' ; import { Component , OnInit } from 's' ; import { ActivatedRoute } from 's' ; import { Build } from 's' ; import { BuildLog } from 's' ; import { BuildWorker } from 's' ; import { Job } from 's' ; import { Revision } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class BuildComponent implements OnInit { build : Build ; buildlogs : BuildLog ; revision : Revision ; worker : BuildWorker ; jobs : Job [ ] ; location : Location ; constructor ( private route , location ) { this . location = location ; } backClicked ( ) { this . location . back ( ) ; } ngOnInit ( ) { this . build = this . route . snapshot . data [ 's' ] ; this . buildlogs = this . route . snapshot . data [ 's' ] as BuildLog ; this . revision = this . build . revision ; this . worker = this . build . worker ; this . jobs = this . route . snapshot . data [ 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Location } from 's' ; import { Component , OnInit } from 's' ; import { ActivatedRoute } from 's' ; import { LastBuild } from 's' ; import { ProjectsBuild } from 's' ; import { JobStatus } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class DashboardComponent implements OnInit { location : Location ; projectsBuilds : ProjectsBuild [ ] ; constructor ( private route , location ) { this . location = location ; } backClicked ( ) { this . location . back ( ) ; } ngOnInit ( ) { this . projectsBuilds = this . route . snapshot . data [ 's' ] ; } showStatus ( projectBuild ) { if ( projectBuild . lastBuild === null || projectBuild . lastBuild . worker === undefined || projectBuild . lastBuild . worker === null ) { return false ; } return true ; } calculateStatusClasses ( lastBuild ) { if ( lastBuild === null || lastBuild . worker === undefined || lastBuild . worker === null ) { return this . unknownStateClasses ( ) ; } const status = lastBuild . worker . status ; switch ( status ) { case JobStatus . Succeeded : return this . successStateClasses ( ) ; case JobStatus . Failed : return this . failureStateClasses ( ) ; case JobStatus . Running : return this . activeStateClasses ( ) ; default : return this . unknownStateClasses ( ) ; } } successStateClasses ( ) { return { 's' : true , 's' : true } ; } failureStateClasses ( ) { return { 's' : true , 's' : true } ; } activeStateClasses ( ) { return { 's' : true } ; } unknownStateClasses ( ) { return { 's' : true , 's' : true , 's' : true } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectsBuild$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LastBuild$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Location } from 's' ; import { Component , OnInit } from 's' ; import { ActivatedRoute } from 's' ; import 's' ; import { Job } from 's' ; import { Log } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , providers : [ Location ] , styleUrls : [ 's' ] } ) export class JobComponent implements OnInit { job : Job ; log : Log ; location : Location ; constructor ( private route , location ) { this . location = location ; } backClicked ( ) { this . location . back ( ) ; } ngOnInit ( ) { this . job = this . route . snapshot . data [ 's' ] ; this . log = this . route . snapshot . data [ 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Location } from 's' ; import { Component , OnInit } from 's' ; import { ActivatedRoute } from 's' ; import 's' ; import { Build } from 's' ; import { Project } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ProjectComponent implements OnInit { project : Project ; builds : Build [ ] ; location : Location ; constructor ( private route , location ) { this . location = location ; } backClicked ( ) { this . location . back ( ) ; } ngOnInit ( ) { this . project = this . route . snapshot . data [ 's' ] ; this . builds = this . route . snapshot . data [ 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Build } from 's' ; import { BuildService } from 's' ; @ Injectable ( ) export class BuildResolver implements Resolve < Build > { constructor ( private buildService ) { } resolve ( route ) { return this . buildService . getBuild ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { BuildLog } from 's' ; import { BuildService } from 's' ; @ Injectable ( ) export class BuildLogResolver implements Resolve < BuildLog > { constructor ( private buildService ) { } resolve ( route ) { return this . buildService . getBuildLog ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Build } from 's' ; import { BuildService } from 's' ; @ Injectable ( ) export class BuildsResolver implements Resolve < Build [ ] > { constructor ( private buildService ) { } resolve ( route ) { return this . buildService . getBuilds ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Job } from 's' ; import { JobService } from 's' ; @ Injectable ( ) export class JobResolver implements Resolve < Job > { constructor ( private jobService ) { } resolve ( route ) { return this . jobService . getJob ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Job } from 's' ; import { JobService } from 's' ; @ Injectable ( ) export class JobsResolver implements Resolve < Job [ ] > { constructor ( private jobService ) { } resolve ( route ) { return this . jobService . getJobs ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Log } from 's' ; import { LogService } from 's' ; @ Injectable ( ) export class LogResolver implements Resolve < Log > { constructor ( private logService ) { } resolve ( route ) { return this . logService . getLog ( route . paramMap . get ( 's' ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogService$ O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import 's' ; import { Observable } from 's' ; import { Project } from 's' ; import { ProjectService } from 's' ; @ Injectable ( ) export class ProjectResolver implements Resolve < Project > { constructor ( private projectService ) { } resolve ( route ) < Project > { return this . projectService . getProject ( route . paramMap . get ( 's' ) ) . catch ( ( e ) => Observable . throw ( console . log ( e ) ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O O $Observable$ O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { Resolve } from 's' ; import { ProjectsBuild } from 's' ; import { ProjectService } from 's' ; @ Injectable ( ) export class ProjectsBuildResolver implements Resolve < ProjectsBuild [ ] > { constructor ( private projectService ) { } resolve ( ) { return this . projectService . getProjectBuilds ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; declare var $ ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class StyleGuideComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { $ ( document ) . foundation ( ) ; } }	O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' ; import { RouterModule , Routes } from 's' ; import { environment } from 's' ; import { BuildComponent } from 's' ; import { DashboardComponent } from 's' ; import { JobComponent } from 's' ; import { ProjectComponent } from 's' ; import { BuildResolver } from 's' ; import { BuildLogResolver } from 's' ; import { BuildsResolver } from 's' ; import { JobResolver } from 's' ; import { JobsResolver } from 's' ; import { LogResolver } from 's' ; import { ProjectResolver } from 's' ; import { ProjectsBuildResolver } from 's' ; import { StyleGuideComponent } from 's' ; const routes = [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , data : { breadcrumb : 's' } , component : DashboardComponent , resolve : { projectsBuilds : ProjectsBuildResolver } , } , { path : 's' , data : { breadcrumb : 's' } , component : ProjectComponent , resolve : { project : ProjectResolver , builds : BuildsResolver } , } , { path : 's' , data : { breadcrumb : 's' } , component : BuildComponent , resolve : { build : BuildResolver , buildlog : BuildLogResolver , jobs : JobsResolver } , } , { path : 's' , data : { breadcrumb : 's' } , component : JobComponent , resolve : { job : JobResolver , log : LogResolver } , } , { path : 's' , component : StyleGuideComponent } ] ; @ NgModule ( { imports : [ RouterModule . forRoot ( routes , { enableTracing : environment . routeDebugging } ) ] , exports : [ RouterModule ] } ) export class AppRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AppComponent { title = 's' ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface BreadCrumb { label : string ; url : string ; }	O O O O O O O O O O O O O
import { Location } from 's' ; import { Component , OnInit , ViewEncapsulation } from 's' ; import { ActivatedRoute , NavigationEnd , Router } from 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import { BreadCrumb } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class BreadcrumbComponent implements OnInit { location : Location ; breadcrumbs$ = this . router . events . filter ( event => event instanceof NavigationEnd ) . distinctUntilChanged ( ) . map ( event => this . buildBreadCrumb ( this . activatedRoute . root ) ) ; constructor ( private activatedRoute , public router , location ) { this . location = location ; } backClicked ( ) { this . location . back ( ) ; } ngOnInit ( ) { } buildBreadCrumb ( route , url = 's' , breadcrumbs < BreadCrumb > = [ ] ) < BreadCrumb > { const label = route . routeConfig ? route . routeConfig . data [ 's' ] : 's' ; const path = route . routeConfig ? route . routeConfig . path : 's' ; const nextUrl = `template` ; const breadcrumb = { label : label , url : nextUrl } ; const newBreadcrumbs = [ ... breadcrumbs , breadcrumb ] ; if ( route . firstChild ) { return this . buildBreadCrumb ( route . firstChild , nextUrl , newBreadcrumbs ) ; } return newBreadcrumbs ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $Router$ O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O $ActivatedRoute$ O $string$ O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FooterComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SidebarComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , TestBed } from 's' ; import { RouterTestingModule } from 's' ; import { AppComponent } from 's' ; import { BreadcrumbComponent } from 's' ; import { FooterComponent } from 's' ; import { SidebarComponent } from 's' ; describe ( 's' , ( ) => { beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AppComponent , BreadcrumbComponent , SidebarComponent , FooterComponent ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : AppComponent } ] ) ] } ) . compileComponents ( ) ; } ) ) ; it ( 's' , async ( ( ) => { const fixture = TestBed . createComponent ( AppComponent ) ; const app = fixture . debugElement . componentInstance ; expect ( app ) . toBeTruthy ( ) ; } ) ) ; it ( `template` , async ( ( ) => { const fixture = TestBed . createComponent ( AppComponent ) ; const app = fixture . debugElement . componentInstance ; expect ( app . title ) . toEqual ( 's' ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const BRIGADE_API_HOST = 's' ;	O O O O O O
export const BRIGADE_API_HOST = window . location . origin ;	O O O O O O O O O O
import { Component , Input , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class BuildStatusBadgeComponent implements OnInit { @ Input ( ) status : string ; constructor ( ) { this . status = status ; } ngOnInit ( ) { } running ( status ) { if ( status === 's' || status === 's' ) { return true ; } } calculateIconClass ( status ) { switch ( status ) { case 's' : return 's' ; case 's' : return 's' ; case 's' : return 's' ; case 's' : return 's' ; default : return 's' ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; import { ActivatedRoute } from 's' ; import 's' ; import { Log } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class LogComponent implements OnInit { log : Log ; constructor ( private route ) { } ngOnInit ( ) { this . log = this . route . snapshot . data [ 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' ; import { Build } from 's' ; export enum TimeDifference { equal = 0 , before = - 0 , after = 0 } @ Pipe ( { name : 's' } ) export class SortBuildByStartDatePipe implements PipeTransform { static compare ( 0 , 0 ) { const workerOneExists = ! ! 0 . worker ; const workerTwoExists = ! ! 0 . worker ; if ( ( ! workerOneExists ) && ( ! workerTwoExists ) ) { return TimeDifference . equal ; } if ( ! workerOneExists ) { return TimeDifference . before ; } if ( ! workerTwoExists ) { return TimeDifference . after ; } const 0 = new Date ( 0 . worker . start_time ) . getTime ( ) ; const 0 = new Date ( 0 . worker . start_time ) . getTime ( ) ; if ( 0 === 0 ) { return TimeDifference . equal ; } if ( 0 < 0 ) { return TimeDifference . after ; } return TimeDifference . before ; } transform ( builds : Build [ ] , desc ) : Build [ ] { if ( ! builds ) { return undefined ; } const order = desc ? - 0 : 0 ; return builds . sort ( ( 0 , 0 ) => { return SortBuildByStartDatePipe . compare ( 0 , 0 ) * order ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Build$ O $Build$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientModule } from 's' ; import { NgModule } from 's' ; import { BrowserModule } from 's' ; import { MomentModule } from 's' ; import { environment } from 's' ; import { AppRoutingModule } from 's' ; import { AppComponent } from 's' ; import { BreadcrumbComponent } from 's' ; import { BuildStatusBadgeComponent } from 's' ; import { BuildComponent } from 's' ; import { DashboardComponent } from 's' ; import { FooterComponent } from 's' ; import { JobComponent } from 's' ; import { LogComponent } from 's' ; import { SortBuildByStartDatePipe } from 's' ; import { ProjectComponent } from 's' ; import { BuildService } from 's' ; import { JobService } from 's' ; import { LogService } from 's' ; import { ProjectService } from 's' ; import { BuildResolver } from 's' ; import { BuildLogResolver } from 's' ; import { BuildsResolver } from 's' ; import { JobResolver } from 's' ; import { JobsResolver } from 's' ; import { LogResolver } from 's' ; import { ProjectResolver } from 's' ; import { ProjectsBuildResolver } from 's' ; import { SidebarComponent } from 's' ; import { StyleGuideComponent } from 's' ; @ NgModule ( { declarations : [ AppComponent , DashboardComponent , StyleGuideComponent , BreadcrumbComponent , SidebarComponent , FooterComponent , ProjectComponent , BuildComponent , BuildStatusBadgeComponent , JobComponent , LogComponent , SortBuildByStartDatePipe ] , imports : [ MomentModule , BrowserModule , HttpClientModule , AppRoutingModule ] , providers : [ { provide : BuildService , useClass : environment . buildServiceType } , { provide : ProjectService , useClass : environment . projectServiceType } , { provide : JobService , useClass : environment . jobServiceType } , { provide : LogService , useClass : environment . logServiceType } , ProjectResolver , ProjectsBuildResolver , BuildsResolver , BuildResolver , BuildLogResolver , JobsResolver , JobResolver , LogResolver ] , bootstrap : [ AppComponent ] } ) export class AppModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientTestingModule } from 's' ; import { async , ComponentFixture , TestBed } from 's' ; import { RouterTestingModule } from 's' ; import { MomentModule } from 's' ; import { BreadcrumbComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < BreadcrumbComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ BreadcrumbComponent ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : BreadcrumbComponent } ] ) , MomentModule , HttpClientTestingModule ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BreadcrumbComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BreadcrumbComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ActivatedRoute } from 's' ; import { RouterTestingModule } from 's' ; import { BuildComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < BuildComponent > ; const build = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 0 , 's' : 's' } ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ BuildComponent ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : BuildComponent } ] ) , ] , providers : [ { provide : ActivatedRoute , useValue : { snapshot : { data : { 's' : build } } } } ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BuildComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; xit ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { BuildStatusBadgeComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < BuildStatusBadgeComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ BuildStatusBadgeComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BuildStatusBadgeComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildStatusBadgeComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientTestingModule } from 's' ; import { async , ComponentFixture , TestBed } from 's' ; import { RouterTestingModule } from 's' ; import { MomentModule } from 's' ; import { ProjectService } from 's' ; import { DashboardComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < DashboardComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ DashboardComponent ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : DashboardComponent } ] ) , MomentModule , HttpClientTestingModule ] , providers : [ ProjectService ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( DashboardComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DashboardComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { FooterComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < FooterComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ FooterComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( FooterComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $FooterComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { RouterTestingModule } from 's' ; import { JobComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < JobComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : JobComponent } ] ) ] , declarations : [ JobComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( JobComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientTestingModule } from 's' ; import { async , ComponentFixture , TestBed } from 's' ; import { RouterTestingModule } from 's' ; import { MomentModule } from 's' ; import { LogComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LogComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LogComponent ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : LogComponent } ] ) , MomentModule , HttpClientTestingModule ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LogComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Factory from 's' ; import { Build } from 's' ; import { JobStatus } from 's' ; export const BuildFactory = Factory . makeFactory < Build > ( { id : 's' , project_id : 's' , type : 's' , provider : 's' , revision : { commit : 's' , ref : 's' } , payload : 's' , script : 's' , worker : { id : 's' , build_id : 's' , project_id : 's' , start_time : 's' , end_time : 's' , exit_code : 0 , status : JobStatus . Failed } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BuildFactory } from 's' ; import { SortBuildByStartDatePipe , TimeDifference } from 's' ; describe ( 's' , ( ) => { let pipe ; beforeEach ( ( ) => { pipe = new SortBuildByStartDatePipe ( ) ; } ) ; it ( 's' , ( ) => { expect ( pipe ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { const result = pipe . transform ( undefined , false ) ; expect ( result ) . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const mockBuilds = BuildFactory . buildList ( 0 , { } ) ; const result = pipe . transform ( mockBuilds , true ) ; expect ( result ) . toEqual ( mockBuilds ) ; } ) ; it ( 's' , ( ) => { const mockBuild = BuildFactory . build ( { worker : undefined } ) ; const result = SortBuildByStartDatePipe . compare ( mockBuild , mockBuild ) ; expect ( result ) . toEqual ( TimeDifference . equal ) ; } ) ; it ( 's' , ( ) => { const 0 = BuildFactory . build ( { worker : undefined } ) ; const 0 = BuildFactory . build ( { } ) ; const result = SortBuildByStartDatePipe . compare ( 0 , 0 ) ; expect ( result ) . toEqual ( TimeDifference . before ) ; } ) ; it ( 's' , ( ) => { const 0 = BuildFactory . build ( { worker : undefined } ) ; const 0 = BuildFactory . build ( { } ) ; const result = SortBuildByStartDatePipe . compare ( 0 , 0 ) ; expect ( result ) . toEqual ( TimeDifference . after ) ; } ) ; it ( 's' , ( ) => { const mockBuild = BuildFactory . build ( { } ) ; const result = SortBuildByStartDatePipe . compare ( mockBuild , mockBuild ) ; expect ( result ) . toEqual ( TimeDifference . equal ) ; } ) ; it ( 's' , ( ) => { const 0 = BuildFactory . build ( { } ) ; 0 . worker . start_time = 's' ; const 0 = BuildFactory . build ( { worker : undefined } ) ; 0 . worker = { ... 0 . worker , start_time : 's' , } ; const result = SortBuildByStartDatePipe . compare ( 0 , 0 ) ; expect ( result ) . toEqual ( TimeDifference . after ) ; } ) ; it ( 's' , ( ) => { const 0 = BuildFactory . build ( { } ) ; 0 . worker . start_time = 's' ; const 0 = BuildFactory . build ( { worker : undefined } ) ; 0 . worker = { ... 0 . worker , start_time : 's' , } ; const result = SortBuildByStartDatePipe . compare ( 0 , 0 ) ; expect ( result ) . toEqual ( TimeDifference . before ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O $SortBuildByStartDatePipe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Factory from 's' ; import { Project } from 's' ; export const ProjectFactory = Factory . makeFactory < Project > ( { id : 's' , name : 's' , repo : { name : 's' , cloneURL : 's' } , defaultScript : 's' , kubernetes : { namespace : 's' , vcsSidecar : 's' , buildStorageSize : 's' } , github : { baseURL : 's' , uploadURL : 's' } , secrets : { } , worker : { registry : 's' , name : 's' , tag : 's' , pullPolicy : 's' } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ActivatedRoute } from 's' ; import { RouterTestingModule } from 's' ; import { MomentModule } from 's' ; import { BuildStatusBadgeComponent } from 's' ; import { Build } from 's' ; import { Project } from 's' ; import { SortBuildByStartDatePipe } from 's' ; import { BuildFactory } from 's' ; import { ProjectFactory } from 's' ; import { ProjectComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProjectComponent > ; let mockProject ; let mockBuilds : Build [ ] ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProjectComponent , BuildStatusBadgeComponent , SortBuildByStartDatePipe ] , imports : [ RouterTestingModule . withRoutes ( [ { path : 's' , component : ProjectComponent } ] ) , MomentModule ] , providers : [ { provide : ActivatedRoute , useValue : { snapshot : { data : { 's' : mockProject , builds : mockBuilds } } } } ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProjectComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; afterEach ( ( ) => { component = undefined ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockProject = ProjectFactory . build ( { name : 's' } ) ; mockBuilds = BuildFactory . buildList ( 0 , { id : 's' } ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { expect ( component . project ) . toEqual ( mockProject ) ; expect ( fixture . nativeElement . querySelector ( 's' ) . textContent ) . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( component . builds ) . toEqual ( mockBuilds ) ; const firstBuild = fixture . nativeElement . querySelector ( 's' ) ; expect ( firstBuild . textContent ) . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { component . project . name = 's' ; component . builds [ 0 ] . id = 's' ; fixture . detectChanges ( ) ; expect ( fixture . nativeElement . querySelector ( 's' ) . textContent ) . toContain ( 's' ) ; const buildElement = fixture . nativeElement . querySelector ( 's' ) ; expect ( buildElement . textContent ) . toContain ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockProject = undefined ; mockBuilds = undefined ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { expect ( component . project ) . toBeUndefined ( ) ; expect ( component . builds ) . toBeUndefined ( ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectComponent$ O O $ComponentFixture$ O O O O O $Project$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClient , HttpHeaders } from 's' ; import { Injectable } from 's' ; import { Observable } from 's' ; import { BRIGADE_API_HOST } from 's' ; import { Build } from 's' ; import { BuildLog } from 's' ; import { BuildService } from 's' ; const httpOptions = { headers : new HttpHeaders ( { 's' : 's' } ) } ; @ Injectable ( ) export class ApiBuildService implements BuildService { constructor ( private http ) { } getBuilds ( projectId ) < Build [ ] > { const buildsUrl = `template` ; return this . http . get < Build [ ] > ( buildsUrl , httpOptions ) ; } getBuild ( buildId ) < Build > { const buildUrl = `template` ; return this . http . get < Build > ( buildUrl , httpOptions ) ; } getBuildLog ( buildId ) < BuildLog > { const buildlogUrl = `template` ; const options = { responseType : 's' as 's' } ; return this . http . get < string > ( buildlogUrl , options ) . map ( ( log ) => < BuildLog > ( { message : log } ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O
import { HttpClientModule } from 's' ; import { HttpClientTestingModule , HttpTestingController } from 's' ; import { async , inject , TestBed } from 's' ; import { ApiBuildService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ApiBuildService ] , imports : [ HttpClientModule , HttpClientTestingModule ] } ) ; } ) ; afterEach ( inject ( [ HttpTestingController ] , ( backend ) => { backend . verify ( ) ; } ) ) ; it ( 's' , inject ( [ ApiBuildService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; xit ( 's' , async ( inject ( [ ApiBuildService , HttpTestingController ] , ( service , backend ) => { service . getBuilds ( 's' ) . subscribe ( ) ; backend . expectOne ( 's' ) . flush ( null , { status : 0 , statusText : 's' } ) ; } ) ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O $ApiBuildService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApiBuildService$ O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClient , HttpHeaders } from 's' ; import { Injectable } from 's' ; import { Observable } from 's' ; import { BRIGADE_API_HOST } from 's' ; import { Job } from 's' ; import { JobService } from 's' ; const httpOptions = { headers : new HttpHeaders ( { 's' : 's' } ) } ; @ Injectable ( ) export class ApiJobService implements JobService { constructor ( private http ) { } getJobs ( buildId ) < Job [ ] > { const jobsUrl = `template` ; return this . http . get < Job [ ] > ( jobsUrl , httpOptions ) ; } getJob ( jobId ) < Job > { const jobUrl = `template` ; return this . http . get < Job > ( jobUrl , httpOptions ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientModule } from 's' ; import { HttpClientTestingModule , HttpTestingController } from 's' ; import { async , inject , TestBed } from 's' ; import { ApiJobService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ApiJobService ] , imports : [ HttpClientModule , HttpClientTestingModule ] } ) ; } ) ; afterEach ( inject ( [ HttpTestingController ] , ( backend ) => { backend . verify ( ) ; } ) ) ; it ( 's' , inject ( [ ApiJobService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; xit ( 's' , async ( inject ( [ ApiJobService , HttpTestingController ] , ( service , backend ) => { service . getJobs ( 's' ) . subscribe ( ) ; backend . expectOne ( 's' ) . flush ( null , { status : 0 , statusText : 's' } ) ; } ) ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O $ApiJobService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApiJobService$ O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClient , HttpHeaders } from 's' ; import { Injectable } from 's' ; import { Observable } from 's' ; import { BRIGADE_API_HOST } from 's' ; import { Log } from 's' ; import { LogService } from 's' ; const httpOptions = { headers : new HttpHeaders ( { 's' : 's' } ) } ; @ Injectable ( ) export class ApiLogService implements LogService { constructor ( private http ) { } getLog ( jobId ) < Log > { const logUrl = `template` ; const options = { responseType : 's' as 's' } ; return this . http . get < string > ( logUrl , options ) . map ( ( log ) => < Log > { message : log } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O
import { HttpClientModule } from 's' ; import { HttpClientTestingModule , HttpTestingController } from 's' ; import { inject , TestBed } from 's' ; import { ApiLogService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ApiLogService ] , imports : [ HttpClientModule , HttpClientTestingModule ] } ) ; } ) ; afterEach ( inject ( [ HttpTestingController ] , ( backend ) => { backend . verify ( ) ; } ) ) ; it ( 's' , inject ( [ ApiLogService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O $ApiLogService$ O O O O O O O O O O O O O O O O O O O
import { HttpClient , HttpHeaders } from 's' ; import { Injectable } from 's' ; import { Observable } from 's' ; import { BRIGADE_API_HOST } from 's' ; import { Project } from 's' ; import { ProjectsBuild } from 's' ; import { ProjectService } from 's' ; const httpOptions = { headers : new HttpHeaders ( { 's' : 's' } ) } ; @ Injectable ( ) export class ApiProjectService implements ProjectService { constructor ( private http ) { } getProjectBuilds ( ) < ProjectsBuild [ ] > { const projectBuildsUrl = `template` ; return this . http . get < ProjectsBuild [ ] > ( projectBuildsUrl , httpOptions ) ; } getProject ( projectId ) < Project > { const projectUrl = `template` ; return this . http . get < Project > ( projectUrl , httpOptions ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpClientModule } from 's' ; import { HttpClientTestingModule , HttpTestingController } from 's' ; import { async , inject , TestBed } from 's' ; import { ApiProjectService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ApiProjectService ] , imports : [ HttpClientModule , HttpClientTestingModule ] } ) ; } ) ; afterEach ( inject ( [ HttpTestingController ] , ( backend ) => { backend . verify ( ) ; } ) ) ; it ( 's' , inject ( [ ApiProjectService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; xit ( 's' , async ( inject ( [ ApiProjectService , HttpTestingController ] , ( service , backend ) => { service . getProjectBuilds ( ) . subscribe ( ) ; backend . expectOne ( 's' ) . flush ( null , { status : 0 , statusText : 's' } ) ; } ) ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O $ApiProjectService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApiProjectService$ O $HttpTestingController$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { BuildService } from 's' ; import { BuildResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ BuildResolver , BuildService ] } ) ; } ) ; it ( 's' , inject ( [ BuildResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { BuildService } from 's' ; import { BuildsResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ BuildsResolver , BuildService ] } ) ; } ) ; it ( 's' , inject ( [ BuildsResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildsResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { BuildService } from 's' ; import { BuildResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ BuildResolver , BuildService ] } ) ; } ) ; it ( 's' , inject ( [ BuildResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { BuildService } from 's' ; import { BuildsResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ BuildsResolver , BuildService ] } ) ; } ) ; it ( 's' , inject ( [ BuildsResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildsResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { JobService } from 's' ; import { JobResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ JobResolver , JobService ] } ) ; } ) ; it ( 's' , inject ( [ JobResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { ProjectService } from 's' ; import { ProjectResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ProjectResolver , ProjectService ] } ) ; } ) ; it ( 's' , inject ( [ ProjectResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectResolver$ O O O O O O O O O O O O O O O O O O O
import { inject , TestBed } from 's' ; import { ProjectService } from 's' ; import { ProjectResolver } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ProjectResolver , ProjectService ] } ) ; } ) ; it ( 's' , inject ( [ ProjectResolver ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectResolver$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { SidebarComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < SidebarComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ SidebarComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( SidebarComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $SidebarComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { StyleGuideComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < StyleGuideComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ StyleGuideComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( StyleGuideComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $StyleGuideComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ApiBuildService } from 's' ; import { ApiJobService } from 's' ; import { ApiLogService } from 's' ; import { ApiProjectService } from 's' ; export const environment = { production : true , routeDebugging : false , buildServiceType : ApiBuildService , projectServiceType : ApiProjectService , jobServiceType : ApiJobService , logServiceType : ApiLogService } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { enableProdMode } from 's' ; import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; import { environment } from 's' ; if ( environment . production ) { enableProdMode ( ) ; } platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) . catch ( err => console . log ( err ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import 's' ;	O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const __karma__ ; declare const require ; __karma__ . loaded = function ( ) { } ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ; __karma__ . start ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O