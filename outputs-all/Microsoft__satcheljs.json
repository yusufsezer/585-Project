'js' module . exports = { transform : { 's' : 's' , } , testMatch : [ 's' , 's' ] , moduleFileExtensions : [ 's' , 's' , 's' , 's' ] , } ;	O $complex$ O $complex$ O O $complex$ O O O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O
interface ActionMessage { type ? : string ; [ key ] : any ; } export default ActionMessage ;	O $any$ O $string$ O O O O O $string$ O O O O O O O $any$ O
import ActionMessage from 's' ; type ActionCreator < T extends ActionMessage > = ( ... args : any [ ] ) => T ; export default ActionCreator ;	O $any$ O O O O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O O $any$ O O O $any$ O
import ActionMessage from 's' ; type MutatorFunction < T extends ActionMessage > = ( actionMessage : T ) => void ; export default MutatorFunction ;	O $any$ O O O O $any$ O $any$ O $any$ O O O $T$ O $any$ O O O O O O $any$ O
import ActionMessage from 's' ; type OrchestratorFunction < T extends ActionMessage > = ( actionMessage : T ) => void | Promise < any > ; export default OrchestratorFunction ;	O $any$ O O O O $any$ O $any$ O $any$ O O O $T$ O $any$ O O O O $PromiseConstructor$ O O O O O O $any$ O
import ActionMessage from 's' ; import MutatorFunction from 's' ; import OrchestratorFunction from 's' ; type Subscriber < T extends ActionMessage > = MutatorFunction < T > | OrchestratorFunction < T > ; export default Subscriber ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O
import ActionMessage from 's' ; type DispatchFunction = ( actionMessage ) => void | Promise < void > ; export default DispatchFunction ;	O $any$ O O O O $any$ O O $ActionMessage$ O O O O $PromiseConstructor$ O O O O O O $any$ O
interface ActionContext { [ key ] : any ; } export default ActionContext ;	O $any$ O O $string$ O O O O O O O $any$ O
interface ActionFunction { ( ) : Promise < any > | void ; } export default ActionFunction ;	O $any$ O O O O $PromiseConstructor$ O O O O O O O O O $any$ O
import { observable , ObservableMap } from 's' ; import ActionMessage from 's' ; import DispatchFunction from 's' ; import Subscriber from 's' ; import ActionContext from 's' ; import ActionFunction from 's' ; const schemaVersion = 0 ; export interface GlobalContext { schemaVersion : number ; rootStore : ObservableMap < any > ; nextActionId : number ; subscriptions : { [ key ] : Subscriber < ActionMessage > [ ] } ; dispatchWithMiddleware : DispatchFunction ; inMutator : boolean ; legacyInDispatch : number ; legacyDispatchWithMiddleware : ( action , actionType , args , actionContext ) => Promise < any > | void ; legacyTestMode : boolean ; } declare var global : { __satchelGlobalContext : GlobalContext ; } ; export function __resetGlobalContext ( ) { global . __satchelGlobalContext = { schemaVersion : schemaVersion , rootStore : observable . map ( { } ) , nextActionId : 0 , subscriptions : { } , dispatchWithMiddleware : null , inMutator : false , legacyInDispatch : 0 , legacyDispatchWithMiddleware : null , legacyTestMode : false , } ; } export function ensureGlobalContextSchemaVersion ( ) { if ( schemaVersion != global . __satchelGlobalContext . schemaVersion ) { throw new Error ( 's' ) ; } } export function getGlobalContext ( ) { return global . __satchelGlobalContext ; } if ( ! global . __satchelGlobalContext ) { __resetGlobalContext ( ) ; } else { ensureGlobalContextSchemaVersion ( ) ; }	O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O $number$ O O O $any$ O $any$ O O O O $number$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O $DispatchFunction$ O $any$ O $boolean$ O O O $number$ O O O $complex$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O $PromiseConstructor$ O O O O O O $boolean$ O O O O O O $complex$ O O $GlobalContext$ O $any$ O O O O O $void$ O O O $complex$ O $GlobalContext$ O O $number$ O O O $any$ O $any$ O $any$ O O O O O $number$ O O O ${}$ O O O O $null$ O O O $false$ O O O $number$ O O O $null$ O O O $false$ O O O O O O O O $void$ O O O O O O O $complex$ O $GlobalContext$ O $number$ O O O O $ErrorConstructor$ O O O O O O O O $GlobalContext$ O O O O $complex$ O $GlobalContext$ O O O O O $complex$ O $GlobalContext$ O O $void$ O O O O O O $void$ O O O O
import { transaction } from 's' ; import ActionMessage from 's' ; import Subscriber from 's' ; import { getPrivateActionId } from 's' ; import { getGlobalContext } from 's' ; export function subscribe ( actionId , callback < any > ) { let subscriptions = getGlobalContext ( ) . subscriptions ; if ( ! subscriptions [ actionId ] ) { subscriptions [ actionId ] = [ ] ; } subscriptions [ actionId ] . push ( callback ) ; } export function dispatch ( actionMessage ) { if ( getGlobalContext ( ) . inMutator ) { throw new Error ( 's' ) ; } let dispatchWithMiddleware = getGlobalContext ( ) . dispatchWithMiddleware || finalDispatch ; transaction ( dispatchWithMiddleware . bind ( null , actionMessage ) ) ; } export function finalDispatch ( actionMessage ) : void | Promise < void > { let actionId = getPrivateActionId ( actionMessage ) ; let subscribers = getGlobalContext ( ) . subscriptions [ actionId ] ; if ( subscribers ) { let promises : Promise < any > [ ] = [ ] ; for ( const subscriber of subscribers ) { let returnValue = subscriber ( actionMessage ) ; if ( returnValue ) { promises . push ( returnValue ) ; } } if ( promises . length ) { return promises . length == 0 ? promises [ 0 ] : Promise . all ( promises ) ; } } }	O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $GlobalContext$ O O O O O O $void$ O $string$ O $Subscriber$ O O O O O O $complex$ O $GlobalContext$ O O O $complex$ O O O O $complex$ O $string$ O O O $complex$ O $string$ O O O O O O $complex$ O $string$ O O $number$ O $Subscriber<any>$ O O O O O $void$ O $ActionMessage$ O O O O $GlobalContext$ O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O $DispatchFunction$ O $GlobalContext$ O O O $DispatchFunction$ O $complex$ O $any$ O $DispatchFunction$ O $any$ O O O $ActionMessage$ O O O O O O $complex$ O $ActionMessage$ O O O O $PromiseConstructor$ O O O O O $any$ O $any$ O $ActionMessage$ O O O $Subscriber<ActionMessage>[]$ O $GlobalContext$ O O O $complex$ O $any$ O O O O $Subscriber<ActionMessage>[]$ O O O $Promise<any>[]$ O $PromiseConstructor$ O O O O O O O O O O O O $Subscriber<ActionMessage>$ O $Subscriber<ActionMessage>[]$ O O O $complex$ O $Subscriber<ActionMessage>$ O $ActionMessage$ O O O O $complex$ O O $Promise<any>[]$ O $number$ O $Promise<any>$ O O O O O O $Promise<any>[]$ O $number$ O O O $Promise<any>[]$ O $number$ O O O $Promise<any>[]$ O O O O $PromiseConstructor$ O O O $Promise<any>[]$ O O O O O
import { getGlobalContext } from 's' ; export default function createActionId ( ) { return ( getGlobalContext ( ) . nextActionId ++ ) . toString ( ) ; }	O O $GlobalContext$ O O O O O O O $string$ O O O O O $GlobalContext$ O O O $number$ O O O $string$ O O O O
import ActionMessage from 's' ; import ActionCreator from 's' ; import { dispatch } from 's' ; import createActionId from 's' ; export function actionCreator < T extends ActionMessage = { } , TActionCreator extends ActionCreator < T > = ( ) => T > ( actionType , target ? ) { return createActionCreator ( actionType , target , false ) ; } export function action < T extends ActionMessage = { } , TActionCreator extends ActionCreator < T > = ( ) => T > ( actionType , target ? ) { return createActionCreator ( actionType , target , true ) ; } function createActionCreator < T extends ActionMessage , TActionCreator extends ActionCreator < T > > ( actionType , target , shouldDispatch ) { let actionId = createActionId ( ) ; let decoratedTarget = function createAction ( ... args : any [ ] ) { let actionMessage = target ? target . apply ( null , args ) : { } ; if ( actionMessage . type ) { throw new Error ( 's' ) ; } actionMessage . type = actionType ; setPrivateActionId ( actionMessage , actionId ) ; if ( shouldDispatch ) { dispatch ( actionMessage ) ; } return actionMessage ; } as TActionCreator ; setPrivateActionId ( decoratedTarget , actionId ) ; return decoratedTarget ; } export function getPrivateActionId ( target ) { return target . __SATCHELJS_ACTION_ID ; } function setPrivateActionId ( target , actionId ) { target . __SATCHELJS_ACTION_ID = actionId ; }	O $any$ O O O O $any$ O O O O O $void$ O O O O O $string$ O O O O O $TActionCreator$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O $TActionCreator$ $TActionCreator$ O O O $TActionCreator$ O $string$ O $TActionCreator$ O O O O O O O $TActionCreator$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O $TActionCreator$ $TActionCreator$ O O O $TActionCreator$ O $string$ O $TActionCreator$ O O O O O O $TActionCreator$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $TActionCreator$ O $boolean$ O O O $string$ O $string$ O O O O $TActionCreator$ O O $ActionMessage$ O O $any[]$ O O O O O O O $ActionMessage$ O $TActionCreator$ O $TActionCreator$ O $any$ O O O $any[]$ O O O O O O O $ActionMessage$ O $string$ O O O O $ErrorConstructor$ O O O O O $ActionMessage$ O $string$ O $string$ O $void$ O $ActionMessage$ O $string$ O O O O $boolean$ O O $void$ O $ActionMessage$ O O O O $ActionMessage$ O O O $any$ O $void$ O $TActionCreator$ O $string$ O O O $TActionCreator$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O
import ActionMessage from 's' ; import DispatchFunction from 's' ; type Middleware = ( next , actionMessage ) => void ; export default Middleware ;	O $any$ O O O O $any$ O O O O $any$ O O $DispatchFunction$ O $ActionMessage$ O O O O O O $any$ O
import DispatchFunction from 's' ; import Middleware from 's' ; import { finalDispatch } from 's' ; import { getGlobalContext } from 's' ; export default function applyMiddleware ( ... middleware : Middleware [ ] ) { var next = finalDispatch ; for ( var i = middleware . length - 0 ; i >= 0 ; i -- ) { next = applyNextMiddleware ( middleware [ i ] , next ) ; } getGlobalContext ( ) . dispatchWithMiddleware = next ; } function applyNextMiddleware ( middleware , next ) { return middleware . bind ( null , next ) ; }	O $any$ O O O O $any$ O O O O O $complex$ O O O O O O $GlobalContext$ O O O O O O O $void$ O O $Middleware[]$ O $any$ O O O O O $DispatchFunction$ O $complex$ O O O O $number$ O $Middleware[]$ O $number$ O O O $number$ O O O $number$ O O O $DispatchFunction$ O $DispatchFunction$ O $Middleware[]$ O $number$ O O $DispatchFunction$ O O O $GlobalContext$ O O O $DispatchFunction$ O $DispatchFunction$ O O O $DispatchFunction$ O $Middleware$ O $DispatchFunction$ O O O $Middleware$ O $any$ O O O $DispatchFunction$ O O O
import { ObservableMap } from 's' ; import { getGlobalContext } from 's' ; export default function getRootStore ( ) { return getGlobalContext ( ) . rootStore ; }	O O $any$ O O O O O O $GlobalContext$ O O O O O O O $any$ O O O O $GlobalContext$ O O O $any$ O O
import { action } from 's' ; import getRootStore from 's' ; let createStoreAction = action ( 's' , function createStoreAction ( key , initialState ) { if ( getRootStore ( ) . get ( key ) ) { throw new Error ( `template` ) ; } getRootStore ( ) . set ( key , initialState ) ; } ) ; export default function createStore < T > ( key , initialState : T ) : ( ) => T { createStoreAction ( key , initialState ) ; return ( ) => < T > getRootStore ( ) . get ( key ) ; }	O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O $void$ O $string$ O $any$ O O O O $any$ O O O $any$ O $string$ O O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O $string$ O $any$ O O O O O O O O $T$ O $any$ O O $string$ O $T$ O $any$ O O O O O $any$ O $any$ O $string$ O $T$ O O O O O O O $any$ O $any$ O O O $any$ O $string$ O O O
import { configure } from 's' ; export default function useStrict ( strictMode ) { configure ( { enforceActions : strictMode ? 's' : 's' } ) ; }	O O $any$ O O O O O O O $void$ O $boolean$ O O $any$ O O $string$ O $boolean$ O O O O O O O O
import { action } from 's' ; import ActionCreator from 's' ; import ActionMessage from 's' ; import MutatorFunction from 's' ; import { getPrivateActionId } from 's' ; import { subscribe } from 's' ; import { getGlobalContext } from 's' ; export default function mutator < T extends ActionMessage > ( actionCreator < T > , target < T > ) < T > { let actionId = getPrivateActionId ( actionCreator ) ; if ( ! actionId ) { throw new Error ( 's' ) ; } let wrappedTarget = action ( ( actionMessage : T ) => { try { getGlobalContext ( ) . inMutator = true ; if ( target ( actionMessage ) as any ) { throw new Error ( 's' ) ; } } finally { getGlobalContext ( ) . inMutator = false ; } } ) ; subscribe ( actionId , wrappedTarget ) ; return target ; }	O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $void$ O O O O O O $GlobalContext$ O O O O O O O $MutatorFunction$ O $any$ O $any$ O O $ActionCreator$ O $any$ O O $MutatorFunction$ O $any$ O O O $any$ O O O $any$ O $any$ O $ActionCreator<T>$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O $T$ O $any$ O O O O O $GlobalContext$ O O O $boolean$ O O O O O $MutatorFunction<T>$ O $T$ O O O O O O O $ErrorConstructor$ O O O O O O O O $GlobalContext$ O O O $boolean$ O O O O O O O $void$ O $any$ O $any$ O O O $MutatorFunction<T>$ O O
import ActionCreator from 's' ; import ActionMessage from 's' ; import OrchestratorFunction from 's' ; import { getPrivateActionId } from 's' ; import { subscribe } from 's' ; export default function orchestrator < T extends ActionMessage > ( actionCreator < T > , target < T > ) { let actionId = getPrivateActionId ( actionCreator ) ; if ( ! actionId ) { throw new Error ( 's' ) ; } subscribe ( actionId , target ) ; return target ; }	O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $void$ O O O O O O O $OrchestratorFunction<T>$ O $any$ O $any$ O O $ActionCreator$ O $any$ O O $OrchestratorFunction$ O $any$ O O O O $any$ O $any$ O $ActionCreator<T>$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $void$ O $any$ O $OrchestratorFunction<T>$ O O O $OrchestratorFunction<T>$ O O
interface SimpleAction { ( ... args : any [ ] ) : void ; } export default SimpleAction ;	O $any$ O O O $any[]$ O O O O O O O O O O O $any$ O
import SimpleAction from 's' ; import { action } from 's' ; import mutator from 's' ; export function createSimpleSubscriber ( decorator ) { return function simpleSubscriber < T extends SimpleAction > ( actionType , target : T ) : T { let simpleActionCreator = action ( actionType , function simpleActionCreator ( ) { return { args : arguments , } ; } ) ; decorator ( simpleActionCreator , function simpleSubscriberCallback ( actionMessage ) { return target . apply ( null , actionMessage . args ) ; } ) ; return ( simpleActionCreator as any ) as T ; } ; } export const mutatorAction = createSimpleSubscriber ( mutator ) ;	O $any$ O O O O O $TActionCreator$ O O O O O $MutatorFunction<T>$ O O O O O $T$ O $Function$ O O O O $T$ O $any$ O $any$ O O $string$ O $T$ O $any$ O O $any$ O O $complex$ O $TActionCreator$ O $string$ O O $complex$ O O O O O $IArguments$ O $IArguments$ O O O O O O $Function$ O $complex$ O O $any$ O $any$ O O O $T$ O $any$ O O O $any$ O $any$ O O O O O O O $complex$ O O O O $any$ O O O O O O $T$ O $T$ O $MutatorFunction<T>$ O O
import useStrict from 's' ; export { default as ActionCreator } from 's' ; export { default as ActionMessage } from 's' ; export { default as DispatchFunction } from 's' ; export { default as Middleware } from 's' ; export { default as MutatorFunction } from 's' ; export { default as OrchestratorFunction } from 's' ; export { action , actionCreator } from 's' ; export { default as applyMiddleware } from 's' ; export { default as createStore } from 's' ; export { dispatch } from 's' ; export { default as mutator } from 's' ; import { default as orchestrator } from 's' ; export { default as getRootStore } from 's' ; export { mutatorAction } from 's' ; export { useStrict } ; export const flow = orchestrator ; export { orchestrator } ; useStrict ( true ) ;	O $void$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $TActionCreator$ O $TActionCreator$ O O O O O O $void$ O $void$ O O O O O O $T$ O $T$ O O O O O O $void$ O O O O O O $MutatorFunction<T>$ O $MutatorFunction<T>$ O O O O O O $OrchestratorFunction<T>$ O $OrchestratorFunction<T>$ O O O O O O $any$ O $any$ O O O O O O $T$ O O O O O O $void$ O O O O $OrchestratorFunction<T>$ O $OrchestratorFunction<T>$ O O O $OrchestratorFunction<T>$ O O $void$ O O O O
import ActionContext from 's' ; import ActionFunction from 's' ; interface DispatchFunction { ( action , actionType , args , actionContext ) : Promise < any > | void ; } export default DispatchFunction ;	O $any$ O O O O $any$ O O O O $any$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O $PromiseConstructor$ O O O O O O O O O $any$ O
import ActionContext from 's' ; import DispatchFunction from 's' ; import ActionFunction from 's' ; interface Middleware { ( next , action , actionType , args , actionContext ) : void ; } export default Middleware ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O O O $any$ O
interface RawAction { ( ... args : any [ ] ) : Promise < any > | void ; } export default RawAction ;	O $any$ O O O $any[]$ O O O O O O $PromiseConstructor$ O O O O O O O O O $any$ O
import ActionContext from 's' ; import ActionFunction from 's' ; import LegacyDispatchFunction from 's' ; import LegacyMiddleware from 's' ; import { getGlobalContext } from 's' ; export default function applyMiddleware ( ... middleware : LegacyMiddleware [ ] ) { var next = finalDispatch ; for ( var i = middleware . length - 0 ; i >= 0 ; i -- ) { next = applyMiddlewareInternal ( middleware [ i ] , next ) ; } getGlobalContext ( ) . legacyDispatchWithMiddleware = next ; } function applyMiddlewareInternal ( middleware , next ) { return middleware . bind ( null , next ) ; } export function dispatchWithMiddleware ( action , actionType , args , actionContext ) { if ( ! getGlobalContext ( ) . legacyDispatchWithMiddleware ) { getGlobalContext ( ) . legacyDispatchWithMiddleware = finalDispatch ; } getGlobalContext ( ) . legacyDispatchWithMiddleware ( action , actionType , args , actionContext ) ; } function finalDispatch ( action , actionType , args , actionContext ) { return action ( ) ; }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $GlobalContext$ O O O O O O O $void$ O O $Middleware[]$ O $any$ O O O O O $LegacyDispatchFunction$ O $complex$ O O O O $number$ O $Middleware[]$ O $number$ O O O $number$ O O O $number$ O O O $DispatchFunction$ O $DispatchFunction$ O $Middleware[]$ O $number$ O O $DispatchFunction$ O O O $GlobalContext$ O O O $complex$ O $DispatchFunction$ O O O $LegacyDispatchFunction$ O $LegacyMiddleware$ O $LegacyDispatchFunction$ O O O $Middleware$ O $any$ O O O $DispatchFunction$ O O O O O $void$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $GlobalContext$ O O O $complex$ O O $GlobalContext$ O O O $complex$ O $complex$ O O $GlobalContext$ O O O $complex$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O $complex$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O $ActionFunction$ O O O O
import { action as mobxAction } from 's' ; import ActionContext from 's' ; import ActionFunction from 's' ; import { dispatchWithMiddleware } from 's' ; import { getGlobalContext } from 's' ; export default function dispatch ( action , actionType , args , actionContext ) { getGlobalContext ( ) . legacyInDispatch ++ ; mobxAction ( actionType ? actionType : 's' , dispatchWithMiddleware . bind ( null , action , actionType , args , actionContext ) ) ( ) ; getGlobalContext ( ) . legacyInDispatch -- ; }	O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O $void$ O O O O O O $GlobalContext$ O O O O O O O $void$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O $GlobalContext$ O O O $number$ O O $any$ O $string$ O $string$ O O O $void$ O $any$ O O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $GlobalContext$ O O O $number$ O O O
import RawAction from 's' ; export function setOriginalTarget ( decoratedTarget , originalTarget ) { decoratedTarget . __SATCHELJS_ORIGINAL_TARGET = originalTarget ; } export function getOriginalTarget ( decoratedTarget ) { if ( typeof decoratedTarget . __SATCHELJS_ORIGINAL_TARGET !== typeof undefined ) { return decoratedTarget . __SATCHELJS_ORIGINAL_TARGET ; } return undefined ; } export function setActionType ( decoratedTarget , actionType ) { decoratedTarget . __SATCHELJS_ACTION_TYPE = actionType ; } export function getActionType ( decoratedTarget ) { return ( < any > decoratedTarget ) . __SATCHELJS_ACTION_TYPE ; }	O $any$ O O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $undefined$ O O O $any$ O $any$ O O O $undefined$ O O O O $void$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O $any$ O $RawAction$ O O O O O O O $RawAction$ O O $any$ O O
import ActionContext from 's' ; import dispatch from 's' ; import RawAction from 's' ; import { setActionType , setOriginalTarget } from 's' ; export interface ActionFactory { < T extends RawAction > ( target : T ) : T ; < T extends RawAction > ( target , propertyKey , descriptor < T > ) : void ; } export default function action ( actionType , actionContext ? ) { return function createAction ( 0 , 0 , 0 ) { if ( arguments . length == 0 && typeof 0 == 's' ) { return wrapFunctionInAction ( 0 , actionType , actionContext ) ; } else { decorateClassMethod ( 0 , 0 , 0 , actionType , actionContext ) ; } } as ActionFactory ; } function wrapFunctionInAction < T extends RawAction > ( target : T , actionType , actionContext ) : T { let decoratedTarget : T = < T > function ( ) { let returnValue ; let passedArguments = arguments ; dispatch ( ( ) => { returnValue = target . apply ( this , passedArguments ) ; return returnValue ; } , actionType , arguments , actionContext ) ; return returnValue ; } ; setOriginalTarget ( decoratedTarget , target ) ; setActionType ( decoratedTarget , actionType ) ; return decoratedTarget ; } function decorateClassMethod < T extends RawAction > ( target , propertyKey , descriptor < T > , actionType , actionContext ) { if ( descriptor && typeof descriptor . value == 's' ) { descriptor . value = wrapFunctionInAction ( descriptor . value , actionType , actionContext ) ; } else { throw new Error ( 's' ) ; } }	O $any$ O O O O $void$ O O O O $any$ O O O O O $void$ O $void$ O O O O O O $any$ O O $any$ O $any$ O O $T$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $string$ O $TypedPropertyDescriptor$ O $any$ O O O O O O O O O $ActionFactory$ O $string$ O $ActionContext$ $ActionContext$ O O O O O O $any$ O $any$ O $any$ O O O O $IArguments$ O $number$ O O O O $any$ O O O O O $T$ O $any$ O $string$ O $ActionContext$ O O O O O $void$ O $any$ O $any$ O $any$ O $string$ O $ActionContext$ O O O O O $any$ O O O $T$ O $any$ O $any$ O O $T$ O $any$ O $string$ O $ActionContext$ O O $any$ O O $T$ O $any$ O O $any$ O O O O O O $any$ O O $IArguments$ O $IArguments$ O $void$ O O O O O $any$ O $T$ O $any$ O O O $IArguments$ O O O $any$ O O O $string$ O $IArguments$ O $ActionContext$ O O O $any$ O O O $void$ O $T$ O $T$ O O $void$ O $T$ O $string$ O O O $T$ O O O $void$ O $any$ O $any$ O O $any$ O $string$ O $TypedPropertyDescriptor$ O $any$ O O $string$ O $ActionContext$ O O O O $TypedPropertyDescriptor<T>$ O O $TypedPropertyDescriptor<T>$ O $T$ O O O O $TypedPropertyDescriptor<T>$ O $T$ O $T$ O $TypedPropertyDescriptor<T>$ O $T$ O $string$ O $ActionContext$ O O O O O O O $ErrorConstructor$ O O O O O O
import { Lambda , spy } from 's' ; import satcheljsAction from 's' ; let spyRefCount = 0 ; let spyDisposer = null ; function initializeSpy ( ) { if ( spyRefCount === 0 ) { spyDisposer = spy ( spyOnChanges ) ; } spyRefCount ++ ; } function disposeSpy ( ) { spyRefCount -- ; if ( spyRefCount === 0 ) { spyDisposer ( ) ; spyDisposer = null ; } } interface UndoStep { verify : ( ) => boolean ; objectName : string ; propertyName : string ; undo : ( ) => void ; } interface UndoWindow { steps : UndoStep [ ] ; } let undoWindows : UndoWindow [ ] = [ ] ; function spyOnChanges ( event ) { let undoStep ; let modifiedObject = event . object ; switch ( event . type ) { case 's' : if ( event . index !== undefined ) { undoStep = { verify : ( ) => modifiedObject [ event . index ] === event . newValue , objectName : event . name , propertyName : event . index , undo : ( ) => { modifiedObject [ event . index ] = event . oldValue ; } , } ; } else if ( typeof modifiedObject . get !== 's' ) { undoStep = { verify : ( ) => modifiedObject . get ( event . key ) === event . newValue , objectName : event . name , propertyName : event . key , undo : ( ) => { modifiedObject . set ( event . key , event . oldValue ) ; } , } ; } else { undoStep = { verify : ( ) => modifiedObject [ event . key ] === event . newValue , objectName : event . name , propertyName : event . key , undo : ( ) => { modifiedObject [ event . key ] = event . oldValue ; } , } ; } break ; case 's' : undoStep = { verify : ( ) => { for ( let i = 0 ; i < event . addedCount ; i ++ ) { if ( modifiedObject [ event . index + i ] !== event . added [ i ] ) { return false ; } } return true ; } , objectName : event . name , propertyName : event . index , undo : ( ) => { modifiedObject . splice ( event . index , event . addedCount ) ; for ( let i = 0 ; i < event . removedCount ; i ++ ) { modifiedObject . splice ( event . index + i , 0 , event . removed [ i ] ) ; } } , } ; break ; case 's' : if ( typeof modifiedObject . get !== 's' ) { undoStep = { verify : ( ) => modifiedObject . get ( event . key ) === event . newValue , objectName : event . name , propertyName : event . key , undo : ( ) => { modifiedObject . delete ( event . key ) ; } , } ; } else { undoStep = { verify : ( ) => modifiedObject [ event . key ] === event . newValue , objectName : event . name , propertyName : event . key , undo : ( ) => { delete modifiedObject [ event . key ] ; } , } ; } break ; case 's' : undoStep = { verify : ( ) => ! modifiedObject . has ( event . key ) , objectName : event . name , propertyName : event . key , undo : ( ) => { modifiedObject . set ( event . key , event . oldValue ) ; } , } ; break ; default : return ; } undoWindows . forEach ( undoWindow => undoWindow . steps . push ( undoStep ) ) ; } export interface UndoResult < T > { actionReturnValue ? : T ; ( ) : void ; } export type CreateUndoReturnValue < T > = ( action : ( ) => T | void ) => UndoResult < T > ; function trackUndo < T > ( actionName , action : ( ) => T , undoVerifiesChanges ) < T > { initializeSpy ( ) ; undoWindows . push ( { steps : [ ] } ) ; try { let returnValue : T = action ( ) ; let undoWindow = undoWindows [ undoWindows . length - 0 ] ; let undoPreviouslyExecuted = false ; undoWindow . steps . reverse ( ) ; let undo < T > = satcheljsAction ( `template` ) ( ( ) => { if ( undoPreviouslyExecuted ) { throw `template` ; } if ( undoVerifiesChanges ) { undoWindow . steps . forEach ( step => { if ( ! step . verify ( ) ) { throw `template` ; } } ) ; } undoWindow . steps . forEach ( step => step . undo ( ) ) ; undoPreviouslyExecuted = true ; } ) ; undo . actionReturnValue = returnValue ; return undo ; } finally { undoWindows . pop ( ) ; disposeSpy ( ) ; } } export default function createUndo < T > ( actionName , undoVerifiesChanges ? ) < T > { return ( action : ( ) => T ) => { return trackUndo ( actionName , action , ! ! undoVerifiesChanges ) ; } ; }	O O $any$ O $any$ O O O O O $ActionFactory$ O O O O $number$ O O O O $Lambda$ O O O O $void$ O O O O O $number$ O O O O $any$ O $any$ O $void$ O O O $number$ O O O O $void$ O O O $number$ O O O O $number$ O O O O $any$ O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $string$ O O O $string$ O O O $void$ O O O O O O O O $any$ O $UndoStep[]$ O $any$ O O O O O $UndoWindow[]$ O $any$ O O O O O O O $void$ O $any$ O O O $UndoStep$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $UndoStep$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O $UndoStep$ O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $UndoStep$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O $UndoStep$ O O $boolean$ O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O $any$ O $any$ O $number$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O $UndoStep$ O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $UndoStep$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $UndoStep$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $UndoWindow[]$ O $void$ O $UndoWindow$ O $UndoWindow$ O $UndoStep[]$ O $number$ O $UndoStep$ O O O O O O $any$ O $any$ O O $T$ O O $any$ O O O O O O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O O O O $any$ O $any$ O O O $UndoResult$ O $any$ O O $string$ O $T$ O O O O $any$ O $boolean$ O O $any$ O O $void$ O O O $UndoWindow[]$ O $number$ O O $undefined[]$ O O O O O O O O O $T$ O $any$ O $T$ O O O O $UndoWindow$ O $UndoWindow[]$ O $UndoWindow[]$ O $number$ O O O O O $boolean$ O O O $UndoWindow$ O $UndoStep[]$ O $UndoStep[]$ O O O O $UndoResult$ O $any$ O O $ActionFactory$ O O O O O O O O O O $boolean$ O O O O O O O O $boolean$ O O $UndoWindow$ O $UndoStep[]$ O $void$ O $UndoStep$ O O O O O $UndoStep$ O $boolean$ O O O O O O O O O O O O $UndoWindow$ O $UndoStep[]$ O $void$ O $UndoStep$ O $UndoStep$ O $void$ O O O O $boolean$ O O O O O O $UndoResult<T>$ O $T$ O $T$ O O $UndoResult<T>$ O O O O $UndoWindow[]$ O $UndoWindow$ O O O $void$ O O O O O O O O $CreateUndoReturnValue$ O $any$ O O $string$ O $boolean$ $boolean$ O O $any$ O O O O $T$ O O O O $any$ O O O O $UndoResult<T>$ O $string$ O $T$ O O O $boolean$ O O O O O
import { Reaction , IObservableValue , isObservableArray } from 's' ; import { getOriginalTarget , getActionType , setActionType } from 's' ; import { getGlobalContext } from 's' ; export type SelectorFunction < T > = { [ key in keyof T ] ? : ( ... args : any [ ] ) => T [ key ] } ; function createCursorFromSelector < T > ( selector < T > , args ? ) { let state = { } ; Object . keys ( selector ) . forEach ( ( key ) => { if ( typeof state [ key ] === typeof undefined ) { Object . defineProperty ( state , key , { enumerable : true , get : ( ) => selector [ key as keyof T ] . apply ( null , args ) , } ) ; } } ) ; Object . freeze ( state ) ; return state ; } export default function select < T > ( selector < T > ) { return function decorator < Target extends Function > ( target ) : Target { if ( getGlobalContext ( ) . legacyTestMode ) { return target ; } let context = this ; let argumentPosition = target . length - 0 ; let actionTarget = getOriginalTarget ( target ) ; if ( actionTarget ) { argumentPosition = actionTarget . length - 0 ; } let returnValue = function ( ) { let state = createCursorFromSelector < T > ( selector , arguments ) ; let args = Array . prototype . slice . call ( arguments ) ; if ( typeof args [ argumentPosition ] === typeof undefined ) { for ( var i = args . length ; i < argumentPosition ; i ++ ) { args [ i ] = undefined ; } args [ argumentPosition ] = state ; } return target . apply ( context , args ) ; } ; setActionType ( returnValue , getActionType ( < any > target ) ) ; return < Target > returnValue ; } ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $void$ O O O O O O $GlobalContext$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $any[]$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $SelectorFunction$ O $any$ O O $any$ $any$ O O O $any$ O O O O $ObjectConstructor$ O $complex$ O $SelectorFunction<T>$ O O $void$ O O $string$ O O O O O O $any$ O $string$ O O O $undefined$ O O $ObjectConstructor$ O $any$ O $any$ O $string$ O O $true$ O O O $any$ O O O O $SelectorFunction<T>$ O $string$ O O $any$ O O $any$ O O O $any$ O O O O O O O O O $ObjectConstructor$ O $complex$ O $any$ O O O $any$ O O O O O $Target$ O $any$ O O $SelectorFunction$ O $any$ O O O O O $Target$ O $any$ O $FunctionConstructor$ O O $Target$ O O $any$ O O O $GlobalContext$ O O O $boolean$ O O O $Target$ O O O $any$ O O O O $number$ O $Target$ O $number$ O O O O $any$ O $any$ O $Target$ O O O O $any$ O O $number$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $SelectorFunction<T>$ O $IArguments$ O O O $any$ O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $IArguments$ O O O O O $any$ O $number$ O O O $undefined$ O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O $any$ O O O $any$ O $any$ O O $undefined$ O O $any$ O $number$ O O $any$ O O O $Target$ O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $Target$ O O O O O $any$ O $any$ O O O O
import { getGlobalContext } from 's' ; export function initializeTestMode ( ) { getGlobalContext ( ) . legacyTestMode = true ; } export function resetTestMode ( ) { getGlobalContext ( ) . legacyTestMode = false ; }	O O $GlobalContext$ O O O O O O $void$ O O O $GlobalContext$ O O O $boolean$ O O O O O O $void$ O O O $GlobalContext$ O O O $boolean$ O O O O
export { default as legacyApplyMiddleware } from 's' ; export { default as LegacyMiddleware } from 's' ; export { default as ActionFunction } from 's' ; export { default as ActionContext } from 's' ; export { default as LegacyDispatchFunction } from 's' ; export { default as action } from 's' ; export { default as select , SelectorFunction } from 's' ; export { default as createUndo , UndoResult , CreateUndoReturnValue } from 's' ; export { getActionType } from 's' ; export { initializeTestMode , resetTestMode } from 's' ;	O O $void$ O $void$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $ActionFactory$ O $ActionFactory$ O O O O O O $Target$ O $Target$ O $any$ O O O O O O $CreateUndoReturnValue<T>$ O $CreateUndoReturnValue<T>$ O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O
import { wrapThen , wrapCatch } from 's' ; export default function install ( ) { let originalThen = Promise . prototype . then ; let originalCatch = Promise . prototype . catch ; Promise . prototype . then = wrapThen ( originalThen ) ; Promise . prototype . catch = wrapCatch ( originalCatch ) ; return function uninstall ( ) { Promise . prototype . then = originalThen ; Promise . prototype . catch = originalCatch ; } ; }	O O $any$ O $any$ O O O O O O O $void$ O O O O O O $PromiseConstructor$ O $Promise<any>$ O O O O $Promise<any>$ O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O $PromiseConstructor$ O $Promise<any>$ O O O $any$ O O O O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<any>$ O O O O $void$ O O O $PromiseConstructor$ O $Promise<any>$ O O O O O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O $Promise<any>$ O O O O
import LegacyDispatchFunction from 's' ; import ActionFunction from 's' ; import ActionContext from 's' ; import install from 's' ; let actionStack : string [ ] = [ ] ; let isInstalled = false ; let uninstall : ( ) => void ; export function getCurrentAction ( ) { return actionStack . length ? actionStack [ actionStack . length - 0 ] : null ; } export function promiseMiddleware ( next , action , actionType , args , actionContext ) { if ( ! isInstalled ) { uninstall = install ( ) ; isInstalled = true ; } try { actionStack . push ( actionType ) ; return next ( action , actionType , args , actionContext ) ; } finally { actionStack . pop ( ) ; if ( ! actionStack . length ) { uninstall ( ) ; isInstalled = false ; } } }	O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O O $string[]$ O O O O O O O O O $boolean$ O O O O $void$ O O O O O O O O $string$ O O O O $string[]$ O $number$ O $string[]$ O $string[]$ O $number$ O O O O O O O O O $complex$ O $LegacyDispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $boolean$ O O $void$ O $void$ O O O $boolean$ O O O O O O $string[]$ O $number$ O $string$ O O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $string[]$ O $string$ O O O O O O $string[]$ O $number$ O O $void$ O O O $boolean$ O O O O O O
import action from 's' ; import { getCurrentAction } from 's' ; export function wrapThen ( originalThen ) { return function wrappedThen ( onFulfilled ? , onRejected ? ) { return originalThen . call ( this , wrapInAction ( onFulfilled , 's' ) , wrapInAction ( onRejected , 's' ) ) ; } ; } export function wrapCatch ( originalCatch ) { return function wrappedCatch ( onRejected ? ) { return originalCatch . call ( this , wrapInAction ( onRejected , 's' ) ) ; } ; } function wrapInAction ( callback , callbackType ) { let currentAction = getCurrentAction ( ) ; if ( ! currentAction || ! callback ) { return callback ; } let actionName = currentAction + 's' + callbackType ; return function ( ) { let returnValue ; let args = arguments ; action ( actionName ) ( ( ) => { returnValue = callback . apply ( null , args ) ; } ) ( ) ; return returnValue ; } ; }	O $ActionFactory$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $Function$ $Function$ O $Function$ $Function$ O O O $any$ O $any$ O O O $Function$ O $Function$ O O O O $Function$ O $Function$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $Function$ $Function$ O O O $any$ O $any$ O O O $Function$ O $Function$ O O O O O O O O O $Function$ O $Function$ O $string$ O O O $string$ O $string$ O O O O O O $string$ O O $Function$ O O O $Function$ O O O $string$ O $string$ O O O $string$ O O O O O O O $any$ O O $IArguments$ O $IArguments$ O $ActionFactory$ O $string$ O O O O O O $any$ O $Function$ O $any$ O O O $IArguments$ O O O O O O O O $any$ O O O O
export { promiseMiddleware } from 's' ;	O O $complex$ O O O O
import * as React from 's' ; import { SelectorFunction } from 's' ; import { getGlobalContext } from 's' ; import { observer } from 's' ; export interface ReactiveTarget extends React . ClassicComponentClass < any > { nonReactiveComponent ? : React . ComponentClass < any > ; nonReactiveStatelessComponent ? : React . StatelessComponent < any > ; } function setPropAccessors < T > ( props , selector < T > ) { let newProps = { } ; Object . keys ( props ) . forEach ( key => { newProps [ key ] = props [ key ] ; } ) ; Object . keys ( selector ) . forEach ( ( key ) => { let getter = selector [ key as keyof T ] ; if ( typeof newProps [ key ] === typeof undefined ) { Object . defineProperty ( newProps , key , { enumerable : true , get : ( ) => getter . call ( null , newProps ) , } ) ; } } ) ; return newProps ; } function createNewConstructor < T > ( original : React . ComponentClass < any > , selector < T > ) : React . ComponentClass < any > | React . Component < any , any > { if ( ! selector ) { return original ; } return class extends React . Component < any , any > { render ( ) { return React . createElement ( original , setPropAccessors ( this . props , selector ) ) ; } } ; } function createNewFunctionalComponent < T > ( original : React . StatelessComponent < any > , selector < T > ) { if ( ! selector ) { return original ; } return function ( props ) { let newProps = setPropAccessors ( props , selector ) ; return ( < Function > original ) . call ( original , newProps ) ; } ; } function isReactComponent ( target ) { return target && target . prototype && target . prototype . isReactComponent ; } function isFunction ( target ) { return target instanceof Function ; } export default function reactive < T > ( selectorOrComponentClass ? : SelectorFunction < T > | React . ComponentClass < any > ) { if ( isReactComponent ( selectorOrComponentClass ) ) { let componentClass = selectorOrComponentClass as React . ComponentClass < any > ; return observer ( componentClass ) ; } return function < Target extends React . ReactType > ( target ) { if ( getGlobalContext ( ) . legacyTestMode ) { if ( isReactComponent ( target ) ) { return observer ( target as React . ComponentClass < any > ) ; } else if ( isFunction ( target ) ) { return observer ( target as React . StatelessComponent < any > ) ; } return target ; } let newComponent ; if ( isReactComponent ( target ) ) { newComponent = observer ( createNewConstructor ( observer ( target as React . ComponentClass < any > ) , selectorOrComponentClass as SelectorFunction < T > ) as React . ComponentClass < any > ) ; newComponent . nonReactiveComponent = target as React . ComponentClass < any > ; return newComponent ; } else if ( isFunction ( target ) ) { newComponent = observer ( createNewFunctionalComponent ( target as React . StatelessComponent < any > , selectorOrComponentClass as SelectorFunction < T > ) ) ; newComponent . nonReactiveStatelessComponent = target as React . StatelessComponent < any > ; return newComponent ; } return < T > newComponent ; } ; }	O O O $any$ O O O O O $any$ O O O O O O $GlobalContext$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $SelectorFunction$ O $any$ O O O O $any$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $void$ O $string$ O O $any$ O $string$ O O $any$ O $string$ O O O O O $ObjectConstructor$ O $complex$ O $SelectorFunction<T>$ O O $void$ O O $string$ O O O O $complex$ O $SelectorFunction<T>$ O $string$ O O $any$ O O O O O $any$ O $string$ O O O $undefined$ O O $ObjectConstructor$ O $any$ O $any$ O $string$ O O $true$ O O O $any$ O O O O $complex$ O $any$ O O O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $SelectorFunction$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $SelectorFunction<T>$ O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $SelectorFunction<T>$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $SelectorFunction$ O $any$ O O O O O O $SelectorFunction<T>$ O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $SelectorFunction<T>$ O O O O O $FunctionConstructor$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $any$ O O O $any$ O $FunctionConstructor$ O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $Target$ O O O O $GlobalContext$ O O O $boolean$ O O O O $any$ O $Target$ O O O O $any$ O $Target$ O $any$ O $any$ O O O O O O O O O $boolean$ O $Target$ O O O O $any$ O $Target$ O $any$ O $any$ O O O O O O O $Target$ O O O $any$ O O O $any$ O $Target$ O O O $any$ O $any$ O $any$ O $any$ O $Target$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $Target$ O $any$ O $any$ O O O O O $any$ O O O O O $boolean$ O $Target$ O O O $any$ O $any$ O $any$ O $Target$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $Target$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O
export { default as reactive , ReactiveTarget } from 's' ;	O O $any$ O $any$ O $any$ O O O O
import action from 's' ; import ActionFunction from 's' ; import LegacyDispatchFunction from 's' ; import ActionContext from 's' ; export interface ActionHandler { ( ... args : any [ ] ) : Promise < any > | void ; } let handlers : { [ key ] : ActionHandler [ ] } = { } ; export function stitch ( next , action , actionType , args , actionContext ) { let returnValue = next ( action , actionType , args , actionContext ) ; if ( actionType && handlers [ actionType ] ) { handlers [ actionType ] . forEach ( handler => handler . apply ( null , args ) ) ; } return returnValue ; } export function subscribe < T extends ActionHandler > ( actionType , callback : T ) { if ( ! handlers [ actionType ] ) { handlers [ actionType ] = [ ] ; } handlers [ actionType ] . push ( callback ) ; } export function raise < T extends ActionHandler > ( actionType , callback ? : ( actionToExecute : T ) => void ) { console . error ( "s" ) ; let actionToExecute = action ( actionType ) ( ( ) => { } ) ; if ( callback ) { callback ( < T > actionToExecute ) ; } else { actionToExecute ( ) ; } } export function raiseAction < T extends ActionHandler > ( actionType ) : T { return < T > action ( actionType ) ( ( ) => { } ) ; }	O $ActionFactory$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O O $any[]$ O O O O O O $PromiseConstructor$ O O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O O $complex$ O $LegacyDispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O $complex$ O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O $string$ O $complex$ O $string$ O O O $complex$ O $string$ O O $void$ O $ActionHandler$ O $ActionHandler$ O $any$ O O O $IArguments$ O O O O O $complex$ O O O O $void$ O $any$ O $any$ O O $string$ O $T$ O $any$ O O O O O $complex$ O $string$ O O O $complex$ O $string$ O O O O O O $complex$ O $string$ O O $number$ O $T$ O O O O O $void$ O $any$ O $any$ O O $string$ O $void$ O O O $T$ O $any$ O O O O O $Console$ O $void$ O O O O O $void$ O $ActionFactory$ O $string$ O O O O O O O O O O O $void$ O O $void$ O O $any$ O $void$ O O O O O $void$ O O O O O O O $T$ O $any$ O $any$ O O $string$ O O $any$ O O O $any$ O $ActionFactory$ O $string$ O O O O O O O O O O
export { stitch , subscribe , raise , raiseAction } from 's' ;	O O $complex$ O $void$ O $void$ O $T$ O O O O
import ActionFunction from 's' ; import LegacyDispatchFunction from 's' ; import ActionContext from 's' ; let depth = 0 ; export default function trace ( next , action , actionType , args , actionContext ) { log ( 's' + ( actionType ? actionType : 's' ) ) ; try { depth ++ ; return next ( action , actionType , args , actionContext ) ; } finally { depth -- ; } } function log ( message ) { let indentation = new Array ( depth + 0 ) . join ( 's' ) ; console . log ( indentation + message ) ; }	O $any$ O O O O $any$ O O O O $any$ O O O O $number$ O O O O O O $complex$ O $LegacyDispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O $void$ O O O O $string$ O $string$ O O O O O O O $number$ O O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $number$ O O O O O $void$ O $string$ O O O $string$ O O $ArrayConstructor$ O $number$ O O O O $string$ O O O O $Console$ O $void$ O $string$ O $string$ O O O
export { default as trace } from 's' ;	O O $complex$ O $complex$ O O O O
import 's' ; import { action , actionCreator , getPrivateActionId } from 's' ; import * as createActionId from 's' ; import * as dispatcher from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const testAction = actionCreator ( 's' , ( 0 , 0 ) => { return { 0 , 0 , } ; } ) ; let actionMessage = testAction ( 's' , 's' ) ; expect ( actionMessage . 0 ) . toBe ( 's' ) ; expect ( actionMessage . 0 ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const testAction = actionCreator ( 's' ) ; let actionMessage = testAction ( ) ; expect ( actionMessage ) . not . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { spyOn ( createActionId , 's' ) . and . returnValue ( 's' ) ; let actionType = 's' ; const testAction = actionCreator ( actionType ) ; let actionMessage = testAction ( ) ; expect ( ( actionMessage as any ) . type ) . toBe ( actionType ) ; expect ( getPrivateActionId ( actionMessage ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const testAction = actionCreator ( 's' ) ; spyOn ( dispatcher , 's' ) ; testAction ( ) ; expect ( dispatcher . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const testAction = actionCreator ( 's' , ( ) => { return { type : 's' } ; } ) ; expect ( testAction ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { spyOn ( createActionId , 's' ) . and . returnValue ( 's' ) ; const testAction = actionCreator ( 's' ) ; expect ( getPrivateActionId ( testAction ) ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let actionMessage = { } ; const testAction = action ( 's' , ( ) => actionMessage ) ; spyOn ( dispatcher , 's' ) ; testAction ( ) ; expect ( dispatcher . dispatch ) . toHaveBeenCalledWith ( actionMessage ) ; } ) ; } ) ;	O O O O O $TActionCreator$ O $TActionCreator$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O $TActionCreator$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O ${}$ O $TActionCreator$ O O O O O ${}$ O ${}$ O O O $any$ O ${}$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $string$ O O O O ${}$ O $TActionCreator$ O $string$ O O O ${}$ O ${}$ O O O $any$ O O ${}$ O O O O $any$ O O $any$ O $string$ O O $any$ O $any$ O ${}$ O O O $any$ O O O O O O O $any$ O O O O O O O O ${}$ O $TActionCreator$ O O O O $any$ O $any$ O O O O ${}$ O O O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $TActionCreator$ O O O O O O O O O $string$ O O O O O O O $any$ O $complex$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O ${}$ O $TActionCreator$ O O O O $any$ O $any$ O ${}$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O ${}$ O O O O O ${}$ O $TActionCreator$ O O O O O O ${}$ O O $any$ O $any$ O O O O ${}$ O O O $any$ O $any$ O $void$ O O $any$ O ${}$ O O O O O O O O
import 's' ; import applyMiddleware from 's' ; import * as dispatcher from 's' ; import { getGlobalContext , __resetGlobalContext } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { __resetGlobalContext ( ) ; let testMiddleware = jasmine . createSpy ( 's' ) ; applyMiddleware ( testMiddleware ) ; getGlobalContext ( ) . dispatchWithMiddleware ( { } ) ; expect ( testMiddleware ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { __resetGlobalContext ( ) ; let dispatchedActionMessage = { } ; let actualNext ; let actualActionMessage ; applyMiddleware ( ( next , actionMessage ) => { actualNext = next ; actualActionMessage = actionMessage ; } ) ; getGlobalContext ( ) . dispatchWithMiddleware ( dispatchedActionMessage ) ; expect ( actualActionMessage ) . toBe ( dispatchedActionMessage ) ; expect ( actualNext ) . toBe ( dispatcher . finalDispatch ) ; } ) ; it ( 's' , ( ) => { __resetGlobalContext ( ) ; let sequence : string [ ] = [ ] ; spyOn ( dispatcher , 's' ) . and . callFake ( ( ) => { sequence . push ( 's' ) ; } ) ; applyMiddleware ( ( next , actionMessage ) => { sequence . push ( 's' ) ; next ( actionMessage ) ; } , ( next , actionMessage ) => { sequence . push ( 's' ) ; next ( actionMessage ) ; } ) ; getGlobalContext ( ) . dispatchWithMiddleware ( { } ) ; expect ( sequence ) . toEqual ( [ 's' , 's' , 's' ] ) ; } ) ; } ) ;	O O O O $void$ O O O O O O $any$ O O O O O $GlobalContext$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O $GlobalContext$ O O O $DispatchFunction$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $void$ O O O O ${}$ O O O O O $any$ O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $GlobalContext$ O O O $DispatchFunction$ O ${}$ O O $any$ O $any$ O O $any$ O ${}$ O O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O O $any$ O O O O O O O $void$ O O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $string[]$ O $number$ O O O O O O O $void$ O O $any$ O $any$ O O O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O $GlobalContext$ O O O $DispatchFunction$ O O O O O $any$ O $string[]$ O O $any$ O O O O O O O O O O O O O O O O
import 's' ; import createActionId from 's' ; import { __resetGlobalContext } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { __resetGlobalContext ( ) ; expect ( createActionId ( ) ) . toBe ( 's' ) ; expect ( createActionId ( ) ) . toBe ( 's' ) ; expect ( createActionId ( ) ) . toBe ( 's' ) ; } ) ; } ) ;	O O O O $string$ O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O $any$ O $string$ O O O O $any$ O O O O $any$ O $string$ O O O O $any$ O O O O $any$ O $string$ O O O O $any$ O O O O O O O O O O
import 's' ; import getRootStore from 's' ; import createStore from 's' ; import { __resetGlobalContext } from 's' ; describe ( 's' , ( ) => { beforeEach ( function ( ) { __resetGlobalContext ( ) ; } ) ; it ( 's' , ( ) => { let initialState = { testProp : 's' } ; let store = createStore ( 's' , initialState ) ( ) ; expect ( store ) . toEqual ( initialState ) ; expect ( getRootStore ( ) . get ( 's' ) ) . toEqual ( initialState ) ; } ) ; it ( 's' , ( ) => { let initialState = { testProp : 's' } ; let secondaryState = { testProp : 's' } ; createStore ( 's' , initialState ) ( ) ; expect ( ( ) => createStore ( 's' , secondaryState ) ( ) ) . toThrow ( 's' ) ; expect ( getRootStore ( ) . get ( 's' ) ) . toEqual ( initialState ) ; } ) ; } ) ;	O O O O $any$ O O O O $T$ O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O $T$ O O O $complex$ O O O O $any$ O $complex$ O O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O $T$ O O O $complex$ O O O O $any$ O O O O $T$ O O O $complex$ O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $complex$ O O O O O O O O
import 's' ; import * as actionCreator from 's' ; import * as dispatcher from 's' ; import * as globalContext from 's' ; describe ( 's' , ( ) => { let mockGlobalContext ; beforeEach ( ( ) => { mockGlobalContext = { subscriptions : { } , dispatchWithMiddleware : jasmine . createSpy ( 's' ) , inMutator : false , } ; spyOn ( globalContext , 's' ) . and . returnValue ( mockGlobalContext ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; let callback = ( ) => { } ; dispatcher . subscribe ( actionId , callback ) ; expect ( mockGlobalContext . subscriptions [ actionId ] ) . toBeDefined ( ) ; expect ( mockGlobalContext . subscriptions [ actionId ] . length ) . toBe ( 0 ) ; expect ( mockGlobalContext . subscriptions [ actionId ] [ 0 ] ) . toBe ( callback ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; let 0 = ( ) => { } ; let 0 = ( ) => { } ; dispatcher . subscribe ( actionId , 0 ) ; dispatcher . subscribe ( actionId , 0 ) ; expect ( mockGlobalContext . subscriptions [ actionId ] ) . toEqual ( [ 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { let actionMessage = { } ; dispatcher . dispatch ( actionMessage ) ; expect ( mockGlobalContext . dispatchWithMiddleware ) . toHaveBeenCalledWith ( actionMessage ) ; } ) ; it ( 's' , ( ) => { mockGlobalContext . dispatchWithMiddleware = null ; let actionId = 's' ; spyOn ( actionCreator , 's' ) . and . returnValue ( actionId ) ; let callback = jasmine . createSpy ( 's' ) ; mockGlobalContext . subscriptions [ actionId ] = [ callback ] ; dispatcher . dispatch ( { } ) ; expect ( callback ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { mockGlobalContext . inMutator = true ; expect ( ( ) => { dispatcher . dispatch ( { } ) ; } ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let actionMessage = { } ; let actionId = 's' ; spyOn ( actionCreator , 's' ) . and . returnValue ( actionId ) ; let 0 = jasmine . createSpy ( 's' ) ; let 0 = jasmine . createSpy ( 's' ) ; mockGlobalContext . subscriptions [ actionId ] = [ 0 , 0 ] ; dispatcher . finalDispatch ( actionMessage ) ; expect ( 0 ) . toHaveBeenCalledWith ( actionMessage ) ; expect ( 0 ) . toHaveBeenCalledWith ( actionMessage ) ; } ) ; it ( 's' , ( ) => { spyOn ( actionCreator , 's' ) . and . returnValue ( 's' ) ; expect ( ( ) => { dispatcher . finalDispatch ( { } ) ; } ) . not . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; spyOn ( actionCreator , 's' ) . and . returnValue ( actionId ) ; let promise = Promise . resolve ( ) ; let callback = ( ) => promise ; mockGlobalContext . subscriptions [ actionId ] = [ callback ] ; let returnValue = dispatcher . finalDispatch ( { } ) ; expect ( returnValue ) . toBe ( promise ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; spyOn ( actionCreator , 's' ) . and . returnValue ( actionId ) ; let 0 = Promise . resolve ( ) ; let 0 = ( ) => 0 ; let 0 = Promise . resolve ( ) ; let 0 = ( ) => 0 ; mockGlobalContext . subscriptions [ actionId ] = [ 0 , 0 ] ; let aggregatePromise = Promise . resolve ( ) ; spyOn ( Promise , 's' ) . and . returnValue ( aggregatePromise ) ; let returnValue = dispatcher . finalDispatch ( { } ) ; expect ( Promise . all ) . toHaveBeenCalledWith ( [ 0 , 0 ] ) ; expect ( returnValue ) . toBe ( aggregatePromise ) ; } ) ; } ) ;	O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O ${}$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O O O O O O $any$ O $void$ O $string$ O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $void$ O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O O O O O O O $void$ O O O O O O O $any$ O $void$ O $string$ O $void$ O O $any$ O $void$ O $string$ O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $void$ O $void$ O O O O O O $any$ O O O O O O O O ${}$ O O O O $any$ O $void$ O ${}$ O O $any$ O $any$ O $any$ O O $any$ O ${}$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O O $any$ O $void$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $void$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O ${}$ O O O O O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O O $any$ O $complex$ O ${}$ O O $any$ O $any$ O O $any$ O ${}$ O O $any$ O $any$ O O $any$ O ${}$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O O O $Promise<void>$ O $any$ O $any$ O $string$ O O O $Promise<void>$ O O O $complex$ O $any$ O $complex$ O O O O O $any$ O $complex$ O O $any$ O $Promise<void>$ O O O O O $any$ O O O O O O O O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O O O $Promise<void>$ O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O O O $Promise<void>$ O $any$ O $any$ O $string$ O O O $Promise<void>$ O $Promise<void>$ O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O $any$ O $PromiseConstructor$ O O O O $any$ O $any$ O $Promise<void>$ O O O $complex$ O $any$ O $complex$ O O O O O $any$ O $PromiseConstructor$ O O O O $any$ O O $Promise<void>$ O $Promise<void>$ O O O $any$ O $complex$ O O $any$ O $Promise<void>$ O O O O O O O O
import 's' ; import { autorun } from 's' ; import { __resetGlobalContext } from 's' ; import { action , applyMiddleware , createStore , dispatch , mutator , mutatorAction , orchestrator , } from 's' ; describe ( 's' , ( ) => { beforeEach ( function ( ) { __resetGlobalContext ( ) ; } ) ; it ( 's' , ( ) => { let actualValue ; let testAction = action ( 's' , function testAction ( value ) { return { value : value , } ; } ) ; mutator ( testAction , function ( actionMessage ) { actualValue = actionMessage . value ; } ) ; testAction ( 's' ) ; expect ( actualValue ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let 0 ; let 0 ; let testMutatorAction = mutatorAction ( 's' , function testMutatorAction ( 0 , 0 ) { 0 = 0 ; 0 = 0 ; } ) ; testMutatorAction ( 's' , 0 ) ; expect ( 0 ) . toBe ( 's' ) ; expect ( 0 ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { let store = createStore ( 's' , { testProperty : 's' } ) ( ) ; autorun ( ( ) => store . testProperty ) ; let modifyStore = action ( 's' ) ; mutator ( modifyStore , ( ) => { store . testProperty = 's' ; } ) ; modifyStore ( ) ; expect ( store . testProperty ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let store = createStore ( 's' , { testProperty : 's' } ) ( ) ; autorun ( ( ) => store . testProperty ) ; let modifyStore = action ( 's' ) ; orchestrator ( modifyStore , ( ) => { store . testProperty = 's' ; } ) ; expect ( ( ) => { modifyStore ( ) ; } ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let store = createStore ( 's' , { testProperty : 0 } ) ( ) ; let modifyStore = action ( 's' ) ; mutator ( modifyStore , ( ) => { store . testProperty ++ ; } ) ; mutator ( modifyStore , ( ) => { store . testProperty ++ ; } ) ; let values : number [ ] = [ ] ; autorun ( ( ) => { values . push ( store . testProperty ) ; } ) ; modifyStore ( ) ; expect ( values ) . toEqual ( [ 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { let actualValue ; let expectedValue = { type : 's' } ; applyMiddleware ( ( next , actionMessage ) => { actualValue = actionMessage ; next ( actionMessage ) ; } ) ; dispatch ( expectedValue ) ; expect ( actualValue ) . toBe ( expectedValue ) ; } ) ; it ( 's' , async ( ) => { let testAction = action ( 's' ) ; orchestrator ( testAction , ( ) => Promise . resolve ( 0 ) ) ; orchestrator ( testAction , ( ) => Promise . resolve ( 0 ) ) ; let returnedPromise ; applyMiddleware ( ( next , actionMessage ) => { returnedPromise = next ( actionMessage ) ; } ) ; testAction ( ) ; let promiseValues = await returnedPromise ; expect ( promiseValues ) . toEqual ( [ 0 , 0 ] ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O $void$ O O O O O O $TActionCreator$ O $void$ O $T$ O $void$ O $MutatorFunction<T>$ O $T$ O $OrchestratorFunction<T>$ O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O $TActionCreator$ O O O O $complex$ O $string$ O O O O $string$ O $string$ O O O O O O $MutatorFunction<T>$ O $complex$ O O O $complex$ O O $any$ O $complex$ O $string$ O O O O $complex$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $any$ O O O O $T$ O O O O O O $string$ O $number$ O O $any$ O $string$ O $any$ O $number$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $T$ O O O O $string$ O O O O O O O $any$ O O O O $complex$ O $string$ O O O ${}$ O $TActionCreator$ O O O O $MutatorFunction<T>$ O ${}$ O O O O O $complex$ O $string$ O O O O O O ${}$ O O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $T$ O O O O $string$ O O O O O O O $any$ O O O O $complex$ O $string$ O O O ${}$ O $TActionCreator$ O O O O $OrchestratorFunction<T>$ O ${}$ O O O O O $complex$ O $string$ O O O O O O $any$ O O O O O ${}$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $T$ O O O O $number$ O O O O O O O O ${}$ O $TActionCreator$ O O O O $MutatorFunction<T>$ O ${}$ O O O O O $complex$ O $number$ O O O O O $MutatorFunction<T>$ O ${}$ O O O O O $complex$ O $number$ O O O O O O $number[]$ O O O O O O O O $any$ O O O O O $number[]$ O $number$ O $complex$ O $number$ O O O O O ${}$ O O O $any$ O $number[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O O $void$ O O $DispatchFunction$ O $ActionMessage$ O O O $any$ O $ActionMessage$ O $DispatchFunction$ O $ActionMessage$ O O O O O $void$ O $complex$ O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O ${}$ O $TActionCreator$ O O O O $OrchestratorFunction<T>$ O ${}$ O O O O $PromiseConstructor$ O $complex$ O O O O O $OrchestratorFunction<T>$ O ${}$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $void$ O O $DispatchFunction$ O $ActionMessage$ O O O $any$ O $DispatchFunction$ O $ActionMessage$ O O O O O ${}$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O
import 's' ; import { isObservableMap } from 's' ; import { __resetGlobalContext , getGlobalContext , ensureGlobalContextSchemaVersion , } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { __resetGlobalContext ( ) ; } ) ; it ( 's' , ( ) => { getGlobalContext ( ) . schemaVersion = - 0 ; expect ( ensureGlobalContextSchemaVersion ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let rootStore = getGlobalContext ( ) . rootStore ; expect ( isObservableMap ( rootStore ) ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O $void$ O $GlobalContext$ O $void$ O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O O O O O $GlobalContext$ O O O $number$ O O O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $GlobalContext$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O
import 's' ; import action from 's' ; import * as dispatchImports from 's' ; import { getGlobalContext } from 's' ; import { getActionType } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let testFunctionCalled = false ; let testFunction = ( a ) => { testFunctionCalled = true ; } ; spyOn ( dispatchImports , 's' ) . and . callThrough ( ) ; testFunction = action ( 's' ) ( testFunction ) ; testFunction ( 's' ) ; expect ( testFunctionCalled ) . toBeTruthy ( ) ; expect ( dispatchImports . default ) . toHaveBeenCalledTimes ( 0 ) ; expect ( ( < jasmine . Spy > dispatchImports . default ) . calls . argsFor ( 0 ) [ 0 ] ) . toBe ( 's' ) ; expect ( ( < jasmine . Spy > dispatchImports . default ) . calls . argsFor ( 0 ) [ 0 ] . length ) . toBe ( 0 ) ; expect ( ( < jasmine . Spy > dispatchImports . default ) . calls . argsFor ( 0 ) [ 0 ] [ 0 ] ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let testFunction = ( ) => { } ; let actionType = 's' ; let wrappedAction = action ( actionType ) ( testFunction ) ; expect ( getActionType ( wrappedAction ) ) . toBe ( actionType ) ; } ) ; it ( 's' , ( ) => { let passedArguments ; let testFunction = function ( a , b ) { passedArguments = arguments ; } ; testFunction = action ( 's' ) ( testFunction ) ; testFunction ( 0 , 0 ) ; expect ( passedArguments [ 0 ] ) . toEqual ( 0 ) ; expect ( passedArguments [ 0 ] ) . toEqual ( 0 ) ; } ) ; it ( 's' , ( ) => { let originalReturnValue = new Promise < any > ( ( ) => { } ) ; let testFunction = function ( ) { return originalReturnValue ; } ; testFunction = action ( 's' ) ( testFunction ) ; let returnValue = testFunction ( ) ; expect ( returnValue ) . toBe ( originalReturnValue ) ; } ) ; it ( 's' , ( ) => { let thisValue ; let inDispatchValue ; class TestClass { @ action ( 's' ) testMethod ( ) { thisValue = this ; inDispatchValue = getGlobalContext ( ) . legacyInDispatch ; } } let testInstance = new TestClass ( ) ; testInstance . testMethod ( ) ; expect ( thisValue ) . toBe ( testInstance ) ; expect ( inDispatchValue ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { let actionType = 's' ; class TestClass { @ action ( actionType ) testMethod ( ) { } } let testInstance = new TestClass ( ) ; expect ( getActionType ( testInstance . testMethod ) ) . toBe ( actionType ) ; } ) ; } ) ;	O O O O $ActionFactory$ O O O O O O $any$ O O O O O $GlobalContext$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O O O O $void$ O O $string$ O O O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O $ActionFactory$ O O O O $void$ O O $void$ O O O O $any$ O $false$ O O $any$ O O O $any$ O $any$ O $void$ O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $string$ O O O O $void$ O $ActionFactory$ O $string$ O O $void$ O O $any$ O $any$ O $void$ O O O $any$ O $string$ O O O O O $any$ O O O O O O O O $IArguments$ O O $void$ O O O $number$ O $number$ O O $IArguments$ O $IArguments$ O O O $void$ O $ActionFactory$ O O O O $void$ O O $void$ O O O O O O $any$ O $IArguments$ O O O O O $any$ O O O O $any$ O $IArguments$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<any>$ O O $PromiseConstructor$ O O O O O O O O O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O O $Promise<any>$ O $ActionFactory$ O O O O $Promise<any>$ O O O $Promise<any>$ O $Promise<any>$ O O O $any$ O $Promise<any>$ O O $any$ O $Promise<any>$ O O O O O $any$ O O O O O O O O $any$ O O $any$ O O $any$ O O $ActionFactory$ O O O $void$ O O O $any$ O O O $any$ O $GlobalContext$ O O O $number$ O O O O $TestClass$ O O $any$ O O O $TestClass$ O $void$ O O O $any$ O $any$ O O $any$ O $TestClass$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $any$ O O $ActionFactory$ O $string$ O $void$ O O O O O O $TestClass$ O O $any$ O O O $any$ O $any$ O $TestClass$ O $void$ O O O $any$ O $string$ O O O O O O O O
import 's' ; import action from 's' ; import createUndo , { UndoResult } from 's' ; import { extendObservable , observable , _resetGlobalState } from 's' ; import { __resetGlobalContext } from 's' ; function resetState ( ) { _resetGlobalState ( ) ; __resetGlobalContext ( ) ; } describe ( 's' , ( ) => { beforeEach ( resetState ) ; describe ( 's' , ( ) => { beforeEach ( resetState ) ; it ( 's' , ( ) => { let index = 0 ; let newValue = 0 ; let oldValue = 0 ; let array = observable ( [ 0 , oldValue , 0 ] ) ; let undoableAction = action ( 's' ) ( ( ) => { array [ index ] = newValue ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( array [ index ] ) . toBe ( newValue ) ; undoResult ( ) ; expect ( array [ index ] ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let oldValue = 0 ; let object = observable . map ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object . get ( index ) ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . get ( index ) ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let newValue = 0 ; let oldValue = 0 ; let object = observable ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . key = newValue ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object . key ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . key ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let object = observable ( [ 0 , 0 , 0 , 0 , 0 , 0 ] as any [ ] ) ; let undoableAction = action ( 's' ) ( ( ) => { object . splice ( 0 , 0 , 's' ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 's' , 0 ] ) ; undoResult ( ) ; expect ( object . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable . map ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object . get ( index ) ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . has ( index ) ) . toBeFalsy ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { extendObservable ( object , { [ index ] : newValue } ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object [ index ] ) . toBe ( newValue ) ; undoResult ( ) ; expect ( Object . getOwnPropertyNames ( object ) ) . not . toContain ( index ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let oldValue = 0 ; let object = observable . map ( { [ index ] : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . delete ( index ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; expect ( object . has ( index ) ) . toBeFalsy ; undoResult ( ) ; expect ( object . get ( index ) ) . toBe ( oldValue ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( resetState ) ; it ( 's' , ( ) => { let index = 0 ; let newValue = 0 ; let oldValue = 0 ; let array = observable ( [ 0 , oldValue , 0 ] ) ; let undoableAction = action ( 's' ) ( ( ) => { array [ index ] = newValue ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( array [ index ] ) . toBe ( newValue ) ; undoResult ( ) ; expect ( array [ index ] ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let oldValue = 0 ; let object = observable . map ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object . get ( index ) ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . get ( index ) ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let newValue = 0 ; let oldValue = 0 ; let object = observable ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . key = newValue ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object . key ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . key ) . toBe ( oldValue ) ; } ) ; it ( 's' , ( ) => { let object = observable ( [ 0 , 0 , 0 , 0 , 0 , 0 ] as any [ ] ) ; let undoableAction = action ( 's' ) ( ( ) => { object . splice ( 0 , 0 , 's' ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 's' , 0 ] ) ; undoResult ( ) ; expect ( object . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable . map ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object . get ( index ) ) . toBe ( newValue ) ; undoResult ( ) ; expect ( object . has ( index ) ) . toBeFalsy ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { extendObservable ( object , { [ index ] : newValue } ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object [ index ] ) . toBe ( newValue ) ; undoResult ( ) ; expect ( Object . getOwnPropertyNames ( object ) ) . not . toContain ( index ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let oldValue = 0 ; let object = observable . map ( { [ index ] : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . delete ( index ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; expect ( object . has ( index ) ) . toBeFalsy ; undoResult ( ) ; expect ( object . get ( index ) ) . toBe ( oldValue ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( resetState ) ; it ( 's' , ( ) => { let index = 0 ; let newValue = 0 ; let oldValue = 0 ; let array = observable ( [ 0 , oldValue , 0 ] ) ; let undoableAction = action ( 's' ) ( ( ) => { array [ index ] = newValue ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { array [ index ] = 0 ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let oldValue = 0 ; let object = observable . map ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object . set ( index , 0 ) ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let newValue = 0 ; let oldValue = 0 ; let object = observable ( { key : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . key = newValue ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object . key = 0 ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let object = observable ( [ 0 , 0 , 0 , 0 , 0 , 0 ] as any [ ] ) ; let undoableAction = action ( 's' ) ( ( ) => { object . splice ( 0 , 0 , 's' ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object [ 0 ] = 0 ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable . map ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( index , newValue ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object . set ( index , 0 ) ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let newValue = 0 ; let object = observable ( { } ) ; let undoableAction = action ( 's' ) ( ( ) => { extendObservable ( object , { [ index ] : newValue } ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object [ index ] = 0 ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let index = 's' ; let oldValue = 0 ; let object = observable . map ( { [ index ] : oldValue } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . delete ( index ) ; } ) ; let undoResult = createUndo ( 's' , true ) ( undoableAction ) ; action ( 's' ) ( ( ) => { object . set ( index , 0 ) ; } ) ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; } ) ; it ( 's' , ( ) => { let array = observable ( [ 0 , 0 , 0 , 0 , 0 ] ) ; let outerUndo = createUndo ( 's' ) ( action ( 's' ) ( ( ) => { array [ 0 ] = 0 ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; let innerUndo = createUndo ( 's' ) ( action ( 's' ) ( ( ) => { array [ 0 ] = 0 ; } ) ) ; array [ 0 ] = 0 ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; innerUndo ( ) ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; } ) ) ; outerUndo ( ) ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { let object = observable . map ( { key : 0 } ) ; let undoableAction = action ( 's' ) ( ( ) => { object . set ( 's' , 0 ) ; } ) ; let undoResult = createUndo ( 's' ) ( undoableAction ) ; undoResult ( ) ; expect ( undoResult ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let array = observable ( [ 0 , 0 , 0 , 0 , 0 ] ) ; let innerUndo ; let outerUndo = createUndo ( 's' ) ( action ( 's' ) ( ( ) => { array [ 0 ] = 0 ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; innerUndo = createUndo ( 's' ) ( action ( 's' ) ( ( ) => { array [ 0 ] = 0 ; } ) ) ; array [ 0 ] = 0 ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; } ) ) ; outerUndo ( ) ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; innerUndo && innerUndo ( ) ; expect ( array . slice ( 0 ) ) . toEqual ( [ 0 , 0 , 0 , 0 , 0 ] ) ; } ) ; } ) ;	O O O O $ActionFactory$ O O O O $CreateUndoReturnValue<T>$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O $void$ O O O $any$ O O O $void$ O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O O O $number$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $number$ O O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $number$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $number$ O O O $any$ O $number$ O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O O O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $any$ O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O $string$ O O $number$ O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $ObjectConstructor$ O $string[]$ O $any$ O O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O $string$ O O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O O O $number$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $number$ O O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $number$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $number$ O O O $any$ O $number$ O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O O O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $any$ O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O $string$ O O $number$ O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $string$ O O O $any$ O $number$ O O $UndoResult<unknown>$ O O O $any$ O $ObjectConstructor$ O $string[]$ O $any$ O O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O $string$ O O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $number$ O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O O O $number$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $number$ O O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $number$ O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O $number$ O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $number$ O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O $number$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O $string$ O O $number$ O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $string$ O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O $string$ O O $number$ O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O O O $void$ O O $ActionFactory$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $ActionFactory$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $ActionFactory$ O O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $number$ O O O O O O $void$ O $ActionFactory$ O O O O O O O O $any$ O $any$ O O O O O O O O O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $void$ O O $UndoResult<unknown>$ O O O $any$ O $UndoResult<unknown>$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $Function$ O O $UndoResult<unknown>$ O $CreateUndoReturnValue<T>$ O O O O $ActionFactory$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O $Function$ O $CreateUndoReturnValue<T>$ O O O O $ActionFactory$ O O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $UndoResult<unknown>$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O $Function$ O $Function$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O
import 's' ; import { autorun , _resetGlobalState } from 's' ; import getRootStore from 's' ; import dispatch from 's' ; import * as legacyApplyMiddlewareImports from 's' ; import { __resetGlobalContext } from 's' ; var backupConsoleError = console . error ; describe ( 's' , ( ) => { beforeEach ( ( ) => { _resetGlobalState ( ) ; __resetGlobalContext ( ) ; } ) ; beforeAll ( ( ) => { console . error = ( message ) : void => null ; } ) ; afterAll ( ( ) => { console . error = backupConsoleError ; } ) ; it ( 's' , ( ) => { spyOn ( legacyApplyMiddlewareImports , 's' ) ; let originalAction = ( ) => { } ; let originalActionType = 's' ; let originalArguments = < IArguments > { } ; let options = { a : 0 } ; dispatch ( originalAction , originalActionType , originalArguments , options ) ; expect ( legacyApplyMiddlewareImports . dispatchWithMiddleware ) . toHaveBeenCalledWith ( originalAction , originalActionType , originalArguments , options ) ; } ) ; it ( 's' , ( ) => { getRootStore ( ) . set ( 's' , 0 ) ; let count = 0 ; autorun ( ( ) => { getRootStore ( ) . get ( 's' ) ; count ++ ; } ) ; expect ( count ) . toBe ( 0 ) ; legacyApplyMiddlewareImports . default ( ( next , action , actionType , actionContext ) => { getRootStore ( ) . set ( 's' , 0 ) ; next ( action , actionType , null , actionContext ) ; } ) ; dispatch ( ( ) => { getRootStore ( ) . set ( 's' , 0 ) ; } , null , null , null ) ; expect ( count ) . toBe ( 0 ) ; } ) ; } ) ;	O O O O O $any$ O $any$ O O O O O $any$ O O O O $void$ O O O O O O $any$ O O O O O $void$ O O O O O $void$ O $Console$ O $void$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O $void$ O O O O O O $any$ O O O O O $Console$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O $Console$ O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $void$ O O O O O O O O $string$ O O O O $IArguments$ O O $any$ O O O O O $complex$ O O $number$ O O O O $void$ O $void$ O $string$ O $IArguments$ O $complex$ O O $any$ O $any$ O $void$ O O $any$ O $void$ O $string$ O $IArguments$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O $any$ O O O O O O O $number$ O O O $any$ O O O O O $any$ O O O $any$ O O O O $number$ O O O O O $any$ O $number$ O O $any$ O O O O $any$ O $void$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O O O $any$ O O O $any$ O O O O O O $DispatchFunction$ O $ActionFunction$ O $string$ O O O $IArguments$ O O O O O $void$ O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O O O O
import 's' ; import { default as legacyApplyMiddleware , dispatchWithMiddleware , } from 's' ; import ActionFunction from 's' ; import ActionContext from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { legacyApplyMiddleware ( ) ; } ) ; it ( 's' , ( ) => { let actionCalled = false ; let middlewareCalled = false ; legacyApplyMiddleware ( ( next , action , actionType , actionContext ) => { middlewareCalled = true ; next ( action , actionType , null , actionContext ) ; } ) ; dispatchWithMiddleware ( ( ) => { actionCalled = true ; } , null , null , null ) ; expect ( actionCalled ) . toBeTruthy ( ) ; expect ( middlewareCalled ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { var 0 = false ; var 0 = false ; legacyApplyMiddleware ( ( next , action , actionType , actionContext ) => { expect ( 0 ) . toBeFalsy ( ) ; 0 = true ; next ( action , actionType , null , actionContext ) ; } , ( next , action , actionType , actionContext ) => { expect ( 0 ) . toBeTruthy ( ) ; 0 = true ; next ( action , actionType , null , actionContext ) ; } ) ; dispatchWithMiddleware ( ( ) => { } , null , null , null ) ; expect ( 0 ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let originalAction = ( ) => { } ; let originalActionType = 's' ; let originalArguments = < IArguments > { } ; let originalOptions = { a : 0 } ; var passedAction ; var passedActionType ; var passedArguments ; var passedOptions ; legacyApplyMiddleware ( ( next , action , actionType , args , actionContext ) => { passedAction = action ; passedActionType = actionType ; passedArguments = args ; passedOptions = actionContext ; } ) ; dispatchWithMiddleware ( originalAction , originalActionType , originalArguments , originalOptions ) ; expect ( passedAction ) . toBe ( originalAction ) ; expect ( passedActionType ) . toBe ( originalActionType ) ; expect ( passedArguments ) . toBe ( originalArguments ) ; expect ( passedOptions ) . toBe ( originalOptions ) ; } ) ; it ( 's' , ( ) => { let originalReturnValue = Promise . resolve ( { } ) ; let originalAction = ( ) => { return originalReturnValue ; } ; let receivedReturnValue : Promise < any > | void ; legacyApplyMiddleware ( ( next , action , actionType , args , actionContext ) => { receivedReturnValue = next ( action , actionType , args , actionContext ) ; } ) ; dispatchWithMiddleware ( originalAction , null , null , null ) ; expect ( receivedReturnValue ) . toBe ( originalReturnValue ) ; } ) ; } ) ;	O O O O O $void$ O $void$ O $void$ O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O O O O O O $boolean$ O O O O $boolean$ O O O $void$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O O O $boolean$ O O O $DispatchFunction$ O $ActionFunction$ O $string$ O O O $IArguments$ O O O O O $void$ O O O O O $boolean$ O O O O O O O O O O O O $any$ O $false$ O O $any$ O O O $any$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O $boolean$ O O O O $boolean$ O O O $void$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O O O $any$ O $boolean$ O O $any$ O O O $boolean$ O O O $DispatchFunction$ O $ActionFunction$ O $string$ O O O $IArguments$ O O O O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O O O $any$ O $boolean$ O O $any$ O O O $boolean$ O O O $DispatchFunction$ O $ActionFunction$ O $string$ O O O $IArguments$ O O O O O $void$ O O O O O O O O O O O O O O $any$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $string$ O O O O $IArguments$ O O $any$ O O O O O $complex$ O O $number$ O O O O O $ActionFunction$ O O $string$ O O $IArguments$ O O $ActionContext$ O $void$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O $ActionFunction$ O $ActionFunction$ O $string$ O $string$ O $IArguments$ O $IArguments$ O $ActionContext$ O $ActionContext$ O O O O $void$ O $void$ O $string$ O $IArguments$ O $complex$ O O $any$ O $ActionFunction$ O O $any$ O $void$ O O $any$ O $string$ O O $any$ O $string$ O O $any$ O $IArguments$ O O $any$ O $IArguments$ O O $any$ O $ActionContext$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O O O O O $Promise<{}>$ O O O O O O $Promise<{}>$ O O O O $complex$ O $PromiseConstructor$ O O O O O O $void$ O O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O $complex$ O $DispatchFunction$ O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O $void$ O $Promise<{}>$ O O O O O O O O $any$ O $complex$ O O $any$ O $Promise<{}>$ O O O O O O O O
import 's' ; import * as actionImports from 's' ; import * as promiseMiddleware from 's' ; import { wrapThen , wrapCatch } from 's' ; describe ( 's' , ( ) => { let originalThenSpy : jasmine . Spy ; let originalCatchSpy : jasmine . Spy ; let getCurrentActionSpy : jasmine . Spy ; beforeEach ( ( ) => { spyOn ( actionImports , 's' ) . and . returnValue ( ( callback ) => callback ) ; getCurrentActionSpy = spyOn ( promiseMiddleware , 's' ) ; originalThenSpy = jasmine . createSpy ( 's' ) ; originalCatchSpy = jasmine . createSpy ( 's' ) ; } ) ; it ( 's' , ( ) => { wrapThen ( originalThenSpy ) ( null , null ) ; wrapCatch ( originalCatchSpy ) ( null ) ; expect ( originalThenSpy ) . toHaveBeenCalledWith ( null , null ) ; expect ( originalCatchSpy ) . toHaveBeenCalledWith ( null ) ; } ) ; it ( 's' , ( ) => { getCurrentActionSpy . and . returnValue ( 's' ) ; let onFulfilled = jasmine . createSpy ( 's' ) ; let onRejectedInThen = jasmine . createSpy ( 's' ) ; wrapThen ( originalThenSpy ) ( onFulfilled , onRejectedInThen ) ; let onRejectedInCatch = jasmine . createSpy ( 's' ) ; wrapCatch ( originalCatchSpy ) ( onRejectedInCatch ) ; fulfillPromise ( ) ; expect ( actionImports . default ) . toHaveBeenCalledWith ( 's' ) ; expect ( onFulfilled ) . toHaveBeenCalled ( ) ; rejectPromiseInThen ( ) ; expect ( actionImports . default ) . toHaveBeenCalledWith ( 's' ) ; expect ( onRejectedInThen ) . toHaveBeenCalled ( ) ; rejectPromiseInCatch ( ) ; expect ( actionImports . default ) . toHaveBeenCalledWith ( 's' ) ; expect ( onRejectedInCatch ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { getCurrentActionSpy . and . returnValue ( 's' ) ; let onFulfilled = jasmine . createSpy ( 's' ) . and . returnValue ( 's' ) ; wrapThen ( originalThenSpy ) ( onFulfilled , null ) ; let returnValue = fulfillPromise ( 's' ) ; expect ( returnValue ) . toBe ( 's' ) ; expect ( onFulfilled ) . toHaveBeenCalledWith ( 's' ) ; } ) ; function fulfillPromise ( arg ? ) { return originalThenSpy . calls . argsFor ( 0 ) [ 0 ] ( arg ) ; } function rejectPromiseInThen ( arg ? ) { return originalThenSpy . calls . argsFor ( 0 ) [ 0 ] ( arg ) ; } function rejectPromiseInCatch ( arg ? ) { return originalCatchSpy . calls . argsFor ( 0 ) [ 0 ] ( arg ) ; } } ) ;	O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $Function$ O O $Function$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $ActionFactory$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $ActionFactory$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $ActionFactory$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O
import 's' ; import { autorun } from 's' ; import { action , legacyApplyMiddleware } from 's' ; import { createStore } from 's' ; import { getCurrentAction , promiseMiddleware } from 's' ; import { __resetGlobalContext } from 's' ; let testAction = action ( 's' ) ( function testAction ( store , newValue ) { return Promise . resolve ( newValue ) . then ( value => { store . testValue = value ; store . currentAction = getCurrentAction ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( function ( ) { __resetGlobalContext ( ) ; } ) ; it ( 's' , done => { legacyApplyMiddleware ( promiseMiddleware ) ; let store = createStore ( 's' , { testValue : 0 , currentAction : null } ) ( ) ; let newValue = 0 ; observeStore ( store ) ; testAction ( store , newValue ) . then ( ( ) => { expect ( store . testValue ) . toBe ( newValue ) ; expect ( store . currentAction ) . toBe ( 's' ) ; expect ( getCurrentAction ( ) ) . toBe ( null ) ; done ( ) ; } ) . catch ( error => { fail ( 's' + error ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { legacyApplyMiddleware ( ) ; let store = createStore ( 's' , { testValue : null } ) ( ) ; let newValue = { } ; observeStore ( store ) ; testAction ( store , newValue ) . then ( ( ) => { fail ( 's' ) ; done ( ) ; } ) . catch ( error => { expect ( store . testValue ) . not . toBe ( newValue ) ; done ( ) ; } ) ; } ) ; } ) ; function observeStore ( store ) { autorun ( ( ) => { store . testValue ; } ) ; }	O O O O O $any$ O O O O O O $ActionFactory$ O $void$ O O O O O O $T$ O O O O O O $string$ O $complex$ O O O O O O $void$ O O O O O $Promise<any>$ O $ActionFactory$ O O O O O $Promise<any>$ O $any$ O $any$ O O O $PromiseConstructor$ O $complex$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O $any$ O O $void$ O $complex$ O O O $complex$ O $T$ O O O O $number$ O O O $null$ O O O O O O O O $number$ O O O $void$ O $complex$ O O $Promise<any>$ O $complex$ O $number$ O O O O O O O O $any$ O $complex$ O $number$ O O $any$ O $number$ O O $any$ O $complex$ O $any$ O O $any$ O O O O $any$ O $string$ O O O O $any$ O O O O $any$ O O O O O O $complex$ O $any$ O O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O O $any$ O O $void$ O O O O $complex$ O $T$ O O O O $null$ O O O O O O O O ${}$ O O O O $void$ O $complex$ O O $Promise<any>$ O $complex$ O ${}$ O O O O O O O O $any$ O O O O $any$ O O O O O O $complex$ O $any$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O ${}$ O O $any$ O O O O O O O O O O O O O $void$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O
import 's' ; import * as actionWrappers from 's' ; import install from 's' ; describe ( 's' , ( ) => { let originalThen = Promise . prototype . then ; let originalCatch = Promise . prototype . catch ; let wrappedThen = ( ) => { } ; let wrappedCatch = ( ) => { } ; it ( 's' , ( ) => { try { setupPromise ( ) ; install ( ) ; expect ( Promise . prototype . then ) . toBe ( wrappedThen ) ; expect ( Promise . prototype . catch ) . toBe ( wrappedCatch ) ; } finally { resetPromise ( ) ; } } ) ; it ( 's' , ( ) => { try { setupPromise ( ) ; let uninstall = install ( ) ; uninstall ( ) ; expect ( Promise . prototype . then ) . toBe ( originalThen ) ; expect ( Promise . prototype . catch ) . toBe ( originalCatch ) ; } finally { resetPromise ( ) ; } } ) ; function setupPromise ( ) { spyOn ( actionWrappers , 's' ) . and . returnValue ( wrappedThen ) ; spyOn ( actionWrappers , 's' ) . and . returnValue ( wrappedCatch ) ; } function resetPromise ( ) { Promise . prototype . then = originalThen ; Promise . prototype . catch = originalCatch ; } } ) ;	O O O O O O $any$ O O O O $void$ O O O $any$ O O O O O O O O O O $PromiseConstructor$ O $Promise<any>$ O O O O $Promise<any>$ O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O O $void$ O O O O O O O O $void$ O O O O O O O $any$ O O O O O O O O O $void$ O O O $void$ O O O $any$ O $PromiseConstructor$ O $Promise<any>$ O O O O $any$ O $void$ O O $any$ O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O O $any$ O $void$ O O O O O $void$ O O O O O O O $any$ O O O O O O O O O $void$ O O O O $void$ O $void$ O O O $void$ O O O $any$ O $PromiseConstructor$ O $Promise<any>$ O O O O $any$ O O O O $any$ O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O O $any$ O $Promise<any>$ O O O O O $void$ O O O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O O O $void$ O O O $PromiseConstructor$ O $Promise<any>$ O O O O O $PromiseConstructor$ O $Promise<any>$ O $Promise<any>$ O $Promise<any>$ O O O O O
import 's' ; import { getCurrentAction , promiseMiddleware } from 's' ; import * as install from 's' ; describe ( 's' , ( ) => { let uninstallSpy : jasmine . Spy ; beforeEach ( ( ) => { uninstallSpy = jasmine . createSpy ( 's' ) ; spyOn ( install , 's' ) . and . returnValue ( uninstallSpy ) ; } ) ; it ( 's' , ( ) => { let next = ( ) => { expect ( install . default ) . toHaveBeenCalled ( ) ; expect ( uninstallSpy ) . not . toHaveBeenCalled ( ) ; } ; promiseMiddleware ( next , null , null , null , null ) ; expect ( uninstallSpy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { let outerNext = ( ) => { let innerNext = ( ) => { expect ( uninstallSpy ) . not . toHaveBeenCalled ( ) ; } ; promiseMiddleware ( innerNext , null , null , null , null ) ; expect ( uninstallSpy ) . not . toHaveBeenCalled ( ) ; } ; promiseMiddleware ( outerNext , null , null , null , null ) ; expect ( uninstallSpy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { let originalAction = ( ) => { } ; let originalActionType = 's' ; let originalArguments = < IArguments > { } ; let originalActionContext = { a : 0 } ; let next = jasmine . createSpy ( 's' ) ; promiseMiddleware ( next , originalAction , originalActionType , originalArguments , originalActionContext ) ; expect ( next ) . toHaveBeenCalledWith ( originalAction , originalActionType , originalArguments , originalActionContext ) ; } ) ; it ( 's' , ( ) => { let actionType = 's' ; let currentAction ; let next = ( ) => { currentAction = getCurrentAction ( ) ; } ; promiseMiddleware ( next , null , actionType , null , null ) ; expect ( currentAction ) . toBe ( actionType ) ; } ) ; it ( 's' , ( ) => { let outerAction = 's' ; let innerAction = 's' ; let currentActionValues : string [ ] = [ ] ; let outerNext = ( ) => { currentActionValues . push ( getCurrentAction ( ) ) ; let innerNext = ( ) => { currentActionValues . push ( getCurrentAction ( ) ) ; } ; promiseMiddleware ( innerNext , null , innerAction , null , null ) ; currentActionValues . push ( getCurrentAction ( ) ) ; } ; promiseMiddleware ( outerNext , null , outerAction , null , null ) ; expect ( currentActionValues ) . toEqual ( [ outerAction , innerAction , outerAction ] ) ; } ) ; } ) ;	O O O O O $string$ O $complex$ O O O O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $void$ O O O O O $any$ O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $complex$ O $void$ O O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $void$ O O O O O O $void$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $complex$ O $void$ O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $complex$ O $void$ O O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $string$ O O O O $IArguments$ O O $any$ O O O O O $complex$ O O $number$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $void$ O $string$ O $IArguments$ O $complex$ O O $any$ O $any$ O O $any$ O $void$ O $string$ O $IArguments$ O $complex$ O O O O O $any$ O O O O O O O O $string$ O O O O $any$ O O $void$ O O O O O $any$ O $string$ O O O O O $complex$ O $void$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $string$ O O O O $string[]$ O O O O O O O O O $void$ O O O O O $string[]$ O $number$ O $string$ O O O O O $void$ O O O O O $string[]$ O $number$ O $string$ O O O O O O $complex$ O $void$ O O O $string$ O O O O O O $string[]$ O $number$ O $string$ O O O O O O $complex$ O $void$ O O O $string$ O O O O O O $any$ O $string[]$ O O $any$ O O $string$ O $string$ O $string$ O O O O O O O O O
import 's' ; import action from 's' ; import select from 's' ; import createStore from 's' ; import { initializeTestMode , resetTestMode } from 's' ; import { getActionType } from 's' ; import { __resetGlobalContext } from 's' ; describe ( 's' , ( ) => { beforeEach ( function ( ) { __resetGlobalContext ( ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { 0 : 's' , 0 : { 0 : 's' , 0 : 's' , } , 0 : [ 's' , 's' ] , } ) ( ) ; interface ReadOnlyActionState { 0 : string ; 0 : string ; 0 : any ; 0 : string [ ] ; 0 : string ; } let readOnlyAction = jasmine . createSpy ( 's' , action ( 's' ) ( ( state ? ) => { expect ( state . 0 ) . toBe ( fooStore . 0 ) ; expect ( state . 0 ) . toBe ( fooStore . 0 . 0 ) ; expect ( state . 0 ) . toBe ( fooStore . 0 ) ; expect ( state . 0 ) . toBe ( fooStore . 0 ) ; expect ( state . 0 ) . toBe ( fooStore . 0 [ 0 ] ) ; } ) ) ; let newAction = select ( { 0 : ( ) => fooStore . 0 , 0 : ( ) => fooStore . 0 . 0 , 0 : ( ) => fooStore . 0 , 0 : ( ) => fooStore . 0 , 0 : ( ) => fooStore . 0 [ 0 ] , } ) ( readOnlyAction ) ; newAction ( ) ; expect ( readOnlyAction ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { 0 : 's' , 0 : [ 's' , 's' , 's' ] , } ) ( ) ; let readAction = action ( 's' ) ( function readAction ( id , arrayIndex , state ? ) { expect ( state . value ) . toBe ( 's' ) ; expect ( state . arrayValue ) . toBe ( 's' ) ; } ) ; let newAction = select ( { value : ( id , arrayIndex ) => fooStore [ id ] , arrayValue : ( id , arrayIndex ) => fooStore . 0 [ arrayIndex ] , } ) ( readAction ) ; newAction ( 's' , 0 ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { key : 's' , } ) ( ) ; let someAction = action ( 's' ) ( ( required , optional ? , state ? ) => { expect ( state . key ) . toBe ( 's' ) ; expect ( optional ) . not . toBeDefined ( ) ; expect ( required ) . toBe ( 's' ) ; } ) ; let newAction = select ( { key : ( ) => fooStore . key , } ) ( someAction ) ; newAction ( 's' ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { key : 's' , } ) ( ) ; let functionIsCalled = false ; let someAction = select ( { key : ( ) => fooStore . key , } ) ( ( required , optional ? , state ? ) => { expect ( state . key ) . toBe ( 's' ) ; expect ( optional ) . not . toBeDefined ( ) ; expect ( required ) . toBe ( 's' ) ; functionIsCalled = true ; } ) ; let newAction = action ( 's' ) ( someAction ) ; newAction ( 's' ) ; expect ( functionIsCalled ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { key : 's' , } ) ( ) ; let someAction = select ( { key : ( ) => fooStore . key , } ) ( ( required , optional ? , state ? ) => { expect ( state . key ) . toBe ( 's' ) ; expect ( optional ) . toBe ( 's' ) ; expect ( required ) . toBe ( 's' ) ; } ) ; let newAction = action ( 's' ) ( someAction ) ; newAction ( 's' , 's' , { key : 's' } ) ; } ) ; it ( 's' , ( ) => { let fooStore = createStore ( 's' , { k : 's' , } ) ( ) ; interface ActionState { key : string ; } let updateAction = action ( 's' ) ( ( state ? ) => { expect ( state . key ) . toBe ( fooStore . k ) ; } ) ; let newAction = select < ActionState > ( { key : ( ) => fooStore . k , } ) ( updateAction ) ; newAction ( ) ; } ) ; it ( 's' , ( ) => { initializeTestMode ( ) ; let fooSelector = jasmine . createSpy ( 's' ) ; let actionSpy = jasmine . createSpy ( 's' ) ; select ( { foo : fooSelector , } ) ( actionSpy ) ( ) ; expect ( fooSelector ) . not . toHaveBeenCalled ( ) ; expect ( actionSpy ) . toHaveBeenCalled ( ) ; resetTestMode ( ) ; } ) ; it ( 's' , ( ) => { initializeTestMode ( ) ; resetTestMode ( ) ; let fooSelector = jasmine . createSpy ( 's' ) . and . returnValue ( 's' ) ; let action = ( state ? ) => { expect ( state . foo ) . toBe ( 's' ) ; } ; select ( { foo : fooSelector , } ) ( action ) ( ) ; expect ( fooSelector ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { let actionName = 's' ; let testAction = action ( actionName ) ( ( ) => { } ) ; let wrappedAction = select ( { } ) ( testAction ) ; expect ( getActionType ( wrappedAction ) ) . toBe ( actionName ) ; } ) ; it ( 's' , ( ) => { let store = { foo : 's' , bar : 0 , } ; let wrapped = select ( { foo : ( ) => store . foo , bar : ( ) => store . bar , } ) ( ( state : typeof store ) => { state . foo = 's' ; } ) ; expect ( wrapped ) . toThrow ( ) ; } ) ; } ) ;	O O O O $ActionFactory$ O O O O $Target$ O O O O $T$ O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O O O O O O O O O O $T$ O O O O $string$ O O O O O O $string$ O O O $string$ O O O O O $string[]$ O O O O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $any$ O O O $string[]$ O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O $ActionFactory$ O O O O O $ReadOnlyActionState$ $ReadOnlyActionState$ O O O $any$ O $ReadOnlyActionState$ O $string$ O O $any$ O O O $string$ O O $any$ O $ReadOnlyActionState$ O $string$ O O $any$ O O O O O $string$ O O $any$ O $ReadOnlyActionState$ O $any$ O O $any$ O O O O O O $any$ O $ReadOnlyActionState$ O $string[]$ O O $any$ O O O $string[]$ O O $any$ O $ReadOnlyActionState$ O $string$ O O $any$ O O O $string[]$ O O O O O O O O O O $any$ O $Target$ O O $string$ O O O O O O $string$ O $string$ O O O O O O O O $string$ O O O O O O O O O O $string[]$ O O O O O O $string[]$ O $string$ O O O O O O $string[]$ O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $T$ O O O O $string$ O O O $string[]$ O O O O O O O O O O O O O O O $void$ O $ActionFactory$ O O O O O $void$ O $string$ O $number$ O $any$ $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $void$ O $Target$ O O $any$ O O $string$ O $number$ O O $any$ O $string$ O O $any$ O O $string$ O $number$ O O $any$ O $any$ O $number$ O O O O O $void$ O O $void$ O O O O O O O O O $any$ O O O O O O O O $any$ O $T$ O O O O $string$ O O O O O O O O O $void$ O $ActionFactory$ O O O O O $string$ O $string$ $string$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $string$ O O $any$ O $any$ O O O $any$ O $string$ O O $any$ O O O O O O O O $void$ O $Target$ O O $any$ O O O O $any$ O $any$ O O O O $void$ O O $void$ O O O O O O O $any$ O O O O O O O O $any$ O $T$ O O O O $string$ O O O O O O O O O $boolean$ O O O O $void$ O $Target$ O O $any$ O O O O $any$ O $any$ O O O O O $string$ O $string$ $string$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $string$ O O $any$ O $any$ O O O $any$ O $string$ O O $any$ O O O O $boolean$ O O O O O O O $void$ O $ActionFactory$ O O O O $void$ O O $void$ O O O O $any$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $T$ O O O O $string$ O O O O O O O O O $void$ O $Target$ O O $any$ O O O O $any$ O $any$ O O O O O $string$ O $string$ $string$ O $any$ $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O O $void$ O $ActionFactory$ O O O O $void$ O O $void$ O O O O O O $string$ O O O O O O O O $any$ O O O O O O O O $complex$ O $T$ O O O O $string$ O O O O O O O O O $any$ O $string$ O O O O O $void$ O $ActionFactory$ O O O O O $ActionState$ $ActionState$ O O O $any$ O $ActionState$ O $string$ O O $any$ O $complex$ O $string$ O O O O O O $void$ O $Target$ O $any$ O O O $string$ O O O O $complex$ O $string$ O O O O $void$ O O $void$ O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $Target$ O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $void$ O O O O O O $any$ O O O O O O O $void$ O O O $void$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $void$ O O $any$ $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $Target$ O O $any$ O $any$ O O O O $void$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O $ActionFactory$ O $string$ O O O O O O O O O O $void$ O $Target$ O O O O O $void$ O O $any$ O $any$ O $void$ O O O $any$ O $string$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O O O O $void$ O $Target$ O O $string$ O O O O $complex$ O $string$ O $number$ O O O O $complex$ O $number$ O O O O O $complex$ O O $complex$ O O O $complex$ O $string$ O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O
import 's' ; import * as actionImport from 's' ; import { raiseAction } from 's' ; interface TestActionType { ( 0 , 0 ) : void ; } describe ( 's' , ( ) => { it ( 's' , ( ) => { let createdAction = jasmine . createSpy ( 's' ) ; spyOn ( actionImport , 's' ) . and . returnValue ( ( rawAction ) => createdAction ) ; raiseAction < TestActionType > ( 's' ) ( 's' , 's' ) ; expect ( actionImport . default ) . toHaveBeenCalledWith ( 's' ) ; expect ( createdAction ) . toHaveBeenCalledWith ( 's' , 's' ) ; } ) ; } ) ;	O O O O O O $any$ O O O O O $T$ O O O O O $any$ O O $string$ O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $Function$ O O $any$ O O $T$ O $any$ O O O O O O O O O O $any$ O $any$ O $ActionFactory$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O
import 's' ; import * as actionImports from 's' ; import { raise } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { spyOn ( console , 's' ) ; } ) ; it ( 's' , ( ) => { spyOn ( actionImports , 's' ) . and . returnValue ( ( rawAction ) => rawAction ) ; raise ( 's' ) ; expect ( actionImports . default ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , ( ) => { let actionToCreate = ( ) => { } ; let passedAction ; spyOn ( actionImports , 's' ) . and . returnValue ( ( rawAction ) => actionToCreate ) ; raise ( 's' , actionToExecute => { passedAction = actionToExecute ; } ) ; expect ( passedAction ) . toBe ( actionToCreate ) ; } ) ; it ( 's' , ( ) => { let actionExecuted = false ; let actionToCreate = ( ) => { actionExecuted = true ; } ; spyOn ( actionImports , 's' ) . and . returnValue ( ( rawAction ) => actionToCreate ) ; raise ( 's' ) ; expect ( actionExecuted ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O $any$ O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $Console$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $Function$ O O $Function$ O O $void$ O O O O $any$ O $any$ O $ActionFactory$ O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $Function$ O $any$ O $any$ O O O O $any$ O $any$ O O $Function$ O O $void$ O O $void$ O O O $ActionHandler$ O O $Function$ O $ActionHandler$ O O O O $any$ O $Function$ O O $any$ O $void$ O O O O O $any$ O O O O O O O O $boolean$ O O O O $void$ O O O O O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $Function$ O O $void$ O O $void$ O O O O $any$ O $false$ O O $any$ O O O O O O O O O
import 's' ; import { LegacyDispatchFunction , ActionContext } from 's' ; import { stitch , subscribe } from 's' ; let sequenceOfEvents : any [ ] ; describe ( 's' , ( ) => { beforeAll ( ( ) => { subscribe ( 's' , args => { sequenceOfEvents . push ( 's' ) ; sequenceOfEvents . push ( args ) ; } ) ; } ) ; beforeEach ( ( ) => { sequenceOfEvents = [ ] ; } ) ; it ( 's' , ( ) => { let actionType = 's' ; let args = < IArguments > { } ; let actionContext = { } ; stitch ( getNext ( ) , ( ) => { } , actionType , args , actionContext ) ; expect ( sequenceOfEvents [ 0 ] ) . toEqual ( { actionType , args , } ) ; } ) ; it ( 's' , ( ) => { let originalReturnValue = Promise . resolve ( { } ) ; let returnValue = stitch ( getNext ( originalReturnValue ) , null , null , null , null ) ; expect ( returnValue ) . toBe ( originalReturnValue ) ; } ) ; it ( 's' , ( ) => { stitch ( getNext ( ) , ( ) => { } , 's' , null , null ) ; expect ( sequenceOfEvents ) . toContain ( 's' ) ; } ) ; it ( "s" , ( ) => { let 0 = { } ; let args = getArguments ( 0 ) ; stitch ( getNext ( ) , ( ) => { } , 's' , args , null ) ; expect ( sequenceOfEvents ) . toContain ( 's' ) ; expect ( sequenceOfEvents ) . toContain ( 0 ) ; } ) ; it ( "s" , ( ) => { stitch ( getNext ( ) , ( ) => { } , 's' , null , null ) ; expect ( sequenceOfEvents ) . not . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { stitch ( getNext ( ) , ( ) => { } , null , null , null ) ; expect ( sequenceOfEvents ) . not . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { let actionType = 's' ; let args = getArguments ( { } ) ; stitch ( getNext ( ) , ( ) => { } , actionType , args , null ) ; expect ( sequenceOfEvents ) . toEqual ( [ { actionType , args , } , 's' , args [ 0 ] , ] ) ; } ) ; } ) ; function getNext ( returnValue ? < any > ) { return ( action , actionType , args ) => { sequenceOfEvents . push ( { actionType , args , } ) ; return returnValue ; } ; } function getArguments ( 0 ) { return arguments ; }	O O O O O $any$ O $any$ O O O O O O $complex$ O $void$ O O O O O $any[]$ O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O $any$ O O $any[]$ O $number$ O O O O $any[]$ O $number$ O $any$ O O O O O O O O $any$ O O O O O $any[]$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $IArguments$ O O $any$ O O O O O $ActionContext$ O O O O $complex$ O $DispatchFunction$ O O O O O O O O O $string$ O $IArguments$ O $ActionContext$ O O $any$ O $any[]$ O O O O O $any$ O O $string$ O $IArguments$ O O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O O O O O $complex$ O $complex$ O $DispatchFunction$ O $Promise<{}>$ O O O O O O O O O O O $any$ O $complex$ O O $any$ O $Promise<{}>$ O O O O O $any$ O O O O O O O $complex$ O $DispatchFunction$ O O O O O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O ${}$ O O O O O $IArguments$ O O O ${}$ O O $complex$ O $DispatchFunction$ O O O O O O O O O O O $IArguments$ O O O O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O $any$ O ${}$ O O O O O $any$ O O O O O O O $complex$ O $DispatchFunction$ O O O O O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $DispatchFunction$ O O O O O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $IArguments$ O O O O O O O $complex$ O $DispatchFunction$ O O O O O O O O O $string$ O $IArguments$ O O O O $any$ O $any[]$ O O $any$ O O O $string$ O $IArguments$ O O O O O $IArguments$ O O O O O O O O O O O O O O $LegacyDispatchFunction$ O $Promise<any>$ $Promise$ O O O O O O O $ActionFunction$ O $string$ O $IArguments$ O O O $any[]$ O $number$ O O $string$ O $IArguments$ O O O O O $Promise<any>$ O O O O O O O $any$ O O O $IArguments$ O O
import 's' ; import trace from 's' ; import { ActionContext } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { spyOn ( console , 's' ) ; } ) ; it ( 's' , ( ) => { let originalAction = ( ) => { } ; let originalActionType = 's' ; let originalArguments = < IArguments > { } ; let originalActionContext = { a : 0 } ; let passedAction ; let passedActionType ; let passedArguments ; let passedActionContext ; trace ( ( action , actionType , args , actionContext ) => { passedAction = action ; passedActionType = actionType ; passedArguments = args ; passedActionContext = actionContext ; } , originalAction , originalActionType , originalArguments , originalActionContext ) ; expect ( passedAction ) . toBe ( originalAction ) ; expect ( passedActionType ) . toBe ( originalActionType ) ; expect ( passedArguments ) . toBe ( originalArguments ) ; expect ( passedActionContext ) . toBe ( originalActionContext ) ; } ) ; it ( 's' , ( ) => { let originalReturnValue = Promise . resolve ( { } ) ; let returnValue = trace ( ( action , actionType , args , actionContext ) => { return originalReturnValue ; } , null , null , null , null ) ; expect ( returnValue ) . toBe ( originalReturnValue ) ; } ) ; it ( 's' , ( ) => { trace ( ( action , actionType , args , actionContext ) => { } , null , 's' , null , null ) ; expect ( console . log ) . toHaveBeenCalledTimes ( 0 ) ; expect ( ( < jasmine . Spy > console . log ) . calls . argsFor ( 0 ) [ 0 ] ) . toMatch ( "s" ) ; } ) ; it ( 's' , ( ) => { trace ( ( action , actionType , args , actionContext ) => { } , null , null , null , null ) ; expect ( console . log ) . toHaveBeenCalledTimes ( 0 ) ; expect ( ( < jasmine . Spy > console . log ) . calls . argsFor ( 0 ) [ 0 ] ) . toMatch ( "s" ) ; } ) ; it ( 's' , ( ) => { let next = ( ) => { trace ( ( ) => { } , null , 's' , null , null ) ; } ; trace ( next , null , 's' , null , null ) ; let logCalls = ( < jasmine . Spy > console . log ) . calls ; expect ( logCalls . argsFor ( 0 ) [ 0 ] ) . toBe ( 's' ) ; expect ( logCalls . argsFor ( 0 ) [ 0 ] ) . toMatch ( 's' ) ; } ) ; it ( 's' , ( ) => { let next = ( ) => { trace ( ( ) => { throw new Error ( ) ; } , null , 's' , null , null ) ; } ; try { trace ( next , null , 's' , null , null ) ; } catch ( ex ) { } trace ( ( ) => { } , null , 's' , null , null ) ; expect ( ( < jasmine . Spy > console . log ) . calls . argsFor ( 0 ) [ 0 ] ) . toBe ( 's' ) ; } ) ; } ) ;	O O O O $complex$ O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $Console$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $string$ O O O O $IArguments$ O O $any$ O O O O O $complex$ O O $number$ O O O O O $any$ O O $any$ O O $IArguments$ O O $ActionContext$ O $complex$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O $any$ O $ActionFunction$ O $any$ O $string$ O $IArguments$ O $IArguments$ O $ActionContext$ O $ActionContext$ O O O $void$ O $string$ O $IArguments$ O $complex$ O O $any$ O $any$ O O $any$ O $void$ O O $any$ O $any$ O O $any$ O $string$ O O $any$ O $IArguments$ O O $any$ O $IArguments$ O O $any$ O $ActionContext$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O O O O O $complex$ O $complex$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O $Promise<{}>$ O O O O O O O O O O O O $any$ O $complex$ O O $any$ O $Promise<{}>$ O O O O O $any$ O O O O O O O $complex$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O O O O O O O O O O $any$ O $Console$ O $void$ O O $any$ O O O O $any$ O O O $any$ O $any$ O $Console$ O $void$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O O $ActionFunction$ O $string$ O $IArguments$ O $ActionContext$ O O O O O O O O O O O O O O $any$ O $Console$ O $void$ O O $any$ O O O O $any$ O O O $any$ O $any$ O $Console$ O $void$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O $complex$ O O O O O O O O O O O O O O O O O O $complex$ O $void$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O $complex$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O O O O $complex$ O $void$ O O O O O O O O O O O O O $any$ O O O $complex$ O O O O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O $Console$ O $void$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O O
import 's' ; import mutator from 's' ; import * as dispatcher from 's' ; import * as globalContext from 's' ; import * as mobx from 's' ; describe ( 's' , ( ) => { let mockGlobalContext ; beforeEach ( ( ) => { mockGlobalContext = { inMutator : false } ; spyOn ( globalContext , 's' ) . and . returnValue ( mockGlobalContext ) ; spyOn ( dispatcher , 's' ) ; } ) ; it ( 's' , ( ) => { let actionCreator = { } ; expect ( ( ) => { mutator ( actionCreator , ( ) => { } ) ; } ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; let actionCreator = { __SATCHELJS_ACTION_ID : actionId } ; mutator ( actionCreator , ( ) => { } ) ; expect ( dispatcher . subscribe ) . toHaveBeenCalled ( ) ; expect ( ( < jasmine . Spy > dispatcher . subscribe ) . calls . argsFor ( 0 ) [ 0 ] ) . toBe ( actionId ) ; } ) ; it ( 's' , ( ) => { let callback = ( ) => { } ; let wrappedCallback = ( ) => { } ; let actionCreator = { __SATCHELJS_ACTION_ID : 's' } ; spyOn ( mobx , 's' ) . and . returnValue ( wrappedCallback ) ; mutator ( actionCreator , callback ) ; expect ( mobx . action ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { let actionCreator = { __SATCHELJS_ACTION_ID : 's' } ; let callback = ( ) => { } ; let returnValue = mutator ( actionCreator , callback ) ; expect ( returnValue ) . toBe ( callback ) ; } ) ; it ( 's' , ( ) => { let actionCreator = { __SATCHELJS_ACTION_ID : 's' } ; let callback = async ( ) => { } ; mutator ( actionCreator , callback ) ; let subscribedCallback = ( dispatcher . subscribe as jasmine . Spy ) . calls . argsFor ( 0 ) [ 0 ] ; expect ( subscribedCallback ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let actionCreator = { __SATCHELJS_ACTION_ID : 's' } ; let inMutatorValue ; let callback = ( ) => { expect ( mockGlobalContext . inMutator ) . toBeTruthy ( ) ; } ; mutator ( actionCreator , callback ) ; let subscribedCallback = ( dispatcher . subscribe as jasmine . Spy ) . calls . argsFor ( 0 ) [ 0 ] ; subscribedCallback ( ) ; expect ( mockGlobalContext . inMutator ) . toBeFalsy ( ) ; } ) ; } ) ;	O O O O $MutatorFunction<T>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $MutatorFunction<T>$ O $any$ O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $any$ O O $string$ O $string$ O O $MutatorFunction<T>$ O $any$ O O O O O O O O $any$ O $any$ O $void$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $void$ O O O O O O O O $any$ O O $string$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O $MutatorFunction<T>$ O $any$ O $void$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $void$ O O O O O O O O $MutatorFunction<ActionMessage>$ O $MutatorFunction<T>$ O $any$ O $void$ O O $any$ O $MutatorFunction<ActionMessage>$ O O $any$ O $void$ O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $Promise<void>$ O O O O O O O O $MutatorFunction<T>$ O $any$ O $Promise<void>$ O O O $any$ O O $any$ O $void$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $MutatorFunction<T>$ O $any$ O $void$ O O O $any$ O O $any$ O $void$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
import 's' ; import orchestrator from 's' ; import * as dispatcher from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let actionCreator = { } ; expect ( ( ) => { orchestrator ( actionCreator , ( ) => { } ) ; } ) . toThrow ( ) ; } ) ; it ( 's' , ( ) => { let callback = ( ) => { } ; let actionId = 's' ; let actionCreator = { __SATCHELJS_ACTION_ID : actionId } ; spyOn ( dispatcher , 's' ) ; orchestrator ( actionCreator , callback ) ; expect ( dispatcher . subscribe ) . toHaveBeenCalledWith ( actionId , callback ) ; } ) ; it ( 's' , ( ) => { let actionCreator = { __SATCHELJS_ACTION_ID : 's' } ; let callback = ( ) => { } ; let returnValue = orchestrator ( actionCreator , callback ) ; expect ( returnValue ) . toBe ( callback ) ; } ) ; } ) ;	O O O O $OrchestratorFunction<T>$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $OrchestratorFunction<T>$ O $any$ O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O $string$ O O O O $any$ O O $string$ O $string$ O O $any$ O $any$ O O O O $OrchestratorFunction<T>$ O $any$ O $void$ O O $any$ O $any$ O $void$ O O $any$ O $string$ O $void$ O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $void$ O O O O O O O O $OrchestratorFunction<ActionMessage>$ O $OrchestratorFunction<T>$ O $any$ O $void$ O O $any$ O $OrchestratorFunction<ActionMessage>$ O O $any$ O $void$ O O O O O O O O
import 's' ; import { createSimpleSubscriber , mutatorAction } from 's' ; import { __resetGlobalContext } from 's' ; import * as actionCreator from 's' ; describe ( 's' , ( ) => { let actionCreatorSpy : jasmine . Spy ; let decoratorSpy : jasmine . Spy ; let simpleSubscriber ; beforeEach ( ( ) => { __resetGlobalContext ( ) ; actionCreatorSpy = spyOn ( actionCreator , 's' ) . and . callThrough ( ) ; decoratorSpy = jasmine . createSpy ( 's' ) ; simpleSubscriber = createSimpleSubscriber ( decoratorSpy ) ; } ) ; it ( 's' , ( ) => { let actionId = 's' ; let returnValue = simpleSubscriber ( actionId , ( ) => { } ) ; expect ( actionCreatorSpy ) . toHaveBeenCalled ( ) ; expect ( actionCreatorSpy . calls . argsFor ( 0 ) [ 0 ] ) . toBe ( actionId ) ; expect ( returnValue ) . toBe ( actionCreatorSpy . calls . first ( ) . returnValue ) ; } ) ; it ( 's' , ( ) => { let returnValue = simpleSubscriber ( 's' , ( ) => { } ) ; let createdAction = returnValue ( 0 , 0 , 0 ) ; expect ( Array . from ( createdAction . args ) ) . toEqual ( [ 0 , 0 , 0 ] ) ; } ) ; it ( 's' , ( ) => { simpleSubscriber ( 's' , ( ) => { } ) ; expect ( decoratorSpy ) . toHaveBeenCalled ( ) ; expect ( decoratorSpy . calls . argsFor ( 0 ) [ 0 ] ) . toBe ( actionCreatorSpy . calls . first ( ) . returnValue ) ; } ) ; it ( 's' , ( ) => { let callback = jasmine . createSpy ( 's' ) ; let actionMessage = { args : [ 0 , 0 , 0 ] } ; simpleSubscriber ( 's' , callback ) ; let decoratorCallback = decoratorSpy . calls . argsFor ( 0 ) [ 0 ] ; decoratorCallback ( actionMessage ) ; expect ( callback ) . toHaveBeenCalledWith ( 0 , 0 , 0 ) ; } ) ; it ( 's' , ( ) => { let callback = async ( ) => { } ; let actionCreator = mutatorAction ( 's' , callback ) ; expect ( actionCreator ) . toThrow ( ) ; } ) ; } ) ;	O O O O O $T$ O $T$ O O O O O O $void$ O O O O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Function$ O $any$ O O O O O $void$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Function$ O $T$ O $any$ O O O O O $any$ O O O O O O O O $string$ O O O O $any$ O $Function$ O $string$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $string$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O O O O O $Function$ O $Function$ O O O O O O O O O O O $any$ O $Function$ O O O O O O O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $Function$ O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O $number[]$ O O O O O O O O O O $Function$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O $T$ O O O $Promise<void>$ O O $any$ O $Promise<void>$ O O $any$ O O O O O O O O O