import { Pipe , PipeTransform } from 's' ; const escape = s => s . replace ( "s" , 's' ) ; @ Pipe ( { name : 's' } ) export class HighlightPipe implements PipeTransform { public transform ( value , arg ) { if ( ! arg . trim ( ) ) { return value ; } try { const regex = new RegExp ( `template` , 's' ) ; return value . replace ( regex , 's' ) ; } catch ( e ) { return value ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const PLACEHOLDER = 's' ; export const SECONDARY_PLACEHOLDER = 's' ; export const KEYDOWN = 's' ; export const KEYUP = 's' ; export const FOCUS = 's' ; export const MAX_ITEMS_WARNING = 's' ; export const ACTIONS_KEYS = { DELETE : 's' , SWITCH_PREV : 's' , SWITCH_NEXT : 's' , TAB : 's' } ; export const KEY_PRESS_ACTIONS = { 0 : ACTIONS_KEYS . DELETE , 0 : ACTIONS_KEYS . SWITCH_PREV , 0 : ACTIONS_KEYS . SWITCH_NEXT , 0 : ACTIONS_KEYS . TAB } ; export const DRAG_AND_DROP_KEY = 's' ; export const NEXT = 's' ; export const PREV = 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ContentChildren , EventEmitter , HostListener , Injector , Input , QueryList , TemplateRef , ViewChild , AfterViewInit , } from 's' ; import { Observable } from 's' ; import { filter , first , debounceTime } from 's' ; import { 0 , 0 } from 's' ; import { defaults } from 's' ; import { TagModel } from 's' ; import { TagInputComponent } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class TagInputDropdown implements AfterViewInit { @ ViewChild ( 0 , { static : false } ) public dropdown : 0 ; @ ContentChildren ( TemplateRef ) public templates : QueryList < TemplateRef < any > > ; @ Input ( ) public offset : string = defaults . dropdown . offset ; @ Input ( ) public focusFirstElement = defaults . dropdown . focusFirstElement ; @ Input ( ) public showDropdownIfEmpty = defaults . dropdown . showDropdownIfEmpty ; @ Input ( ) public autocompleteObservable : ( text ) => Observable < any > ; @ Input ( ) public minimumTextLength = defaults . dropdown . minimumTextLength ; @ Input ( ) public limitItemsTo : number = defaults . dropdown . limitItemsTo ; @ Input ( ) public displayBy = defaults . dropdown . displayBy ; @ Input ( ) public identifyBy = defaults . dropdown . identifyBy ; @ Input ( ) public matchingFn : ( value , target ) => boolean = defaults . dropdown . matchingFn ; @ Input ( ) public appendToBody = defaults . dropdown . appendToBody ; @ Input ( ) public keepOpen = defaults . dropdown . keepOpen ; @ Input ( ) public dynamicUpdate = defaults . dropdown . dynamicUpdate ; @ Input ( ) public zIndex = defaults . dropdown . zIndex ; public items : TagModel [ ] = [ ] ; public tagInput : TagInputComponent = this . injector . get ( TagInputComponent ) ; private _autocompleteItems : TagModel [ ] = [ ] ; public set autocompleteItems ( items : TagModel [ ] ) { this . _autocompleteItems = items ; } @ Input ( ) public get autocompleteItems ( ) : TagModel [ ] { const items = this . _autocompleteItems ; if ( ! items ) { return [ ] ; } return items . map ( ( item ) => { return typeof item === 's' ? { [ this . displayBy ] : item , [ this . identifyBy ] : item } : item ; } ) ; } constructor ( private readonly injector ) { } ngAfterViewInit ( ) { this . onItemClicked ( ) . subscribe ( ( item ) => { this . requestAdding ( item ) ; } ) ; this . onHide ( ) . subscribe ( this . resetItems ) ; const DEBOUNCE_TIME = 0 ; const KEEP_OPEN = this . keepOpen ; this . tagInput . onTextChange . asObservable ( ) . pipe ( debounceTime ( DEBOUNCE_TIME ) , filter ( ( value ) => { if ( KEEP_OPEN === false ) { return value . length > 0 ; } return true ; } ) ) . subscribe ( this . show ) ; } public updatePosition ( ) { const position = this . tagInput . inputForm . getElementPosition ( ) ; this . dropdown . menu . updatePosition ( position , this . dynamicUpdate ) ; } public get isVisible ( ) : boolean { return this . dropdown . menu . state . menuState . isVisible ; } public onHide ( ) < 0 > { return this . dropdown . onHide ; } public onItemClicked ( ) < string > { return this . dropdown . onItemClicked ; } public get selectedItem ( ) : 0 { return this . dropdown . menu . state . dropdownState . selectedItem ; } public get state ( ) : any { return this . dropdown . menu . state ; } public show = ( ) : void => { const maxItemsReached = this . tagInput . items . length === this . tagInput . maxItems ; const value = this . getFormValue ( ) ; const hasMinimumText = value . trim ( ) . length >= this . minimumTextLength ; const position = this . calculatePosition ( ) ; const items = this . getMatchingItems ( value ) ; const hasItems = items . length > 0 ; const isHidden = this . isVisible === false ; const showDropdownIfEmpty = this . showDropdownIfEmpty && hasItems && ! value ; const isDisabled = this . tagInput . disable ; const shouldShow = isHidden && ( ( hasItems && hasMinimumText ) || showDropdownIfEmpty ) ; const shouldHide = this . isVisible && ! hasItems ; if ( this . autocompleteObservable && hasMinimumText ) { return this . getItemsFromObservable ( value ) ; } if ( ( ! this . showDropdownIfEmpty && ! value ) || maxItemsReached || isDisabled ) { return this . dropdown . hide ( ) ; } this . setItems ( items ) ; if ( shouldShow ) { this . dropdown . show ( position ) ; } else if ( shouldHide ) { this . hide ( ) ; } } public hide ( ) { this . resetItems ( ) ; this . dropdown . hide ( ) ; } @ HostListener ( 's' ) public scrollListener ( ) { if ( ! this . isVisible || ! this . dynamicUpdate ) { return ; } this . updatePosition ( ) ; } @ HostListener ( 's' ) public onWindowBlur ( ) { this . dropdown . hide ( ) ; } private getFormValue ( ) { const formValue = this . tagInput . formValue ; return formValue ? formValue . toString ( ) . trim ( ) : 's' ; } private calculatePosition ( ) { return this . tagInput . inputForm . getElementPosition ( ) ; } private requestAdding = async ( item ) => { const tag = this . createTagModel ( item ) ; await this . tagInput . onAddingRequested ( true , tag ) . catch ( ( ) => { } ) ; } private createTagModel ( item ) { const display = typeof item . value === 's' ? item . value : item . value [ this . displayBy ] ; const value = typeof item . value === 's' ? item . value : item . value [ this . identifyBy ] ; return { ... item . value , [ this . tagInput . displayBy ] : display , [ this . tagInput . identifyBy ] : value } ; } private getMatchingItems ( value ) : TagModel [ ] { if ( ! value && ! this . showDropdownIfEmpty ) { return [ ] ; } const dupesAllowed = this . tagInput . allowDupes ; return this . autocompleteItems . filter ( ( item ) => { const hasValue = dupesAllowed ? false : this . tagInput . tags . some ( tag => { const identifyBy = this . tagInput . identifyBy ; const model = typeof tag . model === 's' ? tag . model : tag . model [ identifyBy ] ; return model === item [ this . identifyBy ] ; } ) ; return this . matchingFn ( value , item ) && ( hasValue === false ) ; } ) ; } private setItems ( items : TagModel [ ] ) { this . items = items . slice ( 0 , this . limitItemsTo || items . length ) ; } private resetItems = ( ) : void => { this . items = [ ] ; } private populateItems ( data ) { this . autocompleteItems = data . map ( item => { return typeof item === 's' ? { [ this . displayBy ] : item , [ this . identifyBy ] : item } : item ; } ) ; return this ; } private getItemsFromObservable = ( text ) : void => { this . setLoadingState ( true ) ; const subscribeFn = ( data : any [ ] ) => { this . setLoadingState ( false ) . populateItems ( data ) ; this . setItems ( this . getMatchingItems ( text ) ) ; if ( this . items . length ) { this . dropdown . show ( this . calculatePosition ( ) ) ; } else { this . dropdown . hide ( ) ; } } ; this . autocompleteObservable ( text ) . pipe ( first ( ) ) . subscribe ( subscribeFn , ( ) => this . setLoadingState ( false ) ) ; } private setLoadingState ( state ) { this . tagInput . isLoading = state ; return this ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Injector$ O O O $void$ O O O O O O O O O O O O $Ng2MenuItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EventEmitter$ O O O O O O O O O O O O O O O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientRect$ O O O O O O O O O O O O O O O O O O O O $Ng2MenuItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O $Ng2MenuItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagInputDropdown$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagInputDropdown$ O $boolean$ O O O O O O O O O O O O O O O
import { Observable } from 's' ; import { ValidatorFn , AsyncValidatorFn } from 's' ; import { SECONDARY_PLACEHOLDER , PLACEHOLDER } from 's' ; import { TagInputDropdown } from 's' ; import { TagModel } from 's' ; export interface TagInputOptions { separatorKeys : string [ ] ; separatorKeyCodes : number [ ] ; maxItems : number ; placeholder : string ; secondaryPlaceholder : string ; validators : ValidatorFn [ ] ; asyncValidators : AsyncValidatorFn [ ] ; onlyFromAutocomplete : boolean ; errorMessages : { [ key ] : string ; } ; theme : 's' ; onTextChangeDebounce : number ; inputId : string | null ; inputClass : string ; clearOnBlur : boolean ; hideForm : boolean ; addOnBlur : boolean ; addOnPaste : boolean ; pasteSplitPattern : string | RegExp ; blinkIfDupe : boolean ; removable : boolean ; editable : boolean ; allowDupes : boolean ; modelAsStrings : boolean ; trimTags : boolean ; ripple : boolean ; tabIndex : string ; disable : boolean ; dragZone : string ; onRemoving ? : ( tag ) => Observable < TagModel > ; onAdding ? : ( tag ) => Observable < TagModel > ; displayBy : string ; identifyBy : string ; animationDuration : { enter : string , leave : string } ; } export interface TagInputDropdownOptions { displayBy : string ; identifyBy : string ; appendToBody : boolean ; offset : string ; focusFirstElement : boolean ; showDropdownIfEmpty : boolean ; minimumTextLength : number ; limitItemsTo : number ; keepOpen : boolean ; zIndex : number ; dynamicUpdate : boolean ; matchingFn : ( value , target ) => boolean ; } export const defaults = { tagInput : < TagInputOptions > { separatorKeys : [ ] , separatorKeyCodes : [ ] , maxItems : Infinity , placeholder : PLACEHOLDER , secondaryPlaceholder : SECONDARY_PLACEHOLDER , validators : [ ] , asyncValidators : [ ] , onlyFromAutocomplete : false , errorMessages : { } , theme : 's' , onTextChangeDebounce : 0 , inputId : null , inputClass : 's' , clearOnBlur : false , hideForm : false , addOnBlur : false , addOnPaste : false , pasteSplitPattern : 's' , blinkIfDupe : true , removable : true , editable : false , allowDupes : false , modelAsStrings : false , trimTags : true , ripple : true , tabIndex : 's' , disable : false , dragZone : 's' , onRemoving : undefined , onAdding : undefined , displayBy : 's' , identifyBy : 's' , animationDuration : { enter : 's' , leave : 's' } } , dropdown : < TagInputDropdownOptions > { displayBy : 's' , identifyBy : 's' , appendToBody : true , offset : 's' , focusFirstElement : false , showDropdownIfEmpty : false , minimumTextLength : 0 , limitItemsTo : Infinity , keepOpen : true , dynamicUpdate : true , zIndex : 0 , matchingFn } } ; function matchingFn ( this , value , target ) { const targetValue = target [ this . displayBy ] . toString ( ) ; return targetValue && targetValue . toLowerCase ( ) . indexOf ( value . toLowerCase ( ) ) >= 0 ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TagInputDropdown$ O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { defaults , TagInputOptions , TagInputDropdownOptions } from 's' ; export type Options = { tagInput ? : { [ P in keyof TagInputOptions ] ? : TagInputOptions [ P ] ; } ; dropdown ? : { [ P in keyof TagInputDropdownOptions ] ? : TagInputDropdownOptions [ P ] ; } } ; export class OptionsProvider { public static defaults = defaults ; public setOptions ( options ) { OptionsProvider . defaults . tagInput = { ... defaults . tagInput , ... options . tagInput } ; OptionsProvider . defaults . dropdown = { ... defaults . dropdown , ... options . dropdown } ; } } export { TagInputDropdownOptions , TagInputOptions } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Options$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ControlValueAccessor } from 's' ; import { Input } from 's' ; import { OptionsProvider } from 's' ; import { TagInputDropdown } from 's' ; export class TagModelClass { [ key ] : any ; } export type TagModel = string | TagModelClass ; export function isObject ( obj ) { return obj === Object ( obj ) ; } export class TagInputAccessor implements ControlValueAccessor { private _items : TagModel [ ] = [ ] ; private _onTouchedCallback : ( ) => void ; private _onChangeCallback : ( items : TagModel [ ] ) => void ; public dropdown : TagInputDropdown ; @ Input ( ) public displayBy : string = OptionsProvider . defaults . tagInput . displayBy ; @ Input ( ) public identifyBy : string = OptionsProvider . defaults . tagInput . identifyBy ; public get items ( ) : TagModel [ ] { return this . _items ; } public set items ( items : TagModel [ ] ) { this . _items = items ; this . _onChangeCallback ( this . _items ) ; } public onTouched ( ) { this . _onTouchedCallback ( ) ; } public writeValue ( items : any [ ] ) { this . _items = items || [ ] ; } public registerOnChange ( fn ) { this . _onChangeCallback = fn ; } public registerOnTouched ( fn ) { this . _onTouchedCallback = fn ; } public getItemValue ( item , fromDropdown = false ) { const property = fromDropdown && this . dropdown ? this . dropdown . identifyBy : this . identifyBy ; return isObject ( item ) ? item [ property ] : item ; } public getItemDisplay ( item , fromDropdown = false ) { const property = fromDropdown && this . dropdown ? this . dropdown . displayBy : this . displayBy ; return isObject ( item ) ? item [ property ] : item ; } protected getItemsWithout ( index ) : TagModel [ ] { return this . items . filter ( ( item , position ) => position !== index ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $boolean$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O
export function listen ( listenerType , action : ( ) => any , condition = true ) { if ( ! this . listeners . hasOwnProperty ( listenerType ) ) { throw new Error ( 's' ) ; } if ( ! condition ) { return ; } this . listeners [ listenerType ] . push ( action ) ; }	O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnChanges , OnInit , Output , SimpleChanges , ViewChild } from 's' ; import { AsyncValidatorFn , FormControl , FormGroup , ValidatorFn } from 's' ; @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class TagInputForm implements OnInit , OnChanges { @ Output ( ) public onSubmit : EventEmitter < any > = new EventEmitter ( ) ; @ Output ( ) public onBlur : EventEmitter < any > = new EventEmitter ( ) ; @ Output ( ) public onFocus : EventEmitter < any > = new EventEmitter ( ) ; @ Output ( ) public onKeyup : EventEmitter < any > = new EventEmitter ( ) ; @ Output ( ) public onKeydown : EventEmitter < any > = new EventEmitter ( ) ; @ Output ( ) public inputTextChange : EventEmitter < string > = new EventEmitter ( ) ; @ Input ( ) public placeholder : string ; @ Input ( ) public validators : ValidatorFn [ ] = [ ] ; @ Input ( ) public asyncValidators : AsyncValidatorFn [ ] = [ ] ; @ Input ( ) public inputId : string ; @ Input ( ) public inputClass : string ; @ Input ( ) public tabindex = 's' ; @ Input ( ) public disabled = false ; @ ViewChild ( 's' , { static : false } ) public input ; public form : FormGroup ; @ Input ( ) public get inputText ( ) : string { return this . item . value ; } public set inputText ( text ) { this . item . setValue ( text ) ; this . inputTextChange . emit ( text ) ; } private readonly item : FormControl = new FormControl ( { value : 's' , disabled : this . disabled } ) ; ngOnInit ( ) { this . item . setValidators ( this . validators ) ; this . item . setAsyncValidators ( this . asyncValidators ) ; this . form = new FormGroup ( { item : this . item } ) ; } ngOnChanges ( changes ) { if ( changes . disabled && ! changes . disabled . firstChange ) { if ( changes . disabled . currentValue ) { this . form . controls [ 's' ] . disable ( ) ; } else { this . form . controls [ 's' ] . enable ( ) ; } } } public get value ( ) : FormControl { return this . form . get ( 's' ) as FormControl ; } public isInputFocused ( ) { const doc = typeof document !== 's' ? document : undefined ; return doc ? doc . activeElement === this . input . nativeElement : false ; } public getErrorMessages ( messages : { [ key ] : string } ) : string [ ] { return Object . keys ( messages ) . filter ( err => this . value . hasError ( err ) ) . map ( err => messages [ err ] ) ; } public hasErrors ( ) { const { dirty , value , valid } = this . form ; return dirty && value . item && ! valid ; } public focus ( ) { this . input . nativeElement . focus ( ) ; } public blur ( ) { this . input . nativeElement . blur ( ) ; } public getElementPosition ( ) { return this . input . nativeElement . getBoundingClientRect ( ) ; } public destroy ( ) { const input = this . input . nativeElement ; input . parentElement . removeChild ( input ) ; } public onKeyDown ( $event ) { this . inputText = this . value . value ; if ( $event . key === 's' ) { this . submit ( $event ) ; } else { return this . onKeydown . emit ( $event ) ; } } public onKeyUp ( $event ) { this . inputText = this . value . value ; return this . onKeyup . emit ( $event ) ; } public submit ( $event ) { $event . preventDefault ( ) ; this . onSubmit . emit ( $event ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $SimpleChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $ClientRect$ O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' ; import { animate , trigger , style , transition , keyframes , state } from 's' ; @ Component ( { selector : 's' , styles : [ `template` ] , template : `template` , animations : [ trigger ( 's' , [ state ( 's' , style ( { width : 0 , opacity : 0 } ) ) , transition ( 's' , [ animate ( 0 , keyframes ( [ style ( { opacity : 0 , offset : 0 , width : 's' , borderRadius : 's' } ) , style ( { opacity : 0 , offset : 0 , width : 's' } ) , style ( { opacity : 0 , offset : 0 , width : 's' , borderRadius : 's' } ) ] ) ) ] ) ] ) ] } ) export class TagRipple { @ Input ( ) public state = 's' ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface EventLike { preventDefault ( ) : void ; keyCode : number ; }	O O O O O O O O O O O O O O O
import { Component , Input , Output , EventEmitter , TemplateRef , ElementRef , HostListener , HostBinding , ViewChild , ChangeDetectorRef , 0 } from 's' ; import { TagModel } from 's' ; import { TagRipple } from 's' ; import { EventLike } from 's' ; const navigator = typeof window !== 's' ? window . navigator : { userAgent : 's' , vendor : 's' } ; const isChrome = "s" . test ( navigator . userAgent ) && "s" . test ( navigator . vendor ) ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class TagComponent { @ Input ( ) public model : TagModel ; @ Input ( ) public removable : boolean ; @ Input ( ) public editable : boolean ; @ Input ( ) public template : TemplateRef < any > ; @ Input ( ) public displayBy : string ; @ Input ( ) public identifyBy : string ; @ Input ( ) public index : number ; @ Input ( ) public hasRipple : boolean ; @ Input ( ) public disabled = false ; @ Input ( ) public canAddTag : ( tag ) => boolean ; @ Output ( ) public onSelect : EventEmitter < TagModel > = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onRemove : EventEmitter < TagModel > = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onBlur : EventEmitter < TagModel > = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onKeyDown : EventEmitter < any > = new EventEmitter < any > ( ) ; @ Output ( ) public onTagEdited : EventEmitter < TagModel > = new EventEmitter < TagModel > ( ) ; public get readonly ( ) : boolean { return typeof this . model !== 's' && this . model . readonly === true ; } public editing = false ; @ HostBinding ( 's' ) public moving : boolean ; public rippleState = 's' ; @ ViewChild ( TagRipple , { static : false } ) public ripple : TagRipple ; constructor ( public element , public renderer , private cdRef ) { } public select ( $event ? ) { if ( this . readonly || this . disabled ) { return ; } if ( $event ) { $event . stopPropagation ( ) ; } this . focus ( ) ; this . onSelect . emit ( this . model ) ; } public remove ( $event ) { $event . stopPropagation ( ) ; this . onRemove . emit ( this ) ; } public focus ( ) { this . element . nativeElement . focus ( ) ; } public move ( ) { this . moving = true ; } @ HostListener ( 's' , [ 's' ] ) public keydown ( event ) { if ( this . editing ) { if ( event . keyCode === 0 ) { return this . disableEditMode ( event ) ; } } else { this . onKeyDown . emit ( { event , model : this . model } ) ; } } public blink ( ) { const classList = this . element . nativeElement . classList ; classList . add ( 's' ) ; setTimeout ( ( ) => classList . remove ( 's' ) , 0 ) ; } public toggleEditMode ( ) { if ( this . editable ) { return this . editing ? undefined : this . activateEditMode ( ) ; } } public onBlurred ( event ) { if ( ! this . editable ) { return ; } this . disableEditMode ( ) ; const value = event . target . innerText ; const result = typeof this . model === 's' ? value : { ... this . model , [ this . displayBy ] : value } ; this . onBlur . emit ( result ) ; } public getDisplayValue ( item ) { return typeof item === 's' ? item : item [ this . displayBy ] ; } public get isRippleVisible ( ) : boolean { return ! this . readonly && ! this . editing && isChrome && this . hasRipple ; } public disableEditMode ( $event ? ) { const classList = this . element . nativeElement . classList ; const input = this . getContentEditableText ( ) ; this . editing = false ; classList . remove ( 's' ) ; if ( ! input ) { this . setContentEditableText ( this . model ) ; return ; } this . storeNewValue ( input ) ; this . cdRef . detectChanges ( ) ; if ( $event ) { $event . preventDefault ( ) ; } } public isDeleteIconVisible ( ) { return ( ! this . readonly && ! this . disabled && this . removable && ! this . editing ) ; } private getContentEditableText ( ) { const input = this . getContentEditable ( ) ; return input ? input . innerText . trim ( ) : 's' ; } private setContentEditableText ( model ) { const input = this . getContentEditable ( ) ; const value = this . getDisplayValue ( model ) ; input . innerText = value ; } private activateEditMode ( ) { const classList = this . element . nativeElement . classList ; classList . add ( 's' ) ; this . editing = true ; } private storeNewValue ( input ) { const exists = ( tag ) => { return typeof tag === 's' ? tag === input : tag [ this . displayBy ] === input ; } ; const hasId = ( ) => { return this . model [ this . identifyBy ] !== this . model [ this . displayBy ] ; } ; if ( exists ( this . model ) ) { return ; } const model = typeof this . model === 's' ? input : { index : this . index , [ this . identifyBy ] : hasId ( ) ? this . model [ this . identifyBy ] : input , [ this . displayBy ] : input } ; if ( this . canAddTag ( model ) ) { this . onTagEdited . emit ( { tag : model , index : this . index } ) ; } else { this . setContentEditableText ( this . model ) ; } } private getContentEditable ( ) { return this . element . nativeElement . querySelector ( 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O $Renderer2$ O O $ChangeDetectorRef$ O O O O $void$ O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MouseEvent$ O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $void$ O $EventLike$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $EventLike$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLInputElement$ O O O O O O O O O O O O O O O O O
import { animate , trigger , style , transition , keyframes , state , AnimationTriggerMetadata } from 's' ; export const animations = [ trigger ( 's' , [ state ( 's' , style ( { opacity : 0 } ) ) , state ( 's' , style ( { opacity : 0 } ) ) , transition ( 's' , [ animate ( 's' , keyframes ( [ style ( { opacity : 0 , offset : 0 , transform : 's' } ) , style ( { opacity : 0 , offset : 0 , transform : 's' } ) , style ( { opacity : 0 , offset : 0 , transform : 's' } ) , style ( { opacity : 0 , offset : 0 , transform : 's' } ) , style ( { opacity : 0 , offset : 0 , transform : 's' } ) ] ) ) ] ) , transition ( 's' , [ animate ( 's' , keyframes ( [ style ( { opacity : 0 , transform : 's' , offset : 0 } ) , style ( { opacity : 0 , transform : 's' , offset : 0 } ) , style ( { opacity : 0 , transform : 's' , offset : 0 } ) ] ) ) ] ) ] ) ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , forwardRef , HostBinding , Input , Output , EventEmitter , 0 , ViewChild , ViewChildren , ContentChildren , ContentChild , OnInit , TemplateRef , QueryList , AfterViewInit } from 's' ; import { AsyncValidatorFn , FormControl , NG_VALUE_ACCESSOR , ValidatorFn } from 's' ; import { Observable } from 's' ; import { debounceTime , filter , map , first } from 's' ; import { TagInputAccessor , TagModel } from 's' ; import { listen } from 's' ; import * as constants from 's' ; import { DragProvider , DraggedTag } from 's' ; import { TagInputForm } from 's' ; import { TagComponent } from 's' ; import { animations } from 's' ; import { defaults } from 's' ; import { TagInputDropdown } from 's' ; const DragEvent = ( window as any ) . DragEvent ; const CUSTOM_ACCESSOR = { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => TagInputComponent ) , multi : true } ; @ Component ( { selector : 's' , providers : [ CUSTOM_ACCESSOR ] , styleUrls : [ 's' ] , templateUrl : 's' , animations } ) export class TagInputComponent extends TagInputAccessor implements OnInit , AfterViewInit { @ Input ( ) public separatorKeys : string [ ] = defaults . tagInput . separatorKeys ; @ Input ( ) public separatorKeyCodes : number [ ] = defaults . tagInput . separatorKeyCodes ; @ Input ( ) public placeholder : string = defaults . tagInput . placeholder ; @ Input ( ) public secondaryPlaceholder : string = defaults . tagInput . secondaryPlaceholder ; @ Input ( ) public maxItems : number = defaults . tagInput . maxItems ; @ Input ( ) public validators : ValidatorFn [ ] = defaults . tagInput . validators ; @ Input ( ) public asyncValidators : AsyncValidatorFn [ ] = defaults . tagInput . asyncValidators ; @ Input ( ) public onlyFromAutocomplete = defaults . tagInput . onlyFromAutocomplete ; @ Input ( ) public errorMessages : { [ key ] : string } = defaults . tagInput . errorMessages ; @ Input ( ) public theme : string = defaults . tagInput . theme ; @ Input ( ) public onTextChangeDebounce = defaults . tagInput . onTextChangeDebounce ; @ Input ( ) public inputId = defaults . tagInput . inputId ; @ Input ( ) public inputClass : string = defaults . tagInput . inputClass ; @ Input ( ) public clearOnBlur : boolean = defaults . tagInput . clearOnBlur ; @ Input ( ) public hideForm : boolean = defaults . tagInput . hideForm ; @ Input ( ) public addOnBlur : boolean = defaults . tagInput . addOnBlur ; @ Input ( ) public addOnPaste : boolean = defaults . tagInput . addOnPaste ; @ Input ( ) public pasteSplitPattern = defaults . tagInput . pasteSplitPattern ; @ Input ( ) public blinkIfDupe = defaults . tagInput . blinkIfDupe ; @ Input ( ) public removable = defaults . tagInput . removable ; @ Input ( ) public editable : boolean = defaults . tagInput . editable ; @ Input ( ) public allowDupes = defaults . tagInput . allowDupes ; @ Input ( ) public modelAsStrings = defaults . tagInput . modelAsStrings ; @ Input ( ) public trimTags = defaults . tagInput . trimTags ; @ Input ( ) public get inputText ( ) : string { return this . inputTextValue ; } @ Input ( ) public ripple : boolean = defaults . tagInput . ripple ; @ Input ( ) public tabindex : string = defaults . tagInput . tabIndex ; @ Input ( ) public disable : boolean = defaults . tagInput . disable ; @ Input ( ) public dragZone : string = defaults . tagInput . dragZone ; @ Input ( ) public onRemoving = defaults . tagInput . onRemoving ; @ Input ( ) public onAdding = defaults . tagInput . onAdding ; @ Input ( ) public animationDuration = defaults . tagInput . animationDuration ; @ Output ( ) public onAdd = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onRemove = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onSelect = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onFocus = new EventEmitter < string > ( ) ; @ Output ( ) public onBlur = new EventEmitter < string > ( ) ; @ Output ( ) public onTextChange = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onPaste = new EventEmitter < string > ( ) ; @ Output ( ) public onValidationError = new EventEmitter < TagModel > ( ) ; @ Output ( ) public onTagEdited = new EventEmitter < TagModel > ( ) ; @ ContentChild ( TagInputDropdown , { static : false } ) public dropdown : TagInputDropdown ; @ ContentChildren ( TemplateRef , { descendants : false } ) public templates : QueryList < TemplateRef < any > > ; @ ViewChild ( TagInputForm , { static : false } ) public inputForm : TagInputForm ; public selectedTag : TagModel | undefined ; public isLoading = false ; public set inputText ( text ) { this . inputTextValue = text ; this . inputTextChange . emit ( text ) ; } @ ViewChildren ( TagComponent ) public tags : QueryList < TagComponent > ; private listeners = { [ constants . KEYDOWN ] : < { ( fun ) : any } [ ] > [ ] , [ constants . KEYUP ] : < { ( fun ) : any } [ ] > [ ] } ; @ Output ( ) public inputTextChange : EventEmitter < string > = new EventEmitter ( ) ; public inputTextValue = 's' ; @ HostBinding ( 's' ) public get tabindexAttr ( ) : string { return this . tabindex !== 's' ? 's' : 's' ; } public animationMetadata : { value : string , params : object } ; public errors : string [ ] = [ ] ; public isProgressBarVisible$ : Observable < boolean > ; constructor ( private readonly renderer , public readonly dragProvider ) { super ( ) ; } public ngAfterViewInit ( ) { this . setUpKeypressListeners ( ) ; this . setupSeparatorKeysListener ( ) ; this . setUpInputKeydownListeners ( ) ; if ( this . onTextChange . observers . length ) { this . setUpTextChangeSubscriber ( ) ; } if ( this . clearOnBlur || this . addOnBlur ) { this . setUpOnBlurSubscriber ( ) ; } if ( this . addOnPaste ) { this . setUpOnPasteListener ( ) ; } const statusChanges$ = this . inputForm . form . statusChanges ; statusChanges$ . pipe ( filter ( ( status ) => status !== 's' ) ) . subscribe ( ( ) => { this . errors = this . inputForm . getErrorMessages ( this . errorMessages ) ; } ) ; this . isProgressBarVisible$ = statusChanges$ . pipe ( map ( ( status ) => { return status === 's' || this . isLoading ; } ) ) ; if ( this . hideForm ) { this . inputForm . destroy ( ) ; } } public ngOnInit ( ) { const hasReachedMaxItems = this . maxItems !== undefined && this . items && this . items . length > this . maxItems ; if ( hasReachedMaxItems ) { this . maxItems = this . items . length ; console . warn ( constants . MAX_ITEMS_WARNING ) ; } this . editable = this . onlyFromAutocomplete ? false : this . editable ; this . setAnimationMetadata ( ) ; } public onRemoveRequested ( tag , index ) < TagModel > { return new Promise ( resolve => { const subscribeFn = ( model ) => { this . removeItem ( model , index ) ; resolve ( tag ) ; } ; this . onRemoving ? this . onRemoving ( tag ) . pipe ( first ( ) ) . subscribe ( subscribeFn ) : subscribeFn ( tag ) ; } ) ; } public onAddingRequested ( fromAutocomplete , tag , index ? , giveupFocus ? ) < TagModel > { return new Promise ( ( resolve , reject ) => { const subscribeFn = ( model ) => { return this . addItem ( fromAutocomplete , model , index , giveupFocus ) . then ( resolve ) . catch ( reject ) ; } ; return this . onAdding ? this . onAdding ( tag ) . pipe ( first ( ) ) . subscribe ( subscribeFn , reject ) : subscribeFn ( tag ) ; } ) ; } public appendTag = ( tag , index = this . items . length ) : void => { const items = this . items ; const model = this . modelAsStrings ? tag [ this . identifyBy ] : tag ; this . items = [ ... items . slice ( 0 , index ) , model , ... items . slice ( index , items . length ) ] ; } public createTag = ( model ) : TagModel => { const trim = ( val , key ) : TagModel => { return typeof val === 's' ? val . trim ( ) : val [ key ] ; } ; return { ... typeof model !== 's' ? model : { } , [ this . displayBy ] : this . trimTags ? trim ( model , this . displayBy ) : model , [ this . identifyBy ] : this . trimTags ? trim ( model , this . identifyBy ) : model } ; } public selectItem ( item : TagModel | undefined , emit = true ) { const isReadonly = item && typeof item !== 's' && item . readonly ; if ( isReadonly || this . selectedTag === item ) { return ; } this . selectedTag = item ; if ( emit ) { this . onSelect . emit ( item ) ; } } public fireEvents ( eventName , $event ? ) { this . listeners [ eventName ] . forEach ( listener => listener . call ( this , $event ) ) ; } public handleKeydown ( data ) { const event = data . event ; const key = event . keyCode || event . which ; const shiftKey = event . shiftKey || false ; switch ( constants . KEY_PRESS_ACTIONS [ key ] ) { case constants . ACTIONS_KEYS . DELETE : if ( this . selectedTag && this . removable ) { const index = this . items . indexOf ( this . selectedTag ) ; this . onRemoveRequested ( this . selectedTag , index ) ; } break ; case constants . ACTIONS_KEYS . SWITCH_PREV : this . moveToTag ( data . model , constants . PREV ) ; break ; case constants . ACTIONS_KEYS . SWITCH_NEXT : this . moveToTag ( data . model , constants . NEXT ) ; break ; case constants . ACTIONS_KEYS . TAB : if ( shiftKey ) { if ( this . isFirstTag ( data . model ) ) { return ; } this . moveToTag ( data . model , constants . PREV ) ; } else { if ( this . isLastTag ( data . model ) && ( this . disable || this . maxItemsReached ) ) { return ; } this . moveToTag ( data . model , constants . NEXT ) ; } break ; default : return ; } event . preventDefault ( ) ; } public async onFormSubmit ( ) { try { await this . onAddingRequested ( false , this . formValue ) ; } catch { return ; } } public setInputValue ( value , emitEvent = true ) { const control = this . getControl ( ) ; control . setValue ( value , { emitEvent } ) ; } private getControl ( ) { return this . inputForm . value as FormControl ; } public focus ( applyFocus = false , displayAutocomplete = false ) { if ( this . dragProvider . getState ( 's' ) ) { return ; } this . selectItem ( undefined , false ) ; if ( applyFocus ) { this . inputForm . focus ( ) ; this . onFocus . emit ( this . formValue ) ; } } public blur ( ) { this . onTouched ( ) ; this . onBlur . emit ( this . formValue ) ; } public hasErrors ( ) { return ! ! this . inputForm && this . inputForm . hasErrors ( ) ; } public isInputFocused ( ) { return ! ! this . inputForm && this . inputForm . isInputFocused ( ) ; } public hasCustomTemplate ( ) { const template = this . templates ? this . templates . first : undefined ; const menuTemplate = this . dropdown && this . dropdown . templates ? this . dropdown . templates . first : undefined ; return Boolean ( template && template !== menuTemplate ) ; } public get maxItemsReached ( ) : boolean { return this . maxItems !== undefined && this . items . length >= this . maxItems ; } public get formValue ( ) : string { const form = this . inputForm . value ; return form ? form . value : 's' ; } public onDragStarted ( event , tag , index ) { event . stopPropagation ( ) ; const item = { zone : this . dragZone , tag , index } as DraggedTag ; this . dragProvider . setSender ( this ) ; this . dragProvider . setDraggedItem ( event , item ) ; this . dragProvider . setState ( { dragging : true , index } ) ; } public onDragOver ( event , index ? ) { this . dragProvider . setState ( { dropping : true } ) ; this . dragProvider . setReceiver ( this ) ; event . preventDefault ( ) ; } public onTagDropped ( event , index ? ) { const item = this . dragProvider . getDraggedItem ( event ) ; if ( ! item || item . zone !== this . dragZone ) { return ; } this . dragProvider . onTagDropped ( item . tag , item . index , index ) ; event . preventDefault ( ) ; event . stopPropagation ( ) ; } public isDropping ( ) { const isReceiver = this . dragProvider . receiver === this ; const isDropping = this . dragProvider . getState ( 's' ) ; return Boolean ( isReceiver && isDropping ) ; } public onTagBlurred ( changedElement , index ) { this . items [ index ] = changedElement ; this . blur ( ) ; } public trackBy ( index , item ) { return item [ this . identifyBy ] ; } public updateEditedTag ( { tag , index } : { tag : TagModel , index : number } ) { this . onTagEdited . emit ( tag ) ; } public isTagValid = ( tag , fromAutocomplete = false ) : boolean => { const selectedItem = this . dropdown ? this . dropdown . selectedItem : undefined ; const value = this . getItemDisplay ( tag ) . trim ( ) ; if ( selectedItem && ! fromAutocomplete || ! value ) { return false ; } const dupe = this . findDupe ( tag , fromAutocomplete ) ; if ( ! this . allowDupes && dupe && this . blinkIfDupe ) { const model = this . tags . find ( item => { return this . getItemValue ( item . model ) === this . getItemValue ( dupe ) ; } ) ; if ( model ) { model . blink ( ) ; } } const isFromAutocomplete = fromAutocomplete && this . onlyFromAutocomplete ; const assertions = [ ! dupe || this . allowDupes , ! this . maxItemsReached , ( ( isFromAutocomplete ) || ! this . onlyFromAutocomplete ) ] ; return assertions . filter ( Boolean ) . length === assertions . length ; } private moveToTag ( item , direction ) { const isLast = this . isLastTag ( item ) ; const isFirst = this . isFirstTag ( item ) ; const stopSwitch = ( direction === constants . NEXT && isLast ) || ( direction === constants . PREV && isFirst ) ; if ( stopSwitch ) { this . focus ( true ) ; return ; } const offset = direction === constants . NEXT ? 0 : - 0 ; const index = this . getTagIndex ( item ) + offset ; const tag = this . getTagAtIndex ( index ) ; return tag . select . call ( tag ) ; } private isFirstTag ( item ) { return this . tags . first . model === item ; } private isLastTag ( item ) { return this . tags . last . model === item ; } private getTagIndex ( item ) { const tags = this . tags . toArray ( ) ; return tags . findIndex ( tag => tag . model === item ) ; } private getTagAtIndex ( index ) { const tags = this . tags . toArray ( ) ; return tags [ index ] ; } private removeItem ( tag , index ) { this . items = this . getItemsWithout ( index ) ; if ( this . selectedTag === tag ) { this . selectItem ( undefined , false ) ; } this . focus ( true , false ) ; this . onRemove . emit ( tag ) ; } private addItem ( fromAutocomplete = false , item , index ? , giveupFocus ? ) < TagModel > { const display = this . getItemDisplay ( item ) ; const tag = this . createTag ( item ) ; if ( fromAutocomplete ) { this . setInputValue ( this . getItemValue ( item , true ) ) ; } return new Promise ( ( resolve , reject ) => { const reset = ( ) : void => { this . setInputValue ( 's' ) ; if ( giveupFocus ) { this . focus ( false , false ) ; } else { this . focus ( true , false ) ; } resolve ( display ) ; } ; const appendItem = ( ) : void => { this . appendTag ( tag , index ) ; this . onAdd . emit ( tag ) ; if ( ! this . dropdown ) { return ; } this . dropdown . hide ( ) ; if ( this . dropdown . showDropdownIfEmpty ) { this . dropdown . show ( ) ; } } ; const status = this . inputForm . form . status ; const isTagValid = this . isTagValid ( tag , fromAutocomplete ) ; const onValidationError = ( ) => { this . onValidationError . emit ( tag ) ; return reject ( ) ; } ; if ( status === 's' && isTagValid ) { appendItem ( ) ; return reset ( ) ; } if ( status === 's' || ! isTagValid ) { reset ( ) ; return onValidationError ( ) ; } if ( status === 's' ) { const statusUpdate$ = this . inputForm . form . statusChanges ; return statusUpdate$ . pipe ( filter ( statusUpdate => statusUpdate !== 's' ) , first ( ) ) . subscribe ( ( statusUpdate ) => { if ( statusUpdate === 's' && isTagValid ) { appendItem ( ) ; return reset ( ) ; } else { reset ( ) ; return onValidationError ( ) ; } } ) ; } } ) ; } private setupSeparatorKeysListener ( ) { const useSeparatorKeys = this . separatorKeyCodes . length > 0 || this . separatorKeys . length > 0 ; const listener = ( $event ) => { const hasKeyCode = this . separatorKeyCodes . indexOf ( $event . keyCode ) >= 0 ; const hasKey = this . separatorKeys . indexOf ( $event . key ) >= 0 ; const isIMEProcessing = $event . keyCode === 0 ; if ( hasKeyCode || ( hasKey && ! isIMEProcessing ) ) { $event . preventDefault ( ) ; this . onAddingRequested ( false , this . formValue ) . catch ( ( ) => { } ) ; } } ; listen . call ( this , constants . KEYDOWN , listener , useSeparatorKeys ) ; } private setUpKeypressListeners ( ) { const listener = ( $event ) => { const isCorrectKey = $event . keyCode === 0 || $event . keyCode === 0 ; if ( isCorrectKey && ! this . formValue && this . items . length ) { this . tags . last . select . call ( this . tags . last ) ; } } ; listen . call ( this , constants . KEYDOWN , listener ) ; } private setUpInputKeydownListeners ( ) { this . inputForm . onKeydown . subscribe ( event => { if ( event . key === 's' && this . formValue . trim ( ) === 's' ) { event . preventDefault ( ) ; } } ) ; } private setUpOnPasteListener ( ) { const input = this . inputForm . input . nativeElement ; this . renderer . listen ( input , 's' , ( event ) => { this . onPasteCallback ( event ) ; event . preventDefault ( ) ; return true ; } ) ; } private setUpTextChangeSubscriber ( ) { this . inputForm . form . valueChanges . pipe ( debounceTime ( this . onTextChangeDebounce ) ) . subscribe ( ( value : { item : string } ) => { this . onTextChange . emit ( value . item ) ; } ) ; } private setUpOnBlurSubscriber ( ) { const filterFn = ( ) : boolean => { const isVisible = this . dropdown && this . dropdown . isVisible ; return ! isVisible && ! ! this . formValue ; } ; this . inputForm . onBlur . pipe ( debounceTime ( 0 ) , filter ( filterFn ) ) . subscribe ( ( ) => { const reset = ( ) => this . setInputValue ( 's' ) ; if ( this . addOnBlur ) { return this . onAddingRequested ( false , this . formValue , undefined , true ) . then ( reset ) . catch ( reset ) ; } reset ( ) ; } ) ; } private findDupe ( tag , isFromAutocomplete ) : TagModel | undefined { const identifyBy = isFromAutocomplete ? this . dropdown . identifyBy : this . identifyBy ; const id = tag [ identifyBy ] ; return this . items . find ( item => this . getItemValue ( item ) === id ) ; } private onPasteCallback = async ( data ) => { interface IEWindow extends Window { clipboardData : DataTransfer ; } const getText = ( ) : string => { const isIE = Boolean ( ( window as IEWindow ) . clipboardData ) ; const clipboardData = isIE ? ( ( window as IEWindow ) . clipboardData ) : data . clipboardData ; const type = isIE ? 's' : 's' ; return clipboardData === null ? 's' : clipboardData . getData ( type ) || 's' ; } ; const text = getText ( ) ; const requests = text . split ( this . pasteSplitPattern ) . map ( item => { const tag = this . createTag ( item ) ; this . setInputValue ( tag [ this . displayBy ] ) ; return this . onAddingRequested ( false , tag ) ; } ) ; const resetInput = ( ) => setTimeout ( ( ) => this . setInputValue ( 's' ) , 0 ) ; Promise . all ( requests ) . then ( ( ) => { this . onPaste . emit ( text ) ; resetInput ( ) ; } ) . catch ( resetInput ) ; } private setAnimationMetadata ( ) { this . animationMetadata = { value : 's' , params : { ... this . animationDuration } } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Renderer2$ O O O $DragProvider$ O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TagModel$ O $number$ O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $boolean$ O $TagModel$ O O $number$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O $TagModel$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormControl$ O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $DragEvent$ O $TagModel$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $DragEvent$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $DragEvent$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $TagModel$ O $number$ O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $TagModel$ O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $TagModel$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TagModel$ O O O O O O O O O O O O O O O $boolean$ O $TagModel$ O O O O O O O O O O O O O O O $number$ O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O $void$ O $TagModel$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O $TagModel$ O O $number$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagModel$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClipboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O
import { TagInputComponent } from 's' ; import { TagModel } from 's' ; import { Injectable } from 's' ; export declare interface DraggedTag { index : number ; tag : TagModel ; zone : string ; } import { DRAG_AND_DROP_KEY } from 's' ; export declare interface State { dragging : boolean ; dropping : boolean ; index : number | undefined ; } export declare type StateProperty = keyof State ; @ Injectable ( ) export class DragProvider { public sender : TagInputComponent ; public receiver : TagInputComponent ; public state : State = { dragging : false , dropping : false , index : undefined } ; public setDraggedItem ( event , tag ) { if ( event && event . dataTransfer ) { event . dataTransfer . setData ( DRAG_AND_DROP_KEY , JSON . stringify ( tag ) ) ; } } public getDraggedItem ( event ) : DraggedTag | undefined { if ( event && event . dataTransfer ) { const data = event . dataTransfer . getData ( DRAG_AND_DROP_KEY ) ; try { return JSON . parse ( data ) as DraggedTag ; } catch { return ; } } } public setSender ( sender ) { this . sender = sender ; } public setReceiver ( receiver ) { this . receiver = receiver ; } public onTagDropped ( tag , indexDragged , indexDropped ? ) { this . onDragEnd ( ) ; this . sender . onRemoveRequested ( tag , indexDragged ) ; this . receiver . onAddingRequested ( false , tag , indexDropped ) ; } public setState ( state : { [ K in StateProperty ] ? : State [ K ] } ) { this . state = { ... this . state , ... state } ; } public getState ( key ? ) : State | State [ StateProperty ] { return key ? this . state [ key ] : this . state ; } public onDragEnd ( ) { this . setState ( { dragging : false , dropping : false , index : undefined } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $DragEvent$ O $DraggedTag$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DragEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $TagInputComponent$ O O O O O O O O O O $void$ O $TagInputComponent$ O O O O O O O O O O $void$ O $TagModel$ O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateProperty$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class DeleteIconComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' ; import { ReactiveFormsModule , FormsModule , COMPOSITION_BUFFER_MODE } from 's' ; import { CommonModule } from 's' ; import { 0 } from 's' ; import { HighlightPipe } from 's' ; import { DragProvider } from 's' ; import { OptionsProvider , Options } from 's' ; import { TagInputComponent } from 's' ; import { DeleteIconComponent } from 's' ; import { TagInputForm } from 's' ; import { TagComponent } from 's' ; import { TagInputDropdown } from 's' ; import { TagRipple } from 's' ; const optionsProvider = new OptionsProvider ( ) ; @ NgModule ( { imports : [ CommonModule , ReactiveFormsModule , FormsModule , 0 ] , declarations : [ TagInputComponent , DeleteIconComponent , TagInputForm , TagComponent , HighlightPipe , TagInputDropdown , TagRipple ] , exports : [ TagInputComponent , DeleteIconComponent , TagInputForm , TagComponent , HighlightPipe , TagInputDropdown , TagRipple ] , providers : [ DragProvider , { provide : COMPOSITION_BUFFER_MODE , useValue : false } , ] } ) export class TagInputModule { public static withDefaults ( options ) { optionsProvider . setOptions ( options ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Options$ O O O O O O O O O O O
export { TagInputDropdown } from 's' ;	O O O O O O O
export { DeleteIconComponent } from 's' ;	O O O O O O O
export { TagInputForm } from 's' ;	O O O O O O O
export { TagRipple } from 's' ; export { TagComponent } from 's' ;	O O O O O O O O O O O O O O
export { TagInputComponent } from 's' ;	O O O O O O O
export { TagInputDropdown } from 's' ; export { DeleteIconComponent } from 's' ; export { TagInputForm } from 's' ; export { TagRipple , TagComponent } from 's' ; export { TagInputComponent } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { TagInputModule } from 's' ; export { TagInputDropdown , DeleteIconComponent , TagInputForm , TagRipple , TagComponent , TagInputComponent } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { HttpClient } from 's' ; import { FormBuilder , FormControl , FormGroup } from 's' ; import { filter , map } from 's' ; import { Observable , of } from 's' ; @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class Home { form : FormGroup ; constructor ( private http ) { this . form = new FormBuilder ( ) . group ( { chips : [ [ 's' ] , [ ] ] } ) ; } disabled = true ; items = [ 's' , 's' ] ; inputText = 's' ; itemsAsObjects = [ { id : 0 , name : 's' , readonly : true } , { id : 0 , name : 's' } ] ; autocompleteItems = [ 's' , 's' , 's' , 's' ] ; autocompleteItemsAsObjects = [ { value : 's' , id : 0 , extra : 0 } , { value : 's' , id : 0 , extra : 0 } , 's' ] ; dragAndDropExample = [ 's' , 's' ] ; dragAndDropObjects = [ { display : 's' , value : 's' } , { display : 's' , value : 's' } ] ; dragAndDropStrings = [ 's' , 's' ] ; public requestAutocompleteItems = ( text ) : Observable < any > => { const url = `template` ; return this . http . get < any > ( url ) . pipe ( map ( items => items . map ( item => item . full_name ) ) ) ; } public requestAutocompleteItemsFake = ( text ) : Observable < string [ ] > => { return of ( [ 's' , 's' , 's' ] ) ; } public options = { readonly : undefined , placeholder : 's' } ; public onAdd ( item ) { console . log ( 's' + item ) ; } public onRemove ( item ) { console . log ( 's' + item ) ; } public onSelect ( item ) { console . log ( 's' + item ) ; } public onFocus ( item ) { console . log ( 's' + item ) ; } public onTextChange ( text ) { console . log ( 's' + text ) ; } public onBlur ( item ) { console . log ( 's' + item ) ; } public onTagEdited ( item ) { console . log ( 's' + item ) ; } public onValidationError ( item ) { console . log ( 's' + item ) ; } public transform ( value ) < object > { const item = { display : `template` , value : `template` } ; return of ( item ) ; } private startsWithAt ( control ) { if ( control . value . charAt ( 0 ) !== 's' ) { return { 's' : true } ; } return null ; } private endsWith$ ( control ) { if ( control . value . charAt ( control . value . length - 0 ) !== 's' ) { return { 's' : true } ; } return null ; } private validateAsync ( control ) < any > { return new Promise ( resolve => { const value = control . value ; const result = isNaN ( value ) ? { isNan : true } : null ; setTimeout ( ( ) => { resolve ( result ) ; } , 0 ) ; } ) ; } public asyncErrorMessages = { isNan : 's' } ; public validators = [ this . startsWithAt , this . endsWith$ ] ; public asyncValidators = [ this . validateAsync ] ; public errorMessages = { 's' : 's' , 's' : 's' } ; public onAdding ( tag ) < any > { const confirm = window . confirm ( 's' ) ; return of ( tag ) . pipe ( filter ( ( ) => confirm ) ) ; } public onRemoving ( tag ) < any > { const confirm = window . confirm ( 's' ) ; return of ( tag ) . pipe ( filter ( ( ) => confirm ) ) ; } public asyncOnAdding ( tag ) < any > { const confirm = window . confirm ( 's' ) ; return of ( tag ) . pipe ( filter ( ( ) => confirm ) ) ; } public insertInputTag ( ) { if ( this . inputText ) { this . items . push ( this . inputText ) ; this . inputText = 's' ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormControl$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormControl$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $FormControl$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' ; import { BrowserModule } from 's' ; import { FormsModule , ReactiveFormsModule } from 's' ; import { TagInputModule } from 's' ; import { Home } from 's' ; import { CommonModule } from 's' ; import { HttpClientModule } from 's' ; import { BrowserAnimationsModule } from 's' ; TagInputModule . withDefaults ( { tagInput : { placeholder : 's' } } ) ; @ NgModule ( { imports : [ BrowserModule , BrowserAnimationsModule , CommonModule , HttpClientModule , FormsModule , ReactiveFormsModule , TagInputModule ] , declarations : [ Home ] , bootstrap : [ Home ] , entryComponents : [ Home ] } ) export class AppModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) . catch ( err => console . error ( err ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { clearContext : false } , coverageIstanbulReporter : { dir : require ( 's' ) . join ( __dirname , 's' ) , reports : [ 's' , 's' , 's' ] , fixWebpackSourcePaths : true } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , browsers : [ 's' ] , singleRun : false , restartOnFileChange : true } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { listen } from 's' ;	O O O O O O O
export { HighlightPipe } from 's' ;	O O O O O O O
export { DraggedTag , State , StateProperty , DragProvider } from 's' ; export { Options , OptionsProvider } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O
import * as constants from 's' ; export { constants } ; export { listen } from 's' ; export { HighlightPipe } from 's' ; export { TagModel , isObject , TagInputAccessor } from 's' ; export { DraggedTag , State , StateProperty , DragProvider , Options , OptionsProvider } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { NgModule } from 's' ; import { FormsModule } from 's' ; import { CommonModule } from 's' ; import { Validators , FormControl } from 's' ; import { Observable } from 's' ; import { of } from 's' ; import { TagInputModule } from 's' ; function getItems ( ) { return [ 's' , 's' ] ; } const validators = [ Validators . minLength ( 0 ) , ( control ) => { if ( control . value . charAt ( 0 ) !== 's' ) { return { 's' : true } ; } return null ; } ] ; @ Component ( { selector : 's' , template : `template` } ) export class BasicTagInputComponent { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithOutputs { public items = getItems ( ) ; onAdd ( ) { } onRemove ( ) { } public validators : any = validators ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentTagsAsObjects { public items = [ { value : 0 , display : 's' } , { value : 0 , display : 's' } ] ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentCustomTagsAsObjects { public items = [ { id : 0 , name : 's' } , { id : 0 , name : 's' } ] ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithValidation { public items = getItems ( ) ; validators : any = validators ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithTransformer { public items = getItems ( ) ; onAdding ( value ) < object > { const item = { display : `template` , value : `template` } ; return of ( item ) ; } } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithPlaceholder { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithMaxItems { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithAutocomplete { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithTemplate { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithOnlyAutocomplete { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithModelAsStrings { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithAddOnBlur { public items = getItems ( ) ; } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentWithHooks { public items = getItems ( ) ; public onAdding ( tag ) < any > { return of ( { } ) ; } public onRemoving ( tag ) < any > { return of ( { } ) ; } } @ Component ( { selector : 's' , template : `template` } ) export class TagInputComponentEditable { public items = getItems ( ) ; } const COMPONENTS = [ BasicTagInputComponent , TagInputComponentWithPlaceholder , TagInputComponentWithOutputs , TagInputComponentWithTransformer , TagInputComponentWithValidation , TagInputComponentWithMaxItems , TagInputComponentWithTemplate , TagInputComponentWithAutocomplete , TagInputComponentWithOnlyAutocomplete , TagInputComponentTagsAsObjects , TagInputComponentCustomTagsAsObjects , TagInputComponentWithModelAsStrings , TagInputComponentWithAddOnBlur , TagInputComponentWithHooks , TagInputComponentEditable ] ; @ NgModule ( { imports : [ CommonModule , FormsModule , TagInputModule ] , declarations : COMPONENTS , exports : COMPONENTS } ) export class TestModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormControl$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FormControl } from 's' ; import { async , ComponentFixture , discardPeriodicTasks , fakeAsync , TestBed , tick } from 's' ; import { By } from 's' ; import { Subject } from 's' ; import { BrowserAnimationsModule } from 's' ; import { TagModel } from 's' ; import { TagInputComponent } from 's' ; import { BasicTagInputComponent , TagInputComponentWithAddOnBlur , TagInputComponentWithAutocomplete , TagInputComponentWithHooks , TagInputComponentWithMaxItems , TagInputComponentWithModelAsStrings , TagInputComponentWithOnlyAutocomplete , TagInputComponentWithOutputs , TagInputComponentWithPlaceholder , TagInputComponentWithTemplate , TagInputComponentWithTransformer , TagInputComponentWithValidation , TagInputComponentEditable , TestModule } from 's' ; describe ( 's' , ( ) => { const match = jasmine . objectContaining ; beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ] , imports : [ BrowserAnimationsModule , TestModule ] } ) ; } ) ; beforeEach ( async ( ( ) => { TestBed . compileComponents ( ) ; } ) ) ; function getComponent ( fixture ) { fixture . detectChanges ( ) ; tick ( ) ; fixture . detectChanges ( ) ; tick ( ) ; const component = fixture . debugElement . query ( By . directive ( TagInputComponent ) ) . componentInstance as TagInputComponent ; component . ngAfterViewInit ( ) ; fixture . detectChanges ( ) ; tick ( ) ; return component ; } describe ( 's' , ( ) => { it ( 's' , fakeAsync ( ( ) => { const fixture < BasicTagInputComponent > = TestBed . createComponent ( BasicTagInputComponent ) ; const component = getComponent ( fixture ) ; expect ( component . items . length ) . toEqual ( 0 ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithPlaceholder > = TestBed . createComponent ( TagInputComponentWithPlaceholder ) ; const component = getComponent ( fixture ) ; expect ( component . items . length ) . toEqual ( 0 ) ; expect ( component . inputForm . input . nativeElement . getAttribute ( 's' ) ) . toEqual ( 's' ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < BasicTagInputComponent > = TestBed . createComponent ( BasicTagInputComponent ) ; const component = < TagInputComponent > getComponent ( fixture ) ; const onTouched = jasmine . createSpy ( 's' ) ; component . registerOnTouched ( onTouched ) ; component . blur ( ) ; expect ( onTouched ) . toHaveBeenCalled ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , fakeAsync ( async ( ) => { const fixture < BasicTagInputComponent > = TestBed . createComponent ( BasicTagInputComponent ) ; const component = getComponent ( fixture ) ; const value = 's' ; component . setInputValue ( value ) ; expect ( component . inputForm . form . valid ) . toEqual ( true ) ; await component . onAddingRequested ( false , value ) . catch ( ) ; tick ( ) ; fixture . detectChanges ( ) ; expect ( component . inputForm . form . controls . item . value ) . toEqual ( 's' ) ; expect ( fixture . componentInstance . items . length ) . toEqual ( 0 ) ; expect ( component . items . length ) . toEqual ( 0 ) ; } ) ) ; it ( 's' , fakeAsync ( async ( ) => { const fixture < TagInputComponentWithMaxItems > = TestBed . createComponent ( TagInputComponentWithMaxItems ) ; const component = getComponent ( fixture ) ; const value = 's' ; component . setInputValue ( value ) ; await component . onAddingRequested ( false , value ) . catch ( ( ) => { } ) ; fixture . detectChanges ( ) ; expect ( fixture . componentInstance . items . length ) . toEqual ( 0 ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , ( ) => { const fixture < TagInputComponentWithOutputs > = TestBed . createComponent ( TagInputComponentWithOutputs ) ; const itemName = 's' ; fakeAsync ( async ( done ) => { const component = getComponent ( fixture ) ; const control = component . inputForm . form . get ( 's' ) as FormControl ; control . setValue ( itemName ) ; component . onAdd . subscribe ( item => { expect ( item ) . toEqual ( itemName ) ; done ( ) ; } ) ; await component . onAddingRequested ( false , itemName ) ; tick ( ) ; discardPeriodicTasks ( ) ; } ) ; } ) ; it ( 's' , ( ) => { const fixture < BasicTagInputComponent > = TestBed . createComponent ( BasicTagInputComponent ) ; return fakeAsync ( async ( ) => { const component = getComponent ( fixture ) ; const item = 's' ; component . setInputValue ( item ) ; await component . onAddingRequested ( false , item ) ; tick ( ) ; fixture . detectChanges ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { let fixture < BasicTagInputComponent > ; let tagName ; let item ; let component ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BasicTagInputComponent ) ; tagName = 's' ; } ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; component . removeItem ( tagName , 0 ) ; fixture . detectChanges ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; expect ( component . inputForm . isInputFocused ( ) ) . toEqual ( true ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; component . onRemove . subscribe ( tag => { expect ( tag ) . toEqual ( tagName ) ; } ) ; component . removeItem ( tagName ) ; tick ( ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; component . removeItem ( tagName , 0 ) ; expect ( component . selectedTag ) . toBe ( undefined ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , fakeAsync ( async ( ) => { const fixture < TagInputComponentWithValidation > = TestBed . createComponent ( TagInputComponentWithValidation ) ; const component = getComponent ( fixture ) ; const value = 's' ; component . setInputValue ( value ) ; expect ( component . inputForm . form . valid ) . toBe ( false ) ; await component . onAddingRequested ( false , value ) . catch ( ( ) => { } ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; const invalid = 's' ; component . setInputValue ( 's' ) ; await component . onAddingRequested ( false , invalid ) . catch ( ( ) => { } ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . inputForm . form . valid ) . toBe ( false ) ; const valid = 's' ; component . setInputValue ( valid ) ; expect ( component . inputForm . form . valid ) . toBe ( true ) ; await component . onAddingRequested ( false , valid ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithValidation > = TestBed . createComponent ( TagInputComponentWithValidation ) ; const component = getComponent ( fixture ) ; const value = 's' ; component . setInputValue ( value ) ; expect ( component . inputForm . form . valid ) . toBe ( false ) ; const invalid = 's' ; component . setInputValue ( invalid ) ; expect ( component . inputForm . form . valid ) . toBe ( false ) ; const valid = 's' ; component . setInputValue ( valid ) ; expect ( component . inputForm . form . valid ) . toBe ( true ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( async ( ) => { const fixture < TagInputComponentWithTransformer > = TestBed . createComponent ( TagInputComponentWithTransformer ) ; const component = getComponent ( fixture ) ; component . setInputValue ( 's' ) ; await component . onAddingRequested ( false , 's' ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . items [ 0 ] ) . toEqual ( match ( { display : 's' , value : 's' } ) ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { let keyUp = new Event ( 's' ) , keyDown = new Event ( 's' ) , fixture < BasicTagInputComponent > , component ; keyDown [ 's' ] = 0 ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BasicTagInputComponent ) ; } ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; keyDown [ 's' ] = 0 ; component . inputForm . input . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; keyDown [ 's' ] = 0 ; component . tags . last . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; expect ( component . inputForm . isInputFocused ( ) ) . toEqual ( true ) ; keyDown [ 's' ] = 0 ; component . inputForm . input . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; component . tags . last . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . items . length ) . toEqual ( 0 ) ; expect ( component . selectedTag ) . toBe ( undefined ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; keyDown [ 's' ] = 0 ; component . inputForm . input . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; component . tags . last . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; keyDown [ 's' ] = 0 ; component . tags . first . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; keyDown [ 's' ] = 0 ; component . tags . last . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; expect ( component . inputForm . isInputFocused ( ) ) . toEqual ( true ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; keyDown [ 's' ] = 0 ; component . inputForm . input . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( 's' ) ; keyDown [ 's' ] = 0 ; component . tags . last . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; expect ( component . inputForm . isInputFocused ( ) ) . toEqual ( true ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithTemplate > = TestBed . createComponent ( TagInputComponentWithTemplate ) ; const component = getComponent ( fixture ) ; expect ( component . items . length ) . toEqual ( 0 ) ; expect ( document . querySelectorAll ( 's' ) . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { let keyUp = new Event ( 's' ) ; keyUp [ 's' ] = 0 ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithAutocomplete > = TestBed . createComponent ( TagInputComponentWithAutocomplete ) ; const component = getComponent ( fixture ) ; expect ( component . dropdown . autocompleteItems . length ) . toEqual ( 0 ) ; expect ( document . querySelector ( 's' ) ) . toBeTruthy ( ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithAutocomplete > = TestBed . createComponent ( TagInputComponentWithAutocomplete ) ; const component = getComponent ( fixture ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; tick ( ) ; const dropdown = document . querySelector ( 's' ) ; const items = document . querySelectorAll ( 's' ) ; expect ( dropdown ) . toBeDefined ( ) ; expect ( component . dropdown . items . length ) . toEqual ( 0 ) ; expect ( items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithAutocomplete > = TestBed . createComponent ( TagInputComponentWithAutocomplete ) ; const component = getComponent ( fixture ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . dropdown . items . length ) . toEqual ( 0 ) ; component . dropdown . dropdown . hide ( ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . dropdown . items . length ) . toEqual ( 0 ) ; component . dropdown . dropdown . hide ( ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . dropdown . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithAutocomplete > = TestBed . createComponent ( TagInputComponentWithAutocomplete ) ; const component = getComponent ( fixture ) ; expect ( component . dropdown ) . toBeDefined ( ) ; component . dropdown . ngAfterViewInit ( ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; const dropdown = component . dropdown . dropdown ; tick ( ) ; const item = dropdown . menu . items . first ; dropdown . menu . state . dropdownState . onItemClicked . emit ( item ) ; tick ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , ( ) => { const fixture < TagInputComponentWithOnlyAutocomplete > = TestBed . createComponent ( TagInputComponentWithOnlyAutocomplete ) ; return fakeAsync ( async ( ) => { const component = getComponent ( fixture ) ; const value = 's' ; component . setInputValue ( value ) ; await component . onAddingRequested ( false , value ) ; expect ( component . items . length ) . toEqual ( 0 ) ; tick ( ) ; component . setInputValue ( value ) ; await component . onAddingRequested ( true , value ) ; expect ( component . items . length ) . toEqual ( 0 ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithModelAsStrings > = TestBed . createComponent ( TagInputComponentWithModelAsStrings ) ; const component = getComponent ( fixture ) ; component . appendTag ( { display : 's' , value : 's' } ) ; expect ( component . items [ 0 ] ) . toEqual ( 's' ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , fakeAsync ( ( ) => { const fixture < TagInputComponentWithAddOnBlur > = TestBed . createComponent ( TagInputComponentWithAddOnBlur ) ; const component = getComponent ( fixture ) ; component . setInputValue ( 's' ) ; component . inputForm . onBlur . emit ( ) ; tick ( 0 ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { let keyUp = new Event ( 's' ) ; keyUp [ 's' ] = 0 ; const fixture < TagInputComponentWithAddOnBlur > = TestBed . createComponent ( TagInputComponentWithAddOnBlur ) ; const component = getComponent ( fixture ) ; component . setInputValue ( 's' ) ; component . dropdown . show ( ) ; fixture . detectChanges ( ) ; tick ( ) ; expect ( component . dropdown . isVisible ) . toEqual ( true ) ; component . inputForm . onBlur . emit ( ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { let fixture < TagInputComponentWithHooks > ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( TagInputComponentWithHooks ) ; } ) ; it ( 's' , ( ) => { fakeAsync ( async ( ) => { const component = getComponent ( fixture ) ; const subject = new Subject ( ) ; const tag = component . createTag ( 's' ) ; component . onAdding = ( ) => { return subject ; } ; await component . onAddingRequested ( false , tag ) ; expect ( component . items . length ) . toBe ( 0 ) ; subject . next ( tag ) ; expect ( component . items . length ) . toBe ( 0 ) ; } ) ; } ) ; it ( 's' , ( ) => { fakeAsync ( async ( ) => { const component = getComponent ( fixture ) ; const subject = new Subject ( ) ; component . onRemoving = ( ) => { return subject ; } ; const tag = component . items [ 0 ] ; await component . onRemoveRequested ( tag , 0 ) ; expect ( component . items . length ) . toBe ( 0 ) ; subject . next ( tag ) ; expect ( component . items . length ) . toBe ( 0 ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { let keyDown = new Event ( 's' ) , fixture < TagInputComponentEditable > , component ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( TagInputComponentEditable ) ; } ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; component . tags . first . toggleEditMode ( ) ; component . tags . first . onKeyDown . subscribe ( event => fail ( 's' + event . event . keyCode + 's' ) ) ; keyDown [ 's' ] = 0 ; component . tags . first . element . nativeElement . dispatchEvent ( keyDown ) ; keyDown [ 's' ] = 0 ; component . tags . first . element . nativeElement . dispatchEvent ( keyDown ) ; keyDown [ 's' ] = 0 ; component . tags . first . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . tags . first . editing ) . toEqual ( true ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; it ( 's' , fakeAsync ( ( ) => { component = getComponent ( fixture ) ; expect ( component . selectedTag ) . toEqual ( undefined ) ; component . tags . first . toggleEditMode ( ) ; keyDown [ 's' ] = 0 ; component . tags . first . element . nativeElement . dispatchEvent ( keyDown ) ; expect ( component . tags . first . editing ) . toEqual ( false ) ; expect ( component . items . length ) . toEqual ( 0 ) ; discardPeriodicTasks ( ) ; } ) ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O $DoneFn$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O $string$ O O $TagModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O $Event$ O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TagInputComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HighlightPipe } from 's' ; describe ( 's' , ( ) => { let pipe ; beforeEach ( ( ) => { pipe = new HighlightPipe ( ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , 's' ) ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , 's' ) ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { const str = 's' ; expect ( pipe . transform ( str , 's' ) ) . toEqual ( str ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O $HighlightPipe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ;	O O O
import 's' ; import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const require ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ;	O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O