export const availableProviders = [ 's' , 's' ] ;	O O $string[]$ O O O O O O O
export const availableParsers = [ 's' , 's' ] export const availableParserInputs = [ 's' , 's' ]	O O $string[]$ O O O O O O O O $string[]$ O O O O O O
import { availableProviders } from 's' ; import { availableParsers , availableParserInputs } from 's' ; export const userConfiguration = { type : 's' , properties : { version : { type : 's' } , parserType : { type : 's' , default : 's' , enum : availableParsers . concat ( 's' ) } , configTitle : { type : 's' , default : 's' } , steamCategory : { type : 's' , default : 's' } , executableLocation : { type : 's' , default : 's' } , executableModifier : { type : 's' , default : 's' } , romDirectory : { type : 's' , default : 's' } , steamDirectory : { type : 's' , default : 's' } , startInDirectory : { type : 's' , default : 's' } , userAccounts : { type : 's' , default : { } , properties : { skipWithMissingDataDir : { type : 's' , default : true } , specifiedAccounts : { type : 's' , default : 's' } , useCredentials : { type : 's' , default : true } } } , parserInputs : { type : 's' , default : { } , propertyNames : { enum : availableParserInputs } , patternProperties : { "s" : { "s" : [ "s" , "s" ] } } } , titleFromVariable : { type : 's' , default : { } , properties : { limitToGroups : { type : 's' , default : 's' } , skipFileIfVariableWasNotFound : { type : 's' , default : false } , caseInsensitiveVariables : { type : 's' , default : false } , tryToMatchTitle : { type : 's' , default : false } } } , executableArgs : { type : 's' , default : 's' } , appendArgsToExecutable : { type : 's' , default : true } , imagePool : { type : 's' , default : 's' } , defaultImage : { type : 's' , default : 's' } , localImages : { type : 's' , default : 's' } , localIcons : { type : 's' , default : 's' } , onlineImageQueries : { type : 's' , default : 's' } , imageProviders : { type : 's' , default : < any > [ ] , items : { oneOf : [ { type : 's' , enum : availableProviders } ] } } , titleModifier : { type : 's' , default : 's' } , fuzzyMatch : { type : 's' , default : { } , properties : { use : { type : 's' , default : true } , removeCharacters : { type : 's' , default : true } , removeBrackets : { type : 's' , default : true } , replaceDiacritics : { type : 's' , default : true } } } , advanced : { type : 's' , default : false } , disabled : { type : 's' , default : false } , } } ;	O O $string[]$ O O O O O O $string[]$ O $string[]$ O O O O O O O O O $string$ O O O O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string[]$ O $string[]$ O $complex$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $string[]$ O $string[]$ O O $complex$ O O O O O O O O O O O O O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $any$ O O O O O O O $complex$ O O $complex$ O O O $string$ O O O $string[]$ O $string[]$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O O
import { userConfiguration } from "s" ; import { cloneDeep } from "s" ; export const configPresets = { type : 's' , patternProperties : { "s" : ( ( ) => { let config = cloneDeep ( userConfiguration ) ; delete config . properties . version ; let addStrictValidation = ( data ) => { if ( data [ 's' ] === 's' ) { if ( data [ 's' ] !== undefined ) { const keys = Object . keys ( data [ 's' ] ) ; data [ 's' ] = keys ; data [ 's' ] = false ; for ( const key of keys ) { addStrictValidation ( data [ 's' ] [ key ] ) ; } } else if ( data [ 's' ] !== undefined && data [ 's' ] [ 's' ] !== undefined ) { data [ 's' ] = data [ 's' ] [ 's' ] ; } } } ; addStrictValidation ( config ) ; return config ; } ) ( ) } } ;	O O O O O O O O O $any$ O O O O O O $complex$ O O $string$ O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O O O O O $any$ O O O O O O O O O $any$ O O O O $undefined$ O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O O O $any$ O O O O $string[]$ O $any$ O O O O O O O O O $string$ O $string[]$ O O $void$ O $any$ O O O O $string$ O O O O O O O O $any$ O O O O $undefined$ O $any$ O O O O O O O $undefined$ O O $any$ O O O O $any$ O O O O O O O O O O O $void$ O $any$ O O O $any$ O O O O O O O O
export const customVariables = { type : 's' , patternProperties : { "s" : { type : 's' , patternProperties : { "s" : { type : 's' } } } } } ;	O O $complex$ O O $string$ O O O $complex$ O O O O O $string$ O O O $complex$ O O O O O $string$ O O O O O O O O
import * as fs from 's' ; export function read < T > ( file , fallback ? : T ) { return Promise . resolve ( ) . then ( ( ) => fs . readJson ( file , { throws : true } ) . catch ( ( error : NodeJS . ErrnoException ) => { if ( error . code === "s" ) { return undefined ; } else { throw error ; } } ) . then ( ( data ) => { if ( data === undefined ) { return fallback || null ; } else { return ( data as T ) || null ; } } ) ) ; }	O O O $any$ O O O O O $Promise<any>$ O $any$ O O $string$ O $T$ O O $any$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O $string$ O O $boolean$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $undefined$ O O O O O $any$ O O O O O $any$ O O $any$ O O O O O $any$ O $undefined$ O O O $T$ O O O O O O O O $any$ O $any$ O O O O O O O O O O
import * as fs from 's' ; export function write ( filename , value , replacer ? ) { return Promise . resolve ( ) . then ( ( ) => fs . outputJson ( filename , value , { spaces : "s" , EOL : "s" , replacer } as any ) ) ; }	O O O $any$ O O O O O $Promise<any>$ O $string$ O $any$ O $any$ $any$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O $string$ O $any$ O O $string$ O O O $string$ O O O $any$ O O O O O O O
export interface ValidatorModifier < T > { latestVersion : string | number , controlProperty : string , fields : { [ controlValue ] : { [ fields ] : { method ? : ( oldValue , self : T ) => any , oldValuePath ? : string } } } } export interface userAccountData { name : string , 0 : string , accountID : string } export interface SteamTree < T > { tree : { [ steamDirectory ] : { [ userId ] : T } } , numberOfUsers : number }	O O $any$ O $any$ O O $complex$ O O O O O $string$ O O O $complex$ O O O $string$ O O O O $string$ O O O $any$ O O O $any$ O $T$ O $any$ O O O O $string$ O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $complex$ O O O $string$ O O O O $string$ O O $any$ O O O $number$ O O O
import { ValidatorModifier } from "s" ; import * as Ajv from "s" ; import * as _ from "s" ; export class Validator < T = object > { private ajv : Ajv . Ajv ; private validationFn : Ajv . ValidateFunction | null = null ; private modifier : ValidatorModifier < T > | null = null ; constructor ( schema ? , modifier ? < T > , options : Ajv . Options = { removeAdditional : "s" , useDefaults : true } ) { this . ajv = new Ajv ( options ) ; if ( schema !== undefined ) { this . setSchema ( schema ) ; } if ( modifier !== undefined ) { this . setModifier ( modifier ) ; } } public setSchema ( schema ) { if ( schema ) { this . validationFn = this . ajv . compile ( schema ) ; } else { this . validationFn = null ; } return this ; } public setModifier ( modifier < T > ) { if ( modifier ) { this . modifier = modifier ; } else { this . modifier = null ; } return this ; } public validate ( data ) { if ( this . modifier ) { while ( this . modify ( data ) ) { } _ . set ( data , this . modifier . controlProperty , this . modifier . latestVersion ) ; } if ( this . validationFn ) { this . validationFn ( data ) ; } return this ; } get errors ( ) { if ( this . validationFn ) { return this . validationFn . errors || null ; } else { return null ; } } get errorString ( ) { const errors = this . errors ; return errors !== null ? JSON . stringify ( errors , null , "s" ) : "s" ; } public isValid ( ) { return this . errors === null ; } public getDefaultValues ( ) { const data = { } ; if ( this . validationFn ) { this . validationFn ( data ) ; if ( this . modifier ) { _ . set ( data , this . modifier . controlProperty , this . modifier . latestVersion ) ; } } return data as T ; } private modify ( data ) { const controlValue = _ . get ( data , this . modifier ! . controlProperty , undefined ) ; const modifierFieldSet = this . modifier ! . fields [ controlValue ] ; if ( modifierFieldSet ) { for ( const key in modifierFieldSet ) { const fieldData = modifierFieldSet [ key ] ; if ( fieldData . method ) { _ . set ( data , key , fieldData . method ( _ . get ( data , typeof fieldData . oldValuePath === "s" ? fieldData . oldValuePath : key , undefined , ) , data , ) , ) ; } else if ( typeof fieldData . oldValuePath === "s" ) { _ . set ( data , key , _ . get ( data , fieldData . oldValuePath , undefined ) ) ; } } return ! _ . isEqual ( controlValue , _ . get ( data , this . modifier ! . controlProperty , undefined ) ) ; } else { return false ; } } }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $ValidatorModifier<T>$ O $any$ O $any$ O O O O O O O O $object$ $object$ O $ValidatorModifier<T>$ $ValidatorModifier$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O O O O O O O $any$ O O $any$ O $any$ O O O O $object$ O $undefined$ O O O O $this$ O $object$ O O O O O $ValidatorModifier<T>$ O $undefined$ O O O O $this$ O $ValidatorModifier<T>$ O O O O O $this$ O $object$ O O O O $object$ O O O O $any$ O O O $any$ O $any$ O $object$ O O O O O O O $any$ O O O O O O O O O $this$ O $ValidatorModifier$ O $any$ O O O O O $ValidatorModifier<T>$ O O O O $ValidatorModifier<T>$ O $ValidatorModifier<T>$ O O O O O O $ValidatorModifier<T>$ O O O O O O O O O $this$ O $object$ O O O O O O $ValidatorModifier<T>$ O O O O O O $boolean$ O $object$ O O O O $any$ O $any$ O $object$ O O O $ValidatorModifier<T>$ O $string$ O O O $ValidatorModifier<T>$ O $complex$ O O O O O O O $any$ O O O O $any$ O $object$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $string$ O O O O $any$ O O O $any$ O O $any$ O O O $JSON$ O $complex$ O $any$ O O O O O O O O O O $boolean$ O O O O O O $any$ O O O O O $T$ O O O O ${}$ O O O O O O O O $any$ O O O O $any$ O ${}$ O O O O O O $ValidatorModifier<T>$ O O $any$ O $any$ O ${}$ O O O $ValidatorModifier<T>$ O $string$ O O O $ValidatorModifier<T>$ O $complex$ O O O O O ${}$ O $any$ O O O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $ValidatorModifier<T>$ O O $string$ O $undefined$ O O O $complex$ O O O $ValidatorModifier<T>$ O O $complex$ O $any$ O O O O $complex$ O O O O O $string$ O $complex$ O O O $complex$ O $complex$ O $string$ O O O O $complex$ O $any$ O O $any$ O $any$ O $any$ O $string$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O $string$ O O O $complex$ O $string$ O $string$ O $undefined$ O O O $any$ O O O O O O O O O O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $complex$ O $string$ O $undefined$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ValidatorModifier<T>$ O O $string$ O $undefined$ O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { configPresets } from "s" ; import { customVariables } from "s" ; import * as json from "s" ; let isValid = true ; const validator = new json . Validator ( undefined , undefined , { useDefaults : false } ) ; json . read ( 's' ) . then ( ( data ) => { if ( data !== null && ! validator . setSchema ( configPresets ) . validate ( data ) . isValid ( ) ) { throw new Error ( `template` ) ; } } ) . catch ( ( error ) => { process . stderr . write ( `template` ) ; isValid = false ; } ) . then ( ( ) => { return json . read ( 's' ) ; } ) . then ( ( data ) => { if ( data !== null && ! validator . setSchema ( customVariables ) . validate ( data ) . isValid ( ) ) { throw new Error ( `template` ) ; } } ) . catch ( ( error ) => { process . stderr . write ( `template` ) ; isValid = false ; } ) . then ( ( ) => { process . exit ( isValid ? 0 : 0 ) ; } ) ;	O O $complex$ O O O O O O $complex$ O O O O O O O $any$ O O O O $boolean$ O O O O $Validator<object>$ O O $any$ O $any$ O $undefined$ O $undefined$ O O $boolean$ O O O O O $any$ O $Promise<any>$ O O O O O O O $any$ O O O O O $any$ O O O O $Validator<object>$ O $Validator<object>$ O $complex$ O O $Validator<object>$ O $any$ O O $boolean$ O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O O $Error$ O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O O $any$ O $Promise<any>$ O O O O O O O O O O $any$ O O O O O $any$ O O O O $Validator<object>$ O $Validator<object>$ O $complex$ O O $Validator<object>$ O $any$ O O $boolean$ O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O O $Error$ O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O
'js' module . exports = { plugins : [ require ( 's' ) ( { browsers : [ 's' ] } ) ] } ;	O $complex$ O $complex$ O O $any[]$ O O $any$ O O O O O $string[]$ O O O O O O O O O
export interface languageStruct { about : { component : { info__md : string [ ] } } , preview : { component : { filter : string , by : string , refreshImages : string , addLocalImages : string , retryDownload : string , generateAppList : string , saveAppList : string , removeAppList : string , remainingImages : string , stopUrlRetrieving : string } , service : { info : { listIsBeingGenerated : string , listIsBeingSaved : string , listIsBeingRemoved : string , listIsEmpty : string populatingVDF_List : string , creatingBackups : string , readingVDF_Files : string , mergingVDF_entries : string , removingVDF_entries : string , writingVDF_entries : string , updatingKnownSteamDirList : string , retryingDownload__i : string , disabledConfigurations__i : string , invalidConfigurations__i : string , executingParsers : string , shutdownSteam : string , noParserConfigurations : string , parserFoundNoFiles : string , allImagesRetrieved : string , providerTimeout__i : string , noAccountsWarning : string } , errors : { populatingVDF_entries : string , savingVDF_entries : string , fatalError : string , knownSteamDirListIsEmpty : string , retryingDownload__i : string providerError__i : string unknownProviderError__i : string } , success : { writingVDF_entries : string , removingVDF_entries : string } } } , globParser : { inputTitle : string , docs__md : { self : string [ ] , input : string [ ] } , errors : { noTitle__md : string , moreThanOneTitle__md : string , noStarNextToTitle__md : string , noAnyCharNextToTitle__md : string , noWindowsSlash__md : string , noGlobstarOnBothSides__md : string , noBracedDirSetOnBothSides__md : string , noBracedDirSetOrGlobstarOnBothSides__md : string , noEmptyPattern__md : string , noEmptyCharRange__md : string , noStarInPatternNextToTitle__md : string , noAnyCharInPatternNextToTitle__md : string } } , globRegexParser : { inputTitle : string , docs__md : { self : string [ ] , input : string [ ] } , errors : { noRegex__md : string , moreThanOneRegex__md : string , noStarNextToRegex__md : string , noAnyCharNextToRegex__md : string , noWindowsSlash__md : string , noGlobstarOnBothSides__md : string , noBracedDirSetOnBothSides__md : string , noBracedDirSetOrGlobstarOnBothSides__md : string , noEmptyPattern__md : string , noEmptyCharRange__md : string , noStarInPatternNextToRegex__md : string , noAnyCharInPatternNextToRegex__md : string } } , logger : { component : { noMessages : string , error : string , info : string , success : string , fuzzy : string , textWrap : string , autoscroll : string , clearLog : string } } , customVariables : { service : { error : { failedToDownload__i : string , writingError : string , loadingError : string , corruptedVariables__i : string } , info : { downloaded : string } } } , configPresets : { service : { error : { failedToDownload__i : string , writingError : string , loadingError : string , corruptedVariables__i : string } , info : { downloaded : string } } } , settings : { component : { label : { general : string , imageProviders : string , fuzzy : string } , text : { offlineMode : string , removeApps_desc : string , removeApps_btn : string , preloadImages : string , fuzzy_verbose : string , fuzzy_filter : string , enabledProviders : string , selectLanguage : string , resetFuzzy_desc : string , resetFuzzy_btn : string , showSteamImages : string , clearLogOnTest : string } , placeholder : { noProviders : string } } , service : { error : { writingError : string , readingError : string , corruptedSettings__i : string } } } , nav : { component : { about : string , preview : string , logger : string , settings : string , parsers : string , noTitle : string } } , parsers : { component : { buttons : { save : string , copy : string , testParser : string , delete : string , moveUp : string , moveDown : string , faq : string , undoChanges : string , undoDelete : string , toClipboard : string } , docs__md : { intro : string [ ] , faq : string [ ] , parserType : string [ ] , configTitle : string [ ] , steamCategory : string [ ] , executableLocation : string [ ] , romDirectory : string [ ] , steamDirectory : string [ ] , startInDirectory : string [ ] , userAccounts : string [ ] , titleModifier : string [ ] , executableModifier : string [ ] , titleFromVariable : string [ ] , fuzzyMatch : string [ ] , executableArgs : string [ ] , onlineImageQueries : string [ ] , imageProviders : string [ ] , imagePool : string [ ] , defaultImage : string [ ] , localImages : string [ ] , localIcons : string [ ] } , info : { testStarting__i : string , testCompleted : string , nothingWasFound : string , copiedToClipboard : string , } , error : { missingAccounts__i : string , missingAccountInfo__i : string , noAccountsWarning : string , failedToMatch : string , failedFileInfo__i : string , testFailed : string , cannotTestInvalid : string , cannotCopyInvalid : string , failedToCopy : string } success : { foundAccounts__i : string , foundAccountInfo__i : string , steamCategory__i : string , steamCategoryInfo__i : string , extractedTitle__i : string , fuzzyTitle__i : string , finalTitle__i : string , filePath__i : string , completeShortcut__i : string , firstImageQuery__i : string , imageQueries__i : string , resolvedDefaultImageGlob__i : string , resolvedDefaultImageGlobInfo__i : string , defaultImageResolved__i : string , resolvedImageGlob__i : string , resolvedImageGlobInfo__i : string , localImagesResolved__i : string , localImageInfo__i : string resolvedIconGlob__i : string , resolvedIconGlobInfo__i : string , localIconsResolved__i : string , localIconInfo__i : string , } , label : { parserType : string , configTitle : string , steamCategory : string , executableLocation : string , executableModifier : string , romDirectory : string , steamDirectory : string , startInDirectory : string , userAccounts : string , titleFromVariable : string , titleModifier : string , fuzzyMatch : string , executableArgs : string , onlineImageQueries : string , imageProviders : string , imagePool : string , defaultImage : string , localImages : string , localIcons : string } , placeholder : { parserType : string , imageProviders : string } , text : { skipWithMissingDataDir : string , useCredentials : string , tryToMatchTitle : string , skipFileIfVariableWasNotFound : string , caseInsensitiveVariables : string , fuzzy_use : string , fuzzy_removeCharacters : string , fuzzy_removeBrackets : string , fuzzy_replaceDiacritic : string , appendArgsToExecutable : string , disabled : string , advanced : string , noTitle : string } } , service : { error : { savingConfiguration : string , readingConfiguration : string , corruptedConfiguration__i : string } , validationErrors : { parserType__md : string , configTitle__md : string , parserInput : { noInput : string , inputNotAvailable__i : string , incorrectParser : string , } , romDir__md : string , steamDir__md : string , startInDir__md : string , executable__md : string imagePool__md : string , titleModifier__md : string , executableModifier__md : string , variableString__md : string , imageProviders__md : string , unhandledValidationKey__md : string } , text : { noTitle : string } } } , fuzzyMatcher : { info : { downloading : string , successfulDownload : string , checkingIfListIsUpToDate : string , listIsOutdated : string , listIsUpToDate : string , match__i : string , equal__i : string , notEqual__i : string } , error : { fatalError : string , totalGamesIsUndefined : string } } , fileParser : { error : { parserNotFound__i : string , tooManyFieldGlobs__md : string , parserIsRequired__md : string , noWinSlashes__md : string } } , imageProvider : { error : { webWorkerError__i : string , unknownWebWorkerError : string , } } , vdfManager : { error : { noUsersFound : string , emptyDirectoryList : string , couldNotMergeEntries__i : string , couldNotRemoveEntries__i : string } } , vdfFile : { error : { readingVdf__i : string , writingVdf__i : string , corruptedVdf__i : string , creatingBackup__i : string , unsupportedMimeType__i : string , imageError__i : string } } , helpers : { error : { noUserIdsInDir__i : string , } } } export interface languageContainer { [ language ] : languageStruct }	O O $any$ O $complex$ O O $complex$ O O $string[]$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O $string$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $complex$ O O $string[]$ O O O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $string[]$ O O O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O O $any$ O O $string$ O O $any$ O
export interface AlertMessage { type : string , text : string , timeout : number }	O O $any$ O $string$ O O O $string$ O O O $number$ O O O
export interface LogMessage { type : string , text : string } ; export interface LogSettings { showErrors : boolean , showSuccesses : boolean , showInfo : boolean , showFuzzy : boolean , textWrap : boolean , autoscroll : boolean , currentScrollValue : number } ; export interface MessageSettings { invokeAlert ? : boolean , alertTimeout ? : number , doNotAppendToLog ? : boolean }	O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O O O O $any$ O $boolean$ O O O O $number$ O O O O $boolean$ O O O O
export interface UserConfiguration { parserType : string , configTitle : string , steamCategory : string , executableLocation : string , executableModifier : string , romDirectory : string , steamDirectory : string , startInDirectory : string , userAccounts : { specifiedAccounts : string , skipWithMissingDataDir : boolean , useCredentials : boolean } , parserInputs : { [ inputKey ] : string } , titleFromVariable : { limitToGroups : string , skipFileIfVariableWasNotFound : boolean , caseInsensitiveVariables : boolean , tryToMatchTitle : boolean } , fuzzyMatch : { use : boolean , removeCharacters : boolean , removeBrackets : boolean , replaceDiacritics : boolean } , onlineImageQueries : string , imageProviders : string [ ] , executableArgs : string , imagePool : string , appendArgsToExecutable : boolean , defaultImage : string , localImages : string , localIcons : string , titleModifier : string , disabled : boolean , advanced : boolean }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O O $complex$ O O O $string$ O O O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O $string$ O O O $string[]$ O O O O O $string$ O O O $string$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O
import { userAccountData } from 's' ; export interface ParsedUserConfigurationFile { executableLocation : string , modifiedExecutableLocation : string , startInDirectory : string , filePath : string , extractedTitle : string , fuzzyTitle : string , finalTitle : string , argumentString : string , resolvedLocalImages : string [ ] , resolvedLocalIcons : string [ ] , onlineImageQueries : string [ ] , steamCategories : string [ ] , imagePool : string , resolvedDefaultImages : string [ ] , defaultImage : string , localImages : string [ ] , localIcons : string [ ] } export interface ParsedUserConfiguration { configurationTitle : string , imageProviders : string [ ] , steamDirectory : string , appendArgsToExecutable : boolean , foundUserAccounts : userAccountData [ ] , missingUserAccounts : string [ ] , files : ParsedUserConfigurationFile [ ] , failed : string [ ] } export interface ParserInputField { [ inputKey ] : { label : string , info ? : string , forcedInput ? : string , validationFn ? : ( inputData , suppressSlashError ? ) => null | string } } export interface ParserInfo { title : string , info ? : string , inputs ? : ParserInputField } export interface ParsedData { success : { filePath : string , extractedTitle : string } [ ] , failed : string [ ] } export interface ParserVariableData { executableLocation : string , startInDirectory : string , steamDirectory : string , romDirectory : string , extractedTitle : string , fuzzyTitle : string , finalTitle : string , filePath : string } export type DirectoryVariables = 's' | 's' | 's' | 's' | 's' ; export type NameVariables = 's' | 's' ; export type ExtensionVariables = 's' | 's' ; export type PathVariables = 's' | 's' ; export type ParserVariables = 's' | 's' | 's' ; export type OtherVariables = 's' ; export type AllVariables = DirectoryVariables | NameVariables | ExtensionVariables | PathVariables | ParserVariables | OtherVariables ; export interface GenericParser { getParserInfo ( ) : ParserInfo , execute : ( directory , inputs : { [ key ] : any } , cache ? : { [ key ] : any } ) => Promise < ParsedData > }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string$ O O O $string[]$ O O O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O O O $any$ O $string$ O O O $string[]$ O O O O O $string$ O O O $boolean$ O O O $userAccountData[]$ O $any$ O O O $string[]$ O O O O O $ParsedUserConfigurationFile[]$ O $any$ O O O $string[]$ O O O O O O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O $string$ O O O O $string$ O O O $string$ O $boolean$ $boolean$ O O O O O O O O O $any$ O $string$ O O O $string$ O O O O $ParserInputField$ O O $any$ O O O $any$ O $complex$ O O $string$ O O O $string$ O O O O O O $string[]$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $ParserInfo$ O O O $any$ O $Promise<ParsedData>$ O O $string$ O $complex$ O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O $PromiseConstructor$ O $any$ O O
import { Observable , BehaviorSubject } from "s" ; export type ImageDownloadStatus = 's' | 's' | 's' | 's' ; export interface ImageContent { imageProvider : 's' | 's' | 's' | 's' | 's' , imageUploader ? : string , imageUrl : string , loadStatus : ImageDownloadStatus } ; export interface ImagesStatusAndContent { retrieving : boolean , defaultImageProviders : string [ ] , searchQueries : string [ ] , content : ImageContent [ ] } export interface AppImages { [ extractedTitle ] : ImagesStatusAndContent } ; export interface PreviewDataAppImage { steam : ImageContent , default : ImageContent , imagePool : string , imageIndex : number } export interface PreviewDataApp { entryId : number , status : 's' | 's' | 's' , configurationTitle : string , steamCategories : string [ ] , imageProviders : string [ ] , startInDirectory : string , executableLocation : string , title : string , argumentString : string , currentIconIndex : number , icons : string [ ] , images : PreviewDataAppImage } export interface PreviewDataApps { [ appID ] : PreviewDataApp } export interface PreviewDataUser { username : string , apps : PreviewDataApps } export interface PreviewData { [ steamDirectory ] : { [ userID ] : PreviewDataUser } } export interface PreviewVariables { listIsBeingGenerated : boolean , listIsBeingSaved : boolean , listIsBeingRemoved : boolean , numberOfListItems : number , numberOfQueriedImages : number }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O $string$ O O O O $string$ O O O $ImageDownloadStatus$ O $any$ O O O O $any$ O $boolean$ O O O $string[]$ O O O O O $string[]$ O O O O O $ImageContent[]$ O $any$ O O O O O $any$ O O $string$ O O $any$ O O O O $any$ O $ImageContent$ O $any$ O $ImageContent$ O $any$ O $string$ O O O $number$ O O O O O $any$ O $number$ O O O O O O O O O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string[]$ O O O O O $PreviewDataAppImage$ O $any$ O O O $any$ O O $string$ O O $any$ O O O $any$ O $string$ O O O $PreviewDataApps$ O $any$ O O O $any$ O O $string$ O O O O $string$ O O $any$ O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $number$ O O O
import { Injectable } from 's' ; import { DatePipe } from 's' ; import { BehaviorSubject } from 's' ; import { AlertMessage , LogMessage , MessageSettings , LogSettings } from 's' ; @ Injectable ( ) export class LoggerService { private alertMessage : BehaviorSubject < AlertMessage > = new BehaviorSubject < AlertMessage > ( undefined ) ; private logMessages : BehaviorSubject < LogMessage [ ] > = new BehaviorSubject < LogMessage [ ] > ( [ ] ) ; private hideAfterNavigationChange : boolean = false ; private logSettings : LogSettings ; constructor ( public datePipe ) { this . logSettings = { showErrors : true , showInfo : true , showSuccesses : true , showFuzzy : false , autoscroll : false , textWrap : false , currentScrollValue : 0 } ; } success ( message , settings ? ) { this . postMessage ( 's' , message , settings ) ; } info ( message , settings ? ) { this . postMessage ( 's' , message , settings ) ; } error ( message : string | Error , settings ? ) { this . postMessage ( 's' , message , settings ) ; } fuzzy ( message , settings ? ) { this . postMessage ( 's' , message , settings ) ; } private postMessage ( type : 's' | 's' | 's' | 's' , message , settings ? ) { let keepAfterNavigationChange = false ; let invokeAlert = false ; let doNotAppendToLog = false ; let alertTimeout = 0 ; if ( settings ) { invokeAlert = settings . invokeAlert !== undefined ? settings . invokeAlert : false ; doNotAppendToLog = settings . doNotAppendToLog !== undefined ? settings . doNotAppendToLog : false ; alertTimeout = settings . alertTimeout !== undefined ? settings . alertTimeout : 0 ; } if ( invokeAlert ) { this . alertMessage . next ( { type : type , text : message , timeout : alertTimeout } ) ; } if ( ! doNotAppendToLog ) { let logMessages = this . logMessages . getValue ( ) ; logMessages = logMessages . concat ( { type : type , text : message } ) ; this . logMessages . next ( logMessages ) ; } } clearLog ( ) { this . logMessages . next ( [ ] ) ; } getAlertMessage ( ) { return this . alertMessage . asObservable ( ) ; } getLogMessages ( ) { return this . logMessages . asObservable ( ) ; } getLogSettings ( ) { return this . logSettings ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $undefined$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $boolean$ O O O O O O $LogSettings$ O $any$ O O O O $DatePipe$ O O O O $LogSettings$ O O $true$ O O O $true$ O O O $true$ O O O $false$ O O O $false$ O O O $false$ O O O $number$ O O O O O $void$ O $string$ O $MessageSettings$ $MessageSettings$ O O O O $void$ O O O $string$ O $MessageSettings$ O O O $void$ O $string$ O $MessageSettings$ $MessageSettings$ O O O O $void$ O O O $string$ O $MessageSettings$ O O O $void$ O $complex$ O O O $ErrorConstructor$ O $MessageSettings$ $MessageSettings$ O O O O $void$ O O O $complex$ O $MessageSettings$ O O O $void$ O $string$ O $MessageSettings$ $MessageSettings$ O O O O $void$ O O O $string$ O $MessageSettings$ O O O O $void$ O O O O O O O O O O O $any$ O $MessageSettings$ $MessageSettings$ O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O O $MessageSettings$ O O $boolean$ O $MessageSettings$ O $boolean$ O $undefined$ O $MessageSettings$ O $boolean$ O O O $boolean$ O $MessageSettings$ O $boolean$ O $undefined$ O $MessageSettings$ O $boolean$ O O O $number$ O $MessageSettings$ O $number$ O $undefined$ O $MessageSettings$ O $number$ O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $number$ O $number$ O O O O O O O $boolean$ O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $LogSettings$ O O O O O O $LogSettings$ O O O
import * as _bluebird from 's' ; import 's' ; declare var Zone ; let zone_bluebird = _bluebird . getNewLibraryCopy ( ) ; zone_bluebird . config ( { cancellation : true } ) ; Zone [ Zone . __symbol__ ( 's' ) ] ( zone_bluebird ) ; export const Bluebird = zone_bluebird ;	O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O
export { EnglishLang } from 's' ;	O O $languageContainer$ O O O O
import * as languages from "s" ; import { languageContainer } from "s" ; export class LanguageManager { private availableLanguages : languageContainer = { } ; constructor ( ) { for ( let langData in languages ) { for ( let language in languages [ langData ] ) { this . availableLanguages [ language ] = languages [ langData ] [ language ] ; } } } getAvailableLanguages ( ) { return Object . keys ( this . availableLanguages ) ; } getLanguage ( language ) { if ( this . availableLanguages [ language ] === undefined ) return this . availableLanguages [ this . getAvailableLanguages ( ) [ 0 ] ] ; else return this . availableLanguages [ language ] ; } getDefaultLanguage ( ) { if ( this . availableLanguages [ 's' ] === undefined ) return this . getAvailableLanguages ( ) [ 0 ] ; else return 's' ; } } ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O O $languageContainer$ O $any$ O O O O O O O O O O O $string$ O $any$ O O O O O $string$ O $any$ O $string$ O O O O O $languageContainer$ O $string$ O O $any$ O $string$ O O $string$ O O O O O $string[]$ O O O O $ObjectConstructor$ O $complex$ O O O $languageContainer$ O O O $languageStruct$ O $string$ O O O O O O $languageContainer$ O $string$ O O $undefined$ O O O O $languageContainer$ O O O $string[]$ O O O O O O O O O O O $languageContainer$ O $string$ O O O $string$ O O O O O O O $languageContainer$ O O O O $undefined$ O O O O $string[]$ O O O O O O O O O O O O O
import { GlobalContainer } from "s" ; import { LanguageManager } from "s" ; import * as os from 's' ; export const languageManager = new LanguageManager ( ) ; export const APP = { lang : languageManager . getLanguage ( 's' ) , version : require ( 's' ) [ 's' ] , os : require ( 's' ) ( os . platform ( ) , os . release ( ) ) , arch : os . arch ( ) } ;	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $LanguageManager$ O O $any$ O O O O O $GlobalContainer$ O O $languageStruct$ O $LanguageManager$ O $languageStruct$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O
import { xRequestError , xRequestOptions , xRequestOptionsWithUrl , xRequestResolve } from "s" ; import * as Bluebird from 's' ; export class xRequest { private cancellingPromises : boolean = false ; private promiseRef : Bluebird < any > [ ] = [ ] ; constructor ( private bluebird ? : typeof Bluebird , protected timeout = 0 ) { if ( bluebird === undefined ) { this . bluebird = Bluebird . getNewLibraryCopy ( ) ; this . bluebird . config ( { cancellation : true } ) ; } } get Bluebird ( ) { return this . bluebird ; } private removePromiseRef ( promise < any > ) { if ( ! this . cancellingPromises ) { let index = this . promiseRef . indexOf ( promise ) ; if ( index !== - 0 ) this . promiseRef . splice ( index , 0 ) ; } } addPromise ( promise < any > ) { if ( this . promiseRef . indexOf ( promise ) === - 0 ) { this . promiseRef . push ( promise ) ; promise . finally ( ( ) => this . removePromiseRef ( promise ) ) ; } return promise ; } set promise ( promise < any > ) { this . addPromise ( promise ) ; } cancel ( ) { this . cancellingPromises = true ; this . promiseRef . forEach ( promise => promise . cancel ( ) ) ; this . promiseRef = [ ] ; this . cancellingPromises = false ; } protected parseResponseHeaders ( headers ) { let parsedHeaders = { } ; if ( headers ) { let headerPairs = headers . split ( 's' ) ; for ( let i = 0 ; i < headerPairs . length ; i ++ ) { let index = headerPairs [ i ] . indexOf ( 's' ) ; if ( index > 0 ) { let key = headerPairs [ i ] . substring ( 0 , index ) ; let val = headerPairs [ i ] . substring ( index + 0 ) ; parsedHeaders [ key ] = val ; } } } return parsedHeaders ; } protected makeRequest ( options , delay ) { let self = this ; return this . Bluebird . delay ( delay ) . then ( ( ) => new this . Bluebird < xRequestResolve > ( function ( resolve , reject , onCancel ) { let xhr = new XMLHttpRequest ( ) ; let finalUrl = options . url ; let params = options . params || null ; if ( params && typeof params === 's' ) { params = Object . keys ( params ) . map ( function ( key ) { return encodeURIComponent ( key ) + 's' + encodeURIComponent ( params [ key ] ) ; } ) . join ( 's' ) ; } if ( options . method === 's' && params ) finalUrl = `template` ; xhr . responseType = options . responseType || 's' ; xhr . onload = function ( ) { if ( xhr . status >= 0 && xhr . status < 0 ) { resolve ( xhr . response ) ; } else { reject ( < xRequestError > { config : options , error : { status : xhr . status , statusText : xhr . statusText , url : finalUrl , headers : self . parseResponseHeaders ( xhr . getAllResponseHeaders ( ) ) } , response : xhr . response } ) ; } } ; xhr . onerror = function ( ) { reject ( < xRequestError > { config : options , error : { status : xhr . status , statusText : xhr . statusText , url : finalUrl , headers : self . parseResponseHeaders ( xhr . getAllResponseHeaders ( ) ) } } ) ; } ; xhr . ontimeout = function ( ) { reject ( < xRequestError > { config : options , error : { status : xhr . status , statusText : xhr . statusText , url : finalUrl , headers : self . parseResponseHeaders ( xhr . getAllResponseHeaders ( ) ) } } ) ; } ; xhr . open ( options . method , finalUrl , true ) ; if ( options . headers ) { Object . keys ( options . headers ) . forEach ( function ( key ) { xhr . setRequestHeader ( key , options . headers [ key ] ) ; } ) ; } if ( options . method === 's' ) xhr . send ( null ) ; else xhr . send ( params ) ; onCancel ( ( ) => { xhr . abort ( ) ; } ) ; } ) ) ; } request ( url , options , delay = 0 ) { ( options as xRequestOptionsWithUrl ) . url = url ; return this . makeRequest ( ( options as xRequestOptionsWithUrl ) , delay ) ; } get ( url , params ? : { [ parameter ] : string } , responseType = 's' , delay = 0 ) { return this . request ( url , { headers : null , method : 's' , responseType , params , timeout : this . timeout } , delay ) ; } } ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O $boolean$ O O O O O O $any[]$ O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O $number$ O O O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O $any$ O O O $void$ O $Bluebird$ O O O O O O O O O O $boolean$ O O O $number$ O O O $any[]$ O $number$ O $any$ O O O O $number$ O O O O O O $any[]$ O $complex$ O $number$ O O O O O O $any$ O $Bluebird$ O O O O O O O O O $any[]$ O $number$ O $any$ O O O O O O O O $any[]$ O $number$ O $any$ O O $any$ O $any$ O O O O O O $void$ O $any$ O O O O O $any$ O O O $any$ O $Bluebird$ O O O O O O O $any$ O $any$ O O O $void$ O O O O O $boolean$ O O O O O $any[]$ O $void$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O O O O O O $boolean$ O O O O O ${}$ O $string$ O O O ${}$ O O O O O O $string$ O O O $string[]$ O $string$ O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $number$ O $string[]$ O $number$ O O $number$ O O O O O O $number$ O O O O O $string$ O $string[]$ O $number$ O O $string$ O O O $number$ O O O $string$ O $string[]$ O $number$ O O $string$ O $number$ O O O O ${}$ O $string$ O O $string$ O O O O O ${}$ O O O $any$ O $xRequestOptionsWithUrl$ O $number$ O O O $this$ O O O O O O $any$ O $any$ O $number$ O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $XMLHttpRequest$ O O $complex$ O O O O $string$ O $xRequestOptionsWithUrl$ O $string$ O O $Object$ O $xRequestOptionsWithUrl$ O $complex$ O O O O O $Object$ O O $Object$ O O O O $Object$ O $ObjectConstructor$ O $complex$ O $Object$ O O $U[]$ O O O $string$ O O O $string$ O $string$ O O O O $string$ O $Object$ O $string$ O O O O O O $string$ O O O O O O O $xRequestOptionsWithUrl$ O O O O O $Object$ O $string$ O O O $XMLHttpRequest$ O $XMLHttpRequestResponseType$ O $xRequestOptionsWithUrl$ O $XMLHttpRequestResponseType$ O O O $XMLHttpRequest$ O $any$ O O O O O O O $XMLHttpRequest$ O $number$ O O O $XMLHttpRequest$ O $number$ O O O O $any$ O $XMLHttpRequest$ O $any$ O O O O O $any$ O O $any$ O O $xRequestOptionsWithUrl$ O $xRequestOptionsWithUrl$ O $complex$ O O $number$ O $XMLHttpRequest$ O $number$ O $string$ O $XMLHttpRequest$ O $string$ O $string$ O $string$ O ${}$ O $this$ O ${}$ O $XMLHttpRequest$ O $string$ O O O O O $any$ O $XMLHttpRequest$ O $any$ O O O O O O $XMLHttpRequest$ O $any$ O O O O O $any$ O O $any$ O O $xRequestOptionsWithUrl$ O $xRequestOptionsWithUrl$ O $complex$ O O $number$ O $XMLHttpRequest$ O $number$ O $string$ O $XMLHttpRequest$ O $string$ O $string$ O $string$ O ${}$ O $this$ O ${}$ O $XMLHttpRequest$ O $string$ O O O O O O O O O $XMLHttpRequest$ O $any$ O O O O O $any$ O O $any$ O O $xRequestOptionsWithUrl$ O $xRequestOptionsWithUrl$ O $complex$ O O $number$ O $XMLHttpRequest$ O $number$ O $string$ O $XMLHttpRequest$ O $string$ O $string$ O $string$ O ${}$ O $this$ O ${}$ O $XMLHttpRequest$ O $string$ O O O O O O O O O $XMLHttpRequest$ O $complex$ O $xRequestOptionsWithUrl$ O O O $string$ O O O O O O $xRequestOptionsWithUrl$ O $Object$ O O $ObjectConstructor$ O $complex$ O $xRequestOptionsWithUrl$ O $Object$ O O $void$ O O O $string$ O O $XMLHttpRequest$ O $void$ O $string$ O $xRequestOptionsWithUrl$ O $Object$ O $string$ O O O O O O O O O $xRequestOptionsWithUrl$ O O O O O $XMLHttpRequest$ O O O O O O O $XMLHttpRequest$ O O O $Object$ O O $any$ O O O O O $XMLHttpRequest$ O $void$ O O O O O O O O O O O $any$ O $string$ O $xRequestOptions$ O $number$ O O O O O $xRequestOptions$ O $any$ O O $string$ O $string$ O O O O $any$ O O $xRequestOptions$ O $any$ O O $number$ O O O $any$ O $string$ O $complex$ O O O O $string$ O O O O O $XMLHttpRequestResponseType$ O O O $number$ O O O O O O O $any$ O $string$ O O $null$ O O O O O O O $XMLHttpRequestResponseType$ O $complex$ O $number$ O O O $number$ O O $number$ O O O O O
import { app , remote } from 's' ; import * as path from 's' ; let _userDataDir ; if ( process . env . PORTABLE_EXECUTABLE_DIR ) { _userDataDir = path . join ( process . env . PORTABLE_EXECUTABLE_DIR , 's' ) ; } else { _userDataDir = path . join ( ( app || remote . app ) . getPath ( 's' ) , 's' ) ; } export const userDataDir = _userDataDir ; export const userSettings = path . join ( userDataDir , 's' ) ; export const userThemesDir = path . join ( userDataDir , 's' ) ; export const userConfigurations = path . join ( userDataDir , 's' ) ; export const devThemePath = 's' ; export const savedListFilename = 's' ; export const fuzzyList = path . join ( userDataDir , 's' ) ; export const fuzzyCache = path . join ( userDataDir , 's' ) ; export const customVariables = path . join ( userDataDir , 's' ) ; export const configPresets = path . join ( userDataDir , 's' ) ;	O O $any$ O $any$ O O O O O O O $any$ O O O O $string$ O O O $any$ O $any$ O $any$ O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O
import { languageManager } from 's' ; import { availableProviders } from "s" ; export const appSettings = { type : 's' , properties : { fuzzyMatcher : { type : 's' , default : { } , properties : { timestamps : { type : 's' , default : { } , properties : { check : { type : 's' , default : 0 } , download : { type : 's' , default : 0 } } } , verbose : { type : 's' , default : false } , filterProviders : { type : 's' , default : true } } } , previewSettings : { type : 's' , default : { } , properties : { retrieveCurrentSteamImages : { type : 's' , default : true } , imageZoomPercentage : { type : 's' , default : 0 , minimum : 0 , maximum : 0 } , preload : { type : 's' , default : false } , } } , enabledProviders : { type : 's' , default : [ 's' ] , items : { oneOf : [ { type : 's' , enum : availableProviders } ] } } , language : { type : 's' , default : languageManager . getDefaultLanguage ( ) , enum : languageManager . getAvailableLanguages ( ) } , offlineMode : { type : 's' , default : false } , navigationWidth : { type : 's' , default : 0 } , clearLogOnTest : { type : 's' , default : false } , knownSteamDirectories : { type : 's' , default : < any > [ ] , items : { type : 's' } } } } ;	O O $LanguageManager$ O O O O O O $string[]$ O O O O O O O O O $string$ O O O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O $number$ O O O O $complex$ O O $string$ O O O $number$ O O O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O $complex$ O O $string$ O O O ${}$ O O O O $complex$ O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O O $complex$ O O $string$ O O O $string[]$ O O O O O $complex$ O O $complex$ O O O $string$ O O O $string[]$ O $string[]$ O O O O O $complex$ O O $string$ O O O $string$ O $LanguageManager$ O $string$ O O O $string[]$ O $LanguageManager$ O $string[]$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $number$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O $complex$ O O $string$ O O O $any$ O O O O O O O $complex$ O O $string$ O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { Bluebird } from 's' ; import { CustomVariables } from "s" ; import { LoggerService } from 's' ; import { BehaviorSubject } from "s" ; import { APP } from 's' ; import { xRequest } from 's' ; import * as json from "s" ; import * as paths from "s" ; import * as schemas from 's' ; import * as _ from "s" ; @ Injectable ( ) export class CustomVariablesService { private static xRequest = new xRequest ( Bluebird ) ; private variableData : BehaviorSubject < CustomVariables > = new BehaviorSubject ( { } ) ; private downloadStatus : BehaviorSubject < boolean > = new BehaviorSubject ( false ) ; private validator : json . Validator = new json . Validator ( schemas . customVariables ) ; private savingIsDisabled : boolean = false ; constructor ( private loggerService ) { this . load ( ) ; } private get lang ( ) { return APP . lang . customVariables . service ; } get data ( ) { return this . variableData . getValue ( ) ; } get dataObservable ( ) { return this . variableData . asObservable ( ) ; } get isDownloading ( ) { return this . downloadStatus ; } download ( force = false ) { return Promise . resolve ( ) . then ( ( ) => { if ( ! this . downloadStatus . getValue ( ) ) { this . downloadStatus . next ( true ) ; return CustomVariablesService . xRequest . request ( 's' , { responseType : 's' , method : 's' , timeout : 0 } ) . then ( ( data ) => { const error = this . set ( data || { } ) ; if ( error !== null ) { throw new Error ( error ) ; } else { this . loggerService . info ( this . lang . info . downloaded , force ? { invokeAlert : true , alertTimeout : 0 } : undefined ) ; this . save ( force ) ; } } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . failedToDownload__i . interpolate ( { error : _ . get ( error , 's' , error ) } ) ) ; } ) . finally ( ( ) => { this . downloadStatus . next ( false ) ; } ) } } ) ; } load ( ) { json . read < CustomVariables > ( paths . customVariables ) . then ( ( data ) => { if ( data === null ) { return this . download ( ) ; } else { const error = this . set ( data || { } ) ; if ( error !== null ) { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . loadingError , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( this . lang . error . corruptedVariables__i . interpolate ( { file : paths . customVariables , error } ) ) ; } } } ) . catch ( ( error ) => { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . loadingError , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( error ) ; } ) ; } set ( data ) { if ( this . validator . validate ( data ) . isValid ( ) ) { this . variableData . next ( data ) ; return null ; } else return `template` ; } save ( force = false ) { if ( ! this . savingIsDisabled || force ) { json . write ( paths . customVariables , this . variableData . getValue ( ) ) . then ( ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . writingError , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O $xRequest$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $Validator<object>$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O $boolean$ O O O O O O O O $LoggerService$ O O O O $void$ O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $Promise<any>$ O $boolean$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $xRequest$ O $any$ O O O O O O O O O O O O $number$ O O O O O $any$ O O $any$ O O O O $string$ O O O $string$ O $any$ O O O O O O O $string$ O O O O O O $ErrorConstructor$ O $string$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $boolean$ O O $true$ O O O $number$ O O O O $undefined$ O O O O $void$ O $boolean$ O O O O O O $any$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O $void$ O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $string$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O O O O O O O $string$ O O O $string$ O $any$ O O O O O O O $string$ O O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $any$ O $string$ O $string$ O O O O O O O O O $Promise<any>$ O O $any$ O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O $string$ O $CustomVariables$ O O O O O O $Validator<object>$ O $Validator<object>$ O $CustomVariables$ O O $boolean$ O O O O O O $any$ O $any$ O $CustomVariables$ O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O $boolean$ O $boolean$ O O $any$ O $Promise<any>$ O $any$ O $string$ O O O $any$ O $any$ O O O O O O O O $Promise<any>$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O
import { ValidatorModifier , AppSettings } from 's' ; export const appSettings < AppSettings > = { controlProperty : 's' , latestVersion : 0 , fields : { undefined : { 's' : { method : ( ) => 0 } , 's' : { method : ( oldValue ) => Array . isArray ( oldValue ) ? oldValue . filter ( ( val ) => val !== "s" ) : oldValue } } } } ;	O O $any$ O $any$ O O O O O O $ValidatorModifier$ O $any$ O O O $string$ O O O $number$ O O O $complex$ O O $complex$ O O O O O $number$ O O O O O O O O O O $any$ O O $any$ O O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O $complex$ O O $any$ O O $any$ O O O O $any$ O O O O O
import { ValidatorModifier , UserConfiguration } from 's' ; let replaceVariables_undefined = ( oldValue ) => typeof oldValue === 's' ? oldValue . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) : 's' ; let versionUp = ( version ) => { return version + 0 } ; export const userConfiguration < UserConfiguration > = { controlProperty : 's' , latestVersion : 0 , fields : { undefined : { 's' : { method : ( ) => 0 } , 's' : { method : ( oldValue ) => oldValue === undefined ? false : ! ! ! oldValue , oldValuePath : 's' } , 's' : { method : ( oldValue ) => ( typeof oldValue === 's' && "s" . test ( oldValue ) ) ? 's' : oldValue } , 's' : { method : replaceVariables_undefined } , 's' : { method : replaceVariables_undefined } , 's' : { method : replaceVariables_undefined } , 's' : { method : replaceVariables_undefined } } , 0 : { 's' : { method : versionUp } , 's' : { method : ( oldValue ) => typeof oldValue === 's' ? oldValue . replace ( "s" , 's' ) : 's' } } , 0 : { 's' : { method : versionUp } , 's' : { method : ( oldValue ) => Array . isArray ( oldValue ) ? oldValue . filter ( ( val ) => val !== "s" ) : oldValue } } } } ;	O O $any$ O $any$ O O O O O $string$ O O $any$ O O O $any$ O O O $string$ O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O O O O $number$ O O $number$ O O O O $number$ O O O O O O $ValidatorModifier$ O $any$ O O O $string$ O O O $number$ O O O $complex$ O O $complex$ O O O O O $number$ O O O O O O O O O O $boolean$ O O $any$ O O $any$ O $undefined$ O O O O O O $any$ O $string$ O O O O O O O $any$ O O $any$ O O O O $any$ O O O O O $boolean$ O $string$ O O O O O $any$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O O O O O $number$ O $number$ O O O O O $string$ O O $any$ O O O $any$ O O O $string$ O $complex$ O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O $any$ O O $any$ O O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O $complex$ O O $any$ O O $any$ O O O O $any$ O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { Injectable } from 's' ; import { AppSettings } from "s" ; import { LoggerService } from 's' ; import { Subject , BehaviorSubject } from "s" ; import { APP } from 's' ; import * as json from "s" ; import * as paths from "s" ; import * as schemas from 's' ; import * as modifiers from 's' ; import * as _ from "s" ; @ Injectable ( ) export class SettingsService { private changeSubject : Subject < AppSettings > = new Subject ( ) ; private settingsLoadedSubject : BehaviorSubject < boolean > = new BehaviorSubject ( false ) ; private validator : json . Validator = new json . Validator ( schemas . appSettings , modifiers . appSettings ) ; private savingIsDisabled : boolean = false ; private appSettings : AppSettings ; constructor ( private loggerService ) { this . appSettings = < AppSettings > this . validator . getDefaultValues ( ) ; json . read < AppSettings > ( paths . userSettings , this . appSettings ) . then ( ( settings ) => { if ( ! this . validator . validate ( settings ) . isValid ( ) ) { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . readingError , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( this . lang . error . corruptedSettings__i . interpolate ( { file : paths . userSettings , error : `template` } ) ) ; } else this . appSettings = settings ; } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . readingError , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) . then ( ( ) => { this . settingsLoadedSubject . next ( true ) ; } ) ; } private get lang ( ) { return APP . lang . settings . service ; } getSettings ( ) { return this . appSettings ; } settingsChanged ( ) { this . changeSubject . next ( this . appSettings ) ; } getChangeObservable ( ) { return this . changeSubject . asObservable ( ) ; } saveAppSettings ( ) { if ( ! this . savingIsDisabled ) { json . write ( paths . userSettings , this . appSettings ) . then ( ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . writingError , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } } onLoad ( callback : ( appSettings ) => void ) { this . settingsLoadedSubject . asObservable ( ) . takeWhile ( ( loaded ) => { if ( loaded ) callback ( this . appSettings ) ; return ! loaded ; } ) . subscribe ( ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O $Validator<object>$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $ValidatorModifier<AppSettings>$ O O O $boolean$ O O O O O O $AppSettings$ O $any$ O O O O $LoggerService$ O O O O $AppSettings$ O O $any$ O O O $Validator<object>$ O $object$ O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $string$ O O O $AppSettings$ O O O O O $any$ O O O O O O O O $Validator<object>$ O $Validator<object>$ O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $any$ O $string$ O $string$ O O O O O O O O O O $AppSettings$ O $any$ O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O O O $complex$ O O $AppSettings$ O O O O O O $AppSettings$ O O $void$ O O O O O $any$ O $any$ O O O $AppSettings$ O O O $any$ O O O O O O $any$ O $any$ O O O O $void$ O O O O O O O O $boolean$ O O $any$ O $Promise<any>$ O $any$ O $string$ O O O $AppSettings$ O O O O O O $Promise<any>$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O $void$ O $void$ O O $AppSettings$ O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $void$ O O O $AppSettings$ O O O O $any$ O O O O $any$ O O O O O
import { Injectable } from 's' ; import { LoggerService } from "s" ; import { SettingsService } from "s" ; import { FuzzyEventMap , AppSettings , FuzzyEventCallback } from 's' ; import { APP } from 's' ; import { FuzzyListLoader , FuzzyMatcher } from "s" ; import { Http } from 's' ; @ Injectable ( ) export class FuzzyService { private appSettings : AppSettings ; private fuzzyListLoader : FuzzyListLoader ; private fuzzyListMatcher : FuzzyMatcher ; private currentCacheEntries : number ; constructor ( private http , private loggerService , private settingsService ) { this . fuzzyListLoader = new FuzzyListLoader ( this . http , this . eventCallback . bind ( this ) , ( ) => this . appSettings . offlineMode ) ; this . fuzzyListMatcher = new FuzzyMatcher ( this . eventCallback . bind ( this ) ) ; this . fuzzyListLoader . observeList ( ) . subscribe ( ( list ) => { this . fuzzyListMatcher . setFuzzyList ( list ) ; } ) ; this . fuzzyListLoader . observeCache ( ) . subscribe ( ( data ) => { this . currentCacheEntries = Object . keys ( data ) . length ; this . fuzzyListMatcher . setFuzzyCache ( data ) ; } ) ; this . settingsService . onLoad ( ( appSettings ) => { this . appSettings = appSettings ; this . fuzzyListLoader . setTimestamps ( appSettings . fuzzyMatcher . timestamps ) ; this . fuzzyListLoader . loadCache ( ) . then ( ( ) => { return this . fuzzyListLoader . loadList ( ) ; } ) ; } ) ; setInterval ( ( ) => { this . saveCacheIfNeeded ( ) ; } , 0 ) ; } get fuzzyLoader ( ) { return this . fuzzyListLoader ; } get fuzzyMatcher ( ) { return this . fuzzyListMatcher ; } saveCacheIfNeeded ( ) { return Promise . resolve ( ) . then ( ( ) => { let cacheEntries = Object . keys ( this . fuzzyLoader . getCache ( ) ) . length ; if ( this . currentCacheEntries != undefined && this . currentCacheEntries !== cacheEntries ) { this . currentCacheEntries = cacheEntries ; return this . fuzzyLoader . saveCache ( ) ; } } ) ; } private get lang ( ) { return APP . lang . fuzzyMatcher ; } eventCallback < K extends keyof FuzzyEventMap > ( event : K , data : FuzzyEventMap [ K ] ) { switch ( event ) { case 's' : if ( ! this . appSettings . fuzzyMatcher . verbose ) break ; switch ( ( data as FuzzyEventMap [ 's' ] ) . info ) { case 's' : this . loggerService . fuzzy ( this . lang . info . checkingIfListIsUpToDate ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . downloading ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . listIsOutdated ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . listIsUpToDate ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . successfulDownload ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . match__i . interpolate ( { fuzzyTitle : ( data as FuzzyEventMap [ 's' ] ) . stringA , extractedTitle : ( data as FuzzyEventMap [ 's' ] ) . stringB } ) ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . equal__i . interpolate ( { a : ( data as FuzzyEventMap [ 's' ] ) . stringA , b : ( data as FuzzyEventMap [ 's' ] ) . stringB } ) ) ; break ; case 's' : this . loggerService . fuzzy ( this . lang . info . notEqual__i . interpolate ( { a : ( data as FuzzyEventMap [ 's' ] ) . stringA , b : ( data as FuzzyEventMap [ 's' ] ) . stringB } ) ) ; break ; default : break ; } break ; case 's' : if ( ( data as FuzzyEventMap [ 's' ] ) . isFatal ) { this . loggerService . error ( this . lang . error . fatalError ) ; } switch ( ( data as FuzzyEventMap [ 's' ] ) . error ) { case 's' : this . loggerService . error ( this . lang . error . totalGamesIsUndefined ) ; break ; case 's' : this . loggerService . error ( ( data as FuzzyEventMap [ 's' ] ) . errorMsg ) ; break ; default : break ; } break ; case 's' : this . appSettings . fuzzyMatcher . timestamps = ( data as FuzzyEventMap [ 's' ] ) ; this . settingsService . saveAppSettings ( ) ; default : break ; } } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O $AppSettings$ O $any$ O O $FuzzyListLoader$ O $any$ O O $FuzzyMatcher$ O $any$ O O $number$ O O O O O O $Http$ O O $LoggerService$ O O $SettingsService$ O O O O $FuzzyListLoader$ O O $any$ O O O $any$ O O O $void$ O $any$ O O O O O O O O O $AppSettings$ O $boolean$ O O O O $FuzzyMatcher$ O O $any$ O O O $void$ O $any$ O O O O O O O $FuzzyListLoader$ O $any$ O O O $any$ O O $any$ O O O O O $FuzzyMatcher$ O $void$ O $any$ O O O O O O O $FuzzyListLoader$ O $any$ O O O $any$ O O $any$ O O O O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O O $number$ O O O $FuzzyMatcher$ O $void$ O $any$ O O O O O O O $SettingsService$ O $void$ O O $AppSettings$ O O O O O $AppSettings$ O $AppSettings$ O O O $FuzzyListLoader$ O $void$ O $AppSettings$ O $complex$ O $FuzzyListTimestamps$ O O O O $FuzzyListLoader$ O $Promise<void>$ O O O O O O O O O O O O $FuzzyListLoader$ O $Promise<void>$ O O O O O O O O O $number$ O O O O O O O $Promise<any>$ O O O O O O O O O O $FuzzyListLoader$ O O O O O O $FuzzyListLoader$ O O O $FuzzyMatcher$ O O O O O O $FuzzyMatcher$ O O $Promise<any>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $number$ O $ObjectConstructor$ O $complex$ O O O $FuzzyListLoader$ O $any$ O O O O $number$ O O O O O $number$ O $undefined$ O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $FuzzyListLoader$ O $Promise<any>$ O O O O O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O $void$ O $any$ O O $any$ O O $K$ O $any$ O $FuzzyEventMap[K]$ O $any$ O $any$ O O O O O $K$ O O O O O O O O O O $AppSettings$ O $complex$ O $boolean$ O O O O O O $FuzzyEventMap[K]$ O $any$ O O O O O $FuzzyInfo$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O O O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O O O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O $string$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O $FuzzyEventMap[K]$ O $any$ O O O O O $boolean$ O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O $FuzzyEventMap[K]$ O $any$ O O O O O $FuzzyError$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O $FuzzyEventMap[K]$ O $any$ O O O O O $string$ O O O O O O O O O O O O O O O O $AppSettings$ O $complex$ O $FuzzyListTimestamps$ O O $FuzzyEventMap[K]$ O $any$ O O O O O O O $SettingsService$ O $void$ O O O O O O O O O O
import { Injectable } from 's' ; import { FuzzyService } from 's' ; import { LoggerService } from 's' ; import { SettingsService } from 's' ; import { AppSettings } from 's' ; import { ImageProvider } from "s" ; @ Injectable ( ) export class ImageProviderService { private imageProvider : ImageProvider ; constructor ( private fuzzyService , private loggerService , private settingsService ) { this . imageProvider = new ImageProvider ( this . fuzzyService , this . loggerService ) ; this . settingsService . onLoad ( ( appSettings ) => { this . imageProvider . toggleFilter ( appSettings . fuzzyMatcher . filterProviders ) ; } ) ; this . settingsService . getChangeObservable ( ) . subscribe ( ( appSettings ) => { this . imageProvider . toggleFilter ( appSettings . fuzzyMatcher . filterProviders ) ; } ) ; this . fuzzyService . fuzzyLoader . observeList ( ) . subscribe ( ( list ) => { this . imageProvider . setFuzzyList ( list ) ; } ) ; } get instance ( ) { return this . imageProvider ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O $ImageProvider$ O $any$ O O O O $FuzzyService$ O O $LoggerService$ O O $SettingsService$ O O O O $ImageProvider$ O O $any$ O O O $FuzzyService$ O O O $LoggerService$ O O O O $SettingsService$ O $void$ O O $AppSettings$ O O O O O $ImageProvider$ O $void$ O $AppSettings$ O $complex$ O $boolean$ O O O O O O O $SettingsService$ O $any$ O O O $any$ O O $AppSettings$ O O O O O $ImageProvider$ O $void$ O $AppSettings$ O $complex$ O $boolean$ O O O O O O O $FuzzyService$ O $FuzzyListLoader$ O $any$ O O O $any$ O O $any$ O O O O O $ImageProvider$ O $void$ O $any$ O O O O O O O $ImageProvider$ O O O O O O $ImageProvider$ O O O
import { CustomVariablesService } from 's' ; import { Injectable } from 's' ; import { Http } from 's' ; import { UserConfiguration , ParsedUserConfiguration } from 's' ; import { LoggerService } from 's' ; import { FuzzyService } from 's' ; import { ImageProviderService } from 's' ; import { FileParser , VariableParser } from 's' ; import { BehaviorSubject } from "s" ; import { APP } from 's' ; import * as json from "s" ; import * as paths from "s" ; import * as schemas from 's' ; import * as modifiers from 's' ; import * as fs from 's' ; import * as _ from 's' ; @ Injectable ( ) export class ParsersService { private fileParser : FileParser ; private userConfigurations : BehaviorSubject < { saved : UserConfiguration , current : UserConfiguration } [ ] > ; private deletedConfigurations : BehaviorSubject < { saved : UserConfiguration , current : UserConfiguration } [ ] > ; private validator : json . Validator = new json . Validator ( schemas . userConfiguration , modifiers . userConfiguration ) ; private savingIsDisabled : boolean = false ; constructor ( private fuzzyService , private loggerService , private cVariableService , private http ) { this . fileParser = new FileParser ( this . fuzzyService ) ; this . userConfigurations = new BehaviorSubject < { saved : UserConfiguration , current : UserConfiguration } [ ] > ( [ ] ) ; this . deletedConfigurations = new BehaviorSubject < { saved : UserConfiguration , current : UserConfiguration } [ ] > ( [ ] ) ; this . readUserConfigurations ( ) ; this . cVariableService . dataObservable . subscribe ( ( data ) => { this . fileParser . setCustomVariables ( data ) ; } ) ; } get lang ( ) { return APP . lang . parsers . service ; } getUserConfigurations ( ) { return this . userConfigurations . asObservable ( ) ; } getUserConfigurationsArray ( ) { return this . userConfigurations . getValue ( ) ; } getDeletedConfigurations ( ) { return this . deletedConfigurations . asObservable ( ) ; } getDefaultValues ( ) { return this . validator . getDefaultValues ( ) as UserConfiguration ; } saveConfiguration ( config : { saved : UserConfiguration , current : UserConfiguration } ) { let userConfigurations = this . userConfigurations . getValue ( ) ; userConfigurations = userConfigurations . concat ( _ . cloneDeep ( config ) ) ; this . userConfigurations . next ( userConfigurations ) ; this . saveUserConfigurations ( ) ; } swapIndex ( currentIndex , newIndex ) { let userConfigurations = this . userConfigurations . getValue ( ) ; let temp = userConfigurations [ currentIndex ] ; userConfigurations [ currentIndex ] = userConfigurations [ newIndex ] ; userConfigurations [ newIndex ] = temp ; this . userConfigurations . next ( userConfigurations ) ; this . saveUserConfigurations ( ) ; } updateConfiguration ( index , config ? ) { let userConfigurations = this . userConfigurations . getValue ( ) ; if ( config === undefined ) { if ( userConfigurations [ index ] . current == null ) return ; else userConfigurations [ index ] = { saved : userConfigurations [ index ] . current , current : null } ; } else userConfigurations [ index ] = { saved : config , current : null } ; this . userConfigurations . next ( userConfigurations ) ; this . saveUserConfigurations ( ) ; } setCurrentConfiguration ( index , config ) { let userConfigurations = this . userConfigurations . getValue ( ) ; userConfigurations [ index ] . current = config ; this . userConfigurations . next ( userConfigurations ) ; } deleteConfiguration ( index ) { let userConfigurations = this . userConfigurations . getValue ( ) ; if ( userConfigurations . length > index && index >= 0 ) { let deletedConfigurations = this . deletedConfigurations . getValue ( ) ; deletedConfigurations = deletedConfigurations . concat ( userConfigurations . splice ( index , 0 ) ) ; this . deletedConfigurations . next ( deletedConfigurations ) ; this . userConfigurations . next ( userConfigurations ) ; this . saveUserConfigurations ( ) ; } } restoreConfiguration ( index ? ) { let deletedConfigurations = this . deletedConfigurations . getValue ( ) ; if ( index == undefined ) index = 0 ; if ( deletedConfigurations . length > index && index >= 0 ) { let userConfigurations = this . userConfigurations . getValue ( ) ; userConfigurations = userConfigurations . concat ( deletedConfigurations . splice ( index , 0 ) ) ; this . deletedConfigurations . next ( deletedConfigurations ) ; this . userConfigurations . next ( userConfigurations ) ; this . saveUserConfigurations ( ) ; } } getAvailableParsers ( ) { return this . fileParser . getAvailableParsers ( ) ; } getParserInfo ( parser ) { return this . fileParser . getParserInfo ( parser ) ; } executeFileParser ( ... configs : UserConfiguration [ ] ) { let invalidConfigTitles : string [ ] = [ ] ; let skipped : string [ ] = [ ] ; let validConfigs : UserConfiguration [ ] = [ ] ; if ( configs . length === 0 ) { let configArray = this . getUserConfigurationsArray ( ) ; for ( let i = 0 ; i < configArray . length ; i ++ ) { if ( configArray [ i ] . saved . disabled ) skipped . push ( configArray [ i ] . saved . configTitle ) ; else configs . push ( configArray [ i ] . saved ) ; } } configs = _ . cloneDeep ( configs ) ; for ( let i = 0 ; i < configs . length ; i ++ ) { if ( this . isConfigurationValid ( configs [ i ] ) ) validConfigs . push ( configs [ i ] ) ; else invalidConfigTitles . push ( configs [ i ] . configTitle || this . lang . text . noTitle ) ; } return this . fileParser . executeFileParser ( validConfigs ) . then ( ( parsedData ) => { return { parsedData : parsedData , invalid : invalidConfigTitles , skipped : skipped } ; } ) ; } validate ( key , data ) { switch ( key ) { case 's' : { let availableParsers = this . getAvailableParsers ( ) ; return ( availableParsers . indexOf ( data ) !== - 0 ) ? null : this . lang . validationErrors . parserType__md ; } case 's' : return data ? null : this . lang . validationErrors . configTitle__md ; case 's' : return this . validateVariableParserString ( data || 's' ) ; case 's' : return ( data == null || data . length === 0 || this . validatePath ( data || 's' ) ) ? null : this . lang . validationErrors . executable__md ; case 's' : return this . validatePath ( data || 's' , true ) ? null : this . lang . validationErrors . romDir__md ; case 's' : return this . validatePath ( data || 's' , true ) ? null : this . lang . validationErrors . steamDir__md ; case 's' : return ( data == null || data . length === 0 || this . validatePath ( data || 's' , true ) ) ? null : this . lang . validationErrors . startInDir__md ; case 's' : return this . validateVariableParserString ( data || 's' ) ; case 's' : { let availableParser = this . getParserInfo ( data [ 's' ] ) ; if ( availableParser ) { if ( availableParser . inputs === undefined ) return this . lang . validationErrors . parserInput . noInput ; else if ( availableParser . inputs [ data [ 's' ] ] === undefined ) return this . lang . validationErrors . parserInput . inputNotAvailable__i . interpolate ( { name : data [ 's' ] } ) ; else if ( availableParser . inputs [ data [ 's' ] ] . forcedInput || availableParser . inputs [ data [ 's' ] ] . validationFn === undefined ) return null ; else return availableParser . inputs [ data [ 's' ] ] . validationFn ( data [ 's' ] ) ; } else return this . lang . validationErrors . parserInput . incorrectParser ; } case 's' : return this . validateVariableParserString ( data || 's' , this . lang . validationErrors . titleModifier__md ) ; case 's' : return this . validateVariableParserString ( data || 's' , this . lang . validationErrors . executableModifier__md ) ; case 's' : return this . validateVariableParserString ( data ? data . limitToGroups || 's' : 's' ) ; case 's' : case 's' : return this . validateVariableParserString ( data || 's' ) ; case 's' : return _ . isArray ( data ) ? null : this . lang . validationErrors . imageProviders__md ; case 's' : return this . validateVariableParserString ( data || 's' , this . lang . validationErrors . imagePool__md ) ; case 's' : case 's' : case 's' : return this . fileParser . validateFieldGlob ( data || 's' ) ; default : return this . lang . validationErrors . unhandledValidationKey__md ; } } private validateVariableParserString ( input , emptyError ? ) { let canBeEmpty = emptyError == undefined ; if ( ! canBeEmpty ) input = input . trim ( ) ; if ( canBeEmpty || ( ! canBeEmpty && input . length > 0 ) ) return VariableParser . isValidString ( 's' , 's' , input ) ? null : this . lang . validationErrors . variableString__md ; else return emptyError ; } private validatePath ( fsPath , checkForDirectory ? ) { try { let path = fs . statSync ( fsPath ) ; if ( checkForDirectory !== undefined ) return checkForDirectory ? path . isDirectory ( ) : path . isFile ( ) ; else return true ; } catch ( e ) { return false ; } } isConfigurationValid ( config ) { let simpleValidations : string [ ] = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ; for ( let i = 0 ; i < simpleValidations . length ; i ++ ) { if ( this . validate ( simpleValidations [ i ] , config [ simpleValidations [ i ] ] ) !== null ) return false ; } let availableParser = this . getParserInfo ( config . parserType ) ; if ( availableParser . inputs !== undefined ) { let parserInputs = config . parserInputs ; for ( let inputName in availableParser . inputs ) { if ( this . validate ( 's' , { parser : config . parserType , input : inputName , inputData : parserInputs [ inputName ] } ) !== null ) return false ; } } return true ; } private saveUserConfigurations ( ) { return new Promise < UserConfiguration [ ] > ( ( resolve , reject ) => { if ( ! this . savingIsDisabled ) { fs . outputFile ( paths . userConfigurations , JSON . stringify ( this . userConfigurations . getValue ( ) . map ( ( item ) => { item . saved [ modifiers . userConfiguration . controlProperty ] = modifiers . userConfiguration . latestVersion ; return item . saved ; } ) , null , 0 ) , ( error ) => { if ( error ) reject ( error ) ; else resolve ( ) ; } ) ; } else resolve ( ) ; } ) . then ( ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . savingConfiguration , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } private readUserConfigurations ( ) { return new Promise < UserConfiguration [ ] > ( ( resolve , reject ) => { fs . readFile ( paths . userConfigurations , 's' , ( error , data ) => { try { if ( error ) { if ( error . code === 's' ) resolve ( [ ] ) ; else reject ( error ) ; } else resolve ( JSON . parse ( data ) ) ; } catch ( error ) { reject ( error ) ; } } ) ; } ) . then ( ( data ) => { let validatedConfigs : { saved : UserConfiguration , current : UserConfiguration } [ ] = [ ] ; let errorString = 's' ; for ( let i = 0 ; i < data . length ; i ++ ) { if ( this . validator . validate ( data [ i ] ) . isValid ( ) ) validatedConfigs . push ( { saved : data [ i ] , current : null } ) ; else errorString += `template` ; } ; if ( errorString . length > 0 ) { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . readingConfiguration , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( this . lang . error . corruptedConfiguration__i . interpolate ( { file : paths . userConfigurations , error : errorString } ) ) ; } this . userConfigurations . next ( validatedConfigs ) ; } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . readingConfiguration , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O $FileParser$ O $any$ O O $any$ O $any$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O $any$ O $any$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O $Validator<object>$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $ValidatorModifier<UserConfiguration>$ O O O $boolean$ O O O O O O O O $FuzzyService$ O O $LoggerService$ O O $CustomVariablesService$ O O $Http$ O O O O $FileParser$ O O $any$ O O O $FuzzyService$ O O O O $any$ O O $any$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O O O O O O $any$ O O $any$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O O O O O O $Promise<void>$ O O O O O $CustomVariablesService$ O $any$ O $any$ O O $any$ O O O O O $FileParser$ O $void$ O $any$ O O O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $UserConfiguration$ O O O O O O $Validator<object>$ O $object$ O O O $any$ O O $void$ O $complex$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $void$ O $number$ O $number$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O $any$ O $number$ O O $any$ O $number$ O O $any$ O $number$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $void$ O $number$ O $UserConfiguration$ $UserConfiguration$ O O O $any$ O O O $any$ O $any$ O O O O O $UserConfiguration$ O $undefined$ O O O O $any$ O $number$ O O $any$ O O O O O O $any$ O $number$ O O O $any$ O $any$ O $number$ O O $any$ O $null$ O O O O O O $any$ O $number$ O O O $UserConfiguration$ O $UserConfiguration$ O $null$ O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $void$ O $number$ O $UserConfiguration$ O O O $any$ O O O $any$ O $any$ O O O $any$ O $number$ O O $any$ O $UserConfiguration$ O O O $any$ O $any$ O $any$ O O O $void$ O $number$ O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $number$ O $number$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O O $void$ O $number$ $number$ O O O $any$ O O O $any$ O $any$ O O O O O $number$ O $undefined$ O $number$ O O O O O $any$ O $any$ O $number$ O $number$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O O $string[]$ O O O O O O $FileParser$ O $string[]$ O O O O $ParserInfo$ O $string$ O O O O O $FileParser$ O $ParserInfo$ O $string$ O O O $complex$ O O $UserConfiguration[]$ O $any$ O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O $UserConfiguration[]$ O $any$ O O O O O O O O $UserConfiguration[]$ O $number$ O O O O O $any$ O O O $any$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O $any$ O $string[]$ O $number$ O $any$ O $number$ O O $any$ O $any$ O O O $UserConfiguration[]$ O $number$ O $any$ O $number$ O O $any$ O O O O $UserConfiguration[]$ O $any$ O $any$ O $UserConfiguration[]$ O O O O O $number$ O O O $number$ O $UserConfiguration[]$ O $number$ O $number$ O O O O O O O $boolean$ O $UserConfiguration[]$ O $number$ O O O $UserConfiguration[]$ O $number$ O $UserConfiguration[]$ O $number$ O O O O $string[]$ O $number$ O $UserConfiguration[]$ O $number$ O O $string$ O O O O O $complex$ O $string$ O O O O O O $FileParser$ O $complex$ O $UserConfiguration[]$ O O O O O $complex$ O O O O O $complex$ O $complex$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O O O $any$ O $string$ O $any$ O O O O $string$ O O O O O O O $string[]$ O O O $string[]$ O O O O O $string[]$ O $number$ O $any$ O O O O O O O O O O O O O O $string$ O O O O O O $any$ O O O O O O O O O $string$ O O O O O O O $string$ O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O $string$ O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O $any$ O O O O O O O O O $ParserInfo$ O O O $ParserInfo$ O $any$ O O O O O O O $ParserInfo$ O O O O $ParserInfo$ O $ParserInputField$ O $undefined$ O O O O O O O O $complex$ O $string$ O O O O $ParserInfo$ O $ParserInputField$ O $any$ O O O O O $undefined$ O O O O O O O O $complex$ O $string$ O $string$ O O $any$ O $any$ O O O O O O O O O $ParserInfo$ O $ParserInputField$ O $any$ O O O O O $string$ O $ParserInfo$ O $ParserInputField$ O $any$ O O O O O $string$ O $undefined$ O O O O O O $ParserInfo$ O $ParserInputField$ O $any$ O O O O O $string$ O $any$ O O O O O O O O O O O O O O $complex$ O $string$ O O O O O O O O $string$ O $any$ O O O O O O O O O $string$ O O O O O O O O $string$ O $any$ O O O O O O O O O $string$ O O O O O O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $string$ O O O O O O O $string$ O $any$ O O O O O O O O O $string$ O O O O O O O O O O O O O O $FileParser$ O $any$ O $any$ O O O O O O O O O O O O O $string$ O O O O $string$ O $string$ O $string$ $string$ O O O $boolean$ O $string$ O $undefined$ O O O O $boolean$ O $string$ O $string$ O $string$ O O O O O $boolean$ O O O $boolean$ O $string$ O $number$ O O O O O $any$ O $boolean$ O O O O O $string$ O O O O O O O O O O $string$ O O O $string$ O O O $any$ O $string$ O $boolean$ $boolean$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O $boolean$ O $undefined$ O O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $boolean$ O $UserConfiguration$ O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O O O $any$ O $string[]$ O $number$ O O $UserConfiguration$ O $string[]$ O $number$ O O O O O O O O O O O $ParserInfo$ O O O $ParserInfo$ O $UserConfiguration$ O $string$ O O O O $ParserInfo$ O $ParserInputField$ O $undefined$ O O O $complex$ O $UserConfiguration$ O $complex$ O O O O $string$ O $ParserInfo$ O $ParserInputField$ O O O O O O $any$ O O O O $string$ O $UserConfiguration$ O $string$ O $string$ O $string$ O $string$ O $complex$ O $string$ O O O O O O O O O O O O O O O O $complex$ O O O O O $PromiseConstructor$ O $any$ O O O O O $void$ O $void$ O O O O O O O O $boolean$ O O $any$ O $any$ O $any$ O $string$ O $JSON$ O $complex$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $ValidatorModifier<UserConfiguration>$ O $string$ O O $any$ O $ValidatorModifier<UserConfiguration>$ O $complex$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O O O O O O $void$ O O O O O O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O $any$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $void$ O O O O O O $void$ O $any$ O O O O $void$ O $JSON$ O $any$ O $any$ O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O O O O $UserConfiguration[]$ O O O O $complex$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O O O $string$ O O O O O O $number$ O O O $number$ O $UserConfiguration[]$ O $number$ O $number$ O O O O O O O $Validator<object>$ O $Validator<object>$ O $UserConfiguration[]$ O $number$ O O O $boolean$ O O O $complex$ O $number$ O O $UserConfiguration$ O $UserConfiguration[]$ O $number$ O O $null$ O O O O O O $string$ O O O O O O O $string$ O $number$ O O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O $string$ O O $string$ O $any$ O $string$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O
import * as crc from 's' ; import * as long from 's' ; export function generateAppId ( executableLocation , title ) { let crcValue = crc . 0 ( executableLocation + title ) ; let longValue = new long ( crcValue , crcValue , true ) ; longValue = longValue . or ( 0 ) ; longValue = longValue . shl ( 0 ) ; longValue = longValue . or ( 0 ) ; return longValue . toString ( ) ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O
import { ParsedUserConfiguration , SteamTree } from "s" ; export function generateTreeFromParsedConfig ( data : ParsedUserConfiguration [ ] ) { let steamTree < any > = { tree : { } , numberOfUsers : 0 } ; for ( let i = 0 ; i < data . length ; i ++ ) { let config = data [ i ] ; if ( steamTree . tree [ config . steamDirectory ] === undefined ) steamTree . tree [ config . steamDirectory ] = { } ; for ( let j = 0 ; j < config . foundUserAccounts . length ; j ++ ) { let userAccount = config . foundUserAccounts [ j ] ; if ( steamTree . tree [ config . steamDirectory ] [ userAccount . accountID ] === undefined ) { steamTree . numberOfUsers ++ ; steamTree . tree [ config . steamDirectory ] [ userAccount . accountID ] = { } ; } } } return steamTree ; }	O O $any$ O $any$ O O O O O O $SteamTree<any>$ O $ParsedUserConfiguration[]$ O $any$ O O O O O $SteamTree$ O O O O O ${}$ O O O O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration[]$ O $number$ O $number$ O O O O $ParsedUserConfiguration$ O $ParsedUserConfiguration[]$ O $number$ O O O O $SteamTree<any>$ O $complex$ O $ParsedUserConfiguration$ O $string$ O O $undefined$ O $SteamTree<any>$ O $complex$ O $ParsedUserConfiguration$ O $string$ O O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O $number$ O O O O $userAccountData$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O O O $SteamTree<any>$ O $complex$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $undefined$ O O $SteamTree<any>$ O $number$ O O $SteamTree<any>$ O $complex$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O O O O O O O O $SteamTree<any>$ O O
import * as long from 's' ; export function 0 ( 0 ) { let 0 = long . fromString ( "s" , true , 0 ) ; let longValue = long . fromValue ( 0 ) . subtract ( 0 ) ; return longValue . toString ( ) ; }	O O O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O O O O
import { userAccountData } from "s" ; import { 0 } from "s" ; import * as Glob from 's' ; import * as genericParser from 's' ; import * as path from 's' ; import * as fs from 's' ; export function getAvailableLogins ( steamDirectory , useCredentials ) { return new Promise < userAccountData [ ] > ( ( resolve , reject ) => { if ( useCredentials ) { fs . readFile ( path . join ( steamDirectory , 's' , 's' ) , 's' , ( err , data ) => { try { if ( err && err . code !== 's' ) reject ( err ) ; else { if ( data ) { let parsedData = genericParser . parse ( data ) as any ; let accountData : userAccountData [ ] = [ ] ; if ( parsedData . users ) { for ( let 0 in parsedData . users ) { accountData . push ( { 0 : 0 , accountID : 0 ( 0 ) , name : parsedData . users [ 0 ] . AccountName } ) ; } } resolve ( accountData ) ; } else resolve ( [ ] ) ; } } catch ( error ) { reject ( error ) ; } } ) ; } else { Glob ( 's' , { silent : true , cwd : steamDirectory } , ( err , files ) => { if ( err ) reject ( err ) ; else { let getUserId = function ( filename ) { return "s" . exec ( filename ) [ 0 ] ; } let accountData : userAccountData [ ] = [ ] ; for ( let i = 0 ; i < files . length ; i ++ ) { let userId = getUserId ( files [ i ] ) ; accountData . push ( { 0 : 's' , accountID : userId , name : userId } ) ; } resolve ( accountData ) ; } } ) ; } } ) ; }	O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<userAccountData[]>$ O $string$ O $boolean$ O O O O $PromiseConstructor$ O $any$ O O O O O $void$ O $void$ O O O O O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $userAccountData[]$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O $userAccountData[]$ O $number$ O O $string$ O $string$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O $void$ O $userAccountData[]$ O O O O $void$ O O O O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O $any$ O O O O $boolean$ O O O $string$ O $string$ O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O O O $string$ O O O $string$ O O O O O $RegExpExecArray$ O $string$ O O O O O O O $userAccountData[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O $string$ O $string$ O $any$ O $number$ O O O $userAccountData[]$ O $number$ O O $string$ O O O $string$ O $string$ O $string$ O $string$ O O O O $void$ O $userAccountData[]$ O O O O O O O O O O O
import { SteamTree } from "s" ; import * as path from 's' ; import * as fs from 's' ; import * as _ from "s" ; export function getGridImagesForTree ( tree < { [ appId ] : string } > ) { return Promise . resolve ( ) . then ( ( ) => { let data = _ . cloneDeep ( tree ) ; if ( data . numberOfUsers === 0 ) return data ; else { let promises : Promise < void > [ ] = [ ] ; for ( let steamDirectory in data . tree ) { for ( let userId in data . tree [ steamDirectory ] ) { promises . push ( fs . readdir ( path . join ( steamDirectory , 's' , userId , 's' , 's' ) ) . then ( ( files ) => { let extRegex = "s" ; for ( let i = 0 ; i < files . length ; i ++ ) { let ext = path . extname ( files [ i ] ) ; let appId = path . basename ( files [ i ] , ext ) ; if ( data . tree [ steamDirectory ] [ userId ] [ appId ] === undefined ) { if ( extRegex . test ( ext ) ) data . tree [ steamDirectory ] [ userId ] [ appId ] = path . join ( steamDirectory , 's' , userId , 's' , 's' , files [ i ] ) ; } } } ) . catch ( ( error ) => { if ( error . code !== 's' ) throw error ; } ) ) ; } } return Promise . all ( promises ) . then ( ( ) => data ) ; } } ) ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<any>$ O $SteamTree$ O O O $string$ O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O O O $any$ O O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O O O O $string$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $string$ O O O $Promise<void>[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O O $any$ O O O O $RegExp$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O O O O $any$ O $any$ O $string$ O O $string$ O O $any$ O O $undefined$ O O O O $RegExp$ O $boolean$ O $any$ O O $any$ O $any$ O $string$ O O $string$ O O $any$ O O $any$ O $any$ O $string$ O O O $string$ O O O O O $any$ O $number$ O O O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O O O $any$ O O O O O O O
import { userAccountData } from "s" ; import { getAvailableLogins } from "s" ; export function getMultipleAvailableLogins ( steamDirectories : string [ ] , useCredentials : boolean | boolean [ ] ) { let multipleDirData : { data : { [ directory ] : userAccountData [ ] } , numberOfAccounts : number } = { data : { } , numberOfAccounts : 0 } ; let promises : Promise < userAccountData [ ] > [ ] = [ ] ; let isArray = useCredentials instanceof Array ; for ( let i = 0 ; i < steamDirectories . length ; i ++ ) { promises . push ( getAvailableLogins ( steamDirectories [ i ] , isArray ? ( useCredentials [ i ] || false ) : useCredentials || false ) ) ; } return Promise . resolve ( ) . then ( ( ) => { if ( promises . length > 0 ) { return promises . reduce ( ( p , c , i ) => p . then ( ( data ) => { multipleDirData . data [ steamDirectories [ i ] ] = data ; multipleDirData . numberOfAccounts += data . length ; return c ; } ) , Promise . resolve ( ) . then ( ( ) => promises [ 0 ] ) ) ; } } ) . then ( ( ) => { return multipleDirData ; } ) ; }	O O $any$ O O O O O O $Promise<userAccountData[]>$ O O O O O O $complex$ O $string[]$ O O O O O $complex$ O O O O O O O O O $complex$ O O $complex$ O O O $string$ O O $any$ O O O O $number$ O O O O O ${}$ O O O O $number$ O O O O O $Promise<userAccountData[]>[]$ O $PromiseConstructor$ O $any$ O O O O O O O O O O $boolean$ O $complex$ O $ArrayConstructor$ O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O $Promise<userAccountData[]>[]$ O $number$ O $Promise<userAccountData[]>$ O $string[]$ O $number$ O O $boolean$ O O $complex$ O $number$ O O O O O $complex$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $Promise<userAccountData[]>[]$ O $number$ O O O O O $Promise<userAccountData[]>[]$ O $complex$ O O $Promise<userAccountData[]>$ O $Promise<userAccountData[]>$ O $number$ O O $Promise<userAccountData[]>$ O O O O $userAccountData[]$ O O O $complex$ O $complex$ O $string[]$ O $number$ O O O $userAccountData[]$ O $complex$ O $number$ O $userAccountData[]$ O $number$ O O $Promise<userAccountData[]>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $Promise<userAccountData[]>[]$ O O O O O O O O O O O O O O O O O $complex$ O O O O O
const noError = 's' ; function toMessage ( messages : string | string [ ] | VDF_Error | VDF_Error [ ] | Error | Error [ ] ) { let message = undefined ; if ( typeof messages === 's' ) message = messages ; else if ( messages instanceof VDF_Error || messages instanceof Error ) message = messages . message ; else if ( messages instanceof Array ) { messages = ( messages as any [ ] ) . filter ( error => error !== undefined && error !== null ) ; if ( messages . length > 0 ) { if ( typeof messages [ 0 ] === 's' ) message = ( messages as string [ ] ) . join ( 's' ) ; else if ( messages [ 0 ] instanceof VDF_Error || messages [ 0 ] instanceof Error ) { message = ( messages as any [ ] ) . map ( error => error . message ) . join ( 's' ) ; } } } return message ; } export class VDF_Error extends Error { private isValid : boolean ; constructor ( messages : string | string [ ] | VDF_Error | VDF_Error [ ] | Error | Error [ ] ) { let message = toMessage ( messages ) ; super ( message ) ; this . isValid = message !== undefined ; } get valid ( ) { return this . isValid ; } get invalid ( ) { return ! this . valid ; } }	O $string$ O O O O $any$ O $complex$ O O O O O O O $any$ O $any$ O O O $ErrorConstructor$ O $ErrorConstructor$ O O O O O $any$ O $undefined$ O O O O $complex$ O O O $any$ O $string$ O O O O $complex$ O $any$ O $complex$ O $ErrorConstructor$ O $any$ O $complex$ O $string$ O O O O $complex$ O $ArrayConstructor$ O O $complex$ O O $complex$ O O O O O O $complex$ O $any$ O $any$ O $undefined$ O $any$ O O O O O O $complex$ O $number$ O O O O O O O $complex$ O O O O O O $any$ O O $complex$ O O O O O O $string$ O O O O O O O $complex$ O O O O $any$ O $complex$ O O O O $ErrorConstructor$ O O $any$ O O $complex$ O O O O O O $U[]$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O $any$ O O O O $any$ O $ErrorConstructor$ O O $boolean$ O O O O O $complex$ O O O O O O O $any$ O $any$ O O O $ErrorConstructor$ O $ErrorConstructor$ O O O O O $any$ O $any$ O $complex$ O O O O $any$ O O O O $boolean$ O $any$ O $undefined$ O O O $boolean$ O O O O O O $boolean$ O O O $boolean$ O O O O O O O $boolean$ O O O
import { VDF_AddedItemsData } from "s" ; import { VDF_Error } from 's' ; import { APP } from 's' ; import * as json from 's' ; import * as _ from "s" ; import * as fs from 's' ; import * as path from 's' ; export class VDF_AddedItemsFile { private fileData : VDF_AddedItemsData = undefined ; constructor ( private filepath ) { } get data ( ) { return this . fileData ; } set data ( value ) { this . fileData = value ; } get valid ( ) { return this . fileData !== undefined ; } get invalid ( ) { return ! this . valid ; } read ( ) { return json . read < string [ ] > ( this . filepath , [ ] ) . then ( ( data ) => { this . fileData = { } ; for ( let i = 0 ; i < data . length ; i ++ ) { this . fileData [ data [ i ] ] = true ; } return this . data ; } ) ; } write ( ) { this . fileData = _ . pickBy ( this . fileData , item => item !== undefined ) ; let data = Object . keys ( this . fileData ) ; return json . write ( this . filepath , data ) ; } getItem ( appId ) { return this . fileData [ appId ] ; } removeItem ( appId ) { if ( this . fileData [ appId ] !== undefined ) { this . fileData [ appId ] = undefined ; } } addItem ( appId ) { this . fileData [ appId ] = true ; } }	O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $VDF_AddedItemsData$ O $any$ O $undefined$ O O O O $string$ O O O O $VDF_AddedItemsData$ O O O O O O $VDF_AddedItemsData$ O O O $VDF_AddedItemsData$ O $VDF_AddedItemsData$ O O O O $VDF_AddedItemsData$ O $VDF_AddedItemsData$ O O O $boolean$ O O O O O O $VDF_AddedItemsData$ O $undefined$ O O O $boolean$ O O O O O O O $boolean$ O O $Promise<VDF_AddedItemsData>$ O O O O $any$ O $Promise<any>$ O O O O O O O O $string$ O O O O O O O O $any$ O O O O O $VDF_AddedItemsData$ O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $VDF_AddedItemsData$ O $any$ O $number$ O O O O O O O O O $VDF_AddedItemsData$ O O O O O $Promise<any>$ O O O O O $VDF_AddedItemsData$ O $any$ O $any$ O O O $VDF_AddedItemsData$ O $any$ O $any$ O $undefined$ O O O $string[]$ O $ObjectConstructor$ O $complex$ O O O $VDF_AddedItemsData$ O O O $any$ O $Promise<any>$ O O O $string$ O $string[]$ O O O $true$ O $string$ O O O O O $VDF_AddedItemsData$ O $string$ O O O $void$ O $string$ O O O O O O $VDF_AddedItemsData$ O $string$ O O $undefined$ O O O O $VDF_AddedItemsData$ O $string$ O O $undefined$ O O O $void$ O $string$ O O O O $VDF_AddedItemsData$ O $string$ O O O O O O
import * as Glob from 's' ; export function promise ( pattern , options : Glob . IOptions ) { return new Promise < string [ ] > ( ( resolve , reject ) => { try { Glob ( pattern , options , ( error , files ) => { if ( error ) reject ( error ) ; else resolve ( files ) ; } ) ; } catch ( error ) { reject ( error ) ; } } ) }	O O O $any$ O O O O O $Promise<string[]>$ O $string$ O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O O O O O O O $void$ O $void$ O O O O O $any$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O $any$ O O O O O O O O $any$ O O $void$ O $any$ O O O O O O
export * from 's' ;	O O O O O
import * as path from 's' ; import * as fs from 's' ; export function backup ( filepath , ext , overwrite = false ) { let newFilepath = path . join ( path . dirname ( filepath ) , path . basename ( filepath , path . extname ( filepath ) ) ) ; if ( ext [ 0 ] === 's' ) newFilepath += ext ; else newFilepath = `template` ; return fs . copy ( filepath , newFilepath , { overwrite : overwrite } ) . then ( ) ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $string$ O $string$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O O O O $any$ O $string$ O O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O $boolean$ O $boolean$ O O O $any$ O O O O
export * from 's' ;	O O O O O
import { VDF_ScreenshotsData } from "s" ; import { xRequest } from 's' ; import { VDF_Error } from 's' ; import { APP } from 's' ; import { Bluebird } from 's' ; import * as genericParser from 's' ; import * as glob from 's' ; import * as file from 's' ; import * as _ from "s" ; import * as fs from 's' ; import * as path from 's' ; const mimeTypes = require ( 's' ) ; const toBuffer = require ( 's' ) ; export class VDF_ScreenshotsFile { private static xRequest = new xRequest ( Bluebird ) ; private fileData : any = undefined ; constructor ( private filepath , private gridDirectory ) { } private get lang ( ) { return APP . lang . vdfFile ; } get data ( ) : VDF_ScreenshotsData { if ( this . fileData === undefined ) return undefined ; else return this . fileData [ 's' ] [ 's' ] ; } set data ( value ) { if ( this . fileData === undefined ) return ; else this . fileData [ 's' ] [ 's' ] = value ; } get valid ( ) { return this . fileData !== undefined ; } get invalid ( ) { return ! this . valid ; } read ( ) { return fs . readFile ( this . filepath , 's' ) . catch ( ( error ) => { if ( error . code !== 's' ) { throw new VDF_Error ( APP . lang . vdfFile . error . readingVdf__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } } ) . then ( ( data ) => { if ( data ) this . fileData = genericParser . parse ( data ) ; else this . fileData = { } ; if ( this . fileData [ 's' ] === undefined ) this . fileData [ 's' ] = { 's' : { } } ; else if ( this . fileData [ 's' ] [ 's' ] === undefined ) this . fileData [ 's' ] [ 's' ] = { } ; return this . data ; } ) ; } write ( ) { return Promise . resolve ( ) . then ( ( ) => { let promises : Promise < VDF_Error > [ ] = [ ] ; let screenshotsData = this . data ; for ( const appId in screenshotsData ) { if ( screenshotsData [ appId ] === undefined ) { promises . push ( glob . promise ( `template` , { silent : true , dot : true , cwd : this . gridDirectory , absolute : true } ) . then ( ( files ) => { let errors : Error [ ] = [ ] ; for ( let i = 0 ; i < files . length ; i ++ ) { try { fs . removeSync ( files [ i ] ) ; } catch ( error ) { errors . push ( error ) ; } } return errors ; } ) . then ( ( errors ) => { if ( errors . length > 0 ) return new VDF_Error ( errors ) ; } ) ) ; } else if ( typeof screenshotsData [ appId ] !== 's' ) { let data = screenshotsData [ appId ] as { title : string , url : string } ; promises . push ( Promise . resolve ( ) . then ( ( ) => { return VDF_ScreenshotsFile . xRequest . request ( data . url , { headers : { 's' : 's' } , responseType : 's' , method : 's' , timeout : 0 } ) . then ( ( blob ) => { let ext : string | boolean = mimeTypes . extension ( blob . type ) ; if ( ext === false ) return this . lang . error . unsupportedMimeType__i . interpolate ( { type : blob . type , title : data . title } ) ; else { return new Promise < Buffer > ( ( resolve , reject ) => { toBuffer ( blob , ( error , buffer ) => { if ( error ) reject ( this . lang . error . imageError__i . interpolate ( { error , url : data . url , title : data . title } ) ) ; else resolve ( buffer ) ; } ) ; } ) . then ( ( buffer ) => { return fs . outputFile ( path . join ( this . gridDirectory , `template` ) , buffer ) . then ( ( ) => { screenshotsData [ appId ] = data . title ; } ) . catch ( ( error ) => { return this . lang . error . imageError__i . interpolate ( { error , url : data . url , title : data . title } ) ; } ) } ) . then ( ( error ) => { return error ; } ) . catch ( ( error ) => { return new VDF_Error ( error ) ; } ) } } ) . catch ( ( error ) => { return new VDF_Error ( error ) ; } ) . then ( ( error ) => { if ( error !== undefined ) return new VDF_Error ( error ) ; } ) } ) ) ; } } return Bluebird . map ( promises , promise => promise , { concurrency : 0 } ) . then ( ( errors ) => { this . fileData [ 's' ] [ 's' ] = _ . pickBy ( this . fileData [ 's' ] [ 's' ] , item => item !== undefined ) ; let data = genericParser . stringify ( this . fileData ) ; return fs . outputFile ( this . filepath , data ) . then ( ( ) => errors ) ; } ) . then ( ( errors ) => { if ( errors . length > 0 ) { let error = new VDF_Error ( errors ) ; if ( error . valid ) return error ; } } ) . catch ( ( error ) => { throw new VDF_Error ( this . lang . error . writingVdf__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } ) ; } ) ; } backup ( ext , overwrite = false ) { return file . backup ( this . filepath , ext , overwrite ) . catch ( ( error ) => { if ( error . code !== 's' ) { throw new VDF_Error ( this . lang . error . creatingBackup__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } } ) ; } addItem ( data : { appId : string , title : string , url : string } ) { this . fileData [ 's' ] [ 's' ] [ data . appId ] = { title : data . title , url : data . url } ; } removeItem ( appId ) { this . fileData [ 's' ] [ 's' ] [ appId ] = undefined ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O $xRequest$ O O $any$ O $any$ O O O $any$ O O O $undefined$ O O O O $string$ O O $string$ O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O O $VDF_ScreenshotsData$ O O O $any$ O O O O O $any$ O $undefined$ O O $undefined$ O O O O O $any$ O O O O O O O O O $VDF_ScreenshotsData$ O $VDF_ScreenshotsData$ O O O O O O $any$ O $undefined$ O O O O O O $any$ O O O O O O O $VDF_ScreenshotsData$ O O O $boolean$ O O O O O O $any$ O $undefined$ O O O $boolean$ O O O O O O O $boolean$ O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O $undefined$ O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O O $undefined$ O O O $any$ O O O O O O O O O O O O O $VDF_ScreenshotsData$ O O O O O $Promise<any>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $Promise<VDF_Error>[]$ O $PromiseConstructor$ O $any$ O O O O O O O O $VDF_ScreenshotsData$ O O O $VDF_ScreenshotsData$ O O O O $string$ O $VDF_ScreenshotsData$ O O O O $VDF_ScreenshotsData$ O $string$ O O $undefined$ O O $Promise<VDF_Error>[]$ O $number$ O $any$ O $Promise<string[]>$ O O O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O $boolean$ O O O O O O O O $string[]$ O O O O $Error[]$ O $ErrorConstructor$ O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $any$ O $any$ O $string[]$ O $number$ O O O O O O $any$ O O $Error[]$ O $number$ O $any$ O O O O O $Error[]$ O O O O O O O $Error[]$ O O O O O $Error[]$ O $number$ O O O O O $any$ O $Error[]$ O O O O O O O O O O O $VDF_ScreenshotsData$ O $string$ O O O O O O $complex$ O $VDF_ScreenshotsData$ O $string$ O O O $string$ O O O $string$ O O O O $Promise<VDF_Error>[]$ O $number$ O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $xRequest$ O $any$ O $complex$ O $string$ O O $complex$ O O O O O O O O O O O O O O O $number$ O O O O O $any$ O O $Blob$ O O O O $complex$ O O O O O $any$ O $any$ O $Blob$ O $string$ O O O O $complex$ O O O O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $Blob$ O $string$ O $string$ O $complex$ O $string$ O O O O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O $any$ O $Blob$ O O $Error$ O $Buffer$ O O O O O $Error$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $Error$ O $string$ O $complex$ O $string$ O $string$ O $complex$ O $string$ O O O O O $void$ O $any$ O O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O $any$ O O $any$ O O O O O $VDF_ScreenshotsData$ O $string$ O O $complex$ O $string$ O O O O $any$ O O $any$ O O O O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O $string$ O $complex$ O $string$ O $string$ O $complex$ O $string$ O O O O O O O O O O O $string$ O O O O $string$ O O O O $complex$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O $any$ O $undefined$ O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $Promise<VDF_Error>[]$ O $any$ O $any$ O O $number$ O O O O O $any$ O O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O $any$ O O $any$ O O O O $any$ O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $VDF_Error$ O O $any$ O $any$ O O O O $VDF_Error$ O $boolean$ O O $VDF_Error$ O O O O O $any$ O O $any$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O O O O $any$ O $string$ O $boolean$ O O O O O $any$ O $any$ O O O $string$ O $string$ O $boolean$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O O $void$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O $complex$ O $string$ O O O $string$ O $complex$ O $string$ O $string$ O $complex$ O $string$ O O O $void$ O $string$ O O O O $any$ O O O O O O O $string$ O O $undefined$ O O O
import { VDF_ShortcutsItem } from "s" ; import { VDF_Error } from 's' ; import { APP } from 's' ; import * as steam from 's' ; import * as file from 's' ; import * as _ from "s" ; import * as fs from 's' ; import * as path from 's' ; const shortcutsParser = require ( 's' ) ; export class VDF_ShortcutsFile { private fileData : any = undefined ; private indexMap : { [ appId ] : number } = undefined ; constructor ( private filepath ) { } private get lang ( ) { return APP . lang . vdfFile ; } get data ( ) : VDF_ShortcutsItem [ ] { if ( this . fileData === undefined ) return undefined ; else return this . fileData [ 's' ] ; } set data ( value : VDF_ShortcutsItem [ ] ) { if ( this . fileData === undefined ) return ; else this . fileData [ 's' ] = value ; } get valid ( ) { return this . fileData !== undefined ; } get invalid ( ) { return ! this . valid ; } read ( skipIndexing = false ) { return fs . readFile ( this . filepath ) . catch ( ( error ) => { if ( error . code !== 's' ) { throw new VDF_Error ( APP . lang . vdfFile . error . readingVdf__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } } ) . then ( ( data ) => { if ( data ) this . fileData = shortcutsParser . parseBuffer ( data ) ; else this . fileData = { } ; if ( this . fileData [ 's' ] === undefined ) this . fileData [ 's' ] = [ ] ; let shortcutsData = this . data ; this . indexMap = { } ; if ( ! skipIndexing ) { for ( let i = 0 ; i < shortcutsData . length ; i ++ ) { let shortcut = shortcutsData [ i ] ; this . indexMap [ steam . generateAppId ( shortcut . exe , shortcut . appname || shortcut [ 's' ] ) ] = i ; } } return this . data ; } ) . catch ( ( error ) => { throw new VDF_Error ( this . lang . error . corruptedVdf__i . interpolate ( { filePath : this . filepath , error } ) ) ; } ) ; } write ( ) { return Promise . resolve ( ) . then ( ( ) => { this . fileData [ 's' ] = ( this . fileData [ 's' ] as VDF_ShortcutsItem [ ] ) . filter ( item => item !== undefined ) ; let data = shortcutsParser . writeBuffer ( this . fileData ) ; return fs . outputFile ( this . filepath , data ) ; } ) . catch ( ( error ) => { throw new VDF_Error ( this . lang . error . writingVdf__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } ) ; } backup ( ext , overwrite = false ) { return file . backup ( this . filepath , ext , overwrite ) . catch ( ( error ) => { if ( error . code !== 's' ) { throw new VDF_Error ( this . lang . error . creatingBackup__i . interpolate ( { filePath : this . filepath , error : error } ) ) ; } } ) ; } getItem ( appId ) { if ( this . indexMap [ appId ] !== undefined ) return this . fileData [ 's' ] [ this . indexMap [ appId ] ] ; else return undefined ; } removeItem ( appId ) { if ( this . indexMap [ appId ] !== undefined ) { this . fileData [ 's' ] [ this . indexMap [ appId ] ] = undefined ; this . indexMap [ appId ] = undefined ; } } addItem ( appId , value ) { if ( this . indexMap [ appId ] === undefined ) { this . fileData [ 's' ] . push ( value ) ; this . indexMap [ appId ] = this . fileData [ 's' ] . length - 0 ; } } getAppIds ( ) { return Object . keys ( this . indexMap ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O $undefined$ O O $complex$ O O O $string$ O O O O O $undefined$ O O O O $string$ O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O O $VDF_ShortcutsItem[]$ O O O $any$ O O O O O O O $any$ O $undefined$ O O $undefined$ O O O O O $any$ O O O O O O $VDF_ShortcutsItem[]$ O $VDF_ShortcutsItem[]$ O $any$ O O O O O O O O $any$ O $undefined$ O O O O O O $any$ O O O O $VDF_ShortcutsItem[]$ O O O $boolean$ O O O O O O $any$ O $undefined$ O O O $boolean$ O O O O O O O $boolean$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O O O $string$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O $undefined$ O O O $any$ O O O O O O O O $VDF_ShortcutsItem[]$ O O O $VDF_ShortcutsItem[]$ O O O $complex$ O O O O O O O $boolean$ O O O O O $number$ O O O $number$ O $VDF_ShortcutsItem[]$ O $number$ O $number$ O O O O $VDF_ShortcutsItem$ O $VDF_ShortcutsItem[]$ O $number$ O O O O $complex$ O $any$ O $any$ O $VDF_ShortcutsItem$ O $string$ O $VDF_ShortcutsItem$ O $string$ O $VDF_ShortcutsItem$ O O O O O O $number$ O O O O O O $VDF_ShortcutsItem[]$ O O O O $any$ O O $any$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O O O O O O O O $Promise<any>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $complex$ O $VDF_ShortcutsItem$ O $VDF_ShortcutsItem$ O $undefined$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O $any$ O O O O O $Promise<any>$ O O $any$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O $any$ O $string$ O $boolean$ O O O O O $any$ O $any$ O O O $string$ O $string$ O $boolean$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O O O $any$ O $string$ O O O O O O $complex$ O $string$ O O $undefined$ O O O O $any$ O O O O O O $complex$ O $string$ O O O O O $undefined$ O O $void$ O $string$ O O O O O O $complex$ O $string$ O O $undefined$ O O O O $any$ O O O O O O $complex$ O $string$ O O O $undefined$ O O O $complex$ O $string$ O O $undefined$ O O O $void$ O $string$ O $VDF_ShortcutsItem$ O O O O O O $complex$ O $string$ O O $undefined$ O O O O $any$ O O O O $any$ O $VDF_ShortcutsItem$ O O O O $complex$ O $string$ O O O O $any$ O O O O $any$ O O O O O $string[]$ O O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O
import { PreviewData , VDF_ListData } from "s" ; import { VDF_AddedItemsFile } from "s" ; import { VDF_ScreenshotsFile } from "s" ; import { VDF_ShortcutsFile } from "s" ; import * as path from 's' ; import * as paths from 's' ; export function generateListFromPreviewData ( previewData ) { return Promise . resolve ( ) . then ( ( ) => { let vdfData = { } ; let numberOfGeneratedEntries = 0 ; for ( let directory in previewData ) { for ( let user in previewData [ directory ] ) { if ( vdfData [ directory ] === undefined ) vdfData [ directory ] = { } ; if ( vdfData [ directory ] [ user ] === undefined ) { numberOfGeneratedEntries ++ ; vdfData [ directory ] [ user ] = { addedItems : new VDF_AddedItemsFile ( path . join ( directory , 's' , user , 's' , paths . savedListFilename ) ) , screenshots : new VDF_ScreenshotsFile ( path . join ( directory , 's' , user , 's' , 's' ) , path . join ( directory , 's' , user , 's' , 's' ) ) , shortcuts : new VDF_ShortcutsFile ( path . join ( directory , 's' , user , 's' , 's' ) ) } ; } } } return { data : vdfData , numberOfGeneratedEntries , errors : [ ] as string [ ] } ; } ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $complex$ O $PreviewData$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $VDF_ListData$ O O O O O $number$ O O O O O O $string$ O $PreviewData$ O O O O O $string$ O $PreviewData$ O $string$ O O O O O $VDF_ListData$ O $string$ O O $undefined$ O $VDF_ListData$ O $string$ O O O O O O O $VDF_ListData$ O $string$ O O $string$ O O $undefined$ O O $number$ O O $VDF_ListData$ O $string$ O O $string$ O O O $VDF_AddedItemsFile$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $any$ O $string$ O O O $VDF_ScreenshotsFile$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $VDF_ShortcutsFile$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O O O $VDF_ListData$ O $VDF_ListData$ O $number$ O $string[]$ O O O O O O O O O O O O O
import { VDF_ListData } from "s" ; import { VDF_AddedItemsFile } from "s" ; import { VDF_ScreenshotsFile } from "s" ; import { VDF_ShortcutsFile } from "s" ; import { APP } from "s" ; import * as paths from "s" ; import * as Glob from 's' ; import * as path from 's' ; export function generateListFromDirectoryList ( steamDirectories : string [ ] ) { let retrieveMultipleVDFPaths = function ( steamDirectories : string [ ] ) { let userIdRegex = "s" ; let promises : Promise < { data : { directory : string , users : { id : string , paths : string [ ] } [ ] } , error : string } > [ ] = [ ] ; for ( let i = 0 ; i < steamDirectories . length ; i ++ ) { promises . push ( new Promise < { data : { directory : string , users : { id : string , paths : string [ ] } [ ] } , error : string } > ( ( resolve , reject ) => { Glob ( 's' , { silent : true , dot : true , cwd : steamDirectories [ i ] } , ( error , folders ) => { if ( error ) reject ( error ) ; else if ( folders . length === 0 ) { resolve ( { data : null , error : APP . lang . helpers . error . noUserIdsInDir__i . interpolate ( { steamDirectory : steamDirectories [ i ] } ) } ) ; } else { let users : { id : string , paths : string [ ] } [ ] = [ ] ; for ( let j = 0 ; j < folders . length ; j ++ ) { users . push ( { id : folders [ j ] . match ( userIdRegex ) [ 0 ] , paths : [ path . join ( steamDirectories [ i ] , folders [ j ] , 's' , paths . savedListFilename ) , path . join ( steamDirectories [ i ] , folders [ j ] , 's' , 's' ) , path . join ( steamDirectories [ i ] , folders [ j ] , 's' , 's' ) , path . join ( steamDirectories [ i ] , folders [ j ] , 's' , 's' ) ] } ) ; } resolve ( { data : { directory : steamDirectories [ i ] , users } , error : null } ) ; } } ) ; } ) ) ; } return Promise . all ( promises ) ; } return retrieveMultipleVDFPaths ( steamDirectories ) . then ( ( data ) => { let vdfData = { } ; let numberOfGeneratedEntries = 0 ; let errors : string [ ] = [ ] ; for ( let i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] . error ) errors . push ( data [ i ] . error ) ; else { let directory = data [ i ] . data . directory ; let users = data [ i ] . data . users ; if ( vdfData [ directory ] === undefined ) vdfData [ directory ] = { } ; for ( let j = 0 ; j < users . length ; j ++ ) { let user = users [ j ] ; if ( vdfData [ directory ] [ user . id ] === undefined ) { numberOfGeneratedEntries ++ ; vdfData [ directory ] [ user . id ] = { addedItems : new VDF_AddedItemsFile ( user . paths [ 0 ] ) , screenshots : new VDF_ScreenshotsFile ( path . join ( user . paths [ 0 ] ) , path . join ( user . paths [ 0 ] ) ) , shortcuts : new VDF_ShortcutsFile ( user . paths [ 0 ] ) } ; } } } } return { data : vdfData , numberOfGeneratedEntries , errors } ; } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $complex$ O $string[]$ O O O O O O O $complex$ O O O $string[]$ O O O O O O O $RegExp$ O O O O $complex$ O $PromiseConstructor$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O $complex$ O $number$ O O $PromiseConstructor$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O O O O $void$ O $void$ O O O $any$ O O O O $boolean$ O O O $boolean$ O O O $string$ O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O O $null$ O O O $string$ O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $string[]$ O $number$ O O O O O O O O O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O $complex$ O $number$ O O $any$ O $any$ O $number$ O O $any$ O $RegExp$ O O O O O $any[]$ O O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $number$ O O O O $any$ O $string$ O O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $number$ O O O O O O O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $number$ O O O O O O O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $number$ O O O O O O O O O O O $void$ O O $complex$ O O $string$ O $string[]$ O $number$ O O $complex$ O O $null$ O O O O O O O O O O O O O O O $PromiseConstructor$ O O O $complex$ O O O O $complex$ O $string[]$ O O O O O $complex$ O O O O $VDF_ListData$ O O O O O $number$ O O O O $string[]$ O O O O O O O O O O O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O O O $complex$ O $number$ O O $string$ O $string[]$ O $number$ O $complex$ O $number$ O O $string$ O O O O O $string$ O $complex$ O $number$ O O $complex$ O $string$ O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O O O $VDF_ListData$ O $string$ O O $undefined$ O $VDF_ListData$ O $string$ O O O O O O O O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O O $complex$ O $complex$ O $number$ O O O O $VDF_ListData$ O $string$ O O $complex$ O $string$ O O $undefined$ O O $number$ O O $VDF_ListData$ O $string$ O O $complex$ O $string$ O O O $VDF_AddedItemsFile$ O O $any$ O $complex$ O $string[]$ O O O O O $VDF_ScreenshotsFile$ O O $any$ O $any$ O $any$ O $complex$ O $string[]$ O O O O O $any$ O $any$ O $complex$ O $string[]$ O O O O O O $VDF_ShortcutsFile$ O O $any$ O $complex$ O $string[]$ O O O O O O O O O O O O $VDF_ListData$ O $VDF_ListData$ O $number$ O $string[]$ O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { PreviewDataAppImage , AppImages } from "s" ; export function getMaxLength ( data , images ) { let imagesLength = images [ data . imagePool ] !== undefined ? images [ data . imagePool ] . content . length : 0 ; if ( data . default !== undefined && imagesLength === 0 ) imagesLength ++ ; if ( data . steam !== undefined ) imagesLength ++ ; return imagesLength ; }	O O $any$ O $any$ O O O O O O $number$ O $PreviewDataAppImage$ O $AppImages$ O O O $number$ O $AppImages$ O $PreviewDataAppImage$ O $string$ O O $undefined$ O $AppImages$ O $PreviewDataAppImage$ O $string$ O O $ImageContent[]$ O $number$ O O O O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O $number$ O O O $number$ O O O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O $number$ O O O $number$ O O
import { PreviewDataAppImage , AppImages } from "s" ; import { getMaxLength } from "s" ; export function setImageIndex ( data , images , index ) { let currentIndex = data . imageIndex ; let length = getMaxLength ( data , images ) ; if ( index < 0 ) index = length > 0 ? length - 0 : 0 ; else if ( index >= length ) index = 0 ; data . imageIndex = index ; }	O O $any$ O $any$ O O O O O O $number$ O O O O O O $void$ O $PreviewDataAppImage$ O $AppImages$ O $number$ O O O $number$ O $PreviewDataAppImage$ O $number$ O O $number$ O $number$ O $PreviewDataAppImage$ O $AppImages$ O O O O $number$ O O O $number$ O $number$ O O O $number$ O O O O O O O O $number$ O $number$ O $number$ O O O $PreviewDataAppImage$ O $number$ O $number$ O O
import { PreviewDataAppImage , AppImages } from "s" ; import { getMaxLength } from "s" ; import { setImageIndex } from "s" ; export function getCurrentImage ( data , images ) { let imagesLength = images [ data . imagePool ] !== undefined ? images [ data . imagePool ] . content . length : 0 ; let length = getMaxLength ( data , images ) ; if ( data . imageIndex !== 0 && data . imageIndex >= length ) setImageIndex ( data , images , data . imageIndex ) ; if ( imagesLength === 0 ) { if ( data . imageIndex === 0 && data . steam !== undefined ) return data . steam ; else return data . default || undefined ; } else { if ( data . imageIndex === 0 && data . steam !== undefined ) return data . steam ; else return images [ data . imagePool ] . content [ data . imageIndex - ( data . steam === undefined ? 0 : 0 ) ] ; } }	O O $any$ O $any$ O O O O O O $number$ O O O O O O $void$ O O O O O O $ImageContent$ O $PreviewDataAppImage$ O $AppImages$ O O O $number$ O $AppImages$ O $PreviewDataAppImage$ O $string$ O O $undefined$ O $AppImages$ O $PreviewDataAppImage$ O $string$ O O $ImageContent[]$ O $number$ O O O O $number$ O $number$ O $PreviewDataAppImage$ O $AppImages$ O O O O $PreviewDataAppImage$ O $number$ O O O $PreviewDataAppImage$ O $number$ O $number$ O $void$ O $PreviewDataAppImage$ O $AppImages$ O $PreviewDataAppImage$ O $number$ O O O O $number$ O O O O O O $PreviewDataAppImage$ O $number$ O O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O O $PreviewDataAppImage$ O $ImageContent$ O O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O O O O O O $PreviewDataAppImage$ O $number$ O O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O O $PreviewDataAppImage$ O $ImageContent$ O O O $AppImages$ O $PreviewDataAppImage$ O $string$ O O $ImageContent[]$ O $PreviewDataAppImage$ O $number$ O O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { VDF_ListData , SteamDirectory , PreviewData , AppImages , VDF_ListItem } from "s" ; import { VDF_Error } from 's' ; import { APP } from 's' ; import * as vdf from 's' ; import * as appImage from 's' ; import * as _ from 's' ; export class VDF_Manager { private data : VDF_ListData = { } ; private get lang ( ) { return APP . lang . vdfManager ; } prepare ( data : SteamDirectory [ ] | PreviewData ) { return Promise . resolve ( ) . then ( ( ) => { if ( data instanceof Array ) { if ( data . length > 0 ) return vdf . generateListFromDirectoryList ( data ) ; else throw new VDF_Error ( this . lang . error . emptyDirectoryList ) ; } else return vdf . generateListFromPreviewData ( data ) ; } ) . then ( ( generatedData ) => { if ( generatedData . numberOfGeneratedEntries > 0 ) { this . data = generatedData . data ; if ( generatedData . errors . length > 0 ) return new VDF_Error ( generatedData . errors ) ; } else { if ( generatedData . errors . length > 0 ) throw new VDF_Error ( generatedData . errors ) ; else throw new VDF_Error ( APP . lang . vdfManager . error . noUsersFound ) ; } } ) ; } read ( options ? : { shortcuts ? : { skipIndexing : boolean , read : boolean } , addedItems ? : boolean , screenshots ? : boolean } ) { let promises : Promise < any > [ ] = [ ] ; let readShortcuts = _ . get ( options , 's' , true ) ; let skipIndexing = _ . get ( options , 's' , false ) ; let readAddedItems = _ . get ( options , 's' , true ) ; let readScreenshots = _ . get ( options , 's' , true ) ; for ( let steamDirectory in this . data ) { for ( let userId in this . data [ steamDirectory ] ) { if ( readShortcuts ) promises . push ( this . data [ steamDirectory ] [ userId ] . shortcuts . read ( skipIndexing ) ) ; if ( readAddedItems ) promises . push ( this . data [ steamDirectory ] [ userId ] . addedItems . read ( ) ) ; if ( readScreenshots ) promises . push ( this . data [ steamDirectory ] [ userId ] . screenshots . read ( ) ) ; } } return Promise . all ( promises ) ; } write ( options ? : { shortcuts ? : boolean , addedItems ? : boolean , screenshots ? : boolean } ) { let promises : Promise < VDF_Error > [ ] = [ ] let writeShortcuts = options !== undefined ? options . shortcuts : true ; let writeAddedItems = options !== undefined ? options . addedItems : true ; let writeScreenshots = options !== undefined ? options . screenshots : true ; for ( let steamDirectory in this . data ) { for ( let userId in this . data [ steamDirectory ] ) { if ( writeShortcuts ) promises . push ( this . data [ steamDirectory ] [ userId ] . shortcuts . write ( ) as Promise < undefined > ) ; if ( writeAddedItems ) promises . push ( this . data [ steamDirectory ] [ userId ] . addedItems . write ( ) as Promise < undefined > ) ; if ( writeScreenshots ) promises . push ( this . data [ steamDirectory ] [ userId ] . screenshots . write ( ) ) ; } } return Promise . all ( promises ) . then ( ( errors ) => { if ( errors . length > 0 ) { let error = new VDF_Error ( errors ) ; if ( error . valid ) return error ; } } ) ; } backup ( options ? : { shortcuts ? : boolean , screenshots ? : boolean } ) { let promises : Promise < void > [ ] = [ ] let backupShortcuts = options !== undefined ? options . shortcuts : true ; let backupScreenshots = options !== undefined ? options . screenshots : true ; for ( let steamDirectory in this . data ) { for ( let userId in this . data [ steamDirectory ] ) { if ( backupShortcuts ) { promises . push ( this . data [ steamDirectory ] [ userId ] . shortcuts . backup ( 's' , true ) ) ; promises . push ( this . data [ steamDirectory ] [ userId ] . shortcuts . backup ( 's' ) ) ; } if ( backupScreenshots ) { promises . push ( this . data [ steamDirectory ] [ userId ] . screenshots . backup ( 's' , true ) ) ; promises . push ( this . data [ steamDirectory ] [ userId ] . screenshots . backup ( 's' ) ) ; } } } return Promise . all ( promises ) ; } forEach ( callback : ( steamDirectory , userId , listItem ) => void ) { for ( let steamDirectory in this . data ) { for ( let userId in this . data [ steamDirectory ] ) { callback ( steamDirectory , userId , this . data [ steamDirectory ] [ userId ] ) ; } } } mergeData ( previewData , images ) { return Promise . resolve ( ) . then ( ( ) => { this . forEach ( ( steamDirectory , userId , listItem ) => { let apps = previewData [ steamDirectory ] [ userId ] . apps ; if ( listItem . shortcuts . invalid || listItem . addedItems . invalid || listItem . screenshots . invalid ) return ; for ( let appId in apps ) { let app = apps [ appId ] ; if ( app . status === 's' ) { let item = listItem . shortcuts . getItem ( appId ) ; let currentImage = appImage . getCurrentImage ( app . images , images ) ; if ( item !== undefined ) { item . appname = app . title ; item . exe = app . executableLocation ; item . StartDir = app . startInDirectory ; item . LaunchOptions = app . argumentString ; item . tags = _ . union ( app . steamCategories , item . tags ) ; item . icon = app . icons . length > 0 ? app . icons [ app . currentIconIndex ] : 's' ; } else { listItem . shortcuts . addItem ( appId , { appname : app . title , exe : app . executableLocation , StartDir : app . startInDirectory , LaunchOptions : app . argumentString , tags : app . steamCategories , icon : app . icons . length > 0 ? app . icons [ app . currentIconIndex ] : 's' } ) ; } listItem . addedItems . addItem ( appId ) ; if ( currentImage !== undefined && currentImage . imageProvider !== 's' ) { listItem . screenshots . addItem ( { appId , title : app . title , url : currentImage . imageUrl } ) ; } } else if ( app . status === 's' ) { listItem . shortcuts . removeItem ( appId ) ; listItem . addedItems . removeItem ( appId ) ; listItem . screenshots . removeItem ( appId ) ; app . images . steam = undefined } } } ) ; } ) . catch ( ( error ) => { throw new VDF_Error ( this . lang . error . couldNotMergeEntries__i . interpolate ( { error } ) ) ; } ) ; } removeAllAddedEntries ( ) { return Promise . resolve ( ) . then ( ( ) => { this . forEach ( ( steamDirectory , userId , listItem ) => { let apps = listItem . addedItems . data ; if ( listItem . shortcuts . invalid || listItem . addedItems . invalid || listItem . screenshots . invalid ) return ; for ( let appId in apps ) { let app = apps [ appId ] ; listItem . shortcuts . removeItem ( appId ) ; listItem . screenshots . removeItem ( appId ) ; } listItem . addedItems . data = { } ; } ) ; } ) . catch ( ( error ) => { throw new VDF_Error ( this . lang . error . couldNotRemoveEntries__i . interpolate ( { error } ) ) ; } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $VDF_ListData$ O $any$ O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O $Promise<VDF_Error>$ O $complex$ O $any$ O O O $any$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $complex$ O $ArrayConstructor$ O O O O $string[]$ O $number$ O O O O $any$ O $complex$ O $string[]$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O O O O O $any$ O $complex$ O $PreviewData$ O O O O O O O O $complex$ O O O O O $complex$ O $number$ O O O O O O $VDF_ListData$ O $complex$ O $VDF_ListData$ O O O $complex$ O $string[]$ O $number$ O O O O O $any$ O $complex$ O $string[]$ O O O O O O O $complex$ O $string[]$ O $number$ O O O O O $any$ O $complex$ O $string[]$ O O O O O $any$ O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O $string$ O O O O O O O $Promise<any[]>$ O $complex$ O O O $complex$ O O O $boolean$ O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O O O $Promise<any>[]$ O $PromiseConstructor$ O O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O O O O $string$ O O O $VDF_ListData$ O O O O O $string$ O O O $VDF_ListData$ O $string$ O O O O O $any$ O $Promise<any>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ShortcutsFile$ O $any$ O $any$ O O O O O $any$ O $Promise<any>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_AddedItemsFile$ O $Promise<VDF_AddedItemsData>$ O O O O O O $any$ O $Promise<any>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ScreenshotsFile$ O $any$ O O O O O O O $PromiseConstructor$ O O O $Promise<any>[]$ O O O $Promise<VDF_Error>$ O $complex$ O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O O O $Promise<VDF_Error>[]$ O $PromiseConstructor$ O $any$ O O O O O O O $boolean$ O $complex$ O $undefined$ O $complex$ O $boolean$ O O O O $boolean$ O $complex$ O $undefined$ O $complex$ O $boolean$ O O O O $boolean$ O $complex$ O $undefined$ O $complex$ O $boolean$ O O O O O O $string$ O O O $VDF_ListData$ O O O O O $string$ O O O $VDF_ListData$ O $string$ O O O O O $boolean$ O $Promise<VDF_Error>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ShortcutsFile$ O $Promise<any>$ O O O $PromiseConstructor$ O O O O O O O $boolean$ O $Promise<VDF_Error>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_AddedItemsFile$ O $Promise<any>$ O O O $PromiseConstructor$ O O O O O O O $boolean$ O $Promise<VDF_Error>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ScreenshotsFile$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O $Promise<VDF_Error>[]$ O O O O O $VDF_Error[]$ O O O O O $VDF_Error[]$ O $number$ O O O O O $VDF_Error$ O O $any$ O $VDF_Error[]$ O O O O $VDF_Error$ O $boolean$ O O $VDF_Error$ O O O O O O $Promise<void[]>$ O $complex$ O O O $boolean$ O O O O $boolean$ O O O O O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O $boolean$ O $complex$ O $undefined$ O $complex$ O $boolean$ O O O O $boolean$ O $complex$ O $undefined$ O $complex$ O $boolean$ O O O O O O $string$ O O O $VDF_ListData$ O O O O O $string$ O O O $VDF_ListData$ O $string$ O O O O O $boolean$ O O $Promise<void>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ShortcutsFile$ O $any$ O O O O O O O $Promise<void>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ShortcutsFile$ O $any$ O O O O O O O O $boolean$ O O $Promise<void>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ScreenshotsFile$ O $any$ O O O O O O O $Promise<void>[]$ O $number$ O O O $VDF_ListData$ O $string$ O O $string$ O O $VDF_ScreenshotsFile$ O $any$ O O O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O $void$ O $void$ O O $string$ O $string$ O $VDF_ListItem$ O O O O O O O O $string$ O O O $VDF_ListData$ O O O O O $string$ O O O $VDF_ListData$ O $string$ O O O $void$ O $string$ O $string$ O O O $VDF_ListData$ O $string$ O O $string$ O O O O O O $Promise<void>$ O $PreviewData$ O $AppImages$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $void$ O O $string$ O $string$ O $VDF_ListItem$ O O O O $PreviewDataApps$ O $PreviewData$ O $string$ O O $string$ O O $PreviewDataApps$ O O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $boolean$ O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $boolean$ O $VDF_ListItem$ O $VDF_ScreenshotsFile$ O $boolean$ O O O O O O $string$ O $PreviewDataApps$ O O O $PreviewDataApp$ O $PreviewDataApps$ O $string$ O O O O $PreviewDataApp$ O O O O O O O $any$ O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $any$ O $string$ O O O $ImageContent$ O $any$ O $ImageContent$ O $PreviewDataApp$ O $PreviewDataAppImage$ O $AppImages$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $PreviewDataApp$ O $string$ O $any$ O $any$ O $PreviewDataApp$ O $string$ O $any$ O $any$ O $PreviewDataApp$ O $string$ O $any$ O $any$ O $PreviewDataApp$ O $string$ O $any$ O $any$ O $any$ O $any$ O $PreviewDataApp$ O $string[]$ O $any$ O $any$ O O $any$ O $any$ O $PreviewDataApp$ O $string[]$ O $number$ O O O $PreviewDataApp$ O $string[]$ O $PreviewDataApp$ O $number$ O O O O O O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $void$ O $string$ O O $string$ O $PreviewDataApp$ O $string$ O $string$ O $PreviewDataApp$ O $string$ O $string$ O $PreviewDataApp$ O $string$ O $string$ O $PreviewDataApp$ O $string$ O $string[]$ O $PreviewDataApp$ O $string[]$ O $string$ O $PreviewDataApp$ O $string[]$ O $number$ O O O $PreviewDataApp$ O $string[]$ O $PreviewDataApp$ O $number$ O O O O O O O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $void$ O $string$ O O O O $ImageContent$ O $undefined$ O $ImageContent$ O O O O O O $VDF_ListItem$ O $VDF_ScreenshotsFile$ O $void$ O O $string$ O $string$ O $PreviewDataApp$ O $string$ O $string$ O $ImageContent$ O $string$ O O O O O O O O $PreviewDataApp$ O O O O O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $void$ O $string$ O O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $void$ O $string$ O O $VDF_ListItem$ O $VDF_ScreenshotsFile$ O $void$ O $string$ O O $PreviewDataApp$ O $PreviewDataAppImage$ O $ImageContent$ O $undefined$ O O O O O O O O $complex$ O O $any$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $void$ O O $string$ O $string$ O $VDF_ListItem$ O O O O $VDF_AddedItemsData$ O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $VDF_AddedItemsData$ O O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $boolean$ O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $boolean$ O $VDF_ListItem$ O $VDF_ScreenshotsFile$ O $boolean$ O O O O O O $string$ O $VDF_AddedItemsData$ O O O $true$ O $VDF_AddedItemsData$ O $string$ O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $void$ O $string$ O O $VDF_ListItem$ O $VDF_ScreenshotsFile$ O $void$ O $string$ O O O $VDF_ListItem$ O $VDF_AddedItemsFile$ O $VDF_AddedItemsData$ O O O O O O O O O O $complex$ O O $any$ O O O O O $any$ O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O O O O O O O O O
import { SteamTree , VDF_ShortcutsItem , PreviewData } from "s" ; import { VDF_Manager } from "s" ; import * as _ from "s" ; export function getNonSteamShortcutsData ( tree < { [ appId ] : VDF_ShortcutsItem } > ) { return Promise . resolve ( ) . then ( ( ) => { let data = _ . cloneDeep ( tree ) ; if ( data . numberOfUsers === 0 ) return data ; else { let vdfManager = new VDF_Manager ( ) ; return Promise . resolve ( ) . then ( ( ) => { return vdfManager . prepare ( data . tree as any as PreviewData ) ; } ) . then ( ( ) => { return vdfManager . read ( { shortcuts : { read : true , skipIndexing : true } } ) ; } ) . then ( ( ) => { vdfManager . forEach ( ( steamDirectory , userId , listItem ) => { if ( data . tree [ steamDirectory ] !== undefined && data . tree [ steamDirectory ] [ userId ] !== undefined ) { let appIds = listItem . shortcuts . getAppIds ( ) ; data . tree [ steamDirectory ] [ userId ] = { } ; for ( let i = 0 ; i < appIds . length ; i ++ ) { data . tree [ steamDirectory ] [ userId ] [ appIds [ i ] ] = listItem . shortcuts . getItem ( appIds [ i ] ) ; } } } ) ; return data ; } ) } } ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $Promise<any>$ O $SteamTree$ O O O $string$ O O $any$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O O O $any$ O O O O $VDF_Manager$ O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $VDF_Manager$ O $Promise<VDF_Error>$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O $VDF_Manager$ O $Promise<any[]>$ O O $complex$ O O $true$ O O O $true$ O O O O O O O O O O O O O O O $VDF_Manager$ O $void$ O O $string$ O $string$ O $VDF_ListItem$ O O O O O $any$ O $any$ O $string$ O O $undefined$ O $any$ O $any$ O $string$ O O $string$ O O $undefined$ O O O $string[]$ O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $string[]$ O O O $any$ O $any$ O $string$ O O $string$ O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O $any$ O $any$ O $string$ O O $string$ O O $string[]$ O $number$ O O O $VDF_ListItem$ O $VDF_ShortcutsFile$ O $any$ O $string[]$ O $number$ O O O O O O O O O $any$ O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function encodeFile ( value ) { return encodeURI ( `template` ) . replace ( "s" , 's' ) ; }	O O $string$ O $string$ O O O $string$ O O O O $complex$ O O O O O O O
export * from 's' ;	O O O O O
import { Injectable } from 's' ; import { Http } from 's' ; import { BehaviorSubject , Subject } from 's' ; import { ParsersService } from 's' ; import { LoggerService } from 's' ; import { SettingsService } from 's' ; import { ImageProviderService } from 's' ; import { PreviewData , ImageContent , ParsedUserConfiguration , AppImages , PreviewVariables , ImagesStatusAndContent , ProviderCallbackEventMap , PreviewDataApp , AppSettings , SteamTree , userAccountData } from 's' ; import { VDF_Manager , VDF_Error } from "s" ; import { APP } from 's' ; import { queue } from 's' ; import * as steam from "s" ; import * as url from "s" ; import * as appImage from "s" ; import * as _ from "s" ; import * as fs from "s" ; import * as path from "s" ; @ Injectable ( ) export class PreviewService { private appSettings : AppSettings ; private previewData : PreviewData ; private previewVariables : PreviewVariables ; private previewDataChanged : Subject < boolean > ; private appImages : AppImages ; private allEditedSteamDirectories : string [ ] ; constructor ( private parsersService , private loggerService , private imageProviderService , private settingsService , private http ) { this . previewData = undefined ; this . previewVariables = { listIsBeingSaved : false , listIsBeingGenerated : false , listIsBeingRemoved : false , numberOfQueriedImages : 0 , numberOfListItems : 0 } ; this . previewDataChanged = new Subject < boolean > ( ) ; this . settingsService . onLoad ( ( appSettings ) => { this . appSettings = appSettings ; } ) ; this . appImages = { } ; this . imageProviderService . instance . stopEvent . subscribe ( ( ) => { for ( let imageKey in this . appImages ) { this . appImages [ imageKey ] . retrieving = false ; } this . previewVariables . numberOfQueriedImages = 0 ; this . loggerService . info ( this . lang . info . allImagesRetrieved , { invokeAlert : true , alertTimeout : 0 } ) ; this . previewDataChanged . next ( ) ; } ) ; } get lang ( ) { return APP . lang . preview . service ; } getPreviewData ( ) { return this . previewData ; } getPreviewDataChange ( ) { return this . previewDataChanged ; } getPreviewVariables ( ) { return this . previewVariables ; } generatePreviewData ( ) { if ( this . previewVariables . listIsBeingGenerated ) return this . loggerService . info ( this . lang . info . listIsBeingGenerated , { invokeAlert : true , alertTimeout : 0 } ) ; else if ( this . previewVariables . listIsBeingSaved ) return this . loggerService . info ( this . lang . info . listIsBeingSaved , { invokeAlert : true , alertTimeout : 0 } ) ; else if ( this . previewVariables . listIsBeingRemoved ) return this . loggerService . info ( this . lang . info . listIsBeingRemoved , { invokeAlert : true , alertTimeout : 0 } ) ; this . previewVariables . listIsBeingGenerated = true ; this . imageProviderService . instance . stopUrlDownload ( ) ; this . generatePreviewDataCallback ( ) ; } saveData ( remove ) { if ( this . previewVariables . listIsBeingSaved ) return Promise . resolve ( ) . then ( ( ) => { this . loggerService . info ( this . lang . info . listIsBeingSaved , { invokeAlert : true , alertTimeout : 0 } ) ; return false ; } ) ; else if ( ! remove && this . previewVariables . numberOfListItems === 0 ) return Promise . resolve ( ) . then ( ( ) => { this . loggerService . info ( this . lang . info . listIsEmpty , { invokeAlert : true , alertTimeout : 0 } ) ; return false ; } ) ; else if ( this . previewVariables . listIsBeingRemoved ) return Promise . resolve ( ) . then ( ( ) => { this . loggerService . info ( this . lang . info . listIsBeingRemoved , { invokeAlert : true , alertTimeout : 0 } ) ; return false ; } ) ; else if ( remove && this . appSettings . knownSteamDirectories . length === 0 ) return Promise . resolve ( ) . then ( ( ) => { this . loggerService . error ( this . lang . errors . knownSteamDirListIsEmpty , { invokeAlert : true , alertTimeout : 0 } ) ; return false ; } ) ; let vdfManager = new VDF_Manager ( ) ; this . previewVariables . listIsBeingSaved = true ; this . loggerService . info ( this . lang . info . populatingVDF_List , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . prepare ( remove ? this . appSettings . knownSteamDirectories : this . previewData ) . then ( ( error ) => { if ( error ) { this . loggerService . error ( this . lang . errors . populatingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } this . loggerService . info ( this . lang . info . creatingBackups , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . backup ( ) ; } ) . then ( ( ) => { this . loggerService . info ( this . lang . info . readingVDF_Files , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . read ( ) ; } ) . then ( ( ) => { if ( ! remove ) { this . loggerService . info ( this . lang . info . mergingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . mergeData ( this . previewData , this . appImages ) ; } else { this . loggerService . info ( this . lang . info . removingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . removeAllAddedEntries ( ) ; } } ) . then ( ( ) => { this . loggerService . info ( this . lang . info . writingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; return vdfManager . write ( ) ; } ) . then ( ( error ) => { if ( error ) { this . loggerService . error ( this . lang . errors . savingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } this . loggerService . success ( this . lang . info . updatingKnownSteamDirList , { invokeAlert : true , alertTimeout : 0 } ) ; if ( ! remove ) { let settings = this . settingsService . getSettings ( ) ; settings . knownSteamDirectories = _ . union ( settings . knownSteamDirectories , Object . keys ( this . previewData ) ) ; this . settingsService . settingsChanged ( ) ; } } ) . then ( ( ) => { this . loggerService . success ( this . lang . success . writingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; this . previewVariables . listIsBeingSaved = false ; if ( remove ) { this . loggerService . success ( this . lang . success . removingVDF_entries , { invokeAlert : true , alertTimeout : 0 } ) ; this . clearPreviewData ( ) ; } return true ; } ) . catch ( ( fatalError ) => { this . loggerService . error ( this . lang . errors . fatalError , { invokeAlert : true , alertTimeout : 0 } ) ; if ( fatalError ) this . loggerService . error ( fatalError ) ; this . previewVariables . listIsBeingSaved = false ; return false ; } ) . then ( ( noError ) => { return noError ; } ) ; } loadImage ( app ) { if ( app ) { let image = appImage . getCurrentImage ( app . images , this . appImages ) ; if ( image !== undefined && ( image . loadStatus === 's' || image . loadStatus === 's' ) ) { if ( image . loadStatus === 's' ) { this . loggerService . info ( this . lang . info . retryingDownload__i . interpolate ( { imageUrl : image . imageUrl , appTitle : app . title } ) ) ; } image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; let imageLoader = new Image ( ) ; imageLoader . onload = ( ) => { image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; } ; imageLoader . onerror = ( ) => { this . loggerService . error ( this . lang . errors . retryingDownload__i . interpolate ( { imageUrl : image . imageUrl , appTitle : app . title } ) ) ; image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; } ; imageLoader . src = image . imageUrl ; } } } preloadImages ( ) { for ( let imageKey in this . appImages ) { for ( let i = 0 ; i < this . appImages [ imageKey ] . content . length ; i ++ ) { this . preloadImage ( this . appImages [ imageKey ] . content [ i ] ) ; } } } preloadImage ( image ) { if ( image && image . loadStatus === 's' || image . loadStatus === 's' ) { image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; let imageLoader = new Image ( ) ; imageLoader . onload = ( ) => { image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; } ; imageLoader . onerror = ( ) => { image . loadStatus = 's' ; this . previewDataChanged . next ( ) ; } ; imageLoader . src = image . imageUrl ; } } setImageIndex ( app , index ) { if ( app ) { appImage . setImageIndex ( app . images , this . appImages , index ) ; this . previewDataChanged . next ( ) ; } } areImagesAvailable ( app ) { return this . getTotalLengthOfImages ( app ) > 0 ; } getTotalLengthOfImages ( app ) { if ( app ) return appImage . getMaxLength ( app . images , this . appImages ) ; else return 0 ; } getCurrentImage ( app ) { return appImage . getCurrentImage ( app . images , this . appImages ) ; } setIconIndex ( app , index ) { if ( app && app . icons . length ) { app . currentIconIndex = index < 0 ? app . icons . length - 0 : ( index < app . icons . length ? index : 0 ) ; this . previewDataChanged . next ( ) ; } } get images ( ) { return this . appImages ; } clearPreviewData ( ) { this . previewData = undefined ; this . clearImageCache ( true ) ; this . previewVariables . numberOfListItems = 0 ; this . previewDataChanged . next ( ) ; } private clearImageCache ( settingsOnly ) { for ( let imageKey in this . appImages ) { this . appImages [ imageKey ] . defaultImageProviders = [ ] ; this . appImages [ imageKey ] . searchQueries = [ ] ; this . appImages [ imageKey ] . retrieving = false ; if ( ! settingsOnly ) this . appImages [ imageKey ] . content = [ ] ; } } private generatePreviewDataCallback ( ) { if ( this . previewVariables . numberOfQueriedImages !== 0 ) { setTimeout ( this . generatePreviewDataCallback . bind ( this ) , 0 ) ; } else { let oldPreviewData = this . previewData ; this . previewData = undefined ; this . loggerService . info ( this . lang . info . executingParsers , { invokeAlert : true } ) ; this . parsersService . executeFileParser ( ) . then ( ( data ) => { if ( data . skipped . length > 0 ) { this . loggerService . info ( this . lang . info . disabledConfigurations__i . interpolate ( { count : data . skipped . length } ) , { invokeAlert : true , alertTimeout : 0 } ) ; for ( let i = 0 ; i < data . skipped . length ; i ++ ) { this . loggerService . info ( data . skipped [ i ] ) ; } } if ( data . invalid . length > 0 ) { this . loggerService . info ( this . lang . info . invalidConfigurations__i . interpolate ( { count : data . invalid . length } ) , { invokeAlert : true , alertTimeout : 0 } ) ; for ( let i = 0 ; i < data . invalid . length ; i ++ ) { this . loggerService . info ( data . invalid [ i ] ) ; } } if ( data . parsedData . parsedConfigs . length > 0 ) { if ( data . parsedData . noUserAccounts ) { this . loggerService . info ( this . lang . info . noAccountsWarning , { invokeAlert : true , alertTimeout : 0 } ) ; } else { this . loggerService . info ( this . lang . info . shutdownSteam , { invokeAlert : true , alertTimeout : 0 } ) ; return this . createPreviewData ( data . parsedData . parsedConfigs , oldPreviewData ) ; } } else if ( data . invalid . length === 0 && data . skipped . length === 0 ) { if ( this . parsersService . getUserConfigurationsArray ( ) . length === 0 ) this . loggerService . info ( this . lang . info . noParserConfigurations , { invokeAlert : true , alertTimeout : 0 } ) ; else this . loggerService . info ( this . lang . info . parserFoundNoFiles , { invokeAlert : true , alertTimeout : 0 } ) ; } } ) . then ( ( previewData ) => { if ( previewData && previewData . numberOfItems > 0 ) { this . previewData = previewData . data ; this . previewVariables . numberOfListItems = previewData . numberOfItems ; this . downloadImageUrls ( ) ; } else { this . previewVariables . numberOfListItems = 0 ; } this . previewVariables . listIsBeingGenerated = false ; this . previewDataChanged . next ( ) ; } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . errors . fatalError , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; this . previewVariables . listIsBeingGenerated = false ; this . previewDataChanged . next ( ) ; } ) ; } } private createPreviewData ( data : ParsedUserConfiguration [ ] , oldData ? ) { return Promise . resolve ( ) . then ( ( ) => { let steamTreeData = steam . generateTreeFromParsedConfig ( data ) ; if ( this . appSettings . previewSettings . retrieveCurrentSteamImages ) return steam . getGridImagesForTree ( steamTreeData ) . then ( ( gridData ) => { return { gridData , steamTreeData } } ) ; else return { gridData : steamTreeData , steamTreeData } ; } ) . then ( ( treeData ) => { return steam . getNonSteamShortcutsData ( treeData . steamTreeData ) . then ( ( shortcutData ) => { return Object . assign ( treeData , { shortcutData } ) ; } ) ; } ) . then ( ( treeData ) => { let shortcutsData = treeData . shortcutData . tree ; let gridData = treeData . gridData . tree ; let numberOfItems = 0 ; let previewData = { } ; this . clearImageCache ( true ) ; for ( let i = 0 ; i < data . length ; i ++ ) { let config = data [ i ] ; let oldDataDir = oldData !== undefined ? oldData [ config . steamDirectory ] : undefined ; if ( previewData [ config . steamDirectory ] === undefined ) previewData [ config . steamDirectory ] = { } ; for ( let j = 0 ; j < config . foundUserAccounts . length ; j ++ ) { let userAccount = config . foundUserAccounts [ j ] ; let oldDataAccount = oldDataDir !== undefined ? oldDataDir [ userAccount . accountID ] : undefined ; if ( previewData [ config . steamDirectory ] [ userAccount . accountID ] === undefined ) { previewData [ config . steamDirectory ] [ userAccount . accountID ] = { username : userAccount . name , apps : { } } ; } else if ( previewData [ config . steamDirectory ] [ userAccount . accountID ] . username !== userAccount . name ) { previewData [ config . steamDirectory ] [ userAccount . accountID ] . username = `template` ; } for ( let k = 0 ; k < data [ i ] . files . length ; k ++ ) { let file = config . files [ k ] ; let executableLocation = ( config . appendArgsToExecutable ? `template` : `template` ) . trim ( ) ; let appID = steam . generateAppId ( executableLocation , file . finalTitle ) ; let oldDataApp = oldDataAccount !== undefined ? oldDataAccount . apps [ appID ] : undefined ; if ( shortcutsData [ config . steamDirectory ] [ userAccount . accountID ] [ appID ] !== undefined ) { if ( shortcutsData [ config . steamDirectory ] [ userAccount . accountID ] [ appID ] [ 's' ] !== undefined ) { if ( file . localIcons . indexOf ( shortcutsData [ config . steamDirectory ] [ userAccount . accountID ] [ appID ] [ 's' ] ) === - 0 ) { file . localIcons . unshift ( shortcutsData [ config . steamDirectory ] [ userAccount . accountID ] [ appID ] [ 's' ] ) ; } } } if ( this . appImages [ file . imagePool ] === undefined ) { this . appImages [ file . imagePool ] = { retrieving : false , searchQueries : file . onlineImageQueries , defaultImageProviders : config . imageProviders , content : [ ] } ; } else { let currentQueries = this . appImages [ file . imagePool ] . searchQueries ; let currentProviders = this . appImages [ file . imagePool ] . defaultImageProviders ; this . appImages [ file . imagePool ] . searchQueries = _ . union ( currentQueries , file . onlineImageQueries ) ; this . appImages [ file . imagePool ] . defaultImageProviders = _ . union ( currentProviders , config . imageProviders ) ; } if ( previewData [ config . steamDirectory ] [ userAccount . accountID ] . apps [ appID ] === undefined ) { let steamImage = gridData [ config . steamDirectory ] [ userAccount . accountID ] [ appID ] ; let steamImageUrl = steamImage ? url . encodeFile ( steamImage ) : undefined ; let currentIconIndex = oldDataApp !== undefined ? oldDataApp . currentIconIndex : 0 ; if ( 0 > currentIconIndex || currentIconIndex > file . localIcons . length ) currentIconIndex = 0 ; previewData [ config . steamDirectory ] [ userAccount . accountID ] . apps [ appID ] = { entryId : numberOfItems ++ , status : 's' , configurationTitle : config . configurationTitle , steamCategories : file . steamCategories , startInDirectory : file . startInDirectory , imageProviders : config . imageProviders , argumentString : config . appendArgsToExecutable ? 's' : file . argumentString , title : file . finalTitle , images : { steam : steamImage ? { imageProvider : 's' , imageUrl : steamImageUrl , loadStatus : 's' } : undefined , default : file . defaultImage ? { imageProvider : 's' , imageUrl : file . defaultImage , loadStatus : 's' } : undefined , imagePool : file . imagePool , imageIndex : 0 } , executableLocation , currentIconIndex , icons : file . localIcons } ; } else { let currentCategories = previewData [ config . steamDirectory ] [ userAccount . accountID ] . apps [ appID ] . steamCategories ; previewData [ config . steamDirectory ] [ userAccount . accountID ] . apps [ appID ] . steamCategories = _ . union ( currentCategories , file . steamCategories ) ; } for ( let l = 0 ; l < file . localImages . length ; l ++ ) { this . addUniqueImage ( file . imagePool , { imageProvider : 's' , imageUrl : file . localImages [ l ] , loadStatus : 's' } ) ; } } } } return { numberOfItems : numberOfItems , data : previewData } ; } ) ; } downloadImageUrls ( imageKeys ? : string [ ] , imageProviders ? : string [ ] ) { if ( ! this . appSettings . offlineMode ) { let allImagesRetrieved = true ; let imageQueue = queue ( ( task , callback ) => callback ( ) ) ; if ( imageKeys === undefined || imageKeys . length === 0 ) { imageKeys = Object . keys ( this . appImages ) ; } for ( let i = 0 ; i < imageKeys . length ; i ++ ) { let image = this . appImages [ imageKeys [ i ] ] ; let imageProvidersForKey : string [ ] = imageProviders === undefined || imageProviders . length === 0 ? image . defaultImageProviders : imageProviders ; imageProvidersForKey = _ . intersection ( this . appSettings . enabledProviders , imageProvidersForKey ) ; if ( image !== undefined && ! image . retrieving ) { let numberOfQueriesForImageKey = image . searchQueries . length * imageProvidersForKey . length ; if ( numberOfQueriesForImageKey > 0 ) { image . retrieving = true ; allImagesRetrieved = false ; this . previewVariables . numberOfQueriedImages += numberOfQueriesForImageKey ; for ( let j = 0 ; j < image . searchQueries . length ; j ++ ) { this . imageProviderService . instance . retrieveUrls ( image . searchQueries [ j ] , imageProvidersForKey , < K extends keyof ProviderCallbackEventMap > ( event : K , data : ProviderCallbackEventMap [ K ] ) => { switch ( event ) { case 's' : { let errorData = ( data as ProviderCallbackEventMap [ 's' ] ) ; if ( typeof errorData . error === 's' ) { this . loggerService . error ( this . lang . errors . providerError__i . interpolate ( { provider : errorData . provider , code : errorData . error , title : errorData . title , url : errorData . url } ) ) ; } else { this . loggerService . error ( this . lang . errors . unknownProviderError__i . interpolate ( { provider : errorData . provider , title : errorData . title , error : errorData . error } ) ) ; } } break ; case 's' : { let timeoutData = ( data as ProviderCallbackEventMap [ 's' ] ) ; this . loggerService . info ( this . lang . info . providerTimeout__i . interpolate ( { time : timeoutData . time , provider : timeoutData . provider } ) , { invokeAlert : true , alertTimeout : 0 } ) ; } break ; case 's' : imageQueue . push ( null , ( ) => { let newImage = this . addUniqueImage ( imageKeys [ i ] , ( data as ProviderCallbackEventMap [ 's' ] ) . content ) ; if ( newImage !== null && this . appSettings . previewSettings . preload ) this . preloadImage ( newImage ) ; this . previewDataChanged . next ( ) ; } ) ; break ; case 's' : { if ( -- numberOfQueriesForImageKey === 0 ) { image . retrieving = false ; } if ( -- this . previewVariables . numberOfQueriedImages === 0 ) { this . loggerService . info ( this . lang . info . allImagesRetrieved , { invokeAlert : true , alertTimeout : 0 } ) ; } this . previewDataChanged . next ( ) ; } break ; default : break ; } } ) ; } } } } this . previewDataChanged . next ( ) ; if ( allImagesRetrieved ) { this . loggerService . info ( this . lang . info . allImagesRetrieved , { invokeAlert : true , alertTimeout : 0 } ) ; } } else this . previewDataChanged . next ( ) ; } isImageUnique ( imageKey , imageUrl ) { return this . appImages [ imageKey ] . content . findIndex ( ( item ) => item . imageUrl === imageUrl ) === - 0 ; } addUniqueImage ( imageKey , content ) { if ( this . isImageUnique ( imageKey , content . imageUrl ) ) { this . appImages [ imageKey ] . content . push ( content ) ; return this . appImages [ imageKey ] . content [ this . appImages [ imageKey ] . content . length - 0 ] ; } return null ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O $AppSettings$ O $any$ O O $PreviewData$ O $any$ O O $PreviewVariables$ O $any$ O O $any$ O $any$ O O O O O $AppImages$ O $any$ O O $string[]$ O O O O O O O O $ParsersService$ O O $LoggerService$ O O $ImageProviderService$ O O $SettingsService$ O O $Http$ O O O O $PreviewData$ O $undefined$ O O O $PreviewVariables$ O O $false$ O O O $false$ O O O $false$ O O O $number$ O O O $number$ O O O O O O $any$ O O $any$ O O O O O O O O $SettingsService$ O $void$ O O $AppSettings$ O O O O O $AppSettings$ O $AppSettings$ O O O O O O $AppImages$ O O O O O O $ImageProviderService$ O $ImageProvider$ O $any$ O $any$ O O O O O O O O $string$ O O O $AppImages$ O O O O $AppImages$ O $string$ O O $boolean$ O O O O O O $PreviewVariables$ O $number$ O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O O O $PreviewData$ O O O O O O $PreviewData$ O O $any$ O O O O O O $any$ O O $PreviewVariables$ O O O O O O $PreviewVariables$ O O $void$ O O O O O O O $PreviewVariables$ O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O $PreviewVariables$ O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O $PreviewVariables$ O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O $PreviewVariables$ O $boolean$ O O O O O $ImageProviderService$ O $ImageProvider$ O $void$ O O O O O $void$ O O O O $Promise<boolean>$ O $boolean$ O O O O O O $PreviewVariables$ O $boolean$ O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O O O O O O $boolean$ O O O $PreviewVariables$ O $number$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O O O O O O O $PreviewVariables$ O $boolean$ O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O O O O O $boolean$ O O O $AppSettings$ O $string[]$ O $number$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O O O O O O $VDF_Manager$ O O $any$ O O O O O $PreviewVariables$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<VDF_Error>$ O $boolean$ O O O $AppSettings$ O $string[]$ O O O $PreviewData$ O O O O O $VDF_Error$ O O O O O $VDF_Error$ O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $VDF_Error$ O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<void[]>$ O O O O O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<any[]>$ O O O O O O O O O O O O O O O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<void>$ O O O $PreviewData$ O O O $AppImages$ O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<void>$ O O O O O O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O $VDF_Manager$ O $Promise<VDF_Error>$ O O O O O O O O O $VDF_Error$ O O O O O $VDF_Error$ O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $VDF_Error$ O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O $boolean$ O O O $AppSettings$ O O O $SettingsService$ O $AppSettings$ O O O $AppSettings$ O $string[]$ O $any$ O $any$ O $AppSettings$ O $string[]$ O $ObjectConstructor$ O $complex$ O O O $PreviewData$ O O O O O $SettingsService$ O $void$ O O O O O O O O O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $PreviewVariables$ O $boolean$ O O O O O $boolean$ O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $void$ O O O O O O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $any$ O O O $LoggerService$ O $void$ O $any$ O O O O $PreviewVariables$ O $boolean$ O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewDataApp$ O O O $ImageContent$ O $any$ O $ImageContent$ O $PreviewDataApp$ O $PreviewDataAppImage$ O O O $AppImages$ O O O O $ImageContent$ O $undefined$ O O $ImageContent$ O $ImageDownloadStatus$ O O O $ImageContent$ O O O O O O O O O $ImageContent$ O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O $string$ O O $string$ O $ImageContent$ O $string$ O $string$ O $PreviewDataApp$ O $string$ O O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $HTMLImageElement$ O $any$ O O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O O $HTMLImageElement$ O $OnErrorEventHandlerNonNull$ O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O $string$ O O $string$ O $ImageContent$ O $string$ O $string$ O $PreviewDataApp$ O $string$ O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O O $HTMLImageElement$ O $string$ O $ImageContent$ O $string$ O O O O $void$ O O O O O O $string$ O O O $AppImages$ O O O O O $number$ O O O $number$ O O O $AppImages$ O $string$ O O $ImageContent[]$ O $number$ O $number$ O O O O O $void$ O O O $AppImages$ O $string$ O O $ImageContent[]$ O $number$ O O O O O O $void$ O $ImageContent$ O O O O $ImageContent$ O $ImageContent$ O $ImageDownloadStatus$ O O O $ImageContent$ O $ImageDownloadStatus$ O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $HTMLImageElement$ O $any$ O O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O O $HTMLImageElement$ O $OnErrorEventHandlerNonNull$ O O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O $any$ O $any$ O O O O O $HTMLImageElement$ O $string$ O $ImageContent$ O $string$ O O O $void$ O $PreviewDataApp$ O $number$ O O O O $PreviewDataApp$ O O $any$ O $void$ O $PreviewDataApp$ O $PreviewDataAppImage$ O O O $AppImages$ O $number$ O O O O $any$ O $any$ O O O O O $boolean$ O $PreviewDataApp$ O O O O O $number$ O $PreviewDataApp$ O O O O O $number$ O $PreviewDataApp$ O O O O $PreviewDataApp$ O O $any$ O $number$ O $PreviewDataApp$ O $PreviewDataAppImage$ O O O $AppImages$ O O O O O O O $ImageContent$ O $PreviewDataApp$ O O O $any$ O $ImageContent$ O $PreviewDataApp$ O $PreviewDataAppImage$ O O O $AppImages$ O O O $void$ O $PreviewDataApp$ O $number$ O O O O $PreviewDataApp$ O $PreviewDataApp$ O $string[]$ O $number$ O O $PreviewDataApp$ O $number$ O $number$ O O O $PreviewDataApp$ O $string[]$ O $number$ O O O O $number$ O $PreviewDataApp$ O $string[]$ O $number$ O $number$ O O O O O O $any$ O $any$ O O O O O O $AppImages$ O O O O O O $AppImages$ O O $void$ O O O O O $PreviewData$ O $undefined$ O O O $void$ O O O O O O $PreviewVariables$ O $number$ O O O O O $any$ O $any$ O O O O O $void$ O $boolean$ O O O O O $string$ O O O $AppImages$ O O O O $AppImages$ O $string$ O O $string[]$ O O O O O O $AppImages$ O $string$ O O $string[]$ O O O O O O $AppImages$ O $string$ O O $boolean$ O O O O O O $boolean$ O O O $AppImages$ O $string$ O O $ImageContent[]$ O O O O O O O $void$ O O O O O O O $PreviewVariables$ O $number$ O O O O $number$ O O O $void$ O $any$ O O O O O O O O O O O $PreviewData$ O O O $PreviewData$ O O O $PreviewData$ O $undefined$ O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O O O O O $ParsersService$ O $complex$ O O O O O O $complex$ O O O O O $complex$ O $string[]$ O $number$ O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O $string$ O O $number$ O $complex$ O $string[]$ O $number$ O O O O $true$ O O O $number$ O O O O O O O O $number$ O O O $number$ O $complex$ O $string[]$ O $number$ O $number$ O O O O O $LoggerService$ O $void$ O $complex$ O $string[]$ O $number$ O O O O O O O $complex$ O $string[]$ O $number$ O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O $string$ O O $number$ O $complex$ O $string[]$ O $number$ O O O O $true$ O O O $number$ O O O O O O O O $number$ O O O $number$ O $complex$ O $string[]$ O $number$ O $number$ O O O O O $LoggerService$ O $void$ O $complex$ O $string[]$ O $number$ O O O O O O O $complex$ O $complex$ O $ParsedUserConfiguration[]$ O $number$ O O O O O O $complex$ O $complex$ O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O $complex$ O $complex$ O $complex$ O $ParsedUserConfiguration[]$ O $PreviewData$ O O O O O O O $complex$ O $string[]$ O $number$ O O O $complex$ O $string[]$ O $number$ O O O O O O O O $ParsersService$ O $any$ O O O $any$ O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O O O $complex$ O O O O O $complex$ O $complex$ O $number$ O O O O O O $PreviewData$ O $complex$ O $PreviewData$ O O O $PreviewVariables$ O $number$ O $complex$ O $number$ O O O $void$ O O O O O O O O $PreviewVariables$ O $number$ O O O O O O $PreviewVariables$ O $boolean$ O O O O O $any$ O $any$ O O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O $PreviewVariables$ O $boolean$ O O O O O $any$ O $any$ O O O O O O O O O $complex$ O $ParsedUserConfiguration[]$ O $any$ O O O $PreviewData$ $PreviewData$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $SteamTree<any>$ O $any$ O $SteamTree<any>$ O $ParsedUserConfiguration[]$ O O O O O O $AppSettings$ O $PreviewSettings$ O $boolean$ O O $any$ O $Promise<any>$ O $SteamTree<any>$ O O O O O $any$ O O O O O $any$ O $SteamTree<any>$ O O O O O O O $SteamTree<any>$ O $SteamTree<any>$ O $SteamTree<any>$ O O O O O O O O $complex$ O O O O $any$ O $Promise<any>$ O $complex$ O $SteamTree<any>$ O O O O O $any$ O O O O $ObjectConstructor$ O O O $complex$ O O $any$ O O O O O O O O O O O O $complex$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $complex$ O $any$ O $any$ O O $number$ O O O O $PreviewData$ O O O O O O $void$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration[]$ O $number$ O $number$ O O O O $ParsedUserConfiguration$ O $ParsedUserConfiguration[]$ O $number$ O O O $complex$ O $PreviewData$ O $undefined$ O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $undefined$ O O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $undefined$ O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O $number$ O O O O $userAccountData$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O O $PreviewDataUser$ O $complex$ O $undefined$ O $complex$ O $userAccountData$ O $string$ O O $undefined$ O O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $undefined$ O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O O $string$ O $userAccountData$ O $string$ O ${}$ O O O O O O O O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $string$ O $userAccountData$ O $string$ O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $string$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration[]$ O $number$ O O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O O $ParsedUserConfigurationFile$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O O $string$ O O $ParsedUserConfiguration$ O $boolean$ O O O O O O $string$ O O O O $any$ O $any$ O $any$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O O O $PreviewDataApp$ O $PreviewDataUser$ O $undefined$ O $PreviewDataUser$ O $PreviewDataApps$ O $any$ O O $undefined$ O O O $any$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $any$ O O $undefined$ O O O O $any$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $any$ O O O O O $undefined$ O O O O $ParsedUserConfigurationFile$ O $string[]$ O $number$ O $any$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $any$ O O O O O O O O O O $ParsedUserConfigurationFile$ O $string[]$ O $number$ O $any$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $any$ O O O O O O O O O O O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O $undefined$ O O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O O $false$ O O O $string[]$ O $ParsedUserConfigurationFile$ O $string[]$ O $string[]$ O $ParsedUserConfiguration$ O $string[]$ O $undefined[]$ O O O O O O O O O $string[]$ O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O $string[]$ O O $string[]$ O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O $string[]$ O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O $string[]$ O $any$ O $any$ O $string[]$ O $ParsedUserConfigurationFile$ O $string[]$ O O O O $AppImages$ O $ParsedUserConfigurationFile$ O $string$ O O $string[]$ O $any$ O $any$ O $string[]$ O $ParsedUserConfiguration$ O $string[]$ O O O O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $PreviewDataApps$ O $any$ O O $undefined$ O O O $any$ O $any$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $any$ O O O $string$ O $any$ O $any$ O $string$ O $any$ O O $undefined$ O O $number$ O $PreviewDataApp$ O $undefined$ O $PreviewDataApp$ O $number$ O O O O O O O $number$ O $number$ O $ParsedUserConfigurationFile$ O $string[]$ O $number$ O $number$ O O O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $PreviewDataApps$ O $any$ O O O $number$ O $number$ O O O O O O $string$ O $ParsedUserConfiguration$ O $string$ O $string[]$ O $ParsedUserConfigurationFile$ O $string[]$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string[]$ O $ParsedUserConfiguration$ O $string[]$ O $string$ O $ParsedUserConfiguration$ O $boolean$ O O O $ParsedUserConfigurationFile$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $complex$ O O $complex$ O $any$ O O O O O O $string$ O $string$ O O O O O O $undefined$ O $complex$ O $ParsedUserConfigurationFile$ O $string$ O O O O O O $string$ O $ParsedUserConfigurationFile$ O $string$ O O O O O O $undefined$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $number$ O O O O $string$ O $number$ O $string[]$ O $ParsedUserConfigurationFile$ O $string[]$ O O O O O O $string[]$ O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $PreviewDataApps$ O $any$ O O $string[]$ O $PreviewData$ O $ParsedUserConfiguration$ O $string$ O O $userAccountData$ O $string$ O O $PreviewDataApps$ O $any$ O O $string[]$ O $any$ O $any$ O $string[]$ O $ParsedUserConfigurationFile$ O $string[]$ O O O O O O $number$ O O O $number$ O $ParsedUserConfigurationFile$ O $string[]$ O $number$ O $number$ O O O O O $ImageContent$ O $ParsedUserConfigurationFile$ O $string$ O O O O O O $string$ O $ParsedUserConfigurationFile$ O $string[]$ O $number$ O O O O O O O O O O O O O O $number$ O $number$ O $PreviewData$ O $PreviewData$ O O O O O O $void$ O $string[]$ O O O O O O $string[]$ O O O O O O O O O O O O $AppSettings$ O $boolean$ O O O $boolean$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $string[]$ O $undefined$ O $string[]$ O $number$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O O O $AppImages$ O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $ImagesStatusAndContent$ O O O $AppImages$ O $string[]$ O $number$ O O O O $string[]$ O O O O O $string[]$ O $undefined$ O $string[]$ O $number$ O O O $ImagesStatusAndContent$ O $string[]$ O $string[]$ O $string[]$ O $any$ O $any$ O O O $AppSettings$ O $string[]$ O $string[]$ O O O O $ImagesStatusAndContent$ O $undefined$ O O $ImagesStatusAndContent$ O $boolean$ O O O $number$ O $ImagesStatusAndContent$ O $string[]$ O $number$ O $string[]$ O $number$ O O O $number$ O O O O $ImagesStatusAndContent$ O $boolean$ O O O $boolean$ O O O O O $PreviewVariables$ O $number$ O $number$ O O O O $number$ O O O $number$ O $ImagesStatusAndContent$ O $string[]$ O $number$ O $number$ O O O O O $ImageProviderService$ O $ImageProvider$ O $void$ O $ImagesStatusAndContent$ O $string[]$ O $number$ O O $string[]$ O O $any$ O O $any$ O O $K$ O $any$ O $ProviderCallbackEventMap[K]$ O $any$ O $any$ O O O O O O $K$ O O O O O O O $ProviderErrorData$ O O $ProviderCallbackEventMap[K]$ O $any$ O O O O O O O O $ProviderErrorData$ O $complex$ O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O $string$ O O O O $ProviderErrorData$ O O O $number$ O $ProviderErrorData$ O $number$ O $string$ O $ProviderErrorData$ O $string$ O $string$ O $ProviderErrorData$ O $string$ O O O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O $string$ O O O O $ProviderErrorData$ O O O $string$ O $ProviderErrorData$ O $string$ O $string$ O $ProviderErrorData$ O $string$ O O O O O O O O O O O O O $ProviderTimeoutData$ O O $ProviderCallbackEventMap[K]$ O $any$ O O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O $string$ O O $number$ O $ProviderTimeoutData$ O $number$ O O O $ProviderTimeoutData$ O O O O O O $true$ O O O $number$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $ImageContent$ O O O $ImageContent$ O $string[]$ O $number$ O O O $ProviderCallbackEventMap[K]$ O $any$ O O O O O $ImageContent$ O O O O $ImageContent$ O O O O O $AppSettings$ O $PreviewSettings$ O $boolean$ O O O $void$ O $ImageContent$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O $number$ O O O O $ImagesStatusAndContent$ O $boolean$ O O O O O O O O O $PreviewVariables$ O $number$ O O O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $boolean$ O O O O $LoggerService$ O $void$ O O O O O O O $string$ O O $true$ O O O $number$ O O O O O O O O O O $any$ O $any$ O O O O $boolean$ O $string$ O $string$ O O O O O $AppImages$ O $string$ O O $ImageContent[]$ O $number$ O O $ImageContent$ O O $ImageContent$ O $string$ O $string$ O O O O O O $ImageContent$ O $string$ O $ImageContent$ O O O O O O $boolean$ O $string$ O $ImageContent$ O $string$ O O O O O $AppImages$ O $string$ O O $ImageContent[]$ O $number$ O $ImageContent$ O O O O O $AppImages$ O $string$ O O $ImageContent[]$ O O O $AppImages$ O $string$ O O $ImageContent[]$ O $number$ O O O O O O O O O O
import { Injectable } from 's' ; import { SettingsService } from "s" ; import { languageManager } from "s" ; import { APP } from 's' ; import { BehaviorSubject } from 's' ; @ Injectable ( ) export class LanguageService { private languageChange = new BehaviorSubject < string > ( null ) ; constructor ( private settingsService ) { this . settingsService . onLoad ( ( appSettings ) => { APP . lang = languageManager . getLanguage ( appSettings . language ) ; this . languageChange . next ( appSettings . language ) ; } ) ; } observeChanges ( ) { return this . languageChange . asObservable ( ) ; } getAvailableLanguages ( ) { return languageManager . getAvailableLanguages ( ) ; } loadLanguage ( languageKey ) { if ( languageKey !== this . languageChange . getValue ( ) ) { APP . lang = languageManager . getLanguage ( languageKey ) ; this . languageChange . next ( languageKey ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $LanguageManager$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O O O O O O O O O O $SettingsService$ O O O O $SettingsService$ O $void$ O O $AppSettings$ O O O $GlobalContainer$ O $languageStruct$ O $LanguageManager$ O $languageStruct$ O $AppSettings$ O $string$ O O O O $any$ O $any$ O $AppSettings$ O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $string[]$ O O O O $LanguageManager$ O $string[]$ O O O O $void$ O $string$ O O O O $string$ O O O $any$ O $any$ O O O O $GlobalContainer$ O $languageStruct$ O $LanguageManager$ O $languageStruct$ O $string$ O O O O $any$ O $any$ O $string$ O O O O O
import { Injectable } from 's' ; import { MarkdownIt } from 's' ; import * as markdownIt from 's' ; @ Injectable ( ) export class MarkdownService { private instanceMap : Map < string , MarkdownIt > = new Map < string , MarkdownIt > ( ) ; private defaultId : string = undefined ; createInstance ( id , instance ) { if ( this . instanceMap . has ( id ) ) return this . instanceMap . get ( id ) ; else { if ( this . defaultId === undefined ) this . defaultId = id ; return this . instanceMap . set ( id , instance ) . get ( id ) ; } } getInstance ( id ) { return this . instanceMap . get ( id ) ; } deleteInstance ( id ) { if ( this . instanceMap . has ( id ) ) { if ( this . defaultId === id ) this . defaultId = undefined ; this . instanceMap . delete ( id ) ; } } compile ( text , id ? , env ? ) { let instance = id != undefined ? this . instanceMap . get ( id ) : ( this . defaultId ? this . instanceMap . get ( this . defaultId ) : undefined ) ; if ( instance !== undefined ) return instance . render ( text , env ) ; else return new markdownIt ( ) . render ( text , env ) ; } }	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O O $complex$ O $MapConstructor$ O O O $any$ O O O $MapConstructor$ O O O $any$ O O O O O $string$ O O O $undefined$ O $any$ O $string$ O $MarkdownIt$ O O O O O O $complex$ O $boolean$ O $string$ O O O O O $complex$ O $any$ O $string$ O O O O O O O O $string$ O $undefined$ O O O $string$ O $string$ O O O O $complex$ O $complex$ O $string$ O $any$ O O $any$ O $string$ O O O O $any$ O $string$ O O O O O $complex$ O $any$ O $string$ O O O $void$ O $string$ O O O O O O $complex$ O $boolean$ O $string$ O O O O O O O $string$ O $string$ O O O $string$ O $undefined$ O O O $complex$ O $boolean$ O $string$ O O O O $any$ O $string$ O $string$ $string$ O $any$ $any$ O O O $any$ O $string$ O $undefined$ O O O $complex$ O $any$ O $string$ O O O O O $string$ O O O $complex$ O $any$ O O O $string$ O O $undefined$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O O O $any$ O $string$ O $any$ O O O O
import { Injectable } from 's' ; import { Bluebird } from 's' ; import { ConfigPresets } from "s" ; import { LoggerService } from 's' ; import { BehaviorSubject } from "s" ; import { APP } from 's' ; import { xRequest } from 's' ; import * as json from "s" ; import * as paths from "s" ; import * as schemas from 's' ; import * as _ from "s" ; @ Injectable ( ) export class ConfigurationPresetsService { private static xRequest = new xRequest ( Bluebird ) ; private variableData : BehaviorSubject < ConfigPresets > = new BehaviorSubject ( { } ) ; private downloadStatus : BehaviorSubject < boolean > = new BehaviorSubject ( false ) ; private validator : json . Validator = new json . Validator ( schemas . configPresets ) ; private savingIsDisabled : boolean = false ; constructor ( private loggerService ) { this . load ( ) ; } private get lang ( ) { return APP . lang . configPresets . service ; } get data ( ) { return this . variableData . getValue ( ) ; } get dataObservable ( ) { return this . variableData . asObservable ( ) ; } get isDownloading ( ) { return this . downloadStatus ; } download ( force = false ) { return Promise . resolve ( ) . then ( ( ) => { if ( ! this . downloadStatus . getValue ( ) ) { this . downloadStatus . next ( true ) ; return ConfigurationPresetsService . xRequest . request ( 's' , { responseType : 's' , method : 's' , timeout : 0 } ) . then ( ( data ) => { const error = this . set ( data || { } ) ; if ( error !== null ) { throw new Error ( error ) ; } else { this . loggerService . info ( this . lang . info . downloaded , force ? { invokeAlert : true , alertTimeout : 0 } : undefined ) ; this . save ( force ) ; } } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . failedToDownload__i . interpolate ( { error : _ . get ( error , 's' , error ) } ) ) ; } ) . finally ( ( ) => { this . downloadStatus . next ( false ) ; } ) } } ) ; } load ( ) { json . read < ConfigPresets > ( paths . configPresets ) . then ( ( data ) => { if ( data === null ) { return this . download ( ) ; } else { const error = this . set ( data || { } ) ; if ( error !== null ) { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . loadingError , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( this . lang . error . corruptedVariables__i . interpolate ( { file : paths . configPresets , error } ) ) ; } } } ) . catch ( ( error ) => { this . savingIsDisabled = true ; this . loggerService . error ( this . lang . error . loadingError , { invokeAlert : true , alertTimeout : 0 , doNotAppendToLog : true } ) ; this . loggerService . error ( error ) ; } ) ; } set ( data ) { if ( this . validator . validate ( data ) . isValid ( ) ) { this . variableData . next ( data ) ; return null ; } else return `template` ; } save ( force = false ) { if ( ! this . savingIsDisabled || force ) { json . write ( paths . configPresets , this . variableData . getValue ( ) ) . then ( ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . writingError , { invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O $xRequest$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $Validator<object>$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O $boolean$ O O O O O O O O $LoggerService$ O O O O $void$ O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $Promise<any>$ O $boolean$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $xRequest$ O $any$ O O O O O O O O O O O O $number$ O O O O O $any$ O O $any$ O O O O $string$ O O O $string$ O $any$ O O O O O O O $string$ O O O O O O $ErrorConstructor$ O $string$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $boolean$ O O $true$ O O O $number$ O O O O $undefined$ O O O O $void$ O $boolean$ O O O O O O $any$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O $void$ O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $string$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O O O O O O O $string$ O O O $string$ O $any$ O O O O O O O $string$ O O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $any$ O $string$ O $string$ O O O O O O O O O $Promise<any>$ O O $any$ O O O O O $boolean$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O $true$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O $string$ O $ConfigPresets$ O O O O O O $Validator<object>$ O $Validator<object>$ O $ConfigPresets$ O O $boolean$ O O O O O O $any$ O $any$ O $ConfigPresets$ O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O $boolean$ O $boolean$ O O $any$ O $Promise<any>$ O $any$ O $string$ O O O $any$ O $any$ O O O O O O O O $Promise<any>$ O O $any$ O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VariableParserItem , VariableParserAST , VariableParserBreadthFirstData , VariableParserPostOrderData } from "s" ; export class VariableParser { private static isDelimiter ( input , inputOffset , delimiter ) { for ( let i = 0 ; i < delimiter . length ; i ++ ) { if ( delimiter [ i ] !== input [ i + inputOffset ] ) { return false ; } } return true ; } ; static isValidString ( leftDelimiter , rightDelimiter , input ) { let isEscaped = false ; let valid = true ; let level = 0 ; let i = 0 let leftLengthDiff = input . length - leftDelimiter . length ; let rightLengthDiff = input . length - rightDelimiter . length ; while ( i < input . length ) { if ( input [ i ] === 's' ) { isEscaped = ! isEscaped ; i ++ ; } else { if ( ! isEscaped ) { if ( leftLengthDiff >= i && VariableParser . isDelimiter ( input , i , leftDelimiter ) ) { level ++ ; i += leftDelimiter . length ; } else if ( rightLengthDiff >= i && VariableParser . isDelimiter ( input , i , rightDelimiter ) ) { if ( level > 0 ) level -- ; else { valid = false ; break ; } i += rightDelimiter . length ; } else i ++ ; } else { isEscaped = false ; i ++ ; } } } return valid && level === 0 ; } static buildAST ( leftDelimiter , rightDelimiter , input ) { let isEscaped = false ; let level = 0 ; let lastStringIndex = 0 ; let i = 0 let leftLengthDiff = input . length - leftDelimiter . length ; let rightLengthDiff = input . length - rightDelimiter . length ; let ast = { leftDelimiter , rightDelimiter , input , maxLevel : 0 , parsedTree : [ ] } ; let currentParent = undefined ; let getCurrentTree = ( ) => { return currentParent !== undefined ? currentParent . children : ast . parsedTree ; } ; let pushString = ( parentTree : VariableParserItem [ ] ) => { if ( lastStringIndex < i ) { parentTree . push ( { type : 's' , range : { start : lastStringIndex , end : i } , children : [ ] , parent : currentParent } ) ; } } while ( i < input . length ) { if ( input [ i ] === 's' ) { isEscaped = ! isEscaped ; i ++ ; } else { if ( ! isEscaped ) { if ( leftLengthDiff >= i && VariableParser . isDelimiter ( input , i , leftDelimiter ) ) { let parentTree = getCurrentTree ( ) ; pushString ( parentTree ) ; parentTree . push ( { type : 's' , range : { start : i , end : null } , children : [ ] , parent : currentParent } ) ; currentParent = parentTree [ parentTree . length - 0 ] ; i += leftDelimiter . length ; lastStringIndex = i ; if ( ast . maxLevel < level ) ast . maxLevel ++ ; level ++ ; } else if ( rightLengthDiff >= i && VariableParser . isDelimiter ( input , i , rightDelimiter ) ) { if ( level > 0 ) { pushString ( currentParent . children ) ; level -- ; i += rightDelimiter . length ; lastStringIndex = i ; currentParent . range . end = i ; currentParent = currentParent . parent ; } else break ; } else i ++ ; } else { isEscaped = false ; i ++ ; } } } pushString ( getCurrentTree ( ) ) ; return ast ; } static stringifyAST ( ast , space ? : string | number , includeSegments = false ) { return JSON . stringify ( ast , ( key , value ) => { if ( key === 's' ) { return undefined ; } else if ( value && value [ 's' ] !== undefined && includeSegments ) { return Object . assign ( { segment : ast . input . substring ( value [ 's' ] [ 's' ] , value [ 's' ] [ 's' ] ) } , value ) ; } return value ; } , space ) ; } static traverseAST ( ast , callback : ( ast , item , level , passedData , abort : ( ) => void ) => any | void , fromRoot ) { let abortTraversal = false ; let abortCallback = ( ) => abortTraversal = true ; if ( fromRoot ) { let current = { level : 0 , next : null , children : ast . parsedTree , passedData : undefined } ; let previous = null ; let children : VariableParserItem [ ] = undefined ; let level = undefined ; while ( current && ! abortTraversal ) { level = current . level ; children = current . children ; previous = current ; current = current . next ; for ( let i = 0 ; i < children . length ; i ++ ) { let child = { level : level + 0 , next : current , children : children [ i ] . children , passedData : callback ( ast , children [ i ] , level , previous . passedData , abortCallback ) || null } ; if ( abortTraversal ) break ; current = child ; } } } else { let current = { level : 0 , index : 0 , indexInParent : 0 , previous : null , children : ast . parsedTree , passedData : new Array ( ast . parsedTree . length ) . fill ( undefined ) } ; do { if ( current . index < current . children . length ) { let child = { level : current . level + 0 , index : 0 , indexInParent : current . index , previous : current , children : current . children [ current . index ] . children , passedData : new Array ( current . children [ current . index ] . children . length ) . fill ( undefined ) } ; current . index ++ ; if ( child . index < child . children . length ) current = child ; } else { if ( current . previous !== null ) { if ( current . previous . passedData [ current . indexInParent ] === undefined ) current . previous . passedData [ current . indexInParent ] = [ ] for ( let i = 0 ; i < current . children . length && ! abortTraversal ; i ++ ) { current . previous . passedData [ current . indexInParent ] . push ( callback ( ast , current . children [ i ] , current . level , current . passedData [ i ] , abortCallback ) || null ) ; } } else { for ( let i = 0 ; i < current . children . length && ! abortTraversal ; i ++ ) { callback ( ast , current . children [ i ] , current . level , current . passedData [ i ] , abortCallback ) ; } } current = current . previous ; } } while ( current !== null && ! abortTraversal ) ; } } static unescape ( leftDelimiter , rightDelimiter , input ) { let output = 's' ; let i = 0 let leftLengthDiff = input . length - leftDelimiter . length ; let rightLengthDiff = input . length - rightDelimiter . length ; while ( i < input . length ) { if ( input [ i ] === 's' ) { if ( leftLengthDiff >= i + 0 && VariableParser . isDelimiter ( input , i + 0 , leftDelimiter ) ) { output += leftDelimiter ; i += leftDelimiter . length + 0 ; continue ; } else if ( rightLengthDiff >= i + 0 && VariableParser . isDelimiter ( input , i + 0 , rightDelimiter ) ) { output += rightDelimiter ; i += rightDelimiter . length + 0 ; continue ; } } output += input [ i ++ ] ; } return output ; } static replaceVariables ( ast , replacer : ( variable , level ) => string ) { let output = 's' ; VariableParser . traverseAST ( ast , ( ast , item , level , passedData : string [ ] ) => { if ( level === 0 ) { if ( item . type === 's' ) { let dataString = ast . input . substring ( item . range . start , item . range . end ) ; if ( item . range . end !== ast . input . length && dataString [ dataString . length - 0 ] === 's' ) dataString = dataString . slice ( 0 , - 0 ) ; output += VariableParser . unescape ( ast . leftDelimiter , ast . rightDelimiter , dataString ) ; } else { output += replacer ( passedData ? passedData . join ( 's' ) : 's' , level ) ; } } else { if ( item . type === 's' ) { let dataString = ast . input . substring ( item . range . start , item . range . end ) ; if ( dataString [ dataString . length - 0 ] === 's' ) dataString = dataString . slice ( 0 , - 0 ) ; return VariableParser . unescape ( ast . leftDelimiter , ast . rightDelimiter , dataString ) ; } else { return replacer ( passedData ? passedData . join ( 's' ) : 's' , level ) ; } } } , false ) ; return output ; } static removeVariables ( ast ) { let output = 's' ; VariableParser . traverseAST ( ast , ( ast , item , level , data , abort ) => { if ( level === 0 ) { if ( item . type === 's' ) { let dataString = ast . input . substring ( item . range . start , item . range . end ) ; if ( item . range . end !== ast . input . length && dataString [ dataString . length - 0 ] === 's' ) dataString = dataString . slice ( 0 , - 0 ) ; output += VariableParser . unescape ( ast . leftDelimiter , ast . rightDelimiter , dataString ) ; } } else { abort ( ) ; } } , true ) ; return output ; } static extractVariables ( ast , replacer : ( variable , level ) => string , baseLevel = 0 ) { let variables : string [ ] = [ ] ; VariableParser . traverseAST ( ast , ( ast , item , level , passedData : string [ ] , abort ) => { if ( level === baseLevel ) { if ( item . type === 's' ) { variables . push ( passedData ? passedData . join ( 's' ) : 's' ) ; } } else if ( level > baseLevel ) { if ( item . type === 's' ) { let dataString = ast . input . substring ( item . range . start , item . range . end ) ; if ( dataString [ dataString . length - 0 ] === 's' ) dataString = dataString . slice ( 0 , - 0 ) ; return VariableParser . unescape ( ast . leftDelimiter , ast . rightDelimiter , dataString ) ; } else { return replacer ( passedData ? passedData . join ( 's' ) : 's' , level ) ; } } else abort ( ) ; } , false ) ; return variables ; } private ast : VariableParserAST = undefined ; private valid : boolean = false ; constructor ( private delimiters ? : { left : string , right : string } , private input ? ) { this . setDelimiters ( delimiters ) . setInput ( input ) ; } setDelimiters ( delimiters : { left : string , right : string } ) { this . delimiters = delimiters ; this . ast = undefined ; this . valid = false ; return this ; } setInput ( input ) { this . input = input ; this . ast = undefined ; this . valid = false ; return this ; } isSet ( ) { return this . delimiters != undefined && this . input != undefined ; } isParsed ( ) { return this . ast !== undefined ; } isValid ( ) { if ( ! this . valid && this . isSet ( ) ) this . valid = VariableParser . isValidString ( this . delimiters . left , this . delimiters . right , this . input ) ; return this . valid ; } parse ( ) { if ( this . isValid ( ) ) this . ast = VariableParser . buildAST ( this . delimiters . left , this . delimiters . right , this . input ) ; return this . isParsed ( ) ; } stringifyAST ( space ? : string | number , includeSegments = false ) { return this . isParsed ( ) ? VariableParser . stringifyAST ( this . ast , space , includeSegments ) : 's' ; } traverseAST ( callback : ( ast , item , level , passedData , abort : ( ) => void ) => any | void , fromRoot ) { if ( this . isParsed ( ) ) VariableParser . traverseAST ( this . ast , callback , fromRoot ) ; } unescape ( ) { return this . isSet ( ) ? VariableParser . unescape ( this . delimiters . left , this . delimiters . right , this . input ) : 's' ; } replaceVariables ( replacer : ( variable , level ) => string ) { return this . isParsed ( ) ? VariableParser . replaceVariables ( this . ast , replacer ) : 's' ; } removeVariables ( ) { return this . isParsed ( ) ? VariableParser . removeVariables ( this . ast ) : 's' ; } extractVariables ( replacer : ( variable , level ) => string , baseLevel = 0 ) { return this . isParsed ( ) ? VariableParser . extractVariables ( this . ast , replacer , baseLevel ) : [ ] ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $boolean$ O $string$ O $number$ O $string$ O O O O O $number$ O O O $number$ O $string$ O $number$ O $number$ O O O O O $string$ O $number$ O O $string$ O $number$ O $number$ O O O O O O O O O O O O O O $boolean$ O $string$ O $string$ O $string$ O O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O $number$ O O O $number$ O $string$ O $number$ O $string$ O $number$ O O $number$ O $string$ O $number$ O $string$ O $number$ O O O $number$ O $string$ O $number$ O O O O $string$ O $number$ O O O O O $boolean$ O O $boolean$ O $number$ O O O O O O O O $boolean$ O O O O $number$ O $number$ O $any$ O $boolean$ O $string$ O $number$ O $string$ O O O $number$ O O $number$ O $string$ O $number$ O O O O O $number$ O $number$ O $any$ O $boolean$ O $string$ O $number$ O $string$ O O O O O $number$ O O O $number$ O O O O $boolean$ O O O O O O $number$ O $string$ O $number$ O O O $number$ O O O O O $boolean$ O O O $number$ O O O O O O $boolean$ O $number$ O O O O O $VariableParserAST$ O $string$ O $string$ O $string$ O O O $boolean$ O O O O $number$ O O O O $number$ O O O O $number$ O O O $number$ O $string$ O $number$ O $string$ O $number$ O O $number$ O $string$ O $number$ O $string$ O $number$ O O $VariableParserAST$ O O $string$ O $string$ O $string$ O $number$ O O O $undefined[]$ O O O O O O $VariableParserItem$ O $undefined$ O O $VariableParserItem[]$ O O O O O O $VariableParserItem$ O $undefined$ O $VariableParserItem$ O $VariableParserItem[]$ O $VariableParserAST$ O $VariableParserItem[]$ O O O O $void$ O O $VariableParserItem[]$ O $any$ O O O O O O O $number$ O $number$ O O $VariableParserItem[]$ O $number$ O O O O O O $complex$ O O $number$ O $number$ O $number$ O $number$ O O $undefined[]$ O O O O $VariableParserItem$ O $VariableParserItem$ O O O O O O O $number$ O $string$ O $number$ O O O O $string$ O $number$ O O O O O $boolean$ O O $boolean$ O $number$ O O O O O O O O $boolean$ O O O O $number$ O $number$ O $any$ O $boolean$ O $string$ O $number$ O $string$ O O O O $VariableParserItem[]$ O $VariableParserItem[]$ O O O $void$ O $VariableParserItem[]$ O O $VariableParserItem[]$ O $number$ O O O O O O $complex$ O O $number$ O $number$ O $null$ O O O O $undefined[]$ O O O O $VariableParserItem$ O $VariableParserItem$ O O O $VariableParserItem$ O $VariableParserItem[]$ O $VariableParserItem[]$ O $number$ O O O O $number$ O $string$ O $number$ O $number$ O $number$ O O O $VariableParserAST$ O $number$ O $number$ O $VariableParserAST$ O $number$ O O $number$ O O O O O O $number$ O $number$ O $any$ O $boolean$ O $string$ O $number$ O $string$ O O O O O $number$ O O O O $void$ O $VariableParserItem$ O $VariableParserItem[]$ O O $number$ O O $number$ O $string$ O $number$ O $number$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O $number$ O $VariableParserItem$ O $VariableParserItem$ O $VariableParserItem$ O O O O O O O $number$ O O O O O $boolean$ O O O $number$ O O O O O $void$ O $VariableParserItem[]$ O O O O O $VariableParserAST$ O O O $string$ O $VariableParserAST$ O $complex$ O O O O O O $boolean$ O O O O O $JSON$ O $complex$ O $VariableParserAST$ O O $string$ O $any$ O O O O O $string$ O O O O O $undefined$ O O O O O $any$ O $any$ O O O O $undefined$ O $boolean$ O O O $ObjectConstructor$ O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $complex$ O O O O $void$ O $VariableParserAST$ O $any$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $any$ O $void$ O O O O O O O O O O O $boolean$ O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O $boolean$ O O O $VariableParserBreadthFirstData$ O O $number$ O O O $null$ O O O $VariableParserItem[]$ O $VariableParserAST$ O $VariableParserItem[]$ O $undefined$ O $undefined$ O O O $VariableParserBreadthFirstData$ O O O O $VariableParserItem[]$ O $any$ O O O $undefined$ O O $number$ O $undefined$ O O O $VariableParserBreadthFirstData$ O O $false$ O O $number$ O $VariableParserBreadthFirstData$ O $number$ O $VariableParserItem[]$ O $VariableParserBreadthFirstData$ O $VariableParserItem[]$ O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O O O O $number$ O O O $number$ O $VariableParserItem[]$ O $number$ O $number$ O O O O $VariableParserBreadthFirstData$ O O $number$ O $number$ O O O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O $VariableParserItem[]$ O $VariableParserItem[]$ O $number$ O O $VariableParserItem[]$ O $any$ O $any$ O $VariableParserAST$ O $VariableParserItem[]$ O $number$ O O $number$ O $VariableParserBreadthFirstData$ O $any$ O $boolean$ O O O O O O O $false$ O O O $VariableParserBreadthFirstData$ O $VariableParserBreadthFirstData$ O O O O O O O $VariableParserPostOrderData$ O O $number$ O O O $number$ O O O $number$ O O O $null$ O O O $VariableParserItem[]$ O $VariableParserAST$ O $VariableParserItem[]$ O $any[]$ O O $ArrayConstructor$ O $VariableParserAST$ O $VariableParserItem[]$ O $number$ O O $any[]$ O $undefined$ O O O O O O O $VariableParserPostOrderData$ O $number$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O O O $VariableParserPostOrderData$ O O $number$ O $VariableParserPostOrderData$ O $number$ O O O $number$ O O O $number$ O $VariableParserPostOrderData$ O $number$ O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $VariableParserPostOrderData$ O $number$ O O $VariableParserItem[]$ O $any[]$ O O $ArrayConstructor$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $VariableParserPostOrderData$ O $number$ O O $VariableParserItem[]$ O $number$ O O $any[]$ O $undefined$ O O O $VariableParserPostOrderData$ O $number$ O O O O $VariableParserPostOrderData$ O $number$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O O O O O O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O O O O O O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O $any[]$ O $VariableParserPostOrderData$ O $number$ O O $undefined$ O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O $any[]$ O $VariableParserPostOrderData$ O $number$ O O O O O O O $number$ O O O $number$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O O $false$ O $number$ O O O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O $any[]$ O $VariableParserPostOrderData$ O $number$ O O $any$ O $any$ O $VariableParserAST$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O O $VariableParserPostOrderData$ O $number$ O $VariableParserPostOrderData$ O $any[]$ O $number$ O O $boolean$ O O O O O O O O O O O O $number$ O O O $number$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O O $false$ O $number$ O O O $any$ O $VariableParserAST$ O $VariableParserPostOrderData$ O $VariableParserItem[]$ O $number$ O O $VariableParserPostOrderData$ O $number$ O $VariableParserPostOrderData$ O $any[]$ O $number$ O O $boolean$ O O O O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O $VariableParserPostOrderData$ O O O O O $VariableParserPostOrderData$ O O O O $false$ O O O O O $string$ O $string$ O $string$ O $string$ O O O $string$ O O O O $number$ O O O $number$ O $string$ O $number$ O $string$ O $number$ O O $number$ O $string$ O $number$ O $string$ O $number$ O O O $number$ O $string$ O $number$ O O O O $string$ O $number$ O O O O O O O $number$ O $number$ O O O $any$ O $boolean$ O $string$ O $number$ O O O $string$ O O O $string$ O $string$ O $number$ O $string$ O $number$ O O O O O O O O O $number$ O $number$ O O O $any$ O $boolean$ O $string$ O $number$ O O O $string$ O O O $string$ O $string$ O $number$ O $string$ O $number$ O O O O O O O $string$ O $string$ O $number$ O O O O O $string$ O O O $string$ O $VariableParserAST$ O $string$ O O $string$ O $number$ O O O O O O $string$ O O O $any$ O $void$ O $VariableParserAST$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $string[]$ O O O O O O O O O $number$ O O O O O O $VariableParserItem$ O O O O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O $VariableParserItem$ O $complex$ O $number$ O $VariableParserAST$ O $string$ O $number$ O $string$ O $string$ O $number$ O O O O O O $string$ O $string$ O $string$ O O O O O O O $string$ O $any$ O $string$ O $VariableParserAST$ O $string$ O $VariableParserAST$ O $string$ O $string$ O O O O O $string$ O $string$ O $string[]$ O $string[]$ O $string$ O O O O O O O O O O O O O O O $VariableParserItem$ O O O O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O $string$ O $string$ O $number$ O O O O O O $string$ O $string$ O $string$ O O O O O O O O $any$ O $string$ O $VariableParserAST$ O $string$ O $VariableParserAST$ O $string$ O $string$ O O O O O O $string$ O $string[]$ O $string[]$ O $string$ O O O O O O $number$ O O O O O O O O O O $string$ O O O $string$ O $VariableParserAST$ O O O $string$ O O O $any$ O $void$ O $VariableParserAST$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $any$ O $void$ O O O O O $number$ O O O O O O $VariableParserItem$ O O O O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O $VariableParserItem$ O $complex$ O $number$ O $VariableParserAST$ O $string$ O $number$ O $string$ O $string$ O $number$ O O O O O O $string$ O $string$ O $string$ O O O O O O O $string$ O $any$ O $string$ O $VariableParserAST$ O $string$ O $VariableParserAST$ O $string$ O $string$ O O O O O O $void$ O O O O O O O O O O $string$ O O O $string[]$ O $VariableParserAST$ O $string$ O O $string$ O $number$ O O O O $number$ O O O O O $string[]$ O O O O O O O O $any$ O $void$ O $VariableParserAST$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $string[]$ O O O O O $void$ O O O O O $number$ O $number$ O O O O $VariableParserItem$ O O O O O O $string[]$ O $number$ O $string[]$ O $string[]$ O $string$ O O O O O O O O O O O O $number$ O $number$ O O O O $VariableParserItem$ O O O O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O $string$ O $string$ O $number$ O O O O O O $string$ O $string$ O $string$ O O O O O O O O $any$ O $string$ O $VariableParserAST$ O $string$ O $VariableParserAST$ O $string$ O $string$ O O O O O O $string$ O $string[]$ O $string[]$ O $string$ O O O O O O $number$ O O O O O $void$ O O O O O O O O O $string[]$ O O O $VariableParserAST$ O $any$ O $undefined$ O O $boolean$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ $string$ O O O O $this$ O $complex$ O O $this$ O $string$ O O O $this$ O $complex$ O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $VariableParserAST$ O $undefined$ O O O $boolean$ O O O O O O O $this$ O $string$ O O O O $string$ O $string$ O O O $VariableParserAST$ O $undefined$ O O O $boolean$ O O O O O O O $boolean$ O O O O O O $complex$ O $undefined$ O O O $string$ O $undefined$ O O $boolean$ O O O O O O $VariableParserAST$ O $undefined$ O O $boolean$ O O O O O O O O $boolean$ O O O $boolean$ O O O O O $boolean$ O $any$ O $boolean$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $string$ O O O O O $boolean$ O O $boolean$ O O O O O O O $boolean$ O O O O O $VariableParserAST$ O $any$ O $VariableParserAST$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $string$ O O O O O $boolean$ O O O O $string$ O $complex$ O O O O O O $boolean$ O O O O O O O $boolean$ O O O $any$ O $string$ O O O $VariableParserAST$ O $complex$ O $boolean$ O O O O O $void$ O $any$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $any$ O $void$ O O O O O O O O O O O $boolean$ O O O O O O $boolean$ O O O $any$ O $void$ O O O $VariableParserAST$ O $any$ O $boolean$ O O O $string$ O O O O O O $boolean$ O O O $any$ O $string$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $string$ O O O O O $string$ O $string$ O O $string$ O $number$ O O O O O O O O $boolean$ O O O $any$ O $string$ O O O $VariableParserAST$ O $string$ O O O O O $string$ O O O O O O $boolean$ O O O $any$ O $string$ O O O $VariableParserAST$ O O O O O $string[]$ O $string$ O O $string$ O $number$ O O O O $number$ O O O O O O O $boolean$ O O O $any$ O $string[]$ O O O $VariableParserAST$ O $string$ O $number$ O O O O O O O
import { ParserInfo , GenericParser , UserConfiguration , ParsedData } from 's' ; import { APP } from 's' ; import * as glob from 's' ; import * as path from 's' ; import * as _ from "s" ; import * as minimatch from 's' ; interface TitleTagData { depth : { direction : 's' | 's' , level : number } , finalGlob : string , titleRegex : { regex : RegExp , pos : number } } export class GlobParser implements GenericParser { getParserInfo ( ) { return { title : 's' , info : this . lang . docs__md . self . join ( 's' ) , inputs : { 's' : { label : this . lang . inputTitle , validationFn : this . validate . bind ( this ) , info : this . lang . docs__md . input . join ( 's' ) } } } ; } private get lang ( ) { return APP . lang . globParser ; } private validate ( fileGlob , suppressSlashError = false ) { let testRegExpr = "s" ; let match = testRegExpr . exec ( fileGlob ) ; if ( match === null ) return this . lang . errors . noTitle__md ; else if ( match . length > 0 ) return this . lang . errors . moreThanOneTitle__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noStarNextToTitle__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noAnyCharNextToTitle__md ; if ( ! suppressSlashError ) { testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noWindowsSlash__md ; } testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noGlobstarOnBothSides__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noBracedDirSetOnBothSides__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noBracedDirSetOrGlobstarOnBothSides__md ; testRegExpr = "s" ; while ( ( match = testRegExpr . exec ( fileGlob ) ) !== null ) { if ( match [ 0 ] . length === 0 ) return this . lang . errors . noEmptyPattern__md ; } testRegExpr = "s" ; while ( ( match = testRegExpr . exec ( fileGlob ) ) !== null ) { if ( match [ 0 ] . length === 0 ) return this . lang . errors . noEmptyCharRange__md ; } testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) { let patterns : string [ ] ; if ( match [ 0 ] || match [ 0 ] ) { patterns = ( match [ 0 ] || match [ 0 ] ) . split ( 's' ) ; for ( let i = 0 ; i < patterns . length ; i ++ ) { if ( patterns [ i ] [ patterns [ i ] . length - 0 ] === 's' ) return this . lang . errors . noStarInPatternNextToTitle__md ; else if ( patterns [ i ] [ patterns [ i ] . length - 0 ] === 's' ) return this . lang . errors . noAnyCharInPatternNextToTitle__md ; } } else if ( match [ 0 ] || match [ 0 ] ) { patterns = ( match [ 0 ] || match [ 0 ] ) . split ( 's' ) ; for ( let i = 0 ; i < patterns . length ; i ++ ) { if ( patterns [ i ] [ 0 ] === 's' ) return this . lang . errors . noStarInPatternNextToTitle__md ; else if ( patterns [ i ] [ 0 ] === 's' ) return this . lang . errors . noAnyCharInPatternNextToTitle__md ; } } } return null ; } private getTitleDepth ( fileGlob ) { let depth : { direction : 's' | 's' , level : number } = { direction : undefined , level : undefined } ; let tempGlob = undefined ; if ( fileGlob . replace ( "s" , 's' ) . length === 0 ) { depth . level = null ; } else if ( "s" . test ( fileGlob ) ) { depth . direction = 's' ; tempGlob = fileGlob . replace ( "s" , 's' ) ; } else { depth . direction = 's' ; tempGlob = fileGlob . replace ( "s" , 's' ) ; } if ( depth . level === undefined ) { let dirMatch = tempGlob . match ( "s" ) ; depth . level = dirMatch === null ? 0 : dirMatch . length ; } return depth ; } private getTitleRegex ( fileGlob ) { let titleRegex = 's' ; let pos = 0 ; let getRegexString = ( segment ) => { let mm = new minimatch . Minimatch ( segment , { dot : true } ) ; if ( mm . empty ) return 's' ; else { return mm . makeRe ( ) . source ; } } let titleSegmentMatch = fileGlob . match ( "s" ) ; if ( titleSegmentMatch !== null ) { let titleSegments = ( titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] ) . split ( "s" ) ; if ( titleSegments [ 0 ] . length > 0 ) { let regexString = getRegexString ( titleSegments [ 0 ] ) ; titleRegex += regexString . substr ( 0 , regexString . length - 0 ) ; pos ++ ; } else titleRegex += 's' ; titleRegex += 's' ; if ( titleSegments [ 0 ] . length > 0 ) { let regexString = getRegexString ( titleSegments [ 0 ] ) ; titleRegex += regexString . substr ( 0 , regexString . length - 0 ) ; } else titleRegex += 's' ; } return { regex : new RegExp ( titleRegex ) , pos : pos } ; } private getFinalGlob ( fileGlob , depthLevel ) { if ( depthLevel !== null ) { return fileGlob . replace ( "s" , 's' ) } else return 's' ; } private extractTitleTag ( fileGlob ) { let extractedData = { finalGlob : undefined , titleRegex : undefined , depth : undefined } ; extractedData . depth = this . getTitleDepth ( fileGlob ) ; extractedData . titleRegex = this . getTitleRegex ( fileGlob ) ; extractedData . finalGlob = this . getFinalGlob ( fileGlob , extractedData . depth . level ) ; return extractedData ; } private extractTitle ( titleData , file ) { if ( titleData . depth . level !== null ) { let fileSections = file . split ( 's' ) ; file = fileSections [ titleData . depth . direction === 's' ? fileSections . length - ( titleData . depth . level + 0 ) : titleData . depth . level ] ; } if ( file !== undefined ) { let titleMatch = file . match ( titleData . titleRegex . regex ) ; if ( titleMatch !== null && titleMatch [ titleData . titleRegex . pos ] ) return titleMatch [ titleData . titleRegex . pos ] . replace ( "s" , path . sep ) . trim ( ) ; } return undefined ; } private extractTitles ( titleData , directory , files : string [ ] ) { let parsedData = { success : [ ] , failed : [ ] } ; for ( let i = 0 ; i < files . length ; i ++ ) { let title = this . extractTitle ( titleData , files [ i ] ) ; let filePath = files [ i ] . replace ( "s" , path . sep ) ; filePath = path . isAbsolute ( filePath ) ? filePath : path . join ( directory , filePath ) ; if ( title !== undefined ) parsedData . success . push ( { filePath , extractedTitle : title } ) ; else parsedData . failed . push ( filePath ) ; } return parsedData ; } execute ( directory , inputs : { [ key ] : any } , cache ? : { [ key ] : any } ) { return Promise . resolve ( ) . then ( ( ) => { let validationText = this . validate ( inputs [ 's' ] ) ; if ( validationText === null ) { let titleData = this . extractTitleTag ( inputs [ 's' ] ) ; return new Promise ( ( resolve , reject ) => { glob ( titleData . finalGlob , { silent : true , dot : true , cwd : directory , cache : cache || { } } , ( err , files ) => { if ( err ) reject ( err ) ; else resolve ( files ) ; } ) ; } ) . then ( ( files : string [ ] ) => { return this . extractTitles ( titleData , directory , files ) ; } ) } else throw new Error ( validationText ) ; } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $complex$ O O O O O O O O $number$ O O O O $string$ O O O $complex$ O O $RegExp$ O $RegExpConstructor$ O $number$ O O O O O O $any$ O $any$ O $ParserInfo$ O O O O O $string$ O O O $string$ O O O O O $complex$ O $string[]$ O $string$ O O O O $complex$ O O O O O $string$ O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O $complex$ O $string[]$ O $string$ O O O O O O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O O O O O $string$ O $string$ O $boolean$ O O O O O $RegExp$ O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O O O O $RegExpExecArray$ O $number$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O O O O $boolean$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O O O $RegExpExecArray$ O O O O $number$ O O O O O O O O O O $string$ O O $RegExp$ O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O O O $RegExpExecArray$ O O O O $number$ O O O O O O O O O O $string$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O O O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O $string[]$ O $number$ O O $number$ O O O O O O O O O O O O O $string$ O O O O $string[]$ O $number$ O O $string[]$ O $number$ O O $number$ O O O O O O O O O O O O O $string$ O O O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O O O O O O O O O O O O O $string$ O O O O $string[]$ O $number$ O O O O O O O O O O O O O O $string$ O O O O O O O O O $complex$ O $string$ O O O $complex$ O O O O O O O O $number$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O $any$ O $undefined$ O O O $string$ O $complex$ O O O O O O $number$ O O O O $complex$ O $number$ O O O O O O O O O $boolean$ O $string$ O O O $complex$ O O O O O $any$ O $string$ O $complex$ O O O O O O O O O $complex$ O O O O O $any$ O $string$ O $complex$ O O O O O O O O O $complex$ O $number$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $number$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O O O $complex$ O $string$ O O O $string$ O O O O $number$ O O O O $any$ O O $string$ O O O O $any$ O O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O $RegExpMatchArray$ O $string$ O $complex$ O O O O O O $RegExpMatchArray$ O O O O O $string[]$ O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O O $complex$ O O O O O O $string[]$ O O O O $number$ O O O O O $any$ O $any$ O $string[]$ O O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O O $number$ O O O O $string$ O O O $string$ O O O O O $string[]$ O O O O $number$ O O O O O $any$ O $any$ O $string[]$ O O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $string$ O O O O O O $RegExp$ O O $RegExpConstructor$ O $string$ O O $number$ O $number$ O O O O $string$ O $string$ O $number$ O O O O $number$ O O O O O $string$ O $complex$ O O O O O O O O O O O O $TitleTagData$ O $string$ O O O $TitleTagData$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $TitleTagData$ O $complex$ O O O $complex$ O $string$ O O $TitleTagData$ O $complex$ O O O $complex$ O $string$ O O $TitleTagData$ O $string$ O O O $string$ O $string$ O $TitleTagData$ O $complex$ O $number$ O O O $TitleTagData$ O O O $string$ O $TitleTagData$ O $string$ O O O O $TitleTagData$ O $complex$ O $number$ O O O O O $string[]$ O $string$ O $complex$ O O O O $string$ O $string[]$ O $TitleTagData$ O $complex$ O O O O O $string[]$ O $number$ O O $TitleTagData$ O $complex$ O $number$ O O O O $TitleTagData$ O $complex$ O $number$ O O O O O $string$ O $undefined$ O O O $RegExpMatchArray$ O $string$ O $complex$ O $TitleTagData$ O $complex$ O $RegExp$ O O O O $RegExpMatchArray$ O O O $RegExpMatchArray$ O $TitleTagData$ O $complex$ O $number$ O O O $RegExpMatchArray$ O $TitleTagData$ O $complex$ O $number$ O O $complex$ O O O $any$ O $any$ O O $string$ O O O O O $undefined$ O O O $ParsedData$ O $TitleTagData$ O $string$ O $string[]$ O O O O O O O $ParsedData$ O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O O O $string$ O $TitleTagData$ O $string[]$ O $number$ O O O O $string$ O $string[]$ O $number$ O O $complex$ O O O $any$ O $any$ O O $string$ O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $string$ O $string$ O O O O $string$ O $undefined$ O $ParsedData$ O $complex$ O $number$ O O $string$ O $string$ O $string$ O O O O $ParsedData$ O $string[]$ O $number$ O $string$ O O O O $ParsedData$ O O $Promise<ParsedData>$ O $string$ O $complex$ O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $string$ O O O $string$ O $complex$ O O O O O O O $string$ O O O O O $TitleTagData$ O O O $TitleTagData$ O $complex$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $TitleTagData$ O $string$ O O $boolean$ O O O $boolean$ O O O $string$ O $string$ O $complex$ O $complex$ O O O O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O $any$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $ParsedData$ O $TitleTagData$ O $string$ O $string[]$ O O O O O O O O $ErrorConstructor$ O $string$ O O O O O O O
import { ParserInfo , GenericParser , UserConfiguration , ParsedData } from 's' ; import { APP } from 's' ; import * as _ from "s" ; import * as minimatch from 's' ; import * as glob from 's' ; import * as path from 's' ; interface TitleTagData { depth : { direction : 's' | 's' , level : number } , finalGlob : string , globRegex : { regex : RegExp , replaceText : string } titleRegex : { regex : RegExp , pos : number } } export class GlobRegexParser implements GenericParser { getParserInfo ( ) { return { title : 's' , info : this . lang . docs__md . self . join ( 's' ) , inputs : { 's' : { label : this . lang . inputTitle , validationFn : this . validate . bind ( this ) , info : this . lang . docs__md . input . join ( 's' ) } } } ; } private get lang ( ) { return APP . lang . globRegexParser ; } private validate ( fileGlob , suppressSlashError = false ) { let testRegExpr = "s" ; let match = testRegExpr . exec ( fileGlob ) ; if ( match === null ) return this . lang . errors . noRegex__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match . length > 0 ) return this . lang . errors . moreThanOneRegex__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noStarNextToRegex__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noAnyCharNextToRegex__md ; let fileGlobWithoutRegex = fileGlob . replace ( "s" , 's' ) ; if ( ! suppressSlashError ) { testRegExpr = "s" ; match = testRegExpr . exec ( fileGlobWithoutRegex ) ; if ( match !== null ) return this . lang . errors . noWindowsSlash__md ; } testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noGlobstarOnBothSides__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noBracedDirSetOnBothSides__md ; testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) return this . lang . errors . noBracedDirSetOrGlobstarOnBothSides__md ; testRegExpr = "s" ; while ( ( match = testRegExpr . exec ( fileGlobWithoutRegex ) ) !== null ) { if ( match [ 0 ] . length === 0 ) return this . lang . errors . noEmptyPattern__md ; } testRegExpr = "s" ; while ( ( match = testRegExpr . exec ( fileGlobWithoutRegex ) ) !== null ) { if ( match [ 0 ] . length === 0 ) return this . lang . errors . noEmptyCharRange__md ; } testRegExpr = "s" ; match = testRegExpr . exec ( fileGlob ) ; if ( match !== null ) { let patterns : string [ ] ; if ( match [ 0 ] || match [ 0 ] ) { patterns = ( match [ 0 ] || match [ 0 ] ) . split ( 's' ) ; for ( let i = 0 ; i < patterns . length ; i ++ ) { if ( patterns [ i ] [ patterns [ i ] . length - 0 ] === 's' ) return this . lang . errors . noStarInPatternNextToRegex__md ; else if ( patterns [ i ] [ patterns [ i ] . length - 0 ] === 's' ) return this . lang . errors . noAnyCharInPatternNextToRegex__md ; } } else if ( match [ 0 ] || match [ 0 ] ) { patterns = ( match [ 0 ] || match [ 0 ] ) . split ( 's' ) ; for ( let i = 0 ; i < patterns . length ; i ++ ) { if ( patterns [ i ] [ 0 ] === 's' ) return this . lang . errors . noStarInPatternNextToRegex__md ; else if ( patterns [ i ] [ 0 ] === 's' ) return this . lang . errors . noAnyCharInPatternNextToRegex__md ; } } } return null ; } private getTitleDepth ( fileGlob ) { let depth : { direction : 's' | 's' , level : number } = { direction : undefined , level : undefined } ; let tempGlob = undefined ; if ( fileGlob . replace ( "s" , 's' ) . length === 0 ) { depth . level = null ; } else if ( "s" . test ( fileGlob ) ) { depth . direction = 's' ; tempGlob = fileGlob . replace ( "s" , 's' ) ; } else { depth . direction = 's' ; tempGlob = fileGlob . replace ( "s" , 's' ) ; } if ( depth . level === undefined ) { let dirMatch = tempGlob . match ( "s" ) ; depth . level = dirMatch === null ? 0 : dirMatch . length ; } return depth ; } private getTitleRegex ( fileGlob ) { let titleRegex = 's' ; let pos = 0 ; let getRegexString = ( segment ) => { let mm = new minimatch . Minimatch ( segment , { dot : true } ) ; if ( mm . empty ) return 's' ; else { return mm . makeRe ( ) . source ; } } let titleSegmentMatch = fileGlob . match ( "s" ) ; if ( titleSegmentMatch !== null ) { let titleSegments = ( titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] || titleSegmentMatch [ 0 ] ) . split ( "s" ) ; if ( titleSegments [ 0 ] . length > 0 ) { let regexString = getRegexString ( titleSegments [ 0 ] ) ; titleRegex += regexString . substr ( 0 , regexString . length - 0 ) ; pos ++ ; } else titleRegex += 's' ; titleRegex += 's' ; if ( titleSegments [ 0 ] . length > 0 ) { let regexString = getRegexString ( titleSegments [ 0 ] ) ; titleRegex += regexString . substr ( 0 , regexString . length - 0 ) ; } else titleRegex += 's' ; } return { regex : new RegExp ( titleRegex ) , pos : pos } ; } private getFinalGlob ( fileGlob , depthLevel ) { if ( depthLevel !== null ) { return fileGlob . replace ( "s" , 's' ) } else return 's' ; } private makeRegexRegex ( fileGlob ) { let match = "s" . exec ( fileGlob ) ; if ( match ) { return { regex : new RegExp ( match [ 0 ] , match [ 0 ] || 's' ) , replaceText : match [ 0 ] } ; } else return { regex : new RegExp ( 's' ) , replaceText : 's' } ; } private extractTitleTag ( fileGlob ) { let extractedData = { finalGlob : undefined , globRegex : undefined , titleRegex : undefined , depth : undefined } ; extractedData . depth = this . getTitleDepth ( fileGlob ) ; extractedData . titleRegex = this . getTitleRegex ( fileGlob ) ; extractedData . finalGlob = this . getFinalGlob ( fileGlob , extractedData . depth . level ) ; extractedData . globRegex = this . makeRegexRegex ( fileGlob ) ; return extractedData ; } private extractTitle ( titleData , file ) { if ( titleData . depth . level !== null ) { let fileSections = file . split ( 's' ) ; file = fileSections [ titleData . depth . direction === 's' ? fileSections . length - ( titleData . depth . level + 0 ) : titleData . depth . level ] ; } if ( file !== undefined ) { let titleMatch = file . match ( titleData . titleRegex . regex ) ; if ( titleMatch !== null && titleMatch [ titleData . titleRegex . pos ] ) { if ( typeof titleData . globRegex . replaceText === 's' ) { let title = titleMatch [ titleData . titleRegex . pos ] . replace ( titleData . globRegex . regex , titleData . globRegex . replaceText ) . replace ( "s" , path . sep ) . trim ( ) ; return title . length > 0 ? title : undefined ; } else { titleMatch = titleMatch [ titleData . titleRegex . pos ] . match ( titleData . globRegex . regex ) ; if ( titleMatch !== null ) { let title = 's' ; for ( let i = 0 ; i < titleMatch . length ; i ++ ) { if ( titleMatch [ i ] ) title += titleMatch [ i ] ; } if ( title . length === 0 ) return titleMatch [ 0 ] . replace ( "s" , path . sep ) . trim ( ) ; else return title . replace ( "s" , path . sep ) . trim ( ) ; } } } } return undefined ; } private extractTitles ( titleData , directory , files : string [ ] ) { let parsedData = { success : [ ] , failed : [ ] } ; for ( let i = 0 ; i < files . length ; i ++ ) { let title = this . extractTitle ( titleData , files [ i ] ) ; let filePath = files [ i ] . replace ( "s" , path . sep ) ; filePath = path . isAbsolute ( filePath ) ? filePath : path . join ( directory , filePath ) ; if ( title !== undefined ) parsedData . success . push ( { filePath , extractedTitle : title } ) ; else parsedData . failed . push ( filePath ) ; } return parsedData ; } execute ( directory , inputs : { [ key ] : any } , cache ? : { [ key ] : any } ) { return new Promise < ParsedData > ( ( resolve , reject ) => { let validationText = this . validate ( inputs [ 's' ] ) ; if ( validationText === null ) { let titleData = this . extractTitleTag ( inputs [ 's' ] ) ; glob ( titleData . finalGlob , { silent : true , dot : true , cwd : directory , cache : cache || { } } , ( err , files ) => { if ( err ) reject ( err ) ; else resolve ( this . extractTitles ( titleData , directory , files ) ) ; } ) ; } else throw new Error ( validationText ) ; } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $complex$ O O O O O O O O $number$ O O O O $string$ O O O $complex$ O O $RegExp$ O $RegExpConstructor$ O $string$ O O O $complex$ O O $RegExp$ O $RegExpConstructor$ O $number$ O O O O O O $any$ O $any$ O $ParserInfo$ O O O O O $string$ O O O $string$ O O O O O $complex$ O $string[]$ O $string$ O O O O $complex$ O O O O O $string$ O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O $complex$ O $string[]$ O $string$ O O O O O O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O O O O O $string$ O $string$ O $boolean$ O O O O O $RegExp$ O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O $number$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O O $string$ O $string$ O $complex$ O O O O O O O O O $boolean$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O O O O O $string$ O $RegExp$ O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O O O $RegExpExecArray$ O O O O $number$ O O O O O O O O O O $string$ O O $RegExp$ O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O O O $RegExpExecArray$ O O O O $number$ O O O O O O O O O O $string$ O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O O O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O $string[]$ O $number$ O O $number$ O O O O O O O O O O O O O $string$ O O O O $string[]$ O $number$ O O $string[]$ O $number$ O O $number$ O O O O O O O O O O O O O $string$ O O O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $string[]$ O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O O O O O O O O O O O O O $string$ O O O O $string[]$ O $number$ O O O O O O O O O O O O O O $string$ O O O O O O O O O $complex$ O $string$ O O O $complex$ O O O O O O O O $number$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O $any$ O $undefined$ O O O $string$ O $complex$ O O O O O O $number$ O O O O $complex$ O $number$ O O O O O O O O O $boolean$ O $string$ O O O $complex$ O O O O O $any$ O $string$ O $complex$ O O O O O O O O O $complex$ O O O O O $any$ O $string$ O $complex$ O O O O O O O O O $complex$ O $number$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $number$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O O O $complex$ O $string$ O O O $string$ O O O O $number$ O O O O $any$ O O $string$ O O O O $any$ O O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O $RegExpMatchArray$ O $string$ O $complex$ O O O O O O $RegExpMatchArray$ O O O O O $string[]$ O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O $RegExpMatchArray$ O O O O O $complex$ O O O O O O $string[]$ O O O O $number$ O O O O O $any$ O $any$ O $string[]$ O O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O O $number$ O O O O $string$ O O O $string$ O O O O O $string[]$ O O O O $number$ O O O O O $any$ O $any$ O $string[]$ O O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $string$ O O O O O O $RegExp$ O O $RegExpConstructor$ O $string$ O O $number$ O $number$ O O O O $string$ O $string$ O $number$ O O O O $number$ O O O O O $string$ O $complex$ O O O O O O O O O O O O $complex$ O $string$ O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O $RegExp$ O O $RegExpConstructor$ O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O O O $string$ O $RegExpExecArray$ O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O $string$ O O O O O O $TitleTagData$ O $string$ O O O $TitleTagData$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $TitleTagData$ O $complex$ O O O $complex$ O $string$ O O $TitleTagData$ O $complex$ O O O $complex$ O $string$ O O $TitleTagData$ O $string$ O O O $string$ O $string$ O $TitleTagData$ O $complex$ O $number$ O O $TitleTagData$ O $complex$ O O O $complex$ O $string$ O O O $TitleTagData$ O O O $string$ O $TitleTagData$ O $string$ O O O O $TitleTagData$ O $complex$ O $number$ O O O O O $string[]$ O $string$ O $complex$ O O O O $string$ O $string[]$ O $TitleTagData$ O $complex$ O O O O O $string[]$ O $number$ O O $TitleTagData$ O $complex$ O $number$ O O O O $TitleTagData$ O $complex$ O $number$ O O O O O $string$ O $undefined$ O O O $RegExpMatchArray$ O $string$ O $complex$ O $TitleTagData$ O $complex$ O $RegExp$ O O O O $RegExpMatchArray$ O O O $RegExpMatchArray$ O $TitleTagData$ O $complex$ O $number$ O O O O O O $TitleTagData$ O $complex$ O $string$ O O O O O $string$ O $RegExpMatchArray$ O $TitleTagData$ O $complex$ O $number$ O O $complex$ O $TitleTagData$ O $complex$ O $RegExp$ O $TitleTagData$ O $complex$ O $string$ O O $complex$ O O O $any$ O $any$ O O $string$ O O O O $string$ O $number$ O O O $string$ O $undefined$ O O O O $RegExpMatchArray$ O $RegExpMatchArray$ O $TitleTagData$ O $complex$ O $number$ O O $complex$ O $TitleTagData$ O $complex$ O $RegExp$ O O O O $RegExpMatchArray$ O O O O O $string$ O O O O O O $number$ O O O $number$ O $RegExpMatchArray$ O $number$ O $number$ O O O O O $RegExpMatchArray$ O $number$ O O $string$ O $RegExpMatchArray$ O $number$ O O O O O $string$ O $number$ O O O O $RegExpMatchArray$ O O O O $complex$ O O O $any$ O $any$ O O $string$ O O O O O $string$ O $complex$ O O O $any$ O $any$ O O $string$ O O O O O O O O $undefined$ O O O $ParsedData$ O $TitleTagData$ O $string$ O $string[]$ O O O O O O O $ParsedData$ O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O O O $string$ O $TitleTagData$ O $string[]$ O $number$ O O O O $string$ O $string[]$ O $number$ O O $complex$ O O O $any$ O $any$ O O $string$ O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $string$ O $string$ O O O O $string$ O $undefined$ O $ParsedData$ O $complex$ O $number$ O O $string$ O $string$ O $string$ O O O O $ParsedData$ O $string[]$ O $number$ O $string$ O O O O $ParsedData$ O O $Promise<ParsedData>$ O $string$ O $complex$ O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O $string$ O O O $string$ O $complex$ O O O O O O O $string$ O O O O O $TitleTagData$ O O O $TitleTagData$ O $complex$ O O O O O $any$ O $TitleTagData$ O $string$ O O $boolean$ O O O $boolean$ O O O $string$ O $string$ O $complex$ O $complex$ O O O O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O $ParsedData$ O $TitleTagData$ O $string$ O $any$ O O O O O O O O O O $ErrorConstructor$ O $string$ O O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import * as GenericParsers from 's' ; import { GenericParser } from 's' ; export const parsers = ( ( ) => { let parserObject : { [ title ] : GenericParser } = { } ; for ( let key in GenericParsers ) { let parser = ( GenericParsers [ key ] . prototype as GenericParser ) ; parserObject [ parser . getParserInfo ( ) . title ] = parser ; } return parserObject ; } ) ( ) ;	O O O $any$ O O O O O $any$ O O O O O O $complex$ O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $string$ O $any$ O O O $GenericParser$ O O $any$ O $string$ O O $any$ O $any$ O O $complex$ O $GenericParser$ O $ParserInfo$ O O O $string$ O O $GenericParser$ O O O $complex$ O O O O O O
import { UserConfiguration , ParsedUserConfiguration , ParsedData , ParsedUserConfigurationFile , ParsedDataWithFuzzy , userAccountData , ParserVariableData , AllVariables , CustomVariables } from 's' ; import { FuzzyService } from "s" ; import { VariableParser } from "s" ; import { APP } from 's' ; import { parsers } from 's' ; import { availableParsers } from 's' ; import * as url from 's' ; import * as steam from 's' ; import * as _ from 's' ; import * as glob from 's' ; import * as path from 's' ; import * as fs from 's' ; import * as os from 's' ; export class FileParser { private availableParsers = parsers ; private variableData : CustomVariables = { } ; private globCache : any = { } ; constructor ( private fuzzyService ) { } private get lang ( ) { return APP . lang . fileParser ; } setCustomVariables ( data ) { this . variableData = data ; } getAvailableParsers ( ) { return availableParsers ; } getParserInfo ( key ) { return this . availableParsers [ key ] ? this . availableParsers [ key ] . getParserInfo ( ) : undefined ; } validateFieldGlob ( input ) { let regex = "s" ; let match = regex . exec ( input ) ; let vParser = new VariableParser ( { left : 's' , right : 's' } ) ; if ( match !== null ) { let fieldSets = input . match ( "s" ) ; if ( fieldSets != null && fieldSets . length > 0 ) return this . lang . error . tooManyFieldGlobs__md ; let error = null ; if ( ! match [ 0 ] ) error = this . lang . error . parserIsRequired__md ; else if ( 's' === match [ 0 ] . toLowerCase ( ) ) error = this . availableParsers [ 's' ] . getParserInfo ( ) . inputs [ 's' ] . validationFn ( input . replace ( match [ 0 ] , `template` ) , true ) ; else error = this . availableParsers [ 's' ] . getParserInfo ( ) . inputs [ 's' ] . validationFn ( input . replace ( match [ 0 ] , `template` ) , true ) ; if ( match [ 0 ] ) error = vParser . setInput ( input . replace ( match [ 0 ] , match [ 0 ] ) ) . isValid ( ) ? null : APP . lang . parsers . service . validationErrors . variableString__md ; if ( error ) return error ; } else { if ( ! vParser . setInput ( input ) . isValid ( ) ) return APP . lang . parsers . service . validationErrors . variableString__md ; } if ( "s" . test ( vParser . setInput ( input ) . parse ( ) ? vParser . removeVariables ( ) : input ) ) { return this . lang . error . noWinSlashes__md ; } return null ; } executeFileParser ( configs : UserConfiguration [ ] ) { let steamDirectories : { directory : string , useCredentials : boolean , data : userAccountData [ ] } [ ] = [ ] ; let totalUserAccountsFound = 0 ; let parsedConfigs : ParsedUserConfiguration [ ] = [ ] ; this . globCache = { } ; return Promise . resolve ( ) . then ( ( ) => { let promises : Promise < ParsedData > [ ] = [ ] ; for ( let i = 0 ; i < configs . length ; i ++ ) { let parser = this . getParserInfo ( configs [ i ] . parserType ) ; steamDirectories . push ( { directory : configs [ i ] . steamDirectory , useCredentials : configs [ i ] . userAccounts . useCredentials , data : [ ] } ) ; if ( parser ) { if ( parser . inputs !== undefined ) { for ( var inputName in parser . inputs ) { if ( parser . inputs [ inputName ] . forcedInput ) configs [ i ] . parserInputs [ inputName ] = parser . inputs [ inputName ] . forcedInput ; else if ( configs [ i ] . parserInputs [ inputName ] === undefined ) configs [ i ] . parserInputs [ inputName ] = 's' ; } } promises . push ( this . availableParsers [ configs [ i ] . parserType ] . execute ( configs [ i ] . romDirectory , configs [ i ] . parserInputs , this . globCache ) ) ; } else throw new Error ( this . lang . error . parserNotFound__i . interpolate ( { name : configs [ i ] . parserType } ) ) ; } return promises ; } ) . then ( ( parserPromises ) => { return Promise . resolve ( ) . then ( ( ) => { if ( steamDirectories . length ) { let availableLogins : Promise < userAccountData [ ] > [ ] = [ ] ; for ( let i = 0 ; i < steamDirectories . length ; i ++ ) { availableLogins . push ( steam . getAvailableLogins ( steamDirectories [ i ] . directory , steamDirectories [ i ] . useCredentials ) ) ; } return Promise . all ( availableLogins ) . then ( ( data ) => { for ( let i = 0 ; i < steamDirectories . length ; i ++ ) { steamDirectories [ i ] . data = data [ i ] ; } } ) ; } } ) . then ( ( ) => { return parserPromises ; } ) ; } ) . then ( ( parserPromises ) => { return Promise . all ( parserPromises ) ; } ) . then ( ( data : ParsedDataWithFuzzy [ ] ) => { let defaultImagePromises : Promise < void > [ ] = [ ] ; let localImagePromises : Promise < void > [ ] = [ ] ; let localIconPromises : Promise < void > [ ] = [ ] ; let vParser = new VariableParser ( { left : 's' , right : 's' } ) ; for ( let i = 0 ; i < configs . length ; i ++ ) { if ( configs [ i ] . titleFromVariable . tryToMatchTitle ) this . tryToReplaceTitlesWithVariables ( data [ i ] , configs [ i ] , vParser ) ; if ( configs [ i ] . fuzzyMatch . use ) this . fuzzyService . fuzzyMatcher . fuzzyMatchParsedData ( data [ i ] , configs [ i ] . fuzzyMatch ) ; let userFilter = vParser . setInput ( configs [ i ] . userAccounts . specifiedAccounts ) . parse ( ) ? _ . uniq ( vParser . extractVariables ( data => null ) ) : [ ] ; let filteredAccounts = this . filterUserAccounts ( steamDirectories [ i ] . data , userFilter , configs [ i ] . steamDirectory , configs [ i ] . userAccounts . skipWithMissingDataDir ) ; totalUserAccountsFound += filteredAccounts . found . length ; parsedConfigs . push ( { configurationTitle : configs [ i ] . configTitle , appendArgsToExecutable : configs [ i ] . appendArgsToExecutable , imageProviders : configs [ i ] . imageProviders , foundUserAccounts : filteredAccounts . found , missingUserAccounts : filteredAccounts . missing , steamDirectory : configs [ i ] . steamDirectory , files : [ ] , failed : _ . cloneDeep ( data [ i ] . failed ) } ) ; for ( let j = 0 ; j < data [ i ] . success . length ; j ++ ) { let fuzzyTitle = data [ i ] . success [ j ] . fuzzyTitle || data [ i ] . success [ j ] . extractedTitle ; if ( fuzzyTitle . length === 0 ) { parsedConfigs [ i ] . failed . push ( data [ i ] . success [ j ] . filePath ) ; continue ; } let executableLocation = configs [ i ] . executableLocation ? configs [ i ] . executableLocation : data [ i ] . success [ j ] . filePath ; parsedConfigs [ i ] . files . push ( { steamCategories : undefined , executableLocation : executableLocation , modifiedExecutableLocation : undefined , startInDirectory : configs [ i ] . startInDirectory . length > 0 ? configs [ i ] . startInDirectory : path . dirname ( executableLocation ) , argumentString : undefined , resolvedLocalImages : [ ] , resolvedDefaultImages : [ ] , defaultImage : undefined , localImages : [ ] , resolvedLocalIcons : [ ] , localIcons : [ ] , fuzzyTitle : fuzzyTitle , extractedTitle : data [ i ] . success [ j ] . extractedTitle , finalTitle : undefined , filePath : data [ i ] . success [ j ] . filePath , imagePool : undefined , onlineImageQueries : undefined } ) ; let lastFile = parsedConfigs [ i ] . files [ parsedConfigs [ i ] . files . length - 0 ] ; let variableData = this . makeVariableData ( configs [ i ] , lastFile ) ; lastFile . finalTitle = vParser . setInput ( configs [ i ] . titleModifier ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) . trim ( ) ; } ) : 's' ; variableData . finalTitle = lastFile . finalTitle ; lastFile . argumentString = vParser . setInput ( configs [ i ] . executableArgs ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) . trim ( ) ; } ) : 's' ; lastFile . imagePool = vParser . setInput ( configs [ i ] . imagePool ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) . trim ( ) ; } ) : 's' ; lastFile . modifiedExecutableLocation = vParser . setInput ( configs [ i ] . executableModifier ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) . trim ( ) ; } ) : 's' ; lastFile . onlineImageQueries = vParser . setInput ( configs [ i ] . onlineImageQueries ) . parse ( ) ? _ . uniq ( vParser . extractVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) ; } ) ) : [ ] ; lastFile . steamCategories = vParser . setInput ( configs [ i ] . steamCategory ) . parse ( ) ? _ . uniq ( vParser . extractVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) ; } ) ) : [ ] ; } defaultImagePromises . push ( this . resolveFieldGlobs ( 's' , configs [ i ] , parsedConfigs [ i ] , vParser ) . then ( ( data ) => { for ( let j = 0 ; j < data . parsedConfig . files . length ; j ++ ) { data . parsedConfig . files [ j ] . resolvedDefaultImages = data . resolvedGlobs [ j ] ; let extRegex = "s" ; for ( let k = 0 ; k < data . resolvedFiles [ j ] . length ; k ++ ) { const item = data . resolvedFiles [ j ] [ k ] ; if ( extRegex . test ( path . extname ( item ) ) ) { data . parsedConfig . files [ j ] . defaultImage = url . encodeFile ( item ) ; break ; } } } } ) ) ; localImagePromises . push ( this . resolveFieldGlobs ( 's' , configs [ i ] , parsedConfigs [ i ] , vParser ) . then ( ( data ) => { for ( let j = 0 ; j < data . parsedConfig . files . length ; j ++ ) { data . parsedConfig . files [ j ] . resolvedLocalImages = data . resolvedGlobs [ j ] ; let extRegex = "s" ; data . parsedConfig . files [ j ] . localImages = data . resolvedFiles [ j ] . filter ( ( item ) => { return extRegex . test ( path . extname ( item ) ) ; } ) . map ( ( item ) => { return url . encodeFile ( item ) ; } ) ; } } ) ) ; localIconPromises . push ( this . resolveFieldGlobs ( 's' , configs [ i ] , parsedConfigs [ i ] , vParser ) . then ( ( data ) => { for ( let j = 0 ; j < data . parsedConfig . files . length ; j ++ ) { data . parsedConfig . files [ j ] . resolvedLocalIcons = data . resolvedGlobs [ j ] ; data . parsedConfig . files [ j ] . localIcons = data . resolvedFiles [ j ] ; } } ) ) ; } return Promise . all ( localImagePromises ) . then ( ( ) => Promise . all ( localIconPromises ) ) . then ( ( ) => Promise . all ( defaultImagePromises ) ) ; } ) . then ( ( ) => { return { parsedConfigs , noUserAccounts : totalUserAccountsFound === 0 } ; } ) ; } private tryToReplaceTitlesWithVariables ( data , config , vParser ) { let groups = undefined ; if ( config . titleFromVariable . limitToGroups . length > 0 ) { groups = vParser . setInput ( config . titleFromVariable . limitToGroups ) . parse ( ) ? _ . uniq ( vParser . extractVariables ( data => null ) ) : [ ] ; groups = _ . intersection ( Object . keys ( this . variableData ) , groups ) ; } else { groups = Object . keys ( this . variableData ) ; } if ( groups . length > 0 ) { for ( let i = 0 ; i < data . success . length ; i ++ ) { let found = false ; for ( let j = 0 ; j < groups . length ; j ++ ) { if ( config . titleFromVariable . caseInsensitiveVariables ) { for ( let key in this . variableData [ groups [ j ] ] ) { if ( data . success [ i ] . extractedTitle . toLowerCase ( ) === key . toLowerCase ( ) ) { data . success [ i ] . extractedTitle = this . variableData [ groups [ j ] ] [ key ] ; found = true ; break ; } } } else if ( this . variableData [ groups [ j ] ] [ data . success [ i ] . extractedTitle ] !== undefined ) { data . success [ i ] . extractedTitle = this . variableData [ groups [ j ] ] [ data . success [ i ] . extractedTitle ] ; found = true ; } if ( found ) break ; } if ( config . titleFromVariable . skipFileIfVariableWasNotFound && ! found ) data . success [ i ] . extractedTitle = 's' ; } } else if ( config . titleFromVariable . skipFileIfVariableWasNotFound ) { for ( let i = 0 ; i < data . success . length ; i ++ ) { data . success [ i ] . extractedTitle = 's' ; } } } private filterUserAccounts ( accountData : userAccountData [ ] , nameFilter : string [ ] , steamDirectory , skipWithMissingDirectories ) { let data : { found : userAccountData [ ] , missing : string [ ] } = { found : [ ] , missing : [ ] } ; if ( nameFilter . length === 0 ) { nameFilter = _ . map ( accountData , 's' ) ; } if ( nameFilter . length > 0 ) { for ( let i = 0 ; i < nameFilter . length ; i ++ ) { let index = accountData . findIndex ( ( item ) => item . name === nameFilter [ i ] ) ; if ( index !== - 0 ) { if ( skipWithMissingDirectories ) { let accountPath = path . join ( steamDirectory , 's' , accountData [ index ] . accountID ) ; if ( ! this . validatePath ( accountPath , true ) ) continue ; } data . found . push ( accountData [ index ] ) ; } else data . missing . push ( nameFilter [ i ] ) ; } } return data ; } private resolveFieldGlobs ( field , config , parsedConfig , vParser ) { let promises : Promise < void > [ ] = [ ] ; let resolvedGlobs : string [ ] [ ] = [ ] ; let resolvedFiles : string [ ] [ ] = [ ] ; for ( let i = 0 ; i < parsedConfig . files . length ; i ++ ) { resolvedGlobs . push ( [ ] ) ; resolvedFiles . push ( [ ] ) ; let fieldValue = config [ field ] ; if ( fieldValue ) { let variableData = this . makeVariableData ( config , parsedConfig . files [ i ] ) ; let expandableSet = "s" . exec ( fieldValue ) ; if ( expandableSet === null ) { let replacedGlob = path . resolve ( config . romDirectory , vParser . setInput ( fieldValue ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) ; } ) : 's' ) . replace ( "s" , 's' ) ; resolvedGlobs [ i ] . push ( replacedGlob ) ; promises . push ( this . globPromise ( replacedGlob , { silent : true , dot : true , realpath : true , cwd : config . romDirectory , cache : this . globCache } ) . then ( ( files ) => { resolvedFiles [ i ] = files ; } ) ) ; } else { let secondaryMatch = undefined ; let parserMatch = fieldValue . replace ( expandableSet [ 0 ] , 's' ) ; parserMatch = vParser . setInput ( parserMatch ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) ; } ) : 's' ; parserMatch = path . resolve ( config . romDirectory , parserMatch . replace ( 's' , expandableSet [ 0 ] ) ) . replace ( "s" , 's' ) ; resolvedGlobs [ i ] . push ( parserMatch ) ; if ( expandableSet [ 0 ] != undefined ) { secondaryMatch = fieldValue . replace ( expandableSet [ 0 ] , expandableSet [ 0 ] || 's' ) ; secondaryMatch = path . resolve ( config . romDirectory , vParser . setInput ( secondaryMatch ) . parse ( ) ? vParser . replaceVariables ( ( variable ) => { return this . getVariable ( variable as AllVariables , variableData ) ; } ) : 's' ) . replace ( "s" , 's' ) ; resolvedGlobs [ i ] . push ( secondaryMatch ) ; } promises . push ( Promise . resolve ( ) . then ( ( ) => { if ( "s" . test ( expandableSet [ 0 ] ) ) return this . availableParsers [ 's' ] . execute ( config . romDirectory , { 's' : parserMatch } , this . globCache ) ; else return this . availableParsers [ 's' ] . execute ( config . romDirectory , { 's' : parserMatch } , this . globCache ) ; } ) . then ( ( parsedData ) => { for ( let j = 0 ; j < parsedData . success . length ; j ++ ) { if ( config . fuzzyMatch . use ) { if ( this . fuzzyService . fuzzyMatcher . fuzzyMatchString ( parsedData . success [ j ] . extractedTitle , config . fuzzyMatch ) === parsedConfig . files [ i ] . fuzzyTitle ) { resolvedFiles [ i ] . push ( parsedData . success [ j ] . filePath ) ; } } else if ( parsedData . success [ j ] . extractedTitle === parsedConfig . files [ i ] . extractedTitle ) { resolvedFiles [ i ] . push ( parsedData . success [ j ] . filePath ) ; } } if ( secondaryMatch !== undefined ) { return this . globPromise ( secondaryMatch , { silent : true , dot : true , realpath : true , cwd : config . romDirectory , cache : this . globCache } ) . then ( ( files ) => { return resolvedFiles [ i ] . concat ( files ) ; } ) ; } else return resolvedFiles [ i ] ; } ) . then ( ( files ) => { resolvedFiles [ i ] = _ . uniq ( files ) ; } ) ) ; } } } return Promise . all ( promises ) . then ( ( ) => { return { config , parsedConfig , resolvedGlobs , resolvedFiles } ; } ) ; } private getVariable ( variable , data ) { const unavailable = 's' ; let output = variable as string ; switch ( < AllVariables > variable . toUpperCase ( ) ) { case 's' : output = path . sep ; break ; case 's' : output = data . executableLocation != undefined ? path . dirname ( data . executableLocation ) : unavailable ; break ; case 's' : output = data . executableLocation != undefined ? path . extname ( data . executableLocation ) : unavailable ; break ; case 's' : output = data . executableLocation != undefined ? path . basename ( data . executableLocation , path . extname ( data . executableLocation ) ) : unavailable ; break ; case 's' : output = data . executableLocation != undefined ? data . executableLocation : unavailable ; break ; case 's' : output = data . filePath != undefined ? path . dirname ( data . filePath ) : unavailable ; break ; case 's' : output = data . filePath != undefined ? path . extname ( data . filePath ) : unavailable ; break ; case 's' : output = data . filePath != undefined ? path . basename ( data . filePath , path . extname ( data . filePath ) ) : unavailable ; break ; case 's' : output = data . filePath != undefined ? data . filePath : unavailable ; break ; case 's' : output = data . finalTitle != undefined ? data . finalTitle : unavailable ; break ; case 's' : output = data . fuzzyTitle != undefined ? data . fuzzyTitle : unavailable ; break ; case 's' : output = data . romDirectory != undefined ? data . romDirectory : unavailable ; break ; case 's' : output = data . startInDirectory != undefined ? data . startInDirectory : unavailable ; break ; case 's' : output = data . steamDirectory != undefined ? data . steamDirectory : unavailable ; break ; case 's' : output = data . extractedTitle != undefined ? data . extractedTitle : unavailable ; break ; default : { let match = "s" . exec ( output ) ; if ( match ) { let regex = new RegExp ( match [ 0 ] , match [ 0 ] || 's' ) ; let replaceText = match [ 0 ] ; if ( typeof replaceText === 's' ) { output = match [ 0 ] . replace ( regex , replaceText ) ; } else { let innerMatch = match [ 0 ] . match ( regex ) ; output = 's' ; if ( innerMatch !== null ) { for ( let i = 0 ; i < innerMatch . length ; i ++ ) { if ( innerMatch [ i ] ) output += innerMatch [ i ] ; } if ( output . length === 0 ) output = innerMatch [ 0 ] ; } } break ; } match = "s" . exec ( output ) ; if ( match ) { output = match [ 0 ] . toUpperCase ( ) ; break ; } match = "s" . exec ( output ) ; if ( match ) { output = match [ 0 ] . toLowerCase ( ) ; break ; } match = "s" . exec ( output ) ; if ( match ) { output = match [ 0 ] . replaceDiacritics ( ) ; break ; } match = "s" . exec ( output ) ; if ( match ) { let groups = match [ 0 ] ? _ . intersection ( Object . keys ( this . variableData ) , match [ 0 ] ) : Object . keys ( this . variableData ) ; let found = false ; for ( let i = 0 ; i < groups . length ; i ++ ) { if ( this . variableData [ groups [ i ] ] [ match [ 0 ] ] !== undefined ) { output = match [ 0 ] ; found = true ; break ; } } if ( ! found ) output = unavailable ; break ; } match = "s" . exec ( output ) ; if ( match ) { const regexPlatform = match [ 0 ] . toLowerCase ( ) ; if ( regexPlatform === "s" || regexPlatform === "s" || regexPlatform === "s" ) { let platform = null ; switch ( os . platform ( ) ) { case "s" : platform = "s" ; break ; case "s" : platform = "s" ; break ; case "s" : platform = "s" ; break ; default : break ; } if ( platform !== null ) { output = ( ( platform === regexPlatform ) ? match [ 0 ] : match [ 0 ] ) || 's' ; } } } } break ; } return output ; } private makeVariableData ( config , file ) { return < ParserVariableData > { executableLocation : file . executableLocation , startInDirectory : file . startInDirectory , extractedTitle : file . extractedTitle , steamDirectory : config . steamDirectory , filePath : file . filePath , finalTitle : file . finalTitle , fuzzyTitle : file . fuzzyTitle , romDirectory : config . romDirectory } } private validatePath ( fsPath , checkForDirectory ) { try { let path = fs . statSync ( fsPath ) ; return checkForDirectory ? path . isDirectory ( ) : path . isFile ( ) ; } catch ( e ) { return false ; } } private globPromise ( pattern , options : glob . IOptions ) { return new Promise < string [ ] > ( ( resolve , reject ) => { glob ( pattern , options , ( err , files ) => { if ( err ) reject ( err ) ; else { resolve ( files ) ; } } ) ; } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O O $complex$ O O O O O O $string[]$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $complex$ O $complex$ O O $CustomVariables$ O $any$ O O O O O $any$ O O O O O O O O O $FuzzyService$ O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O $void$ O $CustomVariables$ O O O O $CustomVariables$ O $CustomVariables$ O O $string[]$ O O O O $string[]$ O O $ParserInfo$ O $string$ O O O O O $complex$ O $string$ O O O O $complex$ O $string$ O O $ParserInfo$ O O O $undefined$ O O $any$ O $string$ O O O $RegExp$ O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O $VariableParser$ O O $any$ O O $string$ O O O $string$ O O O O O O O $RegExpExecArray$ O O O O O $RegExpMatchArray$ O $string$ O $complex$ O O O O O O $RegExpMatchArray$ O O O $RegExpMatchArray$ O $number$ O O O O O O $complex$ O $complex$ O $string$ O O $any$ O O O O O O $RegExpExecArray$ O O O O $any$ O O O $complex$ O $complex$ O $string$ O O O O O O $RegExpExecArray$ O O O O $string$ O O O $any$ O O O $complex$ O O O O $ParserInfo$ O O O $ParserInputField$ O O O O $string$ O $string$ O $complex$ O $RegExpExecArray$ O O O O O O O O O O O $any$ O O O $complex$ O O O O $ParserInfo$ O O O $ParserInputField$ O O O O $string$ O $string$ O $complex$ O $RegExpExecArray$ O O O O O O O O O O O O $RegExpExecArray$ O O O O $any$ O $VariableParser$ O $VariableParser$ O $string$ O $complex$ O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O O $boolean$ O O O O O $GlobalContainer$ O $languageStruct$ O O O O O O O $string$ O O O $any$ O O $any$ O O O O O O O $VariableParser$ O $VariableParser$ O $string$ O O $boolean$ O O O O $GlobalContainer$ O $languageStruct$ O O O O O O O $string$ O O O O O O $boolean$ O $VariableParser$ O $VariableParser$ O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O O $string$ O O O O O O $complex$ O $complex$ O $string$ O O O O O O $complex$ O $UserConfiguration[]$ O $any$ O O O O O $complex$ O O $string$ O O O $boolean$ O O O $userAccountData[]$ O $any$ O O O O O O O O O O $number$ O O O O $ParsedUserConfiguration[]$ O $any$ O O O O O O O O $any$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $Promise<ParsedData>[]$ O $PromiseConstructor$ O $any$ O O O O O O O O O O $number$ O O O $number$ O $UserConfiguration[]$ O $number$ O $number$ O O O O $ParserInfo$ O O O $ParserInfo$ O $UserConfiguration[]$ O $number$ O O $string$ O O $complex$ O $number$ O O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O $boolean$ O $UserConfiguration[]$ O $number$ O O $complex$ O $boolean$ O $undefined[]$ O O O O O O O O $ParserInfo$ O O O O $ParserInfo$ O $ParserInputField$ O $undefined$ O O O O O $string$ O $ParserInfo$ O $ParserInputField$ O O O O $ParserInfo$ O $ParserInputField$ O $string$ O O $string$ O $UserConfiguration[]$ O $number$ O O $complex$ O $string$ O O $ParserInfo$ O $ParserInputField$ O $string$ O O $string$ O O O O $UserConfiguration[]$ O $number$ O O $complex$ O $string$ O O $undefined$ O $UserConfiguration[]$ O $number$ O O $complex$ O $string$ O O O O O O $Promise<ParsedData>[]$ O $number$ O O O $complex$ O $UserConfiguration[]$ O $number$ O O $string$ O O $Promise<ParsedData>$ O $UserConfiguration[]$ O $number$ O O $string$ O $UserConfiguration[]$ O $number$ O O $complex$ O O O $any$ O O O O O O O $ErrorConstructor$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O O O O O O $Promise<ParsedData>[]$ O O O O O O O $Promise<ParsedData>[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $complex$ O $number$ O O O $Promise<userAccountData[]>[]$ O $PromiseConstructor$ O $any$ O O O O O O O O O O O O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O $Promise<userAccountData[]>[]$ O $number$ O $any$ O $Promise<userAccountData[]>$ O $complex$ O $number$ O O $string$ O $complex$ O $number$ O O $boolean$ O O O O O $PromiseConstructor$ O O O $Promise<userAccountData[]>[]$ O O O O O $userAccountData[][]$ O O O O O O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O $complex$ O $number$ O O $userAccountData[]$ O $userAccountData[][]$ O $number$ O O O O O O O O O O O O O O O O O $Promise<ParsedData>[]$ O O O O O O O O O O $Promise<ParsedData>[]$ O O O O $PromiseConstructor$ O O O $Promise<ParsedData>[]$ O O O O O O O O $ParsedDataWithFuzzy[]$ O $any$ O O O O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O O $VariableParser$ O O $any$ O O $string$ O O O $string$ O O O O O O O O $number$ O O O $number$ O $UserConfiguration[]$ O $number$ O $number$ O O O O O $UserConfiguration[]$ O $number$ O O $complex$ O $boolean$ O O O $void$ O $ParsedDataWithFuzzy[]$ O $number$ O O $UserConfiguration[]$ O $number$ O O $VariableParser$ O O O O $UserConfiguration[]$ O $number$ O O $complex$ O $boolean$ O O O $FuzzyService$ O $FuzzyMatcher$ O $ParsedDataWithFuzzy$ O $ParsedDataWithFuzzy[]$ O $number$ O O $UserConfiguration[]$ O $number$ O O $complex$ O O O $any$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $complex$ O $string$ O O $boolean$ O O O $any$ O $any$ O $VariableParser$ O $string[]$ O $string$ O O O O O O O O O $complex$ O O O $complex$ O $complex$ O $number$ O O $userAccountData[]$ O $any$ O $UserConfiguration[]$ O $number$ O O $string$ O $UserConfiguration[]$ O $number$ O O $complex$ O $boolean$ O O $number$ O $complex$ O $userAccountData[]$ O $number$ O $ParsedUserConfiguration[]$ O $number$ O O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O $boolean$ O $UserConfiguration[]$ O $number$ O O $boolean$ O $string[]$ O $UserConfiguration[]$ O $number$ O O $string[]$ O $userAccountData[]$ O $complex$ O $userAccountData[]$ O $string[]$ O $complex$ O $string[]$ O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O $undefined[]$ O O O O $any$ O $any$ O $any$ O $ParsedDataWithFuzzy[]$ O $number$ O O $string[]$ O O O O O O O $number$ O O O $number$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O $number$ O O O O $string$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O O O $string$ O $number$ O O O O $ParsedUserConfiguration[]$ O $number$ O O $string[]$ O $number$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O O O O O O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O $UserConfiguration[]$ O $number$ O O $string$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O $ParsedUserConfiguration[]$ O $number$ O O $ParsedUserConfigurationFile[]$ O $number$ O O $undefined$ O $undefined$ O $string$ O $string$ O $undefined$ O $undefined$ O $any$ O $UserConfiguration[]$ O $number$ O O $string$ O $number$ O O O $UserConfiguration[]$ O $number$ O O $string$ O $any$ O $any$ O $string$ O O $undefined$ O $undefined$ O $undefined[]$ O O O O $undefined[]$ O O O O $undefined$ O $undefined$ O $undefined[]$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O $string$ O $string$ O $string$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O $undefined$ O $undefined$ O $string$ O $ParsedDataWithFuzzy[]$ O $number$ O O $complex$ O $number$ O O $string$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O $ParsedUserConfigurationFile$ O $ParsedUserConfiguration[]$ O $number$ O O $ParsedUserConfigurationFile[]$ O $ParsedUserConfiguration[]$ O $number$ O O $ParsedUserConfigurationFile[]$ O $number$ O O O O O $ParserVariableData$ O O O $ParserVariableData$ O $UserConfiguration[]$ O $number$ O O $ParsedUserConfigurationFile$ O O $ParsedUserConfigurationFile$ O $string$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O $string$ O O O O O O O O $ParserVariableData$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O $string$ O O O O O O O O $ParsedUserConfigurationFile$ O $string$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O $string$ O O O O O O O O $ParsedUserConfigurationFile$ O $string$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O $string$ O O O O O O O O $ParsedUserConfigurationFile$ O $string[]$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $any$ O $any$ O $VariableParser$ O $string[]$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O O O O O O O O $ParsedUserConfigurationFile$ O $string[]$ O $VariableParser$ O $VariableParser$ O $UserConfiguration[]$ O $number$ O O $string$ O O $boolean$ O O O $any$ O $any$ O $VariableParser$ O $string[]$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O O O O O O O O O $Promise<void>[]$ O $number$ O O O $complex$ O O O $UserConfiguration[]$ O $number$ O O $ParsedUserConfiguration[]$ O $number$ O O $VariableParser$ O O O O O $complex$ O O O O O O $number$ O O O $number$ O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $complex$ O $string[][]$ O $number$ O O O $RegExp$ O O O O O O $number$ O O O $number$ O $complex$ O $string[][]$ O $number$ O O $number$ O $number$ O O O O $string$ O $complex$ O $string[][]$ O $number$ O O $number$ O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $string$ O O O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O $any$ O $string$ O $string$ O O O O O O O O O O O $Promise<void>[]$ O $number$ O O O $complex$ O O O $UserConfiguration[]$ O $number$ O O $ParsedUserConfiguration[]$ O $number$ O O $VariableParser$ O O O O O $complex$ O O O O O O $number$ O O O $number$ O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $complex$ O $string[][]$ O $number$ O O O $RegExp$ O O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $complex$ O $string[][]$ O $number$ O O $complex$ O O $string$ O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $string$ O O O O O O $U[]$ O O $string$ O O O O $any$ O $string$ O $string$ O O O O O O O O O O $Promise<void>[]$ O $number$ O O O $complex$ O O O $UserConfiguration[]$ O $number$ O O $ParsedUserConfiguration[]$ O $number$ O O $VariableParser$ O O O O O $complex$ O O O O O O $number$ O O O $number$ O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $complex$ O $string[][]$ O $number$ O O $complex$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $complex$ O $string[][]$ O $number$ O O O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O O O O O O O O O O $ParsedUserConfiguration[]$ O $boolean$ O $number$ O O O O O O O O O $void$ O $ParsedDataWithFuzzy$ O $UserConfiguration$ O $VariableParser$ O O O $any$ O $undefined$ O O O $UserConfiguration$ O $complex$ O $string$ O $number$ O O O O $any$ O $VariableParser$ O $VariableParser$ O $UserConfiguration$ O $complex$ O $string$ O O $boolean$ O O O $any$ O $any$ O $VariableParser$ O $string[]$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $ObjectConstructor$ O $complex$ O O O $CustomVariables$ O O $any$ O O O O O $any$ O $ObjectConstructor$ O $complex$ O O O $CustomVariables$ O O O O O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O $number$ O O O O $boolean$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $UserConfiguration$ O $complex$ O $boolean$ O O O O O $string$ O O O $CustomVariables$ O $any$ O $number$ O O O O O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O $string$ O O O $string$ O $string$ O O O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O O $CustomVariables$ O $any$ O $number$ O O O $string$ O O $boolean$ O O O O O O O O O O O O O $CustomVariables$ O $any$ O $number$ O O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O $undefined$ O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O O $CustomVariables$ O $any$ O $number$ O O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O $boolean$ O O O O O O $boolean$ O O O O O O $UserConfiguration$ O $complex$ O $boolean$ O O $boolean$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O O O O O O O $UserConfiguration$ O $complex$ O $boolean$ O O O O O $number$ O O O $number$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O $number$ O O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O O O O O O $complex$ O $userAccountData[]$ O $any$ O O O $string[]$ O O O O O $string$ O $boolean$ O O O $complex$ O O $userAccountData[]$ O $any$ O O O $string[]$ O O O O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $string[]$ O $number$ O O O O $string[]$ O $any$ O $any$ O $userAccountData[]$ O O O O O O O $string[]$ O $number$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $number$ O $userAccountData[]$ O $number$ O O $userAccountData$ O O $userAccountData$ O $string$ O $string[]$ O $number$ O O O O O $number$ O O O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $string$ O O O $userAccountData[]$ O $number$ O O $string$ O O O O O O O $any$ O $any$ O O O O O O O $complex$ O $userAccountData[]$ O $number$ O $userAccountData[]$ O $number$ O O O O O $complex$ O $string[]$ O $number$ O $string[]$ O $number$ O O O O O O $complex$ O O O $complex$ O $string$ O $UserConfiguration$ O $ParsedUserConfiguration$ O $VariableParser$ O O O $Promise<void>[]$ O $PromiseConstructor$ O O O O O O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $string[][]$ O $number$ O O O O O $string[][]$ O $number$ O O O O O O $any$ O $UserConfiguration$ O $string$ O O O O $any$ O O O $ParserVariableData$ O O O $ParserVariableData$ O $UserConfiguration$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $any$ O O O O $RegExpExecArray$ O O O O O $any$ O $any$ O $any$ O $UserConfiguration$ O $string$ O $VariableParser$ O $VariableParser$ O $any$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O O O O O O O $any$ O O O O O O $string[][]$ O $number$ O O $number$ O $any$ O O $Promise<void>[]$ O $number$ O O O $Promise<string[]>$ O $any$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O $UserConfiguration$ O $string$ O $any$ O O O $any$ O O O O O O $string[]$ O O O $string[][]$ O $number$ O O $string[]$ O O O O O O O O O $string$ O $undefined$ O O $any$ O $any$ O $any$ O $RegExpExecArray$ O O O O O O O $any$ O $VariableParser$ O $VariableParser$ O $any$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O O O O O O $any$ O $any$ O $any$ O $UserConfiguration$ O $string$ O $any$ O $any$ O O O $RegExpExecArray$ O O O O O O $any$ O O O O O O $string[][]$ O $number$ O O $number$ O $any$ O O O O $RegExpExecArray$ O O O O $undefined$ O O $string$ O $any$ O $any$ O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O O O $string$ O $any$ O $any$ O $UserConfiguration$ O $string$ O $VariableParser$ O $VariableParser$ O $string$ O O $boolean$ O O O $VariableParser$ O $string$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $ParserVariableData$ O O O O O O O O $any$ O O O O O O $string[][]$ O $number$ O O $number$ O $string$ O O O $Promise<void>[]$ O $number$ O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O O $boolean$ O $RegExpExecArray$ O O O O O O O O $complex$ O O O O $Promise<ParsedData>$ O $UserConfiguration$ O $string$ O O O O $any$ O O O O $any$ O O O O O O $complex$ O O O O $Promise<ParsedData>$ O $UserConfiguration$ O $string$ O O O O $any$ O O O O $any$ O O O O O O O O $ParsedData$ O O O O O O $number$ O O O $number$ O $ParsedData$ O $complex$ O $number$ O $number$ O O O O O $UserConfiguration$ O $complex$ O $boolean$ O O O O O O $FuzzyService$ O $FuzzyMatcher$ O $any$ O $ParsedData$ O $complex$ O $number$ O O $string$ O $UserConfiguration$ O $complex$ O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O $string[][]$ O $number$ O O $number$ O $ParsedData$ O $complex$ O $number$ O O $string$ O O O O O O O $ParsedData$ O $complex$ O $number$ O O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O $string[][]$ O $number$ O O $number$ O $ParsedData$ O $complex$ O $number$ O O $string$ O O O O O O $string$ O $undefined$ O O O O O $Promise<string[]>$ O $string$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O $UserConfiguration$ O $string$ O $any$ O O O $any$ O O O O O O $string[]$ O O O O $string[][]$ O $number$ O O $complex$ O $string[]$ O O O O O O O O $string[][]$ O $number$ O O O O O O O O $string[]$ O O O $string[][]$ O $number$ O O $any$ O $any$ O $string[]$ O O O O O O O O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O O O O O O $UserConfiguration$ O $ParsedUserConfiguration$ O $string[][]$ O $string[][]$ O O O O O O O $string$ O $AllVariables$ O $ParserVariableData$ O O O O O O O O $string$ O $AllVariables$ O O O O O O $any$ O $AllVariables$ O $string$ O O O O O O O $string$ O $any$ O $any$ O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $any$ O $any$ O $ParserVariableData$ O $string$ O $any$ O $any$ O $ParserVariableData$ O $string$ O O O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O $string$ O $ParserVariableData$ O $string$ O $undefined$ O $ParserVariableData$ O $string$ O O O O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O $RegExp$ O O $RegExpConstructor$ O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O O O O $string$ O $RegExpExecArray$ O O O O O O O $string$ O O O O $string$ O $RegExpExecArray$ O O O O $complex$ O $RegExp$ O $string$ O O O O O O $RegExpMatchArray$ O $RegExpExecArray$ O O O O $complex$ O $RegExp$ O O $string$ O O O O O $RegExpMatchArray$ O O O O O O O $number$ O O O $number$ O $RegExpMatchArray$ O $number$ O $number$ O O O O O $RegExpMatchArray$ O $number$ O O $string$ O $RegExpMatchArray$ O $number$ O O O O O $string$ O $number$ O O O $string$ O $RegExpMatchArray$ O O O O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O $string$ O $RegExpExecArray$ O O O O $string$ O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O $string$ O $RegExpExecArray$ O O O O $string$ O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O $string$ O $RegExpExecArray$ O O O O $string$ O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O $any$ O $RegExpExecArray$ O O O O $any$ O $any$ O $ObjectConstructor$ O $complex$ O O O $CustomVariables$ O O $RegExpExecArray$ O O O O O $ObjectConstructor$ O $complex$ O O O $CustomVariables$ O O O $boolean$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O O O $CustomVariables$ O $any$ O $number$ O O O $RegExpExecArray$ O O O O O $undefined$ O O $string$ O $RegExpExecArray$ O O O O $boolean$ O O O O O O O O O O $boolean$ O $string$ O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O $string$ O $RegExpExecArray$ O O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O $string$ O O O $string$ O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O O O O O O O O O O O O $string$ O O O $ParserVariableData$ O $UserConfiguration$ O $ParsedUserConfigurationFile$ O O O O $any$ O O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $UserConfiguration$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $ParsedUserConfigurationFile$ O $string$ O $string$ O $UserConfiguration$ O $string$ O O O $any$ O $string$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $string$ O O O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $Promise<string[]>$ O $string$ O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O O O O O O O $void$ O $void$ O O O $any$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O O $void$ O $any$ O O O O O O O O O O O
export const imageProviders = { 's' : require ( 's' ) , 's' : require ( 's' ) }	O O $complex$ O O O O $any$ O O O O O O $any$ O O O O
import { ProviderPostEventMap , ProviderCallback , ProviderReceiveEventMap , ProviderReceiveObject } from 's' ; import { FuzzyService , LoggerService , SettingsService } from "s" ; import { imageProviders } from 's' ; import { availableProviders } from 's' ; import { APP } from 's' ; import { queue } from "s" ; import { Subject } from "s" ; import * as _ from 's' ; type QueueTask = { title : string , eventCallback : ProviderCallback } ; const _queue = true ? undefined as never : queue < QueueTask , void > ( ( task , callback ) => { } ) ; type AsyncQueue = typeof _queue ; export class ImageProvider { private availableProviders : { [ key ] : { worker : Worker , queue : AsyncQueue } } = { } ; private callbackMap = new Map < string , { queueCallback : ( ) => void , eventCallback : ProviderCallback } > ( ) ; private filterIsEnabled : boolean = false ; private stopped : Subject < any > = new Subject ( ) ; constructor ( private fuzzyService , private loggerService ) { for ( let key in imageProviders ) { this . availableProviders [ key ] = { worker : ( new ( imageProviders [ key ] ) ( ) as Worker ) , queue : this . createQueue ( key ) } ; this . availableProviders [ key ] . worker . addEventListener ( 's' , this . messageEvent . bind ( this ) ) ; this . availableProviders [ key ] . worker . addEventListener ( 's' , this . errorEvent . bind ( this ) ) ; } } private get lang ( ) { return APP . lang . imageProvider ; } private createQueue ( key ) { if ( this . availableProviders [ key ] && this . availableProviders [ key ] . queue ) this . availableProviders [ key ] . queue . kill ( ) ; return queue < QueueTask , void > ( ( task , callback ) => { let id = _ . uniqueId ( ) ; this . callbackMap . set ( id , { eventCallback : task . eventCallback , queueCallback : callback } ) ; this . postMessage ( this . availableProviders [ key ] . worker , 's' , { id : id , title : task . title } ) ; } , 0 ) ; } toggleFilter ( enable ) { if ( this . filterIsEnabled !== enable ) { for ( let key in this . availableProviders ) { this . postMessage ( this . availableProviders [ key ] . worker , 's' , { enable : enable } ) ; } } } setFuzzyList ( list : { totalGames : number , games : string [ ] } ) { for ( let key in this . availableProviders ) { this . postMessage ( this . availableProviders [ key ] . worker , 's' , { list } ) ; } } getAvailableProviders ( ) { return availableProviders ; } retrieveUrls ( title , providers : string [ ] , eventCallback ) { for ( let i = 0 ; i < providers . length ; i ++ ) { if ( this . availableProviders [ providers [ i ] ] ) this . availableProviders [ providers [ i ] ] . queue . push ( { title , eventCallback } ) ; else eventCallback ( 's' , { title : title } ) ; } } stopUrlDownload ( ) { for ( let key in this . availableProviders ) { let provider = this . availableProviders [ key ] ; provider . queue = this . createQueue ( key ) ; this . postMessage ( provider . worker , 's' , null ) ; } this . callbackMap . clear ( ) ; this . stopped . next ( ) ; } get stopEvent ( ) { return this . stopped . asObservable ( ) ; } private postMessage < K extends keyof ProviderReceiveEventMap > ( worker , event : K , data : ProviderReceiveEventMap [ K ] ) { worker . postMessage ( < ProviderReceiveObject < K > > { event : event , data : data } ) ; } private messageEvent ( event ) { if ( event . data && event . data . event ) { switch ( ( event . data . event as keyof ProviderPostEventMap ) ) { case 's' : { let data = ( event . data . data as ProviderPostEventMap [ 's' ] ) ; if ( this . callbackMap . has ( data . id ) ) { this . callbackMap . get ( data . id ) . eventCallback ( 's' , { provider : data . provider , title : data . title , error : data . error , url : data . url } ) ; } } break ; case 's' : { let data = ( event . data . data as ProviderPostEventMap [ 's' ] ) ; if ( this . callbackMap . has ( data . id ) ) { this . callbackMap . get ( data . id ) . eventCallback ( 's' , { provider : data . provider , time : data . time } ) ; } } break ; case 's' : { let data = ( event . data . data as ProviderPostEventMap [ 's' ] ) ; if ( this . callbackMap . has ( data . id ) ) { this . callbackMap . get ( data . id ) . eventCallback ( 's' , { content : data . content } ) ; } } break ; case 's' : { let data = ( event . data . data as ProviderPostEventMap [ 's' ] ) ; if ( this . callbackMap . has ( data . id ) ) { let callbackData = this . callbackMap . get ( data . id ) ; this . callbackMap . delete ( data . id ) ; callbackData . eventCallback ( 's' , { title : data . title } ) ; callbackData . queueCallback ( ) ; } } break ; case 's' : { let data = ( event . data . data as ProviderPostEventMap [ 's' ] ) ; this . fuzzyService . eventCallback ( data . event , data . data ) ; } break ; default : break ; } } } private errorEvent ( event ) { if ( event && event . error ) { this . loggerService . error ( this . lang . error . webWorkerError__i . interpolate ( { error : event . error } ) ) ; } else { this . loggerService . error ( this . lang . error . unknownWebWorkerError . interpolate ( { data : JSON . stringify ( event , null , 0 ) } ) ) ; } } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O O O O O $string[]$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O $string$ O O O $ProviderCallback$ O $any$ O O O $any$ O O O $undefined$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O $any$ O O $complex$ O O O $string$ O O O $Worker$ O $complex$ O $any$ O $any$ O O O O O O O $complex$ O O $MapConstructor$ O O O O $void$ O O O O O O $ProviderCallback$ O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $FuzzyService$ O O $LoggerService$ O O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O O $Worker$ O O O O $complex$ O $string$ O O O O O $complex$ O O $any$ O O O $any$ O $string$ O O O O O $complex$ O $string$ O O $Worker$ O $complex$ O O O O O $void$ O $any$ O O O O O O O $complex$ O $string$ O O $Worker$ O $complex$ O O O O O $void$ O $any$ O O O O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O O O $any$ O $string$ O O O O O O $complex$ O $string$ O O O O $complex$ O $string$ O O $any$ O O O $complex$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O O O $complex$ O $string$ O O $Worker$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $void$ O $boolean$ O O O O O O $boolean$ O $boolean$ O O O O O $string$ O O O $complex$ O O O O $void$ O O O $complex$ O $string$ O O $Worker$ O O O O $boolean$ O $boolean$ O O O O O O $void$ O $complex$ O O $number$ O O O $string[]$ O O O O O O O O O O $string$ O O O $complex$ O O O O $void$ O O O $complex$ O $string$ O O $Worker$ O O O O $complex$ O O O O O $string[]$ O O O O $string[]$ O O $void$ O $string$ O $string[]$ O O O O O $ProviderCallback$ O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O O O $complex$ O $string[]$ O $number$ O O O O O $complex$ O $string[]$ O $number$ O O O $any$ O $any$ O O $string$ O $ProviderCallback$ O O O O $ProviderCallback$ O O O O $string$ O $string$ O O O O O $void$ O O O O O O $string$ O O O $complex$ O O O $complex$ O O O $complex$ O $string$ O O $complex$ O $any$ O O O $any$ O $string$ O O O O $void$ O $complex$ O $Worker$ O O O O O O O O O $complex$ O $void$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O O $Worker$ O $K$ O $any$ O $ProviderReceiveEventMap[K]$ O $any$ O $any$ O O O $Worker$ O $complex$ O O $any$ O $any$ O O O $K$ O $K$ O $ProviderReceiveEventMap[K]$ O $ProviderReceiveEventMap[K]$ O O O O O $void$ O $MessageEvent$ O O O O $MessageEvent$ O $any$ O $MessageEvent$ O $any$ O $any$ O O O O O $MessageEvent$ O $any$ O $any$ O O $any$ O O O O O O O O $ProviderPostErrorData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $boolean$ O $ProviderPostErrorData$ O $string$ O O O O O $complex$ O $complex$ O $ProviderPostErrorData$ O $string$ O O $ProviderCallback$ O O O O O O $ProviderPostErrorData$ O O O $string$ O $ProviderPostErrorData$ O $string$ O $complex$ O $ProviderPostErrorData$ O $complex$ O $string$ O $ProviderPostErrorData$ O $string$ O O O O O O O O O O O O $ProviderPostTimeoutData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $boolean$ O $ProviderPostTimeoutData$ O $string$ O O O O O $complex$ O $complex$ O $ProviderPostTimeoutData$ O $string$ O O $ProviderCallback$ O O O O O O $ProviderPostTimeoutData$ O O O $number$ O $ProviderPostTimeoutData$ O $number$ O O O O O O O O O O O O $ProviderPostImageData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $boolean$ O $ProviderPostImageData$ O $string$ O O O O O $complex$ O $complex$ O $ProviderPostImageData$ O $string$ O O $ProviderCallback$ O O O O $ImageContent$ O $ProviderPostImageData$ O $ImageContent$ O O O O O O O O O O O O $ProviderPostCompletedData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $boolean$ O $ProviderPostCompletedData$ O $string$ O O O O $complex$ O O O $complex$ O $complex$ O $ProviderPostCompletedData$ O $string$ O O O O $complex$ O $boolean$ O $ProviderPostCompletedData$ O $string$ O O $complex$ O $ProviderCallback$ O O O O $string$ O $ProviderPostCompletedData$ O $string$ O O O $complex$ O $void$ O O O O O O O O O O O O $ProviderFuzzyEventData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O $FuzzyService$ O $void$ O $ProviderFuzzyEventData$ O O O $ProviderFuzzyEventData$ O $complex$ O O O O O O O O O O O O O $void$ O $ErrorEvent$ O O O O $ErrorEvent$ O $ErrorEvent$ O $any$ O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $any$ O $ErrorEvent$ O $any$ O O O O O O O O O $LoggerService$ O $void$ O O O $complex$ O $complex$ O $string$ O $string$ O O $string$ O $JSON$ O $complex$ O $ErrorEvent$ O O O O O O O O O O O O
const Memoize = require ( "s" ) ; export class MemoizedFunction < FunctionType = Function > { private static fnFallback = ( ) => { throw new Error ( "s" ) ; } ; private cache : object = { } ; private memoizedFn ! : FunctionType ; constructor ( ) { this . clearFunction ( ) . clearCache ( ) ; } public memoize ( fn , isVariadicFunction ) { this . memoizedFn = Memoize ( fn , { cache : { create : ( ) => { return { get : ( key ) => this . cache [ key ] , has : ( key ) => this . cache [ key ] !== undefined , set : ( key , value ) => this . cache [ key ] = value , } } , } , strategy : isVariadicFunction ? Memoize . strategies . variadic : undefined , } ) ; return this ; } public setCache ( object : { [ key ] : string } ) { this . cache = object ; return this ; } public getCache ( ) { return this . cache ; } get fn ( ) { return this . memoizedFn ; } public clearCache ( ) { this . cache = { } ; return this ; } public clearFunction ( ) { this . memoizedFn = MemoizedFunction . fnFallback as any ; return this ; } }	O $any$ O $any$ O O O O O O $any$ O $any$ O $FunctionConstructor$ O O O O $never$ O O O O O O O $ErrorConstructor$ O O O O O O O $object$ O O O O O O O $FunctionType$ O O $any$ O O O O O O O $this$ O O O $this$ O O O O O $this$ O $FunctionType$ O $boolean$ O O O O $FunctionType$ O $any$ O $FunctionType$ O O $complex$ O O $complex$ O O O O O O O $any$ O O $string$ O O O O $object$ O $string$ O O $boolean$ O O $string$ O O O O $object$ O $string$ O O $undefined$ O $string$ O O $string$ O $string$ O O O O $object$ O $string$ O O $string$ O O O O O O $any$ O $boolean$ O $any$ O $any$ O $any$ O $undefined$ O O O O O O O O O $this$ O $complex$ O O O $string$ O O O O O O O O $object$ O $complex$ O O O O O O $object$ O O O O O O $object$ O O O $FunctionType$ O O O O O O $FunctionType$ O O O $this$ O O O O O $object$ O O O O O O O O O $this$ O O O O O $FunctionType$ O $any$ O $never$ O O O O O O O O
import { ParsedDataWithFuzzy , FuzzyEventCallback , FuzzyMatcherOptions } from "s" ; import { MemoizedFunction } from "s" ; const Fuzzy = require ( 's' ) ; export class FuzzyMatcher { private list : { totalGames : number , games : string [ ] } ; private latinList : string [ ] ; private memFn = new MemoizedFunction ( ) ; constructor ( private eventCallback ? , list ? : { totalGames : number , games : string [ ] } , cache ? : { [ key ] : any } ) { this . setEventCallback ( eventCallback || ( ( event , data ) => { } ) ) ; this . setFuzzyList ( list ) ; this . setFuzzyCache ( cache ) ; this . memFn . memoize ( this . matchFromList . bind ( this ) , false ) ; } setEventCallback ( eventCallback ) { this . eventCallback = eventCallback ; } setFuzzyCache ( cache : { [ key ] : any } ) { this . memFn . setCache ( cache || { } ) ; } setFuzzyList ( list : { totalGames : number , games : string [ ] } ) { this . list = list ; if ( this . isLoaded ( ) ) { this . latinList = new Array ( list . games . length ) ; for ( let i = 0 ; i < list . games . length ; i ++ ) { this . latinList [ i ] = list . games [ i ] . replaceDiacritics ( ) ; } } } fuzzyMatchParsedData ( data , options , verbose = true ) { if ( this . isLoaded ( ) ) { for ( let i = 0 ; i < data . success . length ; i ++ ) { let matchedData = this . memFn . fn ( data . success [ i ] . extractedTitle , options ) ; if ( matchedData . matched ) { data . success [ i ] . fuzzyTitle = matchedData . output ; if ( verbose ) this . eventCallback ( 's' , { info : 's' , stringA : data . success [ i ] . fuzzyTitle , stringB : data . success [ i ] . extractedTitle } ) ; } } } return data ; } fuzzyMatchString ( input , options , verbose = true ) { if ( this . isLoaded ( ) ) { let data = this . memFn . fn ( input , options ) ; if ( data . matched && verbose ) this . eventCallback ( 's' , { info : 's' , stringA : data . output , stringB : input } ) ; return data . output ; } return input ; } fuzzyEqual ( a , b , options , verbose = true ) { if ( this . isLoaded ( ) ) { let dataA = this . memFn . fn ( a , options ) ; let dataB = this . memFn . fn ( b , options ) ; if ( dataA . output === dataB . output ) { if ( verbose ) this . eventCallback ( 's' , { info : 's' , stringA : a , stringB : b } ) ; return true ; } else { if ( verbose ) this . eventCallback ( 's' , { info : 's' , stringA : a , stringB : b } ) ; return false ; } } return false ; } isLoaded ( ) { return this . list != null && this . list . games . length > 0 ; } private matchFromList ( input , options ) { if ( input . length === 0 ) { return { output : input , matched : false } ; } else if ( "s" . test ( input ) ) { let modifiedInput = input . replace ( "s" , 's' ) ; modifiedInput = this . modifyString ( modifiedInput , options ) ; let matches = this . performMatching ( modifiedInput , options . replaceDiacritics ) ; if ( matches . matched ) return matches ; modifiedInput = input . replace ( "s" , 's' ) ; modifiedInput = this . modifyString ( modifiedInput , options ) ; matches = this . performMatching ( modifiedInput , options . replaceDiacritics ) ; if ( matches . matched ) return matches ; } let modifiedInput = this . modifyString ( input , options ) ; return this . performMatching ( modifiedInput , options . replaceDiacritics ) ; } private performMatching ( input , diacriticsRemoved ) { const list = diacriticsRemoved ? this . latinList : this . list . games ; const preparedQuery = Fuzzy . prepareQuery ( input , { usePathScoring : false } ) ; let bestScore = 0 ; let matches : string [ ] = [ ] ; for ( let i = 0 ; i < list . length ; i ++ ) { let score = Fuzzy . score ( list [ i ] , preparedQuery . query , { preparedQuery , usePathScoring : false } ) ; if ( score >= bestScore && score !== 0 ) { bestScore = score ; matches . push ( this . list . games [ i ] ) ; } } if ( matches . length ) return { output : this . getBestMatch ( input , matches ) , matched : true } ; else return { output : input , matched : false } ; } private modifyString ( input , options ) { if ( options . replaceDiacritics ) { input = input . replaceDiacritics ( ) ; } if ( options . removeCharacters ) { input = input . replace ( "s" , 's' ) ; input = input . replace ( "s" , 's' ) ; } if ( options . removeBrackets ) input = input . replace ( "s" , 's' ) ; if ( options . removeCharacters || options . removeBrackets ) { input = input . replace ( "s" , 's' ) . trim ( ) ; } return input . trim ( ) ; } private getBestMatch ( pattern , matches : string [ ] ) { let bestIndex = 0 ; let lengthDiff = Infinity ; let bestScore = 0 ; for ( let i = 0 ; i < matches . length ; i ++ ) { let diff = matches [ i ] . length - pattern . length ; let absDiff = Math . abs ( diff ) ; if ( absDiff < lengthDiff ) { bestIndex = i ; bestScore = Fuzzy . score ( matches [ i ] , pattern ) ; if ( absDiff === 0 ) break ; else lengthDiff = absDiff ; } else if ( absDiff === lengthDiff && diff < 0 ) { let currentScore = Fuzzy . score ( matches [ i ] , pattern ) ; if ( bestScore <= currentScore ) { bestIndex = i ; bestScore = currentScore ; } } } return matches [ bestIndex ] ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $complex$ O O $number$ O O O $string[]$ O O O O O O O $string[]$ O O O O O O $MemoizedFunction<Function>$ O O $any$ O O O O O O $FuzzyEventCallback$ $FuzzyEventCallback$ O $complex$ O O O $number$ O O O $string[]$ O O O O O O $complex$ O O O O $string$ O O O O O O O O $void$ O $FuzzyEventCallback$ O O O $any$ O $any$ O O O O O O O O O $void$ O $complex$ O O O O $void$ O $complex$ O O O O $MemoizedFunction<Function>$ O $MemoizedFunction<Function>$ O O O $complex$ O $any$ O O O O O O O O $void$ O $FuzzyEventCallback$ O O O O $FuzzyEventCallback$ O $FuzzyEventCallback$ O O $void$ O $complex$ O O O $string$ O O O O O O O O $MemoizedFunction<Function>$ O $MemoizedFunction<Function>$ O $complex$ O O O O O O $void$ O $complex$ O O $number$ O O O $string[]$ O O O O O O O O O $complex$ O $complex$ O O O O O $boolean$ O O O O O O $string[]$ O O $ArrayConstructor$ O $complex$ O $string[]$ O $number$ O O O O O $number$ O O O $number$ O $complex$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O $complex$ O $string[]$ O $number$ O O $string$ O O O O O O $ParsedDataWithFuzzy$ O $ParsedDataWithFuzzy$ O $FuzzyMatcherOptions$ O $boolean$ O O O O O O O O $boolean$ O O O O O O O $number$ O O O $number$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O $number$ O O O O $any$ O O O $MemoizedFunction<Function>$ O $Function$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O $FuzzyMatcherOptions$ O O O O $any$ O $any$ O O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O $any$ O $any$ O O O $boolean$ O O O $FuzzyEventCallback$ O O O O O O O O $string$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O $string$ O $ParsedDataWithFuzzy$ O $complex$ O $number$ O O $string$ O O O O O O O $ParsedDataWithFuzzy$ O O $any$ O $string$ O $FuzzyMatcherOptions$ O $boolean$ O O O O O O O O $boolean$ O O O O O $any$ O O O $MemoizedFunction<Function>$ O $Function$ O $string$ O $FuzzyMatcherOptions$ O O O O $any$ O $any$ O $boolean$ O O O $FuzzyEventCallback$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $any$ O $any$ O O O $string$ O O $boolean$ O $string$ O $string$ O $FuzzyMatcherOptions$ O $boolean$ O O O O O O O O $boolean$ O O O O O $any$ O O O $MemoizedFunction<Function>$ O $Function$ O $string$ O $FuzzyMatcherOptions$ O O O $any$ O O O $MemoizedFunction<Function>$ O $Function$ O $string$ O $FuzzyMatcherOptions$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O $FuzzyEventCallback$ O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O $boolean$ O O O $FuzzyEventCallback$ O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O $boolean$ O O O O O O $complex$ O O O O O $complex$ O $string[]$ O $number$ O O O O O $complex$ O $string$ O $FuzzyMatcherOptions$ O O O O $string$ O $number$ O O O O O O $string$ O $string$ O $boolean$ O O O O O O O O O O $boolean$ O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O $string$ O O O $string$ O $string$ O $FuzzyMatcherOptions$ O O O $complex$ O O O $complex$ O $string$ O $FuzzyMatcherOptions$ O $boolean$ O O O O $complex$ O $boolean$ O O $complex$ O $string$ O $string$ O $complex$ O O O O O O $string$ O O O $string$ O $string$ O $FuzzyMatcherOptions$ O O $complex$ O O O $complex$ O $string$ O $FuzzyMatcherOptions$ O $boolean$ O O O O $complex$ O $boolean$ O O $complex$ O O O $string$ O O O $string$ O $string$ O $FuzzyMatcherOptions$ O O O O O $complex$ O $string$ O $FuzzyMatcherOptions$ O $boolean$ O O O O $complex$ O $string$ O $boolean$ O O O $string[]$ O $boolean$ O O O $string[]$ O O O $complex$ O $string[]$ O O $any$ O $any$ O $any$ O $string$ O O $boolean$ O O O O O O $number$ O O O O $string[]$ O O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $any$ O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $any$ O O $any$ O $boolean$ O O O O O O O $any$ O $number$ O $any$ O O O O $number$ O $any$ O $string[]$ O $number$ O O O $complex$ O $string[]$ O $number$ O O O O O O O $string[]$ O $number$ O O O $string$ O O O $string$ O $string$ O $string[]$ O O $boolean$ O O O O O O O $string$ O $string$ O $boolean$ O O O O O O $string$ O $string$ O $FuzzyMatcherOptions$ O O O O $FuzzyMatcherOptions$ O $boolean$ O O $string$ O $string$ O $string$ O O O O O O $FuzzyMatcherOptions$ O $boolean$ O O $string$ O $string$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O O O O $FuzzyMatcherOptions$ O $boolean$ O $string$ O $string$ O $complex$ O O O O O O O O $FuzzyMatcherOptions$ O $boolean$ O $FuzzyMatcherOptions$ O $boolean$ O O $string$ O $string$ O $complex$ O O O O O O $string$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O $string[]$ O O O O O O O $number$ O O O O $number$ O $number$ O O $number$ O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $number$ O $string[]$ O $number$ O O $number$ O $string$ O $number$ O O $number$ O $Math$ O $number$ O $number$ O O O O $number$ O $number$ O O $number$ O $number$ O $number$ O $any$ O $any$ O $string[]$ O $number$ O O $string$ O O O O $number$ O O O O O O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O O O O O $any$ O $any$ O $any$ O $string[]$ O $number$ O O $string$ O O O O $number$ O $any$ O O $number$ O $number$ O $number$ O $any$ O O O O O $string[]$ O $number$ O O O O
import { Http } from 's' ; import { FuzzyListTimestamps , FuzzyEventCallback , FuzzyError } from "s" ; import { FuzzyMatcher } from "s" ; import { BehaviorSubject } from "s" ; import * as paths from "s" ; import * as json from "s" ; export class FuzzyListLoader { private list = new BehaviorSubject < { totalGames : number , games : string [ ] } > ( { totalGames : 0 , games : [ ] } ) ; private cache = new BehaviorSubject < { [ key ] : any } > ( { } ) ; private checkInterval : number = 0 ; private forcedUpdate : number = 0 ; private timeout : number = 0 ; constructor ( private http , private eventCallback , private isOfflineMode ? : ( ) => boolean , private timestamps ? ) { this . setTimestamps ( timestamps || { check : 0 , download : 0 } ) ; } observeList ( ) { return this . list . asObservable ( ) ; } observeCache ( ) { return this . cache . asObservable ( ) ; } setEventCallback ( eventCallback ) { this . eventCallback = eventCallback ; } setTimestamps ( timestamps ) { this . timestamps = timestamps ; } getList ( ) { return this . list . getValue ( ) ; } getCache ( ) { return this . cache . getValue ( ) ; } loadList ( offlineMode ? ) { let isOffline = offlineMode !== undefined ? offlineMode : ( this . isOfflineMode ? this . isOfflineMode ( ) : true ) ; return this . readList ( ) . then ( ( list ) => { if ( this . list . getValue ( ) !== list ) this . list . next ( list ) ; let currentTime = new Date ( ) . getTime ( ) ; if ( ( currentTime - this . timestamps . download > this . forcedUpdate || this . list . getValue ( ) . totalGames === 0 ) && ! isOffline ) { this . eventCallback ( 's' , { info : 's' } ) ; return this . downloadList ( ) . then ( ( listAndCache ) => { this . list . next ( listAndCache ) ; this . timestamps . download = currentTime ; this . timestamps . check = currentTime ; this . eventCallback ( 's' , { info : 's' } ) ; return this . saveList ( ) . then ( ( ) => this . eventCallback ( 's' , this . timestamps ) ) ; } ) ; } else if ( currentTime - this . timestamps . check > this . checkInterval && ! isOffline ) { this . eventCallback ( 's' , { info : 's' } ) ; return this . getTotalCount ( ) . then ( ( countInDatabase ) => { if ( this . list . getValue ( ) . totalGames !== countInDatabase ) { this . eventCallback ( 's' , { info : 's' } ) ; return this . downloadList ( ) . then ( ( list ) => { this . list . next ( list ) ; this . timestamps . download = currentTime ; this . timestamps . check = currentTime ; this . eventCallback ( 's' , { info : 's' } ) ; return this . saveList ( ) . then ( ( ) => this . eventCallback ( 's' , this . timestamps ) ) ; } ) ; } else { this . eventCallback ( 's' , { info : 's' } ) ; this . timestamps . check = currentTime ; return this . eventCallback ( 's' , this . timestamps ) ; } } ) ; } } ) . catch ( ( error ) => { if ( error instanceof Error ) this . eventCallback ( 's' , { error : 's' , isFatal : true , errorMsg : error . message } ) ; else this . eventCallback ( 's' , { error : ( error as FuzzyError ) , isFatal : true } ) ; } ) ; } loadCache ( ) { return json . read ( paths . fuzzyCache , { } ) . then ( ( data ) => { this . cache . next ( data ) ; } ) ; } isLoaded ( ) { return this . list . getValue ( ) . totalGames > 0 ; } isUpToDate ( ) { let currentTime = new Date ( ) . getTime ( ) ; return ! ( currentTime - this . timestamps . download > this . forcedUpdate || currentTime - this . timestamps . check > this . checkInterval ) ; } createFuzzyMatcher ( ) { return new FuzzyMatcher ( this . eventCallback , this . list . getValue ( ) || null ) ; } saveList ( ) { let fuzzyList = { totalGames : this . list . getValue ( ) . totalGames , games : this . list . getValue ( ) . games } ; return json . write ( paths . fuzzyList , fuzzyList ) ; } saveCache ( ) { return json . write ( paths . fuzzyCache , this . cache . getValue ( ) ) ; } resetList ( ) { this . timestamps . download = 0 ; this . timestamps . check = 0 ; this . list . next ( { totalGames : 0 , games : [ ] } ) ; return this . saveList ( ) . then ( ( ) => this . eventCallback ( 's' , this . timestamps ) ) . then ( ( ) => this . loadList ( ) ) ; } resetCache ( ) { this . cache . next ( { } ) ; return this . saveCache ( ) ; } private getTotalCount ( ) { return new Promise < number > ( ( resolve , reject ) => { this . http . get ( 's' ) . timeout ( this . timeout ) . subscribe ( ( response ) => { try { let parsedBody = response . json ( ) ; if ( parsedBody [ 's' ] !== undefined ) resolve ( parseInt ( parsedBody [ 's' ] ) ) ; else reject ( 's' ) ; } catch ( error ) { reject ( error ) ; } } , ( error ) => { reject ( error ) ; } ) ; } ) ; } private downloadList ( ) { return new Promise < { totalGames : number , games : string [ ] , cache : { [ key ] : any } } > ( ( resolve , reject ) => { this . http . get ( 's' ) . timeout ( this . timeout ) . subscribe ( ( response ) => { try { let parsedBody = response . json ( ) ; resolve ( Object . assign ( parsedBody , { cache : { } } ) ) ; } catch ( error ) { reject ( error ) ; } } , ( error ) => { reject ( error ) ; } ) ; } ) ; } private readList ( ) { return Promise . resolve ( ) . then ( ( ) => { if ( this . list . getValue ( ) . totalGames === 0 || this . list . getValue ( ) . games . length === 0 ) { return json . read ( paths . fuzzyList , { totalGames : 0 , games : [ ] } ) . then ( ( data ) => { return data ; } ) ; } else return this . list . getValue ( ) ; } ) ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any$ O O $any$ O O $number$ O O O $string[]$ O O O O O O O O $number$ O O O $undefined[]$ O O O O O O O $any$ O O $any$ O O O $string$ O O O O O O O O O O O $number$ O O O O O O $number$ O O O O O O $number$ O O O O O O O O $Http$ O O $FuzzyEventCallback$ O O $boolean$ O O O O O O O O $FuzzyListTimestamps$ $FuzzyListTimestamps$ O O O O $void$ O $FuzzyListTimestamps$ O O $number$ O O O $number$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $void$ O $FuzzyEventCallback$ O O O O $FuzzyEventCallback$ O $FuzzyEventCallback$ O O $void$ O $FuzzyListTimestamps$ O O O O $FuzzyListTimestamps$ O $FuzzyListTimestamps$ O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $Promise<void>$ O $boolean$ $boolean$ O O O $boolean$ O $boolean$ O $undefined$ O $boolean$ O O O O $boolean$ O O O $boolean$ O O O O O O O O O $Promise<any>$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O $number$ O O O $FuzzyListTimestamps$ O $number$ O O O $number$ O O O $any$ O $any$ O O O $any$ O O O O O $boolean$ O O O O $FuzzyEventCallback$ O O O O O O O O O O O O O $complex$ O O O O O O $complex$ O O O O O $any$ O $any$ O $complex$ O O O O $FuzzyListTimestamps$ O $number$ O $number$ O O O $FuzzyListTimestamps$ O $number$ O $number$ O O O $FuzzyEventCallback$ O O O O O O O O O O O O O $Promise<any>$ O O O O O O O O O O $FuzzyEventCallback$ O O O O O $FuzzyListTimestamps$ O O O O O O O O O O $number$ O O O $FuzzyListTimestamps$ O $number$ O O O $number$ O O $boolean$ O O O O $FuzzyEventCallback$ O O O O O O O O O O O O O $Promise<number>$ O O O O O O $number$ O O O O O O O $any$ O $any$ O O O $any$ O $number$ O O O O $FuzzyEventCallback$ O O O O O O O O O O O O O $complex$ O O O O O O $complex$ O O O O O $any$ O $any$ O $complex$ O O O O $FuzzyListTimestamps$ O $number$ O $number$ O O O $FuzzyListTimestamps$ O $number$ O $number$ O O O $FuzzyEventCallback$ O O O O O O O O O O O O O $Promise<any>$ O O O O O O O O O O $FuzzyEventCallback$ O O O O O $FuzzyListTimestamps$ O O O O O O O O O O O $FuzzyEventCallback$ O O O O O O O O O O O O $FuzzyListTimestamps$ O $number$ O $number$ O O O O $FuzzyEventCallback$ O O O O O $FuzzyListTimestamps$ O O O O O O O O O O $complex$ O O $any$ O O O O O $any$ O $ErrorConstructor$ O O O $FuzzyEventCallback$ O O O O O O O O $true$ O O O $string$ O $Error$ O $string$ O O O O O O $FuzzyEventCallback$ O O O O $FuzzyError$ O O $any$ O $any$ O O $true$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $Promise<any>$ O $any$ O $string$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O O O O $boolean$ O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O $number$ O O O $FuzzyListTimestamps$ O $number$ O O O $number$ O $number$ O O O $FuzzyListTimestamps$ O $number$ O O O $number$ O O O $FuzzyMatcher$ O O O O O $any$ O O O $FuzzyEventCallback$ O O O $any$ O $any$ O O O O O O O $Promise<any>$ O O O O $complex$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $Promise<any>$ O $any$ O $string$ O $complex$ O O O $Promise<any>$ O O O O $any$ O $Promise<any>$ O $any$ O $string$ O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O O $FuzzyListTimestamps$ O $number$ O O O O O $FuzzyListTimestamps$ O $number$ O O O O O $any$ O $any$ O O $number$ O O O $undefined[]$ O O O O O O O O O $Promise<any>$ O O O O O O O O O O $FuzzyEventCallback$ O O O O O $FuzzyListTimestamps$ O O O O O O O O O O $Promise<void>$ O O O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O $Promise<any>$ O O O O O $Promise<number>$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O O O $any$ O O O $number$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $undefined$ O $void$ O $number$ O $any$ O O O O O O O $void$ O O O O O O O $any$ O O $void$ O $any$ O O O O O O $any$ O O O $void$ O $any$ O O O O O O O O O O $complex$ O O O O O $PromiseConstructor$ O O $number$ O O O $string[]$ O O O O O $complex$ O O O $string$ O O O O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O O O $any$ O O O $number$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O $ObjectConstructor$ O O O $any$ O O ${}$ O O O O O O O O O O $any$ O O $void$ O $any$ O O O O O O $any$ O O O $void$ O $any$ O O O O O O O O O O $Promise<any>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $Promise<any>$ O $any$ O $string$ O O $number$ O O O $undefined[]$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O
import { MarkdownIt } from 's' ; import { APP } from 's' ; import * as _ from 's' ; export function MarkdownVariable ( md , options ? ) { md . inline . ruler . push ( "s" , ( state , silent ? ) : boolean => { let startPos = state . pos ; if ( state . src . charAt ( startPos ++ ) !== "s" || state . src . charAt ( startPos ++ ) !== "s" ) { return false ; } let markup = state . src . slice ( state . pos , startPos ) ; let endPos = state . src . indexOf ( "s" , startPos ) ; if ( endPos !== - 0 ) { let content = state . src . slice ( state . pos , ++ endPos ) ; if ( ! content . match ( "s" ) ) { let match = "s" . exec ( content ) ; if ( ! silent && match !== null && match [ 0 ] != null && match [ 0 ] != null ) { let token = state . push ( "s" , match [ 0 ] , 0 ) ; token . content = match [ 0 ] ; token . markup = markup ; } state . pos = endPos ; return true ; } } if ( ! silent ) { state . pending += markup ; } state . pos = startPos ; return true ; } ) ; md . renderer . rules [ "s" ] = ( tokens , idx , options , env , self ) => { const token = tokens [ idx ] ; switch ( token . tag ) { case 's' : return `template` ; default : return 's' ; } } ; }	O O $any$ O O O O O O $GlobalContainer$ O O O O O O O $any$ O O O O O $void$ O $MarkdownIt$ O $any$ $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $boolean$ $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $any$ O O O O O $boolean$ O $RegExpExecArray$ O O O $RegExpExecArray$ O O O O O O $RegExpExecArray$ O O O O O O O O $any$ O $any$ O $any$ O O O $RegExpExecArray$ O O O O O O O $any$ O $any$ O $RegExpExecArray$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O
import * as paths from "s" ; import * as fs from 's' ; import * as path from 's' ; import * as glob from 's' ; import * as _ from 's' ; export class ThemeManager { private currentThemeField : string = 's' ; private colorRules = { } ; readFromColorFile ( themeTitle , silentNotFound ) { this . colorRules = { } ; return new Promise < boolean > ( ( resolve , reject ) => { fs . readFile ( path . join ( paths . userThemesDir , themeTitle + 's' ) , 's' , ( error , data ) => { try { if ( error ) { if ( error . code === 's' && ! silentNotFound || error . code !== 's' ) reject ( error ) ; else resolve ( false ) ; } else { let isColor = require ( 's' ) ; let colorRules = JSON . parse ( data ) ; let prefixedStyles = { } ; for ( let key in colorRules ) { let colorLessKey = key . replace ( 's' , 's' ) ; if ( isColor ( colorRules [ key ] ) ) this . colorRules [ colorLessKey ] = colorRules [ key ] ; } resolve ( true ) ; } } catch ( error ) { reject ( error ) ; } } ) ; } ) ; } saveToColorFile ( themeTitle ) { return new Promise < boolean > ( ( resolve , reject ) => { fs . outputFile ( path . join ( paths . userThemesDir , themeTitle + 's' ) , JSON . stringify ( this . colorRules , null , 0 ) , ( err ) => { if ( err ) reject ( err ) ; else resolve ( ) ; } ) ; } ) ; } deleteColorFile ( themeTitle ) { return new Promise ( ( resolve , reject ) => { fs . unlink ( path . join ( paths . userThemesDir , themeTitle + 's' ) , ( error ) => { if ( error ) reject ( error ) ; else resolve ( ) ; } ) ; } ) ; } saveToDevColorFile ( ) { return new Promise < boolean > ( ( resolve , reject ) => { let newDevFilePath = path . join ( path . dirname ( paths . devThemePath ) , 's' , new Date ( ) . getTime ( ) + path . extname ( paths . devThemePath ) ) ; fs . ensureDir ( path . dirname ( newDevFilePath ) , ( error ) => { if ( error ) reject ( error ) ; else { fs . rename ( paths . devThemePath , newDevFilePath , ( error ) => { if ( error ) reject ( error ) ; else { fs . writeFile ( paths . devThemePath , this . getCssString ( 's' ) , ( err ) => { if ( err ) reject ( error ) ; else resolve ( ) ; } ) ; } } ) ; } } ) ; } ) ; } readFromStylesheets ( selectorText ) { let colorRules : { [ rule ] : string } = { } ; let css = document . styleSheets ; for ( let i = 0 ; i < css . length ; i ++ ) { let sheet = < CSSStyleSheet > css [ i ] ; if ( sheet . cssRules ) { for ( let j = 0 ; j < sheet . cssRules . length ; j ++ ) { let sheetRule = < CSSStyleRule > sheet . cssRules [ j ] ; if ( sheetRule instanceof CSSStyleRule && sheetRule . selectorText === selectorText ) { _ . merge ( colorRules , this . extractCustomProperties ( sheetRule . cssText ) ) ; } } } } this . colorRules = colorRules ; } readThemeTitle ( silentNotFound ) { return new Promise < string > ( ( resolve , reject ) => { fs . readFile ( paths . userSettings , 's' , ( error , data ) => { try { if ( error ) { if ( error . code === 's' && ! silentNotFound || error . code !== 's' ) reject ( error ) ; else resolve ( undefined ) ; } else { resolve ( JSON . parse ( data ) [ this . currentThemeField ] ) ; } } catch ( error ) { reject ( error ) ; } } ) ; } ) ; } saveThemeTitle ( themeTitle ) { return new Promise ( ( resolve , reject ) => { fs . readFile ( paths . userSettings , 's' , ( error , data ) => { try { if ( error ) { if ( error . code !== 's' ) return reject ( error ) ; } let fileData = { } ; if ( data ) fileData = JSON . parse ( data ) ; fileData [ this . currentThemeField ] = themeTitle ; fs . outputFile ( paths . userSettings , JSON . stringify ( fileData , null , 0 ) , ( error ) => { if ( error ) reject ( error ) ; else resolve ( ) ; } ) ; } catch ( error ) { reject ( error ) ; } } ) ; } ) ; } getAvailableThemes ( ) { return new Promise < string [ ] > ( ( resolve , reject ) => { glob ( 's' , { silent : true , cwd : paths . userThemesDir } , ( error , files ) => { if ( error ) reject ( error ) ; else { for ( let i = 0 ; i < files . length ; i ++ ) { files [ i ] = path . basename ( files [ i ] , 's' ) ; } resolve ( files ) ; } } ) ; } ) ; } getCssString ( indent ) { let toCss = require ( 's' ) ; return toCss ( { 's' : this . prefixColorRules ( ) } , { indent : indent } ) ; } updateValuesFromDOM ( ) { let colorValue = null ; for ( let key in this . colorRules ) { colorValue = document . documentElement . style . getPropertyValue ( 's' + key ) ; if ( colorValue ) this . colorRules [ key ] = colorValue ; } } getColorRules ( ) { return this . colorRules ; } getColorRuleValue ( colorRule ) { return this . colorRules [ colorRule ] ; } injectColorRules ( ) { let styleElement = this . getStyleElement ( ) ; styleElement . innerHTML = this . getCssString ( 's' ) ; } removeInjectedColorRules ( ) { let styleElement = this . getStyleElement ( ) ; styleElement . remove ( ) ; } private getStyleElement ( ) { let element = < HTMLStyleElement > document . getElementById ( 's' ) ; if ( element === null ) { let head = document . head ; element = document . createElement ( 's' ) ; element . id = 's' ; let styleTags = document . head . getElementsByTagName ( 's' ) ; if ( styleTags . length ) head . insertBefore ( element , styleTags [ 0 ] ) ; else head . appendChild ( element ) ; } return element ; } private extractCustomProperties ( cssText ) { let extractedProperties : { [ rule ] : string } = { } ; let regExpr = "s" ; let match = null ; let namesToHex = require ( 's' ) ; while ( ( match = regExpr . exec ( cssText ) ) !== null ) { extractedProperties [ match [ 0 ] ] = ( < string > ( match [ 0 ] === 's' ? 's' : ( namesToHex ( match [ 0 ] ) === undefined ? match [ 0 ] : namesToHex ( match [ 0 ] ) ) ) ) . toLowerCase ( ) . replace ( "s" , 's' ) ; } return extractedProperties ; } private prefixColorRules ( ) { let cssObject : { [ rule ] : string } = { } ; for ( let key in this . colorRules ) { cssObject [ 's' + key ] = this . colorRules [ key ] ; } return cssObject ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O O O O ${}$ O O O O $Promise<boolean>$ O $string$ O $boolean$ O O O O ${}$ O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O $any$ O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $JSON$ O $any$ O $any$ O O O ${}$ O O O O O O O $string$ O $any$ O O O $string$ O $string$ O $complex$ O O O O O O O O $any$ O $any$ O $string$ O O O O O ${}$ O $string$ O O $any$ O $string$ O O O $void$ O O O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O O $Promise<boolean>$ O $string$ O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $JSON$ O $complex$ O O O ${}$ O O O O O O O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise<unknown>$ O $string$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise<boolean>$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $DateConstructor$ O O O $number$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O $any$ O O O O O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O O O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O $complex$ O O O $string$ O O O O O O O O O $StyleSheetList$ O $Document$ O $StyleSheetList$ O O O O $number$ O O O $number$ O $StyleSheetList$ O $number$ O $number$ O O O O $CSSStyleSheet$ O O $complex$ O $StyleSheetList$ O $number$ O O O O $CSSStyleSheet$ O $CSSRuleList$ O O O O O $number$ O O O $number$ O $CSSStyleSheet$ O $CSSRuleList$ O $number$ O $number$ O O O O $CSSStyleRule$ O O $complex$ O $CSSStyleSheet$ O $CSSRuleList$ O $number$ O O O O $CSSStyleRule$ O $complex$ O $CSSStyleRule$ O $string$ O $string$ O O $any$ O $any$ O $complex$ O O O $complex$ O $CSSStyleRule$ O $string$ O O O O O O O O O ${}$ O $complex$ O O $Promise<string>$ O $boolean$ O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O $any$ O $any$ O O O $void$ O $any$ O O O $void$ O $undefined$ O O O O O $void$ O $JSON$ O $any$ O $any$ O O O O $string$ O O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O O $Promise<unknown>$ O $string$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $void$ O $any$ O O O O ${}$ O O O O O O $any$ O ${}$ O $JSON$ O $any$ O $any$ O O ${}$ O O O $string$ O O $string$ O $any$ O $any$ O $any$ O $string$ O $JSON$ O $complex$ O ${}$ O O O O O O O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O O O O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O O $Promise<string[]>$ O O O O O $PromiseConstructor$ O O O O O O O $void$ O $void$ O O O $any$ O O O O $boolean$ O O O $string$ O $any$ O $string$ O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O $any$ O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O O O $void$ O $any$ O O O O O O O O O O $any$ O $string$ O O O $any$ O $any$ O O O O O $any$ O O O O O O $complex$ O O O O O $string$ O $string$ O O O O $void$ O O O O $any$ O O O O O O $string$ O O O ${}$ O O $any$ O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $string$ O O O O $any$ O O O ${}$ O $string$ O O $any$ O O O ${}$ O O O O O O ${}$ O O $any$ O $string$ O O O O O ${}$ O $string$ O O O $void$ O O O O $HTMLStyleElement$ O O O $HTMLStyleElement$ O O O $HTMLStyleElement$ O $string$ O O O $any$ O O O O O $void$ O O O O $HTMLStyleElement$ O O O $HTMLStyleElement$ O O O $HTMLStyleElement$ O $void$ O O O O O $HTMLStyleElement$ O O O O $HTMLStyleElement$ O O $complex$ O $Document$ O $HTMLElement$ O O O O O O $HTMLStyleElement$ O O O O O $HTMLHeadElement$ O $Document$ O $HTMLHeadElement$ O $HTMLStyleElement$ O $Document$ O O O O O O $HTMLStyleElement$ O $string$ O O O O $HTMLCollectionOf<HTMLStyleElement>$ O $Document$ O $HTMLHeadElement$ O O O O O O O O $HTMLCollectionOf<HTMLStyleElement>$ O $number$ O $HTMLHeadElement$ O $T$ O $HTMLStyleElement$ O $HTMLCollectionOf<HTMLStyleElement>$ O O O O O O $HTMLHeadElement$ O $T$ O $HTMLStyleElement$ O O O O $HTMLStyleElement$ O O O $complex$ O $string$ O O O $complex$ O O O $string$ O O O O O O O O O $RegExp$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O $complex$ O $any$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $undefined$ O $any$ O O O O $any$ O $any$ O O O O O O O O $string$ O O O $complex$ O O O O O O O O $complex$ O O O $complex$ O O O O $complex$ O O O $string$ O O O O O O O O O O O $string$ O O O ${}$ O O $complex$ O O O $string$ O O O O ${}$ O $string$ O O O O $complex$ O O O
export class FileSelector { private fileInput : HTMLInputElement = undefined ; private callback : ( target , event ? ) => void = undefined ; constructor ( ) { this . fileInput = document . createElement ( 's' ) ; this . fileInput . setAttribute ( 's' , 's' ) ; this . fileInput . onchange = ( event ) => { if ( this . callback ) this . callback ( this . fileInput , event ) ; this . fileInput . value = null ; } } set accept ( value ) { this . fileInput . setAttribute ( 's' , value || 's' ) ; } set multiple ( value ) { this . fileInput . setAttribute ( 's' , value ? 's' : 's' ) ; } set directory ( value ) { this . fileInput . setAttribute ( 's' , value ? 's' : 's' ) ; } set onChange ( callback : ( target , event ) => void ) { this . callback = callback ; } trigger ( ) { this . fileInput . click ( ) ; } } ;	O O $any$ O O $HTMLInputElement$ O $complex$ O $undefined$ O O $void$ O O $HTMLInputElement$ O $Event$ $Event$ O O O O $undefined$ O O O O O O O $HTMLInputElement$ O $Document$ O O O O O O O O $HTMLInputElement$ O $void$ O O O O O O O O $HTMLInputElement$ O $any$ O O $Event$ O O O O O O O $void$ O O O $void$ O O O $HTMLInputElement$ O $Event$ O O O O $HTMLInputElement$ O $string$ O O O O O O $string$ O $string$ O O O O $HTMLInputElement$ O $void$ O O O $string$ O O O O O O $boolean$ O $boolean$ O O O O $HTMLInputElement$ O $void$ O O O $boolean$ O O O O O O O O $boolean$ O $boolean$ O O O O $HTMLInputElement$ O $void$ O O O $boolean$ O O O O O O O O $void$ O $void$ O O $HTMLInputElement$ O $Event$ O O O O O O O $void$ O $void$ O O $void$ O O O O O $HTMLInputElement$ O $void$ O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VDF_ScreenshotsFile , VDF_ShortcutsFile , VDF_AddedItemsFile } from 's' ; export interface VDF_ListItem { shortcuts : VDF_ShortcutsFile , screenshots : VDF_ScreenshotsFile , addedItems : VDF_AddedItemsFile } export interface VDF_ListData { [ steamDirectory ] : { [ userId ] : VDF_ListItem } } export interface VDF_ScreenshotsData { [ appId ] : { title : string , url : string } | string } export interface VDF_ShortcutsItem { appname : string , exe : string , StartDir : string , LaunchOptions : string , icon : string , tags : string [ ] } export interface VDF_AddedItemsData { [ key ] : true | undefined } export type SteamDirectory = string ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $VDF_ShortcutsFile$ O $any$ O $VDF_ScreenshotsFile$ O $any$ O $VDF_AddedItemsFile$ O $any$ O O O $any$ O O $string$ O O O O $string$ O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O $any$ O O $string$ O O O O O O O O $any$ O O O
export interface FuzzyListTimestamps { check : number , download : number } export interface FuzzyInfoData { info : FuzzyInfo , stringA ? : string , stringB ? : string } export interface FuzzyErrorData { isFatal : boolean , error : FuzzyError , errorMsg ? : string } export interface FuzzyTimestampData extends FuzzyListTimestamps { } export interface FuzzyEventMap { info : FuzzyInfoData , error : FuzzyErrorData , newTimestamps : FuzzyTimestampData } export type FuzzyInfo = 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; export type FuzzyError = 's' | 's' ; export type FuzzyEventCallback = < K extends keyof FuzzyEventMap > ( event : K , data : FuzzyEventMap [ K ] ) => void ; export interface ParsedDataWithFuzzy { success : { filePath : string , extractedTitle : string , fuzzyTitle : string } [ ] , failed : string [ ] } export interface FuzzyMatcherOptions { removeCharacters ? : boolean , removeBrackets ? : boolean , replaceDiacritics ? : boolean }	O O $any$ O $number$ O O O $number$ O O O O O $any$ O $FuzzyInfo$ O $any$ O $string$ O O O O $string$ O O O O O O $any$ O $boolean$ O O O $FuzzyError$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $FuzzyInfoData$ O $any$ O $FuzzyErrorData$ O $any$ O $FuzzyTimestampData$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O $any$ O O $any$ O O $K$ O $any$ O $FuzzyEventMap[K]$ O $any$ O $any$ O O O O O O O $any$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $string[]$ O O O O O O O $any$ O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O
import { ImageContent } from "s" ; import { FuzzyEventMap } from "s" ; export interface ProviderImageData { content : ImageContent } export interface ProviderErrorData { title : string , provider : ImageContent [ "s" ] , error : number | string , url ? : string } export interface ProviderTimeoutData { provider : ImageContent [ "s" ] , time : number } export interface ProviderCompletedData { title : string } export interface ProviderCallbackEventMap { image : ProviderImageData , error : ProviderErrorData , timeout : ProviderTimeoutData , completed : ProviderCompletedData } export type ProviderCallback = < K extends keyof ProviderCallbackEventMap > ( event : K , data : ProviderCallbackEventMap [ K ] ) => void ; export interface ProviderId { id : string , } export interface ProviderPostImageData extends ProviderImageData , ProviderId { } export interface ProviderPostErrorData extends ProviderErrorData , ProviderId { } export interface ProviderPostTimeoutData extends ProviderTimeoutData , ProviderId { } export interface ProviderPostCompletedData extends ProviderCompletedData , ProviderId { } export interface ProviderFuzzyEventData { event : keyof FuzzyEventMap , data : FuzzyEventMap [ keyof FuzzyEventMap ] } export interface ProviderPostEventMap { image : ProviderPostImageData , error : ProviderPostErrorData , timeout : ProviderPostTimeoutData , fuzzyEvent : ProviderFuzzyEventData , completed : ProviderPostCompletedData } export interface ProviderPostObject < K extends keyof ProviderPostEventMap > { event : K , data : ProviderPostEventMap [ K ] } ; export interface ProviderFuzzyListData { list : { totalGames : number , games : string [ ] } } export interface ProviderRetrieveData extends ProviderId { title : string } export interface ProviderFilterData { enable : boolean } export interface ProviderReceiveEventMap { fuzzyList : ProviderFuzzyListData , retrieveUrls : ProviderRetrieveData , toggleFiltering : ProviderFilterData stopDownloads : null } export interface ProviderReceiveObject < K extends keyof ProviderReceiveEventMap > { event : K , data : ProviderReceiveEventMap [ K ] } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $ImageContent$ O $any$ O O O $any$ O $string$ O O O O O $any$ O O O O $complex$ O O O O O $string$ O O O O O O $any$ O O O $any$ O O O O $number$ O O O O O $any$ O $string$ O O O O O $any$ O $ProviderImageData$ O $any$ O $ProviderErrorData$ O $any$ O $ProviderTimeoutData$ O $any$ O $ProviderCompletedData$ O $any$ O O O $any$ O O $any$ O O $any$ O O $K$ O $any$ O $ProviderCallbackEventMap[K]$ O $any$ O $any$ O O O O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $complex$ O $any$ O O $any$ O O O O $any$ O $ProviderPostImageData$ O $any$ O $ProviderPostErrorData$ O $any$ O $ProviderPostTimeoutData$ O $any$ O $ProviderFuzzyEventData$ O $any$ O $ProviderPostCompletedData$ O $any$ O O O $any$ O $any$ O O $any$ O O $K$ O $any$ O $ProviderPostEventMap[K]$ O $any$ O $any$ O O O O O $any$ O $complex$ O O $number$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O $boolean$ O O O O O $any$ O $ProviderFuzzyListData$ O $any$ O $ProviderRetrieveData$ O $any$ O $ProviderFilterData$ O $any$ $null$ O O O O O $any$ O $any$ O O $any$ O O $K$ O $any$ O $ProviderReceiveEventMap[K]$ O $any$ O $any$ O O O
import { FuzzyListTimestamps } from "s" ; export interface PreviewSettings { retrieveCurrentSteamImages : boolean , imageZoomPercentage : number , preload : boolean } export interface AppSettings { fuzzyMatcher : { timestamps : FuzzyListTimestamps , verbose : boolean , filterProviders : boolean } , language : string , offlineMode : boolean , enabledProviders : string [ ] , previewSettings : PreviewSettings , navigationWidth : number , clearLogOnTest : boolean , knownSteamDirectories : string [ ] }	O O $any$ O O O O O O $any$ O $boolean$ O O O $number$ O O O $boolean$ O O O O O $any$ O $complex$ O O $FuzzyListTimestamps$ O $any$ O $boolean$ O O O $boolean$ O O O O $string$ O O O $boolean$ O O O $string[]$ O O O O O $PreviewSettings$ O $any$ O $number$ O O O $boolean$ O O O $string[]$ O O O O O
export interface VariableParserItem { type : 's' | 's' , range : { start : number , end : number } , children : VariableParserItem [ ] , parent : VariableParserItem } ; export interface VariableParserAST { leftDelimiter : string , rightDelimiter : string , input : string , maxLevel : number , parsedTree : VariableParserItem [ ] } ; export interface VariableParserBreadthFirstData { level : number , next : VariableParserBreadthFirstData , children : VariableParserItem [ ] , passedData : any } export interface VariableParserPostOrderData { level : number , index : number , indexInParent : number , previous : VariableParserPostOrderData , children : VariableParserItem [ ] , passedData : any [ ] }	O O $any$ O O O O O O O $complex$ O O $number$ O O O $number$ O O O O $VariableParserItem[]$ O $any$ O O O $VariableParserItem$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $VariableParserItem[]$ O $any$ O O O O O O $any$ O $number$ O O O $VariableParserBreadthFirstData$ O $any$ O $VariableParserItem[]$ O $any$ O O O $any$ O O O O O $any$ O $number$ O O O $number$ O O O $number$ O O O $VariableParserPostOrderData$ O $any$ O $VariableParserItem[]$ O $any$ O O O $any[]$ O O O O O
import { AbstractControl } from 's' ; import { Observable } from "s" ; export type NestedInputValidator = ( control , path : string [ ] ) => string ; export type NestedInputInfoClick = ( control , path : string [ ] ) => void ; export type NestedInputChange = ( control , path : string [ ] ) => void ; export type NestedInputHidden = ( ) => Observable < boolean > | Promise < boolean > ; type ObjectFields < T > = { [ P in keyof T ] : T [ P ] ; } ; export namespace NestedFormElement { export class Select { label ? : string ; initialValue ? : any ; isHidden ? : NestedInputHidden ; disabled ? : boolean ; values : { display : string , real ? : any } [ ] ; placeholder ? : string ; multiple ? : boolean allowEmpty ? : boolean onValidate ? : NestedInputValidator ; onChange ? : NestedInputChange ; onInfoClick ? : NestedInputInfoClick ; constructor ( init ? < Select > ) { Object . assign ( this , init ) ; } } ; export class Input { label ? : string ; initialValue ? : string ; isHidden ? : NestedInputHidden ; disabled ? : boolean ; placeholder ? : string ; onValidate ? : NestedInputValidator ; onChange ? : NestedInputChange ; onInfoClick ? : NestedInputInfoClick ; highlight ? : ( input , tag ) => string ; constructor ( init ? < Input > ) { Object . assign ( this , init ) ; } } ; export class Path { label ? : string ; initialValue ? : string ; directory ? : boolean ; isHidden ? : NestedInputHidden ; disabled ? : boolean ; placeholder ? : string ; error ? : string ; onValidate ? : NestedInputValidator ; onChange ? : NestedInputChange ; onInfoClick ? : NestedInputInfoClick ; constructor ( init ? < Path > ) { Object . assign ( this , init ) ; } } ; export class Toggle { label ? : string ; initialValue ? : boolean ; text ? : string ; disabled ? : boolean ; isHidden ? : NestedInputHidden ; onValidate ? : NestedInputValidator ; onChange ? : NestedInputChange ; onInfoClick ? : NestedInputInfoClick ; constructor ( init ? < Toggle > ) { Object . assign ( this , init ) ; } } ; export class Group { label ? : string ; onInfoClick ? : NestedInputInfoClick ; isHidden ? : NestedInputHidden ; children ? : { [ key ] : NestedFormElements } ; constructor ( init ? < Group > ) { Object . assign ( this , init ) ; } } ; } export type NestedFormInputs = NestedFormElement . Input | NestedFormElement . Select | NestedFormElement . Toggle ; export type NestedFormElements = NestedFormInputs | NestedFormElement . Group ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O $AbstractControl$ O $string[]$ O O O O O O O O O O $any$ O O $AbstractControl$ O $string[]$ O O O O O O O O O O $any$ O O $AbstractControl$ O $string[]$ O O O O O O O O O O $any$ O O O O $any$ O O O O $PromiseConstructor$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $string$ O O O O $any$ O O O O $NestedInputHidden$ O O $any$ O $boolean$ O O O O $complex$ O O $string$ O O O $any$ O O O O O O O $string$ O O O O $boolean$ O O O $boolean$ O O O $NestedInputValidator$ O O $any$ O $NestedInputChange$ O O $any$ O $NestedInputInfoClick$ O O $any$ O O O $ObjectFields<Select>$ $ObjectFields$ O $any$ O O O $ObjectConstructor$ O O O O O $ObjectFields<Select>$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O $NestedInputHidden$ O O $any$ O $boolean$ O O O O $string$ O O O O $NestedInputValidator$ O O $any$ O $NestedInputChange$ O O $any$ O $NestedInputInfoClick$ O O $any$ O $string$ O O O $string$ O $string$ O O O O O O $ObjectFields<Input>$ $ObjectFields$ O $any$ O O O $ObjectConstructor$ O O O O O $ObjectFields<Input>$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O $boolean$ O O O O $NestedInputHidden$ O O $any$ O $boolean$ O O O O $string$ O O O O $string$ O O O O $NestedInputValidator$ O O $any$ O $NestedInputChange$ O O $any$ O $NestedInputInfoClick$ O O $any$ O O O $ObjectFields<Path>$ $ObjectFields$ O $any$ O O O $ObjectConstructor$ O O O O O $ObjectFields<Path>$ O O O O O O O $any$ O $string$ O O O O $boolean$ O O O O $string$ O O O O $boolean$ O O O O $NestedInputHidden$ O O $any$ O $NestedInputValidator$ O O $any$ O $NestedInputChange$ O O $any$ O $NestedInputInfoClick$ O O $any$ O O O $ObjectFields<Toggle>$ $ObjectFields$ O $any$ O O O $ObjectConstructor$ O O O O O $ObjectFields<Toggle>$ O O O O O O O $any$ O $string$ O O O O $NestedInputInfoClick$ O O $any$ O $NestedInputHidden$ O O $any$ O $complex$ O O O O $string$ O O $any$ O O O O $ObjectFields<Group>$ $ObjectFields$ O $any$ O O O $ObjectConstructor$ O O O O O $ObjectFields<Group>$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O
import { languageStruct } from "s" ; export interface GlobalContainer { lang : languageStruct , version : number , os : string , arch : string } ;	O O $any$ O O O O O O $any$ O $languageStruct$ O $any$ O $number$ O O O $string$ O O O $string$ O O O O
import * as _Bluebird from 's' ; export interface xRequestOptions { method : 's' , timeout : number , params ? : String | Object , responseType ? : XMLHttpRequestResponseType , headers ? : Object } export interface xRequestOptionsWithUrl extends xRequestOptions { url : string } export interface xRequestError { config : xRequestOptionsWithUrl , response ? : xRequestResponse , error : { status : number , statusText : string , url : string , headers : { } } } export type xRequestResponse = any ; export type xRequestResolve = xRequestResponse | null ; export type xRequestReject = xRequestError | any ;	O O O $any$ O O O O O $any$ O O O O O $number$ O O O $complex$ O O $StringConstructor$ O $ObjectConstructor$ O $XMLHttpRequestResponseType$ O O $any$ O $Object$ O O $ObjectConstructor$ O O O $any$ O $any$ O $string$ O O O O O $any$ O $xRequestOptionsWithUrl$ O $any$ O $any$ O O $any$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O ${}$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O
export interface CustomVariables { [ group ] : { [ variable ] : string } }	O O $any$ O O $string$ O O O O $string$ O O O O O
import { UserConfiguration } from "s" ; export interface ConfigPresets { [ key ] : UserConfiguration }	O O $any$ O O O O O O $any$ O O $string$ O O $any$ O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { languageContainer } from "s" ; export const EnglishLang = { 's' : { about : { component : { info__md : [ require ( 's' ) ] } } , preview : { component : { filter : 's' , by : 's' , refreshImages : 's' , addLocalImages : 's' , retryDownload : 's' , generateAppList : 's' , saveAppList : 's' , removeAppList : 's' , remainingImages : 's' , stopUrlRetrieving : 's' } , service : { info : { listIsBeingGenerated : 's' , listIsBeingSaved : 's' , listIsBeingRemoved : 's' , listIsEmpty : 's' , populatingVDF_List : 's' , creatingBackups : 's' , readingVDF_Files : 's' , mergingVDF_entries : 's' , removingVDF_entries : 's' , writingVDF_entries : 's' , updatingKnownSteamDirList : 's' , retryingDownload__i : 's' , disabledConfigurations__i : 's' , invalidConfigurations__i : 's' , executingParsers : 's' , shutdownSteam : 's' , noParserConfigurations : 's' , parserFoundNoFiles : 's' , allImagesRetrieved : 's' , providerTimeout__i : 's' , noAccountsWarning : 's' } , errors : { populatingVDF_entries : 's' , savingVDF_entries : 's' , fatalError : 's' , knownSteamDirListIsEmpty : 's' , retryingDownload__i : 's' , providerError__i : 's' , unknownProviderError__i : 's' } , success : { writingVDF_entries : 's' , removingVDF_entries : 's' , } } } , globParser : { inputTitle : 's' , docs__md : { self : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , ] , input : [ require ( 's' ) , require ( 's' ) ] } , errors : { noTitle__md : 's' , moreThanOneTitle__md : 's' , noStarNextToTitle__md : 's' , noAnyCharNextToTitle__md : 's' , noWindowsSlash__md : 's' , noGlobstarOnBothSides__md : 's' , noBracedDirSetOnBothSides__md : 's' , noBracedDirSetOrGlobstarOnBothSides__md : 's' , noEmptyPattern__md : 's' , noEmptyCharRange__md : 's' , noStarInPatternNextToTitle__md : 's' , noAnyCharInPatternNextToTitle__md : 's' } } , globRegexParser : { inputTitle : 's' , docs__md : { self : [ require ( 's' ) , require ( 's' ) , require ( 's' ) ] , input : [ require ( 's' ) , require ( 's' ) ] } , errors : { noRegex__md : 's' , moreThanOneRegex__md : 's' , noStarNextToRegex__md : 's' , noAnyCharNextToRegex__md : 's' , noWindowsSlash__md : 's' , noGlobstarOnBothSides__md : 's' , noBracedDirSetOnBothSides__md : 's' , noBracedDirSetOrGlobstarOnBothSides__md : 's' , noEmptyPattern__md : 's' , noEmptyCharRange__md : 's' , noStarInPatternNextToRegex__md : 's' , noAnyCharInPatternNextToRegex__md : 's' } } , logger : { component : { noMessages : 's' , error : 's' , info : 's' , success : 's' , fuzzy : 's' , textWrap : 's' , autoscroll : 's' , clearLog : 's' } } , customVariables : { service : { error : { failedToDownload__i : 's' , writingError : 's' , loadingError : 's' , corruptedVariables__i : 's' , } , info : { downloaded : 's' } } } , configPresets : { service : { error : { failedToDownload__i : 's' , writingError : 's' , loadingError : 's' , corruptedVariables__i : 's' , } , info : { downloaded : 's' } } } , settings : { component : { label : { general : 's' , imageProviders : 's' , fuzzy : 's' } , text : { offlineMode : 's' , removeApps_desc : 's' , removeApps_btn : 's' , preloadImages : 's' , fuzzy_verbose : 's' , fuzzy_filter : 's' , enabledProviders : 's' , selectLanguage : 's' , resetFuzzy_desc : 's' , resetFuzzy_btn : 's' , showSteamImages : 's' , clearLogOnTest : 's' } , placeholder : { noProviders : 's' } } , service : { error : { writingError : 's' , readingError : 's' , corruptedSettings__i : 's' , } } } , nav : { component : { about : 's' , preview : 's' , logger : 's' , settings : 's' , parsers : 's' , noTitle : 's' } } , parsers : { component : { buttons : { save : 's' , copy : 's' , testParser : 's' , delete : 's' , moveUp : 's' , moveDown : 's' , faq : 's' , undoChanges : 's' , undoDelete : 's' , toClipboard : 's' } , docs__md : { intro : [ require ( 's' ) ] , faq : [ require ( 's' ) ] , parserType : [ require ( 's' ) ] , configTitle : [ require ( 's' ) ] , steamCategory : [ require ( 's' ) , require ( 's' ) ] , executableLocation : [ require ( 's' ) ] , romDirectory : [ require ( 's' ) ] , steamDirectory : [ require ( 's' ) ] , startInDirectory : [ require ( 's' ) ] , userAccounts : [ require ( 's' ) ] , titleModifier : [ require ( 's' ) , require ( 's' ) , require ( 's' ) ] , executableModifier : [ require ( 's' ) , require ( 's' ) , require ( 's' ) ] , titleFromVariable : [ require ( 's' ) ] , fuzzyMatch : [ require ( 's' ) ] , executableArgs : [ require ( 's' ) , require ( 's' ) , require ( 's' ) ] , onlineImageQueries : [ require ( 's' ) , require ( 's' ) ] , imageProviders : [ require ( 's' ) ] , imagePool : [ require ( 's' ) , ] , defaultImage : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , localImages : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , localIcons : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] } , info : { testStarting__i : 's' , testCompleted : 's' , nothingWasFound : 's' , copiedToClipboard : 's' , } , error : { missingAccounts__i : 's' , missingAccountInfo__i : 's' , noAccountsWarning : 's' , failedToMatch : 's' , failedFileInfo__i : 's' , testFailed : 's' , cannotTestInvalid : 's' , cannotCopyInvalid : 's' , failedToCopy : 's' } , success : { foundAccounts__i : 's' , foundAccountInfo__i : 's' , steamCategory__i : 's' , steamCategoryInfo__i : 's' , extractedTitle__i : 's' , fuzzyTitle__i : 's' , finalTitle__i : 's' , filePath__i : 's' , completeShortcut__i : 's' , firstImageQuery__i : 's' , imageQueries__i : 's' , resolvedDefaultImageGlob__i : 's' , resolvedDefaultImageGlobInfo__i : 's' , defaultImageResolved__i : 's' , resolvedImageGlob__i : 's' , resolvedImageGlobInfo__i : 's' , localImagesResolved__i : 's' , localImageInfo__i : 's' , resolvedIconGlob__i : 's' , resolvedIconGlobInfo__i : 's' , localIconsResolved__i : 's' , localIconInfo__i : 's' } , label : { parserType : 's' , configTitle : 's' , steamCategory : 's' , executableModifier : 's' , executableLocation : 's' , romDirectory : 's' , steamDirectory : 's' , startInDirectory : 's' , userAccounts : 's' , titleFromVariable : 's' , titleModifier : 's' , fuzzyMatch : 's' , executableArgs : 's' , onlineImageQueries : 's' , imagePool : 's' , imageProviders : 's' , defaultImage : 's' , localImages : 's' , localIcons : 's' } , placeholder : { parserType : 's' , imageProviders : 's' } , text : { skipWithMissingDataDir : 's' , useCredentials : 's' , tryToMatchTitle : 's' , skipFileIfVariableWasNotFound : 's' , caseInsensitiveVariables : 's' , fuzzy_use : 's' , fuzzy_removeCharacters : 's' , fuzzy_removeBrackets : 's' , fuzzy_replaceDiacritic : 's' , appendArgsToExecutable : 's' , disabled : 's' , advanced : 's' , noTitle : 's' } } , service : { error : { savingConfiguration : 's' , readingConfiguration : 's' , corruptedConfiguration__i : 's' , } , validationErrors : { parserType__md : 's' , configTitle__md : 's' , parserInput : { noInput : 's' , inputNotAvailable__i : 's' , incorrectParser : 's' , } , romDir__md : 's' , steamDir__md : 's' , startInDir__md : 's' , executable__md : 's' , imagePool__md : 's' , titleModifier__md : 's' , executableModifier__md : 's' , variableString__md : 's' , imageProviders__md : 's' , unhandledValidationKey__md : 's' } , text : { noTitle : 's' } } } , fuzzyMatcher : { info : { downloading : 's' , successfulDownload : 's' , checkingIfListIsUpToDate : 's' , listIsOutdated : 's' , listIsUpToDate : 's' , match__i : 's' , equal__i : 's' , notEqual__i : 's' } , error : { fatalError : 's' , totalGamesIsUndefined : 's' } } , fileParser : { error : { parserNotFound__i : 's' , tooManyFieldGlobs__md : 's' , parserIsRequired__md : 's' , noWinSlashes__md : 's' } } , imageProvider : { error : { webWorkerError__i : 's' , unknownWebWorkerError : 's' , } } , vdfManager : { error : { noUsersFound : 's' , emptyDirectoryList : 's' , couldNotMergeEntries__i : 's' , couldNotRemoveEntries__i : 's' } } , vdfFile : { error : { readingVdf__i : 's' , writingVdf__i : 's' , corruptedVdf__i : 's' , creatingBackup__i : 's' , unsupportedMimeType__i : 's' , imageError__i : 's' } } , helpers : { error : { noUserIdsInDir__i : 's' } } } }	O O $any$ O O O O O O $languageContainer$ O O O O O $complex$ O O $complex$ O O $any[]$ O O $any$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O O $any[]$ O O $any$ O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $string$ O O O O O O
const diacriticList = require ( 's' ) ; declare global { interface String { replaceDiacritics ( ) : string ; } } String . prototype . replaceDiacritics = function ( ) { return ( this as String ) . replace ( "s" , function ( char ) { return diacriticList [ char ] || char ; } ) ; } export default undefined ;	O $any$ O $any$ O O O O O $any$ O O $StringConstructor$ O $string$ O O O O O O O $StringConstructor$ O $String$ O $string$ O O O O O O O O O $StringConstructor$ O O $complex$ O O O O O $string$ O O O $any$ O $string$ O O $string$ O O O O O O O $undefined$ O
import 's' ; import { FuzzyMatcher } from "s" ; import { FuzzyEventMap , ProviderPostEventMap , ProviderPostObject , ProviderReceiveEventMap , ImageContent } from "s" ; declare var self ; export abstract class GenericProvider { constructor ( protected proxy ) { } abstract retrieveUrls ( ) ; abstract stopUrlDownload ( ) ; } export class GenericProviderManager < T extends GenericProvider > { private listening : boolean = false ; private _filterIsEnabled : boolean = false ; private _fuzzyMatcher = new FuzzyMatcher ( this . fuzzyCallback . bind ( this ) ) ; private instanceMap = new Map < string , T > ( ) ; private isTimedOut : boolean = false ; constructor ( private provider : new ( proxy ) => T , private _providerName ) { if ( ! this . listening ) { self . addEventListener ( 's' , this . onMessage . bind ( this ) ) ; this . listening = true ; } } get filterIsEnabled ( ) { return this . _filterIsEnabled ; } get fuzzyMatcher ( ) { return this . _fuzzyMatcher ; } get providerName ( ) { return this . _providerName ; } get timedOut ( ) { return this . isTimedOut ; } timeout ( timeInMs ) { if ( ! this . isTimedOut ) { this . isTimedOut = true ; setTimeout ( ( ) => { this . isTimedOut = false ; } , timeInMs ) ; } } postMessage < K extends keyof ProviderPostEventMap > ( event : K , data : ProviderPostEventMap [ K ] ) { self . postMessage ( < ProviderPostObject < K > > { event : event , data : data } ) ; } newInstance ( id , title ) { return this . instanceMap . set ( id , new this . provider ( new ProviderProxy ( id , title , this ) ) ) ; } removeInstance ( id ) { return this . instanceMap . delete ( id ) ; } private onMessage ( event ) { if ( event . data && event . data . event ) { switch ( ( event . data . event as keyof ProviderReceiveEventMap ) ) { case 's' : this . _fuzzyMatcher . setFuzzyList ( ( event . data . data as ProviderReceiveEventMap [ 's' ] ) . list || null ) ; break ; case 's' : { let data = ( event . data . data as ProviderReceiveEventMap [ 's' ] ) ; this . newInstance ( data . id , data . title ) . get ( data . id ) . retrieveUrls ( ) ; } break ; case 's' : { let data = ( event . data . data as ProviderReceiveEventMap [ 's' ] ) ; for ( let value of this . instanceMap . values ( ) ) { value . stopUrlDownload ( ) ; } } break ; case 's' : this . _filterIsEnabled = ( event . data . data as ProviderReceiveEventMap [ 's' ] ) . enable ; break ; default : break ; } } } private fuzzyCallback < K extends keyof FuzzyEventMap > ( event : K , data : FuzzyEventMap [ K ] ) { this . postMessage ( 's' , { event : event , data : data } ) ; } } ; export class ProviderProxy { constructor ( private _id , private _title , private _manager < GenericProvider > ) { } get title ( ) { return this . _title ; } get filter ( ) { return this . _manager . filterIsEnabled ; } get fuzzyMatcher ( ) { return this . _manager . fuzzyMatcher ; } get providerName ( ) { return this . _manager . providerName ; } timeout ( timeInSeconds ) { if ( ! this . _manager . timedOut ) { this . _manager . timeout ( timeInSeconds * 0 ) ; this . _manager . postMessage ( 's' , { provider : this . providerName as ImageContent [ "s" ] , time : timeInSeconds , id : this . _id } ) ; } } error ( error : number | string , url ? ) { this . _manager . postMessage ( 's' , { error : error , title : this . _title , provider : this . providerName as ImageContent [ "s" ] , id : this . _id , url : url } ) ; } image ( content ) { this . _manager . postMessage ( 's' , { content : content , id : this . _id } ) ; } completed ( ) { this . _manager . postMessage ( 's' , { title : this . _title , id : this . _id } ) ; this . _manager . removeInstance ( this . _id ) ; } } ;	O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Worker$ O O O O $any$ O O O O $ProviderProxy$ O O O O $void$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $boolean$ O O O O O O $FuzzyMatcher$ O O $any$ O O O $void$ O $any$ O O O O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O O $boolean$ O O O O O O O O $T$ O O O $ProviderProxy$ O O $any$ O O $string$ O O O O O O O $boolean$ O O $Worker$ O $complex$ O O O O O $void$ O $any$ O O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O $FuzzyMatcher$ O O O O O O $FuzzyMatcher$ O O O $string$ O O O O O O $string$ O O O $boolean$ O O O O O O $boolean$ O O $void$ O $number$ O O O O O O O $boolean$ O O O O $boolean$ O O O $number$ O O O O O O O $boolean$ O O O O O $number$ O O O O $void$ O $any$ O O $any$ O O $K$ O $any$ O $ProviderPostEventMap[K]$ O $any$ O $any$ O O O $Worker$ O $complex$ O O $any$ O $any$ O O O $K$ O $K$ O $ProviderPostEventMap[K]$ O $ProviderPostEventMap[K]$ O O O O $any$ O $string$ O $string$ O O O O O $complex$ O $complex$ O $string$ O O O O $T$ O O $any$ O $string$ O $string$ O O O O O O O $boolean$ O $string$ O O O O O $complex$ O $boolean$ O $string$ O O O O $void$ O $MessageEvent$ O O O O $MessageEvent$ O $any$ O $MessageEvent$ O $any$ O $any$ O O O O O $MessageEvent$ O $any$ O $any$ O O $any$ O O O O O O O O $FuzzyMatcher$ O $void$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O $complex$ O O O O O O O O O O O $ProviderRetrieveData$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $ProviderRetrieveData$ O $string$ O $ProviderRetrieveData$ O $string$ O O $any$ O $ProviderRetrieveData$ O $string$ O O $any$ O O O O O O O O O O O $null$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O O O O $T$ O O O $complex$ O $IterableIterator<T>$ O O O O $T$ O $void$ O O O O O O O O O O O O $boolean$ O O $MessageEvent$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O O O O O O O O O $void$ O $any$ O O $any$ O O $K$ O $any$ O $FuzzyEventMap[K]$ O $any$ O $any$ O O O O O $void$ O O O O $K$ O $K$ O $FuzzyEventMap[K]$ O $FuzzyEventMap[K]$ O O O O O O O O $any$ O O O O $string$ O O $string$ O O $GenericProviderManager$ O $any$ O O O O O $string$ O O O O O O $string$ O O O $boolean$ O O O O O O $GenericProviderManager<GenericProvider>$ O $boolean$ O O O $FuzzyMatcher$ O O O O O O $GenericProviderManager<GenericProvider>$ O $FuzzyMatcher$ O O O $string$ O O O O O O $GenericProviderManager<GenericProvider>$ O $string$ O O $void$ O $number$ O O O O O O O $GenericProviderManager<GenericProvider>$ O $boolean$ O O O O $GenericProviderManager<GenericProvider>$ O $void$ O $number$ O O O O O O $GenericProviderManager<GenericProvider>$ O $void$ O O O O O O O O $string$ O $any$ O O O O $number$ O $number$ O $string$ O O O $string$ O O O O O $void$ O $complex$ O O O O O $string$ $string$ O O O O $GenericProviderManager<GenericProvider>$ O $void$ O O O O $complex$ O $complex$ O $string$ O O O $string$ O O O O O $string$ O $any$ O O O O $string$ O O O $string$ O $string$ O $string$ O O O O $void$ O $ImageContent$ O O O O $GenericProviderManager<GenericProvider>$ O $void$ O O O O $ImageContent$ O $ImageContent$ O $string$ O O O $string$ O O O O $void$ O O O O O $GenericProviderManager<GenericProvider>$ O $void$ O O O O $string$ O O O $string$ O $string$ O O O $string$ O O O O O $GenericProviderManager<GenericProvider>$ O $boolean$ O O O $string$ O O O O O
import { GenericProvider , ProviderProxy } from "s" ; import { xRequestError } from "s" ; import { xRequest } from "s" ; import * as Bluebird from 's' ; export class xRequestWrapper extends xRequest { private specialErrors : { [ statusCode ] : { retryCount ? : number , silent : boolean } } = { } ; constructor ( private proxy , private handleErrors , private retryCount , timeout ) { super ( undefined , timeout ) ; } private canRetry ( status , config ) { let retryCount = this . specialErrors [ `template` ] ? this . specialErrors [ `template` ] . retryCount || this . retryCount : this . retryCount ; if ( retryCount > 0 ) { if ( config [ 's' ] === undefined ) { config [ 's' ] = 0 ; return true ; } else return ( config [ 's' ] ++ < retryCount ) ; } else return false ; } private errorHandler ( promise < any > ) < any > { if ( this . handleErrors ) { return promise . catch ( ( data ) => { if ( data . error ) { if ( data . error . status === 0 ) { let timeout = data . error . headers [ 's' ] || 0 ; this . proxy . timeout ( timeout ) ; return this . errorHandler ( this . makeRequest ( data . config , timeout * 0 ) ) ; } else if ( this . canRetry ( data . error . status , data . config ) ) return this . errorHandler ( this . makeRequest ( data . config , 0 ) ) ; else { if ( this . specialErrors [ `template` ] === undefined || ! this . specialErrors [ `template` ] . silent ) this . logError ( data . error . status , data . error . url ) ; return this . Bluebird . resolve ( null ) ; } } else return this . Bluebird . reject ( data ) ; } ) ; } else return promise ; } setSpecialErrors ( specialErrors : { [ statusCode ] : { retryCount ? : number , silent : boolean } } ) { this . specialErrors = specialErrors ; } get ( url , params ? : { [ parameter ] : string } , responseType = 's' , delay = 0 ) { return this . errorHandler ( super . request ( url , { method : 's' , timeout : this . timeout , responseType , params } , delay ) ) ; } logError ( value , url ? ) { if ( value . error ) this . logError ( value . error , url ) ; else this . proxy . error ( typeof value === 's' ? value . status || JSON . stringify ( value ) : value , url ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O $complex$ O O O $string$ O O O $number$ O O O O $boolean$ O O O O O O O O O O O $ProviderProxy$ O O $boolean$ O O $number$ O $number$ O O O O $undefined$ O $number$ O O O O $boolean$ O $number$ O $any$ O O O $number$ O O O $complex$ O O O O O O $complex$ O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O O O O $undefined$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O $number$ O O O O O O O O O $Bluebird$ O $Bluebird$ O O O O O O O O O O O O $boolean$ O O O $any$ O $any$ O O $xRequestError$ O O O O O $xRequestError$ O $complex$ O O O O $xRequestError$ O $complex$ O $number$ O O O O O $any$ O $xRequestError$ O $complex$ O ${}$ O O O O O O O O $ProviderProxy$ O $void$ O $any$ O O O O O $any$ O O O $any$ O $xRequestError$ O $xRequestOptionsWithUrl$ O $any$ O O O O O O O O O O O $boolean$ O $xRequestError$ O $complex$ O $number$ O $xRequestError$ O $xRequestOptionsWithUrl$ O O O O O $any$ O O O $any$ O $xRequestError$ O $xRequestOptionsWithUrl$ O O O O O O O O O O O $complex$ O O O O $undefined$ O O O O $complex$ O O O O $boolean$ O O O $void$ O $xRequestError$ O $complex$ O $number$ O $xRequestError$ O $complex$ O $string$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $xRequestError$ O O O O O O O O $any$ O O $void$ O $complex$ O O O $string$ O O O $number$ O O O O $boolean$ O O O O O O O O $complex$ O $complex$ O O $any$ O $string$ O $complex$ O O O O $string$ O O O O O $XMLHttpRequestResponseType$ O O O $number$ O O O O O O O $any$ O O O $any$ O $string$ O O O O O O $number$ O O O $number$ O $XMLHttpRequestResponseType$ O $complex$ O O $number$ O O O O $void$ O $any$ O $string$ $string$ O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $string$ O O O O O $ProviderProxy$ O $void$ O O $any$ O O O $any$ O $any$ O $JSON$ O $complex$ O $any$ O O $any$ O $string$ O O O O
import { GenericProvider , GenericProviderManager , ProviderProxy } from "s" ; import { xRequestWrapper } from "s" ; import * as Bluebird from 's' ; class RetrogamingCloudProvider extends GenericProvider { private xrw : xRequestWrapper ; constructor ( protected proxy ) { super ( proxy ) ; this . xrw = new xRequestWrapper ( proxy , true , 0 , 0 ) ; } retrieveUrls ( ) { this . retrieveImageList ( ) . then ( ( listData ) => { if ( listData . length > 0 ) { this . xrw . setSpecialErrors ( { 0 : { retryCount : 0 , silent : true } } ) ; let promises : Bluebird < void > [ ] = [ ] ; for ( let i = 0 ; i < listData . length ; i ++ ) { if ( this . proxy . filter && listData [ i ] . name && ! this . proxy . fuzzyMatcher . fuzzyEqual ( this . proxy . title , listData [ i ] . name , { removeBrackets : true , removeCharacters : true , replaceDiacritics : true } ) ) continue ; else { if ( listData [ i ] . id !== undefined ) promises . push ( this . retrieveMediaData ( listData [ i ] . id ) ) ; if ( listData [ i ] . most_popular_media_url && ( listData [ i ] . most_popular_media_url as string ) . length > 0 ) { this . proxy . image ( { imageProvider : 's' , imageUrl : listData [ i ] . most_popular_media_url , imageUploader : listData [ i ] . most_popular_media_created_by_name || undefined , loadStatus : 's' } ) ; } } } return this . xrw . Bluebird . all ( promises ) ; } } ) . finally ( ( ) => { this . proxy . completed ( ) ; } ) ; } stopUrlDownload ( ) { this . xrw . cancel ( ) ; } private retrieveImageList ( ) { return this . xrw . addPromise ( this . xrw . get ( 's' , { name : `template` } ) . then ( ( response ) => { return response != null ? ( response . results || [ ] ) : [ ] ; } ) ) ; } private retrieveMediaData ( gameId ) { return this . xrw . addPromise ( this . xrw . get ( `template` ) . then ( ( response ) => { if ( response !== null ) { let results = response . results || [ ] ; for ( let i = 0 ; i < results . length ; i ++ ) { if ( results [ i ] . url ) { this . proxy . image ( { imageProvider : 's' , imageUrl : results [ i ] . url , imageUploader : results [ i ] . created_by ? results [ i ] . created_by . name : undefined , loadStatus : 's' } ) ; } } } } ) . catch ( ( error ) => { this . xrw . logError ( error ) ; } ) . finally ( ( ) => { return this . xrw . Bluebird . resolve ( ) ; } ) ) ; } } new GenericProviderManager ( RetrogamingCloudProvider , 's' ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O $xRequestWrapper$ O $any$ O O O O $ProviderProxy$ O O O O $ProviderProxy$ O O O O $xRequestWrapper$ O O $any$ O $ProviderProxy$ O O O O O O O O O $void$ O O O O O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $xRequestWrapper$ O $void$ O O O O O $number$ O O O $true$ O O O O O O O $any[]$ O $any$ O O O O O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O O O $ProviderProxy$ O $boolean$ O $any$ O $number$ O O $any$ O O O O $ProviderProxy$ O $FuzzyMatcher$ O $boolean$ O O O $ProviderProxy$ O $string$ O $any$ O $number$ O O $any$ O O $true$ O O O $true$ O O O $true$ O O O O O O O O O O O $any$ O $number$ O O $any$ O $undefined$ O $any[]$ O $number$ O O O $any$ O $any$ O $number$ O O $any$ O O O O O $any$ O $number$ O O $any$ O O $any$ O $number$ O O $any$ O O O O $number$ O O O O O O $ProviderProxy$ O $void$ O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O $any$ O $number$ O O $any$ O $undefined$ O O O O O O O O O O O O O $xRequestWrapper$ O $any$ O $any$ O $any[]$ O O O O O O $any$ O O O O O O O $ProviderProxy$ O $void$ O O O O O O O $void$ O O O O O $xRequestWrapper$ O $void$ O O O O O $any$ O O O O O O $xRequestWrapper$ O $any$ O O O $xRequestWrapper$ O $any$ O O O O $string$ O O O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $number$ O O O O O $xRequestWrapper$ O $any$ O O O $xRequestWrapper$ O $any$ O O O O $any$ O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O O O O $ProviderProxy$ O $void$ O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O $any$ O $any$ O $undefined$ O O O O O O O O O O O O O $any$ O O $any$ O O O O O $xRequestWrapper$ O $void$ O $any$ O O O O O $any$ O O O O O O O O $xRequestWrapper$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O
import { GenericProvider , GenericProviderManager , ProviderProxy } from "s" ; import { xRequestWrapper } from "s" ; class SteamGridDbProvider extends GenericProvider { private xrw : xRequestWrapper ; constructor ( protected proxy ) { super ( proxy ) ; this . xrw = new xRequestWrapper ( proxy , true , 0 , 0 ) ; } retrieveUrls ( ) { this . xrw . promise = this . xrw . get ( 's' , { game : this . proxy . title , fields : [ 's' , 's' ] . toString ( ) } ) . then ( ( response ) => { if ( response !== null && response [ 's' ] !== undefined ) { for ( let i = 0 ; i < response [ 's' ] . length ; i ++ ) { this . proxy . image ( { imageProvider : 's' , imageUrl : response [ 's' ] [ i ] . grid_url , imageUploader : response [ 's' ] [ i ] . author , loadStatus : 's' } ) ; } } } ) . catch ( ( error ) => { this . xrw . logError ( error ) ; } ) . finally ( ( ) => { this . proxy . completed ( ) ; } ) ; } stopUrlDownload ( ) { this . xrw . cancel ( ) ; } } new GenericProviderManager ( SteamGridDbProvider , 's' ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O $xRequestWrapper$ O $any$ O O O O $ProviderProxy$ O O O O $ProviderProxy$ O O O O $xRequestWrapper$ O O $any$ O $ProviderProxy$ O O O O O O O O O $void$ O O O O O $xRequestWrapper$ O $any$ O O O $xRequestWrapper$ O $any$ O O O O $string$ O O O $ProviderProxy$ O $string$ O $string$ O O O O O O O $string$ O O O O O $any$ O O $any$ O O O O O $any$ O O O $any$ O O O O $undefined$ O O O O O $number$ O O O $number$ O $any$ O O O O $any$ O $number$ O O O O O $ProviderProxy$ O $void$ O O O O O O $any$ O $any$ O O O O $number$ O O $any$ O $any$ O $any$ O O O O $number$ O O $any$ O O O O O O O O O O O O $any$ O O $any$ O O O O O $xRequestWrapper$ O $void$ O $any$ O O O O O $any$ O O O O O O O $ProviderProxy$ O $void$ O O O O O O O $void$ O O O O O $xRequestWrapper$ O $void$ O O O O O O $any$ O $any$ O O O O
import * as _ from "s" ; declare global { interface String { interpolate ( params : { [ key ] : any } ) : string ; } } String . prototype . interpolate = function ( params ) { const names = _ . keys ( params ) ; const vals = _ . values ( params ) ; return new Function ( ... names , `template` ) ( ... vals ) ; }	O O O $any$ O O O O $any$ O O $StringConstructor$ O $string$ O $complex$ O O O $string$ O O O O O O O O O O $StringConstructor$ O $String$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $FunctionConstructor$ O O $any$ O O O O O $any$ O O O
import { app , BrowserWindow , shell } from 's' ; import * as paths from "s" ; import * as path from 's' ; import * as url from 's' ; import * as fs from 's' ; const windowStateKeeper = require ( 's' ) ; let mainWindow : Electron . BrowserWindow = null ; function createWindow ( ) { let mainWindowState = windowStateKeeper ( { defaultWidth : 0 , defaultHeight : 0 , maximize : false , path : paths . userDataDir } ) ; mainWindow = new BrowserWindow ( { x : mainWindowState . x , y : mainWindowState . y , width : mainWindowState . width < 0 ? 0 : mainWindowState . width , height : mainWindowState . height , minWidth : 0 , minHeight : 0 , frame : false , backgroundColor : 's' , webPreferences : { devTools : process . env . NODE_ENV !== 's' , nodeIntegrationInWorker : false } } ) ; mainWindowState . manage ( mainWindow ) ; mainWindow . loadURL ( url . format ( { pathname : path . join ( __dirname , 's' , 's' ) , protocol : 's' , slashes : true } ) ) ; mainWindow . on ( 's' , ( ) => { mainWindow = null } ) ; mainWindow . webContents . on ( 's' , ( event , url ) => { event . preventDefault ( ) ; shell . openExternal ( url ) ; } ) ; mainWindow . show ( ) ; } app . on ( 's' , createWindow ) ; app . on ( 's' , ( ) => { if ( process . platform !== 's' ) { app . quit ( ) } } ) ; app . on ( 's' , ( ) => { if ( mainWindow === null ) { createWindow ( ) ; } } ) ;	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O $any$ O $any$ O O $number$ O O O $number$ O O O $boolean$ O O O $string$ O $any$ O $string$ O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O $number$ O O O $boolean$ O O O $string$ O O O $complex$ O O $boolean$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $void$ O O O O O O O
import { Component , ChangeDetectionStrategy , ChangeDetectorRef , OnDestroy } from 's' ; import { SettingsService , LanguageService , MarkdownService } from "s" ; import { MarkdownVariable } from 's' ; import { Router } from "s" ; import * as highlight from 's' ; import * as markdownIt from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class AppComponent { private settingsLoaded : boolean = false ; private languageLoaded : boolean = false ; constructor ( private settingsService , private languageService , private markdownService , private router , private changeDetectionRef ) { this . settingsService . onLoad ( ( appSettings ) => { this . settingsLoaded = true ; this . router . navigate ( [ 's' , - 0 ] ) ; this . changeDetectionRef . detectChanges ( ) ; } ) ; this . languageService . observeChanges ( ) . subscribe ( ( lang ) => { if ( lang !== null ) { this . languageLoaded = true ; } } ) ; this . markdownService . createInstance ( 's' , new markdownIt ( { html : true , typographer : true , highlight : function ( str , lang ) { if ( lang && highlight . getLanguage ( lang ) ) { try { return highlight . highlight ( lang , str ) . value ; } catch ( __ ) { } } return 's' ; } } ) . use ( MarkdownVariable ) . use ( require ( 's' ) ) . use ( require ( 's' ) ) ) ; } ; }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O O O O $SettingsService$ O O $LanguageService$ O O $MarkdownService$ O O $Router$ O O $ChangeDetectorRef$ O O O O $SettingsService$ O $void$ O O $AppSettings$ O O O O O $boolean$ O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $LanguageService$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O O O O O O $boolean$ O O O O O O O O O $MarkdownService$ O $any$ O O O O $any$ O O $boolean$ O O O $boolean$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import { Component , ChangeDetectionStrategy , ChangeDetectorRef , OnDestroy , 0 , ElementRef , 0 , HostListener } from 's' ; import { Subscription } from 's' ; import { PreviewService , SettingsService , ImageProviderService } from "s" ; import { PreviewData , PreviewDataApp , PreviewVariables , AppSettings , ImageContent } from "s" ; import { APP } from 's' ; import { FileSelector } from 's' ; import * as url from 's' ; import * as appImage from 's' ; import * as _ from 's' ; import * as path from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class PreviewComponent implements OnDestroy { private previewData : PreviewData ; private appSettings : AppSettings ; private subscriptions : Subscription = new Subscription ( ) ; private previewVariables : PreviewVariables ; private filterValue : string = 's' ; private scrollingEntries : boolean = false ; private fileSelector : FileSelector = new FileSelector ( ) ; constructor ( private previewService , private settingsService , private imageProviderService , private changeDetectionRef , private renderer , private elementRef ) { this . previewData = this . previewService . getPreviewData ( ) ; this . previewVariables = this . previewService . getPreviewVariables ( ) ; this . subscriptions . add ( this . previewService . getPreviewDataChange ( ) . subscribe ( _ . debounce ( ( ) => { this . previewData = this . previewService . getPreviewData ( ) ; this . changeDetectionRef . detectChanges ( ) ; } , 0 ) ) ) ; this . appSettings = this . settingsService . getSettings ( ) ; } generatePreviewData ( ) { this . previewService . generatePreviewData ( ) ; } preloadImages ( ) { this . previewService . preloadImages ( ) ; } ngAfterContentInit ( ) { this . setImageSize ( this . appSettings . previewSettings . imageZoomPercentage ) ; } ngOnDestroy ( ) { this . subscriptions . unsubscribe ( ) ; } private getImagePool ( poolKey ) { return this . previewService . images [ poolKey ] ; } private getBackgroundImage ( app ) { return this . previewService . getCurrentImage ( app ) ; } private setBackgroundImage ( app , image ) { if ( image == undefined ) { if ( this . previewService . images [ app . images . imagePool ] . retrieving ) return require ( 's' ) ; else return require ( 's' ) ; } else { if ( image . loadStatus === 's' ) { this . loadImage ( app ) ; return require ( 's' ) ; } else if ( image . loadStatus === 's' ) return require ( 's' ) ; else if ( image . loadStatus === 's' ) return image . imageUrl ; else return require ( 's' ) ; } } private loadImage ( app ) { this . previewService . loadImage ( app ) ; } private areImagesAvailable ( app ) { return this . previewService . areImagesAvailable ( app ) ; } private currentImageIndex ( app ) { return app . images . imageIndex + 0 ; } private maxImageIndex ( app ) { return this . previewService . getTotalLengthOfImages ( app ) ; } private addLocalImages ( app ) { this . fileSelector . multiple = true ; this . fileSelector . accept = 's' ; this . fileSelector . onChange = ( target ) => { if ( target . files ) { let extRegex = "s" ; for ( let i = 0 ; i < target . files . length ; i ++ ) { if ( extRegex . test ( path . extname ( target . files [ i ] . path ) ) ) { let imageUrl = url . encodeFile ( target . files [ i ] . path ) ; this . previewService . addUniqueImage ( app . images . imagePool , { imageProvider : 's' , imageUrl , loadStatus : 's' } ) ; } } } } ; this . fileSelector . trigger ( ) ; } private get lang ( ) { return APP . lang . preview . component ; } private stopImageRetrieving ( ) { this . imageProviderService . instance . stopUrlDownload ( ) ; } private setFallbackIcon ( imageElement ) { imageElement . src = require ( 's' ) ; } private save ( ) { this . previewService . saveData ( false ) ; } private remove ( ) { for ( const directory in this . previewData ) { for ( const userId in this . previewData [ directory ] ) { for ( const appId in this . previewData [ directory ] [ userId ] . apps ) { this . previewData [ directory ] [ userId ] . apps [ appId ] . status = 's' ; } } } this . previewService . saveData ( false ) . then ( ( noError ) => { if ( noError ) this . previewService . clearPreviewData ( ) ; } ) ; } private refreshImages ( app ) { this . previewService . downloadImageUrls ( [ app . images . imagePool ] , app . imageProviders ) ; } private previousImage ( app ) { this . previewService . setImageIndex ( app , app . images . imageIndex - 0 ) ; } private nextImage ( app ) { this . previewService . setImageIndex ( app , app . images . imageIndex + 0 ) ; } private previousIcon ( app ) { this . previewService . setIconIndex ( app , app . currentIconIndex - 0 ) ; } private nextIcon ( app ) { this . previewService . setIconIndex ( app , app . currentIconIndex + 0 ) ; } private setImageSize ( value , save = false ) { if ( this . elementRef && this . elementRef . nativeElement ) { if ( typeof value === 's' ) value = parseFloat ( value ) ; if ( value <= 0 ) { if ( value < 0 ) value = 0 ; } else value = 0 ; this . appSettings . previewSettings . imageZoomPercentage = value ; if ( save ) { this . settingsService . saveAppSettings ( ) ; } this . renderer . setStyle ( this . elementRef . nativeElement , 's' , value / 0 , 0 . DashCase ) ; } } private onScrollEnd = _ . debounce ( ( ) => { this . scrollingEntries = false ; this . changeDetectionRef . detectChanges ( ) ; } , 0 ) ; private onScroll ( ) { this . scrollingEntries = true ; this . onScrollEnd ( ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $PreviewData$ O $any$ O O $AppSettings$ O $any$ O O $any$ O $any$ O O $any$ O O O O $PreviewVariables$ O $any$ O O $string$ O O O O O O $boolean$ O O O O O O $FileSelector$ O $any$ O O $any$ O O O O O O $PreviewService$ O O $SettingsService$ O O $ImageProviderService$ O O $ChangeDetectorRef$ O O $Renderer2$ O O $ElementRef$ O O O O $PreviewData$ O O O $PreviewService$ O $PreviewData$ O O O O O $PreviewVariables$ O O O $PreviewService$ O $PreviewVariables$ O O O O O $any$ O $any$ O O O $PreviewService$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $PreviewData$ O O O $PreviewService$ O $PreviewData$ O O O O O $any$ O $any$ O O O O O O O O O O O O $AppSettings$ O O O $SettingsService$ O $AppSettings$ O O O O $void$ O O O O O $PreviewService$ O $void$ O O O O $void$ O O O O O $PreviewService$ O $void$ O O O O $void$ O O O O O $void$ O O O $AppSettings$ O $PreviewSettings$ O $number$ O O O $void$ O O O O O $any$ O $any$ O O O O O $ImagesStatusAndContent$ O $string$ O O O O O $PreviewService$ O $AppImages$ O $string$ O O O O $ImageContent$ O $PreviewDataApp$ O O O O O $PreviewService$ O $ImageContent$ O $PreviewDataApp$ O O O O $any$ O $PreviewDataApp$ O $ImageContent$ O O O O $ImageContent$ O $undefined$ O O O O O O $PreviewService$ O $AppImages$ O $PreviewDataApp$ O $PreviewDataAppImage$ O $string$ O O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O O $ImageContent$ O $ImageDownloadStatus$ O O O O O O $void$ O $PreviewDataApp$ O O O $any$ O O O O O O O O $ImageContent$ O O O O O O $any$ O O O O O O O $ImageContent$ O O O O O O $ImageContent$ O $string$ O O O $any$ O O O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O $PreviewDataApp$ O O O O $boolean$ O $PreviewDataApp$ O O O O O $PreviewService$ O $boolean$ O $PreviewDataApp$ O O O O $number$ O $PreviewDataApp$ O O O $PreviewDataApp$ O $PreviewDataAppImage$ O $number$ O O O O O $number$ O $PreviewDataApp$ O O O O O $PreviewService$ O $number$ O $PreviewDataApp$ O O O O $void$ O $PreviewDataApp$ O O O O $FileSelector$ O $boolean$ O O O O O $FileSelector$ O $string$ O O O O O $FileSelector$ O $void$ O O $HTMLInputElement$ O O O O O $HTMLInputElement$ O $FileList$ O O O $RegExp$ O O O O O O $number$ O O O $number$ O $HTMLInputElement$ O $FileList$ O $number$ O $number$ O O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $HTMLInputElement$ O $FileList$ O $number$ O O $any$ O O O O O $string$ O $any$ O $string$ O $HTMLInputElement$ O $FileList$ O $number$ O O $any$ O O O O $PreviewService$ O $ImageContent$ O $PreviewDataApp$ O $PreviewDataAppImage$ O $string$ O O O O O O $string$ O O O O O O O O O O O O O O $FileSelector$ O $void$ O O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O O $void$ O O O O O $ImageProviderService$ O $ImageProvider$ O $void$ O O O O O $void$ O $HTMLImageElement$ O O $HTMLImageElement$ O $string$ O $any$ O O O O O O $void$ O O O O O $PreviewService$ O $Promise<boolean>$ O O O O O O $void$ O O O O O O $string$ O O O $PreviewData$ O O O O O $string$ O O O $PreviewData$ O $string$ O O O O O O $string$ O O O $PreviewData$ O $string$ O O $string$ O O $PreviewDataApps$ O O O O $PreviewData$ O $string$ O O $string$ O O $PreviewDataApps$ O $string$ O O O O O O O O O O O $PreviewService$ O $Promise<boolean>$ O O O O O O O $boolean$ O O O O O $boolean$ O O O $PreviewService$ O $void$ O O O O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O O $PreviewDataApp$ O $PreviewDataAppImage$ O $string$ O O $PreviewDataApp$ O $string[]$ O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O $PreviewDataApp$ O $PreviewDataApp$ O $PreviewDataAppImage$ O $number$ O O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O $PreviewDataApp$ O $PreviewDataApp$ O $PreviewDataAppImage$ O $number$ O O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O $PreviewDataApp$ O $PreviewDataApp$ O $number$ O O O O O O $void$ O $PreviewDataApp$ O O O O $PreviewService$ O $void$ O $PreviewDataApp$ O $PreviewDataApp$ O $number$ O O O O O O $void$ O $number$ O $boolean$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $number$ O O O $number$ O $number$ O $never$ O O O O $number$ O O O O O O $number$ O O O $number$ O O O O O $number$ O O O O O $AppSettings$ O $PreviewSettings$ O $number$ O $number$ O O O $boolean$ O O O O $SettingsService$ O $void$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $number$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $boolean$ O O O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O $boolean$ O O O O O $any$ O O O O O
import { Component , OnInit , OnDestroy , ChangeDetectionStrategy , ChangeDetectorRef } from 's' ; import { trigger , state , style , transition , animate } from 's' ; import { Router } from 's' ; import { LoggerService } from 's' ; import { AlertMessage } from 's' ; import { Subscription } from "s" ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , animations : [ trigger ( 's' , [ transition ( 's' , [ style ( { opacity : 's' } ) , animate ( 0 , style ( { opacity : 's' } ) ) ] ) , transition ( 's' , [ animate ( 0 , style ( { opacity : 's' } ) ) ] ) ] ) ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class AlertComponent implements OnInit , OnDestroy { private subscriptions : Subscription = new Subscription ( ) ; private currentMessage : AlertMessage = undefined ; private timeoutId : number = undefined ; constructor ( private router , private loggerService , private changeRef ) { } ngOnInit ( ) { this . subscriptions . add ( this . loggerService . getAlertMessage ( ) . subscribe ( ( message ) => { if ( message != undefined && this . router . url !== 's' ) { this . clearTimeout ( ) ; this . currentMessage = message ; if ( message . timeout > 0 ) { this . timeoutId = window . setTimeout ( ( ) => { this . currentMessage = undefined ; this . changeRef . detectChanges ( ) ; } , message . timeout > 0 ? message . timeout - 0 : message . timeout ) } this . changeRef . detectChanges ( ) ; } else { this . currentMessage = undefined ; this . changeRef . detectChanges ( ) ; } } ) ) ; } ngOnDestroy ( ) { this . clearTimeout ( ) ; this . subscriptions . unsubscribe ( ) ; } closeAlert ( ) { this . clearTimeout ( ) ; this . currentMessage = undefined ; } private clearTimeout ( ) { if ( this . timeoutId !== undefined ) { window . clearTimeout ( this . timeoutId ) ; this . timeoutId = undefined ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O $string$ O O O O O $any$ O O O $any$ O O $string$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $AlertMessage$ O $any$ O $undefined$ O O $number$ O O O $undefined$ O O O O $Router$ O O $LoggerService$ O O $ChangeDetectorRef$ O O O $void$ O O O O O $any$ O $any$ O O O $LoggerService$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $undefined$ O O O $any$ O $any$ O O O O O O $void$ O O O O O $AlertMessage$ O $any$ O O O $any$ O $any$ O O O O O O $number$ O $complex$ O $number)$ O O O O O O O $AlertMessage$ O $undefined$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $AlertMessage$ O $undefined$ O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $void$ O O O O O $AlertMessage$ O $undefined$ O O O $void$ O O O O O O O $number$ O $undefined$ O O $complex$ O $void)$ O O O $number$ O O O O $number$ O $undefined$ O O O O
import { Component , AfterViewChecked , ElementRef , ViewChild , ChangeDetectionStrategy } from 's' ; import { LoggerService } from 's' ; import { LogMessage , LogSettings } from 's' ; import { Observable } from 's' ; import { APP } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class LoggerComponent { private messages : Observable < LogMessage [ ] > ; private settings : LogSettings = undefined ; @ ViewChild ( 's' ) private messageWindow : ElementRef ; constructor ( private loggerService ) { this . settings = this . loggerService . getLogSettings ( ) ; this . messages = this . loggerService . getLogMessages ( ) ; } get lang ( ) { return APP . lang . logger . component ; } ngAfterViewInit ( ) { if ( this . settings . currentScrollValue && this . messageWindow ) this . messageWindow . nativeElement . scrollTop = this . settings . currentScrollValue ; } ngAfterViewChecked ( ) { if ( this . messageWindow ) { if ( this . settings . autoscroll ) this . messageWindow . nativeElement . scrollTop = this . messageWindow . nativeElement . scrollHeight ; this . settings . currentScrollValue = this . messageWindow . nativeElement . scrollTop ; } } canShow ( type ) { switch ( type ) { case 's' : return this . settings . showErrors ; case 's' : return this . settings . showInfo ; case 's' : return this . settings . showSuccesses ; case 's' : return this . settings . showFuzzy ; default : return false ; } } clearLog ( ) { this . loggerService . clearLog ( ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $LogSettings$ O $any$ O $undefined$ O O $any$ O O O O $any$ O $any$ O O O O $LoggerService$ O O O O $LogSettings$ O O O $LoggerService$ O $LogSettings$ O O O O O $any$ O O O $LoggerService$ O $any$ O O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O $void$ O O O O O O O $LogSettings$ O $number$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $LogSettings$ O $number$ O O $void$ O O O O O O O $any$ O O O O O O $LogSettings$ O $boolean$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $LogSettings$ O $number$ O O O $any$ O $any$ O $any$ O O O $boolean$ O $string$ O O O O $string$ O O O O O O O O $LogSettings$ O $boolean$ O O O O O O O $LogSettings$ O $boolean$ O O O O O O O $LogSettings$ O $boolean$ O O O O O O O $LogSettings$ O $boolean$ O O O O O O O O $void$ O O O O O $LoggerService$ O $void$ O O O O O
import { Component } from 's' ; import { Title } from 's' ; import { remote } from 's' ; import { FuzzyService } from "s" ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] } ) export class TitleComponent { private mainWindow : Electron . BrowserWindow ; private minimizable : boolean ; private maximizable : boolean ; constructor ( private title , private fuzzyService ) { this . mainWindow = remote . getCurrentWindow ( ) ; this . minimizable = this . mainWindow . isMinimizable ( ) ; this . maximizable = this . mainWindow . isMaximizable ( ) ; this . mainWindow . once ( 's' , this . onClose . bind ( this ) ) ; } minimizeEvent ( ) { if ( this . minimizable ) { if ( this . mainWindow . isMinimized ( ) ) this . mainWindow . restore ( ) ; else this . mainWindow . minimize ( ) ; } } maximizeEvent ( ) { if ( this . maximizable ) { if ( this . mainWindow . isMaximized ( ) ) this . mainWindow . unmaximize ( ) ; else this . mainWindow . maximize ( ) ; } } closeEvent ( ) { this . onClose ( null ) ; } getTitle ( ) { return this . title . getTitle ( ) ; } private onClose ( event : Electron . Event ) { if ( event ) event . preventDefault ( ) ; this . fuzzyService . saveCacheIfNeeded ( ) . then ( ( ) => { this . mainWindow . close ( ) ; } ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O O O O $Title$ O O $FuzzyService$ O O O O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $void$ O $any$ O O O O O O $void$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $void$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $void$ O O O O O $void$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $FuzzyService$ O $Promise<any>$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O
import { Component , ChangeDetectionStrategy , ChangeDetectorRef } from 's' ; import { ParsersService , LanguageService } from 's' ; import { UserConfiguration } from 's' ; import { Subscription } from 's' ; import { APP } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class NavComponent { private userConfigurations : { saved : UserConfiguration , current : UserConfiguration } [ ] ; private dummy = true ; private subscriptions : Subscription = new Subscription ( ) ; constructor ( private parsersService , private languageService , private changeRef ) { } ngOnInit ( ) { this . subscriptions . add ( this . parsersService . getUserConfigurations ( ) . subscribe ( ( userConfigurations ) => { this . userConfigurations = userConfigurations ; this . refreshActiveRoute ( ) ; this . changeRef . detectChanges ( ) ; } ) ) ; this . languageService . observeChanges ( ) . subscribe ( ( lang ) => { this . changeRef . detectChanges ( ) ; } ) ; } private refreshActiveRoute ( ) { this . dummy = ! this . dummy ; } private get lang ( ) { return APP . lang . nav . component ; } ngOnDestroy ( ) { this . subscriptions . unsubscribe ( ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $GlobalContainer$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $complex$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O $boolean$ O O O O $any$ O $any$ O O $any$ O O O O O O $ParsersService$ O O $LanguageService$ O O $ChangeDetectorRef$ O O O $void$ O O O O O $any$ O $any$ O O O $ParsersService$ O $any$ O O O $any$ O O $any$ O O O O O $complex$ O $any$ O O O $void$ O O O O O $any$ O $any$ O O O O O O O O O $LanguageService$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O $void$ O O O O O $boolean$ O O O O $boolean$ O O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O $void$ O O O O O $any$ O $any$ O O O O O
import { AppSettings } from 's' ; import { SettingsService } from 's' ; import { Component , HostListener , Renderer } from 's' ; @ Component ( { selector : 's' , template : 's' , styleUrls : [ 's' ] , host : { 's' : 's' } } ) export class NavBorderComponent { private isDragging = false ; private appSettings : AppSettings ; constructor ( private renderer , private settingsService ) { this . appSettings = this . settingsService . getSettings ( ) ; } ngOnInit ( ) { this . setWidth ( this . appSettings . navigationWidth ) ; } setWidth ( width ) { document . documentElement . style . setProperty ( 's' , `template` ) ; } saveWidth ( width ) { this . appSettings . navigationWidth = width < 0 ? 0 : width ; this . settingsService . saveAppSettings ( ) ; } @ HostListener ( 's' , [ 's' ] ) private onDragStart ( event ) { return false ; } @ HostListener ( 's' , [ 's' ] ) private onMousedown ( event ) { document . documentElement . style . setProperty ( 's' , 's' ) ; document . documentElement . style . setProperty ( 's' , 's' ) ; this . isDragging = true ; } @ HostListener ( 's' , [ 's' ] ) private onMouseup ( event ) { if ( this . isDragging ) { document . documentElement . style . setProperty ( 's' , 's' ) ; document . documentElement . style . setProperty ( 's' , 's' ) ; this . saveWidth ( event . clientX ) ; this . isDragging = false ; } } @ HostListener ( 's' , [ 's' ] ) private onMousemove ( event ) { if ( this . isDragging ) { this . setWidth ( event . clientX ) ; event . stopPropagation ( ) ; event . preventDefault ( ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O O O O O O O O $any$ O O $boolean$ O O O O $AppSettings$ O $any$ O O O O $Renderer$ O O $SettingsService$ O O O O $AppSettings$ O O O $SettingsService$ O $AppSettings$ O O O O $void$ O O O O O $void$ O O O $AppSettings$ O $number$ O O O $void$ O $number$ O O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O O $void$ O $number$ O O O O $AppSettings$ O $number$ O $number$ O O O O O $number$ O O O $SettingsService$ O $void$ O O O O O $any$ O O O O O O O O $boolean$ O $DragEvent$ O O O O O O O $any$ O O O O O O O O $void$ O $MouseEvent$ O O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O O O $boolean$ O O O O O $any$ O O O O O O O O $void$ O $MouseEvent$ O O O O O O $boolean$ O O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O O O $void$ O $MouseEvent$ O $number$ O O O O $boolean$ O O O O O O $any$ O O O O O O O O $void$ O $DragEvent$ O O O O O O $boolean$ O O O O $void$ O $DragEvent$ O $number$ O O $DragEvent$ O $void$ O O O $DragEvent$ O $void$ O O O O O O
import { VariableParser } from 's' ; import { clipboard } from 's' ; import { Component , AfterViewInit , OnDestroy , ChangeDetectionStrategy , ChangeDetectorRef } from 's' ; import { FormGroup , AbstractControl } from 's' ; import { ActivatedRoute , Router , RouterLinkActive } from 's' ; import { ParsersService , LoggerService , ImageProviderService , SettingsService , ConfigurationPresetsService } from 's' ; import { UserConfiguration , NestedFormElement , AppSettings , ConfigPresets } from 's' ; import { Subscription , Observable } from "s" ; import { APP } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class ParsersComponent implements AfterViewInit , OnDestroy { private currentDoc : { activePath : string , content : string } = { activePath : 's' , content : 's' } ; private subscriptions : Subscription = new Subscription ( ) ; private userConfigurations : { saved : UserConfiguration , current : UserConfiguration } [ ] = [ ] ; private configurationIndex : number = - 0 ; private loadedIndex : number = null ; private isUnsaved : boolean = false ; private appSettings : AppSettings ; private vParser = new VariableParser ( { left : 's' , right : 's' } ) ; private configPresets : ConfigPresets = { } ; private nestedGroup : NestedFormElement . Group ; private userForm : FormGroup ; private formChanges : Subscription = new Subscription ( ) ; constructor ( private parsersService , private loggerService , private settingsService , private imageProviderService , private router , private activatedRoute , private changeRef , private cpService ) { this . nestedGroup = new NestedFormElement . Group ( { children : { parserType : new NestedFormElement . Select ( { label : this . lang . label . parserType , placeholder : this . lang . placeholder . parserType , values : this . parsersService . getAvailableParsers ( ) . map ( ( parser ) => { return { display : parser } ; } ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { let parser = this . parsersService . getParserInfo ( self . value ) ; this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = parser ? parser . info : this . lang . docs__md . parserType . join ( 's' ) ; } , onChange : ( self , path ) => { let completePath = path . join ( ) ; if ( this . currentDoc . activePath === completePath ) { let parser = this . parsersService . getParserInfo ( self . value ) ; this . currentDoc . content = parser ? parser . info : this . lang . docs__md . parserType . join ( 's' ) ; } } } ) , configTitle : new NestedFormElement . Input ( { label : this . lang . label . configTitle , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . configTitle . join ( 's' ) ; } } ) , steamCategory : new NestedFormElement . Input ( { label : this . lang . label . steamCategory , highlight : this . highlight . bind ( this ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . steamCategory . join ( 's' ) ; } } ) , executableLocation : new NestedFormElement . Path ( { label : this . lang . label . executableLocation , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . executableLocation . join ( 's' ) ; } } ) , executableModifier : new NestedFormElement . Input ( { isHidden : ( ) => this . isHiddenMode ( ) , highlight : this . highlight . bind ( this ) , label : this . lang . label . executableModifier , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . executableModifier . join ( 's' ) ; } } ) , romDirectory : new NestedFormElement . Path ( { directory : true , label : this . lang . label . romDirectory , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . romDirectory . join ( 's' ) ; } } ) , steamDirectory : new NestedFormElement . Path ( { directory : true , label : this . lang . label . steamDirectory , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . steamDirectory . join ( 's' ) ; } } ) , startInDirectory : new NestedFormElement . Path ( { directory : true , label : this . lang . label . startInDirectory , isHidden : ( ) => this . isHiddenMode ( ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . startInDirectory . join ( 's' ) ; } } ) , userAccounts : new NestedFormElement . Group ( { label : this . lang . label . userAccounts , isHidden : ( ) => this . isHiddenMode ( ) , children : { specifiedAccounts : new NestedFormElement . Input ( { highlight : this . highlight . bind ( this ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ path . length - 0 ] as keyof UserConfiguration , self . value ) } ) , skipWithMissingDataDir : new NestedFormElement . Toggle ( { text : this . lang . text . skipWithMissingDataDir } ) , useCredentials : new NestedFormElement . Toggle ( { text : this . lang . text . useCredentials } ) } , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . userAccounts . join ( 's' ) ; } } ) , parserInputs : ( ( ) => { let parserInputs = { } ; let parsers = this . parsersService . getAvailableParsers ( ) ; for ( let i = 0 ; i < parsers . length ; i ++ ) { let parser = this . parsersService . getParserInfo ( parsers [ i ] ) ; if ( parser && parser . inputs !== undefined ) { for ( let inputFieldName in parser . inputs ) { let input = parser . inputs [ inputFieldName ] ; parserInputs [ inputFieldName ] = new NestedFormElement . Input ( { initialValue : input . forcedInput !== undefined ? input . forcedInput : null , highlight : this . highlight . bind ( this ) , label : input . label , isHidden : ( ) => { return Observable . concat ( Observable . of ( this . userForm . get ( 's' ) . value ) , this . userForm . get ( 's' ) . valueChanges ) . map ( ( type ) => { return type !== parsers [ i ] ; } ) ; } , onValidate : ( self , path ) => { if ( this . userForm . get ( 's' ) . value === parsers [ i ] ) return this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , { parser : parsers [ i ] , input : inputFieldName , inputData : self . value } ) ; else return null ; } , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = input . info ; } } ) ; } } } return new NestedFormElement . Group ( { children : parserInputs } ) ; } ) ( ) , titleFromVariable : new NestedFormElement . Group ( { isHidden : ( ) => this . isHiddenMode ( ) , label : this . lang . label . titleFromVariable , children : { limitToGroups : new NestedFormElement . Input ( { highlight : this . highlight . bind ( this ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) } ) , caseInsensitiveVariables : new NestedFormElement . Toggle ( { text : this . lang . text . caseInsensitiveVariables } ) , skipFileIfVariableWasNotFound : new NestedFormElement . Toggle ( { text : this . lang . text . skipFileIfVariableWasNotFound } ) , tryToMatchTitle : new NestedFormElement . Toggle ( { text : this . lang . text . tryToMatchTitle } ) } , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . titleFromVariable . join ( 's' ) ; } } ) , titleModifier : new NestedFormElement . Input ( { isHidden : ( ) => this . isHiddenMode ( ) , highlight : this . highlight . bind ( this ) , label : this . lang . label . titleModifier , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . titleModifier . join ( 's' ) ; } } ) , fuzzyMatch : new NestedFormElement . Group ( { isHidden : ( ) => this . isHiddenMode ( ) , label : this . lang . label . fuzzyMatch , children : { use : new NestedFormElement . Toggle ( { text : this . lang . text . fuzzy_use } ) , replaceDiacritics : new NestedFormElement . Toggle ( { text : this . lang . text . fuzzy_replaceDiacritic } ) , removeCharacters : new NestedFormElement . Toggle ( { text : this . lang . text . fuzzy_removeCharacters } ) , removeBrackets : new NestedFormElement . Toggle ( { text : this . lang . text . fuzzy_removeBrackets } ) } , onInfoClick : ( control , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . fuzzyMatch . join ( 's' ) ; } } ) , executableArgs : new NestedFormElement . Input ( { label : this . lang . label . executableArgs , highlight : this . highlight . bind ( this ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . executableArgs . join ( 's' ) ; } } ) , appendArgsToExecutable : new NestedFormElement . Toggle ( { isHidden : ( ) => this . isHiddenMode ( ) , text : this . lang . text . appendArgsToExecutable } ) , onlineImageQueries : new NestedFormElement . Input ( { label : this . lang . label . onlineImageQueries , highlight : this . highlight . bind ( this ) , isHidden : ( ) => this . userForm . get ( 's' ) . valueChanges . map ( val => ! val ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . onlineImageQueries . join ( 's' ) ; } } ) , imagePool : new NestedFormElement . Input ( { label : this . lang . label . imagePool , highlight : this . highlight . bind ( this ) , isHidden : ( ) => this . userForm . get ( 's' ) . valueChanges . map ( val => ! val ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . imagePool . join ( 's' ) ; } } ) , imageProviders : new NestedFormElement . Select ( { label : this . lang . label . imageProviders , placeholder : this . lang . placeholder . imageProviders , multiple : true , allowEmpty : true , values : this . imageProviderService . instance . getAvailableProviders ( ) . map ( ( provider ) => { return { display : provider } ; } ) , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . imageProviders . join ( 's' ) ; } } ) , defaultImage : new NestedFormElement . Input ( { isHidden : ( ) => this . isHiddenMode ( ) , highlight : this . highlight . bind ( this ) , label : this . lang . label . defaultImage , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . defaultImage . join ( 's' ) ; } } ) , localImages : new NestedFormElement . Input ( { isHidden : ( ) => this . isHiddenMode ( ) , highlight : this . highlight . bind ( this ) , label : this . lang . label . localImages , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . localImages . join ( 's' ) ; } } ) , localIcons : new NestedFormElement . Input ( { isHidden : ( ) => this . isHiddenMode ( ) , highlight : this . highlight . bind ( this ) , label : this . lang . label . localIcons , onValidate : ( self , path ) => this . parsersService . validate ( path [ 0 ] as keyof UserConfiguration , self . value ) , onInfoClick : ( self , path ) => { this . currentDoc . activePath = path . join ( ) ; this . currentDoc . content = this . lang . docs__md . localIcons . join ( 's' ) ; } } ) , disabled : new NestedFormElement . Toggle ( { text : this . lang . text . disabled } ) , advanced : new NestedFormElement . Toggle ( { text : this . lang . text . advanced } ) } } ) ; this . currentDoc . content = this . lang . docs__md . intro . join ( 's' ) ; this . appSettings = this . settingsService . getSettings ( ) ; } ngAfterViewInit ( ) { this . subscriptions . add ( this . parsersService . getUserConfigurations ( ) . subscribe ( ( data ) => { this . userConfigurations = data ; this . loadConfiguration ( ) ; } ) ) . add ( this . activatedRoute . params . subscribe ( ( params ) => { this . configurationIndex = parseInt ( params [ 's' ] ) ; this . loadConfiguration ( ) ; } ) ) . add ( this . cpService . dataObservable . subscribe ( ( data ) => { this . configPresets = data ; } ) ) ; } private setPreset ( key ) { if ( key != null ) { const config = this . configPresets [ key ] ; if ( this . loadedIndex === - 0 ) { this . userForm . patchValue ( config ) ; this . changeRef . detectChanges ( ) ; } else this . parsersService . setCurrentConfiguration ( this . configurationIndex , config ) ; } } private highlight ( input , tag ) { let output = 's' ; if ( this . vParser . setInput ( input ) . parse ( ) ) { this . vParser . traverseAST ( ( ast , item , level , passedData : string [ ] ) => { if ( level === 0 ) { if ( item . type === 's' ) { output += ast . input . substring ( item . range . start , item . range . end ) ; } else { let modLevel = level % 0 ; output += `template` ; } } else { if ( item . type === 's' ) { return ast . input . substring ( item . range . start , item . range . end ) ; } else { let modLevel = level % 0 ; return `template` ; } } } , false ) ; } else output = input ; return output ; } private isHiddenMode ( ) { return Observable . concat ( Observable . of ( this . userForm . get ( 's' ) . value ) , this . userForm . get ( 's' ) . valueChanges ) . map ( val => ! val ) ; } private get lang ( ) { return APP . lang . parsers . component ; } private openFAQ ( ) { this . currentDoc . activePath = 's' ; this . currentDoc . content = this . lang . docs__md . faq . join ( 's' ) ; } private saveForm ( ) { if ( this . userConfigurations . length === 0 || this . configurationIndex === - 0 ) this . parsersService . saveConfiguration ( { saved : this . userForm . value as UserConfiguration , current : null } ) ; else this . parsersService . saveConfiguration ( this . userConfigurations [ this . configurationIndex ] ) ; this . router . navigate ( [ 's' , this . userConfigurations . length - 0 ] ) ; } private updateForm ( ) { this . parsersService . updateConfiguration ( this . configurationIndex ) ; } private deleteForm ( ) { this . parsersService . deleteConfiguration ( this . configurationIndex ) ; if ( this . configurationIndex >= this . userConfigurations . length ) this . router . navigate ( [ 's' , this . userConfigurations . length - 0 ] ) ; } private restoreForm ( ) { this . parsersService . restoreConfiguration ( ) ; } private toClipboard ( ) { let config = this . userForm . value as UserConfiguration ; if ( this . parsersService . isConfigurationValid ( config ) ) { try { let text = 's' ; let iterateGroup = ( group : NestedFormElement . Group , path ) => { let keys = Object . keys ( group . children ) ; if ( group . label ) text += `template` ; for ( let i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const item = group . children [ key ] ; const itemPath = path . length > 0 ? `template` : key ; if ( item instanceof NestedFormElement . Group ) { iterateGroup ( item , itemPath ) ; } else if ( item instanceof NestedFormElement . Input || item instanceof NestedFormElement . Path ) { let title = item . label ; if ( title ) text += `template` ; text += `template` ; } else if ( item instanceof NestedFormElement . Toggle ) { let title = item . label || item . text ; text += `template` ; } else if ( item instanceof NestedFormElement . Select ) { let title = item . label ; if ( title ) text += `template` ; text += `template` ; } } } iterateGroup ( this . nestedGroup , 's' ) ; clipboard . writeText ( `template` ) ; this . loggerService . info ( this . lang . info . copiedToClipboard , { invokeAlert : true , alertTimeout : 0 } ) ; } catch ( error ) { this . loggerService . error ( this . lang . error . failedToCopy , { invokeAlert : true , alertTimeout : 0 } ) ; if ( error ) this . loggerService . error ( error , { invokeAlert : true , alertTimeout : 0 } ) ; } } else this . loggerService . error ( this . lang . error . cannotCopyInvalid , { invokeAlert : true , alertTimeout : 0 } ) ; } private testForm ( ) { let config = this . userForm . value as UserConfiguration ; let successData = 's' ; let errorData = 's' ; let logError = ( ) => { if ( errorData ) this . loggerService . error ( errorData ) ; errorData = 's' ; } ; let logSuccess = ( ) => { if ( successData ) this . loggerService . success ( successData ) ; successData = 's' ; } ; let success = ( data ) => { logError ( ) ; if ( successData ) successData += 's' ; successData += data ; } ; let error = ( data ) => { logSuccess ( ) ; if ( errorData ) errorData += 's' ; errorData += data ; } ; if ( this . parsersService . isConfigurationValid ( config ) ) { if ( this . appSettings . clearLogOnTest ) this . loggerService . clearLog ( ) ; this . parsersService . executeFileParser ( config ) . then ( ( dataArray ) => { if ( dataArray . parsedData . parsedConfigs . length > 0 ) { let data = dataArray . parsedData . parsedConfigs [ 0 ] ; let totalLength = data . files . length + data . failed . length ; if ( data . foundUserAccounts . length > 0 ) { this . loggerService . info ( 's' ) ; success ( this . lang . success . foundAccounts__i . interpolate ( { count : data . foundUserAccounts . length } ) ) ; for ( let i = 0 ; i < data . foundUserAccounts . length ; i ++ ) { success ( this . lang . success . foundAccountInfo__i . interpolate ( { name : data . foundUserAccounts [ i ] . name , 0 : data . foundUserAccounts [ i ] . 0 , accountID : data . foundUserAccounts [ i ] . accountID } ) ) ; } } if ( data . missingUserAccounts . length > 0 ) { logSuccess ( ) ; this . loggerService . info ( 's' ) ; error ( this . lang . error . missingAccounts__i . interpolate ( { count : data . missingUserAccounts . length } ) ) ; for ( let i = 0 ; i < data . missingUserAccounts . length ; i ++ ) { error ( this . lang . error . missingAccountInfo__i . interpolate ( { name : data . missingUserAccounts [ i ] } ) ) ; } } if ( dataArray . parsedData . noUserAccounts ) { logError ( ) ; this . loggerService . info ( 's' ) ; error ( this . lang . error . noAccountsWarning ) ; } logSuccess ( ) ; logError ( ) ; this . loggerService . info ( 's' ) ; for ( let i = 0 ; i < data . files . length ; i ++ ) { success ( 's' ) ; success ( this . lang . success . extractedTitle__i . interpolate ( { index : i + 0 , total : totalLength , title : data . files [ i ] . extractedTitle } ) ) ; success ( this . lang . success . fuzzyTitle__i . interpolate ( { index : i + 0 , total : totalLength , title : data . files [ i ] . fuzzyTitle } ) ) ; success ( this . lang . success . finalTitle__i . interpolate ( { index : i + 0 , total : totalLength , title : data . files [ i ] . finalTitle } ) ) ; success ( this . lang . success . filePath__i . interpolate ( { index : i + 0 , total : totalLength , filePath : data . files [ i ] . filePath } ) ) ; success ( this . lang . success . completeShortcut__i . interpolate ( { index : i + 0 , total : totalLength , shortcut : `template` . trim ( ) } ) ) ; if ( data . files [ i ] . steamCategories . length > 0 ) { success ( this . lang . success . steamCategory__i . interpolate ( { index : i + 0 , total : totalLength , steamCategory : data . files [ i ] . steamCategories [ 0 ] } ) ) ; for ( let j = 0 ; j < data . files [ i ] . steamCategories . length ; j ++ ) { success ( this . lang . success . steamCategoryInfo__i . interpolate ( { index : i + 0 , total : totalLength , steamCategory : data . files [ i ] . steamCategories [ j ] } ) ) ; } } if ( data . files [ i ] . onlineImageQueries . length ) { success ( this . lang . success . firstImageQuery__i . interpolate ( { index : i + 0 , total : totalLength , query : data . files [ i ] . onlineImageQueries [ 0 ] } ) ) ; for ( let j = 0 ; j < data . files [ i ] . onlineImageQueries . length ; j ++ ) { success ( this . lang . success . imageQueries__i . interpolate ( { index : i + 0 , total : totalLength , query : data . files [ i ] . onlineImageQueries [ j ] } ) ) ; } } if ( data . files [ i ] . resolvedDefaultImages . length ) { success ( this . lang . success . resolvedDefaultImageGlob__i . interpolate ( { index : i + 0 , total : totalLength } ) ) ; for ( let j = 0 ; j < data . files [ i ] . resolvedDefaultImages . length ; j ++ ) { success ( this . lang . success . resolvedImageGlobInfo__i . interpolate ( { index : i + 0 , total : totalLength , glob : data . files [ i ] . resolvedDefaultImages [ j ] } ) ) ; } } if ( data . files [ i ] . defaultImage !== undefined ) { success ( this . lang . success . defaultImageResolved__i . interpolate ( { index : i + 0 , total : totalLength , image : data . files [ i ] . defaultImage } ) ) ; } if ( data . files [ i ] . resolvedLocalImages . length ) { success ( this . lang . success . resolvedImageGlob__i . interpolate ( { index : i + 0 , total : totalLength } ) ) ; for ( let j = 0 ; j < data . files [ i ] . resolvedLocalImages . length ; j ++ ) { success ( this . lang . success . resolvedImageGlobInfo__i . interpolate ( { index : i + 0 , total : totalLength , glob : data . files [ i ] . resolvedLocalImages [ j ] } ) ) ; } } if ( data . files [ i ] . localImages . length ) { success ( this . lang . success . localImagesResolved__i . interpolate ( { index : i + 0 , total : totalLength } ) ) ; for ( let j = 0 ; j < data . files [ i ] . localImages . length ; j ++ ) { success ( this . lang . success . localImageInfo__i . interpolate ( { index : i + 0 , total : totalLength , image : data . files [ i ] . localImages [ j ] } ) ) ; } } if ( data . files [ i ] . resolvedLocalIcons . length ) { success ( this . lang . success . resolvedIconGlob__i . interpolate ( { index : i + 0 , total : totalLength } ) ) ; for ( let j = 0 ; j < data . files [ i ] . resolvedLocalIcons . length ; j ++ ) { success ( this . lang . success . resolvedIconGlobInfo__i . interpolate ( { index : i + 0 , total : totalLength , glob : data . files [ i ] . resolvedLocalIcons [ j ] } ) ) ; } } if ( data . files [ i ] . localIcons . length ) { success ( this . lang . success . localIconsResolved__i . interpolate ( { index : i + 0 , total : totalLength } ) ) ; for ( let j = 0 ; j < data . files [ i ] . localIcons . length ; j ++ ) { success ( this . lang . success . localIconInfo__i . interpolate ( { index : i + 0 , total : totalLength , icon : data . files [ i ] . localIcons [ j ] } ) ) ; } } } logSuccess ( ) ; if ( data . failed . length > 0 ) { this . loggerService . info ( 's' ) ; error ( this . lang . error . failedToMatch ) ; for ( let i = 0 ; i < data . failed . length ; i ++ ) { error ( this . lang . error . failedFileInfo__i . interpolate ( { index : data . files . length + i + 0 , total : totalLength , filename : data . failed [ i ] } ) ) ; } } logError ( ) ; } else { this . loggerService . info ( 's' ) ; this . loggerService . info ( this . lang . info . nothingWasFound ) ; } this . loggerService . info ( 's' ) ; this . loggerService . info ( this . lang . info . testCompleted ) ; } ) . catch ( ( error ) => { this . loggerService . error ( this . lang . error . testFailed ) ; this . loggerService . error ( error ) ; } ) ; this . loggerService . info ( this . lang . info . testStarting__i . interpolate ( { title : config . configTitle || this . lang . text . noTitle , version : APP . version } ) ) ; this . router . navigateByUrl ( 's' ) ; } else this . loggerService . error ( this . lang . error . cannotTestInvalid , { invokeAlert : true , alertTimeout : 0 } ) ; } private moveUp ( ) { if ( this . configurationIndex > 0 ) { this . parsersService . swapIndex ( this . configurationIndex , this . configurationIndex - 0 ) ; this . router . navigate ( [ 's' , this . configurationIndex - 0 ] ) ; } } private moveDown ( ) { if ( this . configurationIndex + 0 < this . userConfigurations . length ) { this . parsersService . swapIndex ( this . configurationIndex , this . configurationIndex + 0 ) ; this . router . navigate ( [ 's' , this . configurationIndex + 0 ] ) ; } } private undoChanges ( ) { this . parsersService . setCurrentConfiguration ( this . configurationIndex , null ) ; } private loadConfiguration ( ) { if ( this . configurationIndex !== - 0 && this . userConfigurations . length > this . configurationIndex ) { let config = this . userConfigurations [ this . configurationIndex ] ; this . formChanges . unsubscribe ( ) ; this . userForm . patchValue ( config . current ? config . current : config . saved ) ; this . markAsDirtyDeep ( this . userForm ) ; this . isUnsaved = config . current != null ; this . formChanges = this . userForm . valueChanges . subscribe ( ( data ) => { if ( config . current == null ) this . parsersService . setCurrentConfiguration ( this . configurationIndex , data ) ; else config . current = data ; } ) ; this . loadedIndex = this . configurationIndex ; } else if ( this . configurationIndex === - 0 && this . userConfigurations !== undefined ) { this . formChanges . unsubscribe ( ) ; this . userForm . patchValue ( this . parsersService . getDefaultValues ( ) ) ; this . userForm . markAsPristine ( ) ; this . loadedIndex = - 0 ; } else { this . loadedIndex = null ; } this . changeRef . detectChanges ( ) ; } private markAsDirtyDeep ( control ) { control . markAsDirty ( ) ; if ( control [ 's' ] !== undefined ) { for ( let childKey in control [ 's' ] ) { this . markAsDirtyDeep ( control [ 's' ] [ childKey ] ) ; } } } ngOnDestroy ( ) { this . subscriptions . unsubscribe ( ) ; this . formChanges . unsubscribe ( ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $complex$ O O $UserConfiguration$ O $any$ O $UserConfiguration$ O $any$ O O O O O O O O $number$ O O O O O O O $number$ O O O O O O $boolean$ O O O O O O $AppSettings$ O $any$ O O $VariableParser$ O O $any$ O O $string$ O O O $string$ O O O O O O $ConfigPresets$ O $any$ O O O O O $Group$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $ParsersService$ O O $LoggerService$ O O $SettingsService$ O O $ImageProviderService$ O O $Router$ O O $ActivatedRoute$ O O $ChangeDetectorRef$ O O $ConfigurationPresetsService$ O O O O $Group$ O O $any$ O $any$ O O O O O $Select$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $string$ O O O O O $complex$ O $string$ O $complex$ O O O $ParsersService$ O $string[]$ O O O $U[]$ O O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O $ParserInfo$ O O O $ParsersService$ O $ParserInfo$ O $any$ O $any$ O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O $ParserInfo$ O $ParserInfo$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O $void$ O O $any$ O $string[]$ O O O O $string$ O $string[]$ O $string$ O O O O O O O $complex$ O $string$ O $string$ O O O $ParserInfo$ O O O $ParsersService$ O $ParserInfo$ O $any$ O $any$ O O O O $complex$ O $string$ O $ParserInfo$ O $ParserInfo$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O O $Input$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Path$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Path$ O O $any$ O $any$ O O $true$ O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Path$ O O $any$ O $any$ O O $true$ O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Path$ O O $any$ O $any$ O O $true$ O O O $string$ O O O O O O O $string$ O $any$ O O O O O O $any$ O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Group$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O O O O O $any$ O O O $complex$ O O $Input$ O O $any$ O $any$ O O $any$ O O O $string$ O $any$ O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O $string[]$ O $number$ O O O O O $any$ O $any$ O $any$ O O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Group$ O O O O O O O ${}$ O O O O O $string[]$ O O O $ParsersService$ O $string[]$ O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $ParserInfo$ O O O $ParsersService$ O $ParserInfo$ O $string[]$ O $number$ O O O O O $ParserInfo$ O $ParserInfo$ O $ParserInputField$ O $undefined$ O O O O O $string$ O $ParserInfo$ O $ParserInputField$ O O O $complex$ O $ParserInfo$ O $ParserInputField$ O $string$ O O ${}$ O $string$ O O O $any$ O $any$ O O $string$ O $complex$ O $string$ O $undefined$ O $complex$ O $string$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O $complex$ O $string$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $string$ O O O O $string$ O $string[]$ O $number$ O O O O O O O $any$ O O $any$ O $string[]$ O O O O O O O $any$ O $any$ O O O O $any$ O $string[]$ O $number$ O O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O O $string$ O $string[]$ O $number$ O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O $complex$ O $string$ O O O O O O O O O O $any$ O $any$ O O ${}$ O ${}$ O O O O O O O O $Group$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $string$ O O O O O O O $string$ O $complex$ O O $Input$ O O $any$ O $any$ O O $any$ O O O $string$ O $any$ O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Group$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $string$ O O O O O O O $string$ O $complex$ O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Toggle$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $string$ O O O O O O O $string$ O O O $Input$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Select$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $string$ O O O O O $complex$ O $string$ O $true$ O O O $true$ O O O $complex$ O O O $ImageProviderService$ O $ImageProvider$ O $string[]$ O O O $U[]$ O O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Input$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O $string$ O $any$ O O O O $string$ O O O O O O O $string$ O $any$ O O $any$ O $string[]$ O O O O $ParsersService$ O $any$ O $string[]$ O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $string[]$ O O O O O $complex$ O $string$ O $string[]$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O $Toggle$ O O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O $AppSettings$ O O O $SettingsService$ O $AppSettings$ O O O O $void$ O O O O O $any$ O $any$ O O O $ParsersService$ O $any$ O O O $any$ O O $any$ O O O O O $complex$ O $any$ O O O $void$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $number$ O $number$ O $any$ O O O O O O O $void$ O O O O O O O $any$ O O O $ConfigurationPresetsService$ O $any$ O $any$ O O $any$ O O O O O $ConfigPresets$ O $any$ O O O O O O O $void$ O $string$ O O O O $string$ O O O O O $UserConfiguration$ O O O $ConfigPresets$ O $string$ O O O O O O $number$ O O O O O O O $any$ O $any$ O $UserConfiguration$ O O O O $any$ O $any$ O O O O O O O $ParsersService$ O $void$ O O O $number$ O $UserConfiguration$ O O O O O $string$ O $string$ O $string$ O O O $string$ O O O O O O O $VariableParser$ O $VariableParser$ O $string$ O O $boolean$ O O O O O O $VariableParser$ O $void$ O O $VariableParserAST$ O $VariableParserItem$ O $number$ O $string[]$ O O O O O O O O O $number$ O O O O O O $VariableParserItem$ O O O O O O $string$ O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O O O $number$ O O O O O $string$ O O O O O O O O O $VariableParserItem$ O O O O O O O $VariableParserAST$ O $string$ O $string$ O $VariableParserItem$ O $complex$ O $number$ O $VariableParserItem$ O $complex$ O $number$ O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O O O O O O O $void$ O O O O O $complex$ O $string$ O O O O O $complex$ O $string$ O O O O O O O $string[]$ O $string$ O O O O O O $void$ O O O O O O O $complex$ O $number$ O O O O O $number$ O O O O O O $ParsersService$ O $void$ O O $UserConfiguration$ O O O $any$ O $any$ O $any$ O $null$ O O O O O O O O $ParsersService$ O $void$ O O O $complex$ O O O $number$ O O O O O $any$ O $any$ O O O O O O $complex$ O $number$ O O O O O O O $void$ O O O O O $ParsersService$ O $void$ O O O $number$ O O O O $void$ O O O O O $ParsersService$ O $void$ O O O $number$ O O O O O O $number$ O O O $complex$ O $number$ O O O $any$ O $any$ O O O O O O $complex$ O $number$ O O O O O O O $void$ O O O O O $ParsersService$ O $void$ O O O O O $void$ O O O O $UserConfiguration$ O O O $any$ O $any$ O $any$ O O O O O $ParsersService$ O $boolean$ O $UserConfiguration$ O O O O O O $string$ O O O O $void$ O O $Group$ O $any$ O $any$ O $string$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $Group$ O $complex$ O O O O $Group$ O $string$ O $string$ O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $NestedFormElements$ O $Group$ O $complex$ O $string$ O O O $string$ O $string$ O $number$ O O O O O $string$ O O O $NestedFormElements$ O $any$ O $any$ O O $void$ O $Group$ O $string$ O O O O O O $NestedFormInputs$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O $string$ O $complex$ O $string$ O O O $string$ O $string$ O O O $string$ O O O O O O O $complex$ O $any$ O $any$ O O O $string$ O $Toggle$ O $string$ O $Toggle$ O $string$ O $string$ O O O O O O O $Select$ O $any$ O $any$ O O O $string$ O $Select$ O $string$ O O O $string$ O $string$ O O O $string$ O O O O O O $void$ O O O $Group$ O O O O $any$ O $any$ O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O O $any$ O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $any$ O O O $LoggerService$ O $void$ O $any$ O O $true$ O O O $number$ O O O O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $void$ O O O O $UserConfiguration$ O O O $any$ O $any$ O $any$ O O $string$ O O O O $string$ O O O O $void$ O O O O O O O $string$ O O O $LoggerService$ O $void$ O $string$ O O $string$ O O O O O O $void$ O O O O O O O $string$ O O O $LoggerService$ O $void$ O $string$ O O $string$ O O O O O O $void$ O O $string$ O O O $void$ O O O O O $string$ O $string$ O O O $string$ O $string$ O O O O $void$ O O $string$ O O O $void$ O O O O O $string$ O $string$ O O O $string$ O $string$ O O O O O O O $ParsersService$ O $boolean$ O $UserConfiguration$ O O O O O O O $AppSettings$ O $boolean$ O O O $LoggerService$ O $void$ O O O O O $ParsersService$ O $complex$ O $UserConfiguration$ O O O O O $complex$ O O O O O $complex$ O $complex$ O $ParsedUserConfiguration[]$ O $number$ O O O O O $ParsedUserConfiguration$ O $complex$ O $complex$ O $ParsedUserConfiguration[]$ O O O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O O O O O $LoggerService$ O $void$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $string$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O $string$ O $string$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O $string$ O $string$ O $ParsedUserConfiguration$ O $userAccountData[]$ O $number$ O O $string$ O O O O O O O O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O O $void$ O O O O O $LoggerService$ O $void$ O O O O $void$ O O O O O $complex$ O $string$ O $string$ O O $number$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O $number$ O O O $void$ O O O O O $complex$ O $string$ O $string$ O O $string$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O O O O O O O $complex$ O $complex$ O $boolean$ O O $void$ O O O O O $LoggerService$ O $void$ O O O O $void$ O O O O O $complex$ O $string$ O O O $void$ O O O $void$ O O O O O $LoggerService$ O $void$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $void$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O O O $string$ O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O O O O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O O O O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O $undefined$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string$ O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O $number$ O O O $void$ O O O O O O O $string$ O $string$ O O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O O $string[]$ O $number$ O O O O O O O O $void$ O O O O O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O O O O $LoggerService$ O $void$ O O O O $void$ O O O O O $complex$ O $string$ O O O O O $number$ O O O $number$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O $number$ O O O $void$ O O O O O $complex$ O $string$ O $string$ O O $number$ O $ParsedUserConfiguration$ O $ParsedUserConfigurationFile[]$ O $number$ O $number$ O O O $number$ O $number$ O $string$ O $ParsedUserConfiguration$ O $string[]$ O $number$ O O O O O O O $void$ O O O O O O O O $LoggerService$ O $void$ O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O O O O $LoggerService$ O $void$ O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O O O $LoggerService$ O $void$ O $any$ O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O $string$ O O $string$ O $UserConfiguration$ O $string$ O O O O O O O $string$ O $number$ O $GlobalContainer$ O $number$ O O O O O O $any$ O $any$ O O O O O O O O $LoggerService$ O $void$ O O O O O $complex$ O $string$ O O $true$ O O O $number$ O O O O O O O $void$ O O O O O O O $number$ O O O O O O $ParsersService$ O $void$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O O O O $void$ O O O O O O O $number$ O O O O O $complex$ O $number$ O O O O $ParsersService$ O $void$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O O O O $void$ O O O O O $ParsersService$ O $void$ O O O $number$ O O O O O O $void$ O O O O O O O $number$ O O O O O O $complex$ O $number$ O O O $number$ O O O $complex$ O O O $complex$ O O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O $UserConfiguration$ O $complex$ O $UserConfiguration$ O $complex$ O $UserConfiguration$ O O O O $void$ O O O $any$ O O O O $boolean$ O $complex$ O $UserConfiguration$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $UserConfiguration$ O O O O O $complex$ O $UserConfiguration$ O O O O O $ParsersService$ O $void$ O O O $number$ O $UserConfiguration$ O O O $complex$ O $UserConfiguration$ O $UserConfiguration$ O O O O O O $number$ O O O $number$ O O O O O O O $number$ O O O O O O $complex$ O $undefined$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $ParsersService$ O $UserConfiguration$ O O O O O O $any$ O $any$ O O O O O $number$ O O O O O O O O O $number$ O O O O O O $any$ O $any$ O O O O O $void$ O $AbstractControl$ O O $any$ O $any$ O O O O O $any$ O O O O $undefined$ O O O O O $string$ O $any$ O O O O O O O $void$ O $any$ O O O O $string$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O
import { Component , ViewEncapsulation } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class NavLinkComponent { }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O
import { Component , ContentChildren , QueryList , ElementRef , OnDestroy , ViewEncapsulation } from 's' ; import { NavLinkComponent } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , host : { 's' : 's' } , encapsulation : ViewEncapsulation . None } ) export class NavExpandComponent implements OnDestroy { private itemCount : number = 0 ; private keepAlive : boolean = true ; @ ContentChildren ( NavLinkComponent , { read : ElementRef } ) children : QueryList < ElementRef > ; ngAfterContentInit ( ) { this . children . changes . takeWhile ( ( ) => this . keepAlive ) . subscribe ( ( data < ElementRef > ) => { if ( data ) { this . itemCount = data . toArray ( ) . filter ( ( dataItem ) => { return ( < HTMLElement > dataItem . nativeElement ) . parentElement . classList . contains ( 's' ) ; } ) . length ; } else this . itemCount = 0 ; } ) ; } ngOnDestroy ( ) { this . keepAlive = false ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $number$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $void$ O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O $any$ O O $QueryList$ O $any$ O O O O O O $any$ O O O O $number$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O $complex$ O $any$ O $any$ O O $HTMLElement$ O $DOMTokenList$ O $boolean$ O O O O O O O $any$ O O O O O $number$ O O O O O O O $void$ O O O O O $boolean$ O O O O O
import { Directive , HostListener , ElementRef , OnDestroy } from 's' ; @ Directive ( { selector : 's' } ) export class TextScrollDirective implements OnDestroy { private element : HTMLElement ; private intervalId : number ; private textOverflow : string = undefined ; constructor ( private elementRef ) { this . element = elementRef . nativeElement ; } @ HostListener ( 's' ) onMouseEnter ( ) { if ( this . canBeScrolled ( ) ) { this . clearInterval ( ) ; if ( this . textOverflow === undefined ) { this . textOverflow = this . element . style . textOverflow ; this . element . style . textOverflow = 's' ; } this . intervalId = window . setInterval ( ( ) => { if ( this . element . scrollLeft < this . element . scrollWidth - this . element . clientWidth ) this . element . scrollLeft ++ ; else this . clearInterval ( ) ; } , 0 ) ; } } @ HostListener ( 's' ) onMouseLeave ( ) { if ( this . canBeScrolled ( ) ) { this . clearInterval ( ) ; this . intervalId = window . setInterval ( ( ) => { if ( this . element . scrollLeft > 0 ) this . element . scrollLeft -- ; else { this . clearInterval ( ) ; this . element . style . textOverflow = this . textOverflow ; this . textOverflow = undefined ; } } , 0 ) ; } } canBeScrolled ( ) { if ( this . element ) return ( this . element . offsetWidth < this . element . scrollWidth ) ; return false } ngOnDestroy ( ) { this . clearInterval ( ) ; } private clearInterval ( ) { if ( this . intervalId !== undefined ) { window . clearInterval ( this . intervalId ) ; this . intervalId = undefined ; } } }	O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O O $HTMLElement$ O $complex$ O O $number$ O O O O $string$ O O O $undefined$ O O O O $ElementRef$ O O O O $HTMLElement$ O $any$ O $any$ O O O $any$ O O O $void$ O O O O O O O $boolean$ O O O O O O $void$ O O O O O O O $string$ O $undefined$ O O O O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $number$ O $complex$ O $number)$ O O O O O O O O O $HTMLElement$ O $number$ O O O $HTMLElement$ O $number$ O O O $HTMLElement$ O $number$ O O O $HTMLElement$ O $number$ O O O O O $void$ O O O O O O O O O O O $any$ O O O $void$ O O O O O O O $boolean$ O O O O O O $void$ O O O O O $number$ O $complex$ O $number)$ O O O O O O O O O $HTMLElement$ O $number$ O O O O O $HTMLElement$ O $number$ O O O O O O $void$ O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $string$ O O O $string$ O $undefined$ O O O O O O O O O $boolean$ O O O O O O O $HTMLElement$ O O O O O $HTMLElement$ O $number$ O O O $HTMLElement$ O $number$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O O O $number$ O $undefined$ O O $complex$ O $void)$ O O O $number$ O O O O $number$ O $undefined$ O O O O
import { Directive , Input , HostListener , ElementRef , OnChanges , SimpleChanges , OnInit , OnDestroy , ContentChildren , QueryList } from 's' ; type limitType = 's' | 's' | 's' ; type userOptionsType = { dragLimit ? : limitType , enable ? : boolean , dragArea ? : boolean } ; @ Directive ( { selector : 's' , } ) export class DraggableDirective implements OnInit , OnDestroy , OnChanges { private keepSubscriptionAlive : boolean ; private userSelect : string ; private position : string ; private dragging : boolean ; private enabled : boolean ; private isDragArea : boolean ; private dragLimit : limitType ; private positionProperties : { left : { value : string , priority : string } , top : { value : string , priority : string } , right : { value : string , priority : string } , bottom : { value : string , priority : string } } ; private pos : { parent : { left : number , top : number , width : number , height : number , selfOffsetLeft : number , selfOffsetTop : number } , self : { left : number , top : number , width : number , height : number , mouseOffsetLeft : number , mouseOffsetTop : number } } ; @ Input ( 's' ) private userOptions : userOptionsType ; @ ContentChildren ( DraggableDirective ) childrenDirectives : QueryList < DraggableDirective > ; @ ContentChildren ( 's' , { read : ElementRef } ) childrenDragAreas : QueryList < ElementRef > ; redrawableChildren : DraggableDirective [ ] ; dragAreas : ElementRef [ ] ; constructor ( private elementRef ) { this . keepSubscriptionAlive = true ; this . userSelect = undefined ; this . position = undefined ; this . dragging = false ; this . enabled = true ; this . isDragArea = true ; this . dragLimit = 's' ; this . positionProperties = undefined ; this . redrawableChildren = [ ] ; this . dragAreas = [ ] ; this . pos = { parent : { left : 0 , top : 0 , width : 0 , height : 0 , selfOffsetLeft : 0 , selfOffsetTop : 0 } , self : { left : 0 , top : 0 , width : 0 , height : 0 , mouseOffsetLeft : 0 , mouseOffsetTop : 0 } } ; } @ HostListener ( 's' , [ 's' ] ) private onDragStart ( event ) { if ( this . dragging ) return false ; } @ HostListener ( 's' , [ 's' ] ) private onMousedown ( event ) { if ( this . enabled ) { if ( this . elementRef . nativeElement ) this . updatePosData ( true , event . clientX , event . clientY ) ; if ( this . canBeDragged ( event . target ) ) this . toggleDrag ( true ) ; } } @ HostListener ( 's' , [ 's' ] ) private onMouseup ( event ) { this . toggleDrag ( false ) ; } @ HostListener ( 's' , [ 's' ] ) private onMousemove ( event ) { if ( this . dragging && this . elementRef . nativeElement ) { this . updatePosData ( false , event . clientX , event . clientY ) ; this . savePosition ( ) ; this . saveUserSelect ( ) ; let el = ( < HTMLElement > this . elementRef . nativeElement ) ; el . style . setProperty ( 's' , this . calculateX ( event . clientX ) + 's' , 's' ) ; el . style . setProperty ( 's' , this . calculateY ( event . clientY ) + 's' , 's' ) ; this . redrawChildren ( ) ; } } private calculateX ( mouseX ) { let el = ( < HTMLElement > this . elementRef . nativeElement ) ; let newLeft = mouseX - this . pos . parent . left - this . pos . parent . selfOffsetLeft - this . pos . self . mouseOffsetLeft ; switch ( this . dragLimit ) { case 's' : return this . fitToLimits ( 0 - this . pos . parent . selfOffsetLeft , newLeft , this . pos . parent . width - this . pos . self . width - this . pos . parent . selfOffsetLeft ) ; case 's' : return this . fitToLimits ( 0 - this . pos . parent . left - this . pos . parent . selfOffsetLeft , newLeft , window . innerWidth - this . pos . self . width - this . pos . parent . left - this . pos . parent . selfOffsetLeft ) ; default : return newLeft ; } } private calculateY ( mouseY ) { let el = ( < HTMLElement > this . elementRef . nativeElement ) ; let newTop = mouseY - this . pos . parent . top - this . pos . parent . selfOffsetTop - this . pos . self . mouseOffsetTop ; switch ( this . dragLimit ) { case 's' : return this . fitToLimits ( 0 - this . pos . parent . selfOffsetTop , newTop , this . pos . parent . height - this . pos . self . height - this . pos . parent . selfOffsetTop ) ; case 's' : return this . fitToLimits ( 0 - this . pos . parent . top - this . pos . parent . selfOffsetTop , newTop , window . innerHeight - this . pos . self . height - this . pos . parent . top - this . pos . parent . selfOffsetTop ) ; default : return newTop ; } } private updatePosData ( onMouseDown , mouseX ? , mouseY ? , ) { let el = ( < HTMLElement > this . elementRef . nativeElement ) ; let rect = el . getBoundingClientRect ( ) ; if ( onMouseDown ) { this . pos . self . left = rect . left ; this . pos . self . top = rect . top ; if ( mouseX !== undefined ) this . pos . self . mouseOffsetLeft = mouseX - rect . left ; else this . pos . self . mouseOffsetLeft = 0 ; if ( mouseY !== undefined ) this . pos . self . mouseOffsetTop = mouseY - rect . top ; else this . pos . self . mouseOffsetTop = 0 ; } this . pos . self . width = rect . width ; this . pos . self . height = rect . height ; if ( el . parentElement ) { let parentRect = el . parentElement . getBoundingClientRect ( ) ; if ( onMouseDown ) { this . pos . parent . selfOffsetLeft = rect . left - parentRect . left - parseFloat ( window . getComputedStyle ( el , null ) . getPropertyValue ( 's' ) ) ; this . pos . parent . selfOffsetTop = rect . top - parentRect . top - parseFloat ( window . getComputedStyle ( el , null ) . getPropertyValue ( 's' ) ) ; } this . pos . parent . left = parentRect . left ; this . pos . parent . top = parentRect . top ; this . pos . parent . width = parentRect . width ; this . pos . parent . height = parentRect . height ; } else { if ( onMouseDown ) { this . pos . parent . selfOffsetLeft = rect . left ; this . pos . parent . selfOffsetLeft = rect . top ; } this . pos . parent . left = 0 ; this . pos . parent . top = 0 ; this . pos . parent . width = rect . width ; this . pos . parent . height = rect . height ; } } private fitToLimits ( min , value , max ) { if ( value > min ) { if ( value < max ) return value ; else return max ; } else return min ; } private saveUserSelect ( ) { if ( this . userSelect === undefined && this . elementRef . nativeElement ) { this . userSelect = ( < HTMLElement > this . elementRef . nativeElement ) . style . userSelect ; ( < HTMLElement > this . elementRef . nativeElement ) . style . userSelect = 's' ; } } private restoreUserSelect ( ) { if ( this . userSelect !== undefined && this . elementRef . nativeElement ) { ( < HTMLElement > this . elementRef . nativeElement ) . style . userSelect = this . userSelect ; this . userSelect = undefined ; } } private toggleDrag ( enable ? ) { if ( enable !== undefined ) { this . dragging = enable ; if ( ! enable ) this . restoreUserSelect ( ) ; } else this . toggleDrag ( ! this . dragging ) ; } private validateDragLimit ( stringValue ) { return new RegExp ( 's' ) . test ( stringValue ) ; } private savePosition ( ) { if ( this . positionProperties === undefined && this . elementRef . nativeElement ) { let el = ( < HTMLElement > this . elementRef . nativeElement ) ; this . positionProperties = { left : { value : el . style . getPropertyValue ( 's' ) , priority : el . style . getPropertyPriority ( 's' ) } , top : { value : el . style . getPropertyValue ( 's' ) , priority : el . style . getPropertyPriority ( 's' ) } , right : { value : el . style . getPropertyValue ( 's' ) , priority : el . style . getPropertyPriority ( 's' ) } , bottom : { value : el . style . getPropertyValue ( 's' ) , priority : el . style . getPropertyPriority ( 's' ) } } ; el . style . setProperty ( 's' , 's' , 's' ) ; el . style . setProperty ( 's' , 's' , 's' ) ; } } private parseRedrawableChildren ( children < DraggableDirective > ) { let redrawableChildren : DraggableDirective [ ] = [ ] ; children . toArray ( ) . forEach ( ( child ) => { if ( this . elementRef . nativeElement !== child . elementRef . nativeElement ) { if ( child . dragLimit === 's' || child . position === 's' ) redrawableChildren . push ( child ) ; } } ) ; this . redrawableChildren = redrawableChildren ; } private parseDragAreas ( directiveChildren < DraggableDirective > , areaChildren < ElementRef > ) { let dragAreas : ElementRef [ ] = [ ] ; let el = < HTMLElement > this . elementRef . nativeElement ; if ( el ) { let directiveArray = directiveChildren . toArray ( ) ; areaChildren . toArray ( ) . forEach ( ( child ) => { let childEl = < HTMLElement > child . nativeElement ; if ( childEl !== null && childEl !== el ) { let parentEl = childEl ; do { parentEl = parentEl . parentElement ; if ( directiveArray . filter ( item => item . elementRef . nativeElement === parentEl ) . length ) { if ( parentEl === el ) dragAreas . push ( child ) ; else break ; } } while ( parentEl ) ; } } ) ; } this . dragAreas = dragAreas ; } private redrawChildren ( ) { for ( let i = 0 ; i < this . redrawableChildren . length ; i ++ ) this . redrawableChildren [ i ] . recalculate ( ) ; } private recalculate ( ) { if ( ! this . dragging && this . elementRef . nativeElement ) { this . updatePosData ( true ) ; this . savePosition ( ) ; let el = ( < HTMLElement > this . elementRef . nativeElement ) ; el . style . setProperty ( 's' , this . calculateX ( this . pos . self . left ) + 's' , 's' ) ; el . style . setProperty ( 's' , this . calculateY ( this . pos . self . top ) + 's' , 's' ) ; } } private canBeDragged ( target ) { if ( target === this . elementRef . nativeElement ) return this . isDragArea ; else { for ( let i = 0 ; i < this . dragAreas . length ; i ++ ) { if ( target === this . dragAreas [ i ] . nativeElement ) return true ; } return false ; } } resetPosition ( ) { if ( this . positionProperties !== undefined && this . elementRef . nativeElement ) { let el = ( < HTMLElement > this . elementRef . nativeElement ) ; if ( this . positionProperties . left . value ) el . style . setProperty ( 's' , this . positionProperties . left . value , this . positionProperties . left . priority ) ; else el . style . removeProperty ( 's' ) ; if ( this . positionProperties . top . value ) el . style . setProperty ( 's' , this . positionProperties . top . value , this . positionProperties . top . priority ) ; else el . style . removeProperty ( 's' ) ; if ( this . positionProperties . right . value ) el . style . setProperty ( 's' , this . positionProperties . right . value , this . positionProperties . right . priority ) ; else el . style . removeProperty ( 's' ) ; if ( this . positionProperties . bottom . value ) el . style . setProperty ( 's' , this . positionProperties . bottom . value , this . positionProperties . bottom . priority ) ; else el . style . removeProperty ( 's' ) ; this . positionProperties = undefined ; } } ngAfterContentInit ( ) { this . parseRedrawableChildren ( this . childrenDirectives ) ; this . parseDragAreas ( this . childrenDirectives , this . childrenDragAreas ) ; this . childrenDirectives . changes . takeWhile ( ( ) => this . keepSubscriptionAlive ) . subscribe ( ( children < DraggableDirective > ) => { this . parseRedrawableChildren ( children ) ; } ) ; this . childrenDragAreas . changes . takeWhile ( ( ) => this . keepSubscriptionAlive ) . subscribe ( ( children < ElementRef > ) => { this . parseDragAreas ( this . childrenDirectives , children ) ; } ) ; } ngOnInit ( ) { if ( this . elementRef . nativeElement ) { this . position = window . getComputedStyle ( this . elementRef . nativeElement , null ) . getPropertyValue ( 's' ) ; if ( this . position === 's' ) { throw Error ( 's' ) ; } } else throw Error ( 's' ) ; } ngOnDestroy ( ) { this . keepSubscriptionAlive = false ; } ngOnChanges ( changes ) { if ( changes [ 's' ] ) { let value = ( < userOptionsType > changes [ 's' ] . currentValue ) ; if ( value . dragLimit !== undefined && this . validateDragLimit ( value . dragLimit ) ) this . dragLimit = value . dragLimit ; if ( value . enable !== undefined ) this . enabled = value . enable ; if ( value . dragArea !== undefined ) this . isDragArea = value . dragArea ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O $limitType$ O O $any$ O $boolean$ O O O O $boolean$ O O O O O O $any$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $limitType$ O $any$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O O O O $userOptionsType$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $DraggableDirective[]$ O $any$ O O O $any[]$ O $any$ O O O O O O $ElementRef$ O O O O $boolean$ O O O O O $string$ O $undefined$ O O O $string$ O $undefined$ O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $limitType$ O O O O O $complex$ O $undefined$ O O O $DraggableDirective[]$ O O O O O O $any[]$ O O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O O O O O O O O $boolean$ O $DragEvent$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O O O $void$ O $MouseEvent$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O $void$ O O O $MouseEvent$ O $number$ O $MouseEvent$ O $number$ O O O O O O $boolean$ O $MouseEvent$ O $EventTarget$ O O O O $void$ O O O O O O O $any$ O O O O O O O O $void$ O $MouseEvent$ O O O O $void$ O O O O O O $any$ O O O O O O O O $void$ O $DragEvent$ O O O O O O $boolean$ O O O $any$ O $any$ O O O O $void$ O O O $DragEvent$ O $number$ O $DragEvent$ O $number$ O O O O $void$ O O O O O $void$ O O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $number$ O $DragEvent$ O $number$ O O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $number$ O $DragEvent$ O $number$ O O O O O O O O O $void$ O O O O O O $number$ O $number$ O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O O $number$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O $limitType$ O O O O O O O O $number$ O O O O O $complex$ O $complex$ O $number$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O O O O $number$ O O O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O $number$ O O O O $number$ O $number$ O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O O $number$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O $limitType$ O O O O O O O O $number$ O O O O O $complex$ O $complex$ O $number$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O O O O $number$ O O O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O O $number$ O O O O $void$ O $boolean$ O $number$ $number$ O $number$ $number$ O O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O O $complex$ O $HTMLElement$ O $complex$ O O O O O $boolean$ O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $number$ O $undefined$ O O O $complex$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O O $complex$ O $complex$ O $number$ O O O O O $number$ O $undefined$ O O O $complex$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O O $complex$ O $complex$ O $number$ O O O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $HTMLElement$ O $HTMLElement$ O O O $complex$ O $HTMLElement$ O $HTMLElement$ O $complex$ O O O O O $boolean$ O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O $number$ O $complex$ O $CSSStyleDeclaration)$ O $HTMLElement$ O O O O $string$ O O O O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O $number$ O $complex$ O $CSSStyleDeclaration)$ O $HTMLElement$ O O O O $string$ O O O O O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O O O O $boolean$ O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O O $complex$ O $complex$ O $number$ O O O O O $complex$ O $complex$ O $number$ O O O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O $complex$ O $complex$ O $number$ O $complex$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O $number$ O $number$ O O O O $number$ O $number$ O O $number$ O O O $number$ O O O O $number$ O O O $void$ O O O O O O O $string$ O $undefined$ O O O $any$ O $any$ O O O O $string$ O O O $complex$ O O O $any$ O $any$ O O $CSSStyleDeclaration$ O $string$ O O O $complex$ O O O $any$ O $any$ O O $CSSStyleDeclaration$ O $string$ O O O O O O $void$ O O O O O O O $string$ O $undefined$ O O O $any$ O $any$ O O O O $complex$ O O O $any$ O $any$ O O $CSSStyleDeclaration$ O $string$ O O O $string$ O O O $string$ O $undefined$ O O O O $void$ O $boolean$ $boolean$ O O O O $boolean$ O $undefined$ O O O O $boolean$ O $boolean$ O O O O $boolean$ O O O $void$ O O O O O O O $void$ O O O O $boolean$ O O O O $boolean$ O $string$ O O O O $RegExpConstructor$ O O O O $boolean$ O $string$ O O O O $void$ O O O O O O O $complex$ O $undefined$ O O O $any$ O $any$ O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O O O $complex$ O O $complex$ O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $complex$ O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $complex$ O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $complex$ O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O O O O O O O $void$ O $QueryList$ O $any$ O O O O $DraggableDirective[]$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $DraggableDirective[]$ O $number$ O $any$ O O O O O O O O $DraggableDirective[]$ O $DraggableDirective[]$ O O O $void$ O $QueryList$ O $any$ O O $QueryList$ O $any$ O O O O $any[]$ O $any$ O O O O O O O $HTMLElement$ O O $complex$ O O O $any$ O $any$ O O O $HTMLElement$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O O $HTMLElement$ O O $complex$ O $any$ O $any$ O O O $HTMLElement$ O O O $HTMLElement$ O $HTMLElement$ O O O $HTMLElement$ O $HTMLElement$ O O O $HTMLElement$ O $HTMLElement$ O $HTMLElement$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $HTMLElement$ O O $any$ O O O O $HTMLElement$ O $HTMLElement$ O $any[]$ O $number$ O $any$ O O O O O O O O O $HTMLElement$ O O O O O O O O O $any[]$ O $any[]$ O O O $void$ O O O O O O $number$ O O O $number$ O O O $DraggableDirective[]$ O $number$ O $number$ O O O O $DraggableDirective[]$ O $number$ O O $void$ O O O O O $void$ O O O O O O O O $boolean$ O O O $any$ O $any$ O O O O $void$ O O O O O O $void$ O O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $number$ O O O $complex$ O $complex$ O $number$ O O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $number$ O O O $complex$ O $complex$ O $number$ O O O O O O O O O O $boolean$ O $EventTarget$ O O O O $EventTarget$ O O O $any$ O $any$ O O O O $boolean$ O O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O O O O O $EventTarget$ O O O $any[]$ O $number$ O O $any$ O O O O O O O O O O $void$ O O O O O O O $complex$ O $undefined$ O O O $any$ O $any$ O O O $HTMLElement$ O O O $complex$ O O O $any$ O $any$ O O O O O O $complex$ O $complex$ O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $complex$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O O O $complex$ O $complex$ O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $complex$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O O O $complex$ O $complex$ O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $complex$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O O O $complex$ O $complex$ O $string$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $complex$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $complex$ O $undefined$ O O O $void$ O O O O O $void$ O O O $any$ O O O O $void$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O $any$ O O $QueryList$ O $any$ O O O O O O $void$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O $any$ O O $QueryList$ O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O O $void$ O O O O O O O $any$ O $any$ O O O O $string$ O $complex$ O $CSSStyleDeclaration)$ O O O $any$ O $any$ O O O O $string$ O O O O O O O O $string$ O O O O O $ErrorConstructor$ O O O O O O O O $ErrorConstructor$ O O O O O $void$ O O O O O $boolean$ O O O O $void$ O $SimpleChanges$ O O O O $any$ O O O O O O $userOptionsType$ O O O $any$ O $any$ O O O O $any$ O O O O $userOptionsType$ O $limitType$ O $undefined$ O O O $boolean$ O $userOptionsType$ O $limitType$ O O O O $limitType$ O $userOptionsType$ O $limitType$ O O O $userOptionsType$ O $boolean$ O $undefined$ O O O $boolean$ O $userOptionsType$ O $boolean$ O O O $userOptionsType$ O $boolean$ O $undefined$ O O O $boolean$ O $userOptionsType$ O $boolean$ O O O O
import { Directive , Input , ViewContainerRef , TemplateRef } from "s" ; @ Directive ( { selector : 's' } ) export class VarDirective { @ Input ( ) set ngVar ( context ) { this . context . $implicit = this . context . ngVar = context ; this . updateView ( ) ; } context : any = { } ; constructor ( private vcRef , private templateRef < any > ) { } updateView ( ) { this . vcRef . clear ( ) ; this . vcRef . createEmbeddedView ( this . templateRef , this . context ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O O O O O O O O O $ViewContainerRef$ O O $TemplateRef$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { Component , OnInit , ElementRef , QueryList , ViewChildren , ViewChild , ChangeDetectionStrategy , Input , OnDestroy , ChangeDetectorRef } from 's' ; import { DraggableDirective } from 's' ; import { ThemeManager } from "s" ; import { LoggerService } from 's' ; import { Subscription } from "s" ; import * as paths from "s" ; import * as fs from 's' ; import * as path from 's' ; @ Component ( { selector : 's' , template : `template` , host : { 's' : 's' , 's' : "s" } , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class ThemeComponent implements OnInit { private subscriptions : Subscription = new Subscription ( ) ; private cssObserver : MutationObserver ; private currentColor : string = "s" ; private selectedKey : string = undefined ; private showThemePicker : boolean = false ; private themeManager : ThemeManager = new ThemeManager ( ) ; private stateVariables : { refreshingThemes : boolean , loadingTheme : boolean , savingTheme : boolean , deletingTheme : boolean } = { loadingTheme : false , refreshingThemes : false , savingTheme : false , deletingTheme : false } ; private availableThemes : string [ ] = [ ] ; @ ViewChildren ( 's' , { read : ElementRef } ) colorSquares : QueryList < ElementRef > ; @ ViewChild ( DraggableDirective ) themePicker : DraggableDirective ; @ Input ( ) themeInput : string ; constructor ( private loggerService , private changeRef ) { } private selectKey ( key ) { let colorValue = document . documentElement . style . getPropertyValue ( 's' + key ) ; if ( ! colorValue ) colorValue = this . themeManager . getColorRuleValue ( key ) ; this . currentColor = colorValue ; this . selectedKey = key ; } private refreshThemes ( ) { if ( ! this . stateVariables . refreshingThemes ) { this . stateVariables . refreshingThemes = true ; this . themeManager . getAvailableThemes ( ) . then ( ( themes ) => { this . availableThemes = themes ; this . stateVariables . refreshingThemes = false ; } ) . catch ( ( error ) => { this . loggerService . error ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; this . stateVariables . refreshingThemes = false ; } ) ; } else { this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; } } private resetColor ( ) { if ( this . selectedKey !== undefined ) this . onColorChange ( this . themeManager . getColorRuleValue ( this . selectedKey ) ) ; } private resetAllColors ( ) { document . documentElement . removeAttribute ( "s" ) ; this . selectedKey = undefined ; } private onColorChange ( color ) { this . currentColor = color ; if ( this . selectedKey !== undefined ) document . documentElement . style . setProperty ( 's' + this . selectedKey , color ) ; } private deleteColorTheme ( themeTitle ) { if ( ! themeTitle ) return this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; else if ( ! this . stateVariables . deletingTheme && ! this . stateVariables . loadingTheme ) { this . stateVariables . deletingTheme = true ; this . themeManager . readThemeTitle ( true ) . then ( ( currentThemeTitle ) => { if ( currentThemeTitle === themeTitle ) { this . stateVariables . loadingTheme = true ; this . resetAllColors ( ) ; this . themeManager . removeInjectedColorRules ( ) ; return this . themeManager . saveThemeTitle ( 's' ) ; } } ) . then ( ( ) => { return this . themeManager . deleteColorFile ( themeTitle ) ; } ) . then ( ( ) => { this . stateVariables . loadingTheme = false ; this . stateVariables . deletingTheme = false ; this . refreshThemes ( ) ; this . loggerService . success ( `template` , { invokeAlert : true , alertTimeout : 0 } ) ; } ) . catch ( ( error ) => { this . stateVariables . loadingTheme = false ; this . stateVariables . deletingTheme = false ; this . loggerService . error ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } else { this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; } } private loadColorTheme ( themeTitle ) { if ( ! themeTitle ) return this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; else if ( ! this . stateVariables . loadingTheme && ! this . stateVariables . deletingTheme ) { if ( this . availableThemes . indexOf ( themeTitle ) === - 0 ) return this . loggerService . info ( `template` , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . stateVariables . loadingTheme = true ; this . themeManager . readFromColorFile ( themeTitle , false ) . then ( ( ) => { return this . themeManager . saveThemeTitle ( themeTitle ) ; } ) . then ( ( ) => { this . themeManager . injectColorRules ( ) ; this . resetAllColors ( ) ; this . stateVariables . loadingTheme = false ; this . loggerService . success ( `template` , { invokeAlert : true , alertTimeout : 0 } ) ; } ) . catch ( ( error ) => { this . stateVariables . loadingTheme = false ; this . loggerService . error ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } else { this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; } } private saveColorRules ( themeTitle ) { if ( ! this . stateVariables . savingTheme ) { if ( process . env . NODE_ENV === 's' ) { if ( ! themeTitle ) return this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . stateVariables . savingTheme = true ; this . themeManager . updateValuesFromDOM ( ) ; this . themeManager . saveToColorFile ( themeTitle ) . then ( ( ) => { return this . themeManager . saveThemeTitle ( themeTitle ) ; } ) . then ( ( ) => { this . themeManager . injectColorRules ( ) ; this . resetAllColors ( ) ; this . stateVariables . savingTheme = false ; this . refreshThemes ( ) ; this . loggerService . success ( `template` , { invokeAlert : true , alertTimeout : 0 } ) ; } ) . catch ( ( error ) => { this . stateVariables . savingTheme = false ; this . loggerService . error ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } else { this . stateVariables . savingTheme = true ; this . themeManager . updateValuesFromDOM ( ) ; this . themeManager . saveToDevColorFile ( ) . then ( ( ) => { this . stateVariables . savingTheme = false ; this . loggerService . success ( 's' , { invokeAlert : true , alertTimeout : 0 } ) ; } ) . catch ( ( error ) => { this . stateVariables . savingTheme = false ; this . loggerService . error ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; this . loggerService . error ( error ) ; } ) ; } } else { this . loggerService . info ( 's' , { doNotAppendToLog : true , invokeAlert : true , alertTimeout : 0 } ) ; } } private hotkeys ( event ) { if ( this . themePicker && process . env . NODE_ENV !== 's' ) { if ( event . key === 's' && event . altKey ) { this . showThemePicker = ! this . showThemePicker ; } else if ( event . key === 's' && event . altKey ) { this . themePicker . resetPosition ( ) ; } } } private styleColorSquares ( colorSquares < ElementRef > ) { if ( colorSquares ) { colorSquares . toArray ( ) . forEach ( ( square ) => { if ( square . nativeElement ) { let el = < HTMLElement > square . nativeElement ; el . style . cssText = `template` ; } } ) ; } } ngAfterViewInit ( ) { this . styleColorSquares ( this . colorSquares ) ; this . subscriptions . add ( this . colorSquares . changes . subscribe ( ( colorSquares < ElementRef > ) => { this . styleColorSquares ( colorSquares ) ; } ) ) ; this . cssObserver = new MutationObserver ( mutations => { this . themeManager . readFromStylesheets ( 's' ) ; } ) ; this . cssObserver . observe ( document . head , { childList : true } ) ; } ngOnInit ( ) { this . themeManager . readFromStylesheets ( 's' ) ; this . refreshThemes ( ) ; } ngOnDestroy ( ) { this . subscriptions . unsubscribe ( ) ; this . cssObserver . disconnect ( ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O O O O O O O O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $MutationObserver$ O $complex$ O O $string$ O O O O O O $string$ O O O $undefined$ O O $boolean$ O O O O O O $ThemeManager$ O $any$ O O $any$ O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O O O $string[]$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $DraggableDirective$ O $any$ O O $any$ O O $string$ O O O O O O $LoggerService$ O O $ChangeDetectorRef$ O O O O $void$ O $string$ O O O $string$ O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $string$ O O O O O $string$ O $string$ O O O $ThemeManager$ O $any$ O $string$ O O O O $string$ O $string$ O O O $string$ O $string$ O O O $void$ O O O O O O O O $complex$ O $boolean$ O O O O $complex$ O $boolean$ O O O O O $ThemeManager$ O $Promise<string[]>$ O O O O O O $string[]$ O O O O O $string[]$ O $string[]$ O O O $complex$ O $boolean$ O O O O O O $complex$ O O $any$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O $complex$ O $boolean$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O $void$ O O O O O O O $string$ O $undefined$ O O O $void$ O O O $ThemeManager$ O $any$ O O O $string$ O O O O O $void$ O O O $Document$ O $HTMLElement$ O $void$ O O O O O O $string$ O $undefined$ O O O $void$ O $string$ O O O O $string$ O $string$ O O O O O $string$ O $undefined$ O $Document$ O $HTMLElement$ O $CSSStyleDeclaration$ O $void$ O O O O O $string$ O $string$ O O O O $void$ O $string$ O O O O O $string$ O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O O O O $complex$ O $boolean$ O O O O $complex$ O $boolean$ O O O O $complex$ O $boolean$ O O O O O $ThemeManager$ O $Promise<string>$ O O O O O O O $string$ O O O O O $string$ O $string$ O O O O $complex$ O $boolean$ O O O O O $void$ O O O O O $ThemeManager$ O $void$ O O O O O O $ThemeManager$ O $Promise<unknown>$ O O O O O O O O O O O O O O O O O $ThemeManager$ O $Promise<unknown>$ O $string$ O O O O O O O O O O O O O $complex$ O $boolean$ O O O O O $complex$ O $boolean$ O O O O O $void$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $number$ O O O O O O O O $complex$ O O $any$ O O O O O $complex$ O $boolean$ O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O $void$ O $string$ O O O O O $string$ O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O O O O $complex$ O $boolean$ O O O O $complex$ O $boolean$ O O O O O O $string[]$ O $number$ O $string$ O O O O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $complex$ O $boolean$ O O O O O $ThemeManager$ O $Promise<boolean>$ O $string$ O O O O O O O O O O O O O $ThemeManager$ O $Promise<unknown>$ O $string$ O O O O O O O O O O O O O $ThemeManager$ O $void$ O O O O O $void$ O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $number$ O O O O O O O O $complex$ O O $any$ O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O $void$ O $string$ O O O O O O O $complex$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $complex$ O $boolean$ O O O O O $ThemeManager$ O $void$ O O O O O $ThemeManager$ O $Promise<boolean>$ O $string$ O O O O O O O O O O O $ThemeManager$ O $Promise<unknown>$ O $string$ O O O O O O O O O O O O O $ThemeManager$ O $void$ O O O O O $void$ O O O O O $complex$ O $boolean$ O O O O O $void$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $number$ O O O O O O O O $complex$ O O $any$ O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O O O $complex$ O $boolean$ O O O O O $ThemeManager$ O $void$ O O O O O $ThemeManager$ O $Promise<boolean>$ O O O O O O O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $number$ O O O O O O O O $complex$ O O $any$ O O O O O $complex$ O $boolean$ O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O $LoggerService$ O $void$ O $any$ O O O O O O O O O O O $LoggerService$ O $void$ O O O O $true$ O O O $true$ O O O $number$ O O O O O O O O $void$ O $KeyboardEvent$ O O O O O O $DraggableDirective$ O $any$ O $any$ O $any$ O O O O O O $KeyboardEvent$ O $string$ O O O $KeyboardEvent$ O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O $KeyboardEvent$ O $string$ O O O $KeyboardEvent$ O $boolean$ O O O O $DraggableDirective$ O $void$ O O O O O O O $void$ O $QueryList$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O $HTMLElement$ O O $complex$ O $any$ O $any$ O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O O O O $void$ O O O O O $void$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $QueryList$ O $any$ O O O O O O $void$ O $any$ O O O O O O O O $MutationObserver$ O O $complex$ O $MutationRecord[]$ O O O O $ThemeManager$ O $void$ O O O O O O O O O $MutationObserver$ O $void$ O $Document$ O $HTMLHeadElement$ O O $true$ O O O O O O $void$ O O O O O $ThemeManager$ O $void$ O O O O O O $void$ O O O O $void$ O O O O O $any$ O $any$ O O O O O $MutationObserver$ O $void$ O O O O O
import { Component , forwardRef , ElementRef , Optional , Host , HostListener , Input , ContentChildren , QueryList , ChangeDetectorRef } from 's' ; import { NgOptionComponent } from "s" ; import { NG_VALUE_ACCESSOR , ControlValueAccessor } from 's' ; import * as _ from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , host : { 's' : 's' } , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => NgSelectComponent ) , multi : true } ] } ) export class NgSelectComponent implements ControlValueAccessor { private open : boolean = false ; private idCounter : number = - 0 ; private selectedIds : number [ ] = [ ] ; private optionsMap = new Map < number , { value : any , displayValue : string } > ( ) ; private displayValue : string = 's' ; private currentValue : any [ ] = [ ] ; private onChange = ( _ ) => { } ; private onTouched = ( ) => { } ; @ ContentChildren ( forwardRef ( ( ) => NgOptionComponent ) ) private optionComponents : QueryList < NgOptionComponent > ; @ Input ( ) private placeholder : string = 's' ; @ Input ( ) private multiple : boolean = false ; @ Input ( ) private allowEmpty : boolean = false ; @ Input ( ) private separator : string = 's' ; @ Input ( ) private sort : boolean = true ; @ Input ( ) private emitOnly : boolean = false ; constructor ( private element , private changeRef ) { } registerOption ( ) { return ++ this . idCounter ; } unregisterOption ( id ) { if ( this . selectedIds . indexOf ( id ) !== - 0 ) { let emptyState = this . allowEmpty ; this . allowEmpty = true ; this . selectOption ( id , true , true ) ; this . allowEmpty = emptyState ; } this . optionsMap . delete ( id ) ; } setOption ( id , data : { value : any , displayValue : string } ) { this . optionsMap . set ( id , data ) ; } selectOption ( id , toggle , suppressChanges = false ) { if ( this . optionsMap . has ( id ) ) { let valueChanged = true ; let selectedIds = this . selectedIds ; if ( this . multiple ) { let selectedIdIndex = selectedIds . indexOf ( id ) ; if ( selectedIdIndex === - 0 ) { selectedIds = selectedIds . concat ( id ) ; } else { if ( ( this . allowEmpty || selectedIds . length > 0 ) && toggle ) selectedIds . splice ( selectedIdIndex , 0 ) ; else valueChanged = false ; } } else { if ( selectedIds . length === 0 ) selectedIds = [ id ] ; else if ( selectedIds [ 0 ] !== id ) selectedIds [ 0 ] = id ; else { if ( this . allowEmpty && toggle ) selectedIds = [ ] ; else valueChanged = false ; } } if ( valueChanged ) { let displayValues : string [ ] = [ ] ; let currentValue = [ ] ; for ( let i = 0 ; i < selectedIds . length ; i ++ ) { currentValue . push ( this . optionsMap . get ( selectedIds [ i ] ) . value ) ; displayValues . push ( this . optionsMap . get ( selectedIds [ i ] ) . displayValue ) ; } if ( displayValues . length > 0 && this . sort ) { displayValues = displayValues . sort ( ) ; } if ( ! this . emitOnly ) { this . displayValue = displayValues . length > 0 ? displayValues . join ( this . separator ) : displayValues [ 0 ] ; this . currentValue = currentValue ; this . selectedIds = selectedIds ; this . optionComponents . forEach ( ( option ) => { option . toggleSelected ( this . selectedIds . indexOf ( option . getId ( ) ) !== - 0 ) ; } ) ; } if ( ! suppressChanges ) { this . onChange ( this . multiple ? currentValue : ( currentValue [ 0 ] || null ) ) ; } this . changeRef . markForCheck ( ) ; } if ( ! suppressChanges ) { this . open = this . open && this . multiple ; this . onTouched ( ) ; } } } clearOptions ( ) { this . selectedIds = [ ] ; this . currentValue = [ ] ; this . displayValue = 's' ; if ( this . optionComponents ) { this . optionComponents . forEach ( ( option ) => { option . toggleSelected ( false ) ; } ) ; } } @ Input ( ) set value ( value ) { this . writeValue ( value , false ) ; } get value ( ) { return this . multiple ? this . currentValue : ( this . currentValue [ 0 ] || null ) ; } writeValue ( value , suppressChanges = true ) { let optionIndex = this . getOptionId ( value ) ; if ( optionIndex !== - 0 ) this . selectOption ( optionIndex , false , suppressChanges ) ; else if ( value instanceof Array ) { for ( let i = 0 ; i < value . length ; i ++ ) this . writeValue ( value [ i ] , suppressChanges ) ; } else this . clearOptions ( ) ; } registerOnChange ( fn : ( value ) => any ) { this . onChange = fn ; } registerOnTouched ( fn : ( ) => any ) { this . onTouched = fn ; } @ HostListener ( 's' , [ 's' ] ) onClick ( event ) { if ( ! ( < HTMLElement > this . element . nativeElement ) . contains ( < Node > event . target ) ) this . open = false ; } private getOptionId ( value ) { for ( let [ id , val ] of this . optionsMap ) { if ( _ . isEqual ( val . value , value ) ) { return id ; } } return - 0 ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O O O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $boolean$ O O O O O O $number$ O O O O O O O $number[]$ O O O O O O O O O $complex$ O O $MapConstructor$ O O O O $any$ O O O $string$ O O O O O O O O $string$ O O O O O O $any[]$ O O O O O O O O O $void$ O O $any$ O O O O O O $void$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $string$ O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $boolean$ O O O O O O O O $ElementRef$ O O $ChangeDetectorRef$ O O O $number$ O O O O O O O $number$ O O $void$ O $number$ O O O O O O $number[]$ O $number$ O $number$ O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $void$ O $number$ O O O O O O O O $boolean$ O $boolean$ O O O O $complex$ O $boolean$ O $number$ O O O $void$ O $number$ O $complex$ O O $any$ O O O $string$ O O O O O O O $complex$ O $complex$ O $number$ O $complex$ O O O $void$ O $number$ O $boolean$ O $boolean$ O O O O O O O O $complex$ O $boolean$ O $number$ O O O O $boolean$ O O O O $number[]$ O O O $number[]$ O O O O O $boolean$ O O O $number$ O $number[]$ O $number$ O $number$ O O O O $number$ O O O O O $number[]$ O $number[]$ O $complex$ O $number$ O O O O O O O O O O $boolean$ O $number[]$ O $number$ O O O O $boolean$ O $number[]$ O $complex$ O $number$ O O O O O $boolean$ O O O O O O O O O $number[]$ O $number$ O O O $number[]$ O O $number$ O O O O O $number[]$ O O O O $number$ O $number[]$ O O O O $number$ O O O O O O O $boolean$ O $boolean$ O $number[]$ O O O O O $boolean$ O O O O O O O $boolean$ O O O $string[]$ O O O O O O O O O $any[]$ O O O O O O O $number$ O O O $number$ O $number[]$ O $number$ O $number$ O O O $any[]$ O $number$ O O O $complex$ O $complex$ O $number[]$ O $number$ O O O $any$ O O $string[]$ O $number$ O O O $complex$ O $complex$ O $number[]$ O $number$ O O O $string$ O O O O O $string[]$ O $number$ O O O O O $boolean$ O O $string[]$ O $string[]$ O $string[]$ O O O O O O O O O $boolean$ O O O O $string$ O $string[]$ O $number$ O O O $string[]$ O $string$ O O O $string$ O O $string[]$ O O O O O O $any[]$ O $any[]$ O O O $number[]$ O $number[]$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $number[]$ O $number$ O $any$ O $any$ O O O O O O O O O O O O O O O $boolean$ O O O O $void$ O O O $boolean$ O $any[]$ O O $any[]$ O O O O O O O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $void$ O O O O O O $void$ O O O O O $number[]$ O O O O O O $any[]$ O O O O O O $string$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O O O O O O $any$ O O O O O O $boolean$ O O O $any[]$ O O O O $any[]$ O O O O O O O O $void$ O $any$ O $boolean$ O O O O O $number$ O O O $number$ O $any$ O O O O $number$ O O O O O O $void$ O $number$ O O O $boolean$ O O O O O $any$ O $ArrayConstructor$ O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O O O O $void$ O $any[]$ O $number$ O O $boolean$ O O O O O O $void$ O O O O $void$ O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O $any$ O O O O O O O $void$ O $MouseEvent$ O O O O O O O $complex$ O O O $any$ O $any$ O O $boolean$ O O O O $MouseEvent$ O $EventTarget$ O O O O $boolean$ O O O O O $number$ O $any$ O O O O O O $number$ O $complex$ O O O O $complex$ O O O O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $number$ O O O O O O O O O
import { Component , ElementRef , Optional , Host , HostListener , Input } from 's' ; import { NgSelectComponent } from "s" ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , host : { 's' : 's' , } } ) export class NgOptionComponent { private id : number ; private value : any ; private valueString : string ; private isSelected : boolean = false ; constructor ( private element , @ Optional ( ) @ Host ( ) private select ) { if ( this . select ) this . id = this . select . registerOption ( ) ; } @ Input ( ) set ngValue ( value ) { this . value = value ; if ( this . select ) this . select . setOption ( this . id , { value : this . value , displayValue : JSON . stringify ( this . value ) } ) ; } @ HostListener ( 's' ) onClick ( ) { if ( this . select ) this . select . selectOption ( this . id , true ) ; } getId ( ) { return this . id ; } toggleSelected ( selected ) { this . isSelected = selected ; } ngAfterViewChecked ( ) { if ( this . element . nativeElement ) { this . valueString = ( < HTMLElement > this . element . nativeElement ) . innerHTML . trim ( ) ; if ( this . valueString ) { if ( this . value === undefined ) this . value = this . valueString ; if ( this . select ) this . select . setOption ( this . id , { value : this . value , displayValue : this . valueString } ) ; } } } ngOnDestroy ( ) { if ( this . select ) this . select . unregisterOption ( this . id ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O O O O O O O O O $any$ O O $number$ O O O O $any$ O O O O $string$ O O O O $boolean$ O O O O O O O O $ElementRef$ O O $any$ O O O $any$ O O O $NgSelectComponent$ O O O O O O $NgSelectComponent$ O O O $number$ O O O $NgSelectComponent$ O $number$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $NgSelectComponent$ O O O $NgSelectComponent$ O $void$ O O O $number$ O O $any$ O O O $any$ O $string$ O $JSON$ O $complex$ O O O $any$ O O O O O O $any$ O O O $void$ O O O O O O O $NgSelectComponent$ O O O $NgSelectComponent$ O $void$ O O O $number$ O O O O O $number$ O O O O O O $number$ O O $void$ O $boolean$ O O O O $boolean$ O $boolean$ O O $void$ O O O O O O O $any$ O $any$ O O O O $string$ O O O $complex$ O O O $any$ O $any$ O O $string$ O $string$ O O O O O O O $string$ O O O O O O $any$ O $undefined$ O O O $any$ O O O $string$ O O O O O $NgSelectComponent$ O O O $NgSelectComponent$ O $void$ O O O $number$ O O $any$ O O O $any$ O $string$ O O O $string$ O O O O O O $void$ O O O O O O O $NgSelectComponent$ O O O $NgSelectComponent$ O $void$ O O O $number$ O O O O
import { Component , forwardRef , Input , ChangeDetectorRef } from 's' ; import { NG_VALUE_ACCESSOR , ControlValueAccessor } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => NgToggleButtonComponent ) , multi : true } ] } ) export class NgToggleButtonComponent implements ControlValueAccessor { @ Input ( 's' ) private contentOnLeft : boolean ; private currentValue : boolean = false ; private onChange = ( _ ) => { } ; private onTouched = ( ) => { } ; constructor ( private changeRef ) { } @ Input ( ) set value ( value ) { this . writeValue ( value ) ; } get value ( ) { return this . currentValue ; } writeValue ( value ) { let previousValue = this . currentValue ; value = ! ! value ; if ( value !== this . currentValue ) { this . currentValue = value ; this . onChange ( this . currentValue ) ; this . changeRef . markForCheck ( ) ; } this . onTouched ( ) ; } registerOnChange ( fn : ( value ) => any ) { this . onChange = fn ; } registerOnTouched ( fn : ( ) => any ) { this . onTouched = fn ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $boolean$ O O O O $boolean$ O O O O O O $void$ O O $any$ O O O O O O $void$ O O O O O O O O O O $ChangeDetectorRef$ O O O O $any$ O O O $boolean$ O $boolean$ O O O O $void$ O $boolean$ O O O O $boolean$ O O O O O O $boolean$ O O $void$ O $any$ O O O $boolean$ O O O $boolean$ O $any$ O O O $any$ O O O $any$ O O O $boolean$ O O O O $boolean$ O $any$ O O O $void$ O O O $boolean$ O O O O $any$ O $any$ O O O O O O $void$ O O O O $void$ O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O
import { Component , forwardRef , ElementRef , Input , Output , ViewChild , HostListener , EventEmitter } from 's' ; import { NG_VALUE_ACCESSOR , ControlValueAccessor } from 's' ; @ Component ( { selector : 's' , template : `template` , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => NgPathInputComponent ) , multi : true } ] } ) export class NgPathInputComponent implements ControlValueAccessor { @ ViewChild ( 's' , { read : ElementRef } ) private fileInput : ElementRef ; private currentValue : string = null ; private onChange = ( _ ) => { } ; private onTouched = ( ) => { } ; @ Input ( ) private directory : boolean = false ; @ Input ( ) private stateless : boolean = false ; @ Output ( ) private pathChange : EventEmitter < string > = new EventEmitter ( ) ; constructor ( ) { } @ HostListener ( 's' ) onClick ( ) { if ( this . fileInput && this . fileInput . nativeElement ) { let fileInput = < HTMLInputElement > this . fileInput . nativeElement ; fileInput . click ( ) ; } } private readInput ( ) { let fileInput = < HTMLInputElement > this . fileInput . nativeElement ; if ( fileInput . files && fileInput . files . length ) { this . writeValue ( fileInput . files [ 0 ] . path ) ; fileInput . value = null ; } } @ Input ( ) set value ( value ) { this . writeValue ( value ) ; } get value ( ) { return this . currentValue ; } writeValue ( value ) { let oldValue = this . currentValue ; if ( value !== oldValue ) { this . currentValue = this . stateless ? null : value ; this . onChange ( value ) ; this . pathChange . next ( value ) ; } this . onTouched ( ) ; } registerOnChange ( fn : ( value ) => any ) { this . onChange = fn ; } registerOnTouched ( fn : ( ) => any ) { this . onTouched = fn ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O O O O $void$ O O $any$ O O O O O O $void$ O O O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O O $void$ O O O O O O O $any$ O O O $any$ O $any$ O O O $HTMLInputElement$ O O $complex$ O O O $any$ O $any$ O $HTMLInputElement$ O $void$ O O O O O O $void$ O O O O $HTMLInputElement$ O O $complex$ O O O $any$ O $any$ O O O $HTMLInputElement$ O $FileList$ O $HTMLInputElement$ O $FileList$ O $number$ O O O O $void$ O $HTMLInputElement$ O $FileList$ O O O O $any$ O O $HTMLInputElement$ O $string$ O O O O O O $any$ O O O $string$ O $string$ O O O O $void$ O $string$ O O O O $string$ O O O O O O $string$ O O $void$ O $any$ O O O $string$ O O O $string$ O O O $any$ O $string$ O O O O $string$ O O O $boolean$ O O O $any$ O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $void$ O O O O $void$ O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O
import { Component , Input , Output , ChangeDetectionStrategy , OnInit , EventEmitter , ViewEncapsulation , ChangeDetectorRef } from 's' ; import { FormGroup , FormControl , AbstractControl , ValidatorFn } from 's' ; import { NestedFormElement , NestedFormInputs , NestedFormElements } from "s" ; import { Observable } from "s" ; import * as _ from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush , encapsulation : ViewEncapsulation . None } ) export class NgNestedFormComponent implements OnInit { private currentForm : FormGroup = new FormGroup ( { } ) ; @ Input ( ) public parentForm : FormGroup ; @ Input ( ) public groupName : string ; @ Input ( ) public nestedGroup : NestedFormElement . Group ; @ Output ( ) private parentFormChange = new EventEmitter ( ) ; constructor ( private changeRef ) { } ngOnInit ( ) { this . currentForm = this . buildFromTemplate ( this . nestedGroup ) ; if ( this . groupName ) this . parentForm . setControl ( this . groupName , this . currentForm ) ; else this . parentFormChange . next ( this . currentForm ) ; } private getHiddenMethod ( el ) { if ( el [ 's' ] === undefined ) { if ( el . isHidden !== undefined ) { el [ 's' ] = el . isHidden ( ) ; } else { el [ 's' ] = null ; } } return el [ 's' ] ; } private buildFromTemplate ( group : NestedFormElement . Group ) { let formGroup = new FormGroup ( { } ) ; formGroup [ 's' ] = this . groupName ? ( this . parentForm ? this . parentForm [ 's' ] : null as Array < string > || [ ] ) . concat ( this . groupName ) : [ ] ; for ( let childKey in group . children ) { if ( group . children [ childKey ] instanceof NestedFormElement . Group === false ) { let child = group . children [ childKey ] as NestedFormInputs ; let formControl = new FormControl ( ) ; formControl [ 's' ] = formGroup [ 's' ] . concat ( childKey ) ; formControl . reset ( { value : child . initialValue || null , disabled : child . disabled || false } , { onlySelf : true , emitEvent : false } ) ; let callbacks : ValidatorFn [ ] = [ ] ; if ( child . onValidate ) { callbacks . push ( ( c ) => { let error = child . onValidate ( c , c [ 's' ] ) ; return error ? { error } : null ; } ) ; } if ( child . onChange ) { callbacks . push ( ( c ) => { child . onChange ( c , c [ 's' ] ) ; return null ; } ) ; } formControl . setValidators ( callbacks ) ; formGroup . setControl ( childKey , formControl ) ; } } return formGroup ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $string$ O O O O $any$ O O O $Group$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O O O O O O $ChangeDetectorRef$ O O O $void$ O O O O O $any$ O O O $any$ O O O $Group$ O O O O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $NestedFormElements$ O O O O $NestedFormElements$ O O O O $undefined$ O O O O $NestedFormElements$ O $NestedInputHidden$ O $undefined$ O O $NestedFormElements$ O O O O $NestedFormElements$ O $NestedInputHidden$ O O O O O O $NestedFormElements$ O O O O O O O O O $NestedFormElements$ O O O O O O $any$ O $Group$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O O O O O O $string$ O O O O $any$ O O O $any$ O O O O O O $ArrayConstructor$ O O O O O O O O $any$ O O O $string$ O O O O O O O O $string$ O $Group$ O $complex$ O O O O $Group$ O $complex$ O $string$ O O $any$ O $any$ O O O O O $NestedFormInputs$ O $Group$ O $complex$ O $string$ O O $any$ O O $any$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $string$ O O $any$ O $any$ O O $any$ O $NestedFormInputs$ O $any$ O O O $boolean$ O $NestedFormInputs$ O $boolean$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any[]$ O $any$ O O O O O O O O $NestedFormInputs$ O $NestedInputValidator$ O O $any[]$ O $number$ O O $any$ O O O O $string$ O $NestedFormInputs$ O $NestedInputValidator$ O $any$ O $any$ O O O O O O $string$ O O $string$ O O O O O O O O O O $NestedFormInputs$ O $NestedInputChange$ O O $any[]$ O $number$ O O $any$ O O O $NestedFormInputs$ O $NestedInputChange$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O O O
import { Component , forwardRef , Input , ChangeDetectorRef , 0 , SimpleChanges , ViewChild , ElementRef } from 's' ; import { NG_VALUE_ACCESSOR , ControlValueAccessor } from 's' ; import * as rangy from 's' ; import * as he from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => NgTextInputComponent ) , multi : true } ] , host : { 's' : 's' } } ) export class NgTextInputComponent implements ControlValueAccessor { private currentValue : string = null ; @ ViewChild ( "s" ) private elementRef : ElementRef ; @ Input ( ) private placeholder : string = null ; @ Input ( ) private highlight : ( input , tag ) => string = null ; @ Input ( ) private highlightTag : string = null ; @ Input ( ) private multiline : boolean = false ; @ Input ( ) private dragAndDrop : boolean = false ; private onChange = ( _ ) => { } ; private onTouched = ( ) => { } ; private handlePaste ( event ) { event . preventDefault ( ) ; let data = event . clipboardData . getData ( 's' ) ; if ( ! this . multiline ) data = data . replace ( "s" , 's' ) ; if ( data ) { if ( this . currentValue && this . currentValue . length > 0 ) { let selection = this . saveSelection ( this . elementRef . nativeElement ) ; let newSelection = selection . start + data . length ; this . writeValue ( `template` , true , { start : newSelection , end : newSelection } ) ; } else { this . writeValue ( data , true , { start : data . length , end : data . length } ) ; } } } private handleKeypress ( event ) { if ( ! this . multiline && event . key === 's' ) event . preventDefault ( ) ; } private handleDragAndDrop ( event ) { if ( ! this . dragAndDrop ) event . preventDefault ( ) ; } private setInnerHtml ( data , selection ? : { start : number , end : number } ) { if ( this . elementRef . nativeElement ) { if ( data ) { selection = selection || ( document . activeElement === this . elementRef . nativeElement && data . length > 0 ? this . saveSelection ( this . elementRef . nativeElement ) : null ) ; if ( this . highlight ) data = this . highlight ( data , this . highlightTag || 's' ) ; data = he . encode ( data ) ; if ( this . highlight ) { data = data . replace ( new RegExp ( `template` , 's' ) , ( match ) => { return he . decode ( match ) ; } ) ; } this . renderer . setProperty ( this . elementRef . nativeElement , 's' , data ) ; if ( selection ) this . restoreSelection ( this . elementRef . nativeElement , selection ) ; } else this . renderer . setProperty ( this . elementRef . nativeElement , 's' , null ) ; } } private saveSelection ( containerEl ) { let charIndex = 0 ; let start = 0 ; let end = 0 ; let foundStart = false ; let stop = { } ; let sel = rangy . getSelection ( ) ; let traverseTextNodes = ( node , range ) => { if ( node . nodeType === Node . TEXT_NODE ) { if ( ! foundStart && node === range . startContainer ) { start = charIndex + range . startOffset ; foundStart = true ; } if ( foundStart && node === range . endContainer ) { end = charIndex + range . endOffset ; throw stop ; } charIndex += ( node as Text ) . length ; } else { for ( let i = 0 ; i < node . childNodes . length ; ++ i ) { traverseTextNodes ( node . childNodes [ i ] , range ) ; } } } if ( sel . rangeCount ) { try { traverseTextNodes ( containerEl , sel . getRangeAt ( 0 ) ) ; } catch ( ex ) { if ( ex !== stop ) { throw ex ; } } } return { start : start , end : end } ; } private restoreSelection ( containerEl , savedSel : { start : number , end : number } ) { let charIndex = 0 ; let foundStart = false ; let stop = { } ; let range = rangy . createRange ( ) range . collapseToPoint ( containerEl , 0 ) ; let traverseTextNodes = ( node ) => { if ( node . nodeType === Node . TEXT_NODE ) { var nextCharIndex = charIndex + ( node as Text ) . length ; if ( ! foundStart && savedSel . start >= charIndex && savedSel . start <= nextCharIndex ) { range . setStart ( node , savedSel . start - charIndex ) ; foundStart = true ; } if ( foundStart && savedSel . end >= charIndex && savedSel . end <= nextCharIndex ) { range . setEnd ( node , savedSel . end - charIndex ) ; throw stop ; } charIndex = nextCharIndex ; } else { for ( let i = 0 ; i < node . childNodes . length ; ++ i ) { traverseTextNodes ( node . childNodes [ i ] ) ; } } } try { traverseTextNodes ( containerEl ) ; } catch ( ex ) { if ( ex === stop ) { rangy . getSelection ( ) . setSingleRange ( range ) ; } else { throw ex ; } } } constructor ( private changeRef , private renderer ) { } @ Input ( ) set value ( value ) { this . writeValue ( value ) ; } get value ( ) { return this . currentValue ; } writeValue ( value , updateDom = true , selection ? : { start : number , end : number } ) { let previousValue = this . currentValue ; if ( value !== this . currentValue ) { this . currentValue = value ; if ( updateDom || this . highlight ) this . setInnerHtml ( value , selection ) ; this . onChange ( this . currentValue ) ; this . changeRef . markForCheck ( ) ; } this . onTouched ( ) ; } registerOnChange ( fn : ( value ) => any ) { this . onChange = fn ; } registerOnTouched ( fn : ( ) => any ) { this . onTouched = fn ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $boolean$ O O O O O $complex$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $string$ O O O O O O $any$ O O O $string$ O O $string$ O $string$ O O O O O O O $any$ O O O $string$ O O O O O O $any$ O O O $boolean$ O O O O O O $any$ O O O $boolean$ O O O O O O $void$ O O $any$ O O O O O O $void$ O O O O O O O O $void$ O $ClipboardEvent$ O O $ClipboardEvent$ O $void$ O O O O $string$ O $ClipboardEvent$ O $DataTransfer$ O $string$ O O O O O O O O O $boolean$ O $string$ O $string$ O $complex$ O O O O O O O O $string$ O O O O O O $string$ O O O $string$ O $number$ O O O O O $complex$ O O O $complex$ O O O $any$ O $any$ O O O $number$ O $complex$ O $number$ O $string$ O $number$ O O O $void$ O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O $void$ O $string$ O O O O $number$ O $string$ O $number$ O $number$ O $string$ O $number$ O O O O O O O $void$ O $KeyboardEvent$ O O O O O O O $boolean$ O $KeyboardEvent$ O $string$ O O O $KeyboardEvent$ O $void$ O O O O O $void$ O $Event$ O O O O O O O $boolean$ O $Event$ O $void$ O O O O O $void$ O $string$ O $complex$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O O $string$ O O $complex$ O $complex$ O O $Document$ O $Element$ O O O $any$ O $any$ O $string$ O $number$ O O O O O $complex$ O O O $any$ O $any$ O O O O O O O O O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O O $string$ O $string$ O $complex$ O O $RegExpConstructor$ O O O O O O O $string$ O O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O O O $complex$ O O O $void$ O O O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $complex$ O $HTMLElement$ O O O $number$ O O O O $number$ O O O O $number$ O O O O $boolean$ O O O O ${}$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O $Node$ O $Range$ O O O O O $Node$ O $number$ O O O $number$ O O O O O $boolean$ O $Node$ O $Range$ O $Node$ O O $number$ O $number$ O $Range$ O $number$ O $boolean$ O O O O O O $boolean$ O $Node$ O $Range$ O $Node$ O O $number$ O $number$ O $Range$ O $number$ O O ${}$ O O $number$ O O $Node$ O $complex$ O O $number$ O O O O O O O $number$ O O O $number$ O $Node$ O $NodeListOf<ChildNode>$ O $number$ O O $number$ O O $void$ O $Node$ O $NodeListOf<ChildNode>$ O $number$ O O $Range$ O O O O O O O $any$ O $any$ O O O O $void$ O $HTMLElement$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O ${}$ O O O $any$ O O O O O O $number$ O $number$ O $number$ O $number$ O O O O $void$ O $HTMLElement$ O $complex$ O O $number$ O O O $number$ O O O O O O $number$ O O O O $boolean$ O O O O ${}$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $HTMLElement$ O O O O O $void$ O O $Node$ O O O O O $Node$ O $number$ O O O $number$ O O O $number$ O $number$ O O $Node$ O $complex$ O O $number$ O O O O $boolean$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O $number$ O O $any$ O $any$ O $Node$ O $complex$ O $number$ O $number$ O O $boolean$ O O O O O O $boolean$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O $number$ O O $any$ O $any$ O $Node$ O $complex$ O $number$ O $number$ O O O ${}$ O O $number$ O $number$ O O O O O O O $number$ O O O $number$ O $Node$ O $NodeListOf<ChildNode>$ O $number$ O O $number$ O O $void$ O $Node$ O $NodeListOf<ChildNode>$ O $number$ O O O O O O O O $void$ O $HTMLElement$ O O O O O $any$ O O O O $any$ O ${}$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $ChangeDetectorRef$ O O $Renderer2$ O O O O $any$ O O O $string$ O $string$ O O O O $void$ O $string$ O O O O $string$ O O O O O O $string$ O O $void$ O $string$ O $boolean$ O O O $complex$ O O O $number$ O O O $number$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O $string$ O O O $void$ O $string$ O $complex$ O O O O $void$ O O O $string$ O O O O $any$ O $any$ O O O O O O $void$ O O O O $void$ O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O
import { Component , ChangeDetectionStrategy , ChangeDetectorRef , OnDestroy } from 's' ; import { SettingsService , PreviewService , LanguageService , ImageProviderService , FuzzyService , CustomVariablesService , ConfigurationPresetsService } from "s" ; import { APP } from 's' ; import { AppSettings } from "s" ; import { Subscription } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class SettingsComponent implements OnDestroy { private subscriptions : Subscription = new Subscription ( ) ; private settings : AppSettings ; private availableProviders : string [ ] ; private availableLanguages : string [ ] ; constructor ( private settingsService , private fuzzyService , private languageService , private imageProviderService , private previewService , private cpService , private cvService , private changeDetectionRef ) { } ngOnInit ( ) { this . subscriptions . add ( this . settingsService . getChangeObservable ( ) . subscribe ( ( ) => { this . changeDetectionRef . detectChanges ( ) ; } ) ) ; this . settings = this . settingsService . getSettings ( ) ; this . availableProviders = this . imageProviderService . instance . getAvailableProviders ( ) ; this . availableLanguages = this . languageService . getAvailableLanguages ( ) ; } ngOnDestroy ( ) { this . subscriptions . unsubscribe ( ) ; } private get lang ( ) { return APP . lang . settings . component ; } private onSettingsChange ( detectChanges = true ) { if ( detectChanges ) this . settingsService . settingsChanged ( ) ; this . settingsService . saveAppSettings ( ) ; } private removeApps ( ) { if ( this . settings . knownSteamDirectories . length > 0 ) this . previewService . saveData ( true ) ; } private resetFuzzy ( ) { this . fuzzyService . fuzzyLoader . resetList ( ) ; } private clearFuzzy ( ) { this . fuzzyService . fuzzyLoader . resetCache ( ) ; } private preload ( value ) { if ( this . settings . previewSettings . preload !== value && value ) this . previewService . preloadImages ( ) ; this . settings . previewSettings . preload = value ; } private loadLanguage ( ) { this . languageService . loadLanguage ( this . settings . language ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $GlobalContainer$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $AppSettings$ O $any$ O O $string[]$ O O O O O O $string[]$ O O O O O O O O $SettingsService$ O O $FuzzyService$ O O $LanguageService$ O O $ImageProviderService$ O O $PreviewService$ O O $ConfigurationPresetsService$ O O $CustomVariablesService$ O O $ChangeDetectorRef$ O O O $void$ O O O O O $any$ O $any$ O O O $SettingsService$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $AppSettings$ O O O $SettingsService$ O $AppSettings$ O O O O O $string[]$ O O O $ImageProviderService$ O $ImageProvider$ O $string[]$ O O O O O $string[]$ O O O $LanguageService$ O $string[]$ O O O O $void$ O O O O O $any$ O $any$ O O O O O O O O O O O $GlobalContainer$ O $languageStruct$ O O O O O O O $void$ O $boolean$ O O O O O O $boolean$ O O O $SettingsService$ O $void$ O O O O O $SettingsService$ O $void$ O O O O O $void$ O O O O O O O $AppSettings$ O $string[]$ O $number$ O O O O O $PreviewService$ O $Promise<boolean>$ O O O O O O $void$ O O O O O $FuzzyService$ O $FuzzyListLoader$ O $Promise<void>$ O O O O O $void$ O O O O O $FuzzyService$ O $FuzzyListLoader$ O $Promise<any>$ O O O O O $void$ O $boolean$ O O O O O O $AppSettings$ O $PreviewSettings$ O $boolean$ O $boolean$ O $boolean$ O O O $PreviewService$ O $void$ O O O O O $AppSettings$ O $PreviewSettings$ O $boolean$ O $boolean$ O O O $void$ O O O O O $LanguageService$ O $void$ O O O $AppSettings$ O $string$ O O O O
import { Component , ElementRef , Input , SimpleChanges , OnChanges , ViewEncapsulation , 0 } from 's' ; import { MarkdownService } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class MarkdownComponent { @ Input ( ) content : string ; constructor ( private renderer , private elementRef , private markdownService ) { } ngOnChanges ( _ ) { if ( this . content && this . elementRef ) { this . renderer . setProperty ( this . elementRef . nativeElement , 's' , this . markdownService . compile ( this . content ) ) ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O $string$ O O O O O O $Renderer2$ O O $ElementRef$ O O $MarkdownService$ O O O $void$ O $SimpleChanges$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $MarkdownService$ O $any$ O O O $string$ O O O O O O
import { Component } from 's' ; import { APP } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] } ) export class AboutComponent { private get lang ( ) { return APP . lang . about . component ; } }	O O $any$ O O O O O O $GlobalContainer$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O O $complex$ O O O O $GlobalContainer$ O $languageStruct$ O $complex$ O $complex$ O O O
import { Component } from 's' ; @ Component ( { selector : 's' , template : `template` , styleUrls : [ 's' ] } ) export class CustomVariablesComponent { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class SelectArrowLeftComponent { @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class SelectArrowRightComponent { @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class SelectArrowDownComponent { @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class RefreshImagesComponent { @ Input ( ) title : string ; @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $string$ O O O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class ImageAlertComponent { @ Input ( ) title : string ; @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $string$ O O O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class AddImagesComponent { @ Input ( ) title : string ; @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $string$ O O O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , template : `template` , host : { viewBox : "s" , version : "s" , xmlns : "s" , 's' : 's' , 's' : 's' } , styles : [ `template` ] } ) export class CopyIconComponent { @ Input ( ) title : string ; @ Input ( ) hover : boolean ; @ Input ( ) active : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $string$ O O O O $any$ O O $boolean$ O O O O $any$ O O $boolean$ O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PipeTransform , Pipe } from 's' ; @ Pipe ( { name : 's' } ) export class KeysPipe implements PipeTransform { transform ( value ) { let keys = [ ] ; for ( let key in value ) keys . push ( key ) ; return keys ; } } @ Pipe ( { name : 's' } ) export class KeyPipe implements PipeTransform { transform ( value , index ) { return Object . keys ( value ) [ index ] ; } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any[]$ O $any$ O O O $any[]$ O O O O O O O $string$ O $any$ O $any[]$ O $number$ O $string$ O O O $any[]$ O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $string$ O $any$ O $number$ O O O $ObjectConstructor$ O $complex$ O $any$ O O $number$ O O O O
import { PipeTransform , Pipe } from 's' ; import { DomSanitizer } from 's' ; @ Pipe ( { name : 's' } ) export class SafeHtml { constructor ( private sanitizer ) { } transform ( html ) { return this . sanitizer . bypassSecurityTrustHtml ( html ) ; } } @ Pipe ( { name : 's' } ) export class SafeStyle { constructor ( private sanitizer ) { } transform ( style ) { return this . sanitizer . bypassSecurityTrustStyle ( style ) ; } } @ Pipe ( { name : 's' } ) export class SafeResourceUrl { constructor ( private sanitizer ) { } transform ( resourceUrl ) { return this . sanitizer . bypassSecurityTrustResourceUrl ( resourceUrl ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O O O $DomSanitizer$ O O O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O O $any$ O O $string$ O O O O O O $any$ O O O O $DomSanitizer$ O O O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O O $any$ O O $string$ O O O O O O $any$ O O O O $DomSanitizer$ O O O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O
import { Pipe , PipeTransform } from 's' ; @ Pipe ( { name : 's' } ) export class ArrayConcatPipe implements PipeTransform { transform ( value : any [ ] , newValue : any | any [ ] ) { return value . concat ( newValue ) ; } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any[]$ O $any[]$ O O O O O $any$ O O O O O O O O O $any[]$ O $complex$ O $any$ O O O O
import { Pipe , PipeTransform } from 's' ; const Fuzzy = require ( 's' ) ; @ Pipe ( { name : 's' } ) export class FuzzyTestPipe implements PipeTransform { transform ( inputString , query ) { return query . length > 0 ? Fuzzy . score ( inputString , query , { usePathScoring : false } ) !== 0 : true ; } }	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $string$ O O O $string$ O $number$ O O O $any$ O $any$ O $string$ O $string$ O O $boolean$ O O O O O O O O O O O
import { PipeTransform , Pipe } from 's' ; import * as url from 's' ; @ Pipe ( { name : 's' } ) export class FileImage { transform ( filePath ) { return url . encodeFile ( filePath ) ; } }	O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O $string$ O $string$ O O O $any$ O $string$ O $string$ O O O O
import { PipeTransform , Pipe } from 's' ; @ Pipe ( { name : 's' } ) export class CssUrl { transform ( filePath ) { return `template` ; } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $string$ O $string$ O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { CanActivate , ActivatedRouteSnapshot } from 's' ; @ Injectable ( ) export class HrefGuard implements CanActivate { constructor ( ) { } canActivate ( ) { return false ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O
export * from 's' ;	O O O O O
import { ModuleWithProviders } from 's' ; import { Routes , RouterModule } from 's' ; import { AppComponent , PreviewComponent , LoggerComponent , ParsersComponent , SettingsComponent , AboutComponent , CustomVariablesComponent } from 's' ; import { HrefGuard } from 's' ; const AppRouter = [ { path : 's' , component : PreviewComponent } , { path : 's' , component : PreviewComponent } , { path : 's' , component : LoggerComponent } , { path : 's' , component : CustomVariablesComponent } , { path : 's' , component : SettingsComponent } , { path : 's' , component : ParsersComponent } , { path : 's' , component : AboutComponent } , { path : 's' , component : AppComponent , canActivate : [ HrefGuard ] } ] ; export const AppRoutes = RouterModule . forRoot ( AppRouter , { useHash : true , initialNavigation : false } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $Routes$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O O O O O O $ModuleWithProviders$ O $any$ O $any$ O $any$ O O $boolean$ O O O $boolean$ O O O O O
import { NgModule } from 's' ; import { BrowserModule , Title } from 's' ; import { BrowserAnimationsModule } from 's' ; import { HttpModule } from 's' ; import { FormsModule , ReactiveFormsModule } from 's' ; import { DatePipe , APP_BASE_HREF } from 's' ; import { ColorPickerModule } from 's' ; import * as Components from 's' ; import * as SvgComponents from 's' ; import * as Services from 's' ; import * as Directives from 's' ; import * as Pipes from 's' ; import * as Guards from 's' ; import { AppRoutes } from 's' ; function ngObjectsToArray ( importObject ) { let objectArray : any [ ] = [ ] ; for ( let attribute in importObject ) { if ( typeof importObject [ attribute ] === 's' ) objectArray . push ( importObject [ attribute ] ) ; } return objectArray ; } @ NgModule ( { imports : [ BrowserModule , BrowserAnimationsModule , HttpModule , AppRoutes , FormsModule , ReactiveFormsModule , ColorPickerModule ] , declarations : [ ] . concat ( ngObjectsToArray ( Components ) , ngObjectsToArray ( SvgComponents ) , ngObjectsToArray ( Directives ) , ngObjectsToArray ( Pipes ) ) , providers : [ ] . concat ( ngObjectsToArray ( Services ) , ngObjectsToArray ( Guards ) , { provide : APP_BASE_HREF , useValue : 's' } , DatePipe , Title ) , bootstrap : [ Components . AppComponent ] } ) export class AppModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any[]$ O $any$ O O O $any[]$ O O O O O O O O O O O $string$ O $any$ O O O O O $any$ O $string$ O O O O $any[]$ O $number$ O $any$ O $string$ O O O O O $any[]$ O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O O O $complex$ O $any[]$ O $any$ O O $any[]$ O $any$ O O $any[]$ O $any$ O O $any[]$ O $any$ O O O $any[]$ O O O O $complex$ O $any[]$ O $any$ O O $any[]$ O $any$ O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O O O O $any$ O O
import 's' ; import 's' ; import 's' ; import 's' ; import { enableProdMode } from 's' ; import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; import 's' ; import 's' ; import 's' ; if ( process . env . NODE_ENV === 's' ) enableProdMode ( ) ; platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) ;	O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O O
'js' let path = require ( 's' ) ; module . exports = { root : function ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) ; return path . join . apply ( path , [ path . resolve ( __dirname , 's' ) ] . concat ( args ) ) ; } } ;	O O $any$ O $any$ O O O O $complex$ O $complex$ O O $any$ O O O $any$ O O $any$ O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $IArguments$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $complex$ O $any$ O O O O O O
'js' let helpers = require ( 's' ) ; let webpack = require ( 's' ) ; let merge = require ( 's' ) ; let clientConfig = { target : 's' , entry : { main : 's' } , context : helpers . root ( 's' ) , output : { filename : 's' , path : helpers . root ( 's' ) } , resolve : { extensions : [ 's' , 's' ] } , module : { rules : [ { test : "s" , use : [ 's' ] } ] } , node : { __dirname : false } } ; let developmentConfig = { devtool : 's' , performance : { hints : false } , output : { devtoolModuleFilenameTemplate : function ( info ) { return "s" + encodeURI ( info . absoluteResourcePath ) ; } } } ; let productionConfig = { bail : process . env . TRAVIS ? JSON . parse ( process . env . TRAVIS ) : false } ; if ( process . env . NODE_ENV === 's' ) module . exports = merge ( clientConfig , productionConfig ) ; else module . exports = merge ( clientConfig , developmentConfig ) ;	O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O $any$ O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $any$ O $complex$ O $any$ O O O O O $complex$ O O $string[]$ O O O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string[]$ O O O O O O O O $complex$ O O $boolean$ O O O O O O $complex$ O O $string$ O O O $complex$ O O $boolean$ O O O O $complex$ O O $string$ O O O $any$ O O O O O $string$ O $any$ O $any$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $JSON$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O
'js' 's' ; module . exports = function ( source ) { var re = new RegExp ( "s" , 's' ) ; return source . replace ( re , 's' ) ; } ;	O O O $any$ O $any$ O O O $any$ O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $any$ O $any$ O $RegExp$ O O O O O O
'js' let helpers = require ( 's' ) ; let webpack = require ( 's' ) ; let merge = require ( 's' ) ; let HtmlWebpackPlugin = require ( 's' ) ; let ExtractTextPlugin = require ( "s" ) ; let GlobalStyle = new ExtractTextPlugin ( 's' ) ; let clientConfig = { target : 's' , entry : { renderer : 's' , polyfill : [ 's' , 's' ] } , context : helpers . root ( 's' ) , output : { filename : 's' , path : helpers . root ( 's' , 's' ) , publicPath : "s" } , resolve : { extensions : [ 's' , 's' ] } , module : { rules : [ { test : "s" , use : [ 's' , 's' ] } , { test : "s" , exclude : "s" , use : [ 's' , 's' ] } , { test : "s" , loader : GlobalStyle . extract ( [ 's' , 's' , 's' ] ) } , { test : "s" , exclude : "s" , use : [ 's' , 's' , 's' , 's' ] } , { test : "s" , use : 's' } , { test : "s" , use : 's' } , { test : "s" , use : { loader : 's' , options : { attrs : [ 's' , 's' ] } } } , { test : "s" , use : [ 's' , 's' , helpers . root ( 's' , 's' ) ] } ] } , plugins : [ new webpack . optimize . CommonsChunkPlugin ( { names : [ 's' ] } ) , new HtmlWebpackPlugin ( { filename : helpers . root ( 's' , 's' , 's' ) , template : helpers . root ( 's' , 's' , 's' ) } ) , new webpack . ContextReplacementPlugin ( "s" , helpers . root ( 's' ) ) , GlobalStyle ] } ; let developmentConfig = { devtool : 's' , performance : { hints : false } , output : { devtoolModuleFilenameTemplate : function ( info ) { return "s" + encodeURI ( info . absoluteResourcePath ) ; } } } ; let productionConfig = { bail : process . env . TRAVIS ? JSON . parse ( process . env . TRAVIS ) : false , plugins : [ new webpack . DefinePlugin ( { 's' : JSON . stringify ( process . env . NODE_ENV ) } ) , ] } ; if ( process . env . NODE_ENV === 's' ) module . exports = merge ( clientConfig , productionConfig ) ; else module . exports = merge ( clientConfig , developmentConfig ) ;	O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O $any$ O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $any$ O $complex$ O $any$ O O O O O O $string$ O O O O $complex$ O O $string[]$ O O O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string[]$ O O O O O O O O O $RegExp$ O O O $RegExp$ O O O $string[]$ O O O O O O O O O $RegExp$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $RegExp$ O O O $RegExp$ O O O $string[]$ O O O O O O O O O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O $RegExp$ O O O $any[]$ O O O O O O $complex$ O $any$ O O O O O O O O O O $any[]$ O O O $any$ O $any$ O $any$ O O $string[]$ O O O O O O O O $any$ O O $any$ O $complex$ O $any$ O O O O O O O O $any$ O $complex$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O $complex$ O $any$ O O O O O $any$ O O O O $complex$ O O $string$ O O O $complex$ O O $boolean$ O O O O $complex$ O O $string$ O O O $any$ O O O O O $string$ O $any$ O $any$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $JSON$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O $any$ O O O O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O