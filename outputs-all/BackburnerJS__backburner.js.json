'js' var Backburner = require ( 's' ) . default ; function sharedSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } , anotherMethod : function ( ) { } } ; var 0 = null ; var 0 = null ; } module . exports = [ { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { backburner . debounce ( target . someMethod , 0 ) ; backburner . debounce ( target . anotherMethod , 0 ) ; 0 = backburner . debounce ( target . someMethod , 0 ) ; 0 = backburner . debounce ( target . anotherMethod , 0 ) ; } , teardown : function ( ) { backburner . cancel ( 0 ) ; backburner . cancel ( 0 ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { backburner . debounce ( target , 's' , 0 ) ; backburner . debounce ( target , 's' , 0 ) ; 0 = backburner . debounce ( target , 's' , 0 ) ; 0 = backburner . debounce ( target , 's' , 0 ) ; backburner . cancel ( 0 ) ; backburner . cancel ( 0 ) ; } , teardown : function ( ) { 0 = null 0 = null } } ] ;	O O $any$ O $any$ O O O O $any$ O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O $void$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $void$ O O O O O $any$ O O $any$ O O O O O O
'js' var Backburner = require ( 's' ) . default ; function sharedSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } } ; } module . exports = [ { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . later ( null , target . someMethod , 0 ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . later ( target , 's' , 0 ) ; backburner . cancel ( timer ) ; } } ] ;	O O $any$ O $any$ O O O O $any$ O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O O O O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O
'js' var Backburner = require ( 's' ) . default ; function sharedSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } } ; } module . exports = [ { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . schedule ( 's' , function ( ) { } ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . schedule ( 's' , target , function ( ) { } ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . schedule ( 's' , target , 's' ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . schedule ( 's' , target , 's' , 's' ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { var timer = backburner . schedule ( 's' , target , 's' , 's' , 's' ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : function ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } } ; var prescheduleSetupIterations = 0 ; while ( prescheduleSetupIterations -- ) { backburner . schedule ( 's' , function ( ) { } ) ; } } , fn : function ( ) { var timer = backburner . schedule ( 's' , target , 's' ) ; backburner . cancel ( timer ) ; } } , { name : 's' , Backburner : Backburner , setup : function ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } } ; var prescheduleSetupIterations = 0 ; while ( prescheduleSetupIterations -- ) { backburner . schedule ( 's' , function ( ) { } ) ; } } , fn : function ( ) { var timer = backburner . schedule ( 's' , target , 's' ) ; backburner . cancel ( timer ) ; } } ] ;	O O $any$ O $any$ O O O O $any$ O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O O O O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O O O $number$ O O O O O $number$ O O O $any$ O $any$ O O O O O O O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O O O $number$ O O O O O $number$ O O O $any$ O $any$ O O O O O O O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O
'js' var Backburner = require ( 's' ) . default ; function prodSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } } ; } function debugSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; backburner . DEBUG = true ; var target = { someMethod : function ( ) { } } ; } let scenarios = [ ] ; let base = [ { name : 's' , Backburner : Backburner , fn : function ( ) { backburner . begin ( ) ; backburner . schedule ( 's' , function ( ) { } ) ; backburner . end ( ) ; } } , { name : 's' , Backburner : Backburner , fn : function ( ) { backburner . begin ( ) ; backburner . schedule ( 's' , target , function ( ) { } ) ; backburner . end ( ) ; } } , { name : 's' , Backburner : Backburner , fn : function ( ) { backburner . begin ( ) ; backburner . schedule ( 's' , target , 's' ) ; backburner . end ( ) ; } } , { name : 's' , Backburner : Backburner , fn : function ( ) { backburner . begin ( ) ; backburner . schedule ( 's' , target , 's' , 's' ) ; backburner . end ( ) ; } } , { name : 's' , Backburner : Backburner , fn : function ( ) { backburner . begin ( ) ; backburner . schedule ( 's' , target , 's' , 's' , 's' ) ; backburner . end ( ) ; } } ] ; base . forEach ( item => { let prodItem = Object . assign ( { } , item ) ; prodItem . setup = prodSetup ; scenarios . push ( prodItem ) ; } ) ; base . forEach ( item => { let debugItem = Object . assign ( { } , item ) ; debugItem . name = `template` ; debugItem . setup = debugSetup ; scenarios . push ( debugItem ) ; } ) ; module . exports = scenarios ;	O O $any$ O $any$ O O O O $any$ O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O O O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O $complex$ O O $void$ O O O O O O O O O O $any[]$ O O O O O $complex$ O O O $string$ O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $complex$ O $void$ O $complex$ O O O $complex$ O $ObjectConstructor$ O O O O O O $complex$ O O $complex$ O $any$ O $void$ O $any[]$ O $number$ O $complex$ O O O O O $complex$ O $void$ O $complex$ O O O $complex$ O $ObjectConstructor$ O O O O O O $complex$ O O $complex$ O $string$ O O O $complex$ O $any$ O $void$ O $any[]$ O $number$ O $complex$ O O O O O $any[]$ O $any[]$ O $any[]$ O
'js' var Backburner = require ( 's' ) . default ; function sharedSetup ( ) { var backburner = new this . Backburner ( [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ) ; var target = { someMethod : function ( ) { } , anotherMethod : function ( ) { } } ; var 0 = null ; var 0 = null ; } module . exports = [ { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { backburner . throttle ( target . someMethod , 0 ) ; backburner . throttle ( target . anotherMethod , 0 ) ; 0 = backburner . throttle ( target . someMethod , 0 ) ; 0 = backburner . throttle ( target . anotherMethod , 0 ) ; } , teardown : function ( ) { backburner . cancel ( 0 ) ; backburner . cancel ( 0 ) ; 0 = null 0 = null } } , { name : 's' , Backburner : Backburner , setup : sharedSetup , fn : function ( ) { backburner . throttle ( target , 's' , 0 ) ; backburner . throttle ( target , 's' , 0 ) ; 0 = backburner . throttle ( target , 's' , 0 ) ; 0 = backburner . throttle ( target , 's' , 0 ) ; backburner . cancel ( 0 ) ; backburner . cancel ( 0 ) ; } , teardown : function ( ) { 0 = null 0 = null } } ] ;	O O $any$ O $any$ O O O O $any$ O O $void$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O $complex$ O O $void$ O O O O O O O $void$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O $string$ O O O $any$ O $any$ O $void$ O $void$ O $void$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $void$ O O O O O $any$ O O $any$ O O O O O O
'js' var glob = require ( 's' ) ; var path = require ( 's' ) ; var bench = require ( 's' ) ; var fileGlob = 's' ; if ( process . argv [ 0 ] ) { fileGlob = process . argv [ 0 ] ; console . log ( fileGlob ) ; } var suites = [ ] ; glob . sync ( fileGlob ) . forEach ( function ( file ) { var exported = require ( path . resolve ( file ) ) ; if ( Array . isArray ( exported ) ) { suites = suites . concat ( exported ) ; } else { suites . push ( exported ) ; } } ) ; bench ( suites ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $string$ O O O O O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O O $Console$ O $void$ O $string$ O O O O $any[]$ O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O O O O $any[]$ O $number$ O $any$ O O O O O O $any$ O $any[]$ O O
'js' 's' ; const MergeTrees = require ( 's' ) ; const Funnel = require ( 's' ) ; const Rollup = require ( 's' ) ; const resolve = require ( 's' ) ; const commonjs = require ( 's' ) ; const path = require ( 's' ) ; const typescript = require ( 's' ) . default ; const buble = require ( 's' ) ; const fs = require ( 's' ) ; const SOURCE_MAPPING_DATA_URL = 's' + 's' ; module . exports = function ( app ) { const src = new MergeTrees ( [ new Funnel ( __dirname + 's' , { destDir : 's' } ) , new Funnel ( __dirname + 's' , { destDir : 's' } ) ] ) ; const compiled = typescript ( src , { throwOnError : process . env . EMBER_ENV === 's' , } ) ; const backburner = new Rollup ( compiled , { rollup : { input : 's' , output : { file : 's' , format : 's' , sourcemap : true } , format : 's' , plugins : [ loadWithInlineMap ( ) ] } } ) ; return new MergeTrees ( [ backburner , new Rollup ( compiled , { rollup : { input : 's' , plugins : [ loadWithInlineMap ( ) , buble ( ) ] , output : [ { file : 's' , exports : 's' , format : 's' , amd : { id : 's' } , sourcemap : true } , { file : 's' , format : 's' , sourcemap : true } ] } } ) , new Rollup ( compiled , { annotation : 's' , rollup : { input : 's' , external : [ 's' ] , plugins : [ resolve ( { module : false , main : true } ) , commonjs ( ) , loadWithInlineMap ( ) , buble ( ) ] , output : [ { file : 's' , format : 's' , amd : { id : 's' } , sourcemap : true } ] } } ) , new Funnel ( path . dirname ( require . resolve ( 's' ) ) , { annotation : 's' , destDir : 's' , files : [ 's' , 's' ] } ) , new Funnel ( path . dirname ( require . resolve ( 's' ) ) , { annotation : 's' , destDir : 's' , files : [ 's' ] } ) , new Funnel ( __dirname + 's' , { destDir : 's' , files : [ 's' ] } ) ] , { annotation : 's' } ) ; } ; function loadWithInlineMap ( ) { return { load : function ( id ) { var code = fs . readFileSync ( id , 's' ) ; var result = { code : code , map : null } ; var index = code . lastIndexOf ( SOURCE_MAPPING_DATA_URL ) ; if ( index === - 0 ) { return result ; } result . code = code . slice ( 0 , index ) ; result . map = parseSourceMap ( code . slice ( index + SOURCE_MAPPING_DATA_URL . length ) ) ; result . file = id ; return result ; } } ; } function parseSourceMap ( 0 ) { return JSON . parse ( new Buffer ( 0 , 's' ) . toString ( 's' ) ) ; }	O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $string$ O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O $any$ O O $any$ O O $any$ O $any$ O O $complex$ O O $string$ O O O $any[]$ O O $complex$ O O O $any$ O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O $boolean$ O O O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $string[]$ O O O O O $any[]$ O O $any$ O O $boolean$ O O O $boolean$ O O O O O $any$ O O O $complex$ O O O $any$ O O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O $boolean$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O O O O O O $complex$ O O O O O $complex$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $any$ O $any$ O $null$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O O O $complex$ O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $number$ O O O $complex$ O $any$ O $any$ O O $complex$ O O O O O O O O $any$ O O O $JSON$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O O O
export interface IQueueItem { method : string ; target : Object ; args : Object [ ] ; stack : string | undefined ; }	O O $any$ O $string$ O O O $Object$ O $ObjectConstructor$ O $Object[]$ O $ObjectConstructor$ O O O $string$ O O O O O O
import { IQueueItem } from 's' ; type MaybeError = Error | undefined ; const NUMBER = "s" ; const enum QueueItemPosition { target , method , args , stack } export const TIMERS_OFFSET = 0 ; export function isCoercableNumber ( suspect ) { let type = typeof suspect ; return type === 's' && suspect === suspect || type === 's' && NUMBER . test ( suspect ) ; } export function getOnError ( options ) { return options . onError || ( options . onErrorTarget && options . onErrorTarget [ options . onErrorMethod ] ) ; } export function findItem ( target , method , collection ) { let index = - 0 ; for ( let i = 0 , l = collection . length ; i < l ; i += 0 ) { if ( collection [ i ] === target && collection [ i + 0 ] === method ) { index = i ; break ; } } return index ; } export function findTimerItem ( target , method , collection ) { let index = - 0 ; for ( let i = 0 , l = collection . length ; i < l ; i += 0 ) { if ( collection [ i ] === target && collection [ i + 0 ] === method ) { index = i - 0 ; break ; } } return index ; } export function getQueueItems ( items : any [ ] , queueItemLength , queueItemPositionOffset = 0 ) : IQueueItem [ ] { let queueItems : IQueueItem [ ] = [ ] ; for ( let i = 0 ; i < items . length ; i += queueItemLength ) { let maybeError = items [ i + QueueItemPosition . stack + queueItemPositionOffset ] ; let queueItem = { target : items [ i + QueueItemPosition . target + queueItemPositionOffset ] , method : items [ i + QueueItemPosition . method + queueItemPositionOffset ] , args : items [ i + QueueItemPosition . args + queueItemPositionOffset ] , stack : maybeError !== undefined && 's' in maybeError ? maybeError . stack : 's' } ; queueItems . push ( queueItem ) ; } return queueItems ; }	O O $any$ O O O O O $any$ O $ErrorConstructor$ O O O O $RegExp$ O O O O O $any$ O $QueueItemPosition.target$ O $QueueItemPosition.method$ O $QueueItemPosition.args$ O $QueueItemPosition.stack$ O O O O O O O O O $boolean$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $RegExp$ O $boolean$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $number$ O $any$ O $any$ O $any$ O O O $number$ O O O O O O O $number$ O O O $any$ O $any$ O $any$ O $number$ O $any$ O $number$ O O O O O O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O $any$ O O $number$ O $number$ O O O O O O $number$ O O O O $number$ O $any$ O $any$ O $any$ O O O $number$ O O O O O O O $number$ O O O $any$ O $any$ O $any$ O $number$ O $any$ O $number$ O O O O O O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O $any$ O O $number$ O $number$ O O O O O O O O $number$ O O O O $IQueueItem[]$ O $any[]$ O O O O O $number$ O $number$ O O O O $any$ O O O O $IQueueItem[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O $number$ O O O $MaybeError$ O $any[]$ O $number$ O $any$ O $QueueItemPosition.stack$ O $number$ O O O $complex$ O O $any$ O $any[]$ O $number$ O $any$ O $QueueItemPosition.target$ O $number$ O O $any$ O $any[]$ O $number$ O $any$ O $QueueItemPosition.method$ O $number$ O O $any$ O $any[]$ O $number$ O $any$ O $QueueItemPosition.args$ O $number$ O O $string$ O $Error$ O $undefined$ O O O $Error$ O $Error$ O $string$ O O O O $IQueueItem[]$ O $number$ O $complex$ O O O O $IQueueItem[]$ O O
import { TIMERS_OFFSET } from 's' ; export default function binarySearch ( time , timers ) { let start = 0 ; let end = timers . length - TIMERS_OFFSET ; let middle ; let l ; while ( start < end ) { l = ( end - start ) / TIMERS_OFFSET ; middle = start + l - ( l % TIMERS_OFFSET ) ; if ( time >= timers [ middle ] ) { start = middle + TIMERS_OFFSET ; } else { end = middle ; } } return ( time >= timers [ start ] ) ? start + TIMERS_OFFSET : start ; }	O O O O O O O O O O $number$ O $any$ O $any$ O O O $number$ O O O O $number$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $number$ O $number$ O O $any$ O O $number$ O $number$ O O O O $any$ O $number$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $number$ O $any$ O O O O O O $number$ O $any$ O O O O O $any$ O $any$ O $number$ O O O $number$ O O O $number$ O O
import { IQueueItem } from 's' ; import { findItem , getOnError , getQueueItems } from 's' ; export const enum QUEUE_STATE { Pause = 0 } const QUEUE_ITEM_LENGTH = 0 ; export default class Queue { private name : string ; private globalOptions : any ; private options : any ; private _queueBeingFlushed : any [ ] = [ ] ; private targetQueues = new Map ( ) ; private index = 0 ; private _queue : any [ ] = [ ] ; constructor ( name , options = { } , globalOptions = { } ) { this . name = name ; this . options = options ; this . globalOptions = globalOptions ; } public stackFor ( index ) { if ( index < this . _queue . length ) { let entry = this . _queue [ index * 0 + QUEUE_ITEM_LENGTH ] ; if ( entry ) { return entry . stack ; } else { return null ; } } } public flush ( sync ? ) { let { before , after } = this . options ; let target ; let method ; let args ; let errorRecordedForStack ; this . targetQueues . clear ( ) ; if ( this . _queueBeingFlushed . length === 0 ) { this . _queueBeingFlushed = this . _queue ; this . _queue = [ ] ; } if ( before !== undefined ) { before ( ) ; } let invoke ; let queueItems = this . _queueBeingFlushed ; if ( queueItems . length > 0 ) { let onError = getOnError ( this . globalOptions ) ; invoke = onError ? this . invokeWithOnError : this . invoke ; for ( let i = this . index ; i < queueItems . length ; i += QUEUE_ITEM_LENGTH ) { this . index += QUEUE_ITEM_LENGTH ; method = queueItems [ i + 0 ] ; if ( method !== null ) { target = queueItems [ i ] ; args = queueItems [ i + 0 ] ; errorRecordedForStack = queueItems [ i + 0 ] ; invoke ( target , method , args , onError , errorRecordedForStack ) ; } if ( this . index !== this . _queueBeingFlushed . length && this . globalOptions . mustYield && this . globalOptions . mustYield ( ) ) { return QUEUE_STATE . Pause ; } } } if ( after !== undefined ) { after ( ) ; } this . _queueBeingFlushed . length = 0 ; this . index = 0 ; if ( sync !== false && this . _queue . length > 0 ) { this . flush ( true ) ; } } public hasWork ( ) { return this . _queueBeingFlushed . length > 0 || this . _queue . length > 0 ; } public cancel ( { target , method } ) { let queue = this . _queue ; let targetQueueMap = this . targetQueues . get ( target ) ; if ( targetQueueMap !== undefined ) { targetQueueMap . delete ( method ) ; } let index = findItem ( target , method , queue ) ; if ( index > - 0 ) { queue . splice ( index , QUEUE_ITEM_LENGTH ) ; return true ; } queue = this . _queueBeingFlushed ; index = findItem ( target , method , queue ) ; if ( index > - 0 ) { queue [ index + 0 ] = null ; return true ; } return false ; } public push ( target , method , args , stack ) { this . _queue . push ( target , method , args , stack ) ; return { queue : this , target , method } ; } public pushUnique ( target , method , args , stack ) { let localQueueMap = this . targetQueues . get ( target ) ; if ( localQueueMap === undefined ) { localQueueMap = new Map ( ) ; this . targetQueues . set ( target , localQueueMap ) ; } let index = localQueueMap . get ( method ) ; if ( index === undefined ) { let queueIndex = this . _queue . push ( target , method , args , stack ) - QUEUE_ITEM_LENGTH ; localQueueMap . set ( method , queueIndex ) ; } else { let queue = this . _queue ; queue [ index + 0 ] = args ; queue [ index + 0 ] = stack ; } return { queue : this , target , method } ; } public _getDebugInfo ( debugEnabled ) : IQueueItem [ ] | undefined { if ( debugEnabled ) { let debugInfo : IQueueItem [ ] = getQueueItems ( this . _queue , QUEUE_ITEM_LENGTH ) ; return debugInfo ; } return undefined ; } private invoke ( target , method , args ) { if ( args === undefined ) { method . call ( target ) ; } else { method . apply ( target , args ) ; } } private invokeWithOnError ( target , method , args , onError , errorRecordedForStack ) { try { if ( args === undefined ) { method . call ( target ) ; } else { method . apply ( target , args ) ; } } catch ( error ) { onError ( error , errorRecordedForStack ) ; } } }	O O $any$ O O O O O O $number$ O $any$ O $IQueueItem[]$ O O O O O O O $any$ O $QUEUE_STATE.Pause$ O O O O O O O O O O O $any$ O O $string$ O O O O $any$ O O O O $any$ O O O O $any[]$ O O O O O O O O O $complex$ O O $MapConstructor$ O O O O $number$ O O O O $any[]$ O O O O O O O O O O $string$ O $any$ O O O O $any$ O O O O O O O $string$ O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any[]$ O $number$ O O O $any$ O O O $any[]$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O O O O O O $QUEUE_STATE$ O $Boolean$ $Boolean$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O O $complex$ O $void$ O O O O O O O $any[]$ O $number$ O O O O O O $any[]$ O O O $any[]$ O O O $any[]$ O O O O O O O $any$ O $undefined$ O O $any$ O O O O O $any$ O O $any[]$ O O O $any[]$ O O O $any[]$ O $number$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $void$ O O O $void$ O O O O $number$ O O O $number$ O $number$ O $any[]$ O $number$ O $number$ O O O O O O $number$ O O O $any$ O $any[]$ O $number$ O O O O O O $any$ O O O O $any$ O $any[]$ O $number$ O O $any$ O $any[]$ O $number$ O O O O $any$ O $any[]$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $number$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $QUEUE_STATE.Pause$ O O O O O O $any$ O $undefined$ O O $any$ O O O O O O $any[]$ O $number$ O O O O O $number$ O O O O O $Boolean$ O O O O O $any[]$ O $number$ O O O O O O $QUEUE_STATE$ O O O O O O O $boolean$ O O O O O O $any[]$ O $number$ O O O O O $any[]$ O $number$ O O O O O $boolean$ O O $any$ O $any$ O O O O $any[]$ O O O $any[]$ O O $any$ O O O $complex$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O $number$ O $number$ O $any$ O $any$ O $any[]$ O O O O $number$ O O O O O $any[]$ O $complex$ O $number$ O O O O O O O O $any[]$ O O O $any[]$ O $number$ O $number$ O $any$ O $any$ O $any[]$ O O O O $number$ O O O O O $any[]$ O $number$ O O O O O O O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O O O O $this$ O O O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O O $MapConstructor$ O O O O O $complex$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $number$ O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O O O O O $any[]$ O O O $any[]$ O $any[]$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O $any$ O O O O $this$ O O O $any$ O $any$ O O O O $IQueueItem[]$ O $boolean$ O O $any$ O O O O O O O $boolean$ O O O $IQueueItem[]$ O $any$ O O O $IQueueItem[]$ O O O $any[]$ O O O O O $IQueueItem[]$ O O O $undefined$ O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O
import { IQueueItem } from 's' ; import Queue , { QUEUE_STATE } from 's' ; export interface IDebugInfo { [ key ] : IQueueItem [ ] | undefined ; } export default class DeferredActionQueues { public queues : { [ name ] : Queue } = { } ; public queueNameIndex = 0 ; private queueNames : string [ ] ; constructor ( queueNames : string [ ] = [ ] , options ) { this . queueNames = queueNames ; queueNames . reduce ( function ( queues , queueName ) { queues [ queueName ] = new Queue ( queueName , options [ queueName ] , options ) ; return queues ; } , this . queues ) ; } public schedule ( queueName , target , method , args , onceFlag , stack ) { let queues = this . queues ; let queue = queues [ queueName ] ; if ( queue === undefined ) { throw new Error ( `template` ) ; } if ( method === undefined || method === null ) { throw new Error ( `template` ) ; } this . queueNameIndex = 0 ; if ( onceFlag ) { return queue . pushUnique ( target , method , args , stack ) ; } else { return queue . push ( target , method , args , stack ) ; } } public flush ( fromAutorun = false ) { let queue ; let queueName ; let numberOfQueues = this . queueNames . length ; while ( this . queueNameIndex < numberOfQueues ) { queueName = this . queueNames [ this . queueNameIndex ] ; queue = this . queues [ queueName ] ; if ( queue . hasWork ( ) === false ) { this . queueNameIndex ++ ; if ( fromAutorun && this . queueNameIndex < numberOfQueues ) { return QUEUE_STATE . Pause ; } } else { if ( queue . flush ( false ) === QUEUE_STATE . Pause ) { return QUEUE_STATE . Pause ; } } } } public _getDebugInfo ( debugEnabled ) : IDebugInfo | undefined { if ( debugEnabled ) { let debugInfo = { } ; let queue ; let queueName ; let numberOfQueues = this . queueNames . length ; let i = 0 ; while ( i < numberOfQueues ) { queueName = this . queueNames [ i ] ; queue = this . queues [ queueName ] ; debugInfo [ queueName ] = queue . _getDebugInfo ( debugEnabled ) ; i ++ ; } return debugInfo ; } return ; } }	O O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O $string$ O O $any$ O O O O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O $number$ O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O $any$ O O O O $string[]$ O $string[]$ O $string[]$ O $complex$ O O O $complex$ O $string$ O O $complex$ O $string$ O O O $any$ O $string$ O $any$ O $string$ O O $any$ O O O $complex$ O O O O O $complex$ O O O O $complex$ O $string$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O O O $complex$ O O O $complex$ O O $Queue$ O $complex$ O $string$ O O O O $Queue$ O $undefined$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $undefined$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $number$ O O O O O $boolean$ O O O $Queue$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Queue$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O $QUEUE_STATE$ O $boolean$ O O O O O $any$ O O $any$ O O $number$ O O O $string[]$ O $number$ O O O O O $number$ O $number$ O O $any$ O O O $string[]$ O O O $number$ O O $any$ O O O $complex$ O $any$ O O O O $any$ O $any$ O O O O O O O O $number$ O O O O $boolean$ O O O $number$ O $number$ O O O $any$ O $QUEUE_STATE.Pause$ O O O O O O O $any$ O $any$ O O O O $any$ O $QUEUE_STATE.Pause$ O O O $any$ O $QUEUE_STATE.Pause$ O O O O O O $IDebugInfo$ O $boolean$ O O $any$ O O O O O $boolean$ O O O $IDebugInfo$ O O O O O $Queue$ O O $string$ O O $number$ O O O $string[]$ O $number$ O O $number$ O O O O O $number$ O $number$ O O $string$ O O O $string[]$ O $number$ O O $Queue$ O O O $complex$ O $string$ O O $IDebugInfo$ O $string$ O O $Queue$ O $IQueueItem[]$ O $true$ O O $number$ O O O O $IDebugInfo$ O O O O O O
export interface Iterable { next : ( ) => { done : boolean , value ? : any } ; } export default function ( fn : ( ) => Iterable ) { let iterator = fn ( ) ; let result = iterator . next ( ) ; while ( result . done === false ) { result . value ( ) ; result = iterator . next ( ) ; } }	O O $any$ O $complex$ O O O O O $boolean$ O O O $any$ O O O O O O O O O O $Iterable$ O O O O $any$ O O O $Iterable$ O $Iterable$ O O O O $complex$ O $Iterable$ O $complex$ O O O O O $complex$ O $boolean$ O O O O $complex$ O $any$ O O O $complex$ O $Iterable$ O $complex$ O O O O O
export interface IPlatform { setTimeout ( fn , ms ) : any ; clearTimeout ( id ) : void ; next ( ) : any ; clearNext ( ) : void ; now ( ) : number ; } const SET_TIMEOUT = setTimeout ; const NOOP = ( ) => { } ; export function buildNext ( flush : ( ) => void ) : ( ) => void { if ( typeof Promise === 's' ) { const autorunPromise = Promise . resolve ( ) ; return ( ) => autorunPromise . then ( flush ) ; } else if ( typeof MutationObserver === 's' ) { let iterations = 0 ; let observer = new MutationObserver ( flush ) ; let node = document . createTextNode ( 's' ) ; observer . observe ( node , { characterData : true } ) ; return ( ) => { iterations = ++ iterations % 0 ; node . data = 's' + iterations ; return iterations ; } ; } else { return ( ) => SET_TIMEOUT ( flush , 0 ) ; } } export function buildPlatform ( flush : ( ) => void ) { let clearNext = NOOP ; return { setTimeout ( fn , ms ) { return setTimeout ( fn , ms ) ; } , clearTimeout ( timerId ) { return clearTimeout ( timerId ) ; } , now ( ) { return Date . now ( ) ; } , next : buildNext ( flush ) , clearNext , } ; }	O O $any$ O $any$ O $Function$ O $number$ O O O O $void$ O $any$ O O O O $any$ O O O O O $void$ O O O O O $number$ O O O O O O O $number$ O $number$ O O $void$ O O O O O O O O O $void$ O $void$ O O O O O O O O O O O O O O O $PromiseConstructor$ O O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O O O O $Promise<void>$ O O O $void$ O O O O O O O $complex$ O O O O O $number$ O O O O $MutationObserver$ O O $complex$ O $void$ O O O $Text$ O $Document$ O $Text$ O O O O $MutationObserver$ O $void$ O $Text$ O O $true$ O O O O O O O O O O $number$ O O $number$ O O O $Text$ O $string$ O O O $number$ O O $number$ O O O O O O O O O O $number$ O $void$ O O O O O O O O $IPlatform$ O $void$ O O O O O O O O $void$ O $void$ O O O $number$ O $Function$ O $number$ O O O $number$ O $Function$ O $number$ O O O O $void$ O $number$ O O O $void$ O $number$ O O O O $number$ O O O O $DateConstructor$ O $number$ O O O O O $void$ O $void$ O $void$ O O $void$ O O O O
export { buildPlatform , IPlatform } from 's' ; import { buildNext , buildPlatform , IPlatform , } from 's' ; import { findTimerItem , getOnError , getQueueItems , isCoercableNumber , TIMERS_OFFSET } from 's' ; import searchTimer from 's' ; import DeferredActionQueues from 's' ; import iteratorDrain , { Iterable } from 's' ; import Queue , { QUEUE_STATE } from 's' ; type Timer = string | number ; const noop = function ( ) { } ; const DISABLE_SCHEDULE = Object . freeze ( [ ] ) ; function parseArgs ( ... args : any [ ] ) ; function parseArgs ( ) { let length = arguments . length ; let args ; let method ; let target ; if ( length === 0 ) { } else if ( length === 0 ) { target = null ; method = arguments [ 0 ] ; } else { let argsIndex = 0 ; let methodOrTarget = arguments [ 0 ] ; let methodOrArgs = arguments [ 0 ] ; let type = typeof methodOrArgs ; if ( type === 's' ) { target = methodOrTarget ; method = methodOrArgs ; } else if ( methodOrTarget !== null && type === 's' && methodOrArgs in methodOrTarget ) { target = methodOrTarget ; method = target [ methodOrArgs ] ; } else if ( typeof methodOrTarget === 's' ) { argsIndex = 0 ; target = null ; method = methodOrTarget ; } if ( length > argsIndex ) { let len = length - argsIndex ; args = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { args [ i ] = arguments [ i + argsIndex ] ; } } } return [ target , method , args ] ; } function parseTimerArgs ( ... args : any [ ] ) ; function parseTimerArgs ( ) { let [ target , method , args ] = parseArgs ( ... arguments ) ; let wait = 0 ; let length = args !== undefined ? args . length : 0 ; if ( length > 0 ) { let last = args [ length - 0 ] ; if ( isCoercableNumber ( last ) ) { wait = parseInt ( args . pop ( ) , 0 ) ; } } return [ target , method , args , wait ] ; } function parseDebounceArgs ( ... args : any [ ] ) ; function parseDebounceArgs ( ) { let target ; let method ; let isImmediate ; let args ; let wait ; if ( arguments . length === 0 ) { method = arguments [ 0 ] ; wait = arguments [ 0 ] ; target = null ; } else { [ target , method , args ] = parseArgs ( ... arguments ) ; if ( args === undefined ) { wait = 0 ; } else { wait = args . pop ( ) ; if ( ! isCoercableNumber ( wait ) ) { isImmediate = wait === true ; wait = args . pop ( ) ; } } } wait = parseInt ( wait , 0 ) ; return [ target , method , args , wait , isImmediate ] ; } let UUID = 0 ; let beginCount = 0 ; let endCount = 0 ; let beginEventCount = 0 ; let endEventCount = 0 ; let runCount = 0 ; let joinCount = 0 ; let deferCount = 0 ; let scheduleCount = 0 ; let scheduleIterableCount = 0 ; let deferOnceCount = 0 ; let scheduleOnceCount = 0 ; let setTimeoutCount = 0 ; let laterCount = 0 ; let throttleCount = 0 ; let debounceCount = 0 ; let cancelTimersCount = 0 ; let cancelCount = 0 ; let autorunsCreatedCount = 0 ; let autorunsCompletedCount = 0 ; let deferredActionQueuesCreatedCount = 0 ; let nestedDeferredActionQueuesCreated = 0 ; export interface IBackburnerOptions { defaultQueue ? : string ; onBegin ? : ( currentInstance , previousInstance ) => void ; onEnd ? : ( currentInstance , nextInstance ) => void ; onError ? : ( error , errorRecordedForStack ? ) => void ; onErrorTarget ? : any ; onErrorMethod ? : string ; mustYield ? : ( ) => boolean ; _buildPlatform ? : ( flush : ( ) => void ) => IPlatform ; flush ? ( queueName , flush : ( ) => void ) : void ; } export default class Backburner { public static Queue = Queue ; public static buildPlatform = buildPlatform ; public static buildNext = buildNext ; public DEBUG = false ; public currentInstance : DeferredActionQueues | null = null ; public options : IBackburnerOptions ; public get counters ( ) { return { begin : beginCount , end : endCount , events : { begin : beginEventCount , end : endEventCount , } , autoruns : { created : autorunsCreatedCount , completed : autorunsCompletedCount , } , run : runCount , join : joinCount , defer : deferCount , schedule : scheduleCount , scheduleIterable : scheduleIterableCount , deferOnce : deferOnceCount , scheduleOnce : scheduleOnceCount , setTimeout : setTimeoutCount , later : laterCount , throttle : throttleCount , debounce : debounceCount , cancelTimers : cancelTimersCount , cancel : cancelCount , loops : { total : deferredActionQueuesCreatedCount , nested : nestedDeferredActionQueuesCreated , } , } ; } private _onBegin : ( currentInstance , previousInstance : DeferredActionQueues | null ) => void ; private _onEnd : ( currentInstance , nextInstance : DeferredActionQueues | null ) => void ; private queueNames : string [ ] ; private instanceStack : DeferredActionQueues [ ] = [ ] ; private _eventCallbacks : { end : Function [ ] ; begin : Function [ ] ; } = { end : [ ] , begin : [ ] } ; private _timerTimeoutId : number | null = null ; private _timers : any [ ] = [ ] ; private _platform : IPlatform ; private _boundRunExpiredTimers : ( ) => void ; private _autorun = false ; private _autorunStack : Error | undefined | null = null ; private _boundAutorunEnd : ( ) => void ; private _defaultQueue : string ; constructor ( queueNames : string [ ] , options ? ) { this . queueNames = queueNames ; this . options = options || { } ; if ( typeof this . options . defaultQueue === 's' ) { this . _defaultQueue = this . options . defaultQueue ; } else { this . _defaultQueue = this . queueNames [ 0 ] ; } this . _onBegin = this . options . onBegin || noop ; this . _onEnd = this . options . onEnd || noop ; this . _boundRunExpiredTimers = this . _runExpiredTimers . bind ( this ) ; this . _boundAutorunEnd = ( ) => { autorunsCompletedCount ++ ; if ( this . _autorun === false ) { return ; } this . _autorun = false ; this . _autorunStack = null ; this . _end ( true ) ; } ; let builder = this . options . _buildPlatform || buildPlatform ; this . _platform = builder ( this . _boundAutorunEnd ) ; } public get defaultQueue ( ) { return this . _defaultQueue ; } public begin ( ) { beginCount ++ ; let options = this . options ; let previousInstance = this . currentInstance ; let current ; if ( this . _autorun !== false ) { current = previousInstance ; this . _cancelAutorun ( ) ; } else { if ( previousInstance !== null ) { nestedDeferredActionQueuesCreated ++ ; this . instanceStack . push ( previousInstance ) ; } deferredActionQueuesCreatedCount ++ ; current = this . currentInstance = new DeferredActionQueues ( this . queueNames , options ) ; beginEventCount ++ ; this . _trigger ( 's' , current , previousInstance ) ; } this . _onBegin ( current , previousInstance ) ; return current ; } public end ( ) { endCount ++ ; this . _end ( false ) ; } public on ( eventName , callback ) { if ( typeof callback !== 's' ) { throw new TypeError ( `template` ) ; } let callbacks = this . _eventCallbacks [ eventName ] ; if ( callbacks !== undefined ) { callbacks . push ( callback ) ; } else { throw new TypeError ( `template` ) ; } } public off ( eventName , callback ) { let callbacks = this . _eventCallbacks [ eventName ] ; if ( ! eventName || callbacks === undefined ) { throw new TypeError ( `template` ) ; } let callbackFound = false ; if ( callback ) { for ( let i = 0 ; i < callbacks . length ; i ++ ) { if ( callbacks [ i ] === callback ) { callbackFound = true ; callbacks . splice ( i , 0 ) ; i -- ; } } } if ( ! callbackFound ) { throw new TypeError ( `template` ) ; } } public run ( target ) ; public run ( target : Function | any | null , method ? : Function | string , ... args ) ; public run ( target : any | null | undefined , method ? , ... args : any [ ] ) ; public run ( ) { runCount ++ ; let [ target , method , args ] = parseArgs ( ... arguments ) ; return this . _run ( target , method , args ) ; } public join ( target ) ; public join ( target : Function | any | null , method ? : Function | string , ... args ) ; public join ( target : any | null | undefined , method ? , ... args : any [ ] ) ; public join ( ) { joinCount ++ ; let [ target , method , args ] = parseArgs ( ... arguments ) ; return this . _join ( target , method , args ) ; } public defer ( queueName , target , method , ... args ) { deferCount ++ ; return this . schedule ( queueName , target , method , ... args ) ; } public schedule ( queueName , method ) ; public schedule < T , U extends keyof T > ( queueName , target : T , method : U , ... args ) ; public schedule ( queueName , target , method : any | Function , ... args ) ; public schedule ( queueName , ... _args ) { scheduleCount ++ ; let [ target , method , args ] = parseArgs ( ... _args ) ; let stack = this . DEBUG ? new Error ( ) : undefined ; return this . _ensureInstance ( ) . schedule ( queueName , target , method , args , false , stack ) ; } public scheduleIterable ( queueName , iterable : ( ) => Iterable ) { scheduleIterableCount ++ ; let stack = this . DEBUG ? new Error ( ) : undefined ; return this . _ensureInstance ( ) . schedule ( queueName , null , iteratorDrain , [ iterable ] , false , stack ) ; } public deferOnce ( queueName , target , method , ... args ) { deferOnceCount ++ ; return this . scheduleOnce ( queueName , target , method , ... args ) ; } public scheduleOnce ( queueName , method ) ; public scheduleOnce < T , U extends keyof T > ( queueName , target : T , method : U , ... args ) ; public scheduleOnce ( queueName , target : any | null , method : any | Function , ... args ) ; public scheduleOnce ( queueName , ... _args ) { scheduleOnceCount ++ ; let [ target , method , args ] = parseArgs ( ... _args ) ; let stack = this . DEBUG ? new Error ( ) : undefined ; return this . _ensureInstance ( ) . schedule ( queueName , target , method , args , true , stack ) ; } public setTimeout ( ... args ) ; public setTimeout ( ) { setTimeoutCount ++ ; return this . later ( ... arguments ) ; } public later < T > ( ... args : any [ ] ) ; public later < T > ( target : T , methodName : keyof T , wait ? : number | string ) ; public later < T > ( target : T , methodName : keyof T , 0 , wait ? : number | string ) ; public later < T > ( target : T , methodName : keyof T , 0 , 0 , wait ? : number | string ) ; public later < T > ( target : T , methodName : keyof T , 0 , 0 , 0 , wait ? : number | string ) ; public later ( thisArg : any | null , method : ( ) => void , wait ? : number | string ) ; public later < A > ( thisArg : any | null , method : ( 0 : A ) => void , 0 : A , wait ? : number | string ) ; public later < A , B > ( thisArg : any | null , method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait ? : number | string ) ; public later < A , B , C > ( thisArg : any | null , method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait ? : number | string ) ; public later ( method : ( ) => void , wait ? : number | string ) ; public later < A > ( method : ( 0 : A ) => void , 0 : A , wait ? : number | string ) ; public later < A , B > ( method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait ? : number | string ) ; public later < A , B , C > ( method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait ? : number | string ) ; public later ( ) { laterCount ++ ; let [ target , method , args , wait ] = parseTimerArgs ( ... arguments ) ; return this . _later ( target , method , args , wait ) ; } public throttle < T > ( target : T , methodName : keyof T , wait ? : number | string , immediate ? ) ; public throttle < T > ( target : T , methodName : keyof T , 0 , wait ? : number | string , immediate ? ) ; public throttle < T > ( target : T , methodName : keyof T , 0 , 0 , wait ? : number | string , immediate ? ) ; public throttle < T > ( target : T , methodName : keyof T , 0 , 0 , 0 , wait ? : number | string , immediate ? ) ; public throttle ( thisArg : any | null , method : ( ) => void , wait ? : number | string , immediate ? ) ; public throttle < A > ( thisArg : any | null , method : ( 0 : A ) => void , 0 : A , wait ? : number | string , immediate ? ) ; public throttle < A , B > ( thisArg : any | null , method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait ? : number | string , immediate ? ) ; public throttle < A , B , C > ( thisArg : any | null , method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait ? : number | string , immediate ? ) ; public throttle ( method : ( ) => void , wait ? : number | string , immediate ? ) ; public throttle < A > ( method : ( 0 : A ) => void , 0 : A , wait ? : number | string , immediate ? ) ; public throttle < A , B > ( method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait ? : number | string , immediate ? ) ; public throttle < A , B , C > ( method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait ? : number | string , immediate ? ) ; public throttle ( ) { throttleCount ++ ; let [ target , method , args , wait , isImmediate = true ] = parseDebounceArgs ( ... arguments ) ; let index = findTimerItem ( target , method , this . _timers ) ; let timerId ; if ( index === - 0 ) { timerId = this . _later ( target , method , isImmediate ? DISABLE_SCHEDULE : args , wait ) ; if ( isImmediate ) { this . _join ( target , method , args ) ; } } else { timerId = this . _timers [ index + 0 ] ; let argIndex = index + 0 ; if ( this . _timers [ argIndex ] !== DISABLE_SCHEDULE ) { this . _timers [ argIndex ] = args ; } } return timerId ; } public debounce < T > ( target : T , methodName : keyof T , wait : number | string , immediate ? ) ; public debounce < T > ( target : T , methodName : keyof T , 0 , wait : number | string , immediate ? ) ; public debounce < T > ( target : T , methodName : keyof T , 0 , 0 , wait : number | string , immediate ? ) ; public debounce < T > ( target : T , methodName : keyof T , 0 , 0 , 0 , wait : number | string , immediate ? ) ; public debounce ( thisArg : any | null , method : ( ) => void , wait : number | string , immediate ? ) ; public debounce < A > ( thisArg : any | null , method : ( 0 : A ) => void , 0 : A , wait : number | string , immediate ? ) ; public debounce < A , B > ( thisArg : any | null , method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait : number | string , immediate ? ) ; public debounce < A , B , C > ( thisArg : any | null , method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait : number | string , immediate ? ) ; public debounce ( method : ( ) => void , wait : number | string , immediate ? ) ; public debounce < A > ( method : ( 0 : A ) => void , 0 : A , wait : number | string , immediate ? ) ; public debounce < A , B > ( method : ( 0 : A , 0 : B ) => void , 0 : A , 0 : B , wait : number | string , immediate ? ) ; public debounce < A , B , C > ( method : ( 0 : A , 0 : B , 0 : C ) => void , 0 : A , 0 : B , 0 : C , wait : number | string , immediate ? ) ; public debounce ( ) { debounceCount ++ ; let [ target , method , args , wait , isImmediate = false ] = parseDebounceArgs ( ... arguments ) ; let _timers = this . _timers ; let index = findTimerItem ( target , method , _timers ) ; let timerId ; if ( index === - 0 ) { timerId = this . _later ( target , method , isImmediate ? DISABLE_SCHEDULE : args , wait ) ; if ( isImmediate ) { this . _join ( target , method , args ) ; } } else { let executeAt = this . _platform . now ( ) + wait ; let argIndex = index + 0 ; if ( _timers [ argIndex ] === DISABLE_SCHEDULE ) { args = DISABLE_SCHEDULE ; } timerId = _timers [ index + 0 ] ; let i = searchTimer ( executeAt , _timers ) ; if ( ( index + TIMERS_OFFSET ) === i ) { _timers [ index ] = executeAt ; _timers [ argIndex ] = args ; } else { let stack = this . _timers [ index + 0 ] ; this . _timers . splice ( i , 0 , executeAt , timerId , target , method , args , stack ) ; this . _timers . splice ( index , TIMERS_OFFSET ) ; } if ( index === 0 ) { this . _reinstallTimerTimeout ( ) ; } } return timerId ; } public cancelTimers ( ) { cancelTimersCount ++ ; this . _clearTimerTimeout ( ) ; this . _timers = [ ] ; this . _cancelAutorun ( ) ; } public hasTimers ( ) { return this . _timers . length > 0 || this . _autorun ; } public cancel ( timer ? ) { cancelCount ++ ; if ( timer === null || timer === undefined ) { return false ; } let timerType = typeof timer ; if ( timerType === 's' ) { return this . _cancelLaterTimer ( timer ) ; } else if ( timerType === 's' && timer . queue && timer . method ) { return timer . queue . cancel ( timer ) ; } return false ; } public ensureInstance ( ) { this . _ensureInstance ( ) ; } public getDebugInfo ( ) { if ( this . DEBUG ) { return { autorun : this . _autorunStack , counters : this . counters , timers : getQueueItems ( this . _timers , TIMERS_OFFSET , 0 ) , instanceStack : [ this . currentInstance , ... this . instanceStack ] . map ( ( deferredActionQueue ) => deferredActionQueue && deferredActionQueue . _getDebugInfo ( this . DEBUG ) ) } ; } return undefined ; } private _end ( fromAutorun ) { let currentInstance = this . currentInstance ; let nextInstance : DeferredActionQueues | null = null ; if ( currentInstance === null ) { throw new Error ( `template` ) ; } let finallyAlreadyCalled = false ; let result ; try { result = currentInstance . flush ( fromAutorun ) ; } finally { if ( ! finallyAlreadyCalled ) { finallyAlreadyCalled = true ; if ( result === QUEUE_STATE . Pause ) { const plannedNextQueue = this . queueNames [ currentInstance . queueNameIndex ] ; this . _scheduleAutorun ( plannedNextQueue ) ; } else { this . currentInstance = null ; if ( this . instanceStack . length > 0 ) { nextInstance = this . instanceStack . pop ( ) as DeferredActionQueues ; this . currentInstance = nextInstance ; } this . _trigger ( 's' , currentInstance , nextInstance ) ; this . _onEnd ( currentInstance , nextInstance ) ; } } } } private _join ( target , method , args ) { if ( this . currentInstance === null ) { return this . _run ( target , method , args ) ; } if ( target === undefined && args === undefined ) { return method ( ) ; } else { return method . apply ( target , args ) ; } } private _run ( target , method , args ) { let onError = getOnError ( this . options ) ; this . begin ( ) ; if ( onError ) { try { return method . apply ( target , args ) ; } catch ( error ) { onError ( error ) ; } finally { this . end ( ) ; } } else { try { return method . apply ( target , args ) ; } finally { this . end ( ) ; } } } private _cancelAutorun ( ) { if ( this . _autorun ) { this . _platform . clearNext ( ) ; this . _autorun = false ; this . _autorunStack = null ; } } private _later ( target , method , args , wait ) { let stack = this . DEBUG ? new Error ( ) : undefined ; let executeAt = this . _platform . now ( ) + wait ; let id = UUID ++ ; if ( this . _timers . length === 0 ) { this . _timers . push ( executeAt , id , target , method , args , stack ) ; this . _installTimerTimeout ( ) ; } else { let i = searchTimer ( executeAt , this . _timers ) ; this . _timers . splice ( i , 0 , executeAt , id , target , method , args , stack ) ; this . _reinstallTimerTimeout ( ) ; } return id ; } private _cancelLaterTimer ( timer ) { for ( let i = 0 ; i < this . _timers . length ; i += TIMERS_OFFSET ) { if ( this . _timers [ i ] === timer ) { this . _timers . splice ( i - 0 , TIMERS_OFFSET ) ; if ( i === 0 ) { this . _reinstallTimerTimeout ( ) ; } return true ; } } return false ; } private _trigger < T , U > ( eventName , 0 : T , 0 : U ) { let callbacks = this . _eventCallbacks [ eventName ] ; if ( callbacks !== undefined ) { for ( let i = 0 ; i < callbacks . length ; i ++ ) { callbacks [ i ] ( 0 , 0 ) ; } } } private _runExpiredTimers ( ) { this . _timerTimeoutId = null ; if ( this . _timers . length > 0 ) { this . begin ( ) ; this . _scheduleExpiredTimers ( ) ; this . end ( ) ; } } private _scheduleExpiredTimers ( ) { let timers = this . _timers ; let i = 0 ; let l = timers . length ; let defaultQueue = this . _defaultQueue ; let n = this . _platform . now ( ) ; for ( ; i < l ; i += TIMERS_OFFSET ) { let executeAt = timers [ i ] ; if ( executeAt > n ) { break ; } let args = timers [ i + 0 ] ; if ( args !== DISABLE_SCHEDULE ) { let target = timers [ i + 0 ] ; let method = timers [ i + 0 ] ; let stack = timers [ i + 0 ] ; this . currentInstance ! . schedule ( defaultQueue , target , method , args , false , stack ) ; } } timers . splice ( 0 , i ) ; this . _installTimerTimeout ( ) ; } private _reinstallTimerTimeout ( ) { this . _clearTimerTimeout ( ) ; this . _installTimerTimeout ( ) ; } private _clearTimerTimeout ( ) { if ( this . _timerTimeoutId === null ) { return ; } this . _platform . clearTimeout ( this . _timerTimeoutId ) ; this . _timerTimeoutId = null ; } private _installTimerTimeout ( ) { if ( this . _timers . length === 0 ) { return ; } let minExpiresAt = this . _timers [ 0 ] ; let n = this . _platform . now ( ) ; let wait = Math . max ( 0 , minExpiresAt - n ) ; this . _timerTimeoutId = this . _platform . setTimeout ( this . _boundRunExpiredTimers , wait ) ; } private _ensureInstance ( ) { let currentInstance = this . currentInstance ; if ( currentInstance === null ) { this . _autorunStack = this . DEBUG ? new Error ( ) : undefined ; currentInstance = this . begin ( ) ; this . _scheduleAutorun ( this . queueNames [ 0 ] ) ; } return currentInstance ; } private _scheduleAutorun ( plannedNextQueue ) { autorunsCreatedCount ++ ; const next = this . _platform . next ; const flush = this . options . flush ; if ( flush ) { flush ( plannedNextQueue , next ) ; } else { next ( ) ; } this . _autorun = true ; } }	O O $IPlatform$ O $any$ O O O O O O $void$ O $IPlatform$ O $any$ O O O O O O O $number$ O $any$ O $IQueueItem[]$ O $boolean$ O O O O O O O $number$ O O O O $any$ O O O O $void$ O O $any$ O O O O O $any$ O O $any$ O O O O O $any$ O O O O O O $void$ O O O O O O O O $complex$ O $ObjectConstructor$ O $complex$ O O O O O O $any$ O O $any[]$ O O O O O O O $any$ O O O O $number$ O $IArguments$ O $number$ O O $any$ O O $any$ O O $any$ O O O $number$ O O O O O O O O $number$ O O O O $any$ O O O $any$ O $IArguments$ O O O O O O O O $number$ O O O O $any$ O $IArguments$ O O O O O $any$ O $IArguments$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $number$ O O O $any$ O O O $any$ O $any$ O O O O $number$ O $number$ O O O $number$ O $number$ O $number$ O $any$ O O $ArrayConstructor$ O $number$ O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $any$ O $number$ O O $IArguments$ O $number$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any[]$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O $IArguments$ O O O $number$ O O O O $any$ O $any$ O $undefined$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $any$ O O O $number$ O $number$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O $any$ O O $any[]$ O O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O O $IArguments$ O $number$ O O O O $any$ O $IArguments$ O O O O $any$ O $IArguments$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O $IArguments$ O O O O $any$ O $undefined$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $number$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O O $any$ O $string$ O O O O $void$ O O O $DeferredActionQueues$ O $DeferredActionQueues$ O O O O $void$ O O O $DeferredActionQueues$ O $DeferredActionQueues$ O O O O $void$ O O O $any$ O $any$ $any$ O O O O $any$ O O O O $string$ O O O O $boolean$ O O O O O O O $IPlatform$ O O O $void$ O O O O O O O $any$ O $void$ O O $string$ O $void$ O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O $IPlatform$ O $IPlatform$ O O O $void$ O $void$ O O $boolean$ O O O O $DeferredActionQueues$ O $any$ O O O O O O $IBackburnerOptions$ O $any$ O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $complex$ O O $number$ O $number$ O $number$ O $number$ O O O $complex$ O O $number$ O $number$ O $number$ O $number$ O O O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $complex$ O O $number$ O $number$ O $number$ O $number$ O O O O O O O $void$ O O $DeferredActionQueues$ O $DeferredActionQueues$ O $any$ O O O O O O O $void$ O O $DeferredActionQueues$ O $DeferredActionQueues$ O $any$ O O O O O O O $string[]$ O O O O O O $DeferredActionQueues[]$ O $any$ O O O O O O O $complex$ O O $Function[]$ O $FunctionConstructor$ O O O $Function[]$ O $FunctionConstructor$ O O O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O $number$ O O O O O O O O $any[]$ O O O O O O O O O $IPlatform$ O $any$ O O $void$ O O O O O O O $boolean$ O O O O $Error$ O $ErrorConstructor$ O O O O O O O O $void$ O O O O O O O $string$ O O O O O $string[]$ O O O O O $IBackburnerOptions$ $IBackburnerOptions$ O O O O $string[]$ O $string[]$ O O O $IBackburnerOptions$ O $IBackburnerOptions$ O O O O O O O O O $IBackburnerOptions$ O $string$ O O O O O O $string$ O O O $IBackburnerOptions$ O $string$ O O O O O O $string$ O O O $string[]$ O O O O O O O $void$ O O O $IBackburnerOptions$ O $void$ O $void$ O O O $void$ O O O $IBackburnerOptions$ O $void$ O $void$ O O O $void$ O O O $void$ O $any$ O O O O O O $void$ O O O O O $number$ O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O $Error$ O O O O O $void$ O O O O O O O $IPlatform$ O O O $IBackburnerOptions$ O $IPlatform$ O $IPlatform$ O O O $IPlatform$ O $IPlatform$ O O O $void$ O O O O O $string$ O O O O O O $string$ O O O $DeferredActionQueues$ O O O $number$ O O O $IBackburnerOptions$ O O O $IBackburnerOptions$ O O $DeferredActionQueues$ O O O $DeferredActionQueues$ O O $any$ O O O O O $boolean$ O O O O $any$ O $DeferredActionQueues$ O O O $void$ O O O O O O O O $DeferredActionQueues$ O O O O $number$ O O O O $DeferredActionQueues[]$ O $number$ O $DeferredActionQueues$ O O O $number$ O O $any$ O O O $DeferredActionQueues$ O O $any$ O O O $string[]$ O $IBackburnerOptions$ O O $number$ O O O O O O O O $any$ O $DeferredActionQueues$ O O O O O $void$ O $any$ O $DeferredActionQueues$ O O O $any$ O O O $void$ O O O $number$ O O O O $void$ O O O O O O $void$ O $any$ O $any$ O O O O O $any$ O O O O O O $TypeErrorConstructor$ O O O O O O $any$ O O O $complex$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O O O $TypeErrorConstructor$ O O O O O O O $void$ O $any$ O $any$ O O O $any$ O O O $complex$ O $any$ O O O O O $any$ O $any$ O $undefined$ O O O O $TypeErrorConstructor$ O O O O O O $boolean$ O O O O O $any$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O O $boolean$ O O O $any$ O $any$ O $number$ O O O O $number$ O O O O O O O O $boolean$ O O O O $TypeErrorConstructor$ O O O O O O O $complex$ O $Function$ O O O $complex$ O $any$ O $FunctionConstructor$ O O O O O $TimerHandler$ O O $FunctionConstructor$ O O O O $any[]$ O O O $complex$ O $any$ O O O O O O O $Function$ $Function$ O O $any[]$ O O O O O O O $complex$ O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O $IArguments$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O $Function$ O O O $complex$ O $any$ O $FunctionConstructor$ O O O O O $TimerHandler$ O O $FunctionConstructor$ O O O O $any[]$ O O O $complex$ O $any$ O O O O O O O $Function$ $Function$ O O $any[]$ O O O O O O O $complex$ O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O $IArguments$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $number$ O O O O O $complex$ O $any$ O $any$ O $any$ O O $any[]$ O O O O $complex$ O $string$ O $Function$ O O O $complex$ O $any$ O $any$ O O $any$ O O $string$ O $T$ O $any$ O $U$ O $any$ O O $any[]$ O O O $complex$ O $string$ O $any$ O $any$ O O O $FunctionConstructor$ O O $any[]$ O O O $complex$ O $any$ O O $any[]$ O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any[]$ O O O $Error$ O O O $boolean$ O O $ErrorConstructor$ O O O $undefined$ O O O O $DeferredActionQueues$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O $Error$ O O O O $complex$ O $string$ O $Iterable$ O O O O $any$ O O $number$ O O O $Error$ O O O $boolean$ O O $ErrorConstructor$ O O O $undefined$ O O O O $DeferredActionQueues$ O O O $complex$ O $string$ O O O $void$ O O $Iterable$ O O O O $Error$ O O O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $number$ O O O O O $complex$ O $any$ O $any$ O $any$ O O $any[]$ O O O O $complex$ O $string$ O $Function$ O O O $complex$ O $any$ O $any$ O O $any$ O O $string$ O $T$ O $any$ O $U$ O $any$ O O $any[]$ O O O $complex$ O $string$ O $any$ O O O O O $any$ O O O $FunctionConstructor$ O O $any[]$ O O O $complex$ O $any$ O O $any[]$ O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any[]$ O O O $Error$ O O O $boolean$ O O $ErrorConstructor$ O O O $undefined$ O O O O $DeferredActionQueues$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O $Error$ O O O O $any$ O O $any[]$ O O O $any$ O O O $number$ O O O O O O O O $IArguments$ O O O O $Timer$ O $any$ O O O $any[]$ O O O O O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O O O O O $void$ O O O O O O $Timer$ O O O O O O O O $Timer$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $void$ O O O O O O $Timer$ O O O O O O O O $Timer$ O $any$ O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O O O O $Timer$ O $any$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $IArguments$ O O O O O $number$ O $any$ O $any$ O $any$ O $any$ O O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O O O O $void$ O O O O O O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $void$ O O O O O O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O O $boolean$ $boolean$ O O O $Timer$ O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $IArguments$ O O O $number$ O $number$ O $any$ O $any$ O O O $any[]$ O O O $any$ O O O $number$ O O O O O $any$ O O O $number$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any[]$ O $number$ O O O O O $number$ O $number$ O O O O O O O $any[]$ O $number$ O O $complex$ O O O O $any[]$ O $number$ O O $any$ O O O O $any$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $T$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O O O O $void$ O O O O O O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $void$ O O O O O O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O O O O O $A$ O $any$ O O O O $A$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O $any$ O $any$ O $any$ O O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O O O O $A$ O $any$ O $B$ O $any$ O $C$ O $any$ O $Timer$ O O O O O $boolean$ $boolean$ O O O $Timer$ O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $IArguments$ O O O $any[]$ O O O $any[]$ O O $number$ O $number$ O $any$ O $any$ O $any[]$ O O O $any$ O O O $number$ O O O O O $any$ O O O $number$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $IPlatform$ O $number$ O O O $any$ O O $number$ O $number$ O O O O O $any[]$ O $number$ O O $complex$ O O $any$ O $complex$ O O $any$ O $any[]$ O $number$ O O O O O $number$ O $number$ O $any$ O $any[]$ O O O O O $number$ O O O O $number$ O O $any[]$ O $number$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O $any$ O O O $any[]$ O $number$ O O O O O O $any[]$ O $complex$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $complex$ O $number$ O O O O O O O $number$ O O O O O O $void$ O O O O O O $any$ O O O $void$ O O O $number$ O O O O $void$ O O O O O $any[]$ O O O O O O $void$ O O O O O $boolean$ O O O O O O $any[]$ O $number$ O O O O O $boolean$ O O O $any$ O $any$ O O O $number$ O O O O $any$ O O O $any$ O $undefined$ O O O O O O O O O O $any$ O O O O O O O O O O O $boolean$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O O O O O $DeferredActionQueues$ O O O O O O O O O O O O O $boolean$ O O O O $Error$ O O O $Error$ O O O O O O O $IQueueItem[]$ O $IQueueItem[]$ O O O $any[]$ O O O O O O $IDebugInfo[]$ O O O O $DeferredActionQueues$ O O O O $DeferredActionQueues[]$ O O $U[]$ O O $DeferredActionQueues$ O O $DeferredActionQueues$ O $DeferredActionQueues$ O $IDebugInfo$ O O O $boolean$ O O O O O O $undefined$ O O O $void$ O $boolean$ O O O $DeferredActionQueues$ O O O $DeferredActionQueues$ O O $DeferredActionQueues$ O $any$ O O O O O O O $DeferredActionQueues$ O O O O O O $ErrorConstructor$ O O O O O O $boolean$ O O O O $any$ O O O $any$ O $DeferredActionQueues$ O $QUEUE_STATE$ O $boolean$ O O O O O O O O $false$ O O $boolean$ O O O O O $any$ O $any$ O $QUEUE_STATE.Pause$ O O O $string$ O O O $string[]$ O $DeferredActionQueues$ O $number$ O O O O $void$ O $string$ O O O O O O O $DeferredActionQueues$ O O O O O O O $DeferredActionQueues[]$ O $number$ O O O O $DeferredActionQueues$ O O O $DeferredActionQueues[]$ O $DeferredActionQueues$ O O O $any$ O O O $DeferredActionQueues$ O $DeferredActionQueues$ O O O O O O O O $DeferredActionQueues$ O $DeferredActionQueues$ O O O O $void$ O $DeferredActionQueues$ O $DeferredActionQueues$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $DeferredActionQueues$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $undefined$ O $any$ O $undefined$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $IBackburnerOptions$ O O O O $DeferredActionQueues$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O O $boolean$ O O O O $IPlatform$ O $void$ O O O O O $boolean$ O O O O O $Error$ O O O O O O $number$ O $any$ O $any$ O $any$ O $any$ O O O $Error$ O O O $boolean$ O O $ErrorConstructor$ O O O $undefined$ O O $any$ O O O $IPlatform$ O $number$ O O O $any$ O O $number$ O $number$ O O O O O O $any[]$ O $number$ O O O O O O $any[]$ O $number$ O $any$ O $number$ O $any$ O $any$ O $any$ O $Error$ O O O O $void$ O O O O O O O $number$ O $number$ O $any$ O O O $any[]$ O O O O $any[]$ O $complex$ O $number$ O O O $any$ O $number$ O $any$ O $any$ O $any$ O $Error$ O O O O $void$ O O O O O $number$ O O O $boolean$ O $any$ O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O O O O O O O O $any[]$ O $number$ O O $any$ O O O O $any[]$ O $complex$ O $number$ O O O O O O O O $number$ O O O O O O $void$ O O O O O O O O O O O O O O O O $any$ O $any$ O O $string$ O $T$ O $any$ O $U$ O $any$ O O O $any$ O O O $complex$ O $string$ O O O O $any$ O $undefined$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O $any$ O $number$ O O $T$ O $U$ O O O O O O $void$ O O O O O $number$ O O O O O O O $any[]$ O $number$ O O O O O O $DeferredActionQueues$ O O O O O $void$ O O O O O $void$ O O O O O O $void$ O O O O $any[]$ O O O $any[]$ O O $number$ O O O O $number$ O $any[]$ O $number$ O O $string$ O O O $string$ O O $number$ O O O $IPlatform$ O $number$ O O O O O O $number$ O $number$ O $number$ O O O O O $any$ O $any[]$ O $number$ O O O O $any$ O $number$ O O O O O O $any$ O $any[]$ O $number$ O O O O O O $any$ O $complex$ O O O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $number$ O O O O O O $DeferredActionQueues$ O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any[]$ O $complex$ O O O $number$ O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O O O $number$ O O O O O O O O O $IPlatform$ O $void$ O O O $number$ O O O O $number$ O O O O O $void$ O O O O O O O $any[]$ O $number$ O O O O O O O O $any$ O O O $any[]$ O O O O O $number$ O O O $IPlatform$ O $number$ O O O O $number$ O $Math$ O $number$ O O O $any$ O $number$ O O O O $number$ O O O $IPlatform$ O $any$ O O O $void$ O $number$ O O O O $DeferredActionQueues$ O O O O $DeferredActionQueues$ O O O $DeferredActionQueues$ O O O $DeferredActionQueues$ O O O O O O $Error$ O O O $boolean$ O O $ErrorConstructor$ O O O $undefined$ O $DeferredActionQueues$ O O O $DeferredActionQueues$ O O O O O $void$ O O O $string[]$ O O O O O O O $DeferredActionQueues$ O O O $void$ O $string$ O O $number$ O O O $any$ O O O $IPlatform$ O $any$ O O $void$ O O O $IBackburnerOptions$ O $void$ O O O $void$ O O $void$ O $string$ O $any$ O O O O O $any$ O O O O O O $boolean$ O O O O O
'js' module . exports = function ( app ) { app . get ( 's' , function ( req , res ) { res . redirect ( 's' ) ; } ) } ;	O $void$ O $void$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
'js' module . exports = { framework : 's' , test_page : 's' , launch_in_ci : [ 's' ] , launch_in_dev : [ 's' ] , browser_args : { Chrome : { ci : [ process . env . CI ? 's' : null , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] . filter ( Boolean ) } } , } ;	O $complex$ O $complex$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O $complex$ O O $complex$ O O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O $complex$ O $BooleanConstructor$ O O O O O O
import Backburner from 's' ; import lolex from 's' ; const SET_TIMEOUT = setTimeout ; let fakeClock ; function escapeCurrentMicrotaskQueue ( ) { return new Promise ( ( resolve ) => { setTimeout ( resolve , 0 ) ; } ) ; } QUnit . module ( 's' , { afterEach ( ) { if ( fakeClock ) { fakeClock . uninstall ( ) ; } } } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; assert . ok ( ! bb . currentInstance , 's' ) ; assert . equal ( step ++ , 0 ) ; bb . schedule ( 's' , null , ( ) => { assert . equal ( step ++ , 0 ) ; setTimeout ( ( ) => { assert . ok ( ! bb . hasTimers ( ) , 's' ) ; done ( ) ; } ) ; } ) ; assert . ok ( bb . currentInstance , 's' ) ; assert . equal ( step ++ , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let order = - 0 ; let tasks = { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } } ; bb . schedule ( 's' , null , ( ) => { tasks . one . count ++ ; tasks . one . order = ++ order ; } ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } } ) ; bb . run ( ( ) => { bb . schedule ( 's' , null , ( ) => { tasks . two . count ++ ; tasks . two . order = ++ order ; } ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } } ) ; } ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : 0 } , two : { count : 0 , order : 0 } } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' , 's' ] ) ; let order = new Array ( ) ; bb . later ( ( ) => { order . push ( 's' ) ; } , 0 ) ; bb . schedule ( 's' , null , ( ) => { order . push ( 's' ) ; } ) ; setTimeout ( ( ) => { assert . deepEqual ( order , [ 's' , 's' ] ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; bb . schedule ( 's' , null , ( ) => { assert . notOk ( true , 's' ) ; } ) ; bb [ 's' ] ( ) ; setTimeout ( done , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let actual : string [ ] = [ ] ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . schedule ( 's' , function ( ) { actual . push ( 's' ) ; bb . schedule ( 's' , ( ) => { actual . push ( 's' ) ; } ) ; Promise . resolve ( ) . then ( ( ) => { actual . push ( 's' ) ; bb . schedule ( 's' , ( ) => { actual . push ( 's' ) ; } ) ; return Promise . resolve ( ) . then ( ( ) => { actual . push ( 's' ) ; bb . schedule ( 's' , ( ) => { actual . push ( 's' ) ; } ) ; } ) ; } ) ; } ) ; setTimeout ( function ( ) { assert . deepEqual ( actual , [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ; done ( ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; assert . ok ( ! bb . currentInstance , 's' ) ; assert . equal ( step ++ , 0 ) ; fakeClock = lolex . install ( ) ; bb . schedule ( 's' , null , ( ) => { assert . equal ( step ++ , 0 ) ; SET_TIMEOUT ( ( ) => { assert . ok ( ! bb . hasTimers ( ) , 's' ) ; done ( ) ; } ) ; } ) ; assert . ok ( bb . currentInstance , 's' ) ; assert . equal ( step ++ , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . step ( 's' ) ; let deferredFlush ; let bb = new Backburner ( [ 's' , 's' , 's' ] , { flush ( queueName , flush ) { if ( queueName === 's' ) { deferredFlush = flush ; } else { flush ( ) ; } } } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; return escapeCurrentMicrotaskQueue ( ) . then ( ( ) => { deferredFlush ( ) ; } ) . then ( escapeCurrentMicrotaskQueue ) . then ( ( ) => { assert . verifySteps ( [ 's' , 's' , 's' , 's' , ] ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . step ( 's' ) ; let deferredFlush ; let bb = new Backburner ( [ 's' , 's' , 's' ] , { flush ( queueName , flush ) { if ( deferredFlush === undefined && queueName === 's' ) { deferredFlush = flush ; } else { flush ( ) ; } } } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; return escapeCurrentMicrotaskQueue ( ) . then ( ( ) => { bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; deferredFlush ( ) ; } ) . then ( escapeCurrentMicrotaskQueue ) . then ( ( ) => { assert . verifySteps ( [ 's' , 's' , 's' , 's' , 's' , ] ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . step ( 's' ) ; let deferredFlush ; let bb = new Backburner ( [ 's' , 's' , 's' ] , { flush ( queueName , flush ) { if ( queueName === 's' ) { deferredFlush = flush ; } else { flush ( ) ; } } } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; bb . schedule ( 's' , null , ( ) => { assert . step ( 's' ) ; } ) ; return escapeCurrentMicrotaskQueue ( ) . then ( ( ) => { bb . run ( ( ) => { } ) ; assert . verifySteps ( [ 's' , 's' , 's' , 's' , ] ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $number$ O $number$ O O $any$ O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O O $void$ O O O $number$ O $void$ O O O O O O O O $any$ O $any$ O O O O $void$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $number$ O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O O $number$ O O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O O $number$ O O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O $any[]$ O O $ArrayConstructor$ O O O $any$ O $any$ O O O O O $any[]$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any[]$ O $number$ O O O O O O O $number$ O O O O O $any$ O $any$ O $any[]$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O $number$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O O O $string[]$ O $number$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O O O $string[]$ O $number$ O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $string[]$ O $number$ O O O O $any$ O $any$ O O O O O O O $string[]$ O $number$ O O O O O O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $string[]$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O O O O O $void$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise<unknown>$ O O O O O O O O O $any$ O O O O O O O O $Promise<unknown>$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O O O O O $void$ O $any$ O $any$ O O O O $any$ O $undefined$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise<unknown>$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Promise<unknown>$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O O O O O $void$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise<unknown>$ O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let timer ; let target = { fn ( ) { } } ; bb . schedule ( 's' , null , ( ) => { assert . ok ( ! bb . hasTimers ( ) , 's' ) ; timer = bb . later ( 's' , ( ) => { } ) ; assert . ok ( bb . hasTimers ( ) , 's' ) ; bb . cancel ( timer ) ; assert . ok ( ! bb . hasTimers ( ) , 's' ) ; timer = bb . debounce ( target , 's' , 0 ) ; assert . ok ( bb . hasTimers ( ) , 's' ) ; bb . cancel ( timer ) ; assert . ok ( ! bb . hasTimers ( ) , 's' ) ; timer = bb . throttle ( target , 's' , 0 ) ; assert . ok ( bb . hasTimers ( ) , 's' ) ; bb . cancel ( timer ) ; assert . ok ( ! bb . hasTimers ( ) , 's' ) ; done ( ) ; } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O $complex$ O O $void$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' , function ( ) { QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let next = Backburner . buildNext ( ( ) => assert . step ( 's' ) ) ; assert . step ( 's' ) ; Promise . resolve ( ) . then ( ( ) => assert . step ( 's' ) ) ; next ( ) ; Promise . resolve ( ) . then ( ( ) => assert . step ( 's' ) ) ; assert . step ( 's' ) ; setTimeout ( ( ) => { assert . verifySteps ( [ 's' , 's' , 's' , 's' , 's' , ] ) ; done ( ) ; } , 0 ) ; } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $number$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { let timer = bb . scheduleOnce ( 's' , ( ) => functionWasCalled = true ) ; assert . ok ( timer , 's' ) ; assert . ok ( bb . cancel ( timer ) , 's' ) ; assert . ok ( ! functionWasCalled , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let called = false ; let bb = new Backburner ( [ 's' ] , { onBegin ( ) { called = true ; } } ) ; let functionWasCalled = false ; let timer = bb . later ( ( ) => functionWasCalled = true ) ; assert . ok ( timer , 's' ) ; assert . ok ( bb . cancel ( timer ) , 's' ) ; assert . ok ( ! called , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! functionWasCalled , 's' ) ; assert . ok ( ! called , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let called = false ; let bb = new Backburner ( [ 's' ] , { onBegin ( ) { called = true ; } } ) ; let 0 = false ; let 0 = false ; let 0 = bb . later ( ( ) => 0 = true ) ; let 0 = bb . later ( ( ) => 0 = true ) ; assert . ok ( 0 , 's' ) ; assert . ok ( bb . cancel ( 0 ) , 's' ) ; assert . ok ( 0 , 's' ) ; assert . ok ( ! called , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! 0 , 's' ) ; assert . ok ( 0 , 's' ) ; assert . ok ( called , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let called = false ; let bb = new Backburner ( [ 's' ] , { onBegin ( ) { called = true ; } } ) ; let 0 = false ; let 0 = false ; let 0 = bb . later ( ( ) => 0 = true , 0 ) ; assert . ok ( 0 , 's' ) ; assert . ok ( bb . cancel ( 0 ) , 's' ) ; let 0 = bb . later ( ( ) => 0 = true , 0 ) ; assert . ok ( 0 , 's' ) ; assert . ok ( ! called , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! 0 , 's' ) ; assert . ok ( 0 , 's' ) ; assert . ok ( called , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let laterWasCalled = false ; let debounceWasCalled = false ; let throttleWasCalled = false ; let 0 = bb . later ( ( ) => laterWasCalled = true , 0 ) ; let 0 = bb . debounce ( ( ) => debounceWasCalled = true , 0 ) ; let 0 = bb . throttle ( ( ) => throttleWasCalled = true , 0 , false ) ; assert . ok ( 0 , 's' ) ; assert . ok ( 0 , 's' ) ; assert . ok ( 0 , 's' ) ; assert . ok ( bb . hasTimers ( ) , 's' ) ; bb . cancelTimers ( ) ; setTimeout ( function ( ) { assert . ok ( ! bb . hasTimers ( ) , 's' ) ; assert . ok ( ! laterWasCalled , 's' ) ; assert . ok ( ! debounceWasCalled , 's' ) ; assert . ok ( ! throttleWasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { let 0 = bb . scheduleOnce ( 's' , ( ) => bb . cancel ( 0 ) ) ; let 0 = bb . scheduleOnce ( 's' , ( ) => functionWasCalled = true ) ; } ) ; assert . ok ( ! functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let obj = { ___FOO___ : 0 } ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = 0 ; function fn ( ) { wasCalled ++ ; } bb . run ( ( ) => { let timer = bb . scheduleOnce ( 's' , obj , fn ) ; assert . equal ( wasCalled , 0 ) ; bb . cancel ( timer ) ; bb . scheduleOnce ( 's' , obj , fn ) ; assert . equal ( wasCalled , 0 ) ; } ) ; assert . equal ( wasCalled , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = 0 ; function fn ( ) { wasCalled ++ ; } bb . run ( ( ) => { let timer = bb . scheduleOnce ( 's' , fn ) ; assert . equal ( wasCalled , 0 ) ; bb . cancel ( timer ) ; bb . scheduleOnce ( 's' , fn ) ; assert . equal ( wasCalled , 0 ) ; } ) ; assert . equal ( wasCalled , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; bb . run ( function ( ) { let 0 = bb . schedule ( 's' , null , function ( ) { } ) ; assert . equal ( bb . cancel ( 0 ) , true ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; let 0 = bb . later ( function ( ) { } , 0 ) ; assert . equal ( bb . cancel ( 0 ) , true ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; let 0 = bb . debounce ( function ( ) { } , 0 ) ; assert . equal ( bb . cancel ( 0 ) , true ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; assert . equal ( bb . cancel ( undefined ) , false ) ; assert . equal ( bb . cancel ( null ) , false ) ; assert . equal ( bb . cancel ( { } ) , false ) ; assert . equal ( bb . cancel ( [ ] ) , false ) ; assert . equal ( bb . cancel ( 0 ) , false ) ; assert . equal ( bb . cancel ( 's' ) , false ) ; } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $boolean$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $boolean$ O O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $false$ O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $false$ O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $false$ O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O $any$ O $any$ O O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O O $number$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $complex$ O $void$ O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O $void$ O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O
import Backburner , { buildPlatform } from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] , { _buildPlatform ( flush ) { let platform = buildPlatform ( flush ) ; platform [ 's' ] = true ; return platform ; } } ) ; assert . ok ( bb [ 's' ] ! [ 's' ] , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let customNextWasUsed = false ; let bb = new Backburner ( [ 's' ] , { _buildPlatform ( flush ) { return { next ( ) { throw new TypeError ( 's' ) ; } , clearNext ( ) { } , setTimeout ( cb ) { customNextWasUsed = true ; return setTimeout ( cb ) ; } , clearTimeout ( timer ) { return clearTimeout ( timer ) ; } , now ( ) { return Date . now ( ) ; } , isFakePlatform : true } ; } } ) ; bb . setTimeout ( ( ) => { assert . ok ( customNextWasUsed , 's' ) ; done ( ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let customNextWasUsed = false ; let bb = new Backburner ( [ 's' ] , { _buildPlatform ( flush ) { return { setTimeout ( ) { throw new TypeError ( 's' ) ; } , clearTimeout ( timer ) { return clearTimeout ( timer ) ; } , next ( ) { customNextWasUsed = true ; return setTimeout ( flush ) ; } , clearNext ( ) { } , now ( ) { return Date . now ( ) ; } , isFakePlatform : true } ; } } ) ; bb . scheduleOnce ( 's' , ( ) => { assert . ok ( customNextWasUsed , 's' ) ; done ( ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let functionWasCalled = false ; let customClearTimeoutWasUsed = false ; let bb = new Backburner ( [ 's' ] , { _buildPlatform ( flush ) { return { setTimeout ( method , wait ) { return setTimeout ( method , wait ) ; } , clearTimeout ( timer ) { customClearTimeoutWasUsed = true ; return clearTimeout ( timer ) ; } , next ( ) { return setTimeout ( flush , 0 ) ; } , clearNext ( ) { customClearTimeoutWasUsed = true ; } , now ( ) { return Date . now ( ) ; } } ; } } ) ; bb . scheduleOnce ( 's' , ( ) => functionWasCalled = true ) ; bb . cancelTimers ( ) ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , ( ) => { assert . ok ( ! functionWasCalled , 's' ) ; assert . ok ( customClearTimeoutWasUsed , 's' ) ; } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let currentTime = 0 ; let customNowWasUsed = false ; let bb = new Backburner ( [ 's' ] , { _buildPlatform ( flush ) { return { setTimeout ( method , wait ) { return setTimeout ( method , wait ) ; } , clearTimeout ( id ) { clearTimeout ( id ) ; } , next ( ) { return setTimeout ( flush , 0 ) ; } , clearNext ( ) { } , now ( ) { customNowWasUsed = true ; return currentTime += 0 ; } , } ; } } ) ; bb . later ( ( ) => { assert . ok ( customNowWasUsed , 's' ) ; done ( ) ; } , 0 ) ; } ) ;	O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $complex$ O $any$ O O O O $never$ O O O O O $TypeErrorConstructor$ O O O O O O $void$ O O O O O $number$ O $any$ O O $boolean$ O O O O $number$ O $any$ O O O O $void$ O $any$ O O O $void$ O $any$ O O O O $number$ O O O O $DateConstructor$ O $number$ O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $complex$ O $any$ O O O O $never$ O O O O O $TypeErrorConstructor$ O O O O O O $void$ O $any$ O O O $void$ O $any$ O O O O $number$ O O O $boolean$ O O O O $number$ O $any$ O O O O $void$ O O O O O $number$ O O O O $DateConstructor$ O $number$ O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $boolean$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $complex$ O $any$ O O O O $number$ O $any$ O $any$ O O O $number$ O $any$ O $any$ O O O O $void$ O $any$ O O $boolean$ O O O O $void$ O $any$ O O O O $number$ O O O O $number$ O $any$ O O O O O O $void$ O O O $boolean$ O O O O O $number$ O O O O $DateConstructor$ O $number$ O O O O O O O O O O $any$ O $any$ O O O O O O $boolean$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $number$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O $complex$ O $any$ O O O O $number$ O $any$ O $any$ O O O $number$ O $any$ O $any$ O O O O $void$ O $any$ O O $void$ O $any$ O O O O $number$ O O O O $number$ O $any$ O O O O O O $void$ O O O O O $number$ O O O $boolean$ O O O O $number$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O
import Backburner from 's' ; import lolex from 's' ; const DATE_NOW = Date . now ; let fakeClock ; QUnit . module ( 's' , { afterEach ( ) { if ( fakeClock ) { fakeClock . uninstall ( ) ; } } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; let done = assert . async ( ) ; let wasCalled = false ; function debouncee ( ) { assert . ok ( ! wasCalled ) ; wasCalled = true ; } bb . debounce ( null , debouncee , 0 ) ; assert . equal ( step ++ , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled , 's' ) ; bb . debounce ( null , debouncee , 0 ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled , 's' ) ; bb . debounce ( null , debouncee , 0 ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled , 's' ) ; bb . debounce ( null , debouncee , 0 ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { wasCalled = false ; assert . equal ( step ++ , 0 ) ; bb . debounce ( null , debouncee , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; let wasCalled = false ; function debouncee ( ) { assert . ok ( ! wasCalled ) ; wasCalled = true ; } bb . debounce ( null , debouncee , 0 , true ) ; assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled ) ; wasCalled = false ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . debounce ( null , debouncee , 0 , true ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . debounce ( null , debouncee , 0 , true ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . debounce ( null , debouncee , 0 , true ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; } , 0 ) ; setTimeout ( ( ) => { wasCalled = false ; assert . equal ( step ++ , 0 ) ; bb . debounce ( null , debouncee , 0 , true ) ; assert . ok ( wasCalled , 's' ) ; wasCalled = false ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { throw error ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . run ( ( ) => { let parentInstance = bb . currentInstance ; bb . debounce ( null , ( ) => { assert . equal ( bb . currentInstance , parentInstance ) ; } , 0 , true ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; let wasCalled = false ; function debouncee ( ) { assert . ok ( ! wasCalled ) ; wasCalled = true ; } bb . debounce ( null , debouncee , 's' ) ; assert . equal ( step ++ , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . debounce ( null , debouncee , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = false ; function debouncee ( ) { assert . ok ( false , 's' ) ; wasCalled = true ; } let timer = bb . debounce ( null , debouncee , 0 ) ; assert . ok ( bb . cancel ( timer ) , 's' ) ; assert . ok ( ! bb . cancel ( timer ) , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = false ; function debouncee ( ) { assert . ok ( true , 's' ) ; wasCalled = true ; } let timer = bb . debounce ( null , debouncee , 0 ) ; setTimeout ( ( ) => { assert . ok ( ! bb . cancel ( timer ) , 's' ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; function debouncee ( arg ) { assert . equal ( 's' , arg , 's' ) ; done ( ) ; } bb . debounce ( null , debouncee , 's' , 0 ) ; bb . debounce ( null , debouncee , 's' , 0 ) ; bb . debounce ( null , debouncee , 's' , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = false ; let done = assert . async ( ) ; function debouncee ( ) { assert . ok ( true , 's' ) ; if ( wasCalled ) { done ( ) ; } wasCalled = true ; } let timer = bb . debounce ( null , debouncee , 0 ) ; setTimeout ( ( ) => { bb . debounce ( null , debouncee , 0 ) ; assert . ok ( ! bb . cancel ( timer ) , 's' ) ; assert . ok ( wasCalled , 's' ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; function debouncee ( ) { calledCount ++ ; } let timer = bb . debounce ( null , debouncee , 0 , true ) ; setTimeout ( ( ) => { assert . equal ( 0 , calledCount , 's' ) ; assert . ok ( bb . cancel ( timer ) , 's' ) ; bb . debounce ( null , debouncee , 0 , true ) ; setTimeout ( ( ) => { assert . equal ( 0 , calledCount , 's' ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith = new Array ( ) ; function debouncee ( ... args ) { calledCount ++ ; calledWith . push ( args ) ; } bb . debounce ( debouncee , 0 ) ; bb . debounce ( debouncee , 0 ) ; bb . debounce ( debouncee , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; assert . deepEqual ( calledWith , [ [ ] ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; function debouncee ( ) { calledCount ++ ; } bb . debounce ( debouncee , 0 ) ; bb . debounce ( debouncee , 0 ) ; let timer = bb . debounce ( debouncee , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { bb . cancel ( timer ) ; assert . equal ( calledCount , 0 , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith = new Array ( ) ; function debouncee ( ... args ) { calledCount ++ ; calledWith . push ( args ) ; } bb . debounce ( debouncee , 0 , true ) ; bb . debounce ( debouncee , 0 , true ) ; bb . debounce ( debouncee , 0 , true ) ; assert . equal ( calledCount , 0 , 's' ) ; assert . deepEqual ( calledWith , [ [ ] ] , 's' ) ; setTimeout ( ( ) => { bb . debounce ( debouncee , 0 , true ) ; assert . equal ( calledCount , 0 , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let fooCalledCount = 0 ; let barCalledCount = 0 ; function foo ( ) { fooCalledCount ++ ; } function bar ( ) { barCalledCount ++ ; } bb . debounce ( foo , 0 , true ) ; bb . debounce ( foo , 0 , true ) ; assert . equal ( fooCalledCount , 0 , 's' ) ; bb . debounce ( bar , 0 , true ) ; let timer = bb . debounce ( bar , 0 , true ) ; assert . equal ( barCalledCount , 0 , 's' ) ; bb . cancel ( timer ) ; bb . debounce ( bar , 0 , true ) ; assert . equal ( barCalledCount , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith : object [ ] = [ ] ; function debouncee ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; bb . debounce ( debouncee , foo , 0 ) ; bb . debounce ( debouncee , bar , 0 ) ; bb . debounce ( debouncee , baz , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ { isBaz : true } ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith : object [ ] = [ ] ; function debouncee ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; bb . debounce ( debouncee , foo , 0 ) ; bb . debounce ( debouncee , bar , 0 ) ; let timer = bb . debounce ( debouncee , baz , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ ] , 's' ) ; bb . cancel ( timer ) ; } , 0 ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith = new Array ( ) ; function debouncee ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; let qux = { isQux : true } ; bb . debounce ( debouncee , foo , 0 , true ) ; bb . debounce ( debouncee , bar , 0 , true ) ; bb . debounce ( debouncee , baz , 0 , true ) ; assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; setTimeout ( ( ) => { bb . debounce ( debouncee , qux , 0 , true ) ; assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith : object [ ] = [ ] ; function debouncee ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; let qux = { isQux : true } ; bb . debounce ( debouncee , foo , 0 , true ) ; bb . debounce ( debouncee , bar , 0 , true ) ; let timer = bb . debounce ( debouncee , baz , 0 , true ) ; assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; setTimeout ( ( ) => { bb . cancel ( timer ) ; bb . debounce ( debouncee , qux , 0 , true ) ; assert . deepEqual ( calledWith , [ { isFoo : true } , { isQux : true } ] , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ { isFoo : true } , { isQux : true } ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; done ( ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . debounce ( null , ( ) => { throw new Error ( 's' ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let foo = ( ) => { assert . ok ( true , 's' ) ; return bb . debounce ( bar , 0 ) ; } ; let bar = ( ) => { assert . ok ( true , 's' ) ; let timer = foo ( ) ; bb . cancel ( timer ) ; setTimeout ( done , 0 ) ; } ; foo ( ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . debounce ( function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' , 0 , true ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; fakeClock = lolex . install ( ) ; let startTime = DATE_NOW ( ) ; bb . debounce ( ( ) => { let endTime = DATE_NOW ( ) ; assert . ok ( endTime - startTime < 0 , 's' ) ; done ( ) ; } , 0 ) ; fakeClock . tick ( 0 ) ; } ) ;	O $any$ O O O O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O $any$ O $any$ O $any$ O O O O $void$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $number$ O O O O O $boolean$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $false$ O O $boolean$ O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O O O O $number$ O O O O O $boolean$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O $false$ O O O O $boolean$ O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O O $any$ O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O O O $boolean$ O O $any$ O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O O $number$ O O O O O $any$ O $any$ O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O O O O O $number$ O O O O O $any$ O $any$ O O O $number$ O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any[]$ O O $ArrayConstructor$ O O O O $void$ O O $any[]$ O O $number$ O O $any[]$ O $number$ O $any[]$ O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $number$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any[]$ O O $ArrayConstructor$ O O O O $void$ O O $any[]$ O O $number$ O O $any[]$ O $number$ O $any[]$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any[]$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $number$ O O O O $number$ O O O O $void$ O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $void$ O O O O O O O $any$ O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $number$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $number$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O $any$ O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any[]$ O O $ArrayConstructor$ O O O O $void$ O $any$ O O $number$ O O $any[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $any[]$ O O O $boolean$ O O O O O O O O $number$ O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $any[]$ O O O $boolean$ O O O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $any[]$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $number$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O O O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O $boolean$ O O O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $void$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $number$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $number$ O $number$ O O O $any$ O $any$ O O O O O O $number$ O $number$ O O O $any$ O $any$ O $number$ O $number$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O
const ERROR = Error ; Error = ERROR ; let stacks : string [ ] = [ ] ; export function pushStackTrace ( stackLine ) { stacks . push ( stackLine ) ; return stackLine ; } export function overrideError ( _Error ) { Error = _Error ; } export function resetError ( ) { Error = ERROR ; stacks = [ ] ; } export default class MockStableError { constructor ( public message ) { } get stack ( ) : string { return stacks . pop ( ) || 's' ; } }	O $ErrorConstructor$ O $ErrorConstructor$ O $ErrorConstructor$ O $ErrorConstructor$ O O $string[]$ O O O O O O O O O O $string$ O $string$ O O $string[]$ O $number$ O $string$ O O O $string$ O O O O $void$ O $any$ O O $ErrorConstructor$ O $any$ O O O O $void$ O O O $ErrorConstructor$ O $ErrorConstructor$ O $string[]$ O O O O O O O O $any$ O O O O $string$ O O O O $string$ O O O O O O $string[]$ O $string$ O O O O O O O
import Backburner from 's' ; import MockStableError , { overrideError , pushStackTrace , resetError , } from 's' ; QUnit . module ( 's' , { beforeEach : function ( ) { overrideError ( MockStableError ) ; } , afterEach : function ( ) { resetError ( ) ; } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let bb = new Backburner ( [ 's' ] ) ; bb . run ( function ( ) { debugInfo = bb . getDebugInfo ( ) ; assert . equal ( debugInfo , undefined , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let 0 = { one : true } ; let 0 = { two : true } ; let method = ( ) => { } ; let 0 = 0 ; let 0 = 0 ; let twoStack = pushStackTrace ( 's' ) ; let oneStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . later ( 0 , method , 0 , 0 ) ; bb . later ( 0 , method , 0 , 0 , 0 ) ; debugInfo = bb . getDebugInfo ( ) ; resetError ( ) ; assert . deepEqual ( debugInfo . timers , [ { args : [ 0 ] , method , stack : oneStack , target : 0 } , { args : [ 0 , 0 ] , method , stack : twoStack , target : 0 } ] , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let 0 = { one : true } ; let 0 = { two : true } ; let method = ( ) => { } ; let 0 = 0 ; let 0 = 0 ; let twoStack = pushStackTrace ( 's' ) ; let oneStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . throttle ( 0 , method , 0 , 0 , false ) ; bb . throttle ( 0 , method , 0 , 0 , 0 , false ) ; debugInfo = bb . getDebugInfo ( ) ; resetError ( ) ; assert . deepEqual ( debugInfo . timers , [ { args : [ 0 ] , method , stack : oneStack , target : 0 } , { args : [ 0 , 0 ] , method , stack : twoStack , target : 0 } ] , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let 0 = { one : true } ; let 0 = { two : true } ; let method = ( ) => { } ; let 0 = 0 ; let 0 = 0 ; let twoStack = pushStackTrace ( 's' ) ; let oneStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . debounce ( 0 , method , 0 , 0 ) ; bb . debounce ( 0 , method , 0 , 0 , 0 ) ; debugInfo = bb . getDebugInfo ( ) ; resetError ( ) ; assert . deepEqual ( debugInfo . timers , [ { args : [ 0 ] , method , stack : oneStack , target : 0 } , { args : [ 0 , 0 ] , method , stack : twoStack , target : 0 } ] , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let 0 = { one : true } ; let 0 = { two : true } ; let method = ( ) => { } ; let 0 = 0 ; let 0 = 0 ; let twoStack = pushStackTrace ( 's' ) ; let oneStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . schedule ( 's' , 0 , method , 0 ) ; bb . schedule ( 's' , 0 , method , 0 , 0 ) ; debugInfo = bb . getDebugInfo ( ) ; resetError ( ) ; assert . deepEqual ( debugInfo . instanceStack , [ { one : [ { args : [ 0 ] , method , stack : oneStack , target : 0 } ] , two : [ { args : [ 0 , 0 ] , method , stack : twoStack , target : 0 } ] } ] , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let method = ( ) => { } ; let twoStack = pushStackTrace ( 's' ) ; let oneStack = pushStackTrace ( 's' ) ; let fourStack = pushStackTrace ( 's' ) ; let threeStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' , 's' , 's' , 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . schedule ( 's' , method ) ; bb . schedule ( 's' , method ) ; bb . run ( function ( ) { bb . schedule ( 's' , method ) ; bb . schedule ( 's' , method ) ; debugInfo = bb . getDebugInfo ( ) ; resetError ( ) ; assert . deepEqual ( debugInfo . instanceStack , [ { four : [ { args : undefined , method , stack : fourStack , target : null } ] , one : [ ] , three : [ { args : undefined , method , stack : threeStack , target : null } ] , two : [ ] } , { four : [ ] , one : [ { args : undefined , method , stack : oneStack , target : null } ] , three : [ ] , two : [ { args : undefined , method , stack : twoStack , target : null } ] } ] , 's' ) ; } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let autorunStack = pushStackTrace ( 's' ) ; pushStackTrace ( 's' ) ; bb . DEBUG = true ; bb . schedule ( 's' , null , ( ) => { setTimeout ( ( ) => { assert . equal ( bb . getDebugInfo ( ) ! . autorun , null ) ; done ( ) ; } ) ; } ) ; assert . equal ( bb . getDebugInfo ( ) ! . autorun ! . stack , autorunStack ) ; } ) ;	O $any$ O O O O $any$ O O $void$ O $string$ O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $void$ O $any$ O O O O $void$ O O O O O $void$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $undefined$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $void$ O O O O O O O O $number$ O O O O $number$ O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O $number$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O $number[]$ O O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O $number[]$ O O $number$ O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $void$ O O O O O O O O $number$ O O O O $number$ O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O O O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O $number[]$ O O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O $number[]$ O O $number$ O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $void$ O O O O O O O O $number$ O O O O $number$ O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O O O O $any$ O $any$ O $complex$ O $void$ O $number$ O $number$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O $number[]$ O O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O $number[]$ O O $number$ O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $void$ O O O O O O O O $number$ O O O O $number$ O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O $number$ O O $any$ O $any$ O O O $complex$ O $void$ O $number$ O $number$ O O $any$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $number[]$ O O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O $complex$ O O O $number[]$ O O $number$ O $number$ O O $void$ O $string$ O $string$ O $complex$ O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $undefined$ O $undefined$ O $void$ O $string$ O $string$ O $null$ O O O O O $undefined[]$ O O O O $complex$ O O O $undefined$ O $undefined$ O $void$ O $string$ O $string$ O $null$ O O O O O $undefined[]$ O O O O O O $undefined[]$ O O O O $complex$ O O O $undefined$ O $undefined$ O $void$ O $string$ O $string$ O $null$ O O O O O $undefined[]$ O O O O $complex$ O O O $undefined$ O $undefined$ O $void$ O $string$ O $string$ O $null$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $string$ O $string$ O O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; bb . schedule ( 's' , ( ) => { } ) ; if ( ! bb . currentInstance ) { throw new Error ( 's' ) ; } assert . ok ( bb . currentInstance && ! bb . currentInstance . queues . one . stackFor ( 0 ) , 's' ) ; bb . DEBUG = true ; bb . schedule ( 's' , ( ) => { } ) ; if ( new Error ( ) . stack ) { assert . expect ( 0 ) ; let stack = bb . currentInstance && bb . currentInstance . queues . one . stackFor ( 0 ) ; assert . ok ( typeof stack === 's' , 's' ) ; let onError = function ( error , errorRecordedForStack ) { assert . ok ( errorRecordedForStack , 's' ) ; assert . ok ( errorRecordedForStack . stack , 's' ) ; } ; bb = new Backburner ( [ 's' ] , { onError } ) ; bb . DEBUG = true ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; } } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let onError = function ( error , errorRecordedForStack ) { assert . strictEqual ( errorRecordedForStack , undefined , 's' ) ; done ( ) ; } ; let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . later ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; if ( new Error ( ) . stack ) { QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let onError = function ( error , errorRecordedForStack ) { assert . ok ( errorRecordedForStack , 's' ) ; assert . ok ( errorRecordedForStack . stack , 's' ) ; assert . ok ( errorRecordedForStack . stack . indexOf ( 's' ) > - 0 , 's' ) ; done ( ) ; } ; let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . DEBUG = true ; bb . later ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; }	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O O O $ErrorConstructor$ O O O $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $void$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O O O $any$ O O O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O $ErrorConstructor$ O O O $string$ O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O
import Backburner from 's' ; import MockStableError , { overrideError , pushStackTrace , resetError , } from 's' ; QUnit . module ( 's' , { beforeEach : function ( ) { overrideError ( MockStableError ) ; } , afterEach : function ( ) { resetError ( ) ; } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . run ( ( ) => { debugInfo = bb . currentInstance && bb . currentInstance . _getDebugInfo ( bb . DEBUG ) ; assert . equal ( debugInfo , undefined ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let method = ( ) => { } ; let afterRenderStack = pushStackTrace ( 's' ) ; let renderStack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . DEBUG = true ; bb . run ( ( ) => { bb . schedule ( 's' , method ) ; bb . schedule ( 's' , method ) ; debugInfo = bb . currentInstance && bb . currentInstance . _getDebugInfo ( bb . DEBUG ) ; assert . deepEqual ( debugInfo , { render : [ { target : null , method , args : undefined , stack : renderStack } ] , afterRender : [ { target : null , method , args : undefined , stack : afterRenderStack } ] } ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O $void$ O $string$ O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $void$ O $any$ O O O O $void$ O O O O O $void$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O O $null$ O O O $void$ O $undefined$ O $undefined$ O $string$ O $string$ O O O $complex$ O O O $null$ O O O $void$ O $undefined$ O $undefined$ O $string$ O $string$ O O O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; class Iterator { private _collection : Function [ ] ; private _iteration : number = 0 ; constructor ( collection : Function [ ] ) { this . _collection = collection ; } public next ( ) { let iteration = this . _iteration ++ ; let collection = this . _collection ; let done = collection . length <= iteration ; let value = done ? undefined : collection [ iteration ] ; return { done , value } ; } } QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let order = 0 ; let tasks = { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } , three : { count : 0 , order : - 0 } } ; function 0 ( ) { tasks . one . count ++ ; tasks . one . order = order ++ ; } function 0 ( ) { tasks . two . count ++ ; tasks . two . order = order ++ ; } function 0 ( ) { tasks . three . count ++ ; tasks . three . order = order ++ ; } let iterator = ( ) => new Iterator ( [ 0 , 0 , 0 ] ) ; bb . run ( ( ) => { bb . scheduleIterable ( 's' , iterator ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } , three : { count : 0 , order : - 0 } } ) ; } ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : 0 } , two : { count : 0 , order : 0 } , three : { count : 0 , order : 0 } } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Function[]$ O $FunctionConstructor$ O O O O $number$ O O O O O O O $Function[]$ O $FunctionConstructor$ O O O O O O $Function[]$ O $Function[]$ O O O $complex$ O O O O $number$ O O O $number$ O O O $Function[]$ O O O $Function[]$ O O $boolean$ O $Function[]$ O $number$ O $number$ O O $Function$ O $boolean$ O $undefined$ O $Function[]$ O $number$ O O O O $boolean$ O $Function$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $number$ O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O $void$ O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O $number$ O O O O $void$ O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O $number$ O O O O $void$ O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O $number$ O O O O $Iterator$ O O O O O $any$ O O $void$ O $void$ O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $Iterator$ O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , ( ) => { functionWasCalled = true ; } ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , { zomg : 's' } , function ( ) { assert . equal ( this . zomg , 's' , 's' ) ; functionWasCalled = true ; } ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; let targetObject = { zomg : 's' , checkFunction ( ) { assert . equal ( this . zomg , 's' , 's' ) ; functionWasCalled = true ; } } ; bb . run ( ( ) => bb . scheduleOnce ( 's' , targetObject , 's' ) ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . scheduleOnce ( 's' , { zomg : 's' } , null ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . deferOnce ( 's' , { zomg : 's' } , undefined ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . deferOnce ( 's' , { zomg : 's' } , 's' ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , { zomg : 's' } , function ( a , b , c ) { assert . equal ( this . zomg , 's' , 's' ) ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( c , 0 , 's' ) ; functionWasCalled = true ; } , 0 , 0 , 0 ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; let functionWasCalled = false ; function deferMethod ( ) { i ++ ; assert . equal ( i , 0 , 's' ) ; functionWasCalled = true ; } bb . run ( ( ) => { bb . scheduleOnce ( 's' , deferMethod ) ; bb . scheduleOnce ( 's' , deferMethod ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; let functionWasCalled = false ; function deferMethod ( ) { i ++ ; assert . equal ( i , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; functionWasCalled = true ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , argObj , deferMethod ) ; bb . scheduleOnce ( 's' , argObj , deferMethod ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( ) { i ++ ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } bb . run ( ( ) => { bb . scheduleOnce ( 's' , { first : 0 } , deferMethod ) ; bb . scheduleOnce ( 's' , { first : 0 } , deferMethod ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 , 0 ) ; bb . scheduleOnce ( 's' , argObj , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 , 0 ) ; bb . scheduleOnce ( 's' , argObj , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; if ( i === 0 ) { assert . equal ( a , 0 , 's' ) ; } else { assert . equal ( a , 0 , 's' ) ; } assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , { first : 0 } , deferMethod , 0 , 0 ) ; bb . scheduleOnce ( 's' , { first : 0 } , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' , 's' ] ) ; let i = 0 ; function deferMethod ( a ) { i ++ ; assert . equal ( a , i , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } function scheduleMethod ( ) { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 ) ; bb . scheduleOnce ( 's' , argObj , scheduleMethod ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let argObj = { first : 0 } ; let bb = new Backburner ( [ 's' , 's' ] , { } ) ; let i = 0 ; function deferMethod ( a ) { i ++ ; assert . equal ( a , i , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } function scheduleMethod ( ) { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 ) ; } bb . run ( ( ) => { bb . scheduleOnce ( 's' , argObj , deferMethod , 0 ) ; bb . scheduleOnce ( 's' , argObj , scheduleMethod ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . scheduleOnce ( 's' , function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' , 0 ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $complex$ O O $string$ O O O $void$ O O O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O $undefined$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $boolean$ O O O O $void$ O O O $number$ O O $any$ O $any$ O $number$ O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $boolean$ O O O O $void$ O O O $number$ O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O $any$ O $any$ O O O $complex$ O $void$ O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $number$ O O O O $void$ O O $any$ O $any$ O O O O $number$ O O O O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $number$ O O O O $void$ O O O O O O $any$ O $any$ O O O O $number$ O O O O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O $number$ O O O O $void$ O $any$ O O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O O O O O O O O O O O O $void$ O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O O $number$ O O O O O $any$ O O $any$ O O O O O O O O O O O O $number$ O O O O $void$ O $any$ O O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O O O O O O O O O O O O $void$ O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O
import Backburner from 's' ; let originalDateValueOf = Date . prototype . valueOf ; QUnit . module ( 's' , { afterEach ( ) { Date . prototype . valueOf = originalDateValueOf ; } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => functionWasCalled = true ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . schedule ( 's' , { zomg : 's' } , function ( ) { assert . equal ( this . zomg , 's' , 's' ) ; functionWasCalled = true ; } ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . schedule ( 's' , function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; let targetObject = { zomg : 's' , checkFunction ( ) { assert . equal ( this . zomg , 's' , 's' ) ; functionWasCalled = true ; } } ; bb . run ( ( ) => bb . schedule ( 's' , targetObject , 's' ) ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . schedule ( 's' , { zomg : 's' } , null ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . schedule ( 's' , { zomg : 's' } , undefined ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => bb . schedule ( 's' , { zomg : 's' } , 's' ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . schedule ( 's' , { zomg : 's' } , function ( a , b , c ) { assert . equal ( this . zomg , 's' , 's' ) ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( c , 0 , 's' ) ; functionWasCalled = true ; } , 0 , 0 , 0 ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( ) { i ++ ; } bb . run ( ( ) => { bb . schedule ( 's' , deferMethod ) ; bb . schedule ( 's' , deferMethod ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; let argObj = { first : 0 } ; function deferMethod ( ) { assert . equal ( this [ 's' ] , 0 , 's' ) ; } bb . run ( ( ) => { bb . schedule ( 's' , argObj , deferMethod ) ; bb . schedule ( 's' , argObj , deferMethod ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . schedule ( 's' , argObj , deferMethod , 0 , 0 ) ; bb . schedule ( 's' , argObj , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; if ( i === 0 ) { assert . equal ( a , 0 , 's' ) ; } else { assert . equal ( a , 0 , 's' ) ; } assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . schedule ( 's' , argObj , deferMethod , 0 , 0 ) ; bb . schedule ( 's' , argObj , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let i = 0 ; function deferMethod ( a , b ) { i ++ ; if ( i === 0 ) { assert . equal ( a , 0 , 's' ) ; } else { assert . equal ( a , 0 , 's' ) ; } assert . equal ( b , 0 , 's' ) ; assert . equal ( this [ 's' ] , 0 , 's' ) ; } let argObj = { first : 0 } ; bb . run ( ( ) => { bb . schedule ( 's' , { first : 0 } , deferMethod , 0 , 0 ) ; bb . schedule ( 's' , { first : 0 } , deferMethod , 0 , 0 ) ; } ) ; assert . equal ( i , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError } ) ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; } ) ;	O $any$ O O O O $number$ O $DateConstructor$ O $Date$ O $number$ O $any$ O $any$ O O O O $void$ O O O $DateConstructor$ O $Date$ O $number$ O $number$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $boolean$ O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $complex$ O O $string$ O O O $void$ O O O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O $undefined$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $complex$ O O $number$ O O O O O $void$ O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $void$ O $any$ O $any$ O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $number$ O O O O $void$ O O O O O O $any$ O $any$ O O O O $number$ O O O O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . on ( 's' , ( ) => callNumber ++ ) ; function funcOne ( ) { assert . equal ( callNumber , 0 ) ; } function funcTwo ( ) { assert . equal ( callNumber , 0 ) ; } bb . run ( ( ) => { bb . schedule ( 's' , null , funcOne ) ; bb . schedule ( 's' , null , funcTwo ) ; } ) ; assert . equal ( callNumber , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let bb = new Backburner ( [ 's' , 's' ] , { onEnd ( ) { assert . equal ( callNumber , 0 ) ; } } ) ; bb . on ( 's' , ( ) => callNumber ++ ) ; function funcOne ( ) { assert . equal ( callNumber , 0 ) ; } function funcTwo ( ) { assert . equal ( callNumber , 0 ) ; } bb . run ( ( ) => { bb . schedule ( 's' , null , funcOne ) ; bb . schedule ( 's' , null , funcTwo ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let firstArgument = null ; let secondArgument = null ; let bb = new Backburner ( [ 's' ] , { onEnd ( first , second ) { assert . equal ( firstArgument , first ) ; assert . equal ( secondArgument , second ) ; } } ) ; bb . on ( 's' , ( first , second ) => { firstArgument = first ; secondArgument = second ; } ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let bb = new Backburner ( [ 's' , 's' ] ) ; bb . on ( 's' , ( ) => callNumber ++ ) ; function funcOne ( ) { assert . equal ( callNumber , 0 ) ; } function funcTwo ( ) { assert . equal ( callNumber , 0 ) ; } assert . equal ( callNumber , 0 ) ; bb . run ( ( ) => { bb . schedule ( 's' , null , funcOne ) ; bb . schedule ( 's' , null , funcTwo ) ; } ) ; assert . equal ( callNumber , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let bb = new Backburner ( [ 's' , 's' ] , { onBegin ( ) { assert . equal ( callNumber , 0 ) ; } } ) ; bb . on ( 's' , ( ) => callNumber ++ ) ; bb . run ( ( ) => { bb . schedule ( 's' , null , ( ) => { } ) ; bb . schedule ( 's' , null , ( ) => { } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let callNumber = 0 ; let firstArgument = null ; let secondArgument = null ; let bb = new Backburner ( [ 's' ] , { onBegin ( first , second ) { assert . equal ( firstArgument , first ) ; assert . equal ( secondArgument , second ) ; } } ) ; bb . on ( 's' , ( first , second ) => { firstArgument = first ; secondArgument = second ; } ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let firstCalled = false ; let secondCalled = false ; let bb = new Backburner ( [ 's' ] ) ; function first ( ) { firstCalled = true ; } function second ( ) { secondCalled = true ; } bb . on ( 's' , first ) ; bb . on ( 's' , second ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; assert . equal ( secondCalled , true ) ; assert . equal ( firstCalled , true ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let firstCalled = false ; let secondCalled = false ; let bb = new Backburner ( [ 's' ] ) ; function first ( ) { firstCalled = true ; } function second ( ) { secondCalled = true ; } bb . on ( 's' , first ) ; bb . on ( 's' , second ) ; bb . off ( 's' , first ) ; bb . run ( ( ) => bb . schedule ( 's' , null , ( ) => { } ) ) ; assert . equal ( secondCalled , true ) ; assert . equal ( firstCalled , false ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $void$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $void$ O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $boolean$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O O $void$ O O O $boolean$ O O O O O $void$ O O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $boolean$ O O O O $boolean$ O O O O $any$ O O $any$ O O O O O O O $void$ O O O $boolean$ O O O O O $void$ O O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O $any$ O $any$ O $false$ O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; function depth ( bb ) { return bb . instanceStack . length + ( bb . currentInstance ? 0 : 0 ) ; } QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; assert . equal ( depth ( bb ) , 0 ) ; let result = bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; return 's' ; } ) ; assert . equal ( result , 's' ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; assert . equal ( depth ( bb ) , 0 ) ; bb . run ( ( ) => { let result = bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; return 's' ; } ) ; assert . equal ( result , 's' ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; assert . equal ( depth ( bb ) , 0 ) ; bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; assert . equal ( depth ( bb ) , 0 ) ; bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; bb . run ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; bb . join ( ( ) => { assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; assert . equal ( depth ( bb ) , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let items : number [ ] = [ ] ; bb . run ( ( ) => { items . push ( 0 ) ; bb . schedule ( 's' , ( ) => items . push ( 0 ) ) ; bb . join ( ( ) => { items . push ( 0 ) ; bb . schedule ( 's' , ( ) => items . push ( 0 ) ) ; items . push ( 0 ) ; } ) ; bb . schedule ( 's' , ( ) => items . push ( 0 ) ) ; items . push ( 0 ) ; } ) ; assert . deepEqual ( items , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; assert . throws ( ( ) => { bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } , "s" ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] , { onError ( error ) { assert . notOk ( true , 's' ) ; } } ) ; bb . run ( ( ) => { assert . throws ( ( ) => { bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } , "s" , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . run ( ( ) => { bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; throw error ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; assert . throws ( ( ) => { bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } , "s" ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; throw error ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; assert . throws ( ( ) => { bb . run ( ( ) => { bb . join ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; } , "s" ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . join ( function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number[]$ O O O O O O O O $any$ O $any$ O O O O O $number[]$ O $number$ O O O O $any$ O $any$ O O O O O O $number[]$ O $number$ O O O O O $any$ O $any$ O O O O O $number[]$ O $number$ O O O O $any$ O $any$ O O O O O O $number[]$ O $number$ O O O O O $number[]$ O $number$ O O O O O O O $any$ O $any$ O O O O O O $number[]$ O $number$ O O O O O $number[]$ O $number$ O O O O O O O $any$ O $any$ O $number[]$ O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O $any$ O $any$ O $false$ O O O O O O O
import Backburner from 's' ; import lolex from 's' ; const originalDateNow = Date . now ; const originalDateValueOf = Date . prototype . valueOf ; let fakeClock ; QUnit . module ( 's' , { afterEach ( ) { Date . now = originalDateNow ; Date . prototype . valueOf = originalDateValueOf ; if ( fakeClock ) { fakeClock . uninstall ( ) ; } } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; let instance ; let done = assert . async ( ) ; let now = + new Date ( ) ; Date . prototype . valueOf = function ( ) { return now ; } ; bb . later ( null , ( ) => { instance = bb . currentInstance ; assert . equal ( step ++ , 0 ) ; } , 0 ) ; bb . later ( null , ( ) => { assert . equal ( step ++ , 0 ) ; assert . equal ( instance , bb . currentInstance , 's' ) ; } , 0 ) ; Date . prototype . valueOf = originalDateValueOf ; while ( ( + new Date ( ) ) <= now + 0 ) { } bb . later ( null , ( ) => { assert . equal ( step ++ , 0 ) ; bb . later ( null , ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( true , 's' ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let done = assert . async ( ) ; let globalNowWasUsed = false ; Date . now = function ( ) { globalNowWasUsed = true ; return originalDateNow ( ) ; } ; bb . later ( ( ) => { assert . ok ( globalNowWasUsed ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let done = assert . async ( ) ; let start = originalDateNow ( ) ; let now = start ; Date . now = ( ) => now ; let 0 = 0 ; let 0 = 0 ; bb . later ( ( ) => 0 = originalDateNow ( ) , 0 ) ; now += 0 ; bb . later ( ( ) => 0 = originalDateNow ( ) , 0 ) ; now += 0 ; setTimeout ( ( ) => { assert . ok ( 0 !== 0 , 's' ) ; assert . ok ( 0 !== 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; let bb ; QUnit . module ( 's' , { beforeEach ( ) { bb = new Backburner ( [ 's' ] ) ; } , afterEach ( ) { bb = undefined ; if ( fakeClock ) { fakeClock . uninstall ( ) ; } } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( function ( ) { assert . equal ( arguments . length , 0 ) ; assert . ok ( true , 's' ) ; done ( ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( function ( ) { assert . equal ( arguments . length , 0 ) ; assert . ok ( true , 's' ) ; done ( ) ; } , undefined ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . ok ( true , 's' ) ; done ( ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . ok ( true , 's' ) ; done ( ) ; } , undefined ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , null ) ; assert . ok ( true , 's' ) ; done ( ) ; } , null ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( function ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } , 's' , 's' , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } , 's' , 's' , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } , 's' , 's' , 's' , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( null , function ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } , 's' , 's' , 's' , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( { bro ( ) { assert . ok ( true , 's' ) ; done ( ) ; } } , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; bb . later ( { bro ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } } , 's' , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; bb . later ( { bro ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } } , 's' , 's' , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; bb . later ( { bro ( ) { assert . equal ( arguments . length , 0 ) ; assert . equal ( arguments [ 0 ] , 's' ) ; assert . ok ( true , 's' ) ; done ( ) ; } } , 's' , 's' , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; done ( ) ; } bb = new Backburner ( [ 's' ] , { onError } ) ; bb . later ( ( ) => { throw new Error ( 's' ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; bb = new Backburner ( [ 's' ] ) ; let 0 = 0 ; let 0 = 0 ; let beginCalls = 0 ; let endCalls = 0 ; let oldBegin = bb . begin ; let oldEnd = bb . end ; let done = assert . async ( ) ; bb . begin = function ( ) { beginCalls ++ ; oldBegin . call ( bb ) ; } ; bb . end = function ( ) { endCalls ++ ; oldEnd . call ( bb ) ; } ; bb . later ( ( ) => 0 ++ , 0 ) ; bb . later ( ( ) => 0 ++ , 0 ) ; setTimeout ( ( ) => { assert . equal ( 0 , 0 , 's' ) ; assert . equal ( 0 , 0 , 's' ) ; assert . equal ( beginCalls , 0 , 's' ) ; assert . equal ( endCalls , 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let steps = 0 ; let done = assert . async ( ) ; let 0 = new Backburner ( [ 's' ] , { onBegin ( ) { assert . equal ( ++ steps , 0 ) ; } } ) ; let 0 = new Backburner ( [ 's' ] , { onBegin ( ) { assert . equal ( ++ steps , 0 ) ; } } ) ; assert . equal ( ++ steps , 0 ) ; 0 . later ( ( ) => assert . equal ( ++ steps , 0 ) , 0 ) ; assert . equal ( ++ steps , 0 ) ; 0 . later ( ( ) => assert . equal ( ++ steps , 0 ) , 0 ) ; assert . equal ( ++ steps , 0 ) ; setTimeout ( ( ) => { assert . equal ( ++ steps , 0 ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let 0 = 0 ; let 0 = 0 ; let done = assert . async ( ) ; bb . later ( ( ) => 0 = Date . now ( ) , 0 ) ; let waitUntil = Date . now ( ) + 0 ; while ( Date . now ( ) < waitUntil ) { } bb . later ( ( ) => 0 = Date . now ( ) , 0 ) ; setTimeout ( ( ) => { assert . ok ( 0 !== 0 , 's' ) ; assert . ok ( 0 !== 0 , 's' ) ; assert . ok ( 0 - 0 > 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let 0 = 0 ; let 0 = 0 ; bb . later ( ( ) => 0 = Date . now ( ) , 0 ) ; bb . later ( ( ) => { } , NaN ) ; bb . later ( ( ) => 0 = Date . now ( ) , 0 ) ; setTimeout ( ( ) => { assert . ok ( 0 !== 0 , 's' ) ; assert . ok ( 0 !== 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; bb . later ( function ( name ) { assert . equal ( name , 's' ) ; done ( ) ; } , 's' , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; fakeClock = lolex . install ( ) ; let startTime = originalDateNow ( ) ; bb . later ( function ( name ) { let endTime = originalDateNow ( ) ; assert . ok ( endTime - startTime < 0 , 's' ) ; done ( ) ; } , 0 ) ; fakeClock . tick ( 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let func = function ( ) { } ; bb . run ( ( ) => { bb . debounce ( func , 0 ) ; setTimeout ( function ( ) { bb . debounce ( func , 0 ) ; } , 0 ) ; let before = Date . now ( ) ; bb . later ( function ( ) { let diff = Date . now ( ) - before ; assert . ok ( diff < 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let timer = bb . later ( function ( ) { } , 0 ) ; bb . cancel ( timer ) ; let boundRunExpiredTimers = bb [ 's' ] ; bb [ 's' ] = function ( ) { assert . ok ( true ) ; done ( ) ; return boundRunExpiredTimers . apply ( bb , arguments ) ; } ; bb . later ( function ( ) { } , 0 ) ; } ) ;	O $any$ O O O O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O $number$ O $DateConstructor$ O $Date$ O $number$ O O $any$ O $any$ O $any$ O O O O $void$ O O O $DateConstructor$ O $number$ O $number$ O $DateConstructor$ O $Date$ O $number$ O $number$ O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O O O $DateConstructor$ O O O $DateConstructor$ O $Date$ O $number$ O O O O O O $number$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $DateConstructor$ O $Date$ O $number$ O $number$ O O O O O O $DateConstructor$ O O O O $number$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O $DateConstructor$ O $number$ O O O O O $boolean$ O O O O $number$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $number$ O $number$ O O O O $number$ O $number$ O $DateConstructor$ O $number$ O O O O $number$ O O $number$ O O O O $number$ O O O $any$ O $any$ O O O O $number$ O $number$ O O O O O O $number$ O O O $any$ O $any$ O O O O $number$ O $number$ O O O O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any$ O O O O O O O O $void$ O O O $any$ O $undefined$ O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O $undefined$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O $undefined$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O O O $any$ O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $number$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $number$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $number$ O O O O O $any$ O $any$ O O O O $number$ O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O $number$ O O O O O O O O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O $number$ O O O O O O O O $any$ O $any$ O O $number$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $number$ O O O O O O O $any$ O $any$ O O $number$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $number$ O O O O O O O $any$ O $any$ O O $number$ O O O O $number$ O O O O O $any$ O $any$ O O $number$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O $DateConstructor$ O $number$ O O O $number$ O O O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $number$ O O O O $number$ O O O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O $any$ O $any$ O O O O O O O $number$ O O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $number$ O $number$ O O O $any$ O $any$ O O O $any$ O O O $number$ O $number$ O O O $any$ O $any$ O $number$ O $number$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $void$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $void$ O O O O $number$ O O O O O $any$ O $any$ O $void$ O O O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O $any$ O $any$ O O O O O O $number$ O $DateConstructor$ O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $IArguments$ O O O O $any$ O $any$ O O O O O O O O O O O O O
import Backburner , { buildPlatform } from 's' ; QUnit . module ( 's' ) ; const queue : any [ ] = [ ] ; let platform ; function buildFakePlatform ( flush ) { platform = buildPlatform ( flush ) ; platform . flushSync = function ( ) { flush ( ) ; } ; return platform ; } QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] , { mustYield ( ) { return true ; } , _buildPlatform : buildFakePlatform } ) ; let order = - 0 ; let tasks = { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } , three : { count : 0 , order : - 0 } } ; bb . schedule ( 's' , null , ( ) => { tasks . one . count ++ ; tasks . one . order = ++ order ; } ) ; bb . schedule ( 's' , null , ( ) => { tasks . two . count ++ ; tasks . two . order = ++ order ; } ) ; bb . schedule ( 's' , null , ( ) => { tasks . three . count ++ ; tasks . three . order = ++ order ; } ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : - 0 } , two : { count : 0 , order : - 0 } , three : { count : 0 , order : - 0 } } , 's' ) ; platform . flushSync ( ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : 0 } , two : { count : 0 , order : - 0 } , three : { count : 0 , order : - 0 } } , 's' ) ; platform . flushSync ( ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : 0 } , two : { count : 0 , order : 0 } , three : { count : 0 , order : - 0 } } , 's' ) ; platform . flushSync ( ) ; assert . deepEqual ( tasks , { one : { count : 0 , order : 0 } , two : { count : 0 , order : 0 } , three : { count : 0 , order : 0 } } , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] , { mustYield ( ) { return true ; } , _buildPlatform : buildFakePlatform } ) ; let fooCalled = 0 ; let barCalled = 0 ; let 0 = { foo ( ) { fooCalled ++ ; } } ; let 0 = { bar ( ) { barCalled ++ ; } } ; bb . scheduleOnce ( 's' , 0 , 's' ) ; bb . scheduleOnce ( 's' , 0 , 's' ) ; bb . scheduleOnce ( 's' , 0 , 's' ) ; bb . scheduleOnce ( 's' , 0 , 's' ) ; platform . flushSync ( ) ; let 0 = bb . scheduleOnce ( 's' , 0 , 's' ) ; let 0 = bb . scheduleOnce ( 's' , 0 , 's' ) ; bb . cancel ( 0 ) ; bb . cancel ( 0 ) ; platform . flushSync ( ) ; platform . flushSync ( ) ; platform . flushSync ( ) ; assert . equal ( fooCalled , 0 , 's' ) ; assert . equal ( barCalled , 0 , 's' ) ; } ) ;	O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any[]$ O O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $number$ O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O O $number$ O O O O $any$ O $any$ O O O O O O O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O O $number$ O O O O $any$ O $any$ O O O O O O O O O $complex$ O $complex$ O $number$ O O $complex$ O $complex$ O $number$ O O $number$ O O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $number$ O O O O $number$ O O O O $complex$ O O $void$ O O O $number$ O O O O O O $complex$ O O $void$ O O O $number$ O O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O O O O O $any$ O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O O
import Backburner from 's' ; import MockStableError , { overrideError , pushStackTrace , resetError , } from 's' ; QUnit . module ( 's' , { beforeEach : function ( ) { overrideError ( MockStableError ) ; } , afterEach : function ( ) { resetError ( ) ; } } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let bb = new Backburner ( [ 's' ] ) ; bb . run ( function ( ) { debugInfo = bb . currentInstance && bb . currentInstance . queues . one . _getDebugInfo ( bb . DEBUG ) ; assert . equal ( debugInfo , undefined , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let method = function ( ) { assert . ok ( true ) ; } ; let stack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . schedule ( 's' , method ) ; debugInfo = bb . currentInstance && bb . currentInstance . queues . one . _getDebugInfo ( bb . DEBUG ) ; assert . deepEqual ( debugInfo , [ { target : null , method , args : undefined , stack } ] ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let target = { } ; let method = function ( ) { assert . ok ( true ) ; } ; let 0 = 0 ; let 0 = 0 ; let stack = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . schedule ( 's' , target , method , 0 , 0 ) ; debugInfo = bb . currentInstance && bb . currentInstance . queues . one . _getDebugInfo ( bb . DEBUG ) ; assert . deepEqual ( debugInfo , [ { target , method , args : [ 0 , 0 ] , stack } ] ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let debugInfo ; let method = function ( ) { assert . ok ( true ) ; } ; let bottom = pushStackTrace ( 's' ) ; let top = pushStackTrace ( 's' ) ; let bb = new Backburner ( [ 's' ] ) ; bb . DEBUG = true ; bb . run ( function ( ) { bb . schedule ( 's' , method ) ; bb . schedule ( 's' , method ) ; debugInfo = bb . currentInstance && bb . currentInstance . queues . one . _getDebugInfo ( bb . DEBUG ) ; assert . deepEqual ( debugInfo , [ { target : null , method , args : undefined , stack : top } , { target : null , method , args : undefined , stack : bottom } ] ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O $void$ O $string$ O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $void$ O $any$ O O O O $void$ O O O O O $void$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O $any$ O $any$ O O O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $null$ O O O $void$ O $undefined$ O $undefined$ O $string$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O ${}$ O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $number$ O O O O $number$ O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O ${}$ O $void$ O $number$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O ${}$ O $void$ O $number[]$ O O $number$ O $number$ O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O $any$ O $any$ O O O O O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $null$ O O O $void$ O $undefined$ O $undefined$ O $string$ O $string$ O O O $null$ O O O $void$ O $undefined$ O $undefined$ O $string$ O $string$ O O O O O O O O O O
import Backburner from 's' ; let Queue = ( Backburner as any ) . Queue ; QUnit . module ( 's' ) ; let slice = [ ] . slice ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; let 0 = { foo ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } , bar : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' ) ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } , bar : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { } , bar : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } , bar : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . deepEqual ( 0 . length , 0 , 's' ) ; assert . deepEqual ( 0 [ 0 ] , [ 's' ] ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { } , bar : function ( ) { 0 . push ( slice . call ( arguments ) ) ; } } ; queue . pushUnique ( 0 , 0 . foo ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; queue . pushUnique ( 0 , 0 . bar , [ 's' ] ) ; assert . deepEqual ( 0 , [ ] ) ; queue . flush ( ) ; assert . equal ( 0 . length , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' , { } ) ; let 0 = 0 ; let 0 = 0 ; let 0 = { foo : function ( ) { 0 ++ ; } } ; let 0 = { foo : function ( ) { 0 ++ ; } } ; let 0 = queue . pushUnique ( 0 , 0 . foo ) ; let 0 = queue . pushUnique ( 0 , 0 . foo ) ; queue . cancel ( 0 ) ; queue . cancel ( 0 ) ; queue . pushUnique ( 0 , 0 . foo ) ; queue . pushUnique ( 0 , 0 . foo ) ; queue . pushUnique ( 0 , 0 . foo ) ; queue . pushUnique ( 0 , 0 . foo ) ; queue . flush ( ) ; assert . equal ( 0 , 0 ) ; assert . equal ( 0 , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let queue = new Queue ( 's' ) ; let invocationArgs : string [ ] [ ] = [ ] ; let 0 = { foo : function ( ) { invocationArgs . push ( ... arguments ) ; } } ; queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; let timer = queue . pushUnique ( 0 , 0 . foo , [ 's' ] ) ; assert . deepEqual ( invocationArgs , [ ] , 's' ) ; queue . cancel ( timer ) ; queue . flush ( ) ; assert . deepEqual ( invocationArgs , [ ] , 's' ) ; } ) ;	O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $undefined[]$ O O O O $undefined[]$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O O $complex$ O O $void$ O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O O O $void$ O O O O O $string[][]$ O $number$ O $undefined[]$ O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $complex$ O O $void$ O O O O O $number$ O O O O O O $complex$ O O $void$ O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O $string[][]$ O O O O O O O O O O O $complex$ O O $void$ O O O O O $string[][]$ O $number$ O O $IArguments$ O O O O O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O $void$ O O O O O O $any$ O $any$ O $string[][]$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $string[][]$ O O O O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' , 's' ] ) ; let step = 0 ; bb . run ( function ( ) { assert . equal ( step ++ , 0 , 's' ) ; bb . schedule ( 's' , null , function ( ) { assert . equal ( step ++ , 0 , 's' ) ; bb . schedule ( 's' , null , function ( ) { assert . equal ( step ++ , 0 , 's' ) ; } ) ; } ) ; bb . schedule ( 's' , null , function ( ) { assert . equal ( step ++ , 0 , 's' ) ; } ) ; } ) ; assert . equal ( step , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let count = 0 ; bb . run ( function ( ) { function increment ( ) { if ( ++ count < 0 ) { bb . schedule ( 's' , increment ) ; } if ( count === 0 ) { bb . schedule ( 's' , increment ) ; } } increment ( ) ; assert . equal ( count , 0 , 's' ) ; let currentInstance = bb . currentInstance ; if ( currentInstance ) { currentInstance . queues . one . flush ( ) ; } assert . equal ( count , 0 , 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' , 's' ] ) ; assert . equal ( bb . defaultQueue , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' , 's' ] , { defaultQueue : 's' } ) ; assert . equal ( bb . defaultQueue , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let befores < any | null | undefined > = [ ] ; let afters < any | null | undefined > = [ ] ; let expectedBefores < any | null | undefined > = [ ] ; let expectedAfters < any | null | undefined > = [ ] ; let outer ; let inner ; let bb = new Backburner ( [ 's' ] , { onBegin : function ( current , previous ) { befores . push ( current ) ; befores . push ( previous ) ; } , onEnd : function ( current , next ) { afters . push ( current ) ; afters . push ( next ) ; } } ) ; bb . run ( function ( ) { outer = bb . currentInstance ; bb . run ( function ( ) { inner = bb . currentInstance ; } ) ; } ) ; expectedBefores = [ outer , null , inner , outer ] ; expectedAfters = [ inner , outer , outer , null ] ; assert . deepEqual ( befores , expectedBefores , 's' ) ; assert . deepEqual ( afters , expectedAfters , 's' ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O $number$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O $any$ O $any$ O O O O O O $void$ O O O O O O $number$ O O O O $any$ O $any$ O O O $void$ O O O O O $number$ O O O O $any$ O $any$ O O O $void$ O O O O $void$ O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $Array$ O O O O O O O O O O O O $Array$ O O O O O O O O O O O O $Array$ O O O O O O O O O O O O $Array$ O O O O O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O $any[]$ O $number$ O $any$ O O O O $void$ O O O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O $any[]$ O $number$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any[]$ O O $any$ O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $any[]$ O O O O $any$ O $any$ O $any[]$ O $any[]$ O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => functionWasCalled = true ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( { zomg : 's' } , function ( ) { assert . equal ( this . zomg , 's' , 's' ) ; functionWasCalled = true ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( { zomg : 's' } , function ( a , b , c ) { assert . equal ( this . zomg , 's' , 's' ) ; assert . equal ( a , 0 , 's' ) ; assert . equal ( b , 0 , 's' ) ; assert . equal ( c , 0 , 's' ) ; functionWasCalled = true ; } , 0 , 0 , 0 ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let outerBeforeFunctionWasCalled = false ; let middleBeforeFunctionWasCalled = false ; let innerFunctionWasCalled = false ; let middleAfterFunctionWasCalled = false ; let outerAfterFunctionWasCalled = false ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => { outerBeforeFunctionWasCalled = true ; } ) ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => { middleBeforeFunctionWasCalled = true ; } ) ; bb . run ( ( ) => { bb . schedule ( 's' , ( ) => { innerFunctionWasCalled = true ; } ) ; assert . ok ( ! innerFunctionWasCalled , 's' ) ; } ) ; assert . ok ( innerFunctionWasCalled , 's' ) ; bb . schedule ( 's' , ( ) => { middleAfterFunctionWasCalled = true ; } ) ; assert . ok ( ! middleBeforeFunctionWasCalled , 's' ) ; assert . ok ( ! middleAfterFunctionWasCalled , 's' ) ; } ) ; assert . ok ( middleBeforeFunctionWasCalled , 's' ) ; assert . ok ( middleAfterFunctionWasCalled , 's' ) ; bb . schedule ( 's' , ( ) => { outerAfterFunctionWasCalled = true ; } ) ; assert . ok ( ! outerBeforeFunctionWasCalled , 's' ) ; assert . ok ( ! outerAfterFunctionWasCalled , 's' ) ; } ) ; assert . ok ( outerBeforeFunctionWasCalled , 's' ) ; assert . ok ( outerAfterFunctionWasCalled , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; bb . run ( ( ) => { assert . equal ( step ++ , 0 ) ; bb . run ( ( ) => { assert . equal ( step ++ , 0 ) ; } ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let value = bb . run ( ( ) => 's' ) ; assert . equal ( value , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . run ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; bb . run ( ( ) => assert . ok ( true ) ) ; bb . options . onError = function ( error ) { assert . equal ( 's' , error . message ) ; } ; bb . run ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let target = { } ; let bb = new Backburner ( [ 's' ] , { onErrorTarget : target , onErrorMethod : 's' } ) ; bb . run ( ( ) => assert . ok ( true ) ) ; target [ 's' ] = function ( error ) { assert . equal ( 's' , error . message ) ; } ; bb . run ( ( ) => { throw new Error ( 's' ) ; } ) ; target [ 's' ] = function ( ) { } ; bb . run ( ( ) => { throw new Error ( 's' ) ; } ) ; target [ 's' ] = function ( error ) { assert . equal ( 's' , error . message ) ; } ; bb . run ( ( ) => { throw new Error ( 's' ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O $boolean$ O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O $string$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O $false$ O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O ${}$ O O O O O $any$ O O $any$ O O O O O O ${}$ O ${}$ O $string$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O ${}$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O ${}$ O O O O O O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O ${}$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O $any$ O $any$ O $false$ O O O O O O O
import Backburner from 's' ; QUnit . module ( 's' ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let step = 0 ; let done = assert . async ( ) ; let wasCalled = false ; function throttler ( ) { assert . ok ( ! wasCalled ) ; wasCalled = true ; } bb . throttle ( null , throttler , 0 , false ) ; assert . equal ( step ++ , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . throttle ( null , throttler , false ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . throttle ( null , throttler , false ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( ! wasCalled ) ; bb . throttle ( null , throttler , false ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled ) ; } , 0 ) ; setTimeout ( ( ) => { wasCalled = false ; assert . equal ( step ++ , 0 ) ; bb . throttle ( null , throttler , 0 , false ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled , 's' ) ; } , 0 ) ; } , 0 ) ; setTimeout ( ( ) => { wasCalled = false ; assert . equal ( step ++ , 0 ) ; bb . throttle ( null , throttler , 's' , false ) ; setTimeout ( ( ) => { assert . equal ( step ++ , 0 ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let count = 0 ; let bb = new Backburner ( [ 's' ] ) ; bb . throttle ( null , ( ) => { } , 0 , false ) ; try { bb . cancelTimers ( ) ; } catch ( e ) { count ++ ; } assert . equal ( count , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let count = 0 ; let bb = new Backburner ( [ 's' ] ) ; function throttled ( arg ) { assert . equal ( arg , 's' ) ; done ( ) ; } bb . throttle ( null , throttled , 's' , 0 , false ) ; bb . throttle ( null , throttled , 's' , 0 , false ) ; bb . throttle ( null , throttled , 's' , 0 , false ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; function 0 ( ) { } function 0 ( ) { } let 0 = bb . throttle ( null , 0 , 0 ) ; let 0 = bb . throttle ( null , 0 , 0 ) ; let 0 = bb . throttle ( null , 0 , 0 ) ; let 0 = bb . throttle ( null , 0 , 0 ) ; assert . equal ( 0 , 0 ) ; assert . equal ( 0 , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let throttle ; let 0 ; let wasCalled = false ; let done = assert . async ( ) ; function throttler ( ) { assert . ok ( ! wasCalled , 's' ) ; wasCalled = true ; } throttle = bb . throttle ( null , throttler , 0 ) ; assert . ok ( wasCalled , 's' ) ; wasCalled = false ; 0 = bb . throttle ( null , throttler , 0 ) ; assert . equal ( throttle , 0 , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! wasCalled , 's' ) ; throttle = bb . throttle ( null , throttler , 0 ) ; assert . ok ( wasCalled , 's' ) ; assert . ok ( bb . cancel ( throttle ) , 's' ) ; wasCalled = false ; 0 = bb . throttle ( null , throttler , 0 ) ; assert . notEqual ( throttle , 0 , 's' ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = false ; function throttler ( ) { assert . ok ( false , 's' ) ; wasCalled = true ; } let timer = bb . throttle ( null , throttler , 0 , false ) ; assert . ok ( bb . cancel ( timer ) , 's' ) ; assert . ok ( ! bb . cancel ( timer ) , 's' ) ; setTimeout ( ( ) => { assert . ok ( ! wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let done = assert . async ( ) ; let wasCalled = false ; function throttler ( ) { assert . ok ( true , 's' ) ; wasCalled = true ; } let timer = bb . throttle ( null , throttler , 0 ) ; setTimeout ( ( ) => { assert . ok ( ! bb . cancel ( timer ) , 's' ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let wasCalled = false ; let done = assert . async ( ) ; function throttler ( ) { assert . ok ( true , 's' ) ; wasCalled = true ; } let timer = bb . throttle ( null , throttler , 0 ) ; let 0 = bb . throttle ( null , throttler , 0 ) ; assert . deepEqual ( timer , 0 , 's' ) ; setTimeout ( ( ) => { bb . throttle ( null , throttler , 0 ) ; assert . ok ( ! bb . cancel ( timer ) , 's' ) ; assert . ok ( wasCalled , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith = new Array ( ) ; function throttled ( ... args ) { calledCount ++ ; calledWith . push ( args ) ; } bb . throttle ( throttled , 0 ) ; bb . throttle ( throttled , 0 ) ; bb . throttle ( throttled , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; assert . deepEqual ( calledWith , [ [ ] ] , 's' ) ; setTimeout ( ( ) => { bb . throttle ( throttled , 0 ) ; assert . equal ( calledCount , 0 , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let fooCalledCount = 0 ; let barCalledCount = 0 ; function foo ( ) { fooCalledCount ++ ; } function bar ( ) { barCalledCount ++ ; } bb . throttle ( foo , 0 ) ; bb . throttle ( foo , 0 ) ; assert . equal ( fooCalledCount , 0 , 's' ) ; bb . throttle ( bar , 0 ) ; let timer = bb . throttle ( bar , 0 ) ; assert . equal ( barCalledCount , 0 , 's' ) ; bb . cancel ( timer ) ; bb . throttle ( bar , 0 ) ; assert . equal ( barCalledCount , 0 , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith = new Array ( ) ; function throttled ( ... args ) { calledCount ++ ; calledWith . push ( args ) ; } bb . throttle ( throttled , 0 , false ) ; bb . throttle ( throttled , 0 , false ) ; bb . throttle ( throttled , 0 , false ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; bb . throttle ( throttled , 0 , false ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( calledCount , 0 , 's' ) ; assert . deepEqual ( calledWith , [ [ ] ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let fooCalledCount = 0 ; let barCalledCount = 0 ; function foo ( ) { fooCalledCount ++ ; } function bar ( ) { barCalledCount ++ ; } bb . throttle ( foo , 0 , false ) ; bb . throttle ( foo , 0 , false ) ; assert . equal ( fooCalledCount , 0 , 's' ) ; bb . throttle ( bar , 0 , false ) ; let timer = bb . throttle ( bar , 0 , false ) ; assert . equal ( barCalledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . equal ( fooCalledCount , 0 , 's' ) ; assert . equal ( barCalledCount , 0 , 's' ) ; bb . cancel ( timer ) ; } , 0 ) ; setTimeout ( ( ) => { assert . equal ( fooCalledCount , 0 , 's' ) ; assert . equal ( barCalledCount , 0 , 's' ) ; bb . throttle ( bar , 0 , false ) ; setTimeout ( ( ) => { assert . equal ( barCalledCount , 0 , 's' ) ; done ( ) ; } , 0 ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let bb = new Backburner ( [ 's' ] ) ; let calledWith : object [ ] = [ ] ; function throttled ( first ) { calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; bb . throttle ( throttled , foo , 0 ) ; bb . throttle ( throttled , bar , 0 ) ; bb . throttle ( throttled , baz , 0 ) ; assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith : object [ ] = [ ] ; function throttled ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; let qux = { isQux : true } ; bb . throttle ( throttled , foo , 0 ) ; bb . throttle ( throttled , bar , 0 ) ; let timer = bb . throttle ( throttled , baz , 0 ) ; assert . deepEqual ( calledWith , [ { isFoo : true } ] , 's' ) ; setTimeout ( ( ) => { bb . cancel ( timer ) ; bb . throttle ( throttled , qux , 0 , true ) ; assert . deepEqual ( calledWith , [ { isFoo : true } , { isQux : true } ] , 's' ) ; } , 0 ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ { isFoo : true } , { isQux : true } ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledWith : object [ ] = [ ] ; function throttler ( first ) { calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; bb . throttle ( throttler , foo , 0 , false ) ; bb . throttle ( throttler , bar , 0 , false ) ; bb . throttle ( throttler , baz , 0 , false ) ; assert . deepEqual ( calledWith , [ ] , 's' ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ { isBaz : true } ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { let done = assert . async ( ) ; let bb = new Backburner ( [ 's' ] ) ; let calledCount = 0 ; let calledWith : object [ ] = [ ] ; function throttled ( first ) { calledCount ++ ; calledWith . push ( first ) ; } let foo = { isFoo : true } ; let bar = { isBar : true } ; let baz = { isBaz : true } ; bb . throttle ( throttled , foo , 0 , false ) ; bb . throttle ( throttled , bar , 0 , false ) ; let timer = bb . throttle ( throttled , baz , 0 , false ) ; assert . equal ( calledCount , 0 , 's' ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ ] , 's' ) ; bb . cancel ( timer ) ; } , 0 ) ; setTimeout ( ( ) => { assert . deepEqual ( calledWith , [ ] , 's' ) ; done ( ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . throttle ( null , ( ) => { throw new Error ( 's' ) ; } , 0 ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; function onError ( error ) { assert . equal ( 's' , error . message ) ; } let bb = new Backburner ( [ 's' ] , { onError : onError } ) ; bb . run ( ( ) => { let parentInstance = bb . currentInstance ; bb . throttle ( null , ( ) => { assert . equal ( bb . currentInstance , parentInstance ) ; } , 0 , true ) ; } ) ; } ) ; QUnit . test ( 's' , function ( assert ) { assert . expect ( 0 ) ; let bb = new Backburner ( [ 's' ] ) ; let functionWasCalled = false ; bb . run ( ( ) => { bb . throttle ( function ( name ) { assert . equal ( name , 's' ) ; functionWasCalled = true ; } , 's' , 0 ) ; } ) ; assert . ok ( functionWasCalled , 's' ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O O O $void$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O O O O O O $number$ O O O O O $boolean$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O O O $number$ O O O O O $boolean$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O $number$ O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $number$ O O O O $any$ O O $any$ O O O O O O O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $void$ O O O O O O O O $any$ O $any$ O O O $void$ O O O O O O O O $any$ O $any$ O O O $void$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $void$ O O O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $any$ O O $any$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $false$ O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $false$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $number$ O O O O O $any$ O $any$ O O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $void$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O O O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any[]$ O O $ArrayConstructor$ O O O O $void$ O O $any[]$ O O $number$ O O $any[]$ O $number$ O $any[]$ O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any[]$ O O O O O O O O O $number$ O O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $number$ O O O O $number$ O O O O $void$ O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $any[]$ O O $ArrayConstructor$ O O O O $void$ O O $any[]$ O O $number$ O O $any[]$ O $number$ O $any[]$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $void$ O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $number$ O O O O $void$ O O O $number$ O O O O $void$ O O O $number$ O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $void$ O O O O O O O $any$ O $any$ O $any$ O $void$ O O O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $void$ O O O O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $number$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O $any$ O $any$ O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O O O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O $boolean$ O O O O O O O O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $object[]$ O O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O $object[]$ O O O O O O O O O $void$ O $any$ O O $number$ O O $object[]$ O $number$ O $any$ O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $void$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $number$ O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $number$ O O O O O $any$ O $any$ O $object[]$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O O $any$ O $any$ O $false$ O O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O