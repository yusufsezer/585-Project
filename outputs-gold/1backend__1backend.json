import { browser , by , element , promise } from 's' ; export class HomePage { navigateTo ( ) { return browser . get ( 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , ElementFinder } from 's' ; export function e ( s ) { return element ( by . css ( s ) ) ; } export function type ( elem : string | ElementFinder , text ) { let el ; if ( typeof elem === 's' ) { el = element ( by . css ( < string > elem ) ) ; } else { el = < ElementFinder > elem ; } el . click ( ) ; browser . sleep ( 0 ) ; el . sendKeys ( text ) ; }	O O O O O O O O O O O O O O O O O $ElementFinder$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $ElementFinder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , ElementFinder } from 's' ; import * as utils from 's' ; export interface UserReg { Email : string ; Password : string ; UserName : string ; } export interface UserLogin { Email : string ; Password : string ; } export class LoginPage { register ( user ) { utils . type ( 's' , user . Email ) ; utils . type ( 's' , user . UserName ) ; utils . type ( 's' , user . Password ) ; utils . type ( 's' , user . Password ) ; utils . e ( 's' ) . click ( ) ; } login ( user ) { utils . type ( 's' , user . Email ) ; utils . type ( 's' , user . Password ) ; utils . e ( 's' ) . click ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserReg$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserLogin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , protractor } from 's' ; import { LoginPage , UserReg , UserLogin } from 's' ; import * as utils from 's' ; export class Header { register ( user ) : promise . Promise < void > { expect ( this . hasRegisterButton ( ) ) . toBeTruthy ( ) ; this . clickRegister ( ) ; const loginPage = new LoginPage ( ) ; const until = protractor . ExpectedConditions ; const regSubmit = utils . e ( 's' ) ; return browser . wait ( until . presenceOf ( regSubmit ) , 0 , 's' ) . then ( ( ) => { expect ( regSubmit . isPresent ( ) ) . toBeTruthy ( ) ; loginPage . register ( user ) ; return browser . wait ( until . titleContains ( user . UserName ) , 0 , 's' ) ; } ) ; } login ( user ) : promise . Promise < void > { expect ( this . hasLoginButton ( ) ) . toBeTruthy ( ) ; const until = protractor . ExpectedConditions ; const loginSubmit = utils . e ( 's' ) ; const loginPage = new LoginPage ( ) ; this . clickLogin ( ) ; return browser . wait ( until . presenceOf ( loginSubmit ) , 0 ) . then ( ( ) => { expect ( loginSubmit ) . toBeTruthy ( ) ; loginPage . login ( { Email : user . Email , Password : user . Password } ) ; return browser . wait ( until . titleContains ( user . UserName ) , 0 , 's' ) ; } ) ; } logout ( ) : promise . Promise < void > { const until = protractor . ExpectedConditions ; const menu = element ( by . id ( 's' ) ) ; const logout = element ( by . css ( 's' ) ) ; expect ( menu . isPresent ( ) ) . toBeTruthy ( ) ; this . clickMenu ( ) ; return browser . wait ( until . elementToBeClickable ( logout ) , 0 ) . then ( ( ) => { expect ( logout . isPresent ( ) ) . toBeTruthy ( ) ; return this . clickLogout ( ) . then ( ( ) => { return browser . wait ( until . titleContains ( 's' ) , 0 ) ; } ) ; } ) ; } private hasRegisterButton ( ) : promise . Promise < boolean > { const regButton = element ( by . id ( 's' ) ) ; return regButton . isPresent ( ) ; } private clickRegister ( ) : promise . Promise < void > { return element ( by . id ( 's' ) ) . click ( ) ; } private hasLoginButton ( ) : promise . Promise < boolean > { const loginButton = element ( by . id ( 's' ) ) ; return loginButton . isPresent ( ) ; } private clickLogin ( ) : promise . Promise < void > { return element ( by . id ( 's' ) ) . click ( ) ; } private hasMenu ( ) : promise . Promise < boolean > { const menuButton = element ( by . id ( 's' ) ) ; return menuButton . isPresent ( ) ; } private clickMenu ( ) : promise . Promise < void > { return element ( by . id ( 's' ) ) . click ( ) ; } private hasLogout ( ) : promise . Promise < boolean > { const logoutButton = element ( by . css ( 's' ) ) ; return logoutButton . isPresent ( ) ; } private clickLogout ( ) : promise . Promise < void > { return element ( by . css ( 's' ) ) . click ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserReg$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserReg$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , protractor } from 's' ; import * as utils from 's' ; export class StripePage { navigateTo ( ) { return browser . get ( 's' ) ; } pay ( ) : promise . Promise < void > { const until = protractor . ExpectedConditions ; const stripeSubmitButton = element ( by . css ( 's' ) ) ; return browser . sleep ( 0 ) . then ( ( ) => { browser . actions ( ) . sendKeys ( 's' ) . perform ( ) ; browser . actions ( ) . sendKeys ( protractor . Key . TAB + 's' ) . perform ( ) ; browser . actions ( ) . sendKeys ( protractor . Key . TAB + 's' ) . perform ( ) ; browser . actions ( ) . sendKeys ( protractor . Key . TAB + 's' + protractor . Key . ENTER ) . perform ( ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , ElementFinder } from 's' ; import * as utils from 's' ; export interface Project { Name : string ; Author : string ; Mode : string ; Infra : string [ ] ; } export class CreateProject { create ( p ) { utils . e ( 's' + p . Mode ) . click ( ) ; p . Infra . forEach ( ( v ) => { utils . e ( 's' + v ) . click ( ) ; } ) ; utils . type ( 's' , p . Name ) ; utils . e ( 's' ) . click ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Project$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , promise , protractor } from 's' ; import * as utils from 's' ; import { StripePage } from 's' ; import { CreateProject , Project } from 's' ; export class AuthorPage { 0 = 0 ; name = 's' ; constructor ( authorName ) { this . name = authorName ; } navigateTo ( ) { return browser . get ( 's' + this . name ) ; } topUpBy ( n ) : promise . Promise < any > { const topUpButton = element ( by . id ( 's' ) ) ; expect ( topUpButton . isPresent ( ) ) . toBeTruthy ( ) ; topUpButton . click ( ) ; const stripePage = new StripePage ( ) ; const callsLeftDiv = utils . e ( 's' ) ; let callsLeft ; callsLeftDiv . getAttribute ( 's' ) . then ( function ( value ) { callsLeft = + value ; } ) ; const until = protractor . ExpectedConditions ; return stripePage . pay ( ) . then ( ( ) => { return browser . wait ( function ( ) { return callsLeftDiv . getAttribute ( 's' ) . then ( function ( value ) { return value === callsLeft + 0 + 's' ; } ) ; } , 0 , 's' ) . then ( ( ) => { return browser . sleep ( 0 ) ; } ) ; } ) ; } createProject ( p ) : promise . Promise < any > { const until = protractor . ExpectedConditions ; const addProjectButton = utils . e ( 's' ) ; return browser . wait ( until . presenceOf ( addProjectButton ) , 0 , 's' ) . then ( ( ) => { expect ( addProjectButton . isPresent ( ) ) . toBeTruthy ( ) ; addProjectButton . click ( ) ; const createProjectButton = utils . e ( 's' ) ; return browser . wait ( until . presenceOf ( createProjectButton ) , 0 , 's' ) ; } ) . then ( ( ) => { const cp = new CreateProject ( ) ; cp . create ( p ) ; return browser . wait ( until . invisibilityOf ( utils . e ( 's' ) ) , 0 , 's' ) ; } ) . then ( ( ) => { return browser . wait ( until . invisibilityOf ( utils . e ( 's' ) ) , 0 , 's' ) ; } ) . then ( ( ) => { return browser . wait ( until . presenceOf ( utils . e ( 's' ) ) , 0 , 's' ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Project$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HomePage } from 's' ; import { LoginPage } from 's' ; import { Header } from 's' ; import { AuthorPage } from 's' ; import { browser , by , element , promise , ElementFinder , protractor } from 's' ; function makeid ( ) { let text = 's' ; const possible = 's' ; for ( let i = 0 ; i < 0 ; i ++ ) { text += possible . charAt ( Math . floor ( Math . random ( ) * possible . length ) ) ; } return text ; } describe ( 's' , ( ) => { let homePage ; let loginPage ; let header ; let authorPage ; const id = makeid ( ) ; const pw = makeid ( ) ; console . log ( 's' , id ) ; browser . driver . manage ( ) . window ( ) . setSize ( 0 , 0 ) ; beforeAll ( ( ) => { browser . waitForAngularEnabled ( false ) ; homePage = new HomePage ( ) ; loginPage = new LoginPage ( ) ; header = new Header ( ) ; authorPage = new AuthorPage ( 's' + id ) ; } ) ; it ( 's' , ( ) => { homePage . navigateTo ( ) ; header . register ( { UserName : 's' + id , Email : 's' + id + 's' , Password : pw } ) ; } ) ; it ( 's' , ( ) => { authorPage . navigateTo ( ) ; authorPage . createProject ( { Mode : 's' , Infra : [ 's' ] , Name : 's' , Author : 's' + id } ) ; } ) ; it ( 's' , ( ) => { authorPage . navigateTo ( ) ; authorPage . createProject ( { Mode : 's' , Infra : [ 's' ] , Name : 's' , Author : 's' + id } ) ; } ) ; it ( 's' , ( ) => { authorPage . navigateTo ( ) ; authorPage . createProject ( { Mode : 's' , Infra : [ 's' ] , Name : 's' , Author : 's' + id } ) ; } ) ; it ( 's' , ( ) => { header . logout ( ) . then ( ( ) => { header . login ( { Email : 's' + id + 's' , Password : pw , UserName : 's' + id } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HomePage$ O O $LoginPage$ O O $Header$ O O $AuthorPage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { clearContext : false } , coverageIstanbulReporter : { reports : [ 's' , 's' ] , fixWebpackSourcePaths : true } , angularCli : { environment : 's' } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , browsers : [ 's' ] , customLaunchers : { ChromeNoSandbox : { base : 's' , flags : [ 's' ] } } , singleRun : false } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { SpecReporter } = require ( 's' ) ; exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , capabilities : { browserName : 's' } , directConnect : true , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : 's' } ) ; jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const config = require ( 's' ) . config ; config . capabilities = { browserName : 's' , chromeOptions : { args : [ 's' ] } } ; exports . config = config ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { Router } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AppComponent { title = 's' ; constructor ( public router ) { } public options = { timeOut : 0 , showProgressbar : true , pauseOnHover : false , clickToClose : false } ; pathOnly ( ) { return this . router . url . split ( 's' ) [ 0 ] . split ( 's' ) [ 0 ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , async } from 's' ; import { AppComponent } from 's' ; describe ( 's' , ( ) => { beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AppComponent ] , } ) . compileComponents ( ) ; } ) ) ; it ( 's' , async ( ( ) => { const fixture = TestBed . createComponent ( AppComponent ) ; const app = fixture . debugElement . componentInstance ; expect ( app ) . toBeTruthy ( ) ; } ) ) ; it ( `template` , async ( ( ) => { const fixture = TestBed . createComponent ( AppComponent ) ; const app = fixture . debugElement . componentInstance ; expect ( app . title ) . toEqual ( 's' ) ; } ) ) ; it ( 's' , async ( ( ) => { const fixture = TestBed . createComponent ( AppComponent ) ; fixture . detectChanges ( ) ; const compiled = fixture . debugElement . nativeElement ; expect ( compiled . querySelector ( 's' ) . textContent ) . toContain ( 's' ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface Endpoint extends Selectable { Id ? : string ; Url ? : string ; Code ? : string ; Method ? : string ; Input ? : string ; Output ? : string ; Description ? : string ; CreatedAt ? : string ; } export interface Project extends Selectable { Id ? : string ; Author ? : string ; Name ? : string ; Recipe ? : string ; ReadMe ? : string ; Mode ? : string ; Endpoints ? : Endpoint [ ] ; Builds ? : Build [ ] ; Tags ? : string ; UpdatedAt ? : string ; Stars ? : number ; Description ? : string ; Public ? : boolean ; Starrers ? : User [ ] ; Imports ? : string ; Packages ? : string ; Types ? : string ; Source ? : string ; OpenSource ? : boolean ; Version ? : string ; Namespace ? : string ; } export interface Languages extends Selectable { Name ? : string ; DisplayName ? : string ; DisplayColor ? : string ; } export interface Dependency extends Selectable { Id ? : string ; Type ? : string ; DisplayName ? : string ; Config ? : string ; CreatedAt ? : string ; UpdatedAt ? : string ; } export interface Selectable { Selected ? : boolean ; } export interface Build { Id : string ; Output : string ; Success : boolean ; ProjectId : string ; InProgress : boolean ; CreatedAt : string ; UpdatedAt ? : string ; Selected ? : boolean ; Version ? : string ; Steps ? : BuildStep [ ] ; } export interface BuildStep { Id : string ; Output : string ; Success : boolean ; BuildId : string ; CreatedAt : string ; UpdatedAt ? : string ; } export interface User { Id : string ; Password : string ; Nick : string ; Name : string ; Email : string ; CreatedAt : number ; UpdatedAt : number ; AvatarLink : string ; Premium ? : boolean ; Tokens ? : Token [ ] ; } export interface AccessToken { Id ? : string ; Token ? : string ; UserId ? : string ; CreatedAt ? : string ; UpdatedAt ? : string ; } export interface Profile { Link ? : string ; FullName ? : string ; Location ? : string ; AboutMe ? : string ; Github ? : string ; } export interface Comment { Id ? : string ; IssueId ? : string ; Content ? : string ; UserId ? : string ; User ? : User ; CreatedBy ? : User ; Issue ? : Issue ; Index ? : number ; Editing ? : boolean ; CreatedAt ? : string ; UpdatedAt ? : string ; } export interface Issue { Id ? : string ; ProjectId ? : string ; Title ? : string ; UserId ? : string ; Comments ? : Comment [ ] ; User ? : User ; CreatedBy ? : User ; CreatedAt ? : string ; UpdatedAt ? : string ; } export interface Token { Id ? : string ; Token ? : string ; UserId ? : string ; Name ? : string ; Description ? : string ; CreatedAt ? : string ; UpdatedAt ? : string ; Enabled ? : boolean ; Quota ? : number ; } export interface Post { Id ? : string ; Title ? : string ; Subtitle ? : string ; UserId ? : string ; Content ? : string ; User ? : User ; CreatedAt ? : string ; UpdatedAt ? : string ; Slug ? : string ; Editing ? : boolean ; } export interface Config { SiteUrl ? : string ; StripeKey ? : string ; SendGridKey ? : string ; Path ? : string ; ApiGeneration ? : ApiGeneration ; NpmPublication ? : NpmPublication ; Sitemap ? : Sitemap ; } export interface ApiGeneration { GithubOrganisation ? : string ; GithubUser ? : string ; GithubPersonalToken ? : string ; Enabled ? : boolean ; } export interface NpmPublication { Enabled ? : boolean ; NpmToken ? : string ; NpmOrganisation ? : string ; } export interface Sitemap { Enabled ? : boolean ; Path ? : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { Cookie } from 's' ; const d = new Date ( ) ; d . setFullYear ( d . getFullYear ( ) + 0 ) ; @ Injectable ( ) export class SessionService { constructor ( ) { } setToken ( t ) { Cookie . set ( 's' , t , d , 's' ) ; } getToken ( ) { return Cookie . get ( 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O
export const environment = { production : false , backendUrl : 's' , stripeKey : 's' } ;	O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import * as types from 's' ; import { HttpClient , HttpParams } from 's' ; import { SessionService } from 's' ; import { Observable } from 's' ; import { environment } from 's' ; interface LoginResponse { token : types . AccessToken ; } interface RegisterResponse { token : types . AccessToken ; } @ Injectable ( ) export class UserService { user : types . User = { } as types . User ; constructor ( private http , private sess ) { this . get ( ) . then ( user => { for ( const k of Object . keys ( user ) ) { this . user [ k ] = user [ k ] ; } } ) ; } loggedIn ( ) { return this . sess . getToken ( ) . length > 0 ; } logout ( ) { this . sess . setToken ( 's' ) ; } get ( ) < types . User > { return new Promise < types . User > ( ( resolve , reject ) => { if ( ! this . sess . getToken ( ) || this . sess . getToken ( ) . length === 0 ) { setTimeout ( function ( ) { resolve ( { } as types . User ) ; } , 0 ) ; return ; } this . http . get < types . User > ( environment . backendUrl + 's' + this . sess . getToken ( ) ) . toPromise ( ) . then ( user => { for ( const k of Object . keys ( user ) ) { this . user [ k ] = user [ k ] ; } resolve ( user ) ; } ) ; } ) ; } getByNick ( nick ) < types . User > { let p = new HttpParams ( ) ; p = p . set ( 's' , this . sess . getToken ( ) ) ; p = p . set ( 's' , nick ) ; return this . http . get < types . User > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } save ( u : types . User ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { password : u . Password , user : { Name : u . Name , Id : u . Id } , token : this . sess . getToken ( ) } ) . toPromise ( ) ; } saveSelf ( ) < void > { return this . http . put < void > ( environment . backendUrl + 's' , { user : { avatarLink : this . user . AvatarLink , name : this . user . Name , email : this . user . Email , nick : this . user . Nick } , token : this . sess . getToken ( ) } ) . toPromise ( ) ; } login ( email , password ) < LoginResponse > { return this . http . post < LoginResponse > ( environment . backendUrl + 's' , { email : email , password : password } ) . toPromise ( ) . then ( loginResp => { this . sess . setToken ( loginResp . token . Token ) ; return loginResp ; } ) ; } register ( userName , email , password ) < RegisterResponse > { return this . http . post < RegisterResponse > ( environment . backendUrl + 's' , { nick : userName , email : email , password : password } ) . toPromise ( ) . then ( registerResp => { this . sess . setToken ( registerResp . token . Token ) ; return registerResp ; } ) ; } changePassword ( oldPw , newPw ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { oldPassword : oldPw , newPassword : newPw , token : this . sess . getToken ( ) } ) . toPromise ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import * as types from 's' ; import { HttpClient , HttpParams } from 's' ; import { SessionService } from 's' ; import { environment } from 's' ; import { Observable } from 's' ; interface PingResponse { pong : boolean ; } interface CallerIdResponse { CallerId : string ; } @ Injectable ( ) export class ProjectService { constructor ( private http , private ss ) { } listByNick ( nick ) < types . Project [ ] > { let p = new HttpParams ( ) ; p = p . set ( 's' , nick ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; return this . http . get < types . Project [ ] > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) . then ( projs => { projs = projs . sort ( ( a , b ) => { if ( a . UpdatedAt === b . UpdatedAt ) { return 0 ; } if ( a . UpdatedAt < b . UpdatedAt ) { return 0 ; } return - 0 ; } ) ; return projs ; } ) ; } getByAuthorAndProjectName ( author , projectName ) < types . Project > { let p = new HttpParams ( ) ; p = p . set ( 's' , author ) ; p = p . set ( 's' , projectName ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; const createdAtSorter = ( a , b ) => { if ( a . CreatedAt === b . CreatedAt ) { return 0 ; } if ( a . CreatedAt < b . CreatedAt ) { return 0 ; } return - 0 ; } ; return this . http . get < types . Project > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) . then ( proj => { if ( proj . Builds ) { proj . Builds = proj . Builds . sort ( createdAtSorter ) ; } proj . Builds . map ( b => { b . Steps = b . Steps . sort ( createdAtSorter ) ; } ) ; if ( proj . Endpoints ) { proj . Endpoints = proj . Endpoints . sort ( ( a , b ) => { if ( a . CreatedAt === b . CreatedAt ) { return 0 ; } if ( a . CreatedAt < b . CreatedAt ) { return 0 ; } return - 0 ; } ) ; } return proj ; } ) ; } getStatus ( author , projectName ) < PingResponse > { return this . http . get < PingResponse > ( environment . backendUrl + 's' + author + 's' + projectName + 's' ) . toPromise ( ) ; } star ( projectId ) < void > { return this . http . put < void > ( environment . backendUrl + 's' , { projectId : projectId , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } unstar ( projectId ) < void > { let p = new HttpParams ( ) ; p = p . set ( 's' , projectId ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; return this . http . delete < void > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } list ( ) < types . Project [ ] > { let p = new HttpParams ( ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; return this . http . get < types . Project [ ] > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } update ( project : types . Project ) < void > { return this . http . put < void > ( environment . backendUrl + 's' , { project : project , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } create ( project : types . Project ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { project : project , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } getCallerId ( project : types . Project ) < CallerIdResponse > { let p = new HttpParams ( ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; p = p . set ( 's' , project . Id ) ; return this . http . get < CallerIdResponse > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } delete ( project : types . Project ) < void > { let p = new HttpParams ( ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; p = p . set ( 's' , project . Id ) ; return this . http . delete < void > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input , ViewEncapsulation } from 's' ; import { ProjectService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class ProjectStatusComponent implements OnInit { @ Input ( ) author : string ; @ Input ( ) projectName : string ; status = false ; loaded = false ; constructor ( private ps ) { } getStatus ( ) { this . ps . getStatus ( this . author , this . projectName ) . then ( pingResponse => { this . loaded = true ; this . status = pingResponse . pong ; } ) . catch ( ( ) => { this . loaded = true ; } ) ; } ngOnInit ( ) { this . getStatus ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input , ViewChild } from 's' ; import { Location } from 's' ; import { ActivatedRoute , Router } from 's' ; import { MatProgressSpinnerModule , MatTabGroup } from 's' ; import * as types from 's' ; import { MatDialog , MatDialogRef , MAT_DIALOG_DATA } from 's' ; import { UserService } from 's' ; import { ProjectService } from 's' ; import { SimpleNotificationsModule } from 's' ; import { NotificationsService } from 's' ; import { Title } from 's' ; import { ProjectStatusComponent } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ProjectComponent implements OnInit { selectedIndex = 0 ; tab = 's' ; color = 's' ; mode = 's' ; value = 0 ; lastBuild : types . Build ; leftWidth = 0 ; that = this ; status : boolean ; issueId = 's' ; loaded = false ; stars : number ; starred = false ; @ ViewChild ( 's' ) private projectStatus : ProjectStatusComponent ; project : types . Project = { Endpoints : [ ] , Builds : [ ] } ; constructor ( private route , private location , private router , private ps , public us , private notif , private title ) { } refresh ( ) { this . ps . getByAuthorAndProjectName ( this . project . Author , this . project . Name ) . then ( project => { if ( project . Builds && project . Builds . length ) { this . lastBuild = project . Builds [ 0 ] ; } if ( ! project . ReadMe ) { project . ReadMe = project . Name + "s" ; } if ( project . Starrers ) { for ( const s of project . Starrers ) { if ( s . Id === this . us . user . Id ) { this . starred = true ; } } } this . loaded = true ; this . stars = project . Stars ; this . project = project ; } ) ; } ngOnInit ( ) { this . project . Author = this . route . snapshot . params [ 's' ] ; this . project . Name = this . route . snapshot . params [ 's' ] ; this . tab = this . route . snapshot . params [ 's' ] ; this . issueId = this . route . snapshot . params [ 's' ] ; this . title . setTitle ( this . project . Author + 's' + this . project . Name ) ; this . refresh ( ) ; if ( this . tab === 's' ) { this . selectedIndex = 0 ; } if ( this . tab === 's' || this . issueId ) { this . selectedIndex = 0 ; } if ( this . tab === 's' ) { this . selectedIndex = 0 ; } if ( this . tab === 's' ) { this . selectedIndex = 0 ; } if ( this . tab === 's' ) { this . selectedIndex = 0 ; } if ( this . tab === 's' ) { this . selectedIndex = 0 ; } setInterval ( ( ) => { if ( ! this . lastBuild . InProgress ) { return ; } this . updateBuilds ( ) ; this . projectStatus . getStatus ( ) ; } , 0 ) ; } selectedIndexChange ( tabGroup ) { const pid = tabGroup . _tabs . find ( ( e , i , a ) => i === tabGroup . selectedIndex ) . content . viewContainerRef . element . nativeElement . dataset . pid ; if ( pid !== 's' ) { this . location . go ( 's' + this . project . Author + 's' + this . project . Name + 's' + pid ) ; } else { this . location . go ( 's' + this . project . Author + 's' + this . project . Name ) ; } } updateBuilds ( ) { this . ps . getByAuthorAndProjectName ( this . project . Author , this . project . Name ) . then ( project => { if ( project . Builds && project . Builds . length ) { this . lastBuild = project . Builds [ 0 ] ; this . project . Builds = project . Builds ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $Location$ O O $Router$ O O $ProjectService$ O O $UserService$ O O $NotificationsService$ O O $Title$ O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MatTabGroup$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { environment } from 's' ; import { HttpClient , HttpParams } from 's' ; import { SessionService } from 's' ; import { NotificationsService } from 's' ; const 0 = 0 ; @ Injectable ( ) export class ChargeService { constructor ( private http , private ss , private ns ) { } charge ( amt , callback : ( ) => void ) { const that = this ; const handler = ( < any > window ) . StripeCheckout . configure ( { key : environment . stripeKey , locale : 's' , token : function ( token ) { that . ns . alert ( 's' ) ; that . http . post ( environment . backendUrl + 's' , { paymentToken : token . id , token : that . ss . getToken ( ) , amount : amt } ) . subscribe ( data => { that . ns . success ( 's' , 's' ) ; callback ( ) ; } , error => { that . ns . error ( error ) ; } ) ; } } ) ; handler . open ( { name : 's' + Math . floor ( 0 * amt / 0 ) + 's' , description : 's' , amount : amt } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O $NotificationsService$ O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , OnChanges , Input } from 's' ; import { ActivatedRoute } from 's' ; import * as types from 's' ; import { Router , NavigationStart , Event } from 's' ; import { ChargeService } from 's' ; import { ProjectService } from 's' ; import { NotificationsService } from 's' ; import { UserService } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AuthorComponent implements OnInit { amount = 0 ; author = 's' ; name = 's' ; projects : types . Project [ ] = [ ] ; user : types . User ; userFound = true ; selectedTabIndex = 0 ; constructor ( private route , private router , private notif , public us , public ps , private charge , private title ) { } ngOnInit ( ) { this . refresh ( ) ; this . router . events . subscribe ( ( event ) => { if ( event instanceof NavigationStart ) { setTimeout ( ( ) => { this . refresh ( ) ; } , 0 ) ; } } ) ; } refresh ( ) { this . author = this . route . snapshot . params [ 's' ] ; this . ps . listByNick ( this . author ) . then ( projects => ( this . projects = projects ) ) . catch ( err => ( this . userFound = false ) ) ; this . us . getByNick ( this . author ) . then ( user => { this . user = user ; } ) . catch ( err => { this . userFound = false ; } ) ; } getAllCallsLeft ( ) { if ( ! this . us . user . Tokens ) { return 0 ; } return this . us . user . Tokens . map ( t => t . Quota ) . reduce ( ( prev , curr ) => { return prev + curr ; } ) ; } purchase ( ) { const that = this ; this . charge . charge ( this . amount * 0 , ( ) => { that . us . get ( ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $Router$ O O $NotificationsService$ O O $UserService$ O O $ProjectService$ O O $ChargeService$ O O $Title$ O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Inject } from 's' ; import { NotificationsService } from 's' ; import { Router } from 's' ; import { MatDialog , MatDialogRef , MAT_DIALOG_DATA } from 's' ; import { UserService } from 's' ; import * as types from 's' ; import { FormControl , Validators } from 's' ; const EMAIL_REGEX = "s" ; const USERNAME_REGEX = "s" ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class LoginComponent implements OnInit { username = 's' ; email = 's' ; password = 's' ; password_conf = 's' ; selectedIndex = 0 ; emailFormControl = new FormControl ( 's' , [ Validators . pattern ( EMAIL_REGEX ) ] ) ; usernameFormControl = new FormControl ( 's' , [ Validators . pattern ( USERNAME_REGEX ) ] ) ; onNoClick ( ) { this . dialogRef . close ( ) ; } constructor ( private notif , public dialogRef < LoginComponent > , private us , @ Inject ( MAT_DIALOG_DATA ) public data , private router ) { if ( ! this . data . isLogin ) { this . selectedIndex = 0 ; } } login ( ) { if ( ! this . loginValid ( ) ) { return ; } this . us . login ( this . email , this . password ) . then ( loginResponse => { this . dialogRef . close ( ) ; this . us . get ( ) . then ( ( ) => { if ( this . data . callback ) { this . data . callback ( loginResponse . token ) ; } else { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } } ) ; } ) . catch ( error => { this . notif . error ( 's' ) ; } ) ; } register ( ) { if ( ! this . registerValid ( ) ) { return ; } this . us . register ( this . username , this . email , this . password ) . then ( registerResponse => { this . dialogRef . close ( ) ; this . us . get ( ) . then ( ( ) => { if ( this . data . callback ) { this . data . callback ( registerResponse . token ) ; } else { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } } ) ; } , e => { this . notif . error ( e . error . error ) ; } ) ; } loginValid ( ) { if ( ! this . email ) { this . notif . error ( 's' ) ; return false ; } if ( ! this . password ) { this . notif . error ( 's' ) ; return false ; } return true ; } ngOnInit ( ) { } registerValid ( ) { if ( ! this . username ) { this . notif . error ( 's' ) ; return false ; } if ( this . username === 's' ) { this . notif . error ( 's' ) ; return false ; } if ( this . username === 's' ) { this . notif . error ( 's' ) ; return false ; } if ( this . username === 's' ) { this . notif . error ( 's' ) ; return false ; } if ( this . username === 's' ) { this . notif . error ( 's' ) ; return false ; } if ( ! USERNAME_REGEX . test ( this . username ) ) { this . notif . error ( 's' ) ; return false ; } if ( ! EMAIL_REGEX . test ( this . email ) ) { this . notif . error ( 's' ) ; return false ; } if ( ! this . password ) { this . notif . error ( 's' ) ; return false ; } if ( this . password_conf !== this . password ) { this . notif . error ( 's' ) ; return false ; } return true ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $NotificationsService$ O O $MatDialogRef$ O O O O O $UserService$ O O O O O O O $any$ O O $Router$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Component , Inject } from 's' ; import { MatDialog } from 's' ; import { LoginComponent } from 's' ; import * as types from 's' ; @ Injectable ( ) export class LoginDialogService { constructor ( public dialog ) { } openDialog ( isLogin , callback : ( token : types . AccessToken ) => void ) { const dialogRef = this . dialog . open ( LoginComponent , { width : 's' , data : { 's' : isLogin , 's' : callback } } ) ; dialogRef . afterClosed ( ) . subscribe ( result => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MatDialog$ O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; import { LoginDialogService } from 's' ; import { SessionService } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HomeComponent implements OnInit { constructor ( private loginDialog , private ss , private title ) { } ngOnInit ( ) { this . title . setTitle ( 's' ) ; } scroll ( el ) { el . scrollIntoView ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginDialogService$ O O $SessionService$ O O $Title$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input } from 's' ; import * as types from 's' ; import { HttpClient , HttpParams } from 's' ; import { SessionService } from 's' ; import { environment } from 's' ; interface RunSqlResponse { Answer : string ; } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SqlComponent implements OnInit { @ Input ( ) project : types . Project ; sqlConsole = 's' ; sqlAnswer = 's' ; constructor ( private http , private ss ) { } ngOnInit ( ) { } runSql ( ) { this . http . post < RunSqlResponse > ( environment . backendUrl + 's' , { projectId : this . project . Id , sql : this . sqlConsole , token : this . ss . getToken ( ) } ) . subscribe ( data => { this . sqlAnswer = data . Answer ; } , error => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input } from 's' ; import * as types from 's' ; import { MatProgressSpinnerModule } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class BuildsComponent implements OnInit { @ Input ( ) project : types . Project ; color = 's' ; mode = 's' ; value = 0 ; currentPage = 0 ; constructor ( private title ) { } ngOnInit ( ) { } reveal ( e : types . Build ) { e . Selected = ! e . Selected ; } timeItTook ( b : types . Build ) { return ( ( new Date ( b . UpdatedAt ) . getTime ( ) - new Date ( b . CreatedAt ) . getTime ( ) ) / 0 ) ; } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Title$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' ; @ Pipe ( { name : 's' , } ) export class FilterPipe implements PipeTransform { transform ( value , input ) { if ( input ) { input = input . toLowerCase ( ) ; return value . filter ( function ( el ) { return JSON . stringify ( el ) . toLowerCase ( ) . indexOf ( input ) > - 0 ; } ) } return value ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Output , EventEmitter , Input } from 's' ; import * as types from 's' ; import { FilterPipe } from 's' ; import { Router } from 's' ; import { UserService } from 's' ; import { ProjectService } from 's' ; import { environment } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class CodeComponent implements OnInit { @ Input ( ) project : types . Project ; @ Output ( ) onProjectSaved = new EventEmitter < void > ( ) ; user : types . User ; backendUrl = environment . backendUrl ; search : string ; endpoints : types . Endpoint [ ] = [ ] ; leftWidth = 0 ; rightWidth = 0 ; newEndpoint : types . Endpoint = { Method : 's' , Url : 's' , Description : 's' } ; status : boolean ; readme : string ; currentPage = 0 ; readOnly = true ; constructor ( private router , private us , private ps , private title ) { this . user = this . us . user ; } ngOnInit ( ) { if ( this . user . Nick === this . project . Author ) { this . readOnly = false ; } } add ( ) { this . project . Endpoints . push ( this . newEndpoint ) ; this . save ( ) ; } save ( ) { this . ps . update ( this . project ) . then ( data => { this . onProjectSaved . emit ( ) ; } ) . catch ( error => { } ) ; } getTestToken ( ) { const tokens = this . us . user . Tokens ; if ( ! tokens || ! tokens . length ) { return 's' ; } const testToken = tokens . filter ( t => { return t . Name === 's' ; } ) ; if ( testToken . length === 0 ) { return 's' ; } return testToken [ 0 ] . Token ; } getAceCompatibleMode ( ) { switch ( this . project . Mode ) { case 's' : { return 's' ; } case 's' : { return 's' ; } case 's' : { return 's' ; } } } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } setRightFullScreen ( ) { this . rightWidth = 0 ; this . leftWidth = 0 ; } smallScreen ( ) { this . rightWidth = 0 ; this . leftWidth = 0 ; } setLeftFullScreen ( ) { this . rightWidth = 0 ; this . leftWidth = 0 ; } isLeftFullScreen ( ) { return this . leftWidth === 0 ; } isRightFullScreen ( ) { return this . rightWidth === 0 ; } reveal ( e : types . Endpoint ) { e . Selected = ! e . Selected ; } goSql ( ) { this . router . navigate ( [ 's' + this . project . Author + 's' + this . project . Name + 's' + 's' ] ) ; location . reload ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $UserService$ O O $ProjectService$ O O $Title$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild , ElementRef , Renderer , AfterViewInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class DemoComponent implements OnInit , AfterViewInit { @ ViewChild ( 's' ) saveButton : ElementRef ; title = 's' ; page = 's' ; selected = 0 ; code = `template` ; terminal = `template` ; counter = 0 ; constructor ( private renderer ) { } typeTerminal ( ) { } ngOnInit ( ) { } ngAfterViewInit ( ) { this . animate ( this ) ; const that = this ; const f = this . animate ; setInterval ( ( ) => { f ( that ) ; } , 0 ) ; } triggerFalseClick ( that ) { } reset ( ) { this . counter = 0 ; } wait ( n ) { this . counter += n ; return this . counter ; } animate ( that ) { that . reset ( ) ; setTimeout ( ( ) => { that . selected = 0 ; } , that . wait ( 0 ) ) ; setTimeout ( ( ) => { that . page = 's' ; that . title = 's' ; that . selected = 0 ; } , that . wait ( 0 ) ) ; setTimeout ( ( ) => { that . triggerFalseClick ( that ) ; } , that . wait ( 0 ) ) ; setTimeout ( ( ) => { that . page = 's' ; that . title = 's' ; } , that . wait ( 0 ) ) ; setTimeout ( ( ) => { that . page = 's' ; that . title = 's' ; } , that . wait ( 0 ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Renderer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DemoComponent$ O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O $DemoComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input , OnChanges } from 's' ; import { UserService } from 's' ; import * as types from 's' ; import { LoginDialogService } from 's' ; import { Router , ActivatedRoute } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HeaderComponent implements OnInit { user : types . User ; constructor ( public us , private router , private lds , private title ) { this . user = this . us . user ; } ngOnInit ( ) { } login ( ) { this . lds . openDialog ( true , ( ) => { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } ) ; } logout ( ) { this . us . logout ( ) ; this . router . navigate ( [ 's' ] ) ; location . reload ( ) ; } viewProfile ( ) { this . router . navigate ( [ 's' + this . user . Nick ] ) ; this . title . setTitle ( this . user . Nick ) ; } getStarted ( ) { this . router . navigate ( [ 's' ] , { fragment : 's' } ) ; } register ( ) { this . lds . openDialog ( false , ( ) => { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } ) ; } pricing ( ) { this . router . navigate ( [ 's' ] , { fragment : 's' } ) ; } github ( ) { window . location . href = 's' ; } scroll ( el ) { el . scrollIntoView ( ) ; } discoverProjects ( ) { this . router . navigate ( [ 's' ] ) ; } home ( ) { this . router . navigate ( [ 's' ] ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $Router$ O O $LoginDialogService$ O O $Title$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; import * as types from 's' ; import { FilterPipe } from 's' ; import { ProjectService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ProjectsComponent implements OnInit { currentPage = 0 ; search = 's' ; projects : types . Project [ ] = [ ] ; constructor ( private ps ) { } refresh ( ) { this . ps . list ( ) . then ( projects => ( this . projects = projects ) ) . catch ( err => console . log ( err ) ) ; } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } ngOnInit ( ) { this . refresh ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input } from 's' ; import { Router } from 's' ; import * as types from 's' ; import { UserService } from 's' ; import { ProjectService } from 's' ; import { LoginDialogService } from 's' ; import { NotificationsService } from 's' ; import { FormControl , Validators } from 's' ; const pNAME_REGEX = "s" ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class CreateProjectComponent implements OnInit { @ Input ( ) callback : ( p : types . Project ) => void ; name = 's' ; user : types . User ; private = false ; languages : types . Languages [ ] = [ { Name : 's' , DisplayName : 's' , DisplayColor : 's' } , { Name : 's' , DisplayName : 's' , DisplayColor : 's' } , { Name : 's' , DisplayName : 's' , DisplayColor : 's' } ] ; dependencies : types . Dependency [ ] = [ { Type : 's' , DisplayName : 's' } ] ; constructor ( public us , private ps , private router , private loginDialog , private notif ) { this . user = this . us . user ; } projectNameControl = new FormControl ( 's' , [ Validators . pattern ( pNAME_REGEX ) ] ) ; resetLanguages ( ) { this . languages . forEach ( l => { l . Selected = false ; } ) ; } ngOnInit ( ) { } createProject ( ) { if ( ! pNAME_REGEX . test ( this . name ) || this . name . length < 0 ) { return ; } const lang = this . languages . filter ( l => { return l . Selected ; } ) [ 0 ] ; if ( ! lang ) { this . notif . error ( 's' ) ; return ; } const dep = this . dependencies . filter ( l => { return l . Selected ; } ) ; const p = { Author : this . user . Nick , Name : this . name , Mode : lang . Name , Dependencies : dep , Public : ! this . private , OpenSource : true } ; this . ps . create ( p ) . then ( ( ) => { if ( this . callback ) { this . callback ( p ) ; console . log ( 's' ) ; } else { console . log ( 's' ) ; this . router . navigate ( [ 's' + this . user . Nick + 's' + this . name ] ) ; } } ) . catch ( error => { console . log ( error ) ; } ) ; } create ( ) { if ( ! this . us . loggedIn ( ) ) { this . loginDialog . openDialog ( true , ( ) => { this . createProject ( ) ; } ) ; } else { this . createProject ( ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $ProjectService$ O O $Router$ O O $LoginDialogService$ O O $NotificationsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Inject } from 's' ; import * as types from 's' ; import { MatDialog , MatDialogRef , MAT_DIALOG_DATA } from 's' ; import { CreateProjectComponent } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , entryComponents : [ CreateProjectComponent ] } ) export class CreateProjectDialogComponent implements OnInit { constructor ( @ Inject ( MAT_DIALOG_DATA ) public data , public dialogRef < CreateProjectComponent > ) { } ngOnInit ( ) { } onNoClick ( ) { this . dialogRef . close ( ) ; } closeDialog ( ) { this . dialogRef . close ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $MatDialogRef$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Component , Inject } from 's' ; import { MatDialog } from 's' ; import { CreateProjectDialogComponent } from 's' ; import * as types from 's' ; @ Injectable ( ) export class CreateProjectDialogService { animal : string ; name : string ; dialogRef ; constructor ( public dialog ) { } openDialog ( callback : ( p : types . Project ) => void ) { this . dialogRef = this . dialog . open ( CreateProjectDialogComponent , { width : 's' , data : { callback : callback } } ) ; this . dialogRef . afterClosed ( ) . subscribe ( result => { } ) ; } closeDialog ( ) { this . dialogRef . close ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MatDialog$ O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input } from 's' ; import { HttpClient , HttpParams } from 's' ; import { Router , ActivatedRoute } from 's' ; import * as types from 's' ; import { environment } from 's' ; import { SessionService } from 's' ; import { UserService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class IssueComponent implements OnInit { @ Input ( ) issueId : string ; @ Input ( ) author ; @ Input ( ) projectName ; issuerComment : types . Comment = { } as types . Comment ; projectId : string ; issue : types . Issue = { } ; commentContent = 's' ; currentPage = 0 ; index = 0 ; constructor ( private http , private ss , public us , private route ) { } ngOnInit ( ) { this . getIssue ( ) ; this . projectName = this . route . snapshot . params [ 's' ] ; } addComment ( ) { const that = this ; this . http . post ( environment . backendUrl + 's' , { comment : { content : this . commentContent , issueId : this . issueId } , token : this . ss . getToken ( ) } ) . toPromise ( ) . then ( data => { this . getIssue ( ) ; this . commentContent = 's' ; } ) ; } getIssue ( ) { let p = new HttpParams ( ) ; p = p . set ( 's' , this . issueId ) ; this . http . get < types . Issue > ( environment . backendUrl + 's' , { params : p } ) . subscribe ( issue => { this . issue = issue ; if ( this . issue . Comments ) { this . issue . Comments = this . issue . Comments . sort ( ( a , b ) => { if ( a . CreatedAt === b . CreatedAt ) { return 0 ; } if ( a . CreatedAt < b . CreatedAt ) { return 0 ; } return - 0 ; } ) ; } this . issue . Comments = this . issue . Comments . reverse ( ) ; for ( let i = 0 ; i < this . issue . Comments . length ; i ++ ) { this . issue . Comments [ i ] . Index = i + 0 ; } console . log ( this . issue . Comments ) ; } , error => { console . log ( error ) ; } ) ; } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O $UserService$ O O $ActivatedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O
import { Component , OnInit , Inject , Input } from 's' ; import { MatDialog , MatDialogRef , MAT_DIALOG_DATA } from 's' ; import { HttpClient , HttpParams } from 's' ; import { environment } from 's' ; import { SessionService } from 's' ; import * as types from 's' ; import { FormControl , Validators } from 's' ; import { Router } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class CreateIssueComponent implements OnInit { issueTitle = 's' ; commentContent = 's' ; errorString ; onNoClick ( ) { this . dialogRef . close ( ) ; } constructor ( @ Inject ( MAT_DIALOG_DATA ) public data , public dialogRef < CreateIssueComponent > , private http , private router , private ss ) { } ngOnInit ( ) { } addIssue ( ) { if ( this . commentContent . length < 0 || this . issueTitle . length < 0 ) { this . errorString = 's' ; return ; } const that = this ; this . http . post ( environment . backendUrl + 's' , { issue : { title : this . issueTitle , projectId : this . data . project . Id } , comment : { content : this . commentContent } , token : this . ss . getToken ( ) } ) . toPromise ( ) . then ( d => { this . data . callback ( ) ; this . dialogRef . close ( ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $any$ O O $MatDialogRef$ O O O O O $HttpClient$ O O $Router$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Component , Inject } from 's' ; import { MatDialog } from 's' ; import { CreateIssueComponent } from 's' ; import * as types from 's' ; @ Injectable ( ) export class CreateIssueDialogService { constructor ( public dialog ) { } openDialog ( project : types . Project , callback : ( ) => void ) { const dialogRef = this . dialog . open ( CreateIssueComponent , { width : 's' , data : { project : project , callback : callback } } ) ; dialogRef . afterClosed ( ) . subscribe ( result => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MatDialog$ O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input , Inject } from 's' ; import * as types from 's' ; import { HttpClient , HttpParams } from 's' ; import { environment } from 's' ; import { ActivatedRoute , Router } from 's' ; import { CreateIssueDialogService } from 's' ; import { FilterPipe } from 's' ; import { LoginDialogService } from 's' ; import { SessionService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class IssuesComponent implements OnInit { @ Input ( ) project : types . Project ; issues : types . Issue [ ] = [ ] ; search : 's' ; currentPage = 0 ; loaded = false ; constructor ( private route , private http , private router , private cris , private lds , private ss ) { } create ( ) { if ( ! this . ss . getToken ( ) ) { this . lds . openDialog ( true , ( ) => { this . cris . openDialog ( this . project , ( ) => this . refresh ( ) ) ; } ) ; } else { this . cris . openDialog ( this . project , ( ) => this . refresh ( ) ) ; } } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } refresh ( ) { let p = new HttpParams ( ) ; p = p . set ( 's' , this . project . Id ) ; this . http . get < types . Issue [ ] > ( environment . backendUrl + 's' , { params : p } ) . subscribe ( issues => { if ( issues ) { this . issues = issues . sort ( ( a , b ) => { if ( a . CreatedAt === b . CreatedAt ) { return 0 ; } if ( a . CreatedAt < b . CreatedAt ) { return 0 ; } return - 0 ; } ) ; } this . loaded = true ; } , error => { console . log ( error ) ; } ) ; } ngOnInit ( ) { this . refresh ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $HttpClient$ O O $Router$ O O $CreateIssueDialogService$ O O $LoginDialogService$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' ; import { LoginDialogService } from 's' ; import { SessionService } from 's' ; import { ChargeService } from 's' ; import { UserService } from 's' ; import { HttpClient , HttpParams } from 's' ; import { Router } from 's' ; import { environment } from 's' ; import * as types from 's' ; const amt = 0 ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class PricingComponent implements OnInit { constructor ( private lds , public ss , private http , private router , private us , private charge ) { } ngOnInit ( ) { } openCheckout ( ) { const that = this ; if ( this . ss . getToken ( ) ) { this . charge . charge ( amt , ( ) => { that . router . navigate ( [ 's' + that . us . user . Nick ] ) ; } ) ; return ; } this . lds . openDialog ( false , ( tok : types . AccessToken ) => { this . charge . charge ( amt , ( ) => { that . router . navigate ( [ 's' + that . us . user . Nick ] ) ; } ) ; } ) ; } register ( ) { this . lds . openDialog ( false , ( ) => { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginDialogService$ O O $SessionService$ O O $HttpClient$ O O $Router$ O O $UserService$ O O $ChargeService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input } from 's' ; import { CreateProjectDialogService } from 's' ; import { UserService } from 's' ; import { Router } from 's' ; import * as types from 's' ; import { ActivatedRoute } from 's' ; import { LoginDialogService } from 's' ; import { ProjectService } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ProjectListComponent implements OnInit { @ Input ( ) projects : types . Project [ ] = [ ] ; search : string ; currentPage = 0 ; author = 's' ; isProjectsPage = false ; constructor ( private cp , private lds , private router , public us , private ps , private route , private title ) { this . author = this . route . snapshot . params [ 's' ] ; this . isProjectsPage = this . router . isActive ( 's' , false ) ; } ngOnInit ( ) { if ( this . router . url === 's' ) { this . title . setTitle ( 's' ) ; } else if ( this . router . url === 's' + this . author ) { this . title . setTitle ( this . author ) ; } } create ( ) { const that = this ; if ( ! this . us . loggedIn ( ) ) { this . lds . openDialog ( true , ( ) => { this . cp . openDialog ( proj => { that . cp . closeDialog ( ) ; that . router . navigate ( [ 's' + proj . Author + 's' + proj . Name ] ) ; } ) ; } ) ; } else { this . cp . openDialog ( proj => { that . cp . closeDialog ( ) ; that . router . navigate ( [ 's' + proj . Author + 's' + proj . Name ] ) ; } ) ; } } pageChanged ( $event ) { this . currentPage = $event . pageIndex ; } star ( p : types . Project ) { this . ps . star ( p . Id ) . then ( ( ) => { p . Stars ++ ; p . Starrers = [ ] ; } ) . catch ( error => { console . log ( error . error ) ; } ) ; } unStar ( proj : types . Project ) { this . ps . unstar ( proj . Id ) . then ( ( ) => { proj . Stars -- ; proj . Starrers = null ; } ) . catch ( error => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateProjectDialogService$ O O $LoginDialogService$ O O $Router$ O O $UserService$ O O $ProjectService$ O O $ActivatedRoute$ O O $Title$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' ; @ Pipe ( { name : 's' } ) export class LengthPipe implements PipeTransform { transform ( list : any [ ] ) { return list . length ; } }	O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation } from 's' ; import { SessionService } from 's' ; import { HttpClient } from 's' ; import { environment } from 's' ; import { ActivatedRoute , Params , Router } from 's' ; import * as types from 's' ; import { NotificationsService } from 's' ; import { Title } from 's' ; import { UserService } from 's' ; interface ResetPasswordResponse { token : types . AccessToken ; } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ResetComponent implements OnInit { newPassword : string ; 0 : string ; secret : string ; constructor ( private ss , private http , private activatedRoute , private router , private notif , private title , private us ) { } ngOnInit ( ) { this . title . setTitle ( 's' ) ; this . secret = this . activatedRoute . snapshot . params [ 's' ] ; } resetPassword ( ) { if ( this . newPassword !== this . 0 ) { this . notif . error ( 's' ) ; return ; } this . http . post < ResetPasswordResponse > ( environment . backendUrl + 's' , { newPassword : this . newPassword , secret : this . secret } ) . subscribe ( rsp => { if ( ! rsp . token . Token ) { this . notif . error ( "s" ) ; } else { this . ss . setToken ( rsp . token . Token ) ; this . us . get ( ) . then ( ( ) => { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } ) ; } } , err => { this . notif . error ( 's' ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SessionService$ O O $HttpClient$ O O $ActivatedRoute$ O O $Router$ O O $NotificationsService$ O O $Title$ O O $UserService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation } from 's' ; import { HttpClient } from 's' ; import { environment } from 's' ; import { NotificationsService } from 's' ; import { Title } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RecoverComponent implements OnInit { email : string ; constructor ( private http , private title , private notif ) { } ngOnInit ( ) { this . title . setTitle ( 's' ) ; } sendReset ( ) { this . http . post ( environment . backendUrl + 's' , { 's' : this . email } ) . subscribe ( rsp => { this . notif . success ( 's' ) ; } , error => { this . notif . error ( 's' ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $Title$ O O $NotificationsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import * as types from 's' ; import { environment } from 's' ; import { HttpClient , HttpParams } from 's' ; import { SessionService } from 's' ; import { Http } from 's' ; @ Injectable ( ) export class PostService { constructor ( private http , private ss ) { } list ( author ) < types . Post [ ] > { let p = new HttpParams ( ) ; p = p . set ( 's' , author ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; return this . http . get < types . Post [ ] > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) . then ( posts => { posts = posts . sort ( ( a , b ) => { if ( a . UpdatedAt === b . UpdatedAt ) { return 0 ; } if ( a . UpdatedAt < b . UpdatedAt ) { return 0 ; } return - 0 ; } ) ; return posts ; } ) ; } get ( postId ) < types . Post > { let p = new HttpParams ( ) ; p = p . set ( 's' , postId ) ; return this . http . get < types . Post > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) ; } edit ( post : types . Post ) < types . Post > { return this . http . put ( environment . backendUrl + 's' , { post : post , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } create ( post : types . Post ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { post : post , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation , Input , Inject } from 's' ; import { PostService } from 's' ; import { UserService } from 's' ; import * as types from 's' ; import { MatDialog , MatDialogRef , MAT_DIALOG_DATA } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class CreatePostComponent implements OnInit { @ Input ( ) author : string ; post : types . Post = { } ; constructor ( private ps , public us , @ Inject ( MAT_DIALOG_DATA ) public data , public dialogRef < CreatePostComponent > ) { } createPost ( ) { this . ps . create ( this . post ) . then ( d => { this . data . callback ( ) ; this . dialogRef . close ( ) ; } ) . catch ( err => console . log ( 's' ) ) ; } ngOnInit ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PostService$ O O $UserService$ O O O O O O O $any$ O O $MatDialogRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Component , Inject } from 's' ; import { MatDialog } from 's' ; import { CreatePostComponent } from 's' ; import * as types from 's' ; @ Injectable ( ) export class CreatePostDialogService { constructor ( public dialog , ) { } openDialog ( user : types . User , callback : ( ) => void ) { const dialogRef = this . dialog . open ( CreatePostComponent , { width : 's' , data : { user : user , callback : callback } } ) ; dialogRef . afterClosed ( ) . subscribe ( result => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MatDialog$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation , Input } from 's' ; import * as types from 's' ; import { UserService } from 's' ; import { Router , ActivatedRoute } from 's' ; import { PostService } from 's' ; import { CreatePostDialogService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class PostsComponent implements OnInit { @ Input ( ) author : string ; posts : types . Post [ ] = [ ] ; search = 's' ; constructor ( public us , private router , private route , private ps , private cpds ) { } getPosts ( ) { this . ps . list ( this . author ) . then ( posts => { this . posts = posts ; } ) . catch ( err => { err = console . log ( 's' ) ; } ) ; } create ( ) { this . cpds . openDialog ( this . us . user , ( ) => this . getPosts ( ) ) ; } ngOnInit ( ) { this . getPosts ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $Router$ O O $ActivatedRoute$ O O $PostService$ O O $CreatePostDialogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { HttpClient , HttpParams } from 's' ; import * as types from 's' ; import { SessionService } from 's' ; import { environment } from 's' ; import { Observable } from 's' ; @ Injectable ( ) export class TokenService { constructor ( private ss , private http ) { } transfer ( from , to , amount ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { token : this . ss . getToken ( ) , from : from , to : to , amount : amount } ) . toPromise ( ) ; } createToken ( tokenName , tokenDescription ) < void > { return this . http . post < void > ( environment . backendUrl + 's' , { token : this . ss . getToken ( ) , serviceTokenName : tokenName , serviceTokenDescription : tokenDescription } ) . toPromise ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SessionService$ O O $HttpClient$ O O O $Promise$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation } from 's' ; import { TokenService } from 's' ; import { UserService } from 's' ; import { NotificationsService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class TokensComponent implements OnInit { serviceTokenName = 's' ; serviceTokenDescription = 's' ; from = 's' ; to = 's' ; transferAmount = 0 ; constructor ( private ts , public us , private notif ) { } ngOnInit ( ) { } transfer ( ) { this . ts . transfer ( this . from , this . to , this . transferAmount ) . then ( ( ) => { this . us . get ( ) ; this . notif . success ( 's' ) ; } ) ; } createToken ( ) { this . ts . createToken ( this . serviceTokenName , this . serviceTokenDescription ) . then ( ( ) => { this . us . get ( ) ; this . notif . success ( 's' ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokenService$ O O $UserService$ O O $NotificationsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , EventEmitter , Input , Output , ViewEncapsulation } from 's' ; import { UserService } from 's' ; import { NotificationsService } from 's' ; import * as types from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class ProfileEditComponent implements OnInit { @ Input ( ) user : types . User ; @ Output ( ) onSelfSave = new EventEmitter < void > ( ) ; saved = true ; oldPw = 's' ; newPw = 's' ; newPwCf = 's' ; constructor ( public us , private notif ) { } ngOnInit ( ) { } save ( ) { if ( ! this . valid ( ) ) { return ; } this . us . saveSelf ( ) . then ( data => { this . saved = true ; this . onSelfSave . emit ( ) ; } ) ; } edit ( ) { this . saved = false ; } changePassword ( ) { if ( ! this . pwChangeValid ( ) ) { return ; } this . us . changePassword ( this . oldPw , this . newPw ) ; } valid ( ) { if ( ! this . user . Nick ) { this . notif . error ( 's' ) ; return false ; } if ( ! this . user . Email ) { this . notif . error ( 's' ) ; return false ; } return true ; } pwChangeValid ( ) { if ( this . newPw . length < 0 ) { this . notif . error ( 's' ) ; return false ; } if ( this . newPw !== this . newPwCf ) { this . notif . error ( 's' ) ; return false ; } return true ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $NotificationsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' ; import { HttpClient , HttpParams } from 's' ; import * as types from 's' ; import { SessionService } from 's' ; import { environment } from 's' ; @ Injectable ( ) export class CommentService { constructor ( private ss , private http ) { } update ( comment : types . Comment ) < void > { return this . http . put < void > ( environment . backendUrl + 's' , { comment : comment , token : this . ss . getToken ( ) } ) . toPromise ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SessionService$ O O $HttpClient$ O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , Input , Output , EventEmitter , ViewEncapsulation } from 's' ; import { ProjectService } from 's' ; import { UserService } from 's' ; import * as types from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class StarButtonComponent implements OnInit { @ Input ( ) showCount = false ; @ Input ( ) project : types . Project ; @ Output ( ) starEvent = new EventEmitter < boolean > ( ) ; constructor ( private ps , private us ) { } ngOnInit ( ) { } starredBySelf ( ) { return ( this . project . Starrers && this . project . Starrers . filter ( x => x . Id === this . us . user . Id ) . length > 0 ) ; } star ( ) { this . ps . star ( this . project . Id ) . then ( ( ) => { this . project . Stars ++ ; if ( this . project . Starrers ) { this . project . Starrers . push ( this . us . user ) ; } else { this . project . Starrers = [ this . us . user ] ; } this . starEvent . emit ( true ) ; } ) ; } unStar ( ) { this . ps . unstar ( this . project . Id ) . then ( ( ) => { this . project . Stars -- ; this . project . Starrers = this . project . Starrers . filter ( x => x . Id !== this . us . user . Id ) ; this . starEvent . emit ( false ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O $UserService$ O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation , Output , EventEmitter , Input } from 's' ; import * as types from 's' ; import { environment } from 's' ; import { UserService } from 's' ; import { CommentService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class CommentComponent implements OnInit { @ Output ( ) onCommentUpdate = new EventEmitter < void > ( ) ; @ Input ( ) comment : types . Comment ; editedCommentContent = 's' ; constructor ( public us , private cs ) { } ngOnInit ( ) { this . editedCommentContent = this . comment . Content ; } updateComment ( ) { this . comment . Content = this . editedCommentContent ; this . cs . update ( this . comment ) . then ( ( ) => { this . onCommentUpdate . emit ( ) ; } ) ; } editComment ( ) { this . comment . Editing = ! this . comment . Editing ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $CommentService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation } from 's' ; import { ActivatedRoute } from 's' ; import { PostService } from 's' ; import * as types from 's' ; import { UserService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class PostComponent implements OnInit { postId : string ; post : types . Post = { } ; constructor ( private route , private ps , public us ) { } getPost ( ) { this . ps . get ( this . postId ) . then ( post => { this . post = post ; } ) . catch ( err => { err = console . log ( 's' ) ; } ) ; } editPost ( ) { this . post . Editing = ! this . post . Editing ; } updatePost ( ) { this . ps . edit ( this . post ) . then ( post => { this . post = post ; this . getPost ( ) ; } ) . catch ( err => ( err = console . log ( 's' ) ) ) ; } cancel ( ) { this . getPost ( ) ; } ngOnInit ( ) { this . postId = this . route . snapshot . params [ 's' ] ; this . getPost ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $PostService$ O O $UserService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation , Input , Output , EventEmitter } from 's' ; import * as types from 's' ; import { ProjectService } from 's' ; import { FormsModule } from 's' ; import { UserService } from 's' ; import { Router } from 's' ; import { NotificationsService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class SettingsComponent implements OnInit { @ Input ( ) project : types . Project ; @ Output ( ) onProjectSaved = new EventEmitter < void > ( ) ; show = false ; callerId = 's' ; color = 's' ; privateChecked = false ; privateDisabled = false ; isPremiumMember = false ; newProjectName ; nameChanged = false ; deleteProjectName : string ; newVersion ; newNamespace ; newDescription ; constructor ( private ps , private us , private router , private notif ) { } ngOnInit ( ) { this . isPremiumMember = this . us . user . Premium ; this . privateChecked = ! this . project . Public ; this . newProjectName = this . project . Name ; this . newVersion = this . project . Version ; this . newNamespace = this . project . Namespace ; this . newDescription = this . project . Description ; } showCallerId ( ) { if ( this . callerId !== 's' ) { this . show = true ; return ; } this . ps . getCallerId ( this . project ) . then ( callerIdResponse => { this . callerId = callerIdResponse . CallerId ; this . show = true ; } ) ; } hideCallerId ( ) { this . show = false ; } saveSettings ( ) { this . project . Version = this . newVersion ; this . project . Description = this . newDescription ; this . project . Namespace = this . newNamespace ; this . project . OpenSource = ! this . privateChecked ; this . ps . update ( this . project ) . then ( ( ) => { this . onProjectSaved . emit ( ) ; } ) ; } deleteProject ( ) { if ( this . project . Name !== this . deleteProjectName ) { this . notif . error ( 's' ) ; return ; } this . ps . delete ( this . project ) . then ( ( ) => { this . router . navigate ( [ 's' + this . us . user . Nick ] ) ; } ) . catch ( err => { this . notif . error ( err ) ; } ) ; } changeName ( ) { if ( this . project . Name !== this . newProjectName ) { this . project . Name = this . newProjectName ; this . nameChanged = true ; } else { return ; } this . ps . update ( this . project ) . then ( ( ) => { if ( this . nameChanged ) { this . router . navigate ( [ 's' + this . project . Author + 's' + this . project . Name ] ) ; this . onProjectSaved . emit ( ) ; } else { this . onProjectSaved . emit ( ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O $UserService$ O O $Router$ O O $NotificationsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation , Input } from 's' ; import * as types from 's' ; import { ProjectService } from 's' ; import { HttpClient , HttpParams } from 's' ; import { environment } from 's' ; import { SessionService } from 's' ; interface ReloadResponse { Logs : string ; } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class LogsComponent implements OnInit { @ Input ( ) project : types . Project ; logs : string ; constructor ( private ps , private http , private ss ) { } ngOnInit ( ) { this . reload ( ) ; } reload ( ) { let p = new HttpParams ( ) ; p = p . set ( 's' , this . project . Id ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; this . http . get < ReloadResponse > ( environment . backendUrl + 's' , { params : p } ) . subscribe ( data => { this . logs = data . Logs ; } , error => { } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O $HttpClient$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewEncapsulation } from 's' ; import * as types from 's' ; import { HttpClient , HttpParams } from 's' ; import { environment } from 's' ; import { MatInputModule } from 's' ; import { SessionService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , encapsulation : ViewEncapsulation . None } ) export class ConfigComponent implements OnInit { config : types . Config = { ApiGeneration : { } , NpmPublication : { } , Sitemap : { } } ; constructor ( private http , private ss ) { } ngOnInit ( ) { this . getConfig ( ) ; } getConfig ( ) { let p = new HttpParams ( ) ; p = p . set ( 's' , this . ss . getToken ( ) ) ; this . http . get < types . Config > ( environment . backendUrl + 's' , { params : p } ) . toPromise ( ) . then ( conf => { this . config = conf ; } ) . catch ( err => ( err = console . log ( 's' ) ) ) ; } saveConfig ( ) { this . http . put ( environment . backendUrl + 's' , { config : this . config , token : this . ss . getToken ( ) } ) . toPromise ( ) . then ( ( ) => this . getConfig ( ) ) . catch ( err => ( err = console . log ( 's' ) ) ) ; console . log ( this . config . Sitemap . Enabled ) ; console . log ( this . config . Sitemap . Path ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $SessionService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BrowserModule , Title } from 's' ; import { NgModule } from 's' ; import { AceEditorModule } from 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import { AppComponent } from 's' ; import { ProjectComponent } from 's' ; import { RouterModule , Routes } from 's' ; import { AuthorComponent } from 's' ; import { BrowserAnimationsModule } from 's' ; import { MatTooltipModule , MatMenuModule , MatSnackBar , MatToolbarModule , MatPaginatorModule , MatProgressSpinnerModule , MatCardModule , MatFormFieldModule , MatInputModule , MatSelectModule , MatOptionModule , MatButtonModule , MatIconModule , MatTabsModule , MatDialogModule , MatDialog , MatListModule , MatExpansionModule , MatCheckboxModule , MatRadioModule , MatSlideToggleModule , MatSliderModule } from 's' ; import { HttpClient , HttpClientModule } from 's' ; import { FormsModule , ReactiveFormsModule } from 's' ; import { FlexLayoutModule } from 's' ; import { LoginComponent } from 's' ; import { SimpleNotificationsModule } from 's' ; import { HomeComponent } from 's' ; import { MomentModule } from 's' ; import { SqlComponent } from 's' ; import { BuildsComponent } from 's' ; import { CodeComponent } from 's' ; import { MarkdownToHtmlModule } from 's' ; import { SessionService } from 's' ; import { ChargeService } from 's' ; import { DemoComponent } from 's' ; import { HeaderComponent } from 's' ; import { ProjectsComponent } from 's' ; import { FilterPipe } from 's' ; import { LoginDialogService } from 's' ; import { UserService } from 's' ; import { CreateProjectComponent } from 's' ; import { 0 } from 's' ; import { CreateProjectDialogComponent } from 's' ; import { CreateProjectDialogService } from 's' ; import 's' ; import { IssueComponent } from 's' ; import { CreateIssueDialogService } from 's' ; import { IssuesComponent } from 's' ; import { PricingComponent } from 's' ; import { CreateIssueComponent } from 's' ; import { ProjectListComponent } from 's' ; import { LengthPipe } from 's' ; import { ResetComponent } from 's' ; import { RecoverComponent } from 's' ; import { PostsComponent } from 's' ; import { TokensComponent } from 's' ; import { ProfileEditComponent } from 's' ; import { TokenService } from 's' ; import { CommentService } from 's' ; import { ProjectService } from 's' ; import { ProjectStatusComponent } from 's' ; import { StarButtonComponent } from 's' ; import { CommentComponent } from 's' ; import { CreatePostComponent } from 's' ; import { PostComponent } from 's' ; import { PostService } from 's' ; import { CreatePostDialogService } from 's' ; import { SettingsComponent } from 's' ; import { LogsComponent } from 's' ; import { ConfigComponent } from 's' ; const appRoutes = [ { path : 's' , component : ResetComponent } , { path : 's' , component : ConfigComponent } , { path : 's' , component : RecoverComponent } , { path : 's' , component : ProjectsComponent } , { path : 's' , component : PostComponent } , { path : 's' , component : ProjectComponent } , { path : 's' , component : ProjectComponent } , { path : 's' , component : ProjectComponent } , { path : 's' , component : DemoComponent } , { path : 's' , component : AuthorComponent } , { path : 's' , component : HomeComponent } ] ; @ NgModule ( { declarations : [ AppComponent , ProjectComponent , AuthorComponent , LoginComponent , SqlComponent , BuildsComponent , CodeComponent , HomeComponent , DemoComponent , HeaderComponent , ProjectsComponent , FilterPipe , CreateProjectComponent , CreateProjectDialogComponent , IssuesComponent , IssueComponent , PricingComponent , CreateIssueComponent , ProjectListComponent , LengthPipe , ResetComponent , RecoverComponent , PostsComponent , TokensComponent , ProfileEditComponent , ProjectStatusComponent , StarButtonComponent , CommentComponent , CreatePostComponent , PostComponent , SettingsComponent , LogsComponent , ConfigComponent ] , imports : [ BrowserModule , MarkdownToHtmlModule . forRoot ( ) , FormsModule , RouterModule . forRoot ( appRoutes , { enableTracing : true } ) , AceEditorModule , BrowserAnimationsModule , HttpClientModule , MatCardModule , MatFormFieldModule , MatInputModule , MatSelectModule , MatOptionModule , MatButtonModule , MatIconModule , MatTabsModule , MatPaginatorModule , MatProgressSpinnerModule , MatToolbarModule , FlexLayoutModule , MomentModule , SimpleNotificationsModule . forRoot ( ) , MatMenuModule , MatDialogModule , 0 , MatTooltipModule , ReactiveFormsModule , MatListModule , MatExpansionModule , MatCheckboxModule , MatRadioModule , MatSlideToggleModule , MatSliderModule ] , providers : [ HttpClient , SessionService , LoginDialogService , UserService , CreateProjectDialogService , CreateIssueDialogService , ChargeService , ProjectService , TokenService , CommentService , PostService , CreatePostDialogService , Title ] , bootstrap : [ AppComponent ] , entryComponents : [ CreateProjectComponent , CreateProjectDialogComponent , CreateIssueComponent , LoginComponent , CreatePostComponent ] } ) export class AppModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { AuthorComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AuthorComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AuthorComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( AuthorComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthorComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CreatePostComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CreatePostComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CreatePostComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CreatePostComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreatePostComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { CreatePostDialogService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ CreatePostDialogService ] } ) ; } ) ; it ( 's' , inject ( [ CreatePostDialogService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreatePostDialogService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { PostComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < PostComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ PostComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( PostComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $PostComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { PostsComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < PostsComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ PostsComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( PostsComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $PostsComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ProfileEditComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProfileEditComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProfileEditComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProfileEditComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProfileEditComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { TokensComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < TokensComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ TokensComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( TokensComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokensComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { ChargeService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ChargeService ] } ) ; } ) ; it ( 's' , inject ( [ ChargeService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ChargeService$ O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { CommentService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ CommentService ] } ) ; } ) ; it ( 's' , inject ( [ CommentService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommentService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ConfigComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ConfigComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ConfigComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ConfigComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { HeaderComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeaderComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ HeaderComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HeaderComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $HeaderComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { DemoComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < DemoComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ DemoComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( DemoComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $DemoComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { HomeComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HomeComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ HomeComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HomeComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $HomeComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { PricingComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < PricingComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ PricingComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( PricingComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $PricingComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { LengthPipe } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const pipe = new LengthPipe ( ) ; expect ( pipe ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { LoginDialogService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ LoginDialogService ] } ) ; } ) ; it ( 's' , inject ( [ LoginDialogService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginDialogService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { LoginComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LoginComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LoginComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LoginComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { PostService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ PostService ] } ) ; } ) ; it ( 's' , inject ( [ PostService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PostService$ O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { ProjectService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ ProjectService ] } ) ; } ) ; it ( 's' , inject ( [ ProjectService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CreateProjectComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CreateProjectComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CreateProjectComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CreateProjectComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateProjectComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CreateProjectDialogComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CreateProjectDialogComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CreateProjectDialogComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CreateProjectDialogComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateProjectDialogComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { CreateProjectDialogService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ CreateProjectDialogService ] } ) ; } ) ; it ( 's' , inject ( [ CreateProjectDialogService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateProjectDialogService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { BuildsComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < BuildsComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ BuildsComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( BuildsComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildsComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CodeComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CodeComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CodeComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CodeComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CodeComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ProjectStatusComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProjectStatusComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProjectStatusComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProjectStatusComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectStatusComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CreateIssueComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CreateIssueComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CreateIssueComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CreateIssueComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateIssueComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { CreateIssueDialogService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ CreateIssueDialogService ] } ) ; } ) ; it ( 's' , inject ( [ CreateIssueDialogService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateIssueDialogService$ O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { CommentComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < CommentComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ CommentComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( CommentComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommentComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { IssueComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < IssueComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ IssueComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( IssueComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $IssueComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { IssuesComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < IssuesComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ IssuesComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( IssuesComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $IssuesComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { LogsComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LogsComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LogsComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LogsComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogsComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ProjectComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProjectComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProjectComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProjectComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { SettingsComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < SettingsComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ SettingsComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( SettingsComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $SettingsComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { SqlComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < SqlComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ SqlComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( SqlComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $SqlComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ProjectListComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProjectListComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProjectListComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProjectListComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectListComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ProjectsComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ProjectsComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ProjectsComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ProjectsComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ProjectsComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { StarButtonComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < StarButtonComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ StarButtonComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( StarButtonComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $StarButtonComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { RecoverComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < RecoverComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ RecoverComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( RecoverComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $RecoverComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { ResetComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ResetComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ResetComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ResetComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResetComponent$ O O $ComponentFixture$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TestBed , inject } from 's' ; import { TokenService } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { TestBed . configureTestingModule ( { providers : [ TokenService ] } ) ; } ) ; it ( 's' , inject ( [ TokenService ] , ( service ) => { expect ( service ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokenService$ O O O O O O O O O O O O O O O O O O O
export const environment = { production : false , backendUrl : 's' , stripeKey : 's' } ;	O O O O O O O O O O O O O O O O O O
export const environment = { production : true , backendUrl : 's' , stripeKey : 's' } ;	O O O O O O O O O O O O O O O O O O
import { enableProdMode } from 's' ; import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; import { environment } from 's' ; if ( environment . production ) { enableProdMode ( ) ; } platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import 's' ; import 's' ;	O O O O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const __karma__ ; declare const require ; __karma__ . loaded = function ( ) { } ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ; __karma__ . start ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O