export function ModeToString ( mode ) { switch ( mode ) { case VimMode . Insert : return "s" ; case VimMode . Normal : return "s" ; case VimMode . Visual : return "s" ; case VimMode . VisualLine : return "s" ; default : throw new Error ( "s" ) ; } } export function isNumber ( val ) { let res = parseInt ( val , 0 ) ; return isNaN ? null : res ; } export function KeyToNum ( key ) { let num = key . charCodeAt ( 0 ) - 0 ; if ( num < 0 || 0 < num ) { return NaN ; } return num ; } export function GetKeyType ( key ) { let charCode = key . charCodeAt ( 0 ) ; if ( charCode <= 0 ) { return VimKeyType . Mark ; } if ( charCode <= 0 ) { return VimKeyType . Number ; } if ( charCode <= 0 ) { return VimKeyType . Number ; } if ( charCode <= 0 ) { return VimKeyType . Charactor ; } if ( charCode <= 0 ) { return VimKeyType . Mark ; } if ( charCode <= 0 ) { return VimKeyType . Charactor ; } return VimKeyType . Mark ; } export function GetCharClass ( charCode ) { if ( charCode <= 0 ) { return CharGroup . Spaces ; } if ( charCode <= 0 ) { return CharGroup . Marks ; } if ( charCode <= 0 ) { return CharGroup . AlphabetAndNumber ; } if ( charCode <= 0 ) { return CharGroup . Marks ; } if ( charCode <= 0 ) { return CharGroup . AlphabetAndNumber ; } if ( charCode <= 0 ) { return CharGroup . Marks ; } if ( charCode === 0 ) { return CharGroup . AlphabetAndNumber ; } if ( charCode === 0 ) { return CharGroup . Marks ; } if ( charCode <= 0 ) { return CharGroup . AlphabetAndNumber ; } if ( charCode <= 0 ) { return CharGroup . Marks ; } if ( charCode === 0 ) { return CharGroup . Spaces ; } if ( charCode < 0 ) { return CharGroup . Other ; } if ( charCode === 0 ) { return CharGroup . Spaces ; } if ( charCode <= 0 ) { return CharGroup . Marks ; } if ( charCode <= 0 ) { return CharGroup . Hiragana ; } if ( charCode <= 0 ) { return CharGroup . Katakana ; } return CharGroup . Other ; } export function CalcVisialPosition ( systemPosition , text , tabSize ) { let tabCount = 0 ; for ( let char of text ) { if ( char === "s" ) { tabCount ++ ; } else { break ; } } return ( tabSize - 0 ) * tabCount + systemPosition ; } export function CalcSystemPosition ( visualPosition , text , tabSize ) { let tabCount = 0 ; for ( let char of text ) { if ( char === "s" ) { tabCount ++ ; } else { break ; } } if ( visualPosition <= tabSize * tabCount ) { return Math . floor ( visualPosition / tabSize ) ; } return visualPosition - ( tabSize - 0 ) * tabCount ; }	O O $string$ O $VimMode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Key$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VimKeyType$ O $Key$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CharGroup$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class GoAction implements IAction { public Motion : IMotion ; constructor ( ) { this . Motion = null ; } public GetActionType ( ) { return ActionType . Move ; } public Execute ( editor , vim ) { let from = editor . GetCurrentPosition ( ) ; let to = this . Motion . CalculateEnd ( editor , vim , from ) ; if ( to == null ) { return ; } if ( from . Char === to . Char && from . Line === to . Line ) { return ; } editor . SetPosition ( editor . UpdateValidPosition ( to , true ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class AbstractMotion implements IMotion { public Count : number ; public CalculateEnd ( editor , vim , start ) { throw new Error ( "s" ) ; } }	O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class FirstCharacterMotion extends AbstractMotion { public Target : Target ; public IsSkipSpaces : boolean ; constructor ( ) { super ( ) ; this . Target = Target . Number ; this . IsSkipSpaces = false ; } public CalculateEnd ( editor , vim , start ) { let lineDocument ; let lineNumber ; switch ( this . Target ) { case Target . Current : lineDocument = editor . ReadLineAtCurrentPosition ( ) ; lineNumber = start . Line ; break ; case Target . First : lineNumber = 0 ; lineDocument = editor . ReadLine ( lineNumber ) ; break ; case Target . Last : lineNumber = editor . GetLastLineNum ( ) ; lineDocument = editor . ReadLine ( lineNumber ) ; break ; case Target . Number : lineNumber = this . Count - 0 ; let lastLineNum = editor . GetLastLineNum ( ) ; if ( lineNumber > lastLineNum ) { lineNumber = lastLineNum ; } lineDocument = editor . ReadLine ( lineNumber ) ; break ; } let l = lineDocument . length ; let charNumber ; for ( charNumber = 0 ; charNumber < l ; charNumber ++ ) { let c = Utils . GetCharClass ( lineDocument . charCodeAt ( charNumber ) ) ; if ( c !== CharGroup . Spaces ) { break ; } } let p = new Position ( ) ; p . Line = lineNumber ; p . Char = charNumber ; return p ; } } export enum Target { Current , First , Last , Number , } export function GotoFirstNonBlankCharacterInLine ( num ) { let a = new GoAction ( ) ; let m = new FirstCharacterMotion ( ) ; a . Motion = m ; m . Target = Target . Current ; return a ; } export function AddFirstNonBlankCharacterInLineMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m = new FirstCharacterMotion ( ) ; m . Target = Target . Current ; a . Motion = m ; } export function GotoLastLine ( num ) { let a = new GoAction ( ) ; let m = new FirstCharacterMotion ( ) ; if ( num === 0 ) { m . Target = Target . Last ; } else { m . Target = Target . Number ; m . Count = num ; } a . Motion = m ; return a ; } export function AddLastLineMotion ( num , action ) { let m = new FirstCharacterMotion ( ) ; if ( num === 0 ) { m . Target = Target . Last ; } else { m . Target = Target . Number ; m . Count = num ; } let a = < IRequireMotionAction > action ; a . Motion = m ; a . IsLine = true ; } export function GotoFirstLineOnFirstNonBlankCharacter ( num ) { let a = new GoAction ( ) ; let m = new FirstCharacterMotion ( ) ; if ( num === 0 ) { m . Target = Target . First ; } else { m . Target = Target . Number ; m . Count = num ; } a . Motion = m ; this . action = a ; return a ; } export function AddFirstLineMotion ( num , action ) { let m = new FirstCharacterMotion ( ) ; if ( num === 0 ) { m . Target = Target . First ; } else { m . Target = Target . Number ; m . Count = num ; } let a = < IRequireMotionAction > action ; a . Motion = m ; a . IsLine = true ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class LastCharacterInLineMotion extends AbstractMotion { public CalculateEnd ( editor , vim , start ) { let end = new Position ( ) ; end . Line = start . Line ; end . Char = Number . MAX_VALUE ; return editor . UpdateValidPosition ( end ) ; } } export function GotoLastCharacterInLine ( num ) { let a = new GoAction ( ) ; a . Motion = new LastCharacterInLineMotion ( ) ; return a ; } export function AddLastCharacterInLineMotion ( num , action ) { let a = < IRequireMotionAction > action ; a . Motion = new LastCharacterInLineMotion ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class RightMotion extends AbstractMotion { public IsLeftDirection : boolean ; constructor ( ) { super ( ) ; this . IsLeftDirection = false ; } public CalculateEnd ( editor , vim , start ) { let line = editor . ReadLineAtCurrentPosition ( ) ; let end = new Position ( ) ; end . Line = start . Line ; if ( this . IsLeftDirection ) { end . Char = start . Char - this . Count ; } else { end . Char = start . Char + this . Count ; } return editor . UpdateValidPosition ( end ) ; } } export function GotoRight ( num ) { let m = new RightMotion ( ) ; m . Count = num > 0 ? num : 0 ; let a = new GoAction ( ) ; a . Motion = new RightMotion ( ) ; a . Motion = m ; return a ; } export function GotoLeft ( num ) { let m = new RightMotion ( ) ; m . Count = num > 0 ? num : 0 ; m . IsLeftDirection = true ; let a = new GoAction ( ) ; a . Motion = new RightMotion ( ) ; a . Motion = m ; return a ; } export function AddRightMotion ( num , action ) { let m = new RightMotion ( ) ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddLeftMotion ( num , action ) { let m = new RightMotion ( ) ; m . IsLeftDirection = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class AbstractInsertTextAction implements IInsertTextAction { protected insertText : string ; protected insertModeInfo : any ; constructor ( ) { this . insertModeInfo = null ; this . insertText = null ; } public abstract GetActionType ( ) ; public abstract Execute ( editor , vim ) ; public GetInsertModeInfo ( ) { return this . insertModeInfo ; } public SetInsertText ( text ) { this . insertText = text ; } protected calcPositionAfterInsert ( p ) { let splitText = this . insertText . split ( "s" ) ; let np = p . Copy ( ) ; if ( splitText . length > 0 ) { np . Line += splitText . length - 0 ; np . Char = 0 ; } np . Char += splitText [ splitText . length - 0 ] . length - 0 ; if ( np . Char < 0 ) { np . Char = 0 ; } return np ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O $any$ O $IEditor$ O $IVimStyle$ O O O $any$ O O O O O O O O O O O O $string$ O O O O O O O O O O $IPosition$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as FirstCharacterMotion from "s" ; import * as LastCharacterInLineMotion from "s" ; import * as RightMotion from "s" ; import { AbstractInsertTextAction } from "s" ; export class InsertTextAction extends AbstractInsertTextAction { public Motion : IMotion ; constructor ( m ? ) { super ( ) ; if ( m === undefined ) { this . Motion = null ; } else { this . Motion = m ; } } public GetActionType ( ) { return ActionType . Insert ; } public Execute ( editor , vim ) { let p = editor . GetCurrentPosition ( ) ; if ( this . Motion != null ) { p = this . Motion . CalculateEnd ( editor , vim , p ) ; } if ( this . insertText !== null ) { editor . Insert ( p , this . insertText ) ; editor . SetPosition ( this . calcPositionAfterInsert ( p ) ) ; } else { vim . ApplyInsertMode ( p ) ; let text = editor . ReadLineAtCurrentPosition ( ) ; this . insertModeInfo = { DocumentLineCount : editor . GetLastLineNum ( ) + 0 , Position : p . Copy ( ) , BeforeText : text . substring ( 0 , p . Char ) , AfterText : text . substring ( p . Char ) , } ; } } } export function AppendTextAfterCursor ( num ) { let m = new RightMotion . RightMotion ( ) ; m . Count = 0 ; return new InsertTextAction ( m ) ; } export function AppendTextAtEndOfLine ( num ) { let m = new LastCharacterInLineMotion . LastCharacterInLineMotion ( ) ; return new InsertTextAction ( m ) ; } export function InsertTextBeforeCursor ( num ) { return new InsertTextAction ( ) ; } export function InsertTextBeforeFirstNonBlankInLine ( num ) { let m = new FirstCharacterMotion . FirstCharacterMotion ( ) ; m . Target = FirstCharacterMotion . Target . Current ; return new InsertTextAction ( m ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; export class RegisterItem { public Type : RegisterType ; public Body : string ; } export class Register implements IRegister { private char : { [ key ] : IRegisterItem } ; private roll : IRegisterItem [ ] ; private yank : IRegisterItem ; private unName : IRegisterItem ; constructor ( ) { this . char = { } ; this . roll = [ ] ; this . yank = null ; this . unName = null ; } public Set ( key , value ) { this . char [ key ] = value ; } public SetYank ( value ) { this . unName = value ; this . yank = value ; } public SetRoll ( value ) { this . unName = value ; this . roll . unshift ( value ) ; if ( this . roll . length > 0 ) { this . roll . length = 0 ; } } public Get ( key ) { switch ( key ) { case "s" : return this . yank ; case "s" : return this . unName ; } switch ( Utils . GetKeyType ( key ) ) { case VimKeyType . Charactor : return this . GetCharactorRegister ( key ) ; case VimKeyType . Number : return this . GetRollRegister ( key ) ; } return null ; } public GetUnName ( ) { return this . unName ; } public GetRollFirst ( value ) { if ( this . roll . length > 0 ) { return this . roll [ 0 ] ; } return null ; } private GetRollRegister ( key ) { let n = Utils . KeyToNum ( key ) ; if ( this . roll . length > n + 0 ) { return this . roll [ n ] ; } return null ; } private GetCharactorRegister ( key ) { if ( this . char [ key ] === undefined || this . char [ key ] == null ) { return null ; } return this . char [ key ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Key$ O $IRegisterItem$ O O O O O O O O O O O O O O O $IRegisterItem$ O O O O O O O O O O O O O O O O O O $IRegisterItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRegisterItem$ O $Key$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRegisterItem$ O O O O O O O O O O O O $IRegisterItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Key$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Key$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { Position , Range } from "s" ; import { AbstractInsertTextAction } from "s" ; export class CallEditorCommandAction implements IAction { public Callback : ICommandCallback ; public Argument : string ; public GetActionType ( ) { return ActionType . Other ; } public Execute ( editor , vim ) { if ( this . Callback === undefined || this . Callback === null ) { editor . CallEditorCommand ( this . Argument ) ; } else { this . Callback ( editor , vim ) ; } } } export function EditorCommand ( command ) { let a = new CallEditorCommandAction ( ) ; a . Argument = command . argument ; a . Callback = command . callback ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $IVimStyleCommand$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Range } from "s" ; export class ExpandHighlightedLineAction implements IAction { public Motion : IMotion ; constructor ( ) { this . Motion = null ; } public GetActionType ( ) { return ActionType . Other ; } public Execute ( editor , vim ) { let before = editor . GetCurrentVisualLineModeSelection ( ) ; let cp = before . focusPosition ; let np = this . Motion . CalculateEnd ( editor , vim , cp ) ; editor . ShowVisualLineMode ( before . startLine , np . Line , np ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Position , Range } from "s" ; export class ExpandHighlightedTextAction implements IAction { public Motion : IMotion ; constructor ( ) { this . Motion = null ; } public GetActionType ( ) { return ActionType . Other ; } public Execute ( editor , vim ) { let before = editor . GetCurrentVisualModeSelection ( ) ; let startPosition ; let currentPosition = editor . GetCurrentPosition ( ) ; if ( before . start . IsEqual ( currentPosition ) ) { startPosition = new Position ( before . end . Line , before . end . Char - 0 ) ; } else { startPosition = before . start ; currentPosition = new Position ( currentPosition . Line , currentPosition . Char - 0 ) ; } let nextPosition = this . Motion . CalculateEnd ( editor , vim , currentPosition ) ; let after = new Range ( ) ; if ( nextPosition . IsAfterOrEqual ( startPosition ) ) { after . start = startPosition ; let endLine = editor . ReadLine ( nextPosition . Line ) ; if ( endLine . length > 0 ) { after . end = new Position ( nextPosition . Line , nextPosition . Char + 0 ) ; } else { after . end = nextPosition ; } } else { let startLine = editor . ReadLine ( nextPosition . Line ) ; if ( startLine . length > 0 ) { after . start = new Position ( startPosition . Line , startPosition . Char + 0 ) ; } else { after . start = startPosition ; } after . end = nextPosition ; } editor . ShowVisualMode ( after , after . end ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position } from "s" ; import { AbstractInsertTextAction } from "s" ; export class OpenNewLineAndAppendTextAction extends AbstractInsertTextAction { public IsAbove : boolean ; constructor ( ) { super ( ) ; this . IsAbove = false ; } public GetActionType ( ) { return ActionType . Insert ; } public Execute ( editor , vim ) { let currentPosition = editor . GetCurrentPosition ( ) ; let selecterPosition = new Position ( ) ; selecterPosition . Char = 0 ; let insertPosition = new Position ( ) ; let currentLine = editor . ReadLineAtCurrentPosition ( ) ; if ( this . IsAbove ) { selecterPosition . Line = currentPosition . Line ; insertPosition . Line = currentPosition . Line ; insertPosition . Char = 0 ; } else { selecterPosition . Line = currentPosition . Line + 0 ; insertPosition . Line = currentPosition . Line ; insertPosition . Char = currentLine . length ; } let insertSpace = appendWhiteSpace ( currentLine ) ; selecterPosition . Char = insertSpace . length ; let insertText = insertSpace ; if ( this . insertText !== null ) { insertText += this . insertText ; } if ( this . IsAbove ) { insertText = insertText + "s" ; } else { insertText = "s" + insertText ; } editor . Insert ( insertPosition , insertText ) ; if ( this . insertText === null ) { this . insertModeInfo = { DocumentLineCunt : editor . GetLastLineNum ( ) + 0 , Position : selecterPosition . Copy ( ) , BeforeText : insertSpace , AfterText : "s" , } ; vim . ApplyInsertMode ( selecterPosition ) ; } else { editor . SetPosition ( this . calcPositionAfterInsert ( selecterPosition ) ) ; } } } function appendWhiteSpace ( prevLine ) { if ( prevLine . length === 0 ) { return "s" ; } let firstChar = prevLine . charCodeAt ( 0 ) ; if ( Utils . GetCharClass ( firstChar ) !== CharGroup . Spaces ) { return "s" ; } let i = 0 ; for ( i = 0 ; i < prevLine . length ; i ++ ) { if ( prevLine . charCodeAt ( i ) !== firstChar ) { break ; } } return prevLine . substr ( 0 , i ) ; } export function OpenNewLineBelowCurrentLineAndAppendText ( num ) { return new OpenNewLineAndAppendTextAction ( ) ; } export function OpenNewLineAboveCurrentLineAndAppendText ( num ) { let a = new OpenNewLineAndAppendTextAction ( ) ; a . IsAbove = true ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O
import { Position } from "s" ; export class PutRegisterAction implements IAction { public IsPrev : boolean ; public RegisterKey : Key ; public Count : number ; constructor ( ) { this . IsPrev = false ; this . RegisterKey = null ; } public GetActionType ( ) { return ActionType . Edit ; } public Execute ( editor , vim ) { let item ; if ( this . RegisterKey == null ) { item = vim . Register . GetUnName ( ) ; } else { item = vim . Register . Get ( this . RegisterKey ) ; } if ( item == null ) { return ; } let content = item . Body ; let cp = editor . GetCurrentPosition ( ) ; if ( item . Type === RegisterType . Text ) { if ( this . IsPrev ) { editor . InsertTextAtCurrentPosition ( item . Body ) ; editor . SetPosition ( cp ) ; return ; } let np = new Position ( ) ; np . Char = cp . Char + 0 ; np . Line = cp . Line ; editor . Insert ( np , content ) ; editor . SetPosition ( np ) ; return ; } else { let np = new Position ( ) ; np . Char = 0 ; if ( this . IsPrev ) { np . Line = cp . Line ; } else { np . Line = cp . Line + 0 ; if ( cp . Line === editor . GetLastLineNum ( ) ) { content = "s" + content . substring ( 0 , content . length - 0 ) ; let lp = editor . GetLastPosition ( ) ; editor . Insert ( lp , content ) ; editor . SetPosition ( np ) ; return ; } } editor . Insert ( np , content ) ; editor . SetPosition ( np ) ; } } } export function PutRegisterAfterCursorPosition ( num ) { let a = new PutRegisterAction ( ) ; a . Count = num === 0 ? 0 : num ; return a ; } export function PutRegisterBeforeCursorPosition ( num ) { let a = new PutRegisterAction ( ) ; a . IsPrev = true ; a . Count = num === 0 ? 0 : num ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O $IRegisterItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Position } from "s" ; export class RepeatLastChangeAction implements IAction { public GetActionType ( ) { return ActionType . Repeat ; } public Execute ( editor , vim ) { if ( vim . LastEditAction ) { switch ( vim . LastEditAction . GetActionType ( ) ) { case ActionType . Insert : case ActionType . Edit : let action = vim . LastEditAction ; vim . LastEditAction . Execute ( editor , vim ) ; } } } } export function RepeatLastChange ( ) { return new RepeatLastChangeAction ( ) ; }	O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { Position , Range } from "s" ; import { AbstractInsertTextAction } from "s" ; export class ReplaceCharacterAction implements IRequireCharAction , ICountableAction { public Count : number ; public CharacterCode : number ; public IsAffectingLayout : boolean ; constructor ( ) { this . Count = null ; this . CharacterCode = null ; this . IsAffectingLayout = true ; } public GetActionType ( ) { return ActionType . Edit ; } public Execute ( editor , vim ) { const cp = editor . GetCurrentPosition ( ) ; const line = editor . ReadLineAtCurrentPosition ( ) ; let text = "s" ; const char = String . fromCharCode ( this . CharacterCode ) ; for ( let i = 0 ; i < this . Count ; i ++ ) { text += char ; } let r = new Range ( ) ; r . start = cp ; if ( cp . Char + this . Count > line . length ) { if ( this . IsAffectingLayout ) { return ; } r . end = new Position ( cp . Line , line . length ) ; } else { r . end = new Position ( cp . Line , cp . Char + this . Count ) ; } let np ; np = new Position ( cp . Line , cp . Char + this . Count - 0 ) ; editor . ReplaceRange ( r , text ) ; editor . SetPosition ( np ) ; return ; } } export function ReplaceCharacter ( num ) { const a = new ReplaceCharacterAction ( ) ; a . Count = num === 0 ? 0 : num ; a . IsAffectingLayout = true ; return a ; } export function ReplaceCharacterWithoutAffectingLayout ( num ) { const a = new ReplaceCharacterAction ( ) ; a . Count = num === 0 ? 0 : num ; a . IsAffectingLayout = false ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { Position , Range } from "s" ; export class ReplaceCharacterOfSelectedTextAction implements IRequireCharAction { public CharacterCode : number ; public GetActionType ( ) { return ActionType . Edit ; } public Execute ( editor , vim ) { let s = editor . GetCurrentVisualModeSelection ( ) ; s . Sort ( ) ; let char = String . fromCharCode ( this . CharacterCode ) ; let text = "s" ; if ( s . start . Line === s . end . Line ) { for ( let i = s . start . Char ; i < s . end . Char ; i ++ ) { text += char ; } } else { let line = editor . ReadLine ( s . start . Line ) ; for ( let c = s . start . Char ; c < line . length ; c ++ ) { text += char ; } text += "s" ; for ( let l = s . start . Line + 0 ; l < s . end . Line ; l ++ ) { line = editor . ReadLine ( l ) ; for ( let c of line ) { text += char ; } text += "s" ; } line = editor . ReadLine ( s . end . Line ) ; for ( let c = 0 ; c < s . end . Char ; c ++ ) { text += char ; } } editor . ReplaceRange ( s , text ) ; editor . SetPosition ( s . start ) ; } } export function ReplaceCharacterOfSelectedText ( num ) { return new ReplaceCharacterOfSelectedTextAction ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O
import { Range } from "s" ; export class StartVisualLineModeAction implements IAction { public GetActionType ( ) { return ActionType . Other ; } public Execute ( editor , vim ) { let cp = editor . GetCurrentPosition ( ) ; editor . ShowVisualLineMode ( cp . Line , cp . Line , cp ) ; vim . ApplyVisualLineMode ( ) ; } } export function StartVisualLineMode ( num ) { return new StartVisualLineModeAction ( ) ; }	O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O
import { Position , Range } from "s" ; export class StartVisualModeAction implements IAction { public GetActionType ( ) { return ActionType . Other ; } public Execute ( editor , vim ) { let cp = editor . GetCurrentPosition ( ) ; let s = new Range ( ) ; s . start = cp ; s . end = new Position ( cp . Line , cp . Char + 0 ) ; editor . ShowVisualMode ( s , cp ) ; vim . ApplyVisualMode ( ) ; } } export function StartVisualMode ( num ) { return new StartVisualModeAction ( ) ; }	O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O
import * as Utils from "s" ; export class GoDownAction implements IAction { public Motion : IMotion ; constructor ( ) { this . Motion = null ; } public GetActionType ( ) { return ActionType . LineMove ; } public Execute ( editor , vim ) { let tabSize = editor . GetTabSize ( ) ; let from = editor . GetCurrentPosition ( ) ; let to = this . Motion . CalculateEnd ( editor , vim , from ) ; if ( to == null ) { return ; } if ( vim . LastAction && ActionType . LineMove === vim . LastAction . GetActionType ( ) ) { let toText = editor . ReadLine ( to . Line ) ; to . Char = Utils . CalcSystemPosition ( vim . LastMoveCharPosition , toText , tabSize ) ; } else { let fromText = editor . ReadLine ( from . Line ) ; vim . LastMoveCharPosition = Utils . CalcVisialPosition ( from . Char , fromText , tabSize ) ; } if ( from . Char === to . Char && from . Line === to . Line ) { return ; } editor . SetPosition ( editor . UpdateValidPosition ( to , true ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoDownAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class DownMotion extends AbstractMotion { public IsUpDirection : boolean ; constructor ( ) { super ( ) ; this . IsUpDirection = false ; } public CalculateEnd ( editor , vim , start ) { let tabSize = editor . GetTabSize ( ) ; let end = new Position ( ) ; if ( this . IsUpDirection ) { end . Line = start . Line - this . Count ; if ( end . Line < 0 ) { end . Line = 0 ; } } else { let lastLine = editor . GetLastLineNum ( ) ; end . Line = start . Line + this . Count ; if ( end . Line > lastLine ) { end . Line = lastLine ; } } let startText = editor . ReadLine ( start . Line ) ; let visualChar = Utils . CalcVisialPosition ( start . Char , startText , tabSize ) ; let endText = editor . ReadLine ( end . Line ) ; end . Char = Utils . CalcSystemPosition ( visualChar , endText , tabSize ) ; return editor . UpdateValidPosition ( end ) ; } } export function GoDown ( num ) { let m = new DownMotion ( ) ; let a = new GoDownAction ( ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function GoUp ( num ) { let m = new DownMotion ( ) ; m . IsUpDirection = true ; m . Count = num > 0 ? num : 0 ; let a = new GoDownAction ( ) ; a . Motion = m ; return a ; } export function AddDownMotion ( num , action ) { let m = new DownMotion ( ) ; let a = < IRequireMotionAction > action ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; a . IsLine = true ; } export function AddUpMotion ( num , action ) { let m = new DownMotion ( ) ; m . IsUpDirection = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; a . IsLine = true ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class MoveWordMotion extends AbstractMotion { public IsWORD : boolean ; constructor ( ) { super ( ) ; } ; public CalculateEnd ( editor , vim , start ) { let cal = new Calculater ( start , this . Count , this . IsWORD , editor ) ; return cal . CalculateEnd ( ) ; } } enum State { first = 0 , character , space , linefeed , decreaseCount , decreaseCountAtLinefeed , moveTo , reachDocumentEnd , } enum NextCharacter { character , sameTypeCharacter , differenceTypeCharacter , lineFeed , space , } class Calculater { public pos : IPosition ; public line : string ; public documentLines : number ; public count : number ; public IsWORD : boolean ; public beforeCharacterGroup : CharGroup ; public editor : IEditor ; constructor ( start , count , isWord , editor ) { this . pos = start . Copy ( ) ; this . pos . Char -- ; this . line = editor . ReadLine ( start . Line ) ; this . editor = editor ; this . documentLines = editor . GetLastLineNum ( ) ; this . count = count ; this . beforeCharacterGroup = null ; this . IsWORD = isWord ; } ; public getNextCharacter ( ) { this . pos . Char ++ ; if ( this . pos . Char > this . line . length ) { this . pos . Line ++ ; this . pos . Char = 0 ; this . line = this . editor . ReadLine ( this . pos . Line ) ; } if ( this . pos . Char === this . line . length ) { if ( this . pos . Line === this . documentLines ) { return null ; } this . beforeCharacterGroup = null ; return NextCharacter . lineFeed ; } let characterGroup = Utils . GetCharClass ( this . line . charCodeAt ( this . pos . Char ) ) ; let result ; if ( characterGroup === CharGroup . Spaces ) { this . beforeCharacterGroup = null ; return NextCharacter . space ; } if ( this . beforeCharacterGroup === null ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . character ; } if ( this . IsWORD ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . sameTypeCharacter ; } if ( this . beforeCharacterGroup === characterGroup ) { return NextCharacter . sameTypeCharacter ; } this . beforeCharacterGroup = characterGroup ; return NextCharacter . differenceTypeCharacter ; } public doAtFirst ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } ; public doAtCharacter ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : return State . decreaseCount ; case NextCharacter . sameTypeCharacter : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtLinefeed ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : return State . decreaseCountAtLinefeed ; case NextCharacter . space : return State . space ; } } public doAtSpace ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public decreaseCount ( ) { this . count -- ; if ( this . count === 0 ) { return State . moveTo ; } return State . character ; } public decreaseCountAtLinefeed ( ) { this . count -- ; if ( this . count === 0 ) { return State . moveTo ; } return State . linefeed ; } public CalculateEnd ( ) { let state = State . first ; let whileContinue = true ; while ( whileContinue ) { switch ( state ) { case State . reachDocumentEnd : whileContinue = false ; break ; case State . first : state = this . doAtFirst ( ) ; break ; case State . character : state = this . doAtCharacter ( ) ; break ; case State . linefeed : state = this . doAtLinefeed ( ) ; break ; case State . space : state = this . doAtSpace ( ) ; break ; case State . decreaseCount : state = this . decreaseCount ( ) ; break ; case State . decreaseCountAtLinefeed : state = this . decreaseCountAtLinefeed ( ) ; break ; case State . moveTo : whileContinue = false ; break ; } } return this . pos ; } } export function GotoWordFoword ( num ) { let a = new GoAction ( ) ; let m = new MoveWordMotion ( ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function GotoBlankSeparated ( num ) { let a = new GoAction ( ) ; let m = new MoveWordMotion ( ) ; m . IsWORD = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddToWordFowordMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m = new MoveWordMotion ( ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; } export function AddToBlankSeparatedMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m = new MoveWordMotion ( ) ; m . IsWORD = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $number$ O $boolean$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CharGroup$ O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class WordMotion extends AbstractMotion { public Direction : Direction ; public IsSkipBlankLine : boolean ; public IsStopLineEnd : boolean ; public IsWordEnd : boolean ; public Command : string ; public IsWORD : boolean ; public IsForRange : boolean ; constructor ( direction ) { super ( ) ; this . Direction = direction ; this . IsSkipBlankLine = false ; this . IsStopLineEnd = false ; this . IsWordEnd = false ; this . IsWORD = false ; this . IsForRange = false ; } ; public CalculateEnd ( editor , vim , start ) { let count = this . Count ; let previousCharClass = null ; let charClass = null ; let nextCharClass = null ; let previousPosition = null ; let position = null ; let nextPosition = editor . GetCurrentPosition ( ) . Copy ( ) ; let beforeCountLoop ; let line = editor . ReadLine ( nextPosition . Line ) ; let lineLength = line . length ; let documentLength = editor . GetLastLineNum ( ) + 0 ; if ( this . Direction === Direction . Right ) { if ( nextPosition . Char === 0 ) { charClass = CharGroup . Spaces ; nextCharClass = CharGroup . Spaces ; nextPosition . Char = - 0 ; if ( this . Command !== "s" && line . length > 0 ) { let charCode = line . charCodeAt ( nextPosition . Char ) ; charClass = Utils . GetCharClass ( charCode ) ; if ( charClass !== CharGroup . Spaces ) { count += 0 ; } } beforeCountLoop = - 0 ; } else if ( nextPosition . Char === 0 ) { nextCharClass = CharGroup . Spaces ; beforeCountLoop = - 0 ; } else { nextPosition . Char -- ; beforeCountLoop = - 0 ; } } else { if ( lineLength - 0 === nextPosition . Char ) { charClass = CharGroup . Spaces ; nextCharClass = CharGroup . Spaces ; beforeCountLoop = - 0 ; } else if ( lineLength - 0 === nextPosition . Char ) { nextCharClass = CharGroup . Spaces ; beforeCountLoop = - 0 ; } else { nextPosition . Char ++ ; beforeCountLoop = - 0 ; } } if ( this . IsForRange && nextCharClass !== CharGroup . Spaces ) { count -- ; } let isReachLast = false ; let charCode ; let lineEnd ; let skipCountDown ; while ( count > - 0 ) { skipCountDown = false ; lineEnd = false ; previousPosition = position ; previousCharClass = charClass ; position = nextPosition ; charClass = nextCharClass ; nextPosition = new Position ( position . Line , position . Char ) ; if ( this . Direction === Direction . Left ) { nextPosition . Char -- ; if ( nextPosition . Char === - 0 ) { nextCharClass = CharGroup . Spaces ; } else if ( nextPosition . Char < - 0 ) { nextPosition . Line -- ; if ( nextPosition . Line < 0 ) { isReachLast = true ; break ; } else { line = editor . ReadLine ( nextPosition . Line ) ; lineLength = line . length ; nextPosition . Char = lineLength - 0 ; nextCharClass = CharGroup . Spaces ; } } else { let nextCharCode = line . charCodeAt ( nextPosition . Char ) ; nextCharClass = Utils . GetCharClass ( nextCharCode ) ; } } else { nextPosition . Char ++ ; if ( lineLength <= nextPosition . Char ) { lineEnd = true ; nextPosition . Line ++ ; if ( nextPosition . Line === documentLength ) { isReachLast = true ; break ; } else { line = editor . ReadLine ( nextPosition . Line ) ; lineLength = line . length ; nextPosition . Char = - 0 ; nextCharClass = CharGroup . Spaces ; } } else { let nextCharCode = line . charCodeAt ( nextPosition . Char ) ; nextCharClass = Utils . GetCharClass ( nextCharCode ) ; } } beforeCountLoop ++ ; if ( beforeCountLoop < 0 ) { continue ; } else if ( beforeCountLoop === 0 && this . IsWordEnd && this . Command !== "s" ) { if ( charClass !== CharGroup . Spaces && nextCharClass !== CharGroup . Spaces ) { if ( this . IsWORD || charClass === nextCharClass ) { count -- ; skipCountDown = true ; } } } let newWord = false ; if ( ! skipCountDown ) { if ( charClass !== CharGroup . Spaces ) { if ( this . IsWORD ) { if ( previousCharClass === CharGroup . Spaces ) { newWord = true ; count -- ; } } else { if ( previousCharClass !== charClass ) { newWord = true ; count -- ; } } } else if ( ! newWord && ! this . IsSkipBlankLine ) { if ( this . Direction === Direction . Right ) { if ( previousPosition !== null && previousPosition . Char === - 0 ) { count -- ; } } else { if ( position . Char === - 0 && previousPosition . Char === - 0 ) { count -- ; } } } } if ( count === 0 ) { if ( this . IsWordEnd ) { if ( this . IsWORD ) { if ( nextCharClass === CharGroup . Spaces ) { break ; } if ( lineEnd ) { break ; } } else { if ( charClass !== nextCharClass ) { break ; } } } else if ( this . IsForRange ) { if ( this . Direction === Direction . Right ) { if ( position . Char === - 0 ) { break ; } } } else { break ; } } } if ( isReachLast ) { if ( this . Direction === Direction . Left ) { return new Position ( 0 , 0 ) ; } else { if ( this . IsForRange ) { position . Char += 0 ; } return position ; } } if ( this . IsForRange && position . Char === - 0 ) { line = editor . ReadLine ( position . Line - 0 ) ; return new Position ( position . Line - 0 , line . length ) ; } if ( this . Command === "s" ) { if ( line . length - 0 > position . Char ) { position . Char ++ ; } } return position ; } } export function GotoWordBackword ( num ) { let a = new GoAction ( ) ; let m ; m = new WordMotion ( Direction . Left ) ; m . IsWordEnd = true ; m . IsWORD = false ; m . IsSkipBlankLine = false ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddWordBackwardMotion ( num , action ) { let m ; m = new WordMotion ( Direction . Left ) ; m . IsWordEnd = true ; m . IsWORD = false ; m . IsSkipBlankLine = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function GotoBlankSeparatedBackwordWord ( num ) { let a = new GoAction ( ) ; let m ; m = new WordMotion ( Direction . Left ) ; m . IsWordEnd = true ; m . IsWORD = true ; m . IsSkipBlankLine = false ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddBlankSeparatedBackwordMotion ( num , action ) { let m ; m = new WordMotion ( Direction . Left ) ; m . IsWordEnd = true ; m . IsWORD = true ; m . IsSkipBlankLine = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Direction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O $CharGroup$ O O O O $CharGroup$ O O O O $CharGroup$ O O O O $Position$ O O O O $Position$ O O O O $Position$ O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $boolean$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $WordMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $WordMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $WordMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $WordMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CallEditorCommandAction } from "s" ; import { ExpandHighlightedLineAction } from "s" ; import { ExpandHighlightedTextAction } from "s" ; import { GoAction } from "s" ; import { InsertTextAction } from "s" ; import { OpenNewLineAndAppendTextAction } from "s" ; import { PutRegisterAction } from "s" ; import { RepeatLastChangeAction } from "s" ; import { ReplaceCharacterAction } from "s" ; import { ReplaceCharacterOfSelectedTextAction } from "s" ; import { StartVisualLineModeAction } from "s" ; import { StartVisualModeAction } from "s" ; import { DownMotion } from "s" ; import * as FirstCharacterMotion from "s" ; import { LastCharacterInLineMotion } from "s" ; import { MoveWordMotion } from "s" ; import { RightMotion } from "s" ; import { WordMotion } from "s" ; import * as Utils from "s" ; export class CommandFactory implements ICommandFactory { public Nmap : { [ key ] : string } ; public Nnoremap : { [ key ] : string } ; public KeyBindings : IKeyBindings ; private state : StateName ; private action : IAction ; private motion : IRequireCharacterMotion ; private stackedKey : string ; private num : number ; private registerCharCode : number ; private commandString : string ; constructor ( ) { this . Clear ( ) ; this . Nmap = { } ; this . Nnoremap = { } ; } public PushKey ( orgKeyStroke , mode , remap ) : IAction [ ] { let keyStroke = orgKeyStroke ; let actionList : IAction [ ] = [ ] ; while ( keyStroke . length > 0 ) { let keyChar = keyStroke . substring ( 0 , 0 ) ; keyStroke = keyStroke . substring ( 0 ) ; if ( keyChar === "s" ) { if ( keyStroke . substring ( 0 , 0 ) === "s" ) { keyChar = "s" ; keyStroke = keyStroke . substring ( 0 ) ; } else if ( keyStroke . substring ( 0 , 0 ) === "s" ) { keyChar = "s" ; keyStroke = keyStroke . substring ( 0 ) ; } else if ( keyStroke . substring ( 0 , 0 ) === "s" ) { keyChar = "s" ; keyStroke = keyStroke . substring ( 0 ) ; } else if ( keyStroke . substring ( 0 , 0 ) === "s" ) { keyChar = "s" ; keyStroke = keyStroke . substring ( 0 ) ; } } this . commandString += keyChar ; if ( remap && mode === VimMode . Normal && this . Nmap [ this . commandString ] !== undefined ) { keyStroke += this . Nmap [ this . commandString ] ; this . ClearState ( ) ; continue ; } if ( remap && mode === VimMode . Normal && this . Nnoremap [ this . commandString ] !== undefined ) { let newCommandString = this . Nnoremap [ this . commandString ] ; this . ClearState ( ) ; actionList = actionList . concat ( this . PushKey ( newCommandString , mode , false ) ) ; } else { let action = this . pushKey ( keyChar , mode ) ; if ( action !== null ) { actionList . push ( action ) ; } } } return actionList ; } public pushKey ( keyChar , mode ) { let command ; if ( mode === VimMode . Normal ) { switch ( this . state ) { case StateName . AtStart : command = this . KeyBindings . AtStart [ keyChar ] ; break ; case StateName . FirstNum : command = this . KeyBindings . FirstNum [ keyChar ] ; break ; case StateName . RequireMotion : command = this . KeyBindings . RequireMotion [ keyChar ] ; break ; case StateName . RequireMotionNum : command = this . KeyBindings . RequireMotionNum [ keyChar ] ; break ; case StateName . RequireCharForMotion : return this . pushKeyAtRequireCharForMotion ( keyChar ) ; case StateName . RequireCharForAction : return this . pushKeyAtRequireCharForAction ( keyChar ) ; case StateName . RequireCharForRegister : return this . pushKeyAtRequireCharForRegister ( keyChar ) ; case StateName . RequireBrancketForLeftBrancket : command = this . KeyBindings . RequireBrancketForLeftBrancket [ keyChar ] ; break ; case StateName . RequireBrancketForLeftBrancketMotion : command = this . KeyBindings . RequireBrancketForLeftBrancketMotion [ keyChar ] ; break ; case StateName . RequireBrancketForRightBrancket : command = this . KeyBindings . RequireBrancketForRightBrancket [ keyChar ] ; break ; case StateName . RequireBrancketForRightBrancketMotion : command = this . KeyBindings . RequireBrancketForRightBrancketMotion [ keyChar ] ; break ; case StateName . RequireInnerTextObject : command = this . KeyBindings . RequireInnerTextObject [ keyChar ] ; break ; case StateName . RequireOuterTextObject : command = this . KeyBindings . RequireOuterTextObject [ keyChar ] ; break ; case StateName . SmallG : command = this . KeyBindings . SmallG [ keyChar ] ; break ; case StateName . SmallGForMotion : command = this . KeyBindings . SmallGForMotion [ keyChar ] ; break ; } } else if ( mode === VimMode . Visual ) { switch ( this . state ) { case StateName . AtStart : this . action = new ExpandHighlightedTextAction ( ) ; command = this . KeyBindings . VisualMode [ keyChar ] ; break ; case StateName . VisualModeNum : this . action = new ExpandHighlightedTextAction ( ) ; command = this . KeyBindings . VisualModeNum [ keyChar ] ; break ; case StateName . RequireMotionNum : command = this . KeyBindings . RequireMotionNum [ keyChar ] ; break ; case StateName . RequireCharForMotion : return this . pushKeyAtRequireCharForMotion ( keyChar ) ; case StateName . RequireCharForAction : return this . pushKeyAtRequireCharForAction ( keyChar ) ; case StateName . RequireCharForRegister : return this . pushKeyAtRequireCharForRegister ( keyChar ) ; case StateName . RequireBrancketForLeftBrancketMotion : command = this . KeyBindings . RequireBrancketForLeftBrancketMotion [ keyChar ] ; break ; case StateName . RequireBrancketForRightBrancketMotion : command = this . KeyBindings . RequireBrancketForRightBrancketMotion [ keyChar ] ; break ; case StateName . SmallGForMotion : command = this . KeyBindings . SmallGForMotion [ keyChar ] ; break ; } } else if ( mode === VimMode . VisualLine ) { switch ( this . state ) { case StateName . AtStart : this . action = new ExpandHighlightedLineAction ( ) ; command = this . KeyBindings . VisualLineMode [ keyChar ] ; break ; case StateName . RequireMotionNum : command = this . KeyBindings . RequireMotionNum [ keyChar ] ; break ; case StateName . RequireCharForMotion : return this . pushKeyAtRequireCharForMotion ( keyChar ) ; case StateName . RequireBrancketForLeftBrancketMotion : command = this . KeyBindings . RequireBrancketForLeftBrancketMotion [ keyChar ] ; break ; case StateName . RequireBrancketForRightBrancketMotion : command = this . KeyBindings . RequireBrancketForRightBrancketMotion [ keyChar ] ; break ; case StateName . SmallGForMotion : command = this . KeyBindings . SmallGForMotion [ keyChar ] ; break ; } } if ( command === undefined ) { this . Clear ( ) ; return null ; } this . createVimStyleCommand ( keyChar , command ) ; if ( command . state === StateName . Panic ) { this . Clear ( ) ; return null ; } if ( command . state === undefined ) { return this . action ; } this . stackedKey = keyChar ; this . state = command . state ; return null ; } public Clear ( ) { this . ClearState ( ) ; this . commandString = "s" ; } public ClearState ( ) { this . state = StateName . AtStart ; this . action = null ; this . stackedKey = null ; this . num = 0 ; } public GetCommandString ( ) { return this . commandString ; } private createVimStyleCommand ( key , command ) { if ( command . CreateAction ) { this . action = command . CreateAction ( this . num ) ; return ; } if ( command . AddMotion ) { command . AddMotion ( this . num , this . action ) ; return ; } if ( command . CreateActionWithArguments ) { this . action = command . CreateActionWithArguments ( command ) ; return ; } switch ( command . cmd ) { case VimCommand . stackNumber : this . stackNumber ( key ) ; case VimCommand . nothing : return ; } } private pushKeyAtRequireCharForMotion ( key ) { const a = this . action as IRequireMotionAction ; const m = a . Motion as IRequireCharacterMotion ; m . CharacterCode = key . charCodeAt ( 0 ) ; return this . action ; } private pushKeyAtRequireCharForAction ( key ) { const a = this . action as IRequireCharAction ; a . CharacterCode = key . charCodeAt ( 0 ) ; return this . action ; } private pushKeyAtRequireCharForRegister ( key ) { this . registerCharCode = key . charCodeAt ( 0 ) ; this . state = StateName . AtStart ; return null ; } private getNumStack ( ) { return this . num === 0 ? 0 : this . num ; } private stackNumber ( key ) { let n = parseInt ( key , 0 ) ; this . num = this . num * 0 + n ; if ( this . num > 0 ) { this . Clear ( ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VimMode$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $string$ O $VimMode$ O O O $IVimStyleCommand$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O $IVimStyleCommand$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class Nmap implements IExCommand { public Execute ( arg , vimStyle , editor ) { if ( arg == null || arg . length === 0 ) { showCurrentMap ( ) ; return ; } let args = divideArg ( arg ) ; if ( args . length === 0 ) { vimStyle . CommandFactory . Nmap [ args [ 0 ] ] = args [ 0 ] ; } } } export class Nnoremap implements IExCommand { public Execute ( arg , vimStyle , editor ) { if ( arg == null || arg . length === 0 ) { showCurrentMap ( ) ; return ; } let args = divideArg ( arg ) ; if ( args . length === 0 ) { vimStyle . CommandFactory . Nnoremap [ args [ 0 ] ] = args [ 0 ] ; } } } function divideArg ( arg ) : string [ ] { return arg . split ( "s" ) ; } function showCurrentMap ( ) { }	O O O O O O O O O $string$ O $IVimStyle$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $IVimStyle$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O
import { Nmap , Nnoremap } from "s" ; export function ExecExCommand ( line , vimStyle , editor ) { let sp = line . indexOf ( "s" ) ; let commandName ; let commandArg ; if ( sp >= 0 ) { commandName = line . substring ( 0 , sp ) ; commandArg = line . substring ( sp + 0 ) ; } else { commandName = line ; commandArg = null ; } let command = selectCommand ( commandName ) ; if ( command !== null ) { command . Execute ( commandArg , vimStyle , editor ) ; } } function selectCommand ( command ) { switch ( command ) { case "s" : return new Nmap ( ) ; case "s" : return new Nnoremap ( ) ; } return null ; }	O O O O O O O O O O O O O $string$ O $IVimStyle$ O $IEditor$ O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IExCommand$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { DownMotion } from "s" ; import { LastCharacterInLineMotion } from "s" ; import { RightMotion } from "s" ; import { Position , Range } from "s" ; import { AbstractInsertTextAction } from "s" ; export class DeleteYankChangeAction extends AbstractInsertTextAction implements IRequireMotionAction , IInsertTextAction { public Motion : IMotion ; public Selection : ISelectionMotion ; public IsLine : boolean ; public IsLarge : boolean ; public IsChange : boolean ; public IsOnlyYanc : boolean ; constructor ( ) { super ( ) ; this . Motion = null ; this . IsLine = false ; this . IsLarge = true ; this . IsChange = false ; this . IsOnlyYanc = false ; } public GetActionType ( ) { if ( this . IsOnlyYanc ) { return ActionType . Other ; } else if ( this . IsChange ) { return ActionType . Insert ; } return ActionType . Edit ; } public Execute ( editor , vim ) { let range = new Range ( ) ; range . start = editor . GetCurrentPosition ( ) ; if ( this . Motion ) { let p = this . Motion . CalculateEnd ( editor , vim , range . start ) ; if ( p == null ) { return ; } range . end = p ; range . Sort ( ) ; } else if ( this . Selection ) { range = this . Selection . CalculateRange ( editor , vim , range . start ) ; if ( range == null ) { return ; } } if ( this . IsLine ) { this . deleteLine ( range , editor , vim ) ; } else { this . deleteRange ( range , editor , vim ) ; } } private deleteRange ( range , editor , vim ) { let nextPosition = new Position ( ) ; nextPosition . Line = range . start . Line ; let endLine = editor . ReadLine ( range . end . Line ) ; if ( range . start . Char === 0 ) { nextPosition . Char = 0 ; } else { if ( endLine . length <= range . end . Char ) { if ( this . IsChange ) { nextPosition . Char = range . start . Char ; } else { nextPosition . Char = range . start . Char - 0 ; } } else { nextPosition . Char = range . start . Char ; } } let item = new RegisterItem ( ) ; item . Body = editor . ReadRange ( range ) ; item . Type = RegisterType . Text ; if ( this . IsLarge ) { vim . Register . SetRoll ( item ) ; } if ( this . IsChange ) { if ( this . insertText === null ) { vim . ApplyInsertMode ( nextPosition ) ; } } if ( ! this . IsOnlyYanc ) { if ( this . IsChange && this . insertText ) { editor . ReplaceRange ( range , this . insertText ) ; editor . SetPosition ( this . calcPositionAfterInsert ( nextPosition ) ) ; } else { editor . DeleteRange ( range , nextPosition ) ; } } if ( this . IsChange && this . insertText === null ) { let startLine = editor . ReadLine ( range . start . Line ) ; let afterLineCount = editor . GetLastLineNum ( ) + 0 - ( range . end . Line - range . start . Line ) ; vim . ApplyInsertMode ( range . start ) ; this . insertModeInfo = { DocumentLineCount : afterLineCount , Position : nextPosition , BeforeText : startLine . substring ( 0 , range . start . Char ) , AfterText : endLine . substring ( range . end . Char ) , } ; } } private deleteLine ( range , editor , vim ) { let del = new Range ( ) ; let nextPosition = new Position ( ) ; let nextPositionLineHasNoChar = false ; nextPosition . Char = 0 ; let lastLine = editor . GetLastLineNum ( ) ; if ( lastLine <= range . end . Line ) { if ( range . start . Line === 0 ) { del . start . Char = 0 ; del . start . Line = 0 ; del . end . Char = Number . MAX_VALUE ; del . end . Line = range . end . Line ; del . end = editor . UpdateValidPosition ( del . end ) ; nextPosition . Line = 0 ; } else if ( this . IsChange ) { del . start . Char = 0 ; del . start . Line = range . start . Line ; del . start = editor . UpdateValidPosition ( del . start ) ; del . end . Char = Number . MAX_VALUE ; del . end . Line = range . end . Line ; del . end = editor . UpdateValidPosition ( del . end ) ; nextPosition . Line = del . start . Line ; } else { del . start . Char = Number . MAX_VALUE ; del . start . Line = range . start . Line - 0 ; del . start = editor . UpdateValidPosition ( del . start ) ; del . end . Char = Number . MAX_VALUE ; del . end . Line = range . end . Line ; del . end = editor . UpdateValidPosition ( del . end ) ; nextPosition . Line = range . start . Line - 0 ; } } else { if ( this . IsChange ) { del . start . Char = 0 ; del . start . Line = range . start . Line ; del . end . Char = Number . MAX_VALUE ; del . end . Line = range . end . Line ; del . end = editor . UpdateValidPosition ( del . end ) ; nextPosition . Line = del . start . Line ; } else { del . start . Char = 0 ; del . start . Line = range . start . Line ; del . end . Char = 0 ; del . end . Line = range . end . Line + 0 ; nextPosition . Line = range . start . Line ; } } let yanc = new Range ( ) ; yanc . start . Line = range . start . Line ; yanc . start . Char = 0 ; yanc . end . Line = range . end . Line ; yanc . end . Char = Number . MAX_VALUE ; yanc . end = editor . UpdateValidPosition ( yanc . end ) ; let item = new RegisterItem ( ) ; item . Body = editor . ReadRange ( yanc ) ; if ( this . IsLine ) { item . Body += "s" ; } item . Type = RegisterType . LineText ; vim . Register . SetRoll ( item ) ; if ( ! this . IsOnlyYanc ) { if ( this . IsChange && this . insertText !== null ) { editor . ReplaceRange ( del , this . insertText ) ; } else { editor . DeleteRange ( del , nextPosition ) ; } } if ( this . IsChange && this . insertText === null ) { vim . ApplyInsertMode ( ) ; this . insertModeInfo = { DocumentLineCount : lastLine + 0 , Position : nextPosition , BeforeText : "s" , AfterText : "s" , } ; } } } export function DeleteCharactersUnderCursor ( num ) { let m = new RightMotion ( ) ; m . Count = num === 0 ? 0 : num ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . Motion = m ; return a ; } export function DeleteCharactersBeforeCursor ( num ) { let m = new RightMotion ( ) ; m . IsLeftDirection = true ; m . Count = num === 0 ? 0 : num ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . Motion = m ; return a ; } export function DeleteTextWithMotion ( num ) { return new DeleteYankChangeAction ( ) ; } export function DeleteCurrentLine ( num ) { let a = new DeleteYankChangeAction ( ) ; a . IsLine = true ; let m = new DownMotion ( ) ; m . Count = num === 0 ? 0 : num - 0 ; a . Motion = m ; return a ; } export function DeleteTextToEndOfLine ( num ) { let m = new LastCharacterInLineMotion ( ) ; m . Count = 0 ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . Motion = m ; return a ; } export function YankTextWithMotion ( num ) { let a = new DeleteYankChangeAction ( ) ; a . IsOnlyYanc = true ; return a ; } export function YankCurrentLine ( num ) { let a = new DeleteYankChangeAction ( ) ; a . IsLine = true ; a . IsOnlyYanc = true ; let m = new DownMotion ( ) ; m . Count = num === 0 ? 0 : num - 0 ; a . Motion = m ; return a ; } export function YankLine ( num ) { let m = new LastCharacterInLineMotion ( ) ; m . Count = 0 ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . IsLine = true ; a . Motion = m ; a . IsOnlyYanc = true ; return a ; } export function ChangeTextWithMotion ( num ) { let a = new DeleteYankChangeAction ( ) ; a . IsChange = true ; return a ; } export function ChangeLines ( num ) { let m = new DownMotion ( ) ; m . Count = this . getNumStack ( ) - 0 ; let a = new DeleteYankChangeAction ( ) ; a . IsLine = true ; a . Motion = m ; a . IsChange = true ; return a ; } export function ChangeCurrentLine ( num ) { let a = new DeleteYankChangeAction ( ) ; a . IsLine = true ; a . IsChange = true ; let m = new DownMotion ( ) ; m . Count = num === 0 ? 0 : num - 0 ; a . Motion = m ; return a ; } export function ChangeTextToEndOfLine ( num ) { let m = new LastCharacterInLineMotion ( ) ; m . Count = 0 ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . Motion = m ; a . IsChange = true ; return a ; } export function ChangeCharacters ( num ) { let m = new RightMotion ( ) ; m . Count = 0 ; let a = new DeleteYankChangeAction ( ) ; a . IsLarge = false ; a . Motion = m ; a . IsChange = true ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { Position , Range } from "s" ; export class DeleteYankChangeHighlightedLineAction implements IInsertTextAction { public isInsert : boolean ; public isOnlyYanc : boolean ; private insertText : string ; private insertModeInfo : any ; constructor ( ) { this . isInsert = false ; this . isOnlyYanc = false ; } public GetActionType ( ) { if ( this . isOnlyYanc ) { return ActionType . Other ; } else if ( this . isInsert ) { return ActionType . Insert ; } return ActionType . Other ; } public SetChangeOption ( ) { this . isInsert = true ; } public SetOnlyYancOption ( ) { this . isOnlyYanc = true ; } public GetInsertModeInfo ( ) { return this . insertModeInfo ; } public SetInsertText ( text ) { this . insertText = text ; } public Execute ( editor , vim ) { let s = editor . GetCurrentVisualLineModeSelection ( ) ; let 0 ; let 0 ; if ( s . startLine < s . endLine ) { 0 = s . startLine ; 0 = s . endLine ; } else { 0 = s . endLine ; 0 = s . startLine ; } let 0 = editor . ReadLine ( 0 ) ; let 0 = new Position ( 0 , 0 ) ; let 0 = new Position ( 0 , 0 . length ) ; let nrange = new Range ( ) ; nrange . start = 0 ; nrange . end = 0 ; let item = new RegisterItem ( ) ; item . Body = editor . ReadRange ( nrange ) + "s" ; item . Type = RegisterType . LineText ; vim . Register . SetRoll ( item ) ; if ( this . isOnlyYanc ) { vim . ApplyNormalMode ( ) ; editor . SetPosition ( s . focusPosition ) ; } else if ( this . isInsert ) { vim . ApplyInsertMode ( ) ; editor . DeleteRange ( nrange , nrange . start ) ; } else { vim . ApplyNormalMode ( ) ; if ( 0 === editor . GetLastLineNum ( ) ) { if ( nrange . start . Line !== 0 ) { nrange . start . Line -= 0 ; let prevLine = editor . ReadLine ( nrange . start . Line ) ; nrange . start . Char = prevLine . length ; } } else { nrange . end . Line += 0 ; nrange . end . Char = 0 ; } editor . DeleteRange ( nrange , nrange . start ) ; } } } export function DeleteHighlightedLine ( num ) { return new DeleteYankChangeHighlightedLineAction ( ) ; } export function YankHighlightedLine ( num ) { let a = new DeleteYankChangeHighlightedLineAction ( ) ; a . SetOnlyYancOption ( ) ; return a ; } export function ChangeHighligtedLine ( num ) { let a = new DeleteYankChangeHighlightedLineAction ( ) ; a . SetChangeOption ( ) ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O
import { RegisterItem } from "s" ; import { Position , Range } from "s" ; export class DeleteYankChangeHighlightedTextAction implements IInsertTextAction { public isInsert : boolean ; public isOnlyYanc : boolean ; private insertText : string ; private insertModeInfo : any ; constructor ( ) { this . isInsert = false ; this . isOnlyYanc = false ; } public GetActionType ( ) { if ( this . isOnlyYanc ) { return ActionType . Other ; } else if ( this . isInsert ) { return ActionType . Insert ; } return ActionType . Other ; } public SetChangeOption ( ) { this . isInsert = true ; } public SetOnlyYancOption ( ) { this . isOnlyYanc = true ; } public GetInsertModeInfo ( ) { return this . insertModeInfo ; } public SetInsertText ( text ) { this . insertText = text ; } public Execute ( editor , vim ) { let s = editor . GetCurrentVisualModeSelection ( ) ; s . Sort ( ) ; if ( s . end . Char === 0 && editor . GetLastLineNum ( ) !== s . end . Line ) { let lastLine = editor . ReadLine ( s . end . Line ) ; if ( lastLine . length === 0 ) { s = s . Copy ( ) ; s . end . Line += 0 ; } } let item = new RegisterItem ( ) ; item . Body = editor . ReadRange ( s ) ; item . Type = RegisterType . Text ; vim . Register . SetRoll ( item ) ; if ( this . isInsert ) { vim . ApplyInsertMode ( ) ; } else { vim . ApplyNormalMode ( ) ; } if ( ! this . isOnlyYanc ) { editor . DeleteRange ( s , s . start ) ; } else { editor . SetPosition ( s . start ) ; } } } export function DeleteHighlightedText ( num ) { return new DeleteYankChangeHighlightedTextAction ( ) ; } export function YankHighlightedText ( num ) { let a = new DeleteYankChangeHighlightedTextAction ( ) ; a . SetOnlyYancOption ( ) ; return a ; } export function ChangeHighlightedText ( num ) { let a = new DeleteYankChangeHighlightedTextAction ( ) ; a . SetChangeOption ( ) ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position , Range } from "s" ; export class JoinHighlightedLinesAction implements IAction { public GetActionType ( ) { return ActionType . Edit ; } public Execute ( editor , vim ) { let startLine ; let endLine ; if ( vim . GetMode ( ) === VimMode . Visual ) { let s = editor . GetCurrentVisualModeSelection ( ) ; startLine = s . start . Line ; endLine = s . end . Line ; } else { let s = editor . GetCurrentVisualLineModeSelection ( ) ; startLine = s . startLine ; endLine = s . endLine ; } const docLines = editor . GetLastLineNum ( ) ; const startPos = new Position ( startLine , 0 ) ; let endPos ; if ( startLine === endLine ) { if ( startLine + 0 === docLines ) { return ; } endPos = new Position ( endLine + 0 , 0 ) ; } else { endPos = new Position ( endLine , 0 ) ; } const range = new Range ( ) ; range . start = startPos ; range . end = endPos ; let text = editor . ReadRange ( range ) ; text = text . replace ( "s" , "s" ) ; text = text . replace ( "s" , "s" ) ; let pos = new Position ( startPos . Line , text . length - 0 ) ; editor . ReplaceRange ( range , text ) ; editor . SetPosition ( pos ) ; } } export function JoinHighlightedText ( num ) { let a = new JoinHighlightedLinesAction ( ) ; return a ; } export function JoinHighlightedLines ( num ) { let a = new JoinHighlightedLinesAction ( ) ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position , Range } from "s" ; export class JoinLinesAction implements IAction { public Count : number ; public GetActionType ( ) { return ActionType . Edit ; } public Execute ( editor , vim ) { const docLines = editor . GetLastLineNum ( ) ; const startPos = new Position ( editor . GetCurrentPosition ( ) . Line , 0 ) ; let endPos ; if ( docLines > startPos . Line + this . Count - 0 ) { endPos = new Position ( startPos . Line + this . Count - 0 , 0 ) ; } else { endPos = new Position ( docLines , 0 ) ; } const range = new Range ( ) ; range . start = startPos ; range . end = endPos ; let text = editor . ReadRange ( range ) ; text = text . replace ( "s" , "s" ) ; text = text . replace ( "s" , "s" ) ; let pos = new Position ( startPos . Line , text . length - 0 ) ; editor . ReplaceRange ( range , text ) ; editor . SetPosition ( pos ) ; } } export function JoinLines ( num ) { let a = new JoinLinesAction ( ) ; a . Count = num < 0 ? 0 : num ; return a ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionType$ O O O O O O O O O O O O $IEditor$ O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class BackToBrancketMotion extends AbstractMotion { public LeftBrancket : string ; public RightBrancket : string ; public TargetBrancket : string ; constructor ( ) { super ( ) ; } public CalculateEnd ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; let lastBrancket = null ; while ( this . Count > 0 ) { p . Char -- ; if ( p . Char < 0 ) { p . Line -- ; if ( p . Line < 0 ) { p = new Position ( 0 , 0 ) ; break ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = line . length - 0 ; } let c = line [ p . Char ] ; if ( c === this . LeftBrancket ) { lastBrancket = p . Copy ( ) ; this . Count -- ; } if ( c === this . RightBrancket ) { this . Count ++ ; } if ( this . Count === 0 && c === this . TargetBrancket ) { break ; } } if ( lastBrancket == null ) { return start . Copy ( ) ; } return lastBrancket ; } } export class ToBrancketMotion extends AbstractMotion { public LeftBrancket : string ; public RightBrancket : string ; public TargetBrancket : string ; constructor ( ) { super ( ) ; } public CalculateEnd ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; let lastBrancket = null ; while ( this . Count > 0 ) { p . Char ++ ; if ( p . Char >= line . length ) { p . Line ++ ; if ( p . Line > lastLine ) { break ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = 0 ; } let c = line [ p . Char ] ; if ( c === this . LeftBrancket ) { this . Count ++ ; } if ( c === this . RightBrancket ) { lastBrancket = p . Copy ( ) ; this . Count -- ; } if ( this . Count === 0 && c === this . TargetBrancket ) { break ; } } if ( lastBrancket == null ) { return start . Copy ( ) ; } return lastBrancket ; } } export function GoBackToUnclosedLeftParenthesis ( num ) { let a = new GoAction ( ) ; let m = new BackToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddBackToUnclosedLeftParenthesisMotion ( num , action ) { let m = new BackToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function GoBackToUnclosedLeftCurlyBracket ( num ) { let a = new GoAction ( ) ; let m = new BackToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddBackToUnclosedLeftCurlyBracketMotion ( num , action ) { let m = new BackToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > this . action ; a . Motion = m ; } export function GoToUnclosedRightParenthesis ( num ) { let a = new GoAction ( ) ; let m = new ToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddToUnclosedRightParenthesisMotion ( num , action ) { let m = new ToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function GoToUnclosedRightCurlyBracket ( num ) { let a = new GoAction ( ) ; let m = new ToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddToUnclosedRightCurlyBracketMotion ( num , action ) { let m = new ToBrancketMotion ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . TargetBrancket = "s" ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O $IPosition$ O O O O O O O O $string$ O O O O O O O O $number$ O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O $IPosition$ O O O O O O O O $string$ O O O O O O O O $number$ O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class DeleteWordMotion extends AbstractMotion { public IsWORD : boolean ; constructor ( ) { super ( ) ; } ; public CalculateEnd ( editor , vim , start ) { let cal = new Calculater ( start , this . Count , this . IsWORD , editor ) ; return cal . CalculateEnd ( ) ; } } enum State { first = 0 , 0 , character , space , linefeed , decreaseCount , decreaseCountAtLinefeed , 0 , 0 , 0 , deleteUntilLinefeed , deleteUntilJustBefore , reachDocumentEnd , } enum NextCharacter { character , sameTypeCharacter , differenceTypeCharacter , lineFeed , space , } class Calculater { public pos : IPosition ; public line : string ; public documentLines : number ; public count : number ; public IsWORD : boolean ; public beforeCharacterGroup : CharGroup ; public editor : IEditor ; constructor ( start , count , isWord , editor ) { this . pos = start . Copy ( ) ; this . pos . Char -- ; this . line = editor . ReadLine ( start . Line ) ; this . editor = editor ; this . documentLines = editor . GetLastLineNum ( ) ; this . count = count ; this . beforeCharacterGroup = null ; this . IsWORD = isWord ; } ; public getNextCharacter ( ) { this . pos . Char ++ ; if ( this . pos . Char > this . line . length ) { this . pos . Line ++ ; this . pos . Char = 0 ; this . line = this . editor . ReadLine ( this . pos . Line ) ; } if ( this . pos . Char === this . line . length ) { if ( this . pos . Line === this . documentLines ) { return null ; } this . beforeCharacterGroup = null ; return NextCharacter . lineFeed ; } let characterGroup = Utils . GetCharClass ( this . line . charCodeAt ( this . pos . Char ) ) ; let result ; if ( characterGroup === CharGroup . Spaces ) { this . beforeCharacterGroup = null ; return NextCharacter . space ; } if ( this . beforeCharacterGroup === null ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . character ; } if ( this . IsWORD ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . sameTypeCharacter ; } if ( this . beforeCharacterGroup === characterGroup ) { return NextCharacter . sameTypeCharacter ; } this . beforeCharacterGroup = characterGroup ; return NextCharacter . differenceTypeCharacter ; } public doAtFirst ( ) { if ( this . count === 0 ) { return State . 0 ; } return State . 0 ; } ; public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtCharacter ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : return State . decreaseCount ; case NextCharacter . sameTypeCharacter : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtLinefeed ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCountAtLinefeed ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtSpace ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public decreaseCount ( ) { this . count -- ; if ( this . count === 0 ) { return State . 0 ; } return State . character ; } public decreaseCountAtLinefeed ( ) { this . count -- ; if ( this . count === 0 ) { return State . 0 ; } return State . linefeed ; } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . 0 ; case NextCharacter . lineFeed : return State . deleteUntilLinefeed ; case NextCharacter . space : return State . 0 ; } } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : case NextCharacter . lineFeed : return State . deleteUntilJustBefore ; case NextCharacter . sameTypeCharacter : return State . 0 ; case NextCharacter . space : return State . 0 ; } } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : case NextCharacter . lineFeed : return State . deleteUntilJustBefore ; case NextCharacter . space : return State . 0 ; } } public CalculateEnd ( ) { let state = State . first ; let whileContinue = true ; while ( whileContinue ) { switch ( state ) { case State . reachDocumentEnd : whileContinue = false ; break ; case State . first : state = this . doAtFirst ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . character : state = this . doAtCharacter ( ) ; break ; case State . linefeed : state = this . doAtLinefeed ( ) ; break ; case State . space : state = this . doAtSpace ( ) ; break ; case State . decreaseCount : state = this . decreaseCount ( ) ; break ; case State . decreaseCountAtLinefeed : state = this . decreaseCountAtLinefeed ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . deleteUntilJustBefore : case State . deleteUntilLinefeed : whileContinue = false ; break ; } } return this . pos ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $number$ O $boolean$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CharGroup$ O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; import { DeleteWordMotion } from "s" ; export class ChangeWordMotion extends AbstractMotion { public IsWORD : boolean ; constructor ( ) { super ( ) ; } ; public CalculateEnd ( editor , vim , start ) { let cal = new Calculater ( start , this . Count , this . IsWORD , editor ) ; return cal . CalculateEnd ( ) ; } } enum State { first = 0 , 0 , character , space , linefeed , decreaseCount , decreaseCountAtLinefeed , 0 , 0 , 0 , deleteUntilJustBefore , reachDocumentEnd , } enum NextCharacter { character , sameTypeCharacter , differenceTypeCharacter , lineFeed , space , } class Calculater { public pos : IPosition ; public line : string ; public documentLines : number ; public count : number ; public IsWORD : boolean ; public beforeCharacterGroup : CharGroup ; public editor : IEditor ; constructor ( start , count , isWord , editor ) { this . pos = start . Copy ( ) ; this . pos . Char -- ; this . line = editor . ReadLine ( start . Line ) ; this . editor = editor ; this . documentLines = editor . GetLastLineNum ( ) ; this . count = count ; this . beforeCharacterGroup = null ; this . IsWORD = isWord ; } ; public getNextCharacter ( ) { this . pos . Char ++ ; if ( this . pos . Char > this . line . length ) { this . pos . Line ++ ; this . pos . Char = 0 ; this . line = this . editor . ReadLine ( this . pos . Line ) ; } if ( this . pos . Char === this . line . length ) { if ( this . pos . Line === this . documentLines ) { return null ; } this . beforeCharacterGroup = null ; return NextCharacter . lineFeed ; } let characterGroup = Utils . GetCharClass ( this . line . charCodeAt ( this . pos . Char ) ) ; let result ; if ( characterGroup === CharGroup . Spaces ) { this . beforeCharacterGroup = null ; return NextCharacter . space ; } if ( this . beforeCharacterGroup === null ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . character ; } if ( this . IsWORD ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . sameTypeCharacter ; } if ( this . beforeCharacterGroup === characterGroup ) { return NextCharacter . sameTypeCharacter ; } this . beforeCharacterGroup = characterGroup ; return NextCharacter . differenceTypeCharacter ; } public doAtFirst ( ) { if ( this . count === 0 ) { return State . 0 ; } return State . 0 ; } ; public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtCharacter ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : return State . decreaseCount ; case NextCharacter . sameTypeCharacter : return State . character ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public doAtLinefeed ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : return State . decreaseCountAtLinefeed ; case NextCharacter . space : return State . space ; } } public doAtSpace ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : return State . linefeed ; case NextCharacter . space : return State . space ; } } public decreaseCount ( ) { this . count -- ; if ( this . count === 0 ) { return State . 0 ; } return State . character ; } public decreaseCountAtLinefeed ( ) { this . count -- ; if ( this . count === 0 ) { return State . 0 ; } return State . 0 ; } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . 0 ; case NextCharacter . lineFeed : return State . deleteUntilJustBefore ; case NextCharacter . space : return State . 0 ; } } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : case NextCharacter . lineFeed : case NextCharacter . space : return State . deleteUntilJustBefore ; case NextCharacter . sameTypeCharacter : return State . 0 ; } } public 0 ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : case NextCharacter . lineFeed : return State . deleteUntilJustBefore ; case NextCharacter . space : return State . 0 ; } } public CalculateEnd ( ) { let state = State . first ; let whileContinue = true ; while ( whileContinue ) { switch ( state ) { case State . reachDocumentEnd : whileContinue = false ; break ; case State . first : state = this . doAtFirst ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . character : state = this . doAtCharacter ( ) ; break ; case State . linefeed : state = this . doAtLinefeed ( ) ; break ; case State . space : state = this . doAtSpace ( ) ; break ; case State . decreaseCount : state = this . decreaseCount ( ) ; break ; case State . decreaseCountAtLinefeed : state = this . decreaseCountAtLinefeed ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . 0 : state = this . 0 ( ) ; break ; case State . deleteUntilJustBefore : whileContinue = false ; break ; } } return this . pos ; } } export function AddWordForwordMotion ( num , action ) { let a = < IRequireMotionAction > action ; if ( a . IsChange ) { let cm = new ChangeWordMotion ( ) ; cm . IsWORD = false ; cm . Count = num > 0 ? num : 0 ; a . Motion = cm ; } else { let dm = new DeleteWordMotion ( ) ; dm . Count = num > 0 ? num : 0 ; dm . IsWORD = false ; a . Motion = dm ; } } export function AddBlankSparatedMotion ( num , action ) { let a = < IRequireMotionAction > action ; if ( a . IsChange ) { let cm = new ChangeWordMotion ( ) ; cm . IsWORD = true ; cm . Count = num > 0 ? num : 0 ; a . Motion = cm ; } else { let dm = new DeleteWordMotion ( ) ; dm . Count = num > 0 ? num : 0 ; dm . IsWORD = true ; a . Motion = dm ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $number$ O $boolean$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CharGroup$ O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class DeleteEndOfWordMotion extends AbstractMotion { public IsWORD : boolean ; public IsMove : boolean ; constructor ( ) { super ( ) ; } ; public CalculateEnd ( editor , vim , start ) { let cal = new Calculater ( start , this . Count , this . IsWORD , this . IsMove , editor ) ; return cal . CalculateEnd ( ) ; } } enum State { first = 0 , firstCharacter , character , spaceOrLinefeed , decreaseCount , finalWord , stop , deleteUntilJustBefore , moveToPreviousCharacter , reachDocumentEnd , } enum NextCharacter { character , sameTypeCharacter , differenceTypeCharacter , lineFeed , space , } class Calculater { public pos : IPosition ; public line : string ; public documentLines : number ; public count : number ; public IsWORD : boolean ; public IsMove : boolean ; public beforeCharacterGroup : CharGroup ; public editor : IEditor ; constructor ( start , count , isWord , isMove , editor ) { this . pos = start . Copy ( ) ; this . pos . Char -- ; this . line = editor . ReadLine ( start . Line ) ; this . editor = editor ; this . documentLines = editor . GetLastLineNum ( ) ; this . count = count ; this . beforeCharacterGroup = null ; this . IsWORD = isWord ; this . IsMove = isMove ; } ; public getNextCharacter ( ) { this . pos . Char ++ ; if ( this . pos . Char > this . line . length ) { this . pos . Line ++ ; this . pos . Char = 0 ; this . line = this . editor . ReadLine ( this . pos . Line ) ; } if ( this . pos . Char === this . line . length ) { if ( this . pos . Line === this . documentLines ) { return null ; } this . beforeCharacterGroup = null ; return NextCharacter . lineFeed ; } let characterGroup = Utils . GetCharClass ( this . line . charCodeAt ( this . pos . Char ) ) ; let result ; if ( characterGroup === CharGroup . Spaces ) { this . beforeCharacterGroup = null ; return NextCharacter . space ; } if ( this . beforeCharacterGroup === null ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . character ; } if ( this . IsWORD ) { this . beforeCharacterGroup = characterGroup ; return NextCharacter . sameTypeCharacter ; } if ( this . beforeCharacterGroup === characterGroup ) { return NextCharacter . sameTypeCharacter ; } this . beforeCharacterGroup = characterGroup ; return NextCharacter . differenceTypeCharacter ; } public doAtFirst ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . firstCharacter ; case NextCharacter . lineFeed : case NextCharacter . space : return State . spaceOrLinefeed ; } } ; public doAtFirstCharacter ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . sameTypeCharacter : case NextCharacter . differenceTypeCharacter : return State . decreaseCount ; case NextCharacter . lineFeed : case NextCharacter . space : return State . spaceOrLinefeed ; } } public doAtCharacter ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . differenceTypeCharacter : return State . decreaseCount ; case NextCharacter . sameTypeCharacter : return State . character ; case NextCharacter . lineFeed : case NextCharacter . space : return State . spaceOrLinefeed ; } } public doAtSpaceOrLinefeed ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . character : return State . decreaseCount ; case NextCharacter . lineFeed : case NextCharacter . space : return State . spaceOrLinefeed ; } } public decreaseCount ( ) { this . count -- ; if ( this . count === 0 ) { return State . finalWord ; } return State . character ; } public doAtFinalWord ( ) { let nextCharacterGroup = this . getNextCharacter ( ) ; if ( nextCharacterGroup === null ) { return State . reachDocumentEnd ; } switch ( nextCharacterGroup ) { case NextCharacter . sameTypeCharacter : return State . finalWord ; case NextCharacter . differenceTypeCharacter : case NextCharacter . lineFeed : case NextCharacter . space : return State . stop ; } } public doAtStoppedPos ( ) { if ( this . IsMove ) { return State . moveToPreviousCharacter ; } return State . deleteUntilJustBefore ; } public moveToPreviousCharacter ( ) { if ( this . pos . Char > 0 ) { this . pos . Char -- ; } } public CalculateEnd ( ) { let state = State . first ; let whileContinue = true ; while ( whileContinue ) { switch ( state ) { case State . reachDocumentEnd : whileContinue = false ; break ; case State . first : state = this . doAtFirst ( ) ; break ; case State . firstCharacter : state = this . doAtFirstCharacter ( ) ; break ; case State . character : state = this . doAtCharacter ( ) ; break ; case State . spaceOrLinefeed : state = this . doAtSpaceOrLinefeed ( ) ; break ; case State . decreaseCount : state = this . decreaseCount ( ) ; break ; case State . finalWord : state = this . doAtFinalWord ( ) ; break ; case State . stop : state = this . doAtStoppedPos ( ) ; break ; case State . deleteUntilJustBefore : whileContinue = false ; break ; case State . moveToPreviousCharacter : this . moveToPreviousCharacter ( ) ; whileContinue = false ; break ; } } return this . pos ; } } export function GotoForwardToEndOfWold ( num ) { let a = new GoAction ( ) ; let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = false ; m . IsMove = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddEndOfWordMotion ( num , action ) { let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = false ; m . IsMove = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddMoveToForwardToEndOfWoldMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = false ; m . IsMove = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; } export function GotoForwardToEndOfBlankSeparated ( num ) { let a = new GoAction ( ) ; let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = true ; m . IsMove = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddEndOfBlankSeparatedMotion ( num , action ) { let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = true ; m . IsMove = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddMoveToForwardToEndOfBlankSeparatedMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m = new DeleteEndOfWordMotion ( ) ; m . IsWORD = true ; m . IsMove = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $number$ O $boolean$ O $boolean$ O $IEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CharGroup$ O O O O O O O O O O O O O O O O O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O $NextCharacter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class FindCharacterMotion extends AbstractMotion implements IRequireCharacterMotion { public CharacterCode : number ; public Direction : Direction ; public OppositeDirection : boolean ; public IsTill : boolean ; public IsContainTargetChar : boolean ; constructor ( direction ) { super ( ) ; this . Direction = direction ; this . OppositeDirection = false ; this . IsTill = false ; this . IsContainTargetChar = false ; this . CharacterCode = null ; } public SetChar ( c ) { this . CharacterCode = c . charCodeAt ( 0 ) ; } public CalculateEnd ( editor , vim , start ) { let line = editor . ReadLineAtCurrentPosition ( ) ; let end = new Position ( ) ; end . Line = start . Line ; let i ; let count = this . Count ; if ( this . CharacterCode === null ) { if ( vim . LastFindCharacterMotion === null ) { return null ; } let last ; last = vim . LastFindCharacterMotion ; if ( this . OppositeDirection ) { if ( last . Direction === Direction . Left ) { this . Direction = Direction . Right ; } else { this . Direction = Direction . Left ; } } else { this . Direction = last . Direction ; } this . IsTill = last . IsTill ; this . CharacterCode = last . CharacterCode ; } else { vim . LastFindCharacterMotion = this ; } if ( this . CharacterCode === null ) { return null ; } if ( this . Direction === Direction . Right ) { for ( i = start . Char + 0 ; i < line . length ; i ++ ) { if ( this . IsTill && i === start . Char + 0 ) { continue ; } if ( this . CharacterCode === line . charCodeAt ( i ) ) { count -- ; if ( count === 0 ) { end . Char = i ; break ; } } } } else { for ( i = start . Char - 0 ; i >= 0 ; i -- ) { if ( this . IsTill && i === start . Char - 0 ) { continue ; } if ( this . CharacterCode === line . charCodeAt ( i ) ) { count -- ; if ( count === 0 ) { end . Char = i ; break ; } } } } if ( count > 0 ) { return null ; } if ( this . IsTill ) { if ( this . Direction === Direction . Right ) { end . Char -= 0 ; } else { end . Char += 0 ; } } if ( this . IsContainTargetChar ) { end . Char += 0 ; } return end ; } } export function GotoCharacterToRight ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function GotoCharacterToLeft ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( Direction . Left ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function GoTillBeforeCharacterToRight ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . Count = num > 0 ? num : 0 ; m . IsTill = true ; a . Motion = m ; return a ; } export function GoTillBeforeCharacterToLeft ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( Direction . Left ) ; m . Count = num > 0 ? num : 0 ; m . IsTill = true ; a . Motion = m ; return a ; } export function AddCharacterToRightMotion ( num , action ) { let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . IsContainTargetChar = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddCharacterToLeftMotion ( num , action ) { let m ; m = new FindCharacterMotion ( Direction . Left ) ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddTillCharacterToRightMotion ( num , action ) { let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . IsContainTargetChar = true ; m . Count = num > 0 ? num : 0 ; m . IsTill = true ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddTillCharacterToLeftMotion ( num , action ) { let m ; m = new FindCharacterMotion ( Direction . Left ) ; m . Count = num > 0 ? num : 0 ; m . IsTill = true ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddVisualGotoCharacterToRightMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . IsContainTargetChar = false ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export let AddVisualGotoCharacterToLeftMotion : ( num , action ) => void = AddCharacterToLeftMotion ; export function AddVisualGoTillCharacterToRightMotion ( num , action ) { let a = < IRequireMotionAction > action ; let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . Count = num > 0 ? num : 0 ; m . IsContainTargetChar = false ; m . IsTill = true ; a . Motion = m ; return a ; } export let AddVisualGoTillCharacterToLeftMotion : ( num , action ) => void = AddTillCharacterToLeftMotion ; export function GotoRepeatCharacter ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( Direction . Right ) ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddRepeartCharacterMotion ( num , action ) { let m ; m = new FindCharacterMotion ( null ) ; m . IsContainTargetChar = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function AddVisualGotoRepeartCharacterMotion ( num , action ) { let m ; m = new FindCharacterMotion ( null ) ; m . IsContainTargetChar = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function GotoRepeatCharacterOppositeDirection ( num ) { let a = new GoAction ( ) ; let m ; m = new FindCharacterMotion ( null ) ; m . OppositeDirection = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddRepeartCharacterMotionOppositeDirection ( num , action ) { let m ; m = new FindCharacterMotion ( null ) ; m . OppositeDirection = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export let AddVisualGotoRepeartCharacterMotionOppositeDirection = AddRepeartCharacterMotionOppositeDirection ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Direction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O $IAction$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O $IAction$ O $number$ O $IAction$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $FindCharacterMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; class FirstCharacterInLineMotion extends AbstractMotion { public CalculateEnd ( editor , vim , start ) { let end = new Position ( ) ; end . Line = start . Line ; end . Char = 0 ; return editor . UpdateValidPosition ( end ) ; } } export function GotoFirstCharacterInLine ( num ) { let a = new GoAction ( ) ; a . Motion = new FirstCharacterInLineMotion ( ) ; return a ; } export function AddFirstCharacterInLineMotion ( num , action ) { let a = < IRequireMotionAction > action ; a . Motion = new FirstCharacterInLineMotion ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O
import { GoAction } from "s" ; import * as Utils from "s" ; import { Position } from "s" ; import { AbstractMotion } from "s" ; export class ParagraphMotion extends AbstractMotion { public IsUpDirection : boolean ; constructor ( ) { super ( ) ; this . IsUpDirection = false ; } public CalculateEnd ( editor , vim , start ) { let tabSize = editor . GetTabSize ( ) ; let line = start . Line ; let lineText = editor . ReadLine ( start . Line ) ; let previousLineIsBlank = lineText . length === 0 ; let lastLine = editor . GetLastLineNum ( ) ; let count = this . Count ; while ( count > 0 ) { if ( this . IsUpDirection ) { line -- ; if ( line === 0 ) { break ; } } else { line ++ ; if ( line > lastLine ) { return editor . GetLastPosition ( ) ; } } lineText = editor . ReadLine ( line ) ; if ( lineText . length === 0 && ! previousLineIsBlank ) { count -- ; previousLineIsBlank = true ; } else if ( lineText . length > 0 ) { previousLineIsBlank = false ; } } let end = new Position ( line , 0 ) ; return editor . UpdateValidPosition ( end ) ; } } export function GotoParagraphBackword ( num ) { let a = new GoAction ( ) ; let m = new ParagraphMotion ( ) ; m . IsUpDirection = true ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddParagraphBackwordMotion ( num , action ) { let m = new ParagraphMotion ( ) ; m . IsUpDirection = true ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; } export function GotoParagraphFoword ( num ) { let a = new GoAction ( ) ; let m = new ParagraphMotion ( ) ; m . IsUpDirection = false ; m . Count = num > 0 ? num : 0 ; a . Motion = m ; return a ; } export function AddParagraphFowordMotion ( num , action ) { let m = new ParagraphMotion ( ) ; m . IsUpDirection = false ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Motion = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $ParagraphMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $ParagraphMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IAction$ O $number$ O O O O O O O O O O O $ParagraphMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O $ParagraphMotion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class AbstractTextObjectSelection implements ISelectionMotion { public Count : number ; public CalculateRange ( editor , vim , start ) { throw new Error ( "s" ) ; } }	O O O O O O O O O O O O O $IRange$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O
import * as Utils from "s" ; import { Range } from "s" ; import { AbstractTextObjectSelection } from "s" ; const INNER = 0 ; const OUTER = 0 ; export class BrancketSelection extends AbstractTextObjectSelection { public LeftBrancket : string ; public RightBrancket : string ; public InnerOuter : number ; constructor ( ) { super ( ) ; } public CalculateRange ( editor , vim , start ) { let left = this . SearchLeftBrancket ( editor , vim , start ) ; let right = this . SearchRightBrancket ( editor , vim , start ) ; if ( left == null || right == null ) { return null ; } if ( this . InnerOuter === INNER ) { left . Char ++ ; } else { right . Char ++ ; } let result = new Range ( ) ; result . start = left ; result . end = right ; return result ; } public SearchRightBrancket ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; let count = this . Count ; while ( count > 0 ) { p . Char ++ ; if ( p . Char >= line . length ) { p . Line ++ ; if ( p . Line > lastLine ) { return null ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = 0 ; } let c = line [ p . Char ] ; if ( c === this . LeftBrancket ) { count ++ ; } if ( c === this . RightBrancket ) { count -- ; } if ( count === 0 ) { break ; } } return p ; } private SearchLeftBrancket ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; let count = this . Count ; while ( this . Count > 0 ) { p . Char -- ; if ( p . Char < 0 ) { p . Line -- ; if ( p . Line < 0 ) { return null ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = line . length - 0 ; } let c = line [ p . Char ] ; if ( c === this . LeftBrancket ) { count -- ; } if ( c === this . RightBrancket ) { count ++ ; } if ( count === 0 ) { break ; } } return p ; } } export function AddInnerUnclosedParenthesisSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterUnclosedParenthesisSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddInnerLessThanSignSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterLessThanSignSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddInnerSquareBlancketSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterSquareBlancketSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddInnerCurlyBrancketSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterCurlyBrancketSelection ( num , action ) { let m = new BrancketSelection ( ) ; m . LeftBrancket = "s" ; m . RightBrancket = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Range } from "s" ; import { AbstractTextObjectSelection } from "s" ; const INNER = 0 ; const OUTER = 0 ; export class QuotationSelection extends AbstractTextObjectSelection { public Quote : string ; public InnerOuter : number ; constructor ( ) { super ( ) ; } public CalculateRange ( editor , vim , start ) { let left = this . SearchLeftQuote ( editor , vim , start ) ; let right = this . SearchRightQuote ( editor , vim , start ) ; if ( left == null || right == null ) { return null ; } if ( this . InnerOuter === INNER ) { left . Char ++ ; } let result = new Range ( ) ; result . start = left ; result . end = right ; return result ; } public SearchRightQuote ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; while ( true ) { p . Char ++ ; if ( p . Char >= line . length ) { p . Line ++ ; if ( p . Line > lastLine ) { return null ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = 0 ; } let c = line [ p . Char ] ; if ( c === this . Quote ) { break ; } } if ( this . InnerOuter === OUTER ) { while ( true ) { p . Char ++ ; if ( p . Char >= line . length ) { p . Char = line . length ; break ; } if ( Utils . GetCharClass ( line . charCodeAt ( p . Char ) ) !== CharGroup . Spaces ) { break ; } } } return p ; } private SearchLeftQuote ( editor , vim , start ) { let p = start . Copy ( ) ; let line = editor . ReadLineAtCurrentPosition ( ) ; let lastLine = editor . GetLastLineNum ( ) ; while ( true ) { p . Char -- ; if ( p . Char < 0 ) { p . Line -- ; if ( p . Line < 0 ) { return null ; } line = editor . ReadLine ( p . Line ) ; if ( line . length === 0 ) { continue ; } p . Char = line . length - 0 ; } let c = line [ p . Char ] ; if ( c === this . Quote ) { break ; } } return p ; } } export function AddInnerApostropheSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterApostropheSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddInnerQuotationSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterQuotationSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddInnerGraveAccentSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = INNER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; } export function AddOuterGraveAccentSelection ( num , action ) { let m = new QuotationSelection ( ) ; m . Quote = "s" ; m . InnerOuter = OUTER ; m . Count = num > 0 ? num : 0 ; let a = < IRequireMotionAction > action ; a . Selection = m ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IEditor$ O $IVimStyle$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $IAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as DeleteYankChangeAction from "s" ; import * as DeleteYankChangeHighlightedLineAction from "s" ; import * as DeleteYankChangeHighlightedTextAction from "s" ; import * as InsertTextAction from "s" ; import * as JoinHighlightedLinesAction from "s" ; import * as JoinLinesAction from "s" ; import * as OpenNewLineAndAppendTextAction from "s" ; import * as PutRegisterAction from "s" ; import * as RepeatLastChangeAction from "s" ; import * as ReplaceCharacterAction from "s" ; import * as ReplaceCharacterOfSelecetdTextAction from "s" ; import * as StartVisualLineModeAction from "s" ; import * as StartVisualModeAction from "s" ; import * as BrancketMotion from "s" ; import * as ChangeWordMotion from "s" ; import * as DeleteEndOfWordMotion from "s" ; import * as DownMotion from "s" ; import * as FindCharacterMotion from "s" ; import * as FirstCharacterInLineMotion from "s" ; import * as FirstCharacterMotion from "s" ; import * as LastCharacterInLineMotion from "s" ; import * as MoveWordMotion from "s" ; import * as ParagraphMotion from "s" ; import * as RightMotion from "s" ; import * as TextObjectSelectionBrancket from "s" ; import * as TextObjectQuotation from "s" ; import * as WordMotion from "s" ; class KeyBindings implements IKeyBindings { public AtStart : { [ key ] : IVimStyleCommand } ; public FirstNum : { [ key ] : IVimStyleCommand } ; public RequireMotion : { [ key ] : IVimStyleCommand } ; public RequireMotionNum : { [ key ] : IVimStyleCommand } ; public RequireBrancketForLeftBrancket : { [ key ] : IVimStyleCommand } ; public RequireBrancketForRightBrancket : { [ key ] : IVimStyleCommand } ; public RequireBrancketForLeftBrancketMotion : { [ key ] : IVimStyleCommand } ; public RequireBrancketForRightBrancketMotion : { [ key ] : IVimStyleCommand } ; public RequireInnerTextObject : { [ key ] : IVimStyleCommand } ; public RequireOuterTextObject : { [ key ] : IVimStyleCommand } ; public SmallG : { [ key ] : IVimStyleCommand } ; public SmallGForMotion : { [ key ] : IVimStyleCommand } ; public VisualMode : { [ key ] : IVimStyleCommand } ; public VisualLineMode : { [ key ] : IVimStyleCommand } ; } function applyKeyBindingsByEachState ( dest : { [ key ] : IVimStyleCommand } , src : { [ key ] : IVimStyleCommand } ) { let key ; for ( key in src ) { dest [ key ] = src [ key ] ; } } export function ApplyKeyBindings ( dest , src ) { if ( dest . AtStart ) { applyKeyBindingsByEachState ( dest . AtStart , src . AtStart ) ; } if ( dest . FirstNum ) { applyKeyBindingsByEachState ( dest . FirstNum , src . AtStart ) ; applyKeyBindingsByEachState ( dest . FirstNum , src . FirstNum ) ; } if ( dest . RequireMotion ) { applyKeyBindingsByEachState ( dest . RequireMotion , src . RequireMotion ) ; } if ( dest . RequireMotionNum ) { applyKeyBindingsByEachState ( dest . RequireMotionNum , src . RequireMotion ) ; applyKeyBindingsByEachState ( dest . RequireMotionNum , src . RequireMotionNum ) ; } if ( dest . RequireBrancketForLeftBrancket ) { applyKeyBindingsByEachState ( dest . RequireBrancketForLeftBrancket , src . RequireBrancketForLeftBrancket ) ; } if ( dest . RequireBrancketForRightBrancket ) { applyKeyBindingsByEachState ( dest . RequireBrancketForRightBrancket , src . RequireBrancketForRightBrancket ) ; } if ( dest . RequireBrancketForLeftBrancketMotion ) { applyKeyBindingsByEachState ( dest . RequireBrancketForLeftBrancketMotion , src . RequireBrancketForLeftBrancketMotion ) ; } if ( dest . RequireBrancketForRightBrancketMotion ) { applyKeyBindingsByEachState ( dest . RequireBrancketForRightBrancketMotion , src . RequireBrancketForRightBrancketMotion ) ; } if ( dest . RequireInnerTextObject ) { applyKeyBindingsByEachState ( dest . RequireInnerTextObject , src . RequireInnerTextObject ) ; } if ( dest . RequireOuterTextObject ) { applyKeyBindingsByEachState ( dest . RequireOuterTextObject , src . RequireOuterTextObject ) ; } if ( dest . SmallG ) { applyKeyBindingsByEachState ( dest . SmallG , src . SmallG ) ; } if ( dest . SmallGForMotion ) { applyKeyBindingsByEachState ( dest . SmallGForMotion , src . SmallGForMotion ) ; } if ( dest . VisualMode ) { applyKeyBindingsByEachState ( dest . VisualMode , src . VisualMode ) ; } if ( dest . VisualModeNum ) { applyKeyBindingsByEachState ( dest . VisualModeNum , src . VisualMode ) ; applyKeyBindingsByEachState ( dest . VisualModeNum , src . VisualModeNum ) ; } if ( dest . VisualLineMode ) { applyKeyBindingsByEachState ( dest . VisualLineMode , src . VisualLineMode ) ; } } const DefaultKeyBindings = { AtStart : { "s" : { CreateAction : InsertTextAction . AppendTextAfterCursor , } , "s" : { CreateAction : InsertTextAction . AppendTextAtEndOfLine , } , "s" : { CreateAction : WordMotion . GotoWordBackword , } , "s" : { CreateAction : WordMotion . GotoBlankSeparatedBackwordWord , } , "s" : { CreateAction : DeleteYankChangeAction . ChangeTextWithMotion , state : StateName . RequireMotion , } , "s" : { CreateAction : DeleteYankChangeAction . ChangeTextToEndOfLine , } , "s" : { CreateAction : DeleteYankChangeAction . DeleteTextWithMotion , state : StateName . RequireMotion , } , "s" : { CreateAction : DeleteYankChangeAction . DeleteTextToEndOfLine , } , "s" : { CreateAction : DeleteEndOfWordMotion . GotoForwardToEndOfWold , } , "s" : { CreateAction : DeleteEndOfWordMotion . GotoForwardToEndOfBlankSeparated , } , "s" : { CreateAction : FindCharacterMotion . GotoCharacterToRight , state : StateName . RequireCharForMotion , } , "s" : { CreateAction : FindCharacterMotion . GotoCharacterToLeft , state : StateName . RequireCharForMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . SmallG , } , "s" : { CreateAction : FirstCharacterMotion . GotoLastLine , } , "s" : { CreateAction : RightMotion . GotoLeft , } , "s" : { CreateAction : InsertTextAction . InsertTextBeforeCursor , } , "s" : { CreateAction : InsertTextAction . InsertTextBeforeFirstNonBlankInLine , } , "s" : { CreateAction : DownMotion . GoDown , } , "s" : { CreateAction : JoinLinesAction . JoinLines , } , "s" : { CreateAction : DownMotion . GoUp , } , "s" : { CreateAction : RightMotion . GotoRight , } , "s" : { CreateAction : OpenNewLineAndAppendTextAction . OpenNewLineBelowCurrentLineAndAppendText , } , "s" : { CreateAction : OpenNewLineAndAppendTextAction . OpenNewLineAboveCurrentLineAndAppendText , } , "s" : { CreateAction : PutRegisterAction . PutRegisterAfterCursorPosition , } , "s" : { CreateAction : PutRegisterAction . PutRegisterBeforeCursorPosition , } , "s" : { CreateAction : ReplaceCharacterAction . ReplaceCharacter , state : StateName . RequireCharForAction , } , "s" : { CreateAction : DeleteYankChangeAction . ChangeCharacters , } , "s" : { CreateAction : DeleteYankChangeAction . ChangeLines , } , "s" : { CreateAction : FindCharacterMotion . GoTillBeforeCharacterToRight , state : StateName . RequireCharForMotion , } , "s" : { CreateAction : FindCharacterMotion . GoTillBeforeCharacterToLeft , state : StateName . RequireCharForMotion , } , "s" : { CreateAction : StartVisualModeAction . StartVisualMode , } , "s" : { CreateAction : StartVisualLineModeAction . StartVisualLineMode , } , "s" : { CreateAction : MoveWordMotion . GotoWordFoword , } , "s" : { CreateAction : MoveWordMotion . GotoBlankSeparated , } , "s" : { CreateAction : DeleteYankChangeAction . DeleteCharactersUnderCursor , } , "s" : { CreateAction : DeleteYankChangeAction . DeleteCharactersBeforeCursor , } , "s" : { CreateAction : DeleteYankChangeAction . YankTextWithMotion , state : StateName . RequireMotion , } , "s" : { CreateAction : DeleteYankChangeAction . YankLine , } , "s" : { CreateAction : FirstCharacterInLineMotion . GotoFirstCharacterInLine , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , "s" : { CreateAction : LastCharacterInLineMotion . GotoLastCharacterInLine , } , "s" : { CreateAction : RepeatLastChangeAction . RepeatLastChange , } , "s" : { CreateAction : FindCharacterMotion . GotoRepeatCharacterOppositeDirection , } , "s" : { CreateAction : FindCharacterMotion . GotoRepeatCharacter , } , "s" : { CreateAction : FirstCharacterMotion . GotoFirstNonBlankCharacterInLine , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForLeftBrancket , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForRightBrancket , } , "s" : { CreateAction : ParagraphMotion . GotoParagraphBackword , } , "s" : { CreateAction : ParagraphMotion . GotoParagraphFoword , } , "s" : { CreateAction : DownMotion . GoUp , } , "s" : { CreateAction : DownMotion . GoDown , } , "s" : { CreateAction : RightMotion . GotoLeft , } , "s" : { CreateAction : RightMotion . GotoRight , } , } , FirstNum : { 0 : { cmd : VimCommand . stackNumber , state : StateName . FirstNum , } , } , RequireMotion : { "s" : { state : StateName . RequireOuterTextObject , } , "s" : { AddMotion : WordMotion . AddWordBackwardMotion , } , "s" : { AddMotion : WordMotion . AddBlankSeparatedBackwordMotion , } , "s" : { CreateAction : DeleteYankChangeAction . ChangeCurrentLine , } , "s" : { CreateAction : DeleteYankChangeAction . DeleteCurrentLine , } , "s" : { AddMotion : DeleteEndOfWordMotion . AddEndOfWordMotion , } , "s" : { AddMotion : DeleteEndOfWordMotion . AddEndOfBlankSeparatedMotion , } , "s" : { AddMotion : FindCharacterMotion . AddCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . SmallGForMotion , } , "s" : { AddMotion : FirstCharacterMotion . AddLastLineMotion , } , "s" : { AddMotion : RightMotion . AddLeftMotion , } , "s" : { state : StateName . RequireInnerTextObject , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : RightMotion . AddRightMotion , } , "s" : { AddMotion : FindCharacterMotion . AddTillCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddTillCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : ChangeWordMotion . AddWordForwordMotion , } , "s" : { AddMotion : ChangeWordMotion . AddBlankSparatedMotion , } , "s" : { CreateAction : DeleteYankChangeAction . YankCurrentLine , } , "s" : { AddMotion : FirstCharacterInLineMotion . AddFirstCharacterInLineMotion , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { AddMotion : LastCharacterInLineMotion . AddLastCharacterInLineMotion , } , "s" : { AddMotion : FindCharacterMotion . AddRepeartCharacterMotionOppositeDirection , } , "s" : { AddMotion : FindCharacterMotion . AddRepeartCharacterMotion , } , "s" : { AddMotion : FirstCharacterMotion . AddFirstNonBlankCharacterInLineMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphBackwordMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphFowordMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForLeftBrancketMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForRightBrancketMotion , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { AddMotion : RightMotion . AddLeftMotion , } , "s" : { AddMotion : RightMotion . AddRightMotion , } , } , RequireMotionNum : { 0 : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , } , RequireBrancketForLeftBrancket : { "s" : { CreateAction : BrancketMotion . GoBackToUnclosedLeftParenthesis , } , "s" : { CreateAction : BrancketMotion . GoBackToUnclosedLeftCurlyBracket , } , } , RequireBrancketForLeftBrancketMotion : { "s" : { AddMotion : BrancketMotion . AddBackToUnclosedLeftParenthesisMotion , } , "s" : { AddMotion : BrancketMotion . AddBackToUnclosedLeftCurlyBracketMotion , } , } , RequireBrancketForRightBrancket : { "s" : { CreateAction : BrancketMotion . GoToUnclosedRightParenthesis , } , "s" : { CreateAction : BrancketMotion . GoToUnclosedRightCurlyBracket , } , } , RequireBrancketForRightBrancketMotion : { "s" : { AddMotion : BrancketMotion . AddToUnclosedRightParenthesisMotion , } , "s" : { AddMotion : BrancketMotion . AddToUnclosedRightCurlyBracketMotion , } , } , RequireInnerTextObject : { "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerUnclosedParenthesisSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerUnclosedParenthesisSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerLessThanSignSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerLessThanSignSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerSquareBlancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerSquareBlancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerCurlyBrancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddInnerCurlyBrancketSelection , } , "s" : { AddMotion : TextObjectQuotation . AddInnerApostropheSelection , } , "s" : { AddMotion : TextObjectQuotation . AddInnerQuotationSelection , } , "s" : { AddMotion : TextObjectQuotation . AddInnerGraveAccentSelection , } , } , RequireOuterTextObject : { "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterUnclosedParenthesisSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterUnclosedParenthesisSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterLessThanSignSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterLessThanSignSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterSquareBlancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterSquareBlancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterCurlyBrancketSelection , } , "s" : { AddMotion : TextObjectSelectionBrancket . AddOuterCurlyBrancketSelection , } , "s" : { AddMotion : TextObjectQuotation . AddOuterApostropheSelection , } , "s" : { AddMotion : TextObjectQuotation . AddOuterQuotationSelection , } , "s" : { AddMotion : TextObjectQuotation . AddOuterGraveAccentSelection , } , } , SmallG : { g : { CreateAction : FirstCharacterMotion . GotoFirstLineOnFirstNonBlankCharacter , } , r : { CreateAction : ReplaceCharacterAction . ReplaceCharacterWithoutAffectingLayout , state : StateName . RequireCharForAction , } , } , SmallGForMotion : { g : { AddMotion : FirstCharacterMotion . AddLastLineMotion , } , } , VisualMode : { "s" : { AddMotion : WordMotion . AddWordBackwardMotion , } , "s" : { AddMotion : WordMotion . AddBlankSeparatedBackwordMotion , } , "s" : { CreateAction : DeleteYankChangeHighlightedTextAction . ChangeHighlightedText , } , "s" : { CreateAction : DeleteYankChangeHighlightedTextAction . DeleteHighlightedText , } , "s" : { AddMotion : DeleteEndOfWordMotion . AddMoveToForwardToEndOfWoldMotion , } , "s" : { AddMotion : DeleteEndOfWordMotion . AddMoveToForwardToEndOfBlankSeparatedMotion , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGotoCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGotoCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . SmallGForMotion , } , "s" : { AddMotion : FirstCharacterMotion . AddLastLineMotion , } , "s" : { AddMotion : RightMotion . AddLeftMotion , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { CreateAction : JoinHighlightedLinesAction . JoinHighlightedText , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : RightMotion . AddRightMotion , } , "s" : { CreateAction : ReplaceCharacterOfSelecetdTextAction . ReplaceCharacterOfSelectedText , state : StateName . RequireCharForAction , } , "s" : { CreateAction : DeleteYankChangeHighlightedTextAction . ChangeHighlightedText , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGoTillCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGoTillCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : MoveWordMotion . AddToWordFowordMotion , } , "s" : { AddMotion : MoveWordMotion . AddToBlankSeparatedMotion , } , "s" : { CreateAction : DeleteYankChangeHighlightedTextAction . DeleteHighlightedText , } , "s" : { CreateAction : DeleteYankChangeHighlightedTextAction . YankHighlightedText , } , "s" : { AddMotion : FirstCharacterInLineMotion . AddFirstCharacterInLineMotion , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , "s" : { AddMotion : LastCharacterInLineMotion . AddLastCharacterInLineMotion , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGotoRepeartCharacterMotionOppositeDirection , } , "s" : { AddMotion : FindCharacterMotion . AddVisualGotoRepeartCharacterMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphBackwordMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphFowordMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForLeftBrancketMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForRightBrancketMotion , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { AddMotion : RightMotion . AddLeftMotion , } , "s" : { AddMotion : RightMotion . AddRightMotion , } , } , VisualModeNum : { 0 : { cmd : VimCommand . stackNumber , state : StateName . VisualModeNum , } , } , VisualLineMode : { "s" : { AddMotion : WordMotion . AddWordBackwardMotion , } , "s" : { AddMotion : WordMotion . AddBlankSeparatedBackwordMotion , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . ChangeHighligtedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . ChangeHighligtedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . DeleteHighlightedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . DeleteHighlightedLine , } , "s" : { AddMotion : FindCharacterMotion . AddCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . SmallGForMotion , } , "s" : { AddMotion : FirstCharacterMotion . AddLastLineMotion , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { CreateAction : JoinHighlightedLinesAction . JoinHighlightedLines , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : FindCharacterMotion . AddCharacterToRightMotion , state : StateName . RequireCharForMotion , } , "s" : { AddMotion : FindCharacterMotion . AddTillCharacterToLeftMotion , state : StateName . RequireCharForMotion , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . DeleteHighlightedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . DeleteHighlightedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . YankHighlightedLine , } , "s" : { CreateAction : DeleteYankChangeHighlightedLineAction . YankHighlightedLine , } , "s" : { AddMotion : FirstCharacterInLineMotion . AddFirstCharacterInLineMotion , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { cmd : VimCommand . stackNumber , state : StateName . RequireMotionNum , } , "s" : { AddMotion : LastCharacterInLineMotion . AddLastCharacterInLineMotion , } , "s" : { AddMotion : FindCharacterMotion . AddRepeartCharacterMotionOppositeDirection , } , "s" : { AddMotion : FindCharacterMotion . AddRepeartCharacterMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphBackwordMotion , } , "s" : { AddMotion : ParagraphMotion . AddParagraphFowordMotion , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForLeftBrancket , } , "s" : { cmd : VimCommand . nothing , state : StateName . RequireBrancketForRightBrancket , } , "s" : { AddMotion : DownMotion . AddUpMotion , } , "s" : { AddMotion : DownMotion . AddDownMotion , } , "s" : { AddMotion : RightMotion . AddLeftMotion , } , "s" : { AddMotion : RightMotion . AddRightMotion , } , } , } ; const ErgonomicKeyBindings = { AtStart : { "s" : DefaultKeyBindings . AtStart . h , "s" : DefaultKeyBindings . AtStart . j , "s" : DefaultKeyBindings . AtStart . k , "s" : DefaultKeyBindings . AtStart . l , } , RequireMotion : { "s" : DefaultKeyBindings . RequireMotion . h , "s" : DefaultKeyBindings . RequireMotion . j , "s" : DefaultKeyBindings . RequireMotion . k , "s" : DefaultKeyBindings . RequireMotion . l , } , VisualMode : { "s" : DefaultKeyBindings . VisualMode . h , "s" : DefaultKeyBindings . VisualMode . j , "s" : DefaultKeyBindings . VisualMode . k , "s" : DefaultKeyBindings . VisualMode . l , } , VisualModeNum : { "s" : DefaultKeyBindings . VisualMode . h , "s" : DefaultKeyBindings . VisualMode . j , "s" : DefaultKeyBindings . VisualMode . k , "s" : DefaultKeyBindings . VisualMode . l , } , VisualLineMode : { "s" : DefaultKeyBindings . VisualMode . h , "s" : DefaultKeyBindings . VisualMode . j , "s" : DefaultKeyBindings . VisualMode . k , "s" : DefaultKeyBindings . VisualMode . l , } , } ; export function LoadKeyBindings ( opts ) { let bindings = { AtStart : { } , FirstNum : { } , RequireMotion : { } , RequireMotionNum : { } , RequireBrancketForLeftBrancket : { } , RequireBrancketForLeftBrancketMotion : { } , RequireBrancketForRightBrancket : { } , RequireBrancketForRightBrancketMotion : { } , RequireInnerTextObject : { } , RequireOuterTextObject : { } , SmallG : { } , SmallGForMotion : { } , VisualMode : { } , VisualModeNum : { } , VisualLineMode : { } , } ; let key ; ApplyKeyBindings ( bindings , DefaultKeyBindings ) ; if ( opts . useErgonomicKeyForMotion ) { ApplyKeyBindings ( bindings , ErgonomicKeyBindings ) ; } if ( opts . editorKeyBindings ) { ApplyKeyBindings ( bindings , opts . editorKeyBindings ) ; } return bindings ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $IKeyBindings$ O $IKeyBindings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IKeyBindings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IKeyBindings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IKeyBindings$ O $IVimStyleOptions$ O O O $IKeyBindings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function InsertModeExecute ( key , editor ) { editor . TypeDirect ( key ) ; }	O O O O $string$ O $IEditor$ O O O O O O O O O O
import { InsertTextAction } from "s" ; import { CommandFactory } from "s" ; import { ExecExCommand } from "s" ; import { ApplyKeyBindings , LoadKeyBindings } from "s" ; import { Register } from "s" ; import { InsertModeExecute } from "s" ; import { FindCharacterMotion } from "s" ; import * as Utils from "s" ; export class VimStyle implements IVimStyle { public CommandFactory : ICommandFactory ; public Options : IVimStyleOptions ; public Register : IRegister ; public LastAction : IAction ; public LastEditAction : IAction ; public LastMoveCharPosition : number ; public LastFindCharacterMotion : FindCharacterMotion ; private mode : VimMode ; private editor : IEditor ; constructor ( editor , conf ) { this . editor = editor ; editor . SetVimStyle ( this ) ; this . setMode ( VimMode . Normal ) ; this . CommandFactory = new CommandFactory ( ) ; this . Register = new Register ( ) ; this . LastAction = null ; this . LastEditAction = null ; this . LastMoveCharPosition = null ; this . ApplyOptions ( conf ) ; this . ExecuteVimrc ( conf ) ; } public PushKey ( key ) { switch ( this . mode ) { case VimMode . Normal : case VimMode . Visual : case VimMode . VisualLine : this . readCommand ( key ) ; return ; case VimMode . Insert : InsertModeExecute ( key , this . editor ) ; } } public PushEscKey ( ) { if ( this . mode === VimMode . Insert ) { this . setInsertText ( ) ; } let p = this . editor . GetCurrentPosition ( ) ; if ( p != null ) { if ( this . mode === VimMode . Insert && p . Char > 0 ) { p . Char -= 0 ; } if ( this . mode === VimMode . Visual && p . Char > 0 ) { p . Char -= 0 ; } } this . setMode ( VimMode . Normal ) ; this . CommandFactory . Clear ( ) ; this . editor . CloseCommandStatus ( ) ; this . editor . ApplyNormalMode ( p ) ; } public ApplyInsertMode ( p ? ) { this . setMode ( VimMode . Insert ) ; this . editor . ApplyInsertMode ( p ) ; } public ApplyVisualMode ( ) { this . setMode ( VimMode . Visual ) ; } public ApplyVisualLineMode ( ) { this . setMode ( VimMode . VisualLine ) ; } public GetMode ( ) { return this . mode ; } public ApplyNormalMode ( ) { this . setMode ( VimMode . Normal ) ; } public ApplyOptions ( conf ) { this . Options = conf ; this . LoadKeyBinding ( ) ; } public ExecuteVimrc ( conf ) { if ( conf . vimrc == null || conf . vimrc . length === 0 ) { return ; } for ( let line of conf . vimrc ) { ExecExCommand ( line , this , this . editor ) ; } } public SetAdditionalKeyBinds ( keyBindings ) { ApplyKeyBindings ( this . CommandFactory . KeyBindings , keyBindings ) ; } private readCommand ( key ) { let actionList = this . CommandFactory . PushKey ( key , this . mode , true ) ; if ( actionList . length === 0 ) { this . showCommand ( ) ; return ; } this . editor . CloseCommandStatus ( ) ; for ( let action of actionList ) { action . Execute ( this . editor , this ) ; let type = action . GetActionType ( ) ; switch ( type ) { case ActionType . Edit : case ActionType . Insert : this . LastEditAction = action ; break ; } this . LastAction = action ; } this . CommandFactory . Clear ( ) ; } private showCommand ( ) { this . editor . ShowCommandStatus ( this . CommandFactory . GetCommandString ( ) ) ; } private setMode ( mode ) { this . mode = mode ; this . editor . ShowModeStatus ( this . mode ) ; } private LoadKeyBinding ( ) { this . CommandFactory . KeyBindings = LoadKeyBindings ( this . Options ) ; } private setInsertText ( ) { if ( this . LastAction . GetActionType ( ) !== ActionType . Insert ) { return ; } let action = this . LastAction as IInsertTextAction ; let info = action . GetInsertModeInfo ( ) ; if ( ! info ) { this . LastAction = null ; return ; } let lineCount = this . editor . GetLastLineNum ( ) + 0 ; if ( info . DocumentLineCount > lineCount ) { return ; } let cp = this . editor . GetCurrentPosition ( ) ; if ( cp . Line < info . Position . Line ) { return ; } let startLine = this . editor . ReadLine ( info . Position . Line ) ; let endLine = this . editor . ReadLine ( cp . Line ) ; if ( startLine . substring ( 0 , info . Position . Char ) !== info . BeforeText ) { return ; } if ( endLine . substring ( cp . Char ) !== info . AfterText ) { return ; } let range = new Range ( ) ; range . start = info . Position ; range . end = cp ; action . SetInsertText ( this . editor . ReadRange ( range ) ) ; } } export class Position implements IPosition { public Line : number ; public Char : number ; constructor ( line ? , char ? ) { this . Line = line === undefined ? 0 : line ; this . Char = char === undefined ? 0 : char ; } public Copy ( ) { return new Position ( this . Line , this . Char ) ; } public IsEqual ( other ) { return other . Line === this . Line && other . Char === this . Char ; } public IsBefore ( other ) { if ( this . Line === other . Line ) { return this . Char < other . Char ; } return this . Line < other . Line ; } public IsBeforeOrEqual ( other ) { if ( this . Line === other . Line ) { return this . Char <= other . Char ; } return this . Line < other . Line ; } public IsAfter ( other ) { if ( this . Line === other . Line ) { return this . Char > other . Char ; } return this . Line > other . Line ; } public IsAfterOrEqual ( other ) { if ( this . Line === other . Line ) { return this . Char >= other . Char ; } return this . Line > other . Line ; } } export class Range implements IRange { public start : IPosition ; public end : IPosition ; constructor ( ) { this . start = new Position ( ) ; this . end = new Position ( ) ; } public Sort ( ) { let isReverse = false ; if ( this . end . Line < this . start . Line ) { isReverse = true ; } else if ( this . end . Line === this . start . Line ) { if ( this . end . Char < this . start . Char ) { isReverse = true ; } } if ( isReverse ) { let b = this . start ; this . start = this . end ; this . end = b ; } } public IsContain ( p ) { let r = this . Copy ( ) ; r . Sort ( ) ; if ( p . Line < r . start . Line ) { return false ; } if ( r . end . Line < p . Line ) { return false ; } if ( p . Line === r . start . Line && p . Char < r . start . Char ) { return false ; } if ( p . Line === r . end . Line && r . end . Char < p . Char ) { return false ; } return true ; } public Copy ( ) { let r = new Range ( ) ; r . start . Char = this . start . Char ; r . start . Line = this . start . Line ; r . end . Char = this . end . Char ; r . end . Line = this . end . Line ; return r ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IEditor$ O $IVimStyleOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VimMode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVimStyleOptions$ O O O O O O O O O O O O O O O O O O $IVimStyleOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IKeyBindings$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VimMode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from "s" ; import * as Utils from "s" ; import { Position , Range } from "s" ; enum EditorActionType { Insert , Replace , Delete , SetPosition , } class EditorAction { public Type : EditorActionType ; public Position : IPosition ; public Range : IRange ; public Text : string ; } export interface IVSCodeEditorOptions { showMode : boolean ; changeCursorStyle : boolean ; defaultMode : string ; imapEsc : string ; } export class VSCodeEditor implements IEditor { public Options : IVSCodeEditorOptions ; private modeStatusBarItem : vscode . StatusBarItem ; private commandStatusBarItem : vscode . StatusBarItem ; private vimStyle : IVimStyle ; private visualLineModeStartLine : number ; private visualLineModeEndLine : number ; private visualLineModeFocusPosition : IPosition ; private inNormalModeContext : ContextKey ; private inInsertModeContext : ContextKey ; private inVisualModeContext : ContextKey ; private latestPosition : IPosition ; private latestPositionTimestamp : number ; private changeSelectionByVimStyle : boolean ; public constructor ( options ) { this . modeStatusBarItem = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left ) ; this . commandStatusBarItem = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left ) ; this . commandStatusBarItem . show ( ) ; this . ApplyOptions ( options ) ; this . inNormalModeContext = new ContextKey ( "s" ) ; this . inInsertModeContext = new ContextKey ( "s" ) ; this . inVisualModeContext = new ContextKey ( "s" ) ; } public SetVimStyle ( vim ) { this . vimStyle = vim ; } public CloseCommandStatus ( ) { this . commandStatusBarItem . text = "s" ; } public ShowCommandStatus ( text ) { this . commandStatusBarItem . text = text ; } public ShowModeStatus ( mode ) { this . modeStatusBarItem . text = Utils . ModeToString ( mode ) ; } public ApplyOptions ( option ) { this . Options = option ; this . Options . showMode ? this . modeStatusBarItem . show ( ) : this . modeStatusBarItem . hide ( ) ; } public InsertTextAtCurrentPosition ( text ) { vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . insert ( vscode . window . activeTextEditor . selection . active , text ) ; } ) ; } public InsertCharactorAtCurrentPosition ( char ) { vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . insert ( vscode . window . activeTextEditor . selection . active , char ) ; } ) ; } public TypeDirect ( char ) { vscode . commands . executeCommand ( "s" , { text : char } ) ; } public Insert ( position , text ) { vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . insert ( tranceVSCodePosition ( position ) , text ) ; } ) ; } public DeleteRange ( range , position ? ) { vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . delete ( tranceVSCodeRange ( range ) ) ; if ( this . vimStyle . GetMode ( ) === VimMode . Normal ) { this . showBlockCursor ( ) ; } } ) ; } public ReplaceRange ( range , text ) { vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . replace ( tranceVSCodeRange ( range ) , text ) ; } ) ; } public ReadLine ( line ) { if ( vscode . window . activeTextEditor . document . lineCount > line ) { return vscode . window . activeTextEditor . document . lineAt ( line ) . text ; } return null ; } public ReadLineAtCurrentPosition ( ) { return vscode . window . activeTextEditor . document . lineAt ( vscode . window . activeTextEditor . selection . active . line ) . text ; } public ReadRange ( range ) { return vscode . window . activeTextEditor . document . getText ( tranceVSCodeRange ( range ) ) ; } public GetCurrentPosition ( ) { if ( this . latestPosition ) { let now = new Date ( ) . getTime ( ) ; if ( now < this . latestPositionTimestamp + 0 ) { return this . latestPosition ; } } if ( vscode . window . activeTextEditor ) { return tranceVimStylePosition ( vscode . window . activeTextEditor . selection . active ) ; } return null ; } public SetPosition ( p ) { let cp = tranceVSCodePosition ( p ) ; vscode . window . activeTextEditor . selection = new vscode . Selection ( cp , cp ) ; vscode . window . activeTextEditor . revealRange ( vscode . window . activeTextEditor . selection , vscode . TextEditorRevealType . Default ) ; this . showBlockCursor ( ) ; this . latestPositionTimestamp = new Date ( ) . getTime ( ) ; this . latestPosition = p ; } public GetLastPosition ( ) { let end = vscode . window . activeTextEditor . document . lineAt ( vscode . window . activeTextEditor . document . lineCount - 0 ) . range . end ; return tranceVimStylePosition ( end ) ; } public GetLastLineNum ( ) { return vscode . window . activeTextEditor . document . lineCount - 0 ; } public dispose ( ) { this . modeStatusBarItem . dispose ( ) ; this . commandStatusBarItem . dispose ( ) ; } public ChangePositionByUser ( ) { if ( this . changeSelectionByVimStyle ) { this . changeSelectionByVimStyle = false ; return ; } if ( this . vimStyle . GetMode ( ) === VimMode . Insert ) { return ; } if ( vscode . window . activeTextEditor === undefined ) { return ; } let s = vscode . window . activeTextEditor . selection ; if ( ! s . start . isEqual ( s . end ) ) { this . vimStyle . ApplyVisualMode ( ) ; return ; } this . vimStyle . ApplyNormalMode ( ) ; } public ApplyNormalMode ( p ? ) { let vp : vscode . Position ; if ( p ) { vp = tranceVSCodePosition ( p ) ; vscode . window . activeTextEditor . selection = new vscode . Selection ( vp , vp ) ; } this . showBlockCursor ( ) ; this . inInsertModeContext . set ( false ) ; this . inNormalModeContext . set ( true ) ; this . inVisualModeContext . set ( false ) ; } public ApplyInsertMode ( p ? ) { if ( p ) { let c = tranceVSCodePosition ( p ) ; vscode . window . activeTextEditor . selection = new vscode . Selection ( c , c ) ; } this . showLineCursor ( ) ; this . inInsertModeContext . set ( true ) ; this . inNormalModeContext . set ( false ) ; this . inVisualModeContext . set ( false ) ; } public ShowVisualMode ( range , focusPosition ? ) { let s = new vscode . Selection ( tranceVSCodePosition ( range . start ) , tranceVSCodePosition ( range . end ) ) ; this . changeSelectionByVimStyle = true ; vscode . window . activeTextEditor . selection = s ; if ( focusPosition !== undefined ) { let p = tranceVSCodePosition ( focusPosition ) ; let r = new vscode . Range ( p , p ) ; vscode . window . activeTextEditor . revealRange ( r , vscode . TextEditorRevealType . Default ) ; } this . showLineCursor ( ) ; this . inInsertModeContext . set ( false ) ; this . inNormalModeContext . set ( false ) ; this . inVisualModeContext . set ( true ) ; } public GetCurrentVisualModeSelection ( ) { return tranceVimStyleRange ( vscode . window . activeTextEditor . selection ) ; } public ShowVisualLineMode ( startLine , endLine , focusPosition ) { this . visualLineModeStartLine = startLine ; this . visualLineModeEndLine = endLine ; this . visualLineModeFocusPosition = focusPosition ; this . changeSelectionByVimStyle = true ; let start : vscode . Position ; let end : vscode . Position ; let line ; if ( startLine <= endLine ) { start = new vscode . Position ( startLine , 0 ) ; line = vscode . window . activeTextEditor . document . lineAt ( endLine ) . text ; end = new vscode . Position ( endLine , line . length ) ; } else if ( endLine < startLine ) { line = vscode . window . activeTextEditor . document . lineAt ( startLine ) . text ; start = new vscode . Position ( startLine , line . length ) ; end = new vscode . Position ( endLine , 0 ) ; } let v = new vscode . Selection ( start , end ) ; vscode . window . activeTextEditor . selection = v ; let fc = tranceVSCodePosition ( focusPosition ) ; let rc = new vscode . Range ( fc , fc ) ; vscode . window . activeTextEditor . revealRange ( rc ) ; this . showBlockCursor ( ) ; this . inInsertModeContext . set ( false ) ; this . inNormalModeContext . set ( false ) ; this . inVisualModeContext . set ( true ) ; } public GetCurrentVisualLineModeSelection ( ) { return { startLine : this . visualLineModeStartLine , endLine : this . visualLineModeEndLine , focusPosition : this . visualLineModeFocusPosition , } ; } public UpdateValidPosition ( p , isBlock ? ) { let cp = new Position ( ) ; cp . Line = p . Line ; cp . Char = p . Char ; if ( p . Line <= 0 ) { cp . Line = 0 ; } else { let lastLineNum = this . GetLastLineNum ( ) ; if ( lastLineNum < p . Line ) { cp . Line = lastLineNum ; } } if ( cp . Char <= 0 ) { cp . Char = 0 ; } else { let line = this . ReadLine ( cp . Line ) ; if ( isBlock ) { if ( line . length === 0 ) { cp . Char = 0 ; } else if ( cp . Char >= line . length ) { cp . Char = line . length - 0 ; } } else { if ( cp . Char > line . length ) { cp . Char = line . length ; } } } return cp ; } public GetTabSize ( ) { let n = vscode . window . activeTextEditor . options . tabSize ; let ntype = typeof n ; if ( ntype === "s" ) { return n as number ; } else if ( ntype === "s" ) { let ns = parseInt ( n as string , 0 ) ; if ( isNaN ( ns ) ) { return ns ; } } return 0 ; } public CallEditorCommand ( argument ) { vscode . commands . executeCommand ( argument , null ) ; } private showLineCursor ( ) { if ( this . Options . changeCursorStyle ) { let opt = vscode . window . activeTextEditor . options ; opt . cursorStyle = vscode . TextEditorCursorStyle . Line ; vscode . window . activeTextEditor . options = opt ; } } private showBlockCursor ( ) { if ( vscode . window . activeTextEditor === undefined ) { return ; } if ( this . Options . changeCursorStyle ) { let opt = vscode . window . activeTextEditor . options ; opt . cursorStyle = vscode . TextEditorCursorStyle . Block ; vscode . window . activeTextEditor . options = opt ; } } } function tranceVimStylePosition ( org : vscode . Position ) { let p = new Position ( ) ; p . Line = org . line ; p . Char = org . character ; return p ; } function tranceVimStyleRange ( org : vscode . Range ) { let r = new Range ( ) ; r . start = tranceVimStylePosition ( org . start ) ; r . end = tranceVimStylePosition ( org . end ) ; return r ; } function tranceVSCodePosition ( org ) : vscode . Position { return new vscode . Position ( org . Line , org . Char ) ; } function tranceVSCodeRange ( org ) : vscode . Range { let start = tranceVSCodePosition ( org . start ) ; let end = tranceVSCodePosition ( org . end ) ; return new vscode . Range ( start , end ) ; } class ContextKey { private name : string ; private lastValue : boolean ; constructor ( name ) { this . name = name ; } public set ( value ) { if ( this . lastValue === value ) { return ; } this . lastValue = value ; vscode . commands . executeCommand ( "s" , this . name , this . lastValue ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVSCodeEditorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVimStyle$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $VimMode$ O O O O O O O O O O O O O O O O O O O $IVSCodeEditorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $IRange$ O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVisualLineModeSelectionInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O $IPosition$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EditorCommand } from "s" ; export const VSCodeEditorKeyBindngs = { AtStart : { "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , } , FirstNum : { } , RequireMotion : { } , RequireMotionNum : { } , RequireBrancketForLeftBrancket : { } , RequireBrancketForLeftBrancketMotion : { } , RequireBrancketForRightBrancket : { } , RequireBrancketForRightBrancketMotion : { } , SmallG : { } , SmallGForMotion : { } , VisualMode : { "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , } , VisualModeNum : { } , VisualLineMode : { "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , "s" : { CreateActionWithArguments : EditorCommand , argument : "s" , } , } , } ;	O O O O O O O O O $IKeyBindings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from "s" ; import * as utils from "s" ; import { VimStyle } from "s" ; import { IVSCodeEditorOptions , VSCodeEditor } from "s" ; import { VSCodeEditorKeyBindngs } from "s" ; function checkImapAction ( bindkey ) { let p = vscode . window . activeTextEditor . selection . active ; let line = vscode . window . activeTextEditor . document . lineAt ( p . line ) . text ; if ( p . character < bindkey . length - 0 ) { return false ; } for ( let i = 0 ; i < bindkey . length - 0 ; i ++ ) { if ( line [ p . character - ( bindkey . length - 0 ) + i ] !== bindkey [ i ] ) { return false ; } } if ( bindkey . length > 0 ) { let deleteRange = new vscode . Range ( new vscode . Position ( p . line , p . character - ( bindkey . length - 0 ) ) , p ) ; vscode . window . activeTextEditor . edit ( ( editBuilder ) => { editBuilder . delete ( deleteRange ) ; } ) ; } let np = new vscode . Position ( p . line , p . character - ( bindkey . length - 0 ) ) ; vscode . window . activeTextEditor . selection = new vscode . Selection ( np , np ) ; return true ; } export function activate ( context : vscode . ExtensionContext ) { if ( vscode . workspace . getConfiguration ( "s" ) . get < boolean > ( "s" , true ) ) { activateVimStyle ( context ) ; } } function activateVimStyle ( context : vscode . ExtensionContext ) { let editorOpt ; let vimOpt ; function loadConfiguration ( ) { let conf = vscode . workspace . getConfiguration ( "s" ) ; editorOpt = { showMode : conf . get < boolean > ( "s" , true ) , changeCursorStyle : conf . get < boolean > ( "s" , true ) , defaultMode : conf . get < string > ( "s" , "s" ) , imapEsc : conf . get < string > ( "s" , "s" ) , } ; vimOpt = { useErgonomicKeyForMotion : conf . get < boolean > ( "s" , false ) , editorKeyBindings : VSCodeEditorKeyBindngs , vimrc : conf . get < string [ ] > ( "s" , null ) , } ; } loadConfiguration ( ) ; let editor = new VSCodeEditor ( editorOpt ) ; context . subscriptions . push ( editor ) ; let vim = new VimStyle ( editor , vimOpt ) ; let disposable = vscode . workspace . onDidChangeConfiguration ( ( ) => { loadConfiguration ( ) ; vim . ApplyOptions ( vimOpt ) ; editor . ApplyOptions ( editorOpt ) ; } ) ; context . subscriptions . push ( disposable ) ; disposable = vscode . window . onDidChangeActiveTextEditor ( ( textEditor ) => { editor . ChangePositionByUser ( ) ; } ) ; context . subscriptions . push ( disposable ) ; disposable = vscode . window . onDidChangeTextEditorSelection ( ( textEditor ) => { editor . ChangePositionByUser ( ) ; } ) ; context . subscriptions . push ( disposable ) ; let imapEscPointer = 0 ; context . subscriptions . push ( vscode . commands . registerCommand ( "s" , async ( args ) => { let text ; if ( args . text && args . text . length > 0 ) { text = args . text ; let charClass = utils . GetCharClass ( text . charCodeAt ( 0 ) ) ; if ( charClass !== CharGroup . AlphabetAndNumber && charClass !== CharGroup . Marks && charClass !== CharGroup . Spaces ) { vim . PushKey ( args . text ) ; return ; } } if ( ! vscode . window . activeTextEditor ) { return ; } if ( vim . GetMode ( ) === VimMode . Insert ) { if ( editorOpt . imapEsc . length === 0 ) { vim . PushKey ( args . text ) ; return ; } if ( editorOpt . imapEsc [ imapEscPointer ] === args . text ) { imapEscPointer ++ ; if ( editorOpt . imapEsc . length === imapEscPointer ) { if ( checkImapAction ( editorOpt . imapEsc ) ) { imapEscPointer = 0 ; vim . PushEscKey ( ) ; return ; } } else { vim . PushKey ( args . text ) ; return ; } } else if ( editorOpt . imapEsc [ 0 ] === args . text ) { imapEscPointer = 0 ; vim . PushKey ( args . text ) ; return ; } imapEscPointer = 0 ; vim . PushKey ( args . text ) ; return ; } vim . PushKey ( args . text ) ; return ; } ) ) ; context . subscriptions . push ( vscode . commands . registerCommand ( "s" , ( ) => { vim . PushEscKey ( ) ; } ) ) ; let chars = "s" ; let otherKeys = [ "s" , "s" , "s" , "s" ] ; let addTypeVim = ( c ) => { context . subscriptions . push ( vscode . commands . registerCommand ( "s" + c , ( ) => { vim . PushKey ( c ) ; } ) ) ; } ; for ( let char of chars ) { addTypeVim ( char ) ; } for ( let key of otherKeys ) { addTypeVim ( key ) ; } vscode . commands . executeCommand ( "s" , "s" , true ) ; setTimeout ( ( ) => { if ( editorOpt . defaultMode === "s" ) { vim . PushKey ( "s" ) ; } else { vim . PushEscKey ( ) ; } } , 0 ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVSCodeEditorOptions$ O O $IVimStyleOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let ChangingText = { } ; ChangingText [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let CopyAndMovingTextTests = { } ; CopyAndMovingTextTests [ "s" ] = { "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let DeletingText = { } ; DeletingText [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; DeletingText [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; DeletingText [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; DeletingText [ "s" ] = { "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , } ; DeletingText [ "s" ] = { "s" : { in : [ "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let InsertModeTests = { } ; InsertModeTests [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let LeftRightMotions = { } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ; LeftRightMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let RepeatTests = { } ; RepeatTests [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , } ; RepeatTests [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let TextObjectMotions = { } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , ] , } , } ; TextObjectMotions [ "s" ] = { "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , ] , key : "s" , out : [ "s" , ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let TextObjects = { } ; TextObjects [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjects [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } ; TextObjects [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , } TextObjects [ "s" ] = { "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , "s" : { in : [ "s" ] , key : "s" , out : [ "s" ] , } , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export let UpDownMotions = { } ; UpDownMotions [ "s" ] = { "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" , ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" , ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" ] , } , "s" : { in : [ "s" , "s" , "s" , "s" , "s" ] , key : "s" , out : [ "s" , "s" , "s" , "s" , "s" ] , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangingText } from "s" ; import { CopyAndMovingTextTests } from "s" ; import { DeletingText } from "s" ; import { InsertModeTests } from "s" ; import { LeftRightMotions } from "s" ; import { RepeatTests } from "s" ; import { TextObjectMotions } from "s" ; import { TextObjects } from "s" ; import { UpDownMotions } from "s" ; export let VimTests = { } ; let testsets = [ LeftRightMotions , UpDownMotions , TextObjectMotions , InsertModeTests , ChangingText , DeletingText , CopyAndMovingTextTests , RepeatTests , TextObjects , ] ; for ( let testset in testsets ) { for ( let test in testsets [ testset ] ) { VimTests [ test ] = testsets [ testset ] [ test ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Utils from "s" ; import { Position , Range , VimStyle } from "s" ; export class VirtualEditor implements IEditor { public CommandStatus : string ; public ModeStatus : string ; public Position : Position ; public VimStyle : IVimStyle ; private contents : string [ ] ; private currentVisualLineModeInfo : IVisualLineModeSelectionInfo ; private currentVisualModeSelection : IRange ; constructor ( ) { this . contents = [ ] ; this . CommandStatus = "s" ; this . ModeStatus = "s" ; this . Position = new Position ( ) ; this . Position . Char = 0 ; this . Position . Line = 0 ; } public SetContent ( textList : string [ ] ) { this . contents = textList ; let len = textList . length ; for ( let i = 0 ; i < len ; i ++ ) { let line = textList [ i ] ; let c = line . indexOf ( "s" ) ; if ( c !== - 0 ) { this . Position . Line = i ; this . Position . Char = c ; this . contents [ i ] = this . contents [ i ] . replace ( "s" , "s" ) ; return ; } } } public GetContent ( ) : string [ ] { let output = [ ] ; let len = this . contents . length ; for ( let i = 0 ; i < len ; i ++ ) { output . push ( this . contents [ i ] ) ; } let line = output [ this . Position . Line ] ; output [ this . Position . Line ] = line . substr ( 0 , this . Position . Char ) + "s" + line . substr ( this . Position . Char , line . length ) ; return output ; } public CloseCommandStatus ( ) { this . CommandStatus = "s" ; } public ShowCommandStatus ( text ) { this . CommandStatus = text ; } public ShowModeStatus ( mode ) { this . ModeStatus = Utils . ModeToString ( mode ) ; } public InsertTextAtCurrentPosition ( text ) { let cLine = this . contents [ this . Position . Line ] ; let pre = cLine . substr ( 0 , this . Position . Char ) ; let su = cLine . substr ( this . Position . Char , cLine . length - this . Position . Char ) ; let lineList = text . split ( "s" ) ; if ( lineList . length === 0 ) { this . contents [ this . Position . Line ] = pre + text + su ; this . Position . Char += text . length ; return ; } this . contents [ this . Position . Line ] = pre + lineList [ 0 ] ; for ( let i = 0 ; i < lineList . length - 0 ; i ++ ) { this . contents . splice ( this . Position . Line + i , 0 , lineList [ i ] ) ; } this . contents . splice ( this . Position . Line + lineList . length - 0 , 0 , lineList [ lineList . length - 0 ] + su ) ; this . Position . Line = this . Position . Line + lineList . length - 0 ; this . Position . Char = lineList [ lineList . length ] . length ; } public SetModeStatusVisibility ( visible ) { return ; } public InsertCharactorAtCurrentPosition ( char ) { let cLine = this . contents [ this . Position . Line ] ; let pre = cLine . substr ( 0 , this . Position . Char ) ; let su = cLine . substr ( this . Position . Char , cLine . length - this . Position . Char ) ; this . contents [ this . Position . Line ] = pre + char + su ; this . Position . Char += 0 ; } public TypeDirect ( char ) { this . InsertCharactorAtCurrentPosition ( char ) ; } public Insert ( position , text ) { let cLine = this . contents [ position . Line ] ; let pre = cLine . substr ( 0 , position . Char ) ; let su = cLine . substr ( position . Char , cLine . length - position . Char ) ; let lineList = text . split ( "s" ) ; if ( lineList . length === 0 ) { this . contents [ position . Line ] = pre + text + su ; return ; } this . contents [ position . Line ] = pre + lineList [ 0 ] ; for ( let i = 0 ; i < lineList . length - 0 ; i ++ ) { this . contents . splice ( position . Line + i , 0 , lineList [ i ] ) ; } this . contents . splice ( position . Line + lineList . length - 0 , 0 , lineList [ lineList . length - 0 ] + su ) ; } public DeleteRange ( range , position ? ) { if ( range . start . Line === range . end . Line ) { let line = this . contents [ range . start . Line ] ; let pre = line . substr ( 0 , range . start . Char ) ; let su = line . substr ( range . end . Char , line . length - range . end . Char ) ; this . contents [ range . start . Line ] = pre + su ; } else { let line = this . contents [ range . start . Line ] . substr ( 0 , range . start . Char ) ; line += this . contents [ range . end . Line ] . substr ( range . end . Char , this . contents [ range . end . Line ] . length - range . end . Char ) ; this . contents . splice ( range . start . Line , range . end . Line - range . start . Line + 0 , line ) ; } if ( position !== undefined ) { this . Position = position ; } } public ReplaceRange ( range , text ) { this . DeleteRange ( range ) ; this . Insert ( range . start , text ) ; } public ReadLineAtCurrentPosition ( ) { return this . ReadLine ( this . Position . Line ) ; } public ReadLine ( line ) { return this . contents [ line ] ; } public ReadRange ( range ) { if ( range . start . Line === range . end . Line ) { return this . contents [ range . start . Line ] . substr ( range . start . Char , range . end . Char - range . start . Char ) ; } let line = this . contents [ range . start . Line ] ; let result = line . substr ( range . start . Char , line . length - range . start . Char ) ; for ( let i = range . start . Line + 0 ; i < range . end . Line ; i ++ ) { result += "s" + this . contents [ i ] ; } line = this . contents [ range . end . Line ] ; result += "s" + line . substr ( 0 , range . end . Char ) ; return result ; } public GetCurrentPosition ( ) { return this . Position ; } public SetPosition ( position ) { this . Position = position ; } public GetLastPosition ( ) { let p = new Position ( ) ; p . Line = this . GetLastLineNum ( ) ; p . Char = this . contents [ this . GetLastLineNum ( ) ] . length ; return p ; } public GetLastLineNum ( ) { return this . contents . length - 0 ; } public SetVimStyle ( vim ) { this . VimStyle = vim ; } public ApplyNormalMode ( cursor ? , isLineHasNoChar ? , isLastLine ? ) { return ; } public ApplyInsertMode ( p ) { this . Position = p ; } public ShowVisualMode ( range , focusPosition ? ) { this . Position = focusPosition ; this . currentVisualModeSelection = range ; } public GetCurrentVisualModeSelection ( ) { return this . currentVisualModeSelection ; } public ShowVisualLineMode ( startLine , endLine , focusPosition ? ) { this . currentVisualLineModeInfo = { startLine , endLine , focusPosition , } ; } public GetCurrentVisualLineModeSelection ( ) { return this . currentVisualLineModeInfo ; } public UpdateValidPosition ( p , isBlock ? ) { if ( p . Line > this . GetLastLineNum ( ) ) { return this . GetLastPosition ( ) ; } if ( isBlock ) { if ( p . Char > this . contents [ p . Line ] . length - 0 ) { let np = new Position ( ) ; np . Line = p . Line ; np . Char = this . contents [ p . Line ] . length - 0 ; return np ; } } else { if ( p . Char > this . contents [ p . Line ] . length ) { let np = new Position ( ) ; np . Line = p . Line ; np . Char = this . contents [ p . Line ] . length ; return np ; } } return p ; } public Type ( keystroke ) { let len = keystroke . length ; for ( let i = 0 ; i < len ; i ++ ) { let k = keystroke . charAt ( i ) ; if ( k === "s" ) { this . VimStyle . PushEscKey ( ) ; } else { this . VimStyle . PushKey ( k ) ; } } } public GetTabSize ( ) { return 0 ; } public dispose ( ) { return ; } public CallEditorCommand ( argument ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $VimMode$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $IPosition$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRange$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O $string$ O $IRange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPosition$ O O O O O O O O O O O O $IPosition$ O O O O O O O O O O $IPosition$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O $IVimStyle$ O O O O O O O O O O O O O $IPosition$ O O $boolean$ O O $boolean$ O O O O O O O O $IPosition$ O O O O O O O O O O O O $IRange$ O O $IPosition$ O O O O O O O O O O O O O O O O $IRange$ O O O O O O O O O O O O $number$ O $number$ O O $IPosition$ O O O O O O O O O O O O O O O O O $IVisualLineModeSelectionInfo$ O O O O O O O O O O $IPosition$ O $IPosition$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O
import * as assert from "s" ; import * as fs from "s" ; import { exec } from "s" ; import { Position , VimStyle } from "s" ; import { VimTests } from "s" ; import { VirtualEditor } from "s" ; for ( let target in VimTests ) { describe ( "s" + target , function ( ) { this . timeout ( 0 ) ; let test = VimTests [ target ] ; for ( let specName in test ) { it ( specName , async ( ) => { let spec = test [ specName ] ; let text = spec [ "s" ] [ 0 ] ; for ( let i = 0 ; i < spec [ "s" ] . length ; i ++ ) { text += "s" + spec [ "s" ] [ i ] ; } await fs . writeFile ( "s" , text ) ; text = "s" ; text += "s" ; let list = spec . key . split ( "s" ) ; for ( let item of list ) { text += "s" + item . replace ( "s" , "s" ) + "s" ; } text += "s" ; text += "s" ; text += "s" ; await fs . writeFile ( "s" , text ) ; await execAsync ( "s" ) ; text = await fs . readFile ( "s" ) ; let out = text . toString ( ) . split ( "s" ) ; let outText = out [ 0 ] ; let specText = spec . out [ 0 ] ; for ( let i = 0 ; i < spec . out . length ; i ++ ) { outText += "s" + out [ i ] ; specText += "s" + spec . out [ i ] ; } assert . equal ( outText , specText ) ; } ) ; } } ) ; } function execAsync ( cmd ) < void > { return new Promise < null > ( ( resolve , reject ) => { exec ( cmd ) . on ( "s" , ( code , signal ) => { resolve ( null ) ; } ) . on ( "s" , ( err ) => { reject ( null ) ; } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VirtualEditor } from "s" ; import { Position , VimStyle } from "s" ; import { VimTests } from "s" ; import { exec } from "s" ; import * as fs from 's' ; import * as assert from "s" ; for ( let target in VimTests ) { describe ( "s" + target , function ( ) { this . timeout ( 0 ) ; let test = VimTests [ target ] ; for ( let specName in test ) { ( function ( specName ) { it ( specName , async function ( ) { let spec = test [ specName ] ; let text = spec [ "s" ] [ 0 ] ; for ( let i = 0 ; i < spec [ "s" ] . length ; i ++ ) { text += "s" + spec [ "s" ] [ i ] ; } await fs . writeFile ( "s" , text ) ; text = "s" ; text += "s" ; let list = spec [ "s" ] . split ( "s" ) ; for ( let i = 0 ; i < list . length ; i ++ ) { text += "s" + list [ i ] . replace ( "s" , "s" ) . replace ( "s" , "s" ) + "s" ; } text += "s" ; text += "s" ; text += "s" ; await fs . writeFile ( "s" , text ) ; await execAsync ( "s" ) ; text = await fs . readFile ( "s" ) ; let out = text . toString ( ) . split ( "s" ) ; let outText = out [ 0 ] ; let specText = spec . out [ 0 ] ; for ( let i = 0 ; i < spec [ "s" ] . length ; i ++ ) { outText += "s" + out [ i ] ; specText += "s" + spec . out [ i ] ; } assert . equal ( outText , specText ) ; } ) ; } ) ( specName ) ; } } ) ; } function execAsync ( cmd ) < void > { return new Promise < null > ( ( resolve , reject ) => { exec ( cmd ) . on ( "s" , ( code , signal ) => { resolve ( null ) ; } ) . on ( "s" , ( err ) => { reject ( null ) ; } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from "s" ; import { Position , VimStyle } from "s" ; import { VimTests } from "s" ; import { VirtualEditor } from "s" ; let opt = { useErgonomicKeyForMotion : false , vimrc : [ ] , } ; let target ; for ( target in VimTests ) { describe ( "s" + target + "s" , ( ) => { let test = VimTests [ target ] ; for ( let specName in test ) { it ( specName , ( ) => { let spec = test [ specName ] ; let ed = new VirtualEditor ( ) ; let vim = new VimStyle ( ed , opt ) ; ed . SetContent ( spec [ "s" ] ) ; ed . Type ( spec . key ) ; let out = ed . GetContent ( ) ; let outText = out [ 0 ] ; let specText = spec . out [ 0 ] ; for ( let i = 0 ; i < out . length ; i ++ ) { outText += "s" + out [ i ] ; } for ( let i = 0 ; i < spec . out . length ; i ++ ) { specText += "s" + spec . out [ i ] ; } assert . equal ( outText , specText ) ; } ) ; } } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IVimStyleOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O