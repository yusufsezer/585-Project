'js' module . exports = require ( 's' ) ;	O $any$ O $any$ O $any$ O O O O
'js' 's' const fs = require ( 's' ) ; const path = require ( 's' ) ; module . exports = function ( filename ) { if ( ! fs . existsSync ( path . join ( __dirname , filename ) ) ) { console . log ( 's' ) ; console . log ( 's' ) ; process . exit ( 0 ) ; } }	O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O $void$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O O
'js' 's' ; require ( 's' ) ( 's' ) ; const { Launcher , launch } = require ( 's' ) ; const args = process . argv . slice ( 0 ) ; const chromeFlags = [ ] ; let startingUrl ; let port ; let ignoreDefaultFlags ; if ( args . length ) { const providedFlags = args . filter ( flag => flag . startsWith ( 's' ) ) ; const portFlag = providedFlags . find ( flag => flag . startsWith ( 's' ) ) ; if ( portFlag ) port = parseInt ( portFlag . replace ( 's' , 's' ) , 0 ) ; const enableExtensions = ! ! providedFlags . find ( flag => flag === 's' ) ; if ( enableExtensions ) { ignoreDefaultFlags = true ; chromeFlags . push ( ... Launcher . defaultFlags ( ) . filter ( flag => flag !== 's' ) ) ; } chromeFlags . push ( ... providedFlags ) ; startingUrl = args . find ( flag => ! flag . startsWith ( 's' ) ) ; } launch ( { startingUrl , port , ignoreDefaultFlags , chromeFlags , } ) . then ( v => console . log ( `template` ) ) ;	O O O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O $any$ O $any$ O O O O O O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any[]$ O $number$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $number$ O $boolean$ O $any[]$ O O O O $any$ O $any$ O $Console$ O $void$ O O O O O
's' ; import { join } from 's' ; import { execSync } from 's' ; import * as mkdirp from 's' ; const isWsl = require ( 's' ) ; export const enum LaunchErrorCodes { ERR_LAUNCHER_PATH_NOT_SET = 's' , ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY = 's' , ERR_LAUNCHER_UNSUPPORTED_PLATFORM = 's' , ERR_LAUNCHER_NOT_INSTALLED = 's' , } export function defaults < T > ( val : T | undefined , def : T ) : T { return typeof val === 's' ? def : val ; } export async function delay ( time ) { return new Promise ( resolve => setTimeout ( resolve , time ) ) ; } export class LauncherError extends Error { constructor ( public message = 's' , public code ? ) { super ( ) ; this . stack = new Error ( ) . stack ; return this ; } } export class ChromePathNotSetError extends LauncherError { message = 's' ; code = LaunchErrorCodes . ERR_LAUNCHER_PATH_NOT_SET ; } export class InvalidUserDataDirectoryError extends LauncherError { message = 's' ; code = LaunchErrorCodes . ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY ; } export class UnsupportedPlatformError extends LauncherError { message = `template` ; code = LaunchErrorCodes . ERR_LAUNCHER_UNSUPPORTED_PLATFORM ; } export class ChromeNotInstalledError extends LauncherError { message = 's' ; code = LaunchErrorCodes . ERR_LAUNCHER_NOT_INSTALLED ; } export function getPlatform ( ) { return isWsl ? 's' : process . platform ; } export function makeTmpDir ( ) { switch ( getPlatform ( ) ) { case 's' : case 's' : return makeUnixTmpDir ( ) ; case 's' : process . env . TEMP = getLocalAppDataPath ( `template` ) ; case 's' : return 0 ( ) ; default : throw new UnsupportedPlatformError ( ) ; } } export function toWinDirFormat ( dir = 's' ) { const results = "s" . exec ( dir ) ; if ( ! results ) { return dir ; } const driveLetter = results [ 0 ] ; return dir . replace ( `template` , `template` ) . replace ( "s" , 's' ) ; } export function getLocalAppDataPath ( path ) { const userRegExp = "s" ; const results = userRegExp . exec ( path ) || [ ] ; return `template` ; } function makeUnixTmpDir ( ) { return execSync ( 's' ) . toString ( ) . trim ( ) ; } function 0 ( ) { const winTmpPath = process . env . TEMP || process . env . TMP || ( process . env . SystemRoot || process . env . windir ) + 's' ; const randomNumber = Math . floor ( Math . random ( ) * 0 + 0 ) ; const tmpdir = join ( winTmpPath , 's' + randomNumber ) ; mkdirp . sync ( tmpdir ) ; return tmpdir ; }	O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $LaunchErrorCodes.ERR_LAUNCHER_PATH_NOT_SET$ O O O $LaunchErrorCodes.ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY$ O O O $LaunchErrorCodes.ERR_LAUNCHER_UNSUPPORTED_PLATFORM$ O O O $LaunchErrorCodes.ERR_LAUNCHER_NOT_INSTALLED$ O O O O O O $T$ O $any$ O O $T$ O $any$ O O O $T$ O $any$ O O $any$ O O O $T$ O O O $T$ O $T$ O O O O O $Promise<unknown>$ O $number$ O O O O $PromiseConstructor$ O $void$ O $number$ O $void$ O $number$ O O O O O O $any$ O $ErrorConstructor$ O O O O $string$ O O O O $string$ $string$ O O O O O O O O $string$ O O $ErrorConstructor$ O O O $string$ O O O O O O O O $any$ O $any$ O $string$ O O O $LaunchErrorCodes$ O $any$ O $LaunchErrorCodes.ERR_LAUNCHER_PATH_NOT_SET$ O O O O $any$ O $any$ O $string$ O O O $LaunchErrorCodes$ O $any$ O $LaunchErrorCodes.ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY$ O O O O $any$ O $any$ O $string$ O O O $LaunchErrorCodes$ O $any$ O $LaunchErrorCodes.ERR_LAUNCHER_UNSUPPORTED_PLATFORM$ O O O O $any$ O $any$ O $string$ O O O $LaunchErrorCodes$ O $any$ O $LaunchErrorCodes.ERR_LAUNCHER_NOT_INSTALLED$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $string$ O $string$ O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O O $RegExpExecArray$ O O O $string$ O O O $string$ O $RegExpExecArray$ O O O O O $string$ O $complex$ O O O O O O $complex$ O O O O O O O O O $string$ O $string$ O O O $RegExp$ O O O O $complex$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O $Math$ O $number$ O $Math$ O $number$ O O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O $any$ O $any$ O $any$ O O O $any$ O O
's' ; const fs = require ( 's' ) ; const path = require ( 's' ) ; const execSync = require ( 's' ) . execSync ; const execFileSync = require ( 's' ) . execFileSync ; const log = require ( 's' ) ; import { getLocalAppDataPath , ChromePathNotSetError } from 's' ; const newLineRegex = "s" ; type Priorities = Array < { regex : RegExp , weight : number } > ; export function darwin ( ) { const suffixes = [ 's' , 's' ] ; const LSREGISTER = 's' + 's' + 's' ; const installations < string > = [ ] ; const customChromePath = resolveChromePath ( ) ; if ( customChromePath ) { installations . push ( customChromePath ) ; } execSync ( `template` + 's' + 's' ) . toString ( ) . split ( newLineRegex ) . forEach ( ( inst ) => { suffixes . forEach ( suffix => { const execPath = path . join ( inst . substring ( 0 , inst . indexOf ( 's' ) + 0 ) . trim ( ) , suffix ) ; if ( canAccess ( execPath ) && installations . indexOf ( execPath ) === - 0 ) { installations . push ( execPath ) ; } } ) ; } ) ; const priorities = [ { regex : new RegExp ( `template` ) , weight : 0 } , { regex : new RegExp ( `template` ) , weight : 0 } , { regex : "s" , weight : 0 } , { regex : "s" , weight : 0 } , { regex : "s" , weight : - 0 } , { regex : "s" , weight : - 0 } , ] ; if ( process . env . LIGHTHOUSE_CHROMIUM_PATH ) { priorities . unshift ( { regex : new RegExp ( `template` ) , weight : 0 } ) ; } if ( process . env . CHROME_PATH ) { priorities . unshift ( { regex : new RegExp ( `template` ) , weight : 0 } ) ; } return sort ( installations , priorities ) ; } function resolveChromePath ( ) { if ( canAccess ( `template` ) ) { return process . env . CHROME_PATH ; } if ( canAccess ( `template` ) ) { log . warn ( 's' , 's' ) ; return process . env . LIGHTHOUSE_CHROMIUM_PATH ; } return undefined ; } export function linux ( ) { let installations : string [ ] = [ ] ; const customChromePath = resolveChromePath ( ) ; if ( customChromePath ) { installations . push ( customChromePath ) ; } const desktopInstallationFolders = [ path . join ( require ( 's' ) . homedir ( ) , 's' ) , 's' , ] ; desktopInstallationFolders . forEach ( folder => { installations = installations . concat ( findChromeExecutables ( folder ) ) ; } ) ; const executables = [ 's' , 's' , 's' , 's' , ] ; executables . forEach ( ( executable ) => { try { const chromePath = execFileSync ( 's' , [ executable ] , { stdio : 's' } ) . toString ( ) . split ( newLineRegex ) [ 0 ] ; if ( canAccess ( chromePath ) ) { installations . push ( chromePath ) ; } } catch ( e ) { } } ) ; if ( ! installations . length ) { throw new ChromePathNotSetError ( ) ; } const priorities = [ { regex : "s" , weight : 0 } , { regex : "s" , weight : 0 } , { regex : "s" , weight : 0 } , { regex : "s" , weight : 0 } , { regex : "s" , weight : 0 } , ] ; if ( process . env . LIGHTHOUSE_CHROMIUM_PATH ) { priorities . unshift ( { regex : new RegExp ( `template` ) , weight : 0 } ) ; } if ( process . env . CHROME_PATH ) { priorities . unshift ( { regex : new RegExp ( `template` ) , weight : 0 } ) ; } return sort ( uniq ( installations . filter ( Boolean ) ) , priorities ) ; } export function wsl ( ) { process . env . LOCALAPPDATA = getLocalAppDataPath ( `template` ) ; process . env . PROGRAMFILES = 's' ; process . env [ 's' ] = 's' ; return 0 ( ) ; } export function 0 ( ) { const installations < string > = [ ] ; const suffixes = [ `template` , `template` ] ; const prefixes = [ process . env . LOCALAPPDATA , process . env . PROGRAMFILES , process . env [ 's' ] ] . filter ( Boolean ) ; const customChromePath = resolveChromePath ( ) ; if ( customChromePath ) { installations . push ( customChromePath ) ; } prefixes . forEach ( prefix => suffixes . forEach ( suffix => { const chromePath = path . join ( prefix , suffix ) ; if ( canAccess ( chromePath ) ) { installations . push ( chromePath ) ; } } ) ) ; return installations ; } function sort ( installations : string [ ] , priorities ) { const defaultPriority = 0 ; return installations . map ( ( inst ) => { for ( const pair of priorities ) { if ( pair . regex . test ( inst ) ) { return { path : inst , weight : pair . weight } ; } } return { path : inst , weight : defaultPriority } ; } ) . sort ( ( a , b ) => ( b . weight - a . weight ) ) . map ( pair => pair . path ) ; } function canAccess ( file ) { if ( ! file ) { return false ; } try { fs . accessSync ( file ) ; return true ; } catch ( e ) { return false ; } } function uniq ( arr < any > ) { return Array . from ( new Set ( arr ) ) ; } function findChromeExecutables ( folder ) < string > { const argumentsRegex = "s" ; const chromeExecRegex = 's' ; let installations < string > = [ ] ; if ( canAccess ( folder ) ) { let execPaths ; try { execPaths = execSync ( `template` , { stdio : 's' } ) ; } catch ( e ) { execPaths = execSync ( `template` , { stdio : 's' } ) ; } execPaths = execPaths . toString ( ) . split ( newLineRegex ) . map ( ( execPath ) => execPath . replace ( argumentsRegex , 's' ) ) ; execPaths . forEach ( ( execPath ) => canAccess ( execPath ) && installations . push ( execPath ) ) ; } return installations ; }	O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $string$ O $any$ O O O O O $RegExp$ O O O O $any$ O $ArrayConstructor$ O O $RegExp$ O $RegExpConstructor$ O $number$ O O O O O O O $string[]$ O O O O $string[]$ O O O O O O O O $string$ O O O O O O O O $Array$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $string[]$ O $number$ O $any$ O O O $any$ O O O O O O O O $any$ O O O $any$ O $RegExp$ O O $any$ O O $string$ O O O $string[]$ O $void$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O $string$ O $number$ O O O O O O O $string$ O O O $string$ O O O O $Boolean$ O $any$ O O $string[]$ O $number$ O $any$ O O O O O O $string[]$ O $number$ O $any$ O O O O O O O O O O $Priorities$ O O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O O $RegExp$ O O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $number$ O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $number$ O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O O O $string[]$ O $string[]$ O $complex$ O O O O $any$ O O O O O $Boolean$ O O O O O O $any$ O $any$ O $any$ O O O O $Boolean$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $undefined$ O O O O $string[]$ O O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $string[]$ O $number$ O $any$ O O O O $any[]$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any[]$ O $void$ O $any$ O O $string[]$ O $string[]$ O $complex$ O $string[]$ O $any$ O O O O O O O $string[]$ O O O O O O O O O O O O $string[]$ O $void$ O O $string$ O O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O O O $any$ O $RegExp$ O O O O O O O $Boolean$ O $any$ O O O $string[]$ O $number$ O $any$ O O O O O O $any$ O O O O O O O O O $string[]$ O $number$ O O O O $any$ O O O O O $Priorities$ O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O $RegExp$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $number$ O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $number$ O O $RegExp$ O O $RegExpConstructor$ O O O O $number$ O O O O O O O $string[]$ O $any[]$ O $string[]$ O $complex$ O $BooleanConstructor$ O O O $complex$ O O O O O $string[]$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $string[]$ O O O O O O $string[]$ O O O O $Array$ O O O O O O O O $string[]$ O O O O O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O $BooleanConstructor$ O O O $any$ O $any$ O O O O O $any$ O O $string[]$ O $number$ O $any$ O O O $any[]$ O $void$ O $any$ O $string[]$ O $void$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $Boolean$ O $any$ O O O $string[]$ O $number$ O $any$ O O O O O O O O $string[]$ O O O $string[]$ O $string[]$ O O O O O $Priorities$ O O O O O O O O $string[]$ O $U[]$ O O $string$ O O O O O O $complex$ O $complex$ O O O O $complex$ O $RegExp$ O $boolean$ O $string$ O O O O O $string$ O $string$ O $number$ O $complex$ O $number$ O O O O O O $string$ O $string$ O $number$ O O O O O O O $complex$ O O $complex$ O $complex$ O O O $complex$ O $number$ O $complex$ O $number$ O O O $U[]$ O $complex$ O $complex$ O $string$ O O O O $Boolean$ O $string$ O O O O O $string$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O O $any[]$ O $Array$ O O O O O O $ArrayConstructor$ O $complex$ O O $SetConstructor$ O $any[]$ O O O O O $Array$ O $string$ O O O O O O $RegExp$ O O O O O O O O O $Array$ O O O O O O O O O $Boolean$ O $string$ O O O O $any$ O O O $any$ O $any$ O O O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $RegExp$ O O $any$ O O $string$ O O $string$ O $complex$ O $RegExp$ O O O O O $any$ O $any$ O O $string$ O O $Boolean$ O $string$ O O $string[]$ O $number$ O $string$ O O O O O $string[]$ O O
's' ; import { createServer } from 's' ; import { AddressInfo } from 's' ; export function getRandomPort ( ) < number > { return new Promise ( ( resolve , reject ) => { const server = createServer ( ) ; server . listen ( 0 ) ; server . once ( 's' , ( ) => { const { port } = server . address ( ) as AddressInfo ; server . close ( ( ) => resolve ( port ) ) ; } ) ; server . once ( 's' , reject ) ; } ) ; }	O O O O $any$ O O O O O O $any$ O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O
's' ; export const DEFAULT_FLAGS < string > = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] ;	O O O O $ReadonlyArray$ O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as childProcess from 's' ; import * as fs from 's' ; import * as net from 's' ; import * as rimraf from 's' ; import * as chromeFinder from 's' ; import { getRandomPort } from 's' ; import { DEFAULT_FLAGS } from 's' ; import { makeTmpDir , defaults , delay , getPlatform , toWinDirFormat , InvalidUserDataDirectoryError , UnsupportedPlatformError , ChromeNotInstalledError } from 's' ; import { ChildProcess } from 's' ; const log = require ( 's' ) ; const spawn = childProcess . spawn ; const execSync = childProcess . execSync ; const isWsl = getPlatform ( ) === 's' ; const isWindows = getPlatform ( ) === 's' ; const _SIGINT = 's' ; const _SIGINT_EXIT_CODE = 0 ; const _SUPPORTED_PLATFORMS = new Set ( [ 's' , 's' , 's' , 's' ] ) ; type SupportedPlatforms = 's' | 's' | 's' | 's' ; const instances = new Set < Launcher > ( ) ; export type RimrafModule = ( path , callback : ( error ) => void ) => void ; export interface Options { startingUrl ? : string ; chromeFlags ? : Array < string > ; port ? : number ; handleSIGINT ? : boolean ; chromePath ? : string ; userDataDir ? : string | boolean ; logLevel ? : 's' | 's' | 's' | 's' ; ignoreDefaultFlags ? : boolean ; connectionPollInterval ? : number ; maxConnectionRetries ? : number ; envVars ? : { [ key ] : string | undefined } ; } export interface LaunchedChrome { pid : number ; port : number ; process : ChildProcess ; kill : ( ) => Promise < { } > ; } export interface ModuleOverrides { fs ? : typeof fs ; rimraf ? : RimrafModule ; spawn ? : typeof childProcess . spawn ; } const sigintListener = async ( ) => { for ( const instance of instances ) { try { await instance . kill ( ) ; } catch ( err ) { } } process . exit ( _SIGINT_EXIT_CODE ) ; } ; async function launch ( opts = { } ) < LaunchedChrome > { opts . handleSIGINT = defaults ( opts . handleSIGINT , true ) ; const instance = new Launcher ( opts ) ; if ( opts . handleSIGINT && instances . size === 0 ) { process . on ( _SIGINT , sigintListener ) ; } instances . add ( instance ) ; await instance . launch ( ) ; const kill = async ( ) => { instances . delete ( instance ) ; if ( instances . size === 0 ) { process . removeListener ( _SIGINT , sigintListener ) ; } return instance . kill ( ) ; } ; return { pid : instance . pid ! , port : instance . port ! , kill , process : instance . chrome ! } ; } class Launcher { private tmpDirandPidFileReady = false ; private pidFile : string ; private startingUrl : string ; private outFile ? : number ; private errFile ? : number ; private chromePath ? : string ; private ignoreDefaultFlags ? : boolean ; private chromeFlags : string [ ] ; private requestedPort ? : number ; private connectionPollInterval : number ; private maxConnectionRetries : number ; private fs : typeof fs ; private rimraf : RimrafModule ; private spawn : typeof childProcess . spawn ; private useDefaultProfile : boolean ; private envVars : { [ key ] : string | undefined } ; chrome ? : childProcess . ChildProcess ; userDataDir ? : string ; port ? : number ; pid ? : number ; constructor ( private opts = { } , moduleOverrides = { } ) { this . fs = moduleOverrides . fs || fs ; this . rimraf = moduleOverrides . rimraf || rimraf ; this . spawn = moduleOverrides . spawn || spawn ; log . setLevel ( defaults ( this . opts . logLevel , 's' ) ) ; this . startingUrl = defaults ( this . opts . startingUrl , 's' ) ; this . chromeFlags = defaults ( this . opts . chromeFlags , [ ] ) ; this . requestedPort = defaults ( this . opts . port , 0 ) ; this . chromePath = this . opts . chromePath ; this . ignoreDefaultFlags = defaults ( this . opts . ignoreDefaultFlags , false ) ; this . connectionPollInterval = defaults ( this . opts . connectionPollInterval , 0 ) ; this . maxConnectionRetries = defaults ( this . opts . maxConnectionRetries , 0 ) ; this . envVars = defaults ( opts . envVars , Object . assign ( { } , process . env ) ) ; if ( typeof this . opts . userDataDir === 's' ) { if ( ! this . opts . userDataDir ) { this . useDefaultProfile = true ; this . userDataDir = undefined ; } else { throw new InvalidUserDataDirectoryError ( ) ; } } else { this . useDefaultProfile = false ; this . userDataDir = this . opts . userDataDir ; } } private get flags ( ) { const flags = this . ignoreDefaultFlags ? [ ] : DEFAULT_FLAGS . slice ( ) ; flags . push ( `template` ) ; if ( getPlatform ( ) === 's' ) { flags . push ( 's' ) ; } if ( ! this . useDefaultProfile ) { flags . push ( `template` ) ; } flags . push ( ... this . chromeFlags ) ; flags . push ( this . startingUrl ) ; return flags ; } static defaultFlags ( ) { return DEFAULT_FLAGS . slice ( ) ; } makeTmpDir ( ) { return makeTmpDir ( ) ; } prepare ( ) { const platform = getPlatform ( ) as SupportedPlatforms ; if ( ! _SUPPORTED_PLATFORMS . has ( platform ) ) { throw new UnsupportedPlatformError ( ) ; } this . userDataDir = this . userDataDir || this . makeTmpDir ( ) ; this . outFile = this . fs . openSync ( `template` , 's' ) ; this . errFile = this . fs . openSync ( `template` , 's' ) ; this . pidFile = `template` ; log . verbose ( 's' , `template` ) ; this . tmpDirandPidFileReady = true ; } async launch ( ) { if ( this . requestedPort !== 0 ) { this . port = this . requestedPort ; try { return await this . isDebuggerReady ( ) ; } catch ( err ) { log . log ( 's' , `template` ) ; } } if ( this . chromePath === undefined ) { const installations = await chromeFinder [ getPlatform ( ) as SupportedPlatforms ] ( ) ; if ( installations . length === 0 ) { throw new ChromeNotInstalledError ( ) ; } this . chromePath = installations [ 0 ] ; } if ( ! this . tmpDirandPidFileReady ) { this . prepare ( ) ; } this . pid = await this . spawnProcess ( this . chromePath ) ; return Promise . resolve ( ) ; } private async spawnProcess ( execPath ) { const spawnPromise = ( async ( ) => { if ( this . chrome ) { log . log ( 's' , `template` ) ; return this . chrome . pid ; } if ( this . requestedPort === 0 ) { this . port = await getRandomPort ( ) ; } log . verbose ( 's' , `template` ) ; const chrome = this . spawn ( execPath , this . flags , { detached : true , stdio : [ 's' , this . outFile , this . errFile ] , env : this . envVars } ) ; this . chrome = chrome ; this . fs . writeFileSync ( this . pidFile , chrome . pid . toString ( ) ) ; log . verbose ( 's' , `template` ) ; return chrome . pid ; } ) ( ) ; const pid = await spawnPromise ; await this . waitUntilReady ( ) ; return pid ; } private cleanup ( client ? : net . Socket ) { if ( client ) { client . removeAllListeners ( ) ; client . end ( ) ; client . destroy ( ) ; client . unref ( ) ; } } private isDebuggerReady ( ) < { } > { return new Promise ( ( resolve , reject ) => { const client = net . createConnection ( this . port ! ) ; client . once ( 's' , err => { this . cleanup ( client ) ; reject ( err ) ; } ) ; client . once ( 's' , ( ) => { this . cleanup ( client ) ; resolve ( ) ; } ) ; } ) ; } waitUntilReady ( ) { const launcher = this ; return new Promise ( ( resolve , reject ) => { let retries = 0 ; let waitStatus = 's' ; const poll = ( ) => { if ( retries === 0 ) { log . log ( 's' , waitStatus ) ; } retries ++ ; waitStatus += 's' ; log . log ( 's' , waitStatus ) ; launcher . isDebuggerReady ( ) . then ( ( ) => { log . log ( 's' , waitStatus + `template` ) ; resolve ( ) ; } ) . catch ( err => { if ( retries > launcher . maxConnectionRetries ) { log . error ( 's' , err . message ) ; const stderr = this . fs . readFileSync ( `template` , { encoding : 's' } ) ; log . error ( 's' , `template` ) ; log . error ( 's' , stderr ) ; return reject ( err ) ; } delay ( launcher . connectionPollInterval ) . then ( poll ) ; } ) ; } ; poll ( ) ; } ) ; } kill ( ) { return new Promise < { } > ( ( resolve , reject ) => { if ( this . chrome ) { this . chrome . on ( 's' , ( ) => { delete this . chrome ; this . destroyTmp ( ) . then ( resolve ) ; } ) ; log . log ( 's' , `template` ) ; try { if ( isWindows ) { execSync ( `template` ) ; } else { process . kill ( - this . chrome . pid ) ; } } catch ( err ) { const message = `template` ; log . warn ( 's' , message ) ; reject ( new Error ( message ) ) ; } } else { resolve ( ) ; } } ) ; } destroyTmp ( ) { return new Promise ( resolve => { if ( this . userDataDir === undefined || this . opts . userDataDir !== undefined ) { return resolve ( ) ; } if ( this . outFile ) { this . fs . closeSync ( this . outFile ) ; delete this . outFile ; } if ( this . errFile ) { this . fs . closeSync ( this . errFile ) ; delete this . errFile ; } this . rimraf ( this . userDataDir , ( ) => resolve ( ) ) ; } ) ; } } ; export default Launcher ; export { Launcher , launch } ;	O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<number>$ O O O O O O $complex$ O O O O O O $any$ O $T$ O $Promise<unknown>$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $boolean$ O $any$ O O O O O O $boolean$ O $any$ O O O O O O O O O O O O O O O O $Set<string>$ O O $SetConstructor$ O O O O O O O O O O O O O $any$ O O O O O O O O O O $Set<Launcher>$ O O $SetConstructor$ O $any$ O O O O O O $any$ O O $string$ O $void$ O O $Error$ O O O O O O O O O $any$ O $string$ O O O O $string[]$ O O $ArrayConstructor$ O O O O $number$ O O O O $boolean$ O O O O $string$ O O O O $complex$ O O O O O O O O O O O O O O O O O $boolean$ O O O O $number$ O O O O $number$ O O O O $complex$ O O O O $string$ O O O O O O O O O O $any$ O $number$ O O O $number$ O O O $any$ O $any$ O $Promise<{}>$ O O O O $PromiseConstructor$ O O O O O O O O $any$ O $any$ O O O $any$ O $RimrafModule$ O O $any$ O $any$ O O O $any$ O $any$ O O O $Promise<void>$ O O O O O O O O O $Launcher$ O $Set<Launcher>$ O O O O O $Launcher$ O $Promise<{}>$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $Promise$ O $Options$ O O O O O $any$ O O $Options$ O $boolean$ O $T$ O $Options$ O $boolean$ O O O O O $Launcher$ O O $any$ O $Options$ O O O O $Options$ O $boolean$ O $Set<Launcher>$ O $number$ O O O O $any$ O $any$ O O O $Promise<void>$ O O O $Set<Launcher>$ O $Set<Launcher>$ O $Launcher$ O O O $Launcher$ O $complex$ O O O O $Promise<{}>$ O O O O O O $Set<Launcher>$ O $boolean$ O $Launcher$ O O O O $Set<Launcher>$ O $number$ O O O O $any$ O $any$ O O O $Promise<void>$ O O O O $Launcher$ O $Promise<{}>$ O O O O O O O $number$ O $Launcher$ O $number$ O O $number$ O $Launcher$ O $number$ O O $Promise<{}>$ O $any$ O $Launcher$ O $any$ O O O O O $any$ O O $boolean$ O O O O $string$ O O O O $string$ O O O O $number$ O O O O O $number$ O O O O O $string$ O O O O O $boolean$ O O O O O $string[]$ O O O O O O $number$ O O O O O $number$ O O O O $number$ O O O O $any$ O O $any$ O O $RimrafModule$ O $any$ O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $complex$ O O O $string$ O O O O O O O $any$ O O $any$ O $any$ O $string$ O O O O $number$ O O O O $number$ O O O O O O O $Options$ O O O O $ModuleOverrides$ O O O O O O O $any$ O $ModuleOverrides$ O $any$ O $any$ O O O $RimrafModule$ O $ModuleOverrides$ O $RimrafModule$ O $any$ O O O $any$ O $ModuleOverrides$ O $any$ O $any$ O $any$ O $any$ O $T$ O O O $Options$ O O O O O O O O O $string$ O $T$ O O O $Options$ O $string$ O O O O O O $string[]$ O $T$ O O O $Options$ O $string[]$ O O O O O O O $number$ O $T$ O O O $Options$ O $number$ O O O O O O $string$ O O O $Options$ O $string$ O O O $boolean$ O $T$ O O O $Options$ O $boolean$ O O O O O O $number$ O $T$ O O O $Options$ O $number$ O O O O O O $number$ O $T$ O O O $Options$ O $number$ O O O O O O $complex$ O $T$ O $Options$ O $complex$ O $ObjectConstructor$ O O O O O O $any$ O $any$ O O O O O O O O $Options$ O $complex$ O O O O O O O O O $Options$ O $boolean$ O O O O $boolean$ O O O O O $string$ O $undefined$ O O O O O O $any$ O O O O O O O O O $boolean$ O O O O O $string$ O O O $Options$ O $string$ O O O O O $string[]$ O O O O $string[]$ O O O $boolean$ O O O O $complex$ O $string[]$ O O O $string[]$ O $number$ O O O O O O $any$ O O O O O O $string[]$ O $number$ O O O O O O O O O O $boolean$ O O $string[]$ O $number$ O O O O O $string[]$ O $number$ O O O O $string[]$ O O $string[]$ O $number$ O O O $string$ O O O $string[]$ O O O $string[]$ O O O O $complex$ O $string[]$ O O O O $any$ O O O O $any$ O O O O $void$ O O O O $SupportedPlatforms$ O $any$ O O O $any$ O O O O $Set<string>$ O $boolean$ O $SupportedPlatforms$ O O O O O $any$ O O O O O O $string$ O O O $string$ O O O $any$ O O O O O $number$ O O O $any$ O $any$ O O O O O O O O $number$ O O O $any$ O $any$ O O O O O O O O $string$ O O O $any$ O $any$ O O O O O O O O $boolean$ O O O O O $complex$ O O O O O O O $number$ O O O O O O $number$ O O O $number$ O O O O O O O $Promise<{}>$ O O O O O O $any$ O O $any$ O $any$ O O O O O O O O O O O O $string$ O $undefined$ O O O $string[]$ O O $any$ O $any$ O O O $any$ O O O O O O $string[]$ O $number$ O O O O O O $any$ O O O O O O $string$ O $string[]$ O O O O O O O O O O $boolean$ O O O O $void$ O O O O O O $number$ O O O O $Promise<any>$ O O O $string$ O O O $PromiseConstructor$ O $complex$ O O O O O O $Promise<any>$ O $string$ O O O $Promise<any>$ O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O O $number$ O O $Promise<number>$ O O O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $string$ O O O $string[]$ O O $boolean$ O O O $complex$ O O O O O O $number$ O O O $number$ O O $complex$ O O O $complex$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O $Promise<any>$ O O O O $Promise<unknown>$ O O O O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $Promise$ O O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O O $number$ O O O $any$ O $any$ O O O $any$ O O O O $void$ O $any$ O O $void$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $void$ O $any$ O O $void$ O O O O O O O O O O $Promise<unknown>$ O O O O $this$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $number$ O O O O $string$ O O O O $void$ O O O O O O O $number$ O O O O $any$ O $any$ O O O $string$ O O O $number$ O O $string$ O O O $any$ O $any$ O O O $string$ O O $this$ O $Promise<{}>$ O O O O O O O O O $any$ O $any$ O O O $string$ O O O O $void$ O O O O O O $complex$ O $any$ O O O O $number$ O $this$ O $number$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $void$ O $any$ O O O $Promise<unknown>$ O $this$ O $number$ O O O O $void$ O O O O O O O $void$ O O O O O O O $Promise<{}>$ O O O O O $PromiseConstructor$ O O O O O O $void$ O $void$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O $Promise<unknown>$ O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O O O O $boolean$ O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O $void$ O O $ErrorConstructor$ O $string$ O O O O O O O $void$ O O O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O O O O O $string$ O $undefined$ O O O $Options$ O $complex$ O $undefined$ O O O $void$ O O O O O O O O $number$ O O O O $any$ O $any$ O O O $number$ O O O O O $number$ O O O O O O $number$ O O O O $any$ O $any$ O O O $number$ O O O O O $number$ O O O O $RimrafModule$ O O O $string$ O O O O $void$ O O O O O O O O O O O O $any$ O O O $any$ O $Promise<LaunchedChrome>$ O O
export * from 's' ;	O O O O O
's' ; import { Launcher , Options } from 's' ; import { DEFAULT_FLAGS } from 's' ; import { spy , stub } from 's' ; import * as assert from 's' ; const log = require ( 's' ) ; const fsMock = { openSync : ( ) => { } , closeSync : ( ) => { } , writeFileSync : ( ) => { } } ; const launchChromeWithOpts = async ( opts = { } ) => { const spawnStub = stub ( ) . returns ( { pid : 's' } ) ; const chromeInstance = new Launcher ( opts , { fs : fsMock as any , rimraf : spy ( ) as any , spawn : spawnStub as any } ) ; stub ( chromeInstance , 's' ) . returns ( Promise . resolve ( ) ) ; chromeInstance . prepare ( ) ; try { await chromeInstance . launch ( ) ; return Promise . resolve ( spawnStub ) ; } catch ( err ) { return Promise . reject ( err ) ; } } ; describe ( 's' , ( ) => { beforeEach ( ( ) => { log . setLevel ( 's' ) ; } ) ; afterEach ( ( ) => { log . setLevel ( 's' ) ; } ) ; it ( 's' , async ( ) => { const spawnStub = await launchChromeWithOpts ( { userDataDir : 's' } ) ; const chromeFlags = spawnStub . getCall ( 0 ) . args [ 0 ] as string [ ] ; assert . ok ( chromeFlags . find ( f => f . startsWith ( 's' ) ) ) assert . ok ( chromeFlags . find ( f => f . startsWith ( 's' ) ) ) assert . strictEqual ( chromeFlags [ chromeFlags . length - 0 ] , 's' ) ; } ) ; it ( 's' , async ( ) => { const rimrafMock = spy ( ) ; const chromeInstance = new Launcher ( { userDataDir : 's' } , { fs : fsMock as any , rimraf : rimrafMock as any } ) ; chromeInstance . prepare ( ) ; await chromeInstance . destroyTmp ( ) ; assert . strictEqual ( rimrafMock . callCount , 0 ) ; } ) ; it ( 's' , async ( ) => { const rimrafMock = stub ( ) . callsFake ( ( _ , done ) => done ( ) ) ; const chromeInstance = new Launcher ( { } , { fs : fsMock as any , rimraf : rimrafMock as any } ) ; chromeInstance . prepare ( ) ; await chromeInstance . destroyTmp ( ) ; assert . strictEqual ( rimrafMock . callCount , 0 ) ; } ) ; it ( 's' , ( ) => { const chromeInstance = new Launcher ( { userDataDir : 's' } , { fs : fsMock as any } ) ; chromeInstance . prepare ( ) ; assert . equal ( chromeInstance . userDataDir , 's' ) ; } ) ; it ( 's' , ( ) => { const chromeInstance = new Launcher ( { } , { fs : fsMock as any } ) ; const originalMakeTmp = chromeInstance . makeTmpDir ; chromeInstance . makeTmpDir = ( ) => 's' chromeInstance . prepare ( ) assert . equal ( chromeInstance . userDataDir , 's' ) ; chromeInstance . makeTmpDir = originalMakeTmp ; } ) ; it ( 's' , async ( ) => { const chromeInstance = new Launcher ( ) ; await chromeInstance . launch ( ) ; await chromeInstance . kill ( ) ; await chromeInstance . kill ( ) ; } ) ; it ( 's' , async ( ) => { const chromeInstance = new Launcher ( ) ; await chromeInstance . launch ( ) ; let pid = chromeInstance . pid ! ; await chromeInstance . launch ( ) ; assert . strictEqual ( pid , chromeInstance . pid ) ; await chromeInstance . kill ( ) ; } ) ; it ( 's' , async ( ) => { const flags = Launcher . defaultFlags ( ) ; assert . ok ( flags . length ) ; assert . deepStrictEqual ( flags , DEFAULT_FLAGS ) ; } ) ; it ( 's' , async ( ) => { const flags = Launcher . defaultFlags ( ) ; flags . push ( 's' ) ; const currentDefaultFlags = Launcher . defaultFlags ( ) . slice ( ) ; assert . notDeepStrictEqual ( flags , currentDefaultFlags ) ; } ) ; it ( 's' , async ( ) => { const originalDefaultFlags = Launcher . defaultFlags ( ) . slice ( ) ; await launchChromeWithOpts ( ) ; const currentDefaultFlags = Launcher . defaultFlags ( ) . slice ( ) ; assert . deepStrictEqual ( originalDefaultFlags , currentDefaultFlags ) ; } ) ; it ( 's' , async ( ) => { const spawnStub = await launchChromeWithOpts ( { ignoreDefaultFlags : true } ) ; const chromeFlags = spawnStub . getCall ( 0 ) . args [ 0 ] as string [ ] ; assert . ok ( ! chromeFlags . includes ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const spawnStub = await launchChromeWithOpts ( ) ; const chromeFlags = spawnStub . getCall ( 0 ) . args [ 0 ] as string [ ] ; assert . ok ( ! chromeFlags . includes ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const spawnStub = await launchChromeWithOpts ( ) ; const spawnOptions = spawnStub . getCall ( 0 ) . args [ 0 ] as { env : { } } ; assert . deepEqual ( spawnOptions . env , Object . assign ( { } , process . env ) ) ; } ) ; it ( 's' , async ( ) => { const envVars = { 's' : 's' } ; const spawnStub = await launchChromeWithOpts ( { envVars } ) ; const spawnOptions = spawnStub . getCall ( 0 ) . args [ 0 ] as { env : { } } ; assert . deepEqual ( spawnOptions . env , envVars ) ; } ) ; it ( 's' , async ( ) => { const spawnStub = await launchChromeWithOpts ( { ignoreDefaultFlags : true , chromeFlags : [ 's' , 's' , 's' ] } ) ; const chromeFlags = spawnStub . getCall ( 0 ) . args [ 0 ] as string [ ] ; assert . ok ( chromeFlags . includes ( 's' ) ) ; assert . ok ( chromeFlags . includes ( 's' ) ) ; assert . ok ( ! chromeFlags . includes ( 's' ) ) ; assert . ok ( ! chromeFlags . includes ( 's' ) ) ; } ) ; it ( 's' , ( done ) => { const chromeInstance = new Launcher ( { chromePath : 's' } ) ; chromeInstance . launch ( ) . catch ( ( ) => done ( ) ) ; } ) ; } ) ;	O O O O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $complex$ O O $void$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O O O O $Promise<any>$ O O O $Options$ O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O O O O $Launcher$ O O $any$ O $Options$ O O $any$ O $complex$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $Launcher$ O O O O $any$ O $PromiseConstructor$ O $complex$ O O O O $Launcher$ O $void$ O O O O O O $Launcher$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O $any$ O O O O O $any$ O O O $PromiseConstructor$ O $Promise<T>$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O $string$ O O O O O O $string[]$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $string[]$ O $complex$ O $string$ O $string$ O $boolean$ O O O O O $any$ O $any$ O $string[]$ O $complex$ O $string$ O $string$ O $boolean$ O O O O O $any$ O $any$ O $string[]$ O $string[]$ O $number$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Launcher$ O O $any$ O O $string$ O O O O O $any$ O $complex$ O O O $any$ O $any$ O O O O O $Launcher$ O $void$ O O O O $Launcher$ O $Promise<unknown>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O O O $Launcher$ O O $any$ O O O O O $any$ O $complex$ O O O $any$ O $any$ O O O O O $Launcher$ O $void$ O O O O $Launcher$ O $Promise<unknown>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Launcher$ O O $any$ O O $string$ O O O O O $any$ O $complex$ O O O O O $Launcher$ O $void$ O O O $any$ O $any$ O $Launcher$ O $string$ O O O O O O O $any$ O O O O O O O O $Launcher$ O O $any$ O O O O O $any$ O $complex$ O O O O O O $any$ O $Launcher$ O $any$ O $Launcher$ O $any$ O O O O O $Launcher$ O $void$ O O $any$ O $any$ O $Launcher$ O $string$ O O O O $Launcher$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $Launcher$ O O $any$ O O O O $Launcher$ O $complex$ O O O O $Launcher$ O $Promise<{}>$ O O O O $Launcher$ O $Promise<{}>$ O O O O O O $any$ O O O O O O O O O $Launcher$ O O $any$ O O O O $Launcher$ O $complex$ O O O O $number$ O $Launcher$ O $number$ O O O $Launcher$ O $complex$ O O O $any$ O $any$ O $number$ O $Launcher$ O $number$ O O O $Launcher$ O $Promise<{}>$ O O O O O O $any$ O O O O O O O O O $string[]$ O $any$ O $string[]$ O O O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $any$ O $string[]$ O $complex$ O O O O O $any$ O O O O O O O O O $string[]$ O $any$ O $string[]$ O O O $string[]$ O $number$ O O O O O $string[]$ O $any$ O $string[]$ O O O $string[]$ O O O $any$ O $any$ O $string[]$ O $string[]$ O O O O O $any$ O O O O O O O O O $string[]$ O $any$ O $string[]$ O O O $string[]$ O O O O $Promise<any>$ O O O O $string[]$ O $any$ O $string[]$ O O O $string[]$ O O O $any$ O $any$ O $string[]$ O $string[]$ O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O $true$ O O O O O O $string[]$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O $string[]$ O $boolean$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $string[]$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O $string[]$ O $boolean$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $complex$ O $any$ O $any$ O O O O $any$ O O O O O ${}$ O O O O O $any$ O $any$ O $complex$ O ${}$ O $ObjectConstructor$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $complex$ O O O O O O O O $any$ O O $Promise<any>$ O O $complex$ O O O O $complex$ O $any$ O $any$ O O O O $any$ O O O O O ${}$ O O O O O $any$ O $any$ O $complex$ O ${}$ O $complex$ O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O $true$ O O O $string[]$ O O O O O O O O O O O O $string[]$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $string[]$ O $boolean$ O O O O O $any$ O $any$ O $string[]$ O $boolean$ O O O O O $any$ O $any$ O O $string[]$ O $boolean$ O O O O O $any$ O $any$ O O $string[]$ O $boolean$ O O O O O O O O $any$ O O O O $any$ O O O O $Launcher$ O O $any$ O O $string$ O O O O O $Launcher$ O $complex$ O O O $complex$ O O O O $any$ O O O O O O O O O O
's' ; import { launch } from 's' ; import * as assert from 's' ; const log = require ( 's' ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { log . setLevel ( 's' ) ; } ) ; afterEach ( ( ) => { log . setLevel ( 's' ) ; } ) ; it ( 's' , async ( ) => { this . timeout = 0 ; const chrome = await launch ( ) ; assert . notEqual ( chrome . process , undefined ) ; assert . notEqual ( chrome . pid , undefined ) ; assert . notEqual ( chrome . port , undefined ) ; assert . notEqual ( chrome . kill , undefined ) ; await chrome . kill ( ) ; } ) ; } ) ;	O O O O $Promise<LaunchedChrome>$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O $any$ O O O O $LaunchedChrome$ O O $Promise<LaunchedChrome>$ O O O $any$ O $any$ O $LaunchedChrome$ O $any$ O $undefined$ O O $any$ O $any$ O $LaunchedChrome$ O $number$ O $undefined$ O O $any$ O $any$ O $LaunchedChrome$ O $number$ O $undefined$ O O $any$ O $any$ O $LaunchedChrome$ O $Promise<{}>$ O $undefined$ O O O $LaunchedChrome$ O $Promise<{}>$ O O O O O O O O O
's' ; import * as assert from 's' ; import { getRandomPort } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { return getRandomPort ( ) . then ( port => { assert . ok ( Number . isInteger ( port ) && port > 0 && port <= 0 ) ; } ) ; } ) ; } ) ;	O O O O O $any$ O O O O O $Promise<number>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<number>$ O O O O O $number$ O O $any$ O $any$ O $NumberConstructor$ O $boolean$ O $number$ O O $number$ O O O $number$ O O O O O O O O O O O O O
's' ; import * as assert from 's' ; import { toWinDirFormat , getLocalAppDataPath } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const wsl = 's' ; const windows = 's' ; assert . equal ( toWinDirFormat ( wsl ) , windows ) ; } ) ; it ( 's' , ( ) => { const wsl = 's' ; const windows = 's' ; assert . equal ( toWinDirFormat ( wsl ) , windows ) ; } ) ; it ( 's' , ( ) => { const path = 's' ; const appDataPath = 's' ; assert . equal ( getLocalAppDataPath ( path ) , appDataPath ) ; } ) ; } ) ;	O O O O O $any$ O O O O O $string$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O O O O