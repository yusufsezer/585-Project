export const defaultModules = { toolbar : [ [ 's' , 's' , 's' , 's' ] , [ 's' , 's' ] , [ { header : 0 } , { header : 0 } ] , [ { list : 's' } , { list : 's' } ] , [ { script : 's' } , { script : 's' } ] , [ { indent : 's' } , { indent : 's' } ] , [ { direction : 's' } ] , [ { size : [ 's' , false , 's' , 's' ] } ] , [ { header : [ 0 , 0 , 0 , 0 , 0 , 0 , false ] } ] , [ { color : [ ] } , { background : [ ] } ] , [ { font : [ ] } ] , [ { align : [ ] } ] , [ 's' ] , [ 's' , 's' , 's' ] ] }	O O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O O O O $number$ O O O O O $number$ O O O O O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O O $complex$ O O O O O O O O O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O $undefined[]$ O O O O O O $undefined[]$ O O O O O O O O $undefined[]$ O O O O O O O O $undefined[]$ O O O O O O O O O O O O O O O O O O O
import { InjectionToken } from 's' export type QuillToolbarConfig = Array < Array < string | { indent ? : string list ? : string direction ? : string header ? : number | Array < boolean | number > color ? : string [ ] | string background ? : string [ ] | string align ? : string [ ] | string script ? : string font ? : string [ ] | string size ? : Array < boolean | string > } > > export interface QuillModules { [ key ] : any clipboard ? : { matchers ? : any [ ] matchVisual ? : boolean } | boolean history ? : { delay ? : number maxStack ? : number userOnly ? : boolean } | boolean keyboard ? : { bindings ? : any } | boolean syntax ? : boolean toolbar ? : QuillToolbarConfig | string | { container ? : string | string [ ] | QuillToolbarConfig handlers ? : { [ key ] : any } } | boolean } export type QuillFormat = 's' | 's' | 's' | 's' export interface QuillConfig { bounds ? : HTMLElement | string debug ? : 's' | 's' | 's' | false format ? : QuillFormat formats ? : string [ ] modules ? : QuillModules placeholder ? : string readOnly ? : boolean scrollingContainer ? : HTMLElement | string | null theme ? : string trackChanges ? : 's' | 's' } export const QUILL_CONFIG_TOKEN = new InjectionToken < QuillConfig > ( 's' )	O O $any$ O O O O O $any$ O $ArrayConstructor$ O $ArrayConstructor$ O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O O $ArrayConstructor$ O O O O O $complex$ O O O O O O O $complex$ O O O O O O O $complex$ O O O O O O O $string$ O O O $complex$ O O O O O O O $complex$ O O $ArrayConstructor$ O O O O O O O O O O $any$ O O $string$ O O O $complex$ O O O $any[]$ O O O O O $boolean$ O O O O O O $complex$ O O O $number$ O O O $number$ O O O $boolean$ O O O O O O $complex$ O O O $any$ O O O O O O $boolean$ O O O $complex$ O O $any$ O O O O $complex$ O O O O O O O O $any$ $complex$ O O O O $string$ O O O O O O O O O O $any$ O O O O O O O O O O $any$ O $complex$ O O $complex$ O O $complex$ O O O O O O O O O $QuillFormat$ O O $any$ $string[]$ O O O O O $QuillModules$ O O $any$ $string$ O O O $boolean$ O O O $complex$ O O $complex$ O O O O $string$ O O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O
import { DOCUMENT , isPlatformServer } from 's' import { DomSanitizer } from 's' import { QUILL_CONFIG_TOKEN , QuillConfig , QuillFormat , QuillModules } from 's' import { AfterViewInit , Component , ElementRef , EventEmitter , forwardRef , Inject , Input , NgZone , OnChanges , OnDestroy , Output , PLATFORM_ID , 0 , SecurityContext , SimpleChanges , ViewEncapsulation } from 's' import { ControlValueAccessor , NG_VALIDATORS , NG_VALUE_ACCESSOR , Validator } from 's' import { defaultModules } from 's' declare const require let Quill = null export interface CustomOption { import : string whitelist : any [ ] } export interface Range { index : number length : number } const getFormat = ( format ? , configFormat ? ) : QuillFormat => { const passedFormat = format || configFormat return passedFormat || 's' } @ Component ( { encapsulation : ViewEncapsulation . None , providers : [ { multi : true , provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => QuillEditorComponent ) } , { multi : true , provide : NG_VALIDATORS , useExisting : forwardRef ( ( ) => QuillEditorComponent ) } ] , selector : 's' , template : `template` } ) export class QuillEditorComponent implements AfterViewInit , ControlValueAccessor , OnChanges , OnDestroy , Validator { static normalizeClassNames ( classes ) : string [ ] { const classList = classes . trim ( ) . split ( 's' ) return classList . reduce ( ( prev : string [ ] , cur ) => { const trimmed = cur . trim ( ) if ( trimmed ) { prev . push ( trimmed ) } return prev } , [ ] ) } quillEditor : any editorElem : HTMLElement | undefined content : any @ Input ( ) format ? : 's' | 's' | 's' | 's' @ Input ( ) theme ? : string @ Input ( ) modules ? : QuillModules @ Input ( ) debug ? : 's' | 's' | 's' | false @ Input ( ) readOnly ? : boolean @ Input ( ) placeholder ? : string @ Input ( ) maxLength ? : number @ Input ( ) minLength ? : number @ Input ( ) required = false @ Input ( ) formats ? : string [ ] | null @ Input ( ) customToolbarPosition : 's' | 's' = 's' @ Input ( ) sanitize = false @ Input ( ) styles : any = null @ Input ( ) strict = true @ Input ( ) scrollingContainer ? : HTMLElement | string | null @ Input ( ) bounds ? : HTMLElement | string @ Input ( ) customOptions : CustomOption [ ] = [ ] @ Input ( ) trackChanges ? : 's' | 's' @ Input ( ) preserveWhitespace = false @ Input ( ) classes ? : string @ Output ( ) onEditorCreated : EventEmitter < any > = new EventEmitter ( ) @ Output ( ) onEditorChanged : EventEmitter < { content : any delta : any editor : any event : 's' html : string | null oldDelta : any source : string text : string } | { editor : any event : 's' oldRange : Range | null range : Range | null source : string } > = new EventEmitter ( ) @ Output ( ) onContentChanged : EventEmitter < { content : any delta : any editor : any html : string | null oldDelta : any source : string text : string } > = new EventEmitter ( ) @ Output ( ) onSelectionChanged : EventEmitter < { editor : any oldRange : Range | null range : Range | null source : string } > = new EventEmitter ( ) @ Output ( ) onFocus : EventEmitter < { editor : any source : string } > = new EventEmitter ( ) @ Output ( ) onBlur : EventEmitter < { editor : any source : string } > = new EventEmitter ( ) disabled = false constructor ( @ Inject ( ElementRef ) private elementRef , private domSanitizer , @ Inject ( DOCUMENT ) private doc , @ Inject ( PLATFORM_ID ) private platformId , private renderer , private zone , @ Inject ( QUILL_CONFIG_TOKEN ) private config ) { } onModelChange ( _modelValue ? ) { } onModelTouched ( ) { } @ Input ( ) valueGetter = ( quillEditor , editorElement ) : string | any => { let html : string | null = editorElement . querySelector ( 's' ) ! . innerHTML if ( html === 's' || html === 's' ) { html = null } let modelValue = html const format = getFormat ( this . format , this . config . format ) if ( format === 's' ) { modelValue = quillEditor . getText ( ) } else if ( format === 's' ) { modelValue = quillEditor . getContents ( ) } else if ( format === 's' ) { try { modelValue = JSON . stringify ( quillEditor . getContents ( ) ) } catch ( e ) { modelValue = quillEditor . getText ( ) } } return modelValue } @ Input ( ) valueSetter = ( quillEditor , value ) : any => { const format = getFormat ( this . format , this . config . format ) if ( format === 's' ) { if ( this . sanitize ) { value = this . domSanitizer . sanitize ( SecurityContext . HTML , value ) } return quillEditor . clipboard . convert ( value ) } else if ( format === 's' ) { try { return JSON . parse ( value ) } catch ( e ) { return [ { insert : value } ] } } return value } ngAfterViewInit ( ) { if ( isPlatformServer ( this . platformId ) ) { return } if ( ! Quill ) { Quill = require ( 's' ) } this . elementRef . nativeElement . insertAdjacentHTML ( this . customToolbarPosition === 's' ? 's' : 's' , this . preserveWhitespace ? 's' : 's' ) this . editorElem = this . elementRef . nativeElement . querySelector ( 's' ) const toolbarElem = this . elementRef . nativeElement . querySelector ( 's' ) const modules = Object . assign ( { } , this . modules || ( this . config . modules || defaultModules ) ) if ( toolbarElem ) { modules . toolbar = toolbarElem } else if ( modules . toolbar === undefined ) { modules . toolbar = defaultModules . toolbar } let placeholder = this . placeholder !== undefined ? this . placeholder : this . config . placeholder if ( placeholder === undefined ) { placeholder = 's' } if ( this . styles ) { Object . keys ( this . styles ) . forEach ( ( key ) => { this . renderer . setStyle ( this . editorElem , key , this . styles [ key ] ) } ) } if ( this . classes ) { this . addClasses ( this . classes ) } this . customOptions . forEach ( ( customOption ) => { const newCustomOption = Quill . import ( customOption . import ) newCustomOption . whitelist = customOption . whitelist Quill . register ( newCustomOption , true ) } ) let bounds = this . bounds && this . bounds === 's' ? this . editorElem : this . bounds if ( ! bounds ) { bounds = this . config . bounds ? this . config . bounds : this . doc . body } let debug = this . debug if ( ! debug && debug !== false && this . config . debug ) { debug = this . config . debug } let readOnly = this . readOnly if ( ! readOnly && this . readOnly !== false ) { readOnly = this . config . readOnly !== undefined ? this . config . readOnly : false } let scrollingContainer = this . scrollingContainer if ( ! scrollingContainer && this . scrollingContainer !== null ) { scrollingContainer = this . config . scrollingContainer === null || this . config . scrollingContainer ? this . config . scrollingContainer : null } let formats = this . formats if ( ! formats && formats === undefined ) { formats = this . config . formats ? [ ... this . config . formats ] : ( this . config . formats === null ? null : undefined ) } this . quillEditor = new Quill ( this . editorElem , { bounds , debug , formats , modules , placeholder , readOnly , scrollingContainer , strict : this . strict , theme : this . theme || ( this . config . theme ? this . config . theme : 's' ) } ) if ( this . content ) { const format = getFormat ( this . format , this . config . format ) if ( format === 's' ) { this . quillEditor . setContents ( this . content , 's' ) } else if ( format === 's' ) { this . quillEditor . setText ( this . content , 's' ) } else if ( format === 's' ) { try { this . quillEditor . setContents ( JSON . parse ( this . content ) , 's' ) } catch ( e ) { this . quillEditor . setText ( this . content , 's' ) } } else { if ( this . sanitize ) { this . content = this . domSanitizer . sanitize ( SecurityContext . HTML , this . content ) } const contents = this . quillEditor . clipboard . convert ( this . content ) this . quillEditor . setContents ( contents , 's' ) } this . quillEditor . history . clear ( ) } this . setDisabledState ( ) this . quillEditor . on ( 's' , this . editorChangeHandler ) this . quillEditor . on ( 's' , this . selectionChangeHandler ) this . quillEditor . on ( 's' , this . textChangeHandler ) setTimeout ( ( ) => this . onEditorCreated . emit ( this . quillEditor ) ) } selectionChangeHandler = ( range : Range | null , oldRange : Range | null , source ) => { this . zone . run ( ( ) => { if ( range === null ) { this . onBlur . emit ( { editor : this . quillEditor , source } ) } else if ( oldRange === null ) { this . onFocus . emit ( { editor : this . quillEditor , source } ) } this . onSelectionChanged . emit ( { editor : this . quillEditor , oldRange , range , source } ) if ( ! range && this . onModelTouched ) { this . onModelTouched ( ) } } ) } textChangeHandler = ( delta , oldDelta , source ) : void => { const text = this . quillEditor . getText ( ) const content = this . quillEditor . getContents ( ) let html : string | null = this . editorElem ! . querySelector ( 's' ) ! . innerHTML if ( html === 's' || html === 's' ) { html = null } this . zone . run ( ( ) => { const trackChanges = this . trackChanges || this . config . trackChanges if ( ( source === Quill . sources . USER || trackChanges && trackChanges === 's' ) && this . onModelChange ) { this . onModelChange ( this . valueGetter ( this . quillEditor , this . editorElem ! ) ) } this . onContentChanged . emit ( { content , delta , editor : this . quillEditor , html , oldDelta , source , text } ) } ) } editorChangeHandler = ( event : 's' | 's' , current : any | Range | null , old : any | Range | null , source ) : void => { if ( event === 's' ) { const text = this . quillEditor . getText ( ) const content = this . quillEditor . getContents ( ) let html : string | null = this . editorElem ! . querySelector ( 's' ) ! . innerHTML if ( html === 's' || html === 's' ) { html = null } this . zone . run ( ( ) => { this . onEditorChanged . emit ( { content , delta : current , editor : this . quillEditor , event , html , oldDelta : old , source , text } ) } ) } else { this . onEditorChanged . emit ( { editor : this . quillEditor , event , oldRange : old , range : current , source } ) } } ngOnDestroy ( ) { if ( this . quillEditor ) { this . quillEditor . off ( 's' , this . selectionChangeHandler ) this . quillEditor . off ( 's' , this . textChangeHandler ) this . quillEditor . off ( 's' , this . editorChangeHandler ) } } ngOnChanges ( changes ) { if ( ! this . quillEditor ) { return } if ( changes [ 's' ] ) { this . quillEditor . enable ( ! changes [ 's' ] . currentValue ) } if ( changes [ 's' ] ) { this . quillEditor . root . dataset . placeholder = changes [ 's' ] . currentValue } if ( changes [ 's' ] ) { const currentStyling = changes [ 's' ] . currentValue const previousStyling = changes [ 's' ] . previousValue if ( previousStyling ) { Object . keys ( previousStyling ) . forEach ( ( key ) => { this . renderer . removeStyle ( this . editorElem , key ) } ) } if ( currentStyling ) { Object . keys ( currentStyling ) . forEach ( ( key ) => { this . renderer . setStyle ( this . editorElem , key , this . styles [ key ] ) } ) } } if ( changes [ 's' ] ) { const currentClasses = changes [ 's' ] . currentValue const previousClasses = changes [ 's' ] . previousValue if ( previousClasses ) { this . removeClasses ( previousClasses ) } if ( currentClasses ) { this . addClasses ( currentClasses ) } } } addClasses ( classList ) { QuillEditorComponent . normalizeClassNames ( classList ) . forEach ( ( c ) => { this . renderer . addClass ( this . editorElem , c ) } ) } removeClasses ( classList ) { QuillEditorComponent . normalizeClassNames ( classList ) . forEach ( ( c ) => { this . renderer . removeClass ( this . editorElem , c ) } ) } writeValue ( currentValue ) { this . content = currentValue const format = getFormat ( this . format , this . config . format ) if ( this . quillEditor ) { if ( currentValue ) { if ( format === 's' ) { this . quillEditor . setText ( currentValue ) } else { this . quillEditor . setContents ( this . valueSetter ( this . quillEditor , this . content ) ) } return } this . quillEditor . setText ( 's' ) } } setDisabledState ( isDisabled = this . disabled ) { this . disabled = isDisabled if ( this . quillEditor ) { if ( isDisabled ) { this . quillEditor . disable ( ) this . renderer . setAttribute ( this . elementRef . nativeElement , 's' , 's' ) } else { if ( ! this . readOnly ) { this . quillEditor . enable ( ) } this . renderer . removeAttribute ( this . elementRef . nativeElement , 's' ) } } } registerOnChange ( fn : ( modelValue ) => void ) { this . onModelChange = fn } registerOnTouched ( fn : ( ) => void ) { this . onModelTouched = fn } validate ( ) { if ( ! this . quillEditor ) { return null } const err : { minLengthError ? : { given : number minLength : number } maxLengthError ? : { given : number maxLength : number } requiredError ? : { empty : boolean } } = { } let valid = true const textLength = this . quillEditor . getText ( ) . trim ( ) . length if ( this . minLength && textLength && textLength < this . minLength ) { err . minLengthError = { given : textLength , minLength : this . minLength } valid = false } if ( this . maxLength && textLength > this . maxLength ) { err . maxLengthError = { given : textLength , maxLength : this . maxLength } valid = false } if ( this . required && ! textLength ) { err . requiredError = { empty : true } valid = false } return valid ? null : err } }	O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O O O O $any$ O $any$ O O O O $any$ O $string$ O O $any[]$ O O O O O O O $any$ O $number$ O O $number$ O O O O $QuillFormat$ O O $QuillFormat$ $QuillFormat$ O $QuillFormat$ $QuillFormat$ O O $any$ O O O $QuillFormat$ O $QuillFormat$ O $QuillFormat$ O $QuillFormat$ O O O O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string[]$ O $string$ O O O O O O O $string[]$ O $string$ O $string$ O O O $complex$ O O O O $string[]$ O $complex$ O O $string[]$ O O O O O $string$ O O O O $string$ O $string$ O $string$ O O O O $string$ O O $string[]$ O $number$ O $string$ O O O $string[]$ O O O O O O $any$ O O $HTMLElement$ O $complex$ O O $any$ O O O $any$ O O $QuillFormat$ O O O O O O O O O O $any$ O O $string$ O O O O $any$ O O $QuillModules$ O O $any$ O $any$ O O $complex$ O O O O O O O O O O $any$ O O $boolean$ O O O O $any$ O O $string$ O O O O $any$ O O $number$ O O O O $any$ O O $number$ O O O O $any$ O O $boolean$ O O O $any$ O O $string[]$ O O O O O O O O $any$ O O O O O O O O O O $any$ O O $boolean$ O O O $any$ O O $any$ O O O O O $any$ O O $boolean$ O O O $any$ O O $complex$ O O $complex$ O O O O O $any$ O O $complex$ O O $complex$ O O O $any$ O O $CustomOption[]$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $boolean$ O O O $any$ O O $string$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O O O O $string$ O O O O $any$ O O $string$ O O $string$ O O O O O $any$ O O O O O $Range$ O $any$ O O $Range$ O $any$ O O $string$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O $string$ O O O O $any$ O O $string$ O O $string$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O $Range$ O $any$ O O $Range$ O $any$ O O $string$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $ElementRef$ O O $DomSanitizer$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $Renderer2$ O O $NgZone$ O O $any$ O $any$ O O $QuillConfig$ O O O $void$ O $any$ $any$ O O O $void$ O O O O O $any$ O O $any$ O O $any$ O $HTMLElement$ O O O O O O O O $string$ O O O O O $HTMLElement$ O O O O O O O $string$ O O $string$ O O O $string$ O O O O $string$ O O O O $string$ O $string$ O $QuillFormat$ O $QuillFormat$ O O O $QuillFormat$ O O O $QuillConfig$ O $QuillFormat$ O O O $QuillFormat$ O O O O $string$ O $any$ O $any$ O O O O O O O O O O O $string$ O $any$ O $any$ O O O O O O O O O O O O O $string$ O $JSON$ O $complex$ O $any$ O $any$ O O O O O O $any$ O O $string$ O $any$ O $any$ O O O O O $string$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O O $QuillFormat$ O $QuillFormat$ O O O $QuillFormat$ O O O $QuillConfig$ O $QuillFormat$ O O O $QuillFormat$ O O O O O O O O $boolean$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $JSON$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $void$ O O O O O $any$ O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $boolean$ O O O O O O O $HTMLElement$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $ObjectConstructor$ O O O O O O O O $QuillModules$ O O O O $QuillConfig$ O $QuillModules$ O $complex$ O O O O $any$ O O $complex$ O $complex$ O $any$ O O O O $complex$ O $complex$ O $undefined$ O O $complex$ O $complex$ O $complex$ O $complex$ O O $string$ O O O $string$ O $undefined$ O O O $string$ O O O $QuillConfig$ O $string$ O O $string$ O $undefined$ O O $string$ O O O O O O O $any$ O O $ObjectConstructor$ O $complex$ O O O $any$ O O $void$ O O $string$ O O O O O $any$ O $any$ O O O $HTMLElement$ O $string$ O O O $any$ O $string$ O O O O O O O O O $string$ O O O O $void$ O O O $string$ O O O O $CustomOption[]$ O $void$ O O $CustomOption$ O O O O $any$ O $any$ O $any$ O $CustomOption$ O $string$ O $any$ O $any$ O $CustomOption$ O $any[]$ $any$ O $any$ O $any$ O O O O O O $complex$ O O O $complex$ O O O $complex$ O O O O O $HTMLElement$ O O O $complex$ O O O $complex$ O O $complex$ O O O $QuillConfig$ O $complex$ O O O $QuillConfig$ O $complex$ O O O $any$ O $any$ O O $complex$ O O O $complex$ O O O $complex$ O $complex$ O O O O O $QuillConfig$ O $complex$ O O $complex$ O O O $QuillConfig$ O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O $boolean$ O O O $QuillConfig$ O $boolean$ O $undefined$ O O O $QuillConfig$ O $boolean$ O O O O $complex$ O O O $complex$ O O O $complex$ O O O $complex$ O O O O $complex$ O O O $QuillConfig$ O $complex$ O O O O O $QuillConfig$ O $complex$ O O O $QuillConfig$ O $complex$ O O O O $string[]$ O O O $string[]$ O O O $string[]$ O $string[]$ O $undefined$ O O $string[]$ O O O $QuillConfig$ O $string[]$ O O O O O $QuillConfig$ O $string[]$ O O O O O $QuillConfig$ O $string[]$ O O O O O $undefined$ O O O O $any$ O O $any$ O O O $HTMLElement$ O O $complex$ O $complex$ O $string[]$ O $complex$ O $string$ O $boolean$ O $complex$ O $boolean$ O O O $boolean$ O $string$ O O O $string$ O O O O $QuillConfig$ O $string$ O O O $QuillConfig$ O $string$ O O O O O O O O O $any$ O O O $QuillFormat$ O $QuillFormat$ O O O $QuillFormat$ O O O $QuillConfig$ O $QuillFormat$ O O O $QuillFormat$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O $JSON$ O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $boolean$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $void$ O O O O $any$ O $any$ O O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O $number$ O O O O O O $any$ O $any$ O O O $any$ O O O $void$ O O $Range$ O $any$ O O O $Range$ O $any$ O O O $string$ O O O O O $any$ O $any$ O O O O O O O $Range$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $string$ O O O O O O $Range$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $string$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O $Range$ O $Range$ O $string$ O O O O O $Range$ O O O $void$ O O O O $void$ O O O O O O $void$ O O $any$ O $any$ O $string$ O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O O O O O O O $HTMLElement$ O O O O O O O O $string$ O O $string$ O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O $QuillConfig$ O O O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O O O O $void$ O O O $any$ O O O $any$ O O O $HTMLElement$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $string$ O $any$ O $string$ O $any$ O O O O O $void$ O O O O O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $string$ O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O O O O O O O $HTMLElement$ O O O O O O O O $string$ O O $string$ O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $void$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O O O $void$ O $SimpleChanges$ O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O $ObjectConstructor$ O $complex$ O $any$ O O $void$ O O $string$ O O O O O $any$ O $any$ O O O $HTMLElement$ O $string$ O O O O O O $any$ O O $ObjectConstructor$ O $complex$ O $any$ O O $void$ O O $string$ O O O O O $any$ O $any$ O O O $HTMLElement$ O $string$ O O O $any$ O $string$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $void$ O $any$ O O O O $any$ O O O O $void$ O $any$ O O O O $void$ O $string$ O O $any$ O $string[]$ O $string$ O O $void$ O O $string$ O O O O O $any$ O $any$ O O O $HTMLElement$ O $string$ O O O O $void$ O $string$ O O $any$ O $string[]$ O $string$ O O $void$ O O $string$ O O O O O $any$ O $any$ O O O $HTMLElement$ O $string$ O O O O $void$ O $any$ O O O O $any$ O $any$ O $QuillFormat$ O $QuillFormat$ O O O $QuillFormat$ O O O $QuillConfig$ O $QuillFormat$ O O O O O $any$ O O O O $any$ O O O O $QuillFormat$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O $void$ O $boolean$ O O O $boolean$ O O O O $boolean$ O $boolean$ O O O O $any$ O O O O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $void$ O $void$ O O $any$ O O O O O O O $void$ O $void$ O $void$ O $void$ O O O O O O O O O $void$ O $void$ O $complex$ O O O O O O O O $any$ O O O O O O $complex$ O O $complex$ O O O $number$ O O $number$ O O O $complex$ O O O $number$ O O $number$ O O O $complex$ O O O $boolean$ O O O O O O O O $boolean$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O $number$ O $any$ O $any$ O O O $number$ O O $complex$ O $complex$ O O $any$ O $any$ O $number$ O O O $number$ O $boolean$ O O O O O O O $number$ O $any$ O O O $number$ O O $complex$ O $complex$ O O $any$ O $any$ O $number$ O O O $number$ O $boolean$ O O O O O O O $boolean$ O O $any$ O O $complex$ O $complex$ O O $true$ O O O $boolean$ O O O O $boolean$ O O O $complex$ O O
import { DomSanitizer , SafeHtml } from 's' import { QUILL_CONFIG_TOKEN , QuillConfig } from 's' import { Component , Inject , Input , OnChanges , SimpleChanges , ViewEncapsulation } from 's' @ Component ( { encapsulation : ViewEncapsulation . None , selector : 's' , styles : [ `template` ] , template : `template` } ) export class QuillViewHTMLComponent implements OnChanges { innerHTML : SafeHtml = 's' themeClass = 's' @ Input ( ) content = 's' @ Input ( ) theme ? : string constructor ( private sanitizer , @ Inject ( QUILL_CONFIG_TOKEN ) private config ) { } ngOnChanges ( changes ) { if ( changes . theme ) { const theme = changes . theme . currentValue || ( this . config . theme ? this . config . theme : 's' ) this . themeClass = `template` } else if ( ! this . theme ) { const theme = this . config . theme ? this . config . theme : 's' this . themeClass = `template` } if ( changes . content ) { this . innerHTML = this . sanitizer . bypassSecurityTrustHtml ( changes . content . currentValue ) } } }	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string[]$ O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $any$ O O $string$ O O O $any$ O O $string$ O O O O O O $DomSanitizer$ O O $any$ O $any$ O O $QuillConfig$ O O O $void$ O $SimpleChanges$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $QuillConfig$ O $string$ O O O $QuillConfig$ O $string$ O O O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $QuillConfig$ O $string$ O O O $QuillConfig$ O $string$ O O O O $string$ O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O
import { isPlatformServer } from 's' import { QUILL_CONFIG_TOKEN , QuillConfig , QuillFormat , QuillModules } from 's' import { AfterViewInit , Component , ElementRef , Inject , Input , OnChanges , PLATFORM_ID , 0 , SimpleChanges , ViewEncapsulation } from 's' import { defaultModules } from 's' import { CustomOption } from 's' declare const require let Quill = null const getFormat = ( format ? , configFormat ? ) : QuillFormat => { const passedFormat = format || configFormat return passedFormat || 's' } @ Component ( { encapsulation : ViewEncapsulation . None , selector : 's' , styles : [ `template` ] , template : `template` } ) export class QuillViewComponent implements AfterViewInit , OnChanges { quillEditor : any editorElem : HTMLElement | undefined @ Input ( ) format ? : 's' | 's' | 's' | 's' @ Input ( ) theme ? : string @ Input ( ) modules ? : QuillModules @ Input ( ) debug ? : 's' | 's' | 's' | false @ Input ( ) formats ? : string [ ] | null @ Input ( ) strict = true @ Input ( ) content : any @ Input ( ) customOptions : CustomOption [ ] = [ ] @ Input ( ) preserveWhitespace = false constructor ( @ Inject ( PLATFORM_ID ) private platformId , @ Inject ( QUILL_CONFIG_TOKEN ) private config , private renderer , @ Inject ( ElementRef ) private elementRef ) { } valueSetter = ( quillEditor , value ) : any => { const format = getFormat ( this . format , this . config . format ) let content = value if ( format === 's' || format === 's' ) { content = quillEditor . clipboard . convert ( value ) } else if ( format === 's' ) { try { content = JSON . parse ( value ) } catch ( e ) { content = [ { insert : value } ] } } quillEditor . setContents ( content ) } ngOnChanges ( changes ) { if ( ! this . quillEditor ) { return } if ( changes . content ) { this . valueSetter ( this . quillEditor , changes . content . currentValue ) } } ngAfterViewInit ( ) { if ( isPlatformServer ( this . platformId ) ) { return } if ( ! Quill ) { Quill = require ( 's' ) } const modules = Object . assign ( { } , this . modules || ( this . config . modules || defaultModules ) ) modules . toolbar = false this . customOptions . forEach ( ( customOption ) => { const newCustomOption = Quill . import ( customOption . import ) newCustomOption . whitelist = customOption . whitelist Quill . register ( newCustomOption , true ) } ) let debug = this . debug if ( ! debug && debug !== false && this . config . debug ) { debug = this . config . debug } let formats = this . formats if ( ! formats && formats === undefined ) { formats = this . config . formats ? Object . assign ( { } , this . config . formats ) : ( this . config . formats === null ? null : undefined ) } const theme = this . theme || ( this . config . theme ? this . config . theme : 's' ) this . elementRef . nativeElement . insertAdjacentHTML ( 's' , this . preserveWhitespace ? 's' : 's' ) this . editorElem = this . elementRef . nativeElement . querySelector ( 's' ) this . quillEditor = new Quill ( this . editorElem , { debug , formats , modules , readOnly : true , strict : this . strict , theme } ) this . renderer . addClass ( this . editorElem , 's' ) if ( this . content ) { this . valueSetter ( this . quillEditor , this . content ) } } }	O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O O O O $any$ O O O O O $any$ O $any$ O O O $QuillFormat$ O O $QuillFormat$ $QuillFormat$ O $QuillFormat$ $QuillFormat$ O O $any$ O O O $QuillFormat$ O $QuillFormat$ O $QuillFormat$ O $QuillFormat$ O O O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string[]$ O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $HTMLElement$ O $complex$ O O O $any$ O O $QuillFormat$ O O O O O O O O O O $any$ O O $string$ O O O O $any$ O O $QuillModules$ O O $any$ O $any$ O O $complex$ O O O O O O O O O O $any$ O O $string[]$ O O O O O O O O $any$ O O $boolean$ O O O $any$ O O $any$ O O O $any$ O O $CustomOption[]$ O $any$ O O O O O O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $QuillConfig$ O O $Renderer2$ O O $any$ O $any$ O O $ElementRef$ O O O $any$ O O $any$ O $any$ O O O O O O $QuillFormat$ O $QuillFormat$ O O O $QuillFormat$ O O O $QuillConfig$ O $QuillFormat$ O O $any$ O $any$ O O $QuillFormat$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $JSON$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $void$ O $SimpleChanges$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $void$ O O O O O $any$ O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O $ObjectConstructor$ O O O O O O O O $QuillModules$ O O O O $QuillConfig$ O $QuillModules$ O $complex$ O O $complex$ O $complex$ O O O O $CustomOption[]$ O $void$ O O $CustomOption$ O O O O $any$ O $any$ O $any$ O $CustomOption$ O $string$ O $any$ O $any$ O $CustomOption$ O $any[]$ $any$ O $any$ O $any$ O O O O O O $complex$ O O O $complex$ O O O $complex$ O $complex$ O O O O O $QuillConfig$ O $complex$ O O $complex$ O O O $QuillConfig$ O O O O $string[]$ O O O $string[]$ O O O $string[]$ O $string[]$ O $undefined$ O O $string[]$ O O O $QuillConfig$ O $string[]$ O $ObjectConstructor$ O O O O O O O O $QuillConfig$ O $string[]$ O O O O O $QuillConfig$ O $string[]$ O O O O O $undefined$ O O O $string$ O O O $string$ O O O O $QuillConfig$ O $string$ O O O $QuillConfig$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O $boolean$ O O O O O O O $HTMLElement$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $HTMLElement$ O O $complex$ O $string[]$ O $complex$ O $boolean$ O O O $boolean$ O O O $boolean$ O $string$ O O O O $any$ O $any$ O O O $HTMLElement$ O O O O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O
import { CommonModule } from 's' import { ModuleWithProviders , NgModule } from 's' import { defaultModules } from 's' import { QuillEditorComponent } from 's' import { QUILL_CONFIG_TOKEN , QuillConfig } from 's' import { QuillViewHTMLComponent } from 's' import { QuillViewComponent } from 's' @ NgModule ( { declarations : [ QuillEditorComponent , QuillViewComponent , QuillViewHTMLComponent ] , exports : [ QuillEditorComponent , QuillViewComponent , QuillViewHTMLComponent ] , imports : [ CommonModule ] , providers : [ ] } ) export class QuillModule { static forRoot ( config ? ) { return { ngModule : QuillModule , providers : [ { provide : QUILL_CONFIG_TOKEN , useValue : config || { modules : defaultModules } } ] } } }	O O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O O $undefined[]$ O O O O O O O $any$ O O $ModuleWithProviders$ O $QuillConfig$ $QuillConfig$ O O O O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $complex$ O $QuillConfig$ O O $complex$ O $complex$ O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O
'js' Error . stackTraceLimit = Infinity require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) require ( 's' ) const appContext = require . context ( 's' , true , "s" ) appContext . keys ( ) . forEach ( appContext ) const testing = require ( 's' ) const browser = require ( 's' ) testing . TestBed . initTestEnvironment ( browser . BrowserDynamicTestingModule , browser . platformBrowserDynamicTesting ( ) )	O $ErrorConstructor$ O $any$ O $number$ $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O
'js' const path = require ( 's' ) let _config = { mode : 's' , resolve : { extensions : [ 's' , 's' ] } , entry : { 's' : path . resolve ( __dirname , 's' ) } , devtool : 's' , module : { rules : [ { test : "s" , use : [ { loader : 's' } ] } , { test : "s" , enforce : 's' , use : [ { loader : 's' , options : { embedSource : true , noAutoWrap : true } } ] , exclude : [ "s" , "s" ] } ] } } module . exports = _config	O O $any$ O $any$ O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O $complex$ O O O O $any$ O $any$ O $any$ O O O O O $string$ O O O $complex$ O O $complex$ O O O $RegExp$ O O O $complex$ O O O $string$ O O O O O O O $RegExp$ O O O $string$ O O O $complex$ O O O $string$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O O O O $RegExp[]$ O O O O O O O O O O $complex$ O $complex$ O $complex$
'js' const webpackConfig = require ( 's' ) const karmaWebpack = require ( 's' ) process . env . CHROME_BIN = require ( 's' ) . executablePath ( ) module . exports = function ( config ) { const _config = { basePath : 's' , plugins : [ 's' , 's' , 's' , karmaWebpack , 's' , 's' ] , frameworks : [ 's' ] , files : [ { pattern : 's' , watched : false } ] , preprocessors : { 's' : [ 's' ] } , webpack : webpackConfig , webpackMiddleware : { stats : 's' } , webpackServer : { noInfo : true } , reporters : [ 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : false , browsers : [ 's' ] , singleRun : true } _config . reporters . push ( 's' ) _config . coverageIstanbulReporter = { fixWebpackSourcePaths : true , reports : [ 's' ] } config . set ( _config ) }	O O $complex$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $void$ O $void$ O O O $any$ O O O O O O $string$ O O O $any[]$ O O O O O O O O $any$ O O O O O O $string[]$ O O O O O $complex$ O O O $string$ O O O $boolean$ O O O O O $complex$ O O O O O O O O O $complex$ O $complex$ O $complex$ O O $string$ O O O O $complex$ O O $boolean$ O O O O $string[]$ O O O O O $number$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $boolean$ O O O $string[]$ O O O O O $boolean$ O O O O O $string[]$ O $number$ O O O O O $any$ O O $boolean$ O O O $string[]$ O O O O O $any$ O $any$ O O O O
import { Component , 0 , ViewChild } from 's' import { async , ComponentFixture , TestBed } from 's' import { FormControl , FormsModule , ReactiveFormsModule } from 's' import { QuillEditorComponent } from 's' import * as QuillNamespace from 's' import { QuillModule } from 's' const Quill = QuillNamespace @ Component ( { template : `template` } ) class TestComponent { title : any = 's' isReadOnly = false required = false minLength = 0 focused = false blured = false maxLength = 0 style : { backgroundColor ? : string color ? : string height ? : string } | null = { height : 's' } editor : any changed : any changedEditor : any selected : any handleEditorCreated ( event ) { this . editor = event } handleChange ( event ) { this . changed = event } handleEditorChange ( event ) { this . changedEditor = event } handleSelection ( event ) { this . selected = event } } @ Component ( { template : `template` } ) class TestToolbarComponent { title = 's' isReadOnly = false minLength = 0 maxLength = 0 toolbarPosition = 's' handleEditorCreated ( _event ) { } handleChange ( _event ) { } } @ Component ( { template : `template` } ) class ReactiveFormTestComponent { formControl : FormControl = new FormControl ( null ) @ ViewChild ( QuillEditorComponent , { static : true } ) editor ! : QuillEditorComponent } @ Component ( { template : `template` } ) class PreserveWhitespaceTestComponent { content = 's' @ ViewChild ( QuillEditorComponent , { static : true } ) editor ! : QuillEditorComponent } describe ( 's' , ( ) => { let fixture < QuillEditorComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( QuillEditorComponent ) } ) it ( 's' , ( ) => { fixture . detectChanges ( ) const spy = spyOn ( fixture . componentInstance . quillEditor , 's' ) . and . callThrough ( ) fixture . componentInstance . ngOnDestroy ( ) expect ( spy ) . toHaveBeenCalledTimes ( 0 ) } ) it ( 's' , async ( async ( ) => { const element = fixture . nativeElement fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( element . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( fixture . componentInstance . quillEditor ) . toBeDefined ( ) } ) ) it ( 's' , async ( async ( ) => { const element = fixture . nativeElement fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( element . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( fixture . componentInstance . quillEditor ) . toBeDefined ( ) } ) ) } ) describe ( 's' , ( ) => { describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class ObjectComponent { title = [ { insert : 's' } ] editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < ObjectComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ObjectComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( ObjectComponent ) as ComponentFixture < ObjectComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . title = [ { insert : 's' } ] fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { component . editor . setContents ( [ { insert : 's' } ] , 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( JSON . stringify ( component . title ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class HTMLComponent { title = 's' editor : any handleEditorCreated ( event ) { this . editor = event } } @ Component ( { template : `template` } ) class HTMLSanitizeComponent { title = 's' editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < HTMLComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ HTMLComponent , HTMLSanitizeComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( HTMLComponent ) as ComponentFixture < HTMLComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance component . title = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . title . trim ( ) ) . toEqual ( 's' ) component . editor . setText ( 's' , 's' ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . title . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { fixture = TestBed . createComponent ( HTMLSanitizeComponent ) as ComponentFixture < HTMLSanitizeComponent > fixture . detectChanges ( ) const component = fixture . componentInstance await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } , { insert : { image : 's' } } , { insert : 's' } ] } ) ) component . title = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : { image : 's' } } , { insert : 's' } ] } ) ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class TextComponent { title = 's' editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < TextComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ TextComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( TextComponent ) as ComponentFixture < TextComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance component . title = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . editor . setText ( 's' , 's' ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . title . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . editor . setText ( 's' ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . title . trim ( ) ) . toEqual ( 's' ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class JSONComponent { title = JSON . stringify ( [ { insert : 's' } ] ) editor : any handleEditorCreated ( event ) { this . editor = event } } @ Component ( { template : `template` } ) class JSONInvalidComponent { title = JSON . stringify ( [ { insert : 's' } ] ) + 's' editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < JSONComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ JSONComponent , JSONInvalidComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( JSONComponent ) as ComponentFixture < JSONComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance component . title = JSON . stringify ( [ { insert : 's' } ] ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( JSON . stringify ( component . editor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . editor . setContents ( [ { insert : 's' } ] , 's' ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . title ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( async ( ) => { fixture = TestBed . createComponent ( JSONInvalidComponent ) as ComponentFixture < JSONInvalidComponent > fixture . detectChanges ( ) const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( JSON . stringify ( [ { insert : 's' } ] ) + 's' ) component . title = JSON . stringify ( [ { insert : 's' } ] ) + 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . editor . getText ( ) . trim ( ) ) . toEqual ( JSON . stringify ( [ { insert : 's' } ] ) + 's' ) } ) ) } ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class StylingComponent { title = 's' style = { backgroundColor : 's' } editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < StylingComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ StylingComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( StylingComponent ) as ComponentFixture < StylingComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { expect ( component . editor . container . style . backgroundColor ) . toEqual ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { component . style = { backgroundColor : 's' } fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( component . editor . container . style . backgroundColor ) . toEqual ( 's' ) } ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class ClassesComponent { title = 's' classes = 's' editor : any constructor ( public 0 ) { } handleEditorCreated ( event ) { this . editor = event } } let fixture < ClassesComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ClassesComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( ClassesComponent ) as ComponentFixture < ClassesComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) } ) } ) ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { component . classes = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( false ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) } ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class ClassesComponent { title = 's' classes = 's' editor : any handleEditorCreated ( event ) { this . editor = event } } let fixture < ClassesComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ClassesComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( ClassesComponent ) as ComponentFixture < ClassesComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) } ) } ) ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { component . classes = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( false ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) expect ( component . editor . container . classList . contains ( 's' ) ) . toBe ( true ) } ) } ) ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const classList = QuillEditorComponent . normalizeClassNames ( 's' ) expect ( classList ) . toEqual ( [ 's' ] ) } ) it ( 's' , ( ) => { const classList = QuillEditorComponent . normalizeClassNames ( 's' ) expect ( classList ) . toEqual ( [ 's' , 's' ] ) } ) } ) describe ( 's' , ( ) => { let fixture < ReactiveFormTestComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ReactiveFormTestComponent ] , imports : [ FormsModule , ReactiveFormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( ReactiveFormTestComponent ) as ComponentFixture < ReactiveFormTestComponent > fixture . detectChanges ( ) } ) it ( 's' , ( ) => { const component = fixture . componentInstance component . formControl . disable ( ) expect ( component . editor . quillEditor . container . classList . contains ( 's' ) ) . toBeTruthy ( ) } ) it ( 's' , ( ) => { const component = fixture . componentInstance component . formControl . disable ( ) expect ( fixture . nativeElement . children [ 0 ] . attributes . disabled ) . toBeDefined ( ) } ) it ( 's' , ( ) => { const component = fixture . componentInstance component . formControl . disable ( ) component . formControl . enable ( ) expect ( component . editor . quillEditor . container . classList . contains ( 's' ) ) . toBeFalsy ( ) expect ( fixture . nativeElement . children [ 0 ] . attributes . disabled ) . not . toBeDefined ( ) } ) it ( 's' , async ( ( ) => { const values : string [ ] = [ ] fixture . componentInstance . formControl . valueChanges . subscribe ( ( value ) => values . push ( value ) ) fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { fixture . componentInstance . formControl . patchValue ( 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( fixture . nativeElement . querySelector ( 's' ) . textContent ) . toEqual ( 's' ) expect ( fixture . componentInstance . formControl . value ) . toEqual ( 's' ) expect ( fixture . componentInstance . formControl . pristine ) . toBeTruthy ( ) expect ( values ) . toEqual ( [ 's' ] ) } ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { fixture . componentInstance . editor . quillEditor . setText ( 's' , 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( fixture . nativeElement . querySelector ( 's' ) . textContent ) . toEqual ( 's' ) expect ( fixture . componentInstance . formControl . dirty ) . toBeTruthy ( ) expect ( fixture . componentInstance . formControl . value ) . toEqual ( 's' ) } ) } ) ) } ) describe ( 's' , ( ) => { let fixture < TestComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ TestComponent , TestToolbarComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) . compileComponents ( ) fixture = TestBed . createComponent ( TestComponent ) as ComponentFixture < TestComponent > } ) it ( 's' , async ( ( ) => { spyOn ( Quill , 's' ) . and . callThrough ( ) spyOn ( Quill , 's' ) . and . callThrough ( ) fixture . detectChanges ( ) const editorElem = fixture . debugElement . children [ 0 ] const editorCmp = fixture . debugElement . children [ 0 ] . componentInstance expect ( editorCmp . readOnly ) . toBe ( false ) fixture . componentInstance . isReadOnly = true fixture . detectChanges ( ) expect ( Quill . import ) . toHaveBeenCalledWith ( 's' ) expect ( Quill . register ) . toHaveBeenCalled ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( editorCmp . readOnly ) . toBe ( true ) expect ( editorElem . nativeElement . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( editorElem . nativeElement . querySelector ( 's' ) . style . height ) . toBe ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorElem = fixture . debugElement . children [ 0 ] fixture . componentInstance . style = { backgroundColor : 's' } fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( editorElem . nativeElement . querySelector ( 's' ) . style . backgroundColor ) . toBe ( 's' ) expect ( editorElem . nativeElement . querySelector ( 's' ) . style . height ) . toEqual ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorElem = fixture . debugElement . children [ 0 ] fixture . componentInstance . style = null fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { fixture . componentInstance . style = { color : 's' } expect ( editorElem . nativeElement . querySelector ( 's' ) . style . height ) . toEqual ( 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( editorElem . nativeElement . querySelector ( 's' ) . style . color ) . toBe ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorElem = fixture . debugElement . children [ 0 ] fixture . componentInstance . isReadOnly = true fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( editorElem . nativeElement . querySelector ( 's' ) . style . height ) . toEqual ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorFixture = fixture . debugElement . children [ 0 ] editorFixture . componentInstance . quillEditor . focus ( ) editorFixture . componentInstance . quillEditor . blur ( ) fixture . detectChanges ( ) expect ( editorFixture . nativeElement . className ) . toMatch ( 's' ) } ) ) it ( 's' , async ( ( ) => { const editorElement = fixture . debugElement . children [ 0 ] . nativeElement fixture . componentInstance . title = 's' fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( async ( ) => { spyOn ( fixture . componentInstance , 's' ) fixture . detectChanges ( ) await fixture . whenStable ( ) const editorComponent = fixture . debugElement . children [ 0 ] . componentInstance expect ( fixture . componentInstance . handleEditorCreated ) . toHaveBeenCalledWith ( editorComponent . quillEditor ) } ) ) it ( 's' , async ( ( ) => { spyOn ( fixture . componentInstance , 's' ) . and . callThrough ( ) spyOn ( fixture . componentInstance , 's' ) . and . callThrough ( ) fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { const editorFixture = fixture . debugElement . children [ 0 ] editorFixture . componentInstance . quillEditor . setText ( 's' , 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( fixture . componentInstance . handleChange ) . toHaveBeenCalledWith ( fixture . componentInstance . changed ) expect ( fixture . componentInstance . handleEditorChange ) . toHaveBeenCalledWith ( fixture . componentInstance . changedEditor ) } ) } ) ) it ( 's' , async ( ( ) => { spyOn ( fixture . componentInstance , 's' ) . and . callThrough ( ) spyOn ( fixture . componentInstance , 's' ) . and . callThrough ( ) fixture . detectChanges ( ) const editorFixture = fixture . debugElement . children [ 0 ] editorFixture . componentInstance . quillEditor . focus ( ) editorFixture . componentInstance . quillEditor . blur ( ) fixture . detectChanges ( ) expect ( fixture . componentInstance . handleSelection ) . toHaveBeenCalledWith ( fixture . componentInstance . selected ) expect ( fixture . componentInstance . handleEditorChange ) . toHaveBeenCalledWith ( fixture . componentInstance . changedEditor ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorFixture = fixture . debugElement . children [ 0 ] editorFixture . componentInstance . quillEditor . focus ( ) fixture . detectChanges ( ) expect ( fixture . componentInstance . focused ) . toBe ( true ) } ) ) it ( 's' , async ( ( ) => { fixture . detectChanges ( ) const editorFixture = fixture . debugElement . children [ 0 ] editorFixture . componentInstance . quillEditor . focus ( ) editorFixture . componentInstance . quillEditor . blur ( ) fixture . detectChanges ( ) expect ( fixture . componentInstance . blured ) . toBe ( true ) } ) ) it ( 's' , async ( ( ) => { const editorComponent = fixture . debugElement . children [ 0 ] . componentInstance const editorElement = fixture . debugElement . children [ 0 ] . nativeElement fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( editorElement . className ) . toMatch ( 's' ) fixture . componentInstance . minLength = 0 fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorComponent . minLength ) . toBe ( 0 ) expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const editorComponent = fixture . debugElement . children [ 0 ] . componentInstance const editorElement = fixture . debugElement . children [ 0 ] . nativeElement fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { editorComponent . minLength = 0 editorComponent . quillEditor . setText ( 's' , 's' ) fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const editorComponent = fixture . debugElement . children [ 0 ] . componentInstance const editorElement = fixture . debugElement . children [ 0 ] . nativeElement fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( fixture . debugElement . children [ 0 ] . nativeElement . className ) . toMatch ( 's' ) fixture . componentInstance . maxLength = 0 fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorComponent . maxLength ) . toBe ( 0 ) expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const editorElement = fixture . debugElement . children [ 0 ] . nativeElement fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( fixture . debugElement . children [ 0 ] . nativeElement . className ) . toMatch ( 's' ) fixture . componentInstance . minLength = 0 fixture . componentInstance . maxLength = 0 fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorElement . className ) . toMatch ( 's' ) fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const editorElement = fixture . debugElement . children [ 0 ] . nativeElement const editorComponent = fixture . debugElement . children [ 0 ] . componentInstance fixture . detectChanges ( ) fixture . whenStable ( ) . then ( ( ) => { expect ( fixture . debugElement . children [ 0 ] . nativeElement . className ) . toMatch ( 's' ) expect ( editorComponent . required ) . toBeFalsy ( ) fixture . componentInstance . required = true fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorComponent . required ) . toBeTruthy ( ) expect ( editorElement . className ) . toMatch ( 's' ) fixture . componentInstance . title = 's' fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { fixture . detectChanges ( ) expect ( editorElement . className ) . toMatch ( 's' ) } ) } ) ) it ( 's' , async ( ( ) => { const toolbarFixture = TestBed . createComponent ( TestToolbarComponent ) as ComponentFixture < TestToolbarComponent > toolbarFixture . detectChanges ( ) expect ( toolbarFixture . debugElement . children [ 0 ] . nativeElement . children [ 0 ] . attributes [ 's' ] ) . toBeDefined ( ) expect ( toolbarFixture . debugElement . children [ 0 ] . nativeElement . children [ 0 ] . attributes [ 's' ] ) . toBeDefined ( ) const editorComponent = toolbarFixture . debugElement . children [ 0 ] . componentInstance expect ( editorComponent . required ) . toBe ( true ) expect ( editorComponent . customToolbarPosition ) . toEqual ( 's' ) } ) ) it ( 's' , async ( ( ) => { const toolbarFixture = TestBed . createComponent ( TestToolbarComponent ) as ComponentFixture < TestToolbarComponent > toolbarFixture . componentInstance . toolbarPosition = 's' toolbarFixture . detectChanges ( ) expect ( toolbarFixture . debugElement . children [ 0 ] . nativeElement . children [ 0 ] . attributes [ 's' ] ) . toBeDefined ( ) expect ( toolbarFixture . debugElement . children [ 0 ] . nativeElement . children [ 0 ] . attributes [ 's' ] ) . toBeDefined ( ) const editorComponent = toolbarFixture . debugElement . children [ 0 ] . componentInstance expect ( editorComponent . customToolbarPosition ) . toEqual ( 's' ) } ) ) } ) describe ( 's' , ( ) => { let fixture < TestComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ TestComponent , TestToolbarComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( { bounds : 's' , debug : false , format : 's' , formats : [ 's' ] , modules : { toolbar : [ [ 's' ] ] } , placeholder : 's' , readOnly : true , scrollingContainer : null , theme : 's' , trackChanges : 's' } ) . providers } ) . compileComponents ( ) } ) it ( 's' , async ( async ( ) => { fixture = TestBed . createComponent ( TestComponent ) fixture . detectChanges ( ) await fixture . whenStable ( ) const editor = fixture . componentInstance . editor as QuillNamespace . Quill expect ( fixture . nativeElement . querySelector ( 's' ) . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( fixture . nativeElement . querySelector ( 's' ) . querySelector ( 's' ) ) . toBeDefined ( ) editor . updateContents ( [ { insert : 's' , attributes : { bold : true , italic : true } } ] as any , 's' ) fixture . detectChanges ( ) expect ( JSON . stringify ( fixture . componentInstance . title ) ) . toEqual ( JSON . stringify ( { ops : [ { attributes : { bold : true } , insert : `template` } , { 's' : 's' } ] } ) ) expect ( editor . root . dataset . placeholder ) . toEqual ( 's' ) } ) ) } ) describe ( 's' , ( ) => { let fixture < PreserveWhitespaceTestComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ PreserveWhitespaceTestComponent ] , imports : [ FormsModule , QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) . compileComponents ( ) } ) it ( 's' , async ( async ( ) => { fixture = TestBed . createComponent ( PreserveWhitespaceTestComponent ) fixture . detectChanges ( ) const editor = fixture . componentInstance . editor expect ( editor . editorElem ! . tagName ) . toEqual ( 's' ) } ) ) } )	O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O O O $boolean$ O O $boolean$ O O $number$ O O $boolean$ O O $boolean$ O O $number$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $any$ O O $any$ O O $any$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $boolean$ O O $number$ O O $number$ O O $string$ O O $void$ O $any$ O O O $void$ O $any$ O O O O O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $boolean$ O O O O $QuillEditorComponent$ O O $any$ O O $any$ O O $string$ O O O O O $any$ O $string$ O O O $any$ O $any$ O O $boolean$ O O O O $QuillEditorComponent$ O O $any$ O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $complex$ O O O $string$ O O O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O O $string$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $complex$ O O $string$ O O O O O O $string$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O $JSON$ O $complex$ O O O $string$ O O O O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $any$ O O $string$ O O O O O $any$ O $string$ O $JSON$ O $complex$ O O O $string$ O O O O O O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O $JSON$ O $complex$ O O O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $JSON$ O $complex$ O O O $string$ O O O O O O O O $any$ O $any$ O $JSON$ O $complex$ O O O $string$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $JSON$ O $complex$ O O O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $complex$ O O $string$ O O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $string$ O O $any$ O O O O O $Renderer2$ O O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $string$ O O $string$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string[]$ O $any$ O $string[]$ O O O $any$ O $string[]$ O O $any$ O O O O O O O $any$ O O O O O O O O $string[]$ O $any$ O $string[]$ O O O $any$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $string[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O $string[]$ O $number$ O $string$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $false$ O O O O O O O $string[]$ O O O O O $complex$ O O $string[][]$ O O O O O O O O $string$ O O O $true$ O O O $null$ O O O $string$ O O O O O O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O $string$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O O O O O O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O $any$ O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O
import { Component , ViewChild } from 's' import { async , ComponentFixture , TestBed } from 's' import { QuillViewHTMLComponent } from 's' import { QuillModule } from 's' describe ( 's' , ( ) => { let fixture < QuillViewHTMLComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { imports : [ QuillModule . forRoot ( ) ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( QuillViewHTMLComponent ) } ) it ( 's' , async ( async ( ) => { const element = fixture . nativeElement fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( element . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( fixture . componentInstance . themeClass ) . toBe ( 's' ) const viewElement = element . querySelector ( 's' ) expect ( viewElement ) . toBeDefined ( ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class HTMLComponent { @ ViewChild ( QuillViewHTMLComponent , { static : true } ) view : QuillViewHTMLComponent | undefined content = 's' } let fixture < HTMLComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ HTMLComponent ] , imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( HTMLComponent ) as ComponentFixture < HTMLComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const element = fixture . nativeElement await fixture . whenStable ( ) const viewElement = element . querySelector ( 's' ) expect ( viewElement . innerHTML ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . content = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) const element = fixture . nativeElement const viewElement = element . querySelector ( 's' ) expect ( viewElement . innerHTML ) . toEqual ( 's' ) } ) ) } )	O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $QuillViewHTMLComponent$ O $any$ O O $string$ O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O
import { Component , ViewChild } from 's' import { async , ComponentFixture , TestBed } from 's' import { QuillViewComponent } from 's' import { QuillModule } from 's' describe ( 's' , ( ) => { let fixture < QuillViewComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { imports : [ QuillModule . forRoot ( ) ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( QuillViewComponent ) } ) it ( 's' , async ( async ( ) => { const element = fixture . nativeElement fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( element . querySelectorAll ( 's' ) . length ) . toBe ( 0 ) expect ( fixture . componentInstance . quillEditor ) . toBeDefined ( ) const viewElement = element . querySelector ( 's' ) expect ( viewElement ) . toBeDefined ( ) } ) ) } ) describe ( 's' , ( ) => { describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class ObjectComponent { @ ViewChild ( QuillViewComponent , { static : true } ) view : QuillViewComponent | undefined content = [ { insert : 's' } ] } let fixture < ObjectComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ObjectComponent ] , imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( ObjectComponent ) as ComponentFixture < ObjectComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { expect ( JSON . stringify ( component . view ! . quillEditor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) } ) ) it ( 's' , async ( ( ) => { const component = fixture . componentInstance fixture . whenStable ( ) . then ( ( ) => { component . content = [ { insert : 's' } ] fixture . detectChanges ( ) return fixture . whenStable ( ) } ) . then ( ( ) => { expect ( JSON . stringify ( component . view ! . quillEditor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class HTMLComponent { @ ViewChild ( QuillViewComponent , { static : true } ) view : QuillViewComponent | undefined content = 's' } let fixture < HTMLComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ HTMLComponent ] , imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( HTMLComponent ) as ComponentFixture < HTMLComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . view ! . quillEditor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . content = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . view ! . quillEditor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class TextComponent { @ ViewChild ( QuillViewComponent , { static : true } ) view : QuillViewComponent | undefined content = 's' } let fixture < TextComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ TextComponent ] , imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( TextComponent ) as ComponentFixture < TextComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) expect ( component . view ! . quillEditor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . content = 's' fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( component . view ! . quillEditor . getText ( ) . trim ( ) ) . toEqual ( 's' ) } ) ) } ) describe ( 's' , ( ) => { @ Component ( { template : `template` } ) class JSONComponent { @ ViewChild ( QuillViewComponent , { static : true } ) view : QuillViewComponent | undefined content = JSON . stringify ( [ { insert : 's' } ] ) } let fixture < JSONComponent > beforeEach ( ( ) => { TestBed . configureTestingModule ( { declarations : [ JSONComponent ] , imports : [ QuillModule ] , providers : QuillModule . forRoot ( ) . providers } ) fixture = TestBed . createComponent ( JSONComponent ) as ComponentFixture < JSONComponent > fixture . detectChanges ( ) } ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) await fixture . whenStable ( ) expect ( JSON . stringify ( component . view ! . quillEditor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) it ( 's' , async ( async ( ) => { const component = fixture . componentInstance await fixture . whenStable ( ) component . content = JSON . stringify ( [ { insert : 's' } ] ) fixture . detectChanges ( ) await fixture . whenStable ( ) expect ( JSON . stringify ( component . view ! . quillEditor . getContents ( ) ) ) . toEqual ( JSON . stringify ( { ops : [ { insert : 's' } ] } ) ) } ) ) } ) } )	O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $QuillViewComponent$ O $any$ O O $complex$ O O O $string$ O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $QuillViewComponent$ O $any$ O O $string$ O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $QuillViewComponent$ O $any$ O O $string$ O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $QuillViewComponent$ O $any$ O O $string$ O $JSON$ O $complex$ O O O $string$ O O O O O O O $ComponentFixture$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $JSON$ O $complex$ O O O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O O O O