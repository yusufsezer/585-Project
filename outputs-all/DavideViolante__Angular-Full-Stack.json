import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AboutComponent { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { AboutComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AboutComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AboutComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( AboutComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { const el = fixture . debugElement . query ( By . css ( 's' ) ) . nativeElement ; expect ( el . textContent ) . toContain ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AboutComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $AboutComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $AboutComponent$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ToastComponent { @ Input ( ) message = { body : 's' , type : 's' } ; setMessage ( body , type , time = 0 ) { this . message . body = body ; this . message . type = type ; setTimeout ( ( ) => this . message . body = 's' , time ) ; } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O $void$ O $any$ O $any$ O $number$ O O O O O O $complex$ O $string$ O $any$ O O O $complex$ O $string$ O $any$ O $number$ O O O O O O $complex$ O $string$ O O O $number$ O O O O
export class User { _id ? : string ; username ? : string ; email ? : string ; role ? : string ; }	O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O
import { Injectable } from 's' ; import { HttpClient } from 's' ; import { Observable } from 's' ; import { User } from 's' ; @ Injectable ( ) export class UserService { constructor ( private http ) { } register ( user ) < User > { return this . http . post < User > ( 's' , user ) ; } login ( credentials ) < any > { return this . http . post ( 's' , credentials ) ; } getUsers ( ) < User [ ] > { return this . http . get < User [ ] > ( 's' ) ; } countUsers ( ) < number > { return this . http . get < number > ( 's' ) ; } addUser ( user ) < User > { return this . http . post < User > ( 's' , user ) ; } getUser ( user ) < User > { return this . http . get < User > ( `template` ) ; } editUser ( user ) < any > { return this . http . put ( `template` , user , { responseType : 's' } ) ; } deleteUser ( user ) < any > { return this . http . delete ( `template` , { responseType : 's' } ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $HttpClient$ O O O $Observable$ O $User$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $User$ O O O $Observable$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O $Observable$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Observable$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Observable$ O $User$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $User$ O O O $Observable$ O $User$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $Observable$ O $User$ O O O O O O O O $any$ O $any$ O O O $User$ O O $string$ O O O O O O $Observable$ O $User$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O O O O O
import { Injectable } from 's' ; import { Router } from 's' ; import { JwtHelperService } from 's' ; import { UserService } from 's' ; import { User } from 's' ; import 's' ; @ Injectable ( ) export class AuthService { loggedIn = false ; isAdmin = false ; currentUser : User = new User ( ) ; constructor ( private userService , private router , private jwtHelper ) { const token = localStorage . getItem ( 's' ) ; if ( token ) { const decodedUser = this . decodeUserFromToken ( token ) ; this . setCurrentUser ( decodedUser ) ; } } login ( emailAndPassword ) { return this . userService . login ( emailAndPassword ) . map ( res => { localStorage . setItem ( 's' , res . token ) ; const decodedUser = this . decodeUserFromToken ( res . token ) ; this . setCurrentUser ( decodedUser ) ; return this . loggedIn ; } ) ; } logout ( ) { localStorage . removeItem ( 's' ) ; this . loggedIn = false ; this . isAdmin = false ; this . currentUser = new User ( ) ; this . router . navigate ( [ 's' ] ) ; } decodeUserFromToken ( token ) { return this . jwtHelper . decodeToken ( token ) . user ; } setCurrentUser ( decodedUser ) { this . loggedIn = true ; this . currentUser . _id = decodedUser . _id ; this . currentUser . username = decodedUser . username ; this . currentUser . role = decodedUser . role ; decodedUser . role === 's' ? this . isAdmin = true : this . isAdmin = false ; delete decodedUser . role ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $boolean$ O O O $boolean$ O O O $User$ O $any$ O O $any$ O O O O O O $UserService$ O O $Router$ O O $JwtHelperService$ O O O $string$ O $Storage$ O $string$ O O O O O O $string$ O O O $any$ O O O $any$ O $string$ O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O $UserService$ O $any$ O $any$ O O $any$ O $any$ O O $Storage$ O $void$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O O O O $boolean$ O O O O O $void$ O O O $Storage$ O $void$ O O O O O O $boolean$ O O O O O $boolean$ O O O O O $User$ O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O $void$ O $any$ O O O O $boolean$ O O O O O $User$ O $string$ O $any$ O $any$ O O O $User$ O $string$ O $any$ O $any$ O O O $User$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O $any$ O $any$ O O O
import { Component , OnInit } from 's' ; import { ToastComponent } from 's' ; import { AuthService } from 's' ; import { UserService } from 's' ; import { User } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class AccountComponent implements OnInit { user : User ; isLoading = true ; constructor ( private auth , public toast , private userService ) { } ngOnInit ( ) { this . getUser ( ) ; } getUser ( ) { this . userService . getUser ( this . auth . currentUser ) . subscribe ( data => this . user = data , error => console . log ( error ) , ( ) => this . isLoading = false ) ; } save ( user ) { this . userService . editUser ( user ) . subscribe ( res => this . toast . setMessage ( 's' , 's' ) , error => console . log ( error ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $User$ O $any$ O $boolean$ O O O O O O $AuthService$ O O $ToastComponent$ O O $UserService$ O O O $void$ O O O O O $void$ O O O O $void$ O O O O O $UserService$ O $any$ O O O $AuthService$ O $User$ O O $any$ O $any$ O O O $User$ O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O O O $boolean$ O O O O O $void$ O $User$ O O O O $UserService$ O $any$ O $User$ O O $any$ O $any$ O O O $ToastComponent$ O $void$ O O O O O O $any$ O $Console$ O $void$ O $any$ O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { AccountComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AccountComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AccountComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( AccountComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AccountComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $AccountComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O
import { Component , OnInit } from 's' ; import { ToastComponent } from 's' ; import { AuthService } from 's' ; import { UserService } from 's' ; import { User } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class AdminComponent implements OnInit { users : User [ ] = [ ] ; isLoading = true ; constructor ( public auth , public toast , private userService ) { } ngOnInit ( ) { this . getUsers ( ) ; } getUsers ( ) { this . userService . getUsers ( ) . subscribe ( data => this . users = data , error => console . log ( error ) , ( ) => this . isLoading = false ) ; } deleteUser ( user ) { if ( window . confirm ( 's' + user . username + 's' ) ) { this . userService . deleteUser ( user ) . subscribe ( data => this . toast . setMessage ( 's' , 's' ) , error => console . log ( error ) , ( ) => this . getUsers ( ) ) ; } } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $User[]$ O $any$ O O O O O O $boolean$ O O O O O O $AuthService$ O O $ToastComponent$ O O $UserService$ O O O $void$ O O O O O $void$ O O O O $void$ O O O O O $UserService$ O $any$ O O O $any$ O $any$ O O O $User[]$ O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O O O $boolean$ O O O O O $void$ O $User$ O O O O $complex$ O $boolean)$ O O O $User$ O $string$ O O O O O O O $UserService$ O $any$ O $User$ O O $any$ O $any$ O O O $ToastComponent$ O $void$ O O O O O O $any$ O $Console$ O $void$ O $any$ O O O O O O O $void$ O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { AdminComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AdminComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ AdminComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( AdminComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AdminComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $AdminComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O
import { Injectable } from 's' ; import { CanActivate } from 's' ; import { AuthService } from 's' ; @ Injectable ( ) export class AuthGuardLogin implements CanActivate { constructor ( public auth ) { } canActivate ( ) { return this . auth . loggedIn ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O $AuthService$ O O O $boolean$ O O O O O O $AuthService$ O $boolean$ O O O
import { Injectable } from 's' ; import { CanActivate } from 's' ; import { AuthService } from 's' ; @ Injectable ( ) export class AuthGuardAdmin implements CanActivate { constructor ( public auth ) { } canActivate ( ) { return this . auth . isAdmin ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O $AuthService$ O O O $boolean$ O O O O O O $AuthService$ O $boolean$ O O O
export class Cat { _id ? : string ; name ? : string ; weight ? : number ; age ? : number ; }	O O $any$ O $string$ O O O O $string$ O O O O $number$ O O O O $number$ O O O O O
import { Injectable } from 's' ; import { HttpClient } from 's' ; import { Observable } from 's' ; import { Cat } from 's' ; @ Injectable ( ) export class CatService { constructor ( private http ) { } getCats ( ) < Cat [ ] > { return this . http . get < Cat [ ] > ( 's' ) ; } countCats ( ) < number > { return this . http . get < number > ( 's' ) ; } addCat ( cat ) < Cat > { return this . http . post < Cat > ( 's' , cat ) ; } getCat ( cat ) < Cat > { return this . http . get < Cat > ( `template` ) ; } editCat ( cat ) < any > { return this . http . put ( `template` , cat , { responseType : 's' } ) ; } deleteCat ( cat ) < any > { return this . http . delete ( `template` , { responseType : 's' } ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $HttpClient$ O O O $Observable$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Observable$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Observable$ O $Cat$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $Cat$ O O O $Observable$ O $Cat$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $Observable$ O $Cat$ O O O O O O O O $any$ O $any$ O O O $Cat$ O O $string$ O O O O O O $Observable$ O $Cat$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O O O O O
import { Component , OnInit } from 's' ; import { FormBuilder , FormControl , FormGroup , Validators } from 's' ; import { CatService } from 's' ; import { ToastComponent } from 's' ; import { Cat } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class CatsComponent implements OnInit { cat = new Cat ( ) ; cats : Cat [ ] = [ ] ; isLoading = true ; isEditing = false ; addCatForm : FormGroup ; name = new FormControl ( 's' , Validators . required ) ; age = new FormControl ( 's' , Validators . required ) ; weight = new FormControl ( 's' , Validators . required ) ; constructor ( private catService , private formBuilder , public toast ) { } ngOnInit ( ) { this . getCats ( ) ; this . addCatForm = this . formBuilder . group ( { name : this . name , age : this . age , weight : this . weight } ) ; } getCats ( ) { this . catService . getCats ( ) . subscribe ( data => this . cats = data , error => console . log ( error ) , ( ) => this . isLoading = false ) ; } addCat ( ) { this . catService . addCat ( this . addCatForm . value ) . subscribe ( res => { this . cats . push ( res ) ; this . addCatForm . reset ( ) ; this . toast . setMessage ( 's' , 's' ) ; } , error => console . log ( error ) ) ; } enableEditing ( cat ) { this . isEditing = true ; this . cat = cat ; } cancelEditing ( ) { this . isEditing = false ; this . cat = new Cat ( ) ; this . toast . setMessage ( 's' , 's' ) ; this . getCats ( ) ; } editCat ( cat ) { this . catService . editCat ( cat ) . subscribe ( ( ) => { this . isEditing = false ; this . cat = cat ; this . toast . setMessage ( 's' , 's' ) ; } , error => console . log ( error ) ) ; } deleteCat ( cat ) { if ( window . confirm ( 's' ) ) { this . catService . deleteCat ( cat ) . subscribe ( ( ) => { const pos = this . cats . map ( elem => elem . _id ) . indexOf ( cat . _id ) ; this . cats . splice ( pos , 0 ) ; this . toast . setMessage ( 's' , 's' ) ; } , error => console . log ( error ) ) ; } } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $Cat$ O O $any$ O O O $Cat[]$ O $any$ O O O O O O $boolean$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O O O O $CatService$ O O $FormBuilder$ O O $ToastComponent$ O O O $void$ O O O O O $void$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $void$ O O O O O $CatService$ O $any$ O O O $any$ O $any$ O O O $Cat[]$ O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O O O $boolean$ O O O O O $void$ O O O O O $CatService$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $Cat[]$ O $number$ O $any$ O O O O $any$ O $any$ O O O O O $ToastComponent$ O $void$ O O O O O O O O $any$ O $Console$ O $void$ O $any$ O O O O $void$ O $Cat$ O O O O $boolean$ O O O O O $Cat$ O $Cat$ O O $void$ O O O O O $boolean$ O O O O O $Cat$ O O $any$ O O O O O $ToastComponent$ O $void$ O O O O O O O O $void$ O O O O $void$ O $Cat$ O O O O $CatService$ O $any$ O $Cat$ O O $any$ O O O O O O O $boolean$ O O O O O $Cat$ O $Cat$ O O O $ToastComponent$ O $void$ O O O O O O O O $any$ O $Console$ O $void$ O $any$ O O O O $void$ O $Cat$ O O O O $complex$ O $boolean)$ O O O O O O O $CatService$ O $any$ O $Cat$ O O $any$ O O O O O O $number$ O O O $Cat[]$ O $U[]$ O $Cat$ O $Cat$ O $string$ O O $number$ O $Cat$ O $string$ O O O O $Cat[]$ O $complex$ O $number$ O O O O O O $ToastComponent$ O $void$ O O O O O O O O $any$ O $Console$ O $void$ O $any$ O O O O O O
import { Component , OnInit } from 's' ; import { Router } from 's' ; import { FormBuilder , FormControl , FormGroup , Validators } from 's' ; import { UserService } from 's' ; import { ToastComponent } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class RegisterComponent implements OnInit { registerForm : FormGroup ; username = new FormControl ( 's' , [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) , Validators . pattern ( 's' ) ] ) ; email = new FormControl ( 's' , [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] ) ; password = new FormControl ( 's' , [ Validators . required , Validators . minLength ( 0 ) ] ) ; role = new FormControl ( 's' , [ Validators . required ] ) ; constructor ( private formBuilder , private router , public toast , private userService ) { } ngOnInit ( ) { this . registerForm = this . formBuilder . group ( { username : this . username , email : this . email , password : this . password , role : this . role } ) ; } setClassUsername ( ) { return { 's' : ! this . username . pristine && ! this . username . valid } ; } setClassEmail ( ) { return { 's' : ! this . email . pristine && ! this . email . valid } ; } setClassPassword ( ) { return { 's' : ! this . password . pristine && ! this . password . valid } ; } register ( ) { this . userService . register ( this . registerForm . value ) . subscribe ( res => { this . toast . setMessage ( 's' , 's' ) ; this . router . navigate ( [ 's' ] ) ; } , error => this . toast . setMessage ( 's' , 's' ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O $FormBuilder$ O O $Router$ O O $ToastComponent$ O O $UserService$ O O O $void$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O O O O O $UserService$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $ToastComponent$ O $void$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O $ToastComponent$ O $void$ O O O O O O O O O
import { Component , OnInit } from 's' ; import { Router } from 's' ; import { FormBuilder , FormControl , FormGroup , Validators } from 's' ; import { AuthService } from 's' ; import { ToastComponent } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LoginComponent implements OnInit { loginForm : FormGroup ; email = new FormControl ( 's' , [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] ) ; password = new FormControl ( 's' , [ Validators . required , Validators . minLength ( 0 ) ] ) ; constructor ( private auth , private formBuilder , private router , public toast ) { } ngOnInit ( ) { if ( this . auth . loggedIn ) { this . router . navigate ( [ 's' ] ) ; } this . loginForm = this . formBuilder . group ( { email : this . email , password : this . password } ) ; } setClassEmail ( ) { return { 's' : ! this . email . pristine && ! this . email . valid } ; } setClassPassword ( ) { return { 's' : ! this . password . pristine && ! this . password . valid } ; } login ( ) { this . auth . login ( this . loginForm . value ) . subscribe ( res => this . router . navigate ( [ 's' ] ) , error => this . toast . setMessage ( 's' , 's' ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $AuthService$ O O $FormBuilder$ O O $Router$ O O $ToastComponent$ O O O $void$ O O O O O O O $AuthService$ O $boolean$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O O O O O $AuthService$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O $ToastComponent$ O $void$ O O O O O O O O O
import { Component , OnInit } from 's' ; import { AuthService } from 's' ; @ Component ( { selector : 's' , template : 's' } ) export class LogoutComponent implements OnInit { constructor ( private auth ) { } ngOnInit ( ) { this . auth . logout ( ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O O $AuthService$ O O O $void$ O O O O O $AuthService$ O $void$ O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class NotFoundComponent { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O O O O O O
import { NgModule } from 's' ; import { RouterModule , Routes } from 's' ; import { AuthGuardLogin } from 's' ; import { AuthGuardAdmin } from 's' ; import { CatsComponent } from 's' ; import { AboutComponent } from 's' ; import { RegisterComponent } from 's' ; import { LoginComponent } from 's' ; import { LogoutComponent } from 's' ; import { AccountComponent } from 's' ; import { AdminComponent } from 's' ; import { NotFoundComponent } from 's' ; const routes = [ { path : 's' , component : AboutComponent } , { path : 's' , component : CatsComponent } , { path : 's' , component : RegisterComponent } , { path : 's' , component : LoginComponent } , { path : 's' , component : LogoutComponent } , { path : 's' , component : AccountComponent , canActivate : [ AuthGuardLogin ] } , { path : 's' , component : AdminComponent , canActivate : [ AuthGuardAdmin ] } , { path : 's' , component : NotFoundComponent } , { path : 's' , redirectTo : 's' } , ] ; @ NgModule ( { imports : [ RouterModule . forRoot ( routes ) ] , exports : [ RouterModule ] } ) export class AppRoutingModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Routes$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $string$ O O O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O O $any[]$ O O $any$ O O O O O $any$ O O
import { AfterViewChecked , ChangeDetectorRef , Component } from 's' ; import { AuthService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class AppComponent implements AfterViewChecked { constructor ( public auth , private changeDetector ) { } ngAfterViewChecked ( ) { this . changeDetector . detectChanges ( ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O O $AuthService$ O O $ChangeDetectorRef$ O O O $void$ O O O O O $any$ O $any$ O O O O O
import { NO_ERRORS_SCHEMA } from 's' ; import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { AppComponent } from 's' ; import { AuthService } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AppComponent > ; let authService ; let authServiceStub : { loggedIn : boolean , isAdmin : boolean , currentUser : any } ; beforeEach ( async ( ( ) => { authServiceStub = { loggedIn : false , isAdmin : false , currentUser : { username : 's' } } ; TestBed . configureTestingModule ( { declarations : [ AppComponent ] , providers : [ { provide : AuthService , useValue : authServiceStub } ] , schemas : [ NO_ERRORS_SCHEMA ] } ) . compileComponents ( ) . then ( ( ) => { fixture = TestBed . createComponent ( AppComponent ) ; component = fixture . componentInstance ; authService = fixture . debugElement . injector . get ( AuthService ) ; fixture . detectChanges ( ) ; } ) ; } ) ) ; it ( 's' , async ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; it ( 's' , ( ) => { const de = fixture . debugElement . queryAll ( By . css ( 's' ) ) ; expect ( de . length ) . toBe ( 0 ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { authService . loggedIn = true ; fixture . detectChanges ( ) ; const de = fixture . debugElement . queryAll ( By . css ( 's' ) ) ; expect ( de . length ) . toBe ( 0 ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { authService . loggedIn = true ; authService . isAdmin = true ; fixture . detectChanges ( ) ; const de = fixture . debugElement . queryAll ( By . css ( 's' ) ) ; expect ( de . length ) . toBe ( 0 ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . nativeElement . textContent ) . toContain ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; expect ( de [ 0 ] . attributes . routerLink ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AppComponent$ O O $ComponentFixture$ O $any$ O O O $AuthService$ O O $complex$ O O $boolean$ O O O $boolean$ O O O $any$ O O O O $any$ O $any$ O O O O O $complex$ O O $false$ O O O $false$ O O O $complex$ O O $string$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O O $any$ O $any$ O $complex$ O $complex$ O O O $any[]$ O O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $AppComponent$ O $any$ O $any$ O $AuthService$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $AppComponent$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $AuthService$ O $boolean$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $AuthService$ O $boolean$ O O O $AuthService$ O $boolean$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { Component , Input } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LoadingComponent { @ Input ( ) condition : boolean ; }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O $any$ O O $boolean$ O O O O
import { NgModule } from 's' ; import { BrowserModule } from 's' ; import { FormsModule , ReactiveFormsModule } from 's' ; import { HttpClientModule } from 's' ; import { ToastComponent } from 's' ; import { LoadingComponent } from 's' ; @ NgModule ( { imports : [ BrowserModule , FormsModule , ReactiveFormsModule , HttpClientModule ] , exports : [ BrowserModule , FormsModule , ReactiveFormsModule , HttpClientModule , ToastComponent , LoadingComponent ] , declarations : [ ToastComponent , LoadingComponent ] , providers : [ ToastComponent ] } ) export class SharedModule { }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O $complex$ O O $any$ O O O O O $any$ O O
import { NgModule , CUSTOM_ELEMENTS_SCHEMA } from 's' ; import { JwtModule } from 's' ; import { AppRoutingModule } from 's' ; import { SharedModule } from 's' ; import { CatService } from 's' ; import { UserService } from 's' ; import { AuthService } from 's' ; import { AuthGuardLogin } from 's' ; import { AuthGuardAdmin } from 's' ; import { AppComponent } from 's' ; import { CatsComponent } from 's' ; import { AboutComponent } from 's' ; import { RegisterComponent } from 's' ; import { LoginComponent } from 's' ; import { LogoutComponent } from 's' ; import { AccountComponent } from 's' ; import { AdminComponent } from 's' ; import { NotFoundComponent } from 's' ; export function tokenGetter ( ) { return localStorage . getItem ( 's' ) ; } @ NgModule ( { declarations : [ AppComponent , CatsComponent , AboutComponent , RegisterComponent , LoginComponent , LogoutComponent , AccountComponent , AdminComponent , NotFoundComponent ] , imports : [ AppRoutingModule , SharedModule , JwtModule . forRoot ( { config : { tokenGetter , } } ) ] , providers : [ AuthService , AuthGuardLogin , AuthGuardAdmin , CatService , UserService ] , schemas : [ CUSTOM_ELEMENTS_SCHEMA ] , bootstrap : [ AppComponent ] } ) export class AppModule { }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O $Storage$ O $string$ O O O O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O O $complex$ O O $any$ O O O O O $any$ O O
import { TestBed , async } from 's' ; import { CatsComponent } from 's' ;	O O $any$ O $any$ O O O O O O $any$ O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { LoginComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LoginComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LoginComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LoginComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $LoginComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $LoginComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { LogoutComponent } from 's' ; import { AuthService } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LogoutComponent > ; let authService ; let authServiceStub : { loggedIn : boolean , logout : any } ; beforeEach ( async ( ( ) => { authServiceStub = { loggedIn : true , logout : ( function ( ) { this . loggedIn = false ; } ) } ; TestBed . configureTestingModule ( { declarations : [ LogoutComponent ] , providers : [ { provide : AuthService , useValue : authServiceStub } ] , } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LogoutComponent ) ; component = fixture . componentInstance ; authService = fixture . debugElement . injector . get ( AuthService ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { authService . loggedIn = true ; expect ( authService . loggedIn ) . toBeTruthy ( ) ; authService . logout ( ) ; expect ( authService . loggedIn ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $LogoutComponent$ O O $ComponentFixture$ O $any$ O O O $AuthService$ O O $complex$ O O $boolean$ O O O $any$ O O O O $any$ O $any$ O O O O O $complex$ O O $true$ O O O $void$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O O $any$ O $any$ O $complex$ O $complex$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $LogoutComponent$ O $any$ O $any$ O $AuthService$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $LogoutComponent$ O O $any$ O O O O O O $any$ O O O O O O O $AuthService$ O $boolean$ O O O $any$ O $AuthService$ O $true$ O O $any$ O O O $AuthService$ O $void$ O O O $any$ O $AuthService$ O $true$ O O $any$ O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { NotFoundComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < NotFoundComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ NotFoundComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( NotFoundComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { const el = fixture . debugElement . query ( By . css ( 's' ) ) . nativeElement ; expect ( el . textContent ) . toContain ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $NotFoundComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $NotFoundComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $NotFoundComponent$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { RegisterComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < RegisterComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ RegisterComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( RegisterComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $RegisterComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $RegisterComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { LoadingComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LoadingComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LoadingComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LoadingComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { const de = fixture . debugElement . query ( By . css ( 's' ) ) ; expect ( de ) . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { component . condition = true ; fixture . detectChanges ( ) ; expect ( component ) . toBeTruthy ( ) ; const de = fixture . debugElement . query ( By . css ( 's' ) ) ; const el = de . nativeElement ; expect ( de ) . toBeDefined ( ) ; expect ( el . textContent ) . toContain ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $LoadingComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $LoadingComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $LoadingComponent$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $LoadingComponent$ O $boolean$ O O O $any$ O $any$ O O O $any$ O $LoadingComponent$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { By } from 's' ; import { ToastComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < ToastComponent > ; beforeEach ( async ( ( ) => { TestBed . configureTestingModule ( { declarations : [ ToastComponent ] } ) . compileComponents ( ) ; } ) ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( ToastComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { expect ( component . message . body ) . toBeFalsy ( ) ; expect ( component . message . type ) . toBeFalsy ( ) ; const de = fixture . debugElement . query ( By . css ( 's' ) ) ; expect ( de ) . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { const mockMessage = { body : 's' , type : 's' } ; component . setMessage ( mockMessage . body , mockMessage . type ) ; expect ( component . message . body ) . toBe ( mockMessage . body ) ; expect ( component . message . type ) . toBe ( mockMessage . type ) ; fixture . detectChanges ( ) ; const de = fixture . debugElement . query ( By . css ( 's' ) ) ; const el = de . nativeElement ; expect ( de ) . toBeDefined ( ) ; expect ( el . textContent ) . toContain ( mockMessage . body ) ; expect ( el . className ) . toContain ( mockMessage . type ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $ToastComponent$ O O $ComponentFixture$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $ToastComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $ToastComponent$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $ToastComponent$ O $complex$ O $string$ O O $any$ O O O $any$ O $ToastComponent$ O $complex$ O $string$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O $ToastComponent$ O $void$ O $complex$ O $string$ O $complex$ O $string$ O O $any$ O $ToastComponent$ O $complex$ O $string$ O O $any$ O $complex$ O $string$ O O $any$ O $ToastComponent$ O $complex$ O $string$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $complex$ O $string$ O O O O O O O O
export const environment = { production : true } ;	O O $complex$ O O $boolean$ O O O O
export const environment = { production : false } ;	O O $complex$ O O $boolean$ O O O O
import { enableProdMode } from 's' ; import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; import { environment } from 's' ; if ( environment . production ) { enableProdMode ( ) ; } platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) . catch ( err => console . error ( err ) ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $complex$ O $boolean$ O O $any$ O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $Console$ O $void$ O $any$ O O O
import 's' ;	O O O
import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const require ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ;	O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O
'js' const { SpecReporter } = require ( 's' ) ; exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , capabilities : { 's' : 's' } , directConnect : true , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : require ( 's' ) . join ( __dirname , 's' ) } ) ; jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) ; } } ;	O O O $any$ O O $any$ O O O O $any$ O $any$ O O $number$ O O O $string[]$ O O O O O $complex$ O O O O O O O $boolean$ O O O $string$ O O O $string$ O O O $complex$ O O $boolean$ O O O $number$ O O O $void$ O O O O O O O O $void$ O O O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O $complex$ O O $boolean$ O O O O O O O O O O
import { $$ , browser } from 's' ; export class 0 { navigateTo ( ) { return browser . get ( browser . baseUrl ) as Promise < any > ; } getNavbarElement ( n ) { return $$ ( 's' ) . get ( n ) . getText ( ) as Promise < string > ; } getNavbarButton ( ) { return $$ ( 's' ) . get ( 0 ) . getText ( ) as Promise < string > ; } }	O O $any$ O $any$ O O O O O O $any$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O $Promise<string>$ O $any$ O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $PromiseConstructor$ O O O O O $Promise<string>$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $PromiseConstructor$ O O O O O O
import { browser , logging } from 's' ; import { 0 } from 's' ; describe ( 's' , ( ) => { let page ; beforeEach ( ( ) => { page = new 0 ( ) ; } ) ; it ( 's' , ( ) => { browser . manage ( ) . window ( ) . setSize ( 0 , 0 ) ; page . navigateTo ( ) ; expect ( page . getNavbarElement ( 0 ) ) . toEqual ( 's' ) ; expect ( page . getNavbarElement ( 0 ) ) . toEqual ( 's' ) ; expect ( page . getNavbarElement ( 0 ) ) . toEqual ( 's' ) ; expect ( page . getNavbarElement ( 0 ) ) . toEqual ( 's' ) ; expect ( page . getNavbarButton ( ) ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { browser . manage ( ) . window ( ) . setSize ( 0 , 0 ) ; page . navigateTo ( ) ; expect ( page . getNavbarButton ( ) ) . toEqual ( 's' ) ; } ) ; afterEach ( async ( ) => { const logs = await browser . manage ( ) . logs ( ) . get ( logging . Type . BROWSER ) ; expect ( logs ) . not . toContain ( jasmine . objectContaining ( { level : logging . Level . SEVERE , } as logging . Entry ) ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $Angular2FullStackPage$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O O $Promise<any>$ O O O $any$ O O O $Promise<string>$ O O O O O $any$ O O O O $any$ O O O $Promise<string>$ O O O O O $any$ O O O O $any$ O O O $Promise<string>$ O O O O O $any$ O O O O $any$ O O O $Promise<string>$ O O O O O $any$ O O O O $any$ O O O $Promise<string>$ O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O O $Promise<any>$ O O O $any$ O O O $Promise<string>$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { clearContext : false } , coverageIstanbulReporter : { dir : require ( 's' ) . join ( __dirname , 's' ) , reports : [ 's' , 's' , 's' ] , fixWebpackSourcePaths : true } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , browsers : [ 's' ] , singleRun : false , restartOnFileChange : true } ) ; } ;	O $void$ O $void$ O O O $any$ O O $any$ O $any$ O O $string$ O O O $string[]$ O O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $complex$ O O $boolean$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string[]$ O O O O O O O O O $boolean$ O O O O $string[]$ O O O O O O O $number$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $boolean$ O O O $string[]$ O O O O O $boolean$ O O O $boolean$ O O O O O O O
import * as mongoose from 's' ; const catSchema = new mongoose . Schema ( { name : String , weight : Number , age : Number } ) ; const Cat = mongoose . model ( 's' , catSchema ) ; export default Cat ;	O O O $any$ O O O O $any$ O O $any$ O $any$ O O $StringConstructor$ O $StringConstructor$ O $NumberConstructor$ O $NumberConstructor$ O $NumberConstructor$ O $NumberConstructor$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O
abstract class BaseCtrl { abstract model : any ; getAll = async ( req , res ) => { try { const docs = await this . model . find ( { } ) ; res . status ( 0 ) . json ( docs ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } count = async ( req , res ) => { try { const count = await this . model . count ( ) ; res . status ( 0 ) . json ( count ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } insert = async ( req , res ) => { try { const obj = await new this . model ( req . body ) . save ( ) ; res . status ( 0 ) . json ( obj ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } get = async ( req , res ) => { try { const obj = await this . model . findOne ( { _id : req . params . id } ) ; res . status ( 0 ) . json ( obj ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } update = async ( req , res ) => { try { await this . model . findOneAndUpdate ( { _id : req . params . id } , req . body ) ; res . sendStatus ( 0 ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } delete = async ( req , res ) => { try { await this . model . findOneAndRemove ( { _id : req . params . id } ) ; res . sendStatus ( 0 ) ; } catch ( err ) { return res . status ( 0 ) . json ( { error : err . message } ) ; } } } export default BaseCtrl ;	O O $any$ O O $any$ O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O
import Cat from 's' ; import BaseCtrl from 's' ; export default class CatCtrl extends BaseCtrl { model = Cat ; }	O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O
import * as bcrypt from 's' ; import * as mongoose from 's' ; const userSchema = new mongoose . Schema ( { username : String , email : { type : String , unique : true , lowercase : true , trim : true } , password : String , role : String } ) ; userSchema . pre ( 's' , function ( next ) { const user = this ; if ( ! user . isModified ( 's' ) ) { return next ( ) ; } bcrypt . genSalt ( 0 , ( err , salt ) => { if ( err ) { return next ( err ) ; } bcrypt . hash ( user . password , salt , ( error , hash ) => { if ( error ) { return next ( error ) ; } user . password = hash ; next ( ) ; } ) ; } ) ; } ) ; userSchema . methods . comparePassword = function ( candidatePassword , callback ) { bcrypt . compare ( candidatePassword , this . password , ( err , isMatch ) => { if ( err ) { return callback ( err ) ; } callback ( null , isMatch ) ; } ) ; } ; userSchema . set ( 's' , { transform : ( doc , ret , options ) => { delete ret . password ; return ret ; } } ) ; const User = mongoose . model ( 's' , userSchema ) ; export default User ;	O O O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O $StringConstructor$ O $StringConstructor$ O $complex$ O O $StringConstructor$ O $StringConstructor$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O $StringConstructor$ O $StringConstructor$ O $StringConstructor$ O $StringConstructor$ O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O
import * as jwt from 's' ; import User from 's' ; import BaseCtrl from 's' ; export default class UserCtrl extends BaseCtrl { model = User ; login = ( req , res ) => { this . model . findOne ( { email : req . body . email } , ( err , user ) => { if ( ! user ) { return res . sendStatus ( 0 ) ; } user . comparePassword ( req . body . password , ( error , isMatch ) => { if ( ! isMatch ) { return res . sendStatus ( 0 ) ; } const token = jwt . sign ( { user } , process . env . SECRET_TOKEN ) ; res . status ( 0 ) . json ( { token } ) ; } ) ; } ) ; } }	O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O O
import * as express from 's' ; import CatCtrl from 's' ; import UserCtrl from 's' ; export default function setRoutes ( app ) { const router = express . Router ( ) ; const catCtrl = new CatCtrl ( ) ; const userCtrl = new UserCtrl ( ) ; router . route ( 's' ) . get ( catCtrl . getAll ) ; router . route ( 's' ) . get ( catCtrl . count ) ; router . route ( 's' ) . post ( catCtrl . insert ) ; router . route ( 's' ) . get ( catCtrl . get ) ; router . route ( 's' ) . put ( catCtrl . update ) ; router . route ( 's' ) . delete ( catCtrl . delete ) ; router . route ( 's' ) . post ( userCtrl . login ) ; router . route ( 's' ) . get ( userCtrl . getAll ) ; router . route ( 's' ) . get ( userCtrl . count ) ; router . route ( 's' ) . post ( userCtrl . insert ) ; router . route ( 's' ) . get ( userCtrl . get ) ; router . route ( 's' ) . put ( userCtrl . update ) ; router . route ( 's' ) . delete ( userCtrl . delete ) ; app . use ( 's' , router ) ; }	O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $any$ O O O $any$ O $any$ O $any$ O O O O $CatCtrl$ O O $any$ O O O O $UserCtrl$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $CatCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $void$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $UserCtrl$ O $Promise<any>$ O O $any$ O $any$ O O O $any$ O O O
import * as dotenv from 's' ; import * as express from 's' ; import * as morgan from 's' ; import * as mongoose from 's' ; import * as path from 's' ; import setRoutes from 's' ; const app = express ( ) ; dotenv . config ( ) ; app . set ( 's' , ( process . env . PORT || 0 ) ) ; app . use ( 's' , express . static ( path . join ( __dirname , 's' ) ) ) ; app . use ( express . json ( ) ) ; app . use ( express . urlencoded ( { extended : false } ) ) ; let mongodbURI ; if ( process . env . NODE_ENV === 's' ) { mongodbURI = process . env . MONGODB_TEST_URI ; } else { mongodbURI = process . env . MONGODB_URI ; app . use ( morgan ( 's' ) ) ; } mongoose . Promise = global . Promise ; mongoose . connect ( mongodbURI ) . then ( db => { console . log ( 's' ) ; setRoutes ( app ) ; app . get ( 's' , ( req , res ) => { res . sendFile ( path . join ( __dirname , 's' ) ) ; } ) ; if ( ! module . parent ) { app . listen ( app . get ( 's' ) , ( ) => console . log ( `template` ) ) ; } } ) . catch ( err => console . error ( err ) ) ; export { app } ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $Console$ O $void$ O O O O $void$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $Console$ O $void$ O O O O O O O O O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O $any$ O O
import * as chai from 's' ; import chaiHttp = require ( 's' ) ; import { describe , it } from 's' ; process . env . NODE_ENV = 's' ; import { app } from 's' ; import Cat from 's' ; chai . use ( chaiHttp ) . should ( ) ; describe ( 's' , ( ) => { beforeEach ( done => { Cat . remove ( { } , err => { done ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , done => { chai . request ( app ) . get ( 's' ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . length . should . be . eql ( 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { chai . request ( app ) . get ( 's' ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . be . eql ( 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { const cat = new Cat ( { name : 's' , weight : 0 , age : 0 } ) ; chai . request ( app ) . post ( 's' ) . send ( cat ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . have . a . property ( 's' ) ; res . body . should . have . a . property ( 's' ) ; res . body . should . have . a . property ( 's' ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { const cat = new Cat ( { name : 's' , weight : 0 , age : 0 } ) ; cat . save ( ( error , newCat ) => { chai . request ( app ) . get ( `template` ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) . eql ( newCat . id ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { const cat = new Cat ( { name : 's' , weight : 0 , age : 0 } ) ; cat . save ( ( error , newCat ) => { chai . request ( app ) . put ( `template` ) . send ( { weight : 0 } ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { const cat = new Cat ( { name : 's' , weight : 0 , age : 0 } ) ; cat . save ( ( error , newCat ) => { chai . request ( app ) . del ( `template` ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $number$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O
import * as chai from 's' ; import chaiHttp = require ( 's' ) ; import { describe , it } from 's' ; process . env . NODE_ENV = 's' ; import { app } from 's' ; import User from 's' ; chai . use ( chaiHttp ) . should ( ) ; describe ( 's' , ( ) => { beforeEach ( done => { User . remove ( { } , err => { done ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , done => { chai . request ( app ) . get ( 's' ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . length . should . be . eql ( 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { chai . request ( app ) . get ( 's' ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . be . eql ( 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { const user = new User ( { username : 's' , email : 's' , role : 's' } ) ; chai . request ( app ) . post ( 's' ) . send ( user ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . have . a . property ( 's' ) ; res . body . should . have . a . property ( 's' ) ; res . body . should . have . a . property ( 's' ) ; done ( ) ; } ) ; } ) ; it ( 's' , done => { const user = new User ( { username : 's' , email : 's' , role : 's' } ) ; user . save ( ( error , newUser ) => { chai . request ( app ) . get ( `template` ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; res . body . should . be . a ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) ; res . body . should . have . property ( 's' ) . eql ( newUser . id ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { const user = new User ( { username : 's' , email : 's' , role : 's' } ) ; user . save ( ( error , newUser ) => { chai . request ( app ) . put ( `template` ) . send ( { username : 's' } ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { const user = new User ( { username : 's' , email : 's' , role : 's' } ) ; user . save ( ( error , newUser ) => { chai . request ( app ) . del ( `template` ) . end ( ( err , res ) => { res . should . have . status ( 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $string$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O