import * as yargs from 's' ; type Options = { fileName : string | undefined ; port : number ; corsOrigin : string | true ; openEditor : boolean ; extendURL : string | undefined ; headers : { [ key ] : string } ; forwardHeaders : [ string ] ; } function builder ( cmd ) { return cmd . positional ( 's' , { describe : 's' , type : 's' , nargs : 0 , } ) . options ( { 's' : { alias : 's' , describe : 's' , type : 's' , requiresArg : true , default : process . env . PORT || 0 , } , 's' : { alias : 's' , describe : 's' , type : 's' , } , 's' : { alias : 's' , describe : 's' , type : 's' , requiresArg : true , default : true , } , 's' : { alias : 's' , describe : 's' , type : 's' , requiresArg : true , } , 's' : { alias : 's' , describe : 's' , array : true , type : 's' , requiresArg : true , implies : 's' , coerce ( arr ) { const headers = { } ; for ( const str of arr ) { const [ , name , value ] = str . match ( "s" ) ; headers [ name . toLowerCase ( ) ] = value . trim ( ) ; } return headers ; } , } , 's' : { describe : 's' , array : true , type : 's' , implies : 's' , coerce ( arr ) { return arr . map ( str => str . toLowerCase ( ) ) ; } , } , } ) . epilog ( epilog ) . strict ( ) ; } export function parseCLI ( commandCB : ( options ) => void ) { yargs . usage ( 's' , 's' , builder , handler ) . help ( 's' ) . alias ( 's' , 's' ) . argv ; function handler ( argv ) { commandCB ( { fileName : argv . SDLFile , port : argv . port , corsOrigin : argv [ 's' ] , openEditor : argv . open , extendURL : argv . extend , headers : argv . header || { } , forwardHeaders : argv . forwardHeaders || [ ] , } ) ; } } const epilog = `template` ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Options$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { plugins : [ require ( 's' ) , ] }	O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const path = require ( 's' ) ; const ExtractTextPlugin = require ( 's' ) ; function root ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) ; return path . join . apply ( path , [ __dirname ] . concat ( args ) ) ; } module . exports = { devtool : 's' , performance : { hints : false , } , devServer : { contentBase : root ( 's' ) , watchContentBase : true , port : 0 , stats : 's' , proxy : { 's' : 's' , 's' : 's' , } , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' ] , } , entry : [ 's' ] , output : { path : root ( 's' ) , filename : 's' , sourceMapFilename : 's' , } , module : { rules : [ { test : "s" , loader : 's' , exclude : "s" , } , { test : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : [ { loader : 's' , options : { sourceMap : true , minimize : true , } , } , 's' , ] , } ) , } , ] , } , plugins : [ new webpack . LoaderOptionsPlugin ( { minimize : true , debug : false , } ) , new ExtractTextPlugin ( { filename : 's' , allChunks : true , } ) , new webpack . IgnorePlugin ( "s" , "s" ) ] , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const faker = require ( 's' ) ; import * as moment from 's' ; export function getRandomInt ( min , max ) { return faker . random . number ( { min , max } ) ; } export function getRandomItem < T > ( array < T > ) : T { return array [ getRandomInt ( 0 , array . length - 0 ) ] ; } export const stdScalarFakers = { 's' : ( ) => faker . random . number ( { min : 0 , max : 0 , precision : 0 } ) , 's' : ( ) => faker . random . number ( { min : 0 , max : 0 , precision : 0 } ) , 's' : ( ) => 's' , 's' : ( ) => faker . random . boolean ( ) , 's' : ( ) => 0 ( faker . random . number ( { max : 0 } ) . toString ( ) ) , } ; function 0 ( str ) { return Buffer . from ( str ) . toString ( 's' ) ; } const fakeFunctions = { zipCode : ( ) => faker . address . zipCode ( ) , city : ( ) => faker . address . city ( ) , streetName : ( ) => faker . address . streetName ( ) , streetAddress : { args : [ 's' ] , func : ( useFullAddress ) => faker . address . streetAddress ( useFullAddress ) , } , secondaryAddress : ( ) => faker . address . secondaryAddress ( ) , county : ( ) => faker . address . county ( ) , country : ( ) => faker . address . country ( ) , countryCode : ( ) => faker . address . countryCode ( ) , state : ( ) => faker . address . state ( ) , stateAbbr : ( ) => faker . address . stateAbbr ( ) , latitude : ( ) => faker . address . latitude ( ) , longitude : ( ) => faker . address . longitude ( ) , colorName : ( ) => faker . commerce . color ( ) , productCategory : ( ) => faker . commerce . department ( ) , productName : ( ) => faker . commerce . productName ( ) , money : { args : [ 's' , 's' , 's' ] , func : ( min , max , dec ) => faker . commerce . price ( min , max , dec ) , } , productMaterial : ( ) => faker . commerce . productMaterial ( ) , product : ( ) => faker . commerce . product ( ) , companyName : ( ) => faker . company . companyName ( ) , companyCatchPhrase : ( ) => faker . company . catchPhrase ( ) , companyBs : ( ) => faker . company . bs ( ) , dbColumn : ( ) => faker . database . column ( ) , dbType : ( ) => faker . database . type ( ) , dbCollation : ( ) => faker . database . collation ( ) , dbEngine : ( ) => faker . database . engine ( ) , pastDate : { args : [ 's' ] , func : ( dateFormat ) => { const date = faker . date . past ( ) return ( dateFormat !== undefined ? moment ( date ) . format ( dateFormat ) : date ) } } , futureDate : { args : [ 's' ] , func : ( dateFormat ) => { const date = faker . date . future ( ) return ( dateFormat !== undefined ? moment ( date ) . format ( dateFormat ) : date ) } } , recentDate : { args : [ 's' ] , func : ( dateFormat ) => { const date = faker . date . recent ( ) return ( dateFormat !== undefined ? moment ( date ) . format ( dateFormat ) : date ) } } , financeAccountName : ( ) => faker . finance . accountName ( ) , financeTransactionType : ( ) => faker . finance . transactionType ( ) , currencyCode : ( ) => faker . finance . currencyCode ( ) , currencyName : ( ) => faker . finance . currencyName ( ) , currencySymbol : ( ) => faker . finance . currencySymbol ( ) , bitcoinAddress : ( ) => faker . finance . bitcoinAddress ( ) , internationalBankAccountNumber : ( ) => faker . finance . iban ( ) , bankIdentifierCode : ( ) => faker . finance . bic ( ) , hackerAbbr : ( ) => faker . hacker . itAbbr ( ) , hackerPhrase : ( ) => faker . hacker . phrase ( ) , imageUrl : { args : [ 's' , 's' , 's' , 's' ] , func : ( height , width , category , randomize ) => faker . image . imageUrl ( height , width , category , randomize , false ) , } , avatarUrl : ( ) => faker . internet . avatar ( ) , email : { args : [ 's' ] , func : ( provider ) => faker . internet . email ( undefined , undefined , provider ) , } , url : ( ) => faker . internet . url ( ) , domainName : ( ) => faker . internet . domainName ( ) , 0 : ( ) => faker . internet . ip ( ) , 0 : ( ) => faker . internet . 0 ( ) , userAgent : ( ) => faker . internet . userAgent ( ) , colorHex : { args : [ 's' ] , func : ( { 0 , 0 , 0 } ) => { return faker . internet . color ( 0 , 0 , 0 ) ; } , } , macAddress : ( ) => faker . internet . mac ( ) , password : { args : [ 's' ] , func : ( len ) => faker . internet . password ( len ) , } , lorem : { args : [ 's' ] , func : ( size ) => faker . lorem [ size || 's' ] ( ) , } , firstName : ( ) => faker . name . firstName ( ) , lastName : ( ) => faker . name . lastName ( ) , fullName : ( ) => faker . name . findName ( ) , jobTitle : ( ) => faker . name . jobTitle ( ) , phoneNumber : ( ) => faker . phone . phoneNumber ( ) , number : { args : [ 's' , 's' , 's' ] , func : ( min , max , precision ) => faker . random . number ( { min , max , precision } ) , } , uuid : ( ) => faker . random . uuid ( ) , word : ( ) => faker . random . word ( ) , words : ( ) => faker . random . words ( ) , locale : ( ) => faker . random . locale ( ) , filename : ( ) => faker . system . commonFileName ( ) , mimeType : ( ) => faker . system . mimeType ( ) , fileExtension : ( ) => faker . system . fileExt ( ) , semver : ( ) => faker . system . semver ( ) , } ; Object . keys ( fakeFunctions ) . forEach ( key => { var value = fakeFunctions [ key ] ; if ( typeof fakeFunctions [ key ] === 's' ) fakeFunctions [ key ] = { args : [ ] , func : value } ; } ) ; export function fakeValue ( type , options ? , locale ? ) { const fakeGenerator = fakeFunctions [ type ] ; const argNames = fakeGenerator . args ; const callArgs = argNames . map ( name => options [ name ] ) ; const localeBackup = faker . locale ; faker . locale = locale || localeBackup ; const result = fakeGenerator . func ( ... callArgs ) ; faker . locale = localeBackup ; return result ; }	O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $ReadonlyArray$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Kind , parse , concatAST , DocumentNode } from 's' ; const fakeDefinitionAST = parse ( `template` ) ; function defToName ( defNode ) { const { kind , name } = defNode ; if ( name == null ) { return 's' ; } return ( kind === Kind . DIRECTIVE_DEFINITION ? 's' : 's' ) + name . value ; } const fakeDefinitionsSet = new Set ( fakeDefinitionAST . definitions . map ( defToName ) , ) ; export function mergeWithFakeDefinitions ( schemaAST , ) { const filteredAST = { ... schemaAST , definitions : schemaAST . definitions . filter ( def => { const name = defToName ( def ) ; return name === 's' || ! fakeDefinitionsSet . has ( name ) ; } ) , } ; return concatAST ( [ filteredAST , fakeDefinitionAST ] ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DocumentNode$ O $DocumentNode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { isListType , isNonNullType , isObjectType , isInputObjectType , isEnumType , isLeafType , isAbstractType , GraphQLLeafType , GraphQLTypeResolver , GraphQLFieldResolver , defaultTypeResolver , defaultFieldResolver , getDirectiveValues , } from 's' ; import { getRandomInt , getRandomItem , stdScalarFakers , fakeValue } from 's' ; type FakeArgs = { type : string ; options : { [ key ] : any } ; locale : string ; } ; type ExamplesArgs = { values : [ any ] ; } ; type ListLengthArgs = { min : number ; max : number ; } ; type DirectiveArgs = { fake ? : FakeArgs ; examples ? : ExamplesArgs ; listLength ? : ListLengthArgs ; } ; export const fakeTypeResolver < unknown , unknown > = async ( value , context , info , abstractType , ) => { const defaultResolved = await defaultTypeResolver ( value , context , info , abstractType , ) ; if ( defaultResolved != null ) { return defaultResolved ; } const possibleTypes = info . schema . getPossibleTypes ( abstractType ) ; return getRandomItem ( possibleTypes ) ; } ; export const fakeFieldResolver < unknown , unknown > = async ( source , args , context , info , ) => { const { schema , parentType , fieldName } = info ; const fieldDef = parentType . getFields ( ) [ fieldName ] ; let defaultResolved = await defaultFieldResolver ( source , args , context , info ) ; if ( defaultResolved instanceof Error ) { return defaultResolved ; } const mutationType = schema . getMutationType ( ) ; const isMutation = parentType === mutationType ; if ( isMutation && isRelayMutation ( fieldDef ) ) { return { ... args [ 's' ] , ... ( defaultResolved || { } ) } ; } if ( defaultResolved != null ) { return defaultResolved ; } return fakeValueOfType ( fieldDef . type ) ; function fakeValueOfType ( type ) { if ( isNonNullType ( type ) ) { return fakeValueOfType ( type . ofType ) ; } if ( isListType ( type ) ) { return Array ( getListLength ( fieldDef ) ) . fill ( null ) . map ( ( ) => fakeValueOfType ( type . ofType ) ) ; } const valueCB = getExampleValueCB ( fieldDef ) || getFakeValueCB ( fieldDef ) || getExampleValueCB ( type ) || getFakeValueCB ( type ) ; if ( isLeafType ( type ) ) { if ( valueCB ) { return valueCB ( ) ; } return fakeLeafValueCB ( type ) } else { const __typename = isAbstractType ( type ) ? getRandomItem ( schema . getPossibleTypes ( type ) ) . name : type . name ; return { __typename , ... ( valueCB ? valueCB ( ) : { } ) , } ; } } function getFakeValueCB ( object ) { const fakeDirective = schema . getDirective ( 's' ) ; const args = getDirectiveArgs ( fakeDirective , object ) as FakeArgs ; return args && ( ( ) => fakeValue ( args . type , args . options , args . locale ) ) ; } function getExampleValueCB ( object ) { const examplesDirective = schema . getDirective ( 's' ) ; const args = getDirectiveArgs ( examplesDirective , object ) as ExamplesArgs ; return args && ( ( ) => getRandomItem ( args . values ) ) ; } function getListLength ( object ) { const listLength = schema . getDirective ( 's' ) ; const args = getDirectiveArgs ( listLength , object ) as ListLengthArgs ; return args ? getRandomInt ( args . min , args . max ) : getRandomInt ( 0 , 0 ) ; } } ; function fakeLeafValueCB ( type ) { if ( isEnumType ( type ) ) { const values = type . getValues ( ) . map ( x => x . value ) ; return getRandomItem ( values ) ; } const faker = stdScalarFakers [ type . name ] ; if ( faker ) return faker ( ) ; return `template` ; } function isRelayMutation ( fieldDef ) { const { args } = fieldDef ; if ( args . length !== 0 || args [ 0 ] . name !== 's' ) { return false ; } const inputType = args [ 0 ] . type ; return ( isNonNullType ( inputType ) && isInputObjectType ( inputType . ofType ) && isObjectType ( fieldDef . type ) ) ; } function getDirectiveArgs ( directive , object ) { assert ( directive != null ) ; let args = undefined ; if ( object . astNode != null ) { args = getDirectiveValues ( directive , object . astNode ) ; } if ( object . extensionNodes != null ) { for ( const node of object . extensionNodes ) { args = getDirectiveValues ( directive , node ) ; } } return args ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GraphQLTypeResolver$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GraphQLFieldResolver$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ListLengthArgs$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GraphQLLeafType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DirectiveArgs$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; import fetch from 's' ; import { Headers } from 's' ; import { Source , GraphQLSchema , buildClientSchema , introspectionQuery , } from 's' ; export function existsSync ( filePath ) { try { fs . statSync ( filePath ) ; } catch ( err ) { if ( err . code == 's' ) return false ; } return true ; } export function readSDL ( filepath ) { return new Source ( fs . readFileSync ( filepath , 's' ) , filepath ) ; } export function getRemoteSchema ( url , headers : { [ name ] : string } , ) < GraphQLSchema > { return graphqlRequest ( url , headers , introspectionQuery ) . then ( response => { if ( response . errors ) { throw Error ( JSON . stringify ( response . errors , null , 0 ) ) ; } return buildClientSchema ( response . data ) ; } ) . catch ( error => { throw Error ( `template` ) ; } ) } export function graphqlRequest ( url , headers , query , variables ? , operationName ? ) { return fetch ( url , { method : 's' , headers : new Headers ( { "s" : 's' , ... ( headers || { } ) , } ) , body : JSON . stringify ( { operationName , query , variables , } ) } ) . then ( responce => { if ( responce . ok ) return responce . json ( ) ; return responce . text ( ) . then ( body => { throw Error ( `template` ) ; } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O $string$ O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Request } from 's' ; import { Kind , print , visit , execute , TypeInfo , isAbstractType , visitWithTypeInfo , separateOperations , ExecutionArgs , GraphQLError , } from 's' ; import { graphqlRequest } from 's' ; export function getProxyExecuteFn ( url , headers , forwardHeaders ) { return ( args ) => { const { schema , document , contextValue , operationName } = args ; const request = ( contextValue as Request ) ; const proxyHeaders = Object . create ( null ) ; for ( const name of forwardHeaders ) { proxyHeaders [ name ] = request . headers [ name ] ; } const strippedAST = removeUnusedVariables ( stripExtensionFields ( schema , document ) , ) ; const operations = separateOperations ( strippedAST ) ; const operationAST = operationName ? operations [ operationName ] : Object . values ( operations ) [ 0 ] ; return graphqlRequest ( url , { ... headers , ... proxyHeaders } , print ( operationAST ) , args . variableValues , operationName , ) . then ( result => proxyResponse ( result , args ) ) ; } ; } function proxyResponse ( response , args ) { const rootValue = response . data || { } ; const globalErrors = [ ] ; for ( const error of ( response . errors || [ ] ) ) { const { message , path , extensions } = error ; const errorObj = new GraphQLError ( message , undefined , undefined , undefined , path , undefined , extensions , ) ; if ( ! path ) { globalErrors . push ( errorObj ) ; continue ; } pathSet ( rootValue , error . path , errorObj ) ; } if ( globalErrors . length !== 0 ) { return { errors : globalErrors } ; } return execute ( { ... args , rootValue } ) ; } function pathSet ( rootObject , path , value ) { let currentObject = rootObject ; const basePath = [ ... path ] ; const lastKey = basePath . pop ( ) ; for ( const key of basePath ) { if ( currentObject [ key ] == null ) { currentObject [ key ] = typeof key === 's' ? [ ] : { } ; } currentObject = currentObject [ key ] ; } currentObject [ lastKey ] = value ; } function injectTypename ( node ) { return { ... node , selections : [ ... node . selections , { kind : Kind . FIELD , name : { kind : Kind . NAME , value : 's' , } , } , ] , } ; } function stripExtensionFields ( schema , operationAST ) { const typeInfo = new TypeInfo ( schema ) ; return visit ( operationAST , visitWithTypeInfo ( typeInfo , { [ Kind . FIELD ] : ( ) => { const fieldDef = typeInfo . getFieldDef ( ) ; if ( fieldDef . name . startsWith ( 's' ) || ( fieldDef as any ) . isExtensionField ) return null ; } , [ Kind . SELECTION_SET ] : { leave ( node ) { const type = typeInfo . getParentType ( ) if ( isAbstractType ( type ) || node . selections . length === 0 ) return injectTypename ( node ) ; } } , } ) ) ; } function removeUnusedVariables ( documentAST ) { const seenVariables = Object . create ( null ) ; visit ( documentAST , { [ Kind . VARIABLE_DEFINITION ] : ( ) => false , [ Kind . VARIABLE ] : ( node ) => { seenVariables [ node . name . value ] = true ; } , } ) ; return visit ( documentAST , { [ Kind . VARIABLE_DEFINITION ] : ( node ) => { if ( ! seenVariables [ node . variable . name . value ] ) { return null ; } } } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExecutionArgs$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Source , GraphQLSchema , parse , printSchema , buildASTSchema , extendSchema , isObjectType , isInterfaceType , } from 's' ; import * as fs from 's' ; import * as path from 's' ; import * as express from 's' ; import * as graphqlHTTP from 's' ; import chalk from 's' ; import * as open from 's' ; import * as cors from 's' ; import * as bodyParser from 's' ; import { parseCLI } from 's' ; import { getProxyExecuteFn } from 's' ; import { mergeWithFakeDefinitions } from 's' ; import { existsSync , readSDL , getRemoteSchema } from 's' ; import { fakeTypeResolver , fakeFieldResolver } from 's' ; const log = console . log ; parseCLI ( ( options ) => { const { extendURL , headers , forwardHeaders } = options ; const fileName = options . fileName || ( extendURL ? 's' : 's' ) ; if ( ! options . fileName ) { log ( chalk . yellow ( `template` + `template` ) ) ; } let userSDL = existsSync ( fileName ) && readSDL ( fileName ) ; if ( extendURL ) { getRemoteSchema ( extendURL , headers ) . then ( schema => { const remoteSDL = new Source ( printSchema ( schema ) , `template` , ) ; if ( ! userSDL ) { let body = fs . readFileSync ( path . join ( __dirname , 's' ) , 's' , ) ; const rootTypeName = schema . getQueryType ( ) . name ; body = body . replace ( 's' , rootTypeName ) ; userSDL = new Source ( body , fileName ) ; } const executeFn = getProxyExecuteFn ( extendURL , headers , forwardHeaders ) ; runServer ( options , userSDL , remoteSDL , executeFn ) ; } ) . catch ( error => { log ( chalk . red ( error . stack ) ) ; process . exit ( 0 ) ; } ) ; } else { if ( ! userSDL ) { userSDL = new Source ( fs . readFileSync ( path . join ( __dirname , 's' ) , 's' ) , fileName , ) ; } runServer ( options , userSDL ) ; } } ) ; function runServer ( options , userSDL , remoteSDL ? , customExecuteFn ? ) { const { port , openEditor } = options ; const corsOptions = { credentials : true , origin : options . corsOrigin , } ; const app = express ( ) ; app . options ( 's' , cors ( corsOptions ) ) ; app . use ( 's' , cors ( corsOptions ) , graphqlHTTP ( ( ) => ( { schema : remoteSDL ? buildSchema ( remoteSDL , userSDL ) : buildSchema ( userSDL ) , typeResolver : fakeTypeResolver , fieldResolver : fakeFieldResolver , customExecuteFn , graphiql : true , } ) ) ) ; app . get ( 's' , ( _ , res ) => { res . status ( 0 ) . json ( { userSDL : userSDL . body , remoteSDL : remoteSDL && remoteSDL . body , } ) ; } ) ; app . use ( 's' , bodyParser . text ( { limit : 's' } ) ) ; app . post ( 's' , ( req , res ) => { try { const fileName = userSDL . name ; fs . writeFileSync ( fileName , req . body ) ; userSDL = new Source ( req . body , fileName ) ; const date = ( new Date ( ) ) . toLocaleString ( ) ; log ( `template` ) ; res . status ( 0 ) . send ( 's' ) ; } catch ( err ) { res . status ( 0 ) . send ( err . message ) } } ) ; app . use ( 's' , express . static ( path . join ( __dirname , 's' ) ) ) ; const server = app . listen ( port ) ; const shutdown = ( ) => { server . close ( ) ; process . exit ( 0 ) ; } ; process . on ( 's' , shutdown ) ; process . on ( 's' , shutdown ) ; log ( `template` ) ; if ( openEditor ) { setTimeout ( ( ) => open ( `template` ) , 0 ) ; } } function buildSchema ( schemaSDL , extendSDL ? ) { let schemaAST = parse ( schemaSDL ) ; let schema = buildASTSchema ( mergeWithFakeDefinitions ( schemaAST ) ) ; if ( extendSDL ) { schema = extendSchema ( schema , parse ( extendSDL ) ) ; for ( const type of Object . values ( schema . getTypeMap ( ) ) ) { if ( isObjectType ( type ) || isInterfaceType ( type ) ) { for ( const field of Object . values ( type . getFields ( ) ) ) { const node = field . astNode ; if ( node && node . loc && node . loc . source === extendSDL ) { ( field as any ) . isExtensionField = true ; } } } } } return schema ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GraphQLSchema$ O $Source$ O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O