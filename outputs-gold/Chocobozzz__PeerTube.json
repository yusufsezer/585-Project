'js' const { SpecReporter } = require ( 's' ) exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , directConnect : true , capabilities : { 's' : 's' , 's' : { binary : 's' , log : { "s" : "s" } } } , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : require ( 's' ) . join ( __dirname , 's' ) } ) jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { SpecReporter } = require ( 's' ) exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , seleniumAddress : 's' , commonCapabilities : { 's' : process . env . BROWSERSTACK_USER , 's' : process . env . BROWSERSTACK_KEY , 's' : true , project : 's' } , multiCapabilities : [ { browserName : 's' , name : 's' , resolution : 's' } , { browserName : 's' , version : 's' , name : 's' , resolution : 's' } , { browserName : 's' , version : 's' , name : 's' , resolution : 's' } , { browserName : 's' , name : 's' , resolution : 's' } , { browserName : 's' , name : 's' , resolution : 's' } , { browserName : 's' , device : 's' , realMobile : 's' , os_version : 's' , name : 's' } , { browserName : 's' , device : 's' , realMobile : 's' , os_version : 's' , name : 's' } ] , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : require ( 's' ) . join ( __dirname , 's' ) } ) jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) } } exports . config . multiCapabilities . forEach ( function ( caps ) { for ( var i in exports . config . commonCapabilities ) caps [ i ] = caps [ i ] || exports . config . commonCapabilities [ i ] } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , element , by } from 's' export class LoginPage { async loginAsRootUser ( ) { await browser . get ( 's' ) element ( by . css ( 's' ) ) . sendKeys ( 's' ) element ( by . css ( 's' ) ) . sendKeys ( 's' ) await browser . sleep ( 0 ) await element ( by . css ( 's' ) ) . click ( ) expect ( this . getLoggedInInfo ( ) . getText ( ) ) . toContain ( 's' ) } private getLoggedInInfo ( ) { return element ( by . css ( 's' ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { by , element } from 's' export class MyAccountPage { navigateToMyVideos ( ) { return element ( by . css ( 's' ) ) . click ( ) } navigateToMyPlaylists ( ) { return element ( by . css ( 's' ) ) . click ( ) } navigateToMyHistory ( ) { return element ( by . css ( 's' ) ) . click ( ) } removeVideo ( name ) { return this . getVideoElement ( name ) . element ( by . css ( 's' ) ) . click ( ) } validRemove ( ) { return element ( by . css ( 's' ) ) . click ( ) } countVideos ( names : string [ ] ) { return element . all ( by . css ( 's' ) ) . filter ( e => { return e . element ( by . css ( 's' ) ) . getText ( ) . then ( t => names . some ( n => t . includes ( n ) ) ) } ) . count ( ) } getPlaylistVideosText ( name ) { return this . getPlaylist ( name ) . element ( by . css ( 's' ) ) . getText ( ) } clickOnPlaylist ( name ) { return this . getPlaylist ( name ) . element ( by . css ( 's' ) ) . click ( ) } countTotalPlaylistElements ( ) { return element . all ( by . css ( 's' ) ) . count ( ) } playPlaylist ( ) { return element ( by . css ( 's' ) ) . click ( ) } private getVideoElement ( name ) { return element . all ( by . css ( 's' ) ) . filter ( e => e . element ( by . css ( 's' ) ) . getText ( ) . then ( t => t . includes ( name ) ) ) . first ( ) } private getPlaylist ( name ) { return element . all ( by . css ( 's' ) ) . filter ( e => e . element ( by . css ( 's' ) ) . getText ( ) . then ( t => t . includes ( name ) ) ) . first ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { by , element } from 's' export class VideoUpdatePage { async updateName ( videoName ) { const nameInput = element ( by . css ( 's' ) ) await nameInput . clear ( ) await nameInput . sendKeys ( videoName ) } async validUpdate ( ) { const submitButton = await this . getSubmitButton ( ) return submitButton . click ( ) } private getSubmitButton ( ) { return element ( by . css ( 's' ) ) } }	O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element } from 's' import { FileDetector } from 's' import { join } from 's' export class VideoUploadPage { async navigateTo ( ) { await element ( by . css ( 's' ) ) . click ( ) return browser . wait ( browser . ExpectedConditions . visibilityOf ( element ( by . css ( 's' ) ) ) ) } async uploadVideo ( ) { browser . setFileDetector ( new FileDetector ( ) ) const fileToUpload = join ( __dirname , 's' ) const fileInputSelector = 's' const parentFileInput = 's' await browser . executeScript ( `template` ) await browser . executeScript ( `template` ) await browser . sleep ( 0 ) const elem = element ( by . css ( fileInputSelector ) ) await elem . sendKeys ( fileToUpload ) await browser . wait ( browser . ExpectedConditions . elementToBeClickable ( this . getSecondStepSubmitButton ( ) ) ) } async validSecondUploadStep ( videoName ) { const nameInput = element ( by . css ( 's' ) ) await nameInput . clear ( ) await nameInput . sendKeys ( videoName ) await this . getSecondStepSubmitButton ( ) . click ( ) return browser . wait ( browser . ExpectedConditions . urlContains ( 's' ) ) } private getSecondStepSubmitButton ( ) { return element ( by . css ( 's' ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { browser , by , element , ElementFinder , ExpectedConditions } from 's' export class VideoWatchPage { async goOnVideosList ( isMobileDevice , isSafari ) { let url if ( isMobileDevice === true || isSafari === true ) { url = 's' } else { url = 's' } await browser . get ( url ) if ( isSafari === true ) return browser . sleep ( 0 ) const elem = element . all ( by . css ( 's' ) ) . first ( ) return browser . wait ( browser . ExpectedConditions . visibilityOf ( elem ) ) } getVideosListName ( ) { return element . all ( by . css ( 's' ) ) . getText ( ) . then ( ( texts ) => texts . map ( ( t ) => t . trim ( ) ) ) } waitWatchVideoName ( videoName , isMobileDevice , isSafari ) { const index = isMobileDevice ? 0 : 0 const elem = element . all ( by . css ( 's' ) ) . get ( index ) if ( isSafari ) return browser . sleep ( 0 ) return browser . wait ( browser . ExpectedConditions . textToBePresentInElement ( elem , videoName ) ) } getWatchVideoPlayerCurrentTime ( ) { return element ( by . css ( 's' ) ) . getText ( ) . then ( ( t ) => t . split ( 's' ) [ 0 ] ) . then ( seconds => parseInt ( seconds , 0 ) ) } getVideoName ( ) { return this . getVideoNameElement ( ) . getText ( ) } async playAndPauseVideo ( isAutoplay , isMobileDevice ) { if ( isAutoplay === false ) { const playButton = element ( by . css ( 's' ) ) await browser . wait ( browser . ExpectedConditions . elementToBeClickable ( playButton ) ) await playButton . click ( ) } await browser . sleep ( 0 ) await browser . wait ( browser . ExpectedConditions . invisibilityOf ( element ( by . css ( 's' ) ) ) ) const videojsEl = element ( by . css ( 's' ) ) await browser . wait ( browser . ExpectedConditions . elementToBeClickable ( videojsEl ) ) if ( isMobileDevice ) { await browser . sleep ( 0 ) await videojsEl . click ( ) } await browser . sleep ( 0 ) return videojsEl . click ( ) } async clickOnVideo ( videoName ) { const video = element ( by . css ( 's' + videoName + 's' ) ) await browser . wait ( browser . ExpectedConditions . elementToBeClickable ( video ) ) await video . click ( ) await browser . wait ( browser . ExpectedConditions . urlContains ( 's' ) ) } async clickOnFirstVideo ( ) { const video = element . all ( by . css ( 's' ) ) . first ( ) const videoName = element . all ( by . css ( 's' ) ) . first ( ) await browser . wait ( browser . ExpectedConditions . elementToBeClickable ( video ) ) const textToReturn = videoName . getText ( ) await video . click ( ) await browser . wait ( browser . ExpectedConditions . urlContains ( 's' ) ) return textToReturn } async goOnAssociatedEmbed ( ) { let url = await browser . getCurrentUrl ( ) url = url . replace ( 's' , 's' ) url = url . replace ( 's' , 's' ) return browser . get ( url ) } async 0 ( ) { return browser . get ( 's' ) } async clickOnUpdate ( ) { const dropdown = element ( by . css ( 's' ) ) await dropdown . click ( ) const items : ElementFinder [ ] = await element . all ( by . css ( 's' ) ) for ( const item of items ) { const href = await item . getAttribute ( 's' ) if ( href && href . includes ( 's' ) ) { await item . click ( ) return } } } async clickOnSave ( ) { return element ( by . css ( 's' ) ) . click ( ) } async createPlaylist ( name ) { await element ( by . css ( 's' ) ) . click ( ) await element ( by . css ( 's' ) ) . sendKeys ( name ) return element ( by . css ( 's' ) ) . click ( ) } async saveToPlaylist ( name ) { return element . all ( by . css ( 's' ) ) . filter ( p => p . getText ( ) . then ( t => t === name ) ) . click ( ) } waitUntilVideoName ( name , maxTime ) { const elem = this . getVideoNameElement ( ) return browser . wait ( ExpectedConditions . textToBePresentInElement ( elem , name ) , maxTime ) } private getVideoNameElement ( ) { return element . all ( by . css ( 's' ) ) . filter ( e => e . getText ( ) . then ( t => ! ! t ) ) . first ( ) } }	O O O O O O O O O O O O O O O O O O O O O $boolean$ O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $string$ O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoWatchPage } from 's' import { VideoUploadPage } from 's' import { LoginPage } from 's' import { browser } from 's' import { VideoUpdatePage } from 's' import { MyAccountPage } from 's' async function skipIfUploadNotSupported ( ) { if ( await isMobileDevice ( ) || await isSafari ( ) ) { console . log ( 's' ) return true } return false } async function isMobileDevice ( ) { const caps = await browser . getCapabilities ( ) return caps . get ( 's' ) === 's' || caps . get ( 's' ) === true } async function isSafari ( ) { const caps = await browser . getCapabilities ( ) return caps . get ( 's' ) && caps . get ( 's' ) . toLowerCase ( ) === 's' } describe ( 's' , ( ) => { let videoWatchPage let videoUploadPage let videoUpdatePage let myAccountPage let loginPage let videoName = new Date ( ) . getTime ( ) + 's' const 0 = new Date ( ) . getTime ( ) + 's' const playlistName = new Date ( ) . getTime ( ) + 's' let videoWatchUrl beforeEach ( async ( ) => { videoWatchPage = new VideoWatchPage ( ) videoUploadPage = new VideoUploadPage ( ) videoUpdatePage = new VideoUpdatePage ( ) myAccountPage = new MyAccountPage ( ) loginPage = new LoginPage ( ) if ( await isMobileDevice ( ) ) { console . log ( 's' ) } if ( await isSafari ( ) ) { console . log ( 's' ) } } ) it ( 's' , async ( ) => { if ( await isMobileDevice ( ) || await isSafari ( ) ) { console . log ( 's' ) return } return loginPage . loginAsRootUser ( ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await videoUploadPage . navigateTo ( ) await videoUploadPage . uploadVideo ( ) return videoUploadPage . validSecondUploadStep ( videoName ) } ) it ( 's' , async ( ) => { await videoWatchPage . goOnVideosList ( await isMobileDevice ( ) , await isSafari ( ) ) if ( await skipIfUploadNotSupported ( ) ) return const videoNames = videoWatchPage . getVideosListName ( ) expect ( videoNames ) . toContain ( videoName ) } ) it ( 's' , async ( ) => { let videoNameToExcept = videoName if ( await isMobileDevice ( ) || await isSafari ( ) ) videoNameToExcept = await videoWatchPage . clickOnFirstVideo ( ) else await videoWatchPage . clickOnVideo ( videoName ) return videoWatchPage . waitWatchVideoName ( videoNameToExcept , await isMobileDevice ( ) , await isSafari ( ) ) } ) it ( 's' , async ( ) => { videoWatchUrl = await browser . getCurrentUrl ( ) await videoWatchPage . playAndPauseVideo ( true , await isMobileDevice ( ) ) expect ( videoWatchPage . getWatchVideoPlayerCurrentTime ( ) ) . toBeGreaterThanOrEqual ( 0 ) } ) it ( 's' , async ( ) => { await browser . waitForAngularEnabled ( false ) await videoWatchPage . goOnAssociatedEmbed ( ) await videoWatchPage . playAndPauseVideo ( false , await isMobileDevice ( ) ) expect ( videoWatchPage . getWatchVideoPlayerCurrentTime ( ) ) . toBeGreaterThanOrEqual ( 0 ) await browser . waitForAngularEnabled ( true ) } ) it ( 's' , async ( ) => { await browser . waitForAngularEnabled ( false ) await videoWatchPage . 0 ( ) await videoWatchPage . playAndPauseVideo ( false , await isMobileDevice ( ) ) expect ( videoWatchPage . getWatchVideoPlayerCurrentTime ( ) ) . toBeGreaterThanOrEqual ( 0 ) await browser . waitForAngularEnabled ( true ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await browser . get ( videoWatchUrl ) await videoWatchPage . clickOnUpdate ( ) videoName += 's' await videoUpdatePage . updateName ( videoName ) await videoUpdatePage . validUpdate ( ) const name = await videoWatchPage . getVideoName ( ) expect ( name ) . toEqual ( videoName ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await videoWatchPage . clickOnSave ( ) await videoWatchPage . createPlaylist ( playlistName ) await videoWatchPage . saveToPlaylist ( playlistName ) await videoUploadPage . navigateTo ( ) await videoUploadPage . uploadVideo ( ) await videoUploadPage . validSecondUploadStep ( 0 ) await videoWatchPage . clickOnSave ( ) await videoWatchPage . saveToPlaylist ( playlistName ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await myAccountPage . navigateToMyPlaylists ( ) const videosNumberText = await myAccountPage . getPlaylistVideosText ( playlistName ) expect ( videosNumberText ) . toEqual ( 's' ) await myAccountPage . clickOnPlaylist ( playlistName ) const count = await myAccountPage . countTotalPlaylistElements ( ) expect ( count ) . toEqual ( 0 ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await myAccountPage . playPlaylist ( ) await videoWatchPage . waitUntilVideoName ( 0 , 0 * 0 ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await myAccountPage . navigateToMyVideos ( ) await myAccountPage . removeVideo ( 0 ) await myAccountPage . validRemove ( ) const count = await myAccountPage . countVideos ( [ videoName , 0 ] ) expect ( count ) . toEqual ( 0 ) } ) it ( 's' , async ( ) => { if ( await skipIfUploadNotSupported ( ) ) return await myAccountPage . removeVideo ( videoName ) await myAccountPage . validRemove ( ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoWatchPage$ O $VideoUploadPage$ O $VideoUpdatePage$ O $MyAccountPage$ O $LoginPage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { FollowService } from 's' import { ComponentPagination , hasMoreItems } from 's' import { Notifier } from 's' import { RestService } from 's' import { SortMeta } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AboutFollowsComponent implements OnInit { followers : string [ ] = [ ] followings : string [ ] = [ ] followersPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } followingsPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } sort : SortMeta = { field : 's' , order : - 0 } onDataSubject = new Subject < any [ ] > ( ) constructor ( private restService , private notifier , private followService ) { } ngOnInit ( ) { this . loadMoreFollowers ( ) this . loadMoreFollowings ( ) } onNearOfBottom ( ) { this . onNearOfFollowersBottom ( ) this . onNearOfFollowingsBottom ( ) } onNearOfFollowersBottom ( ) { if ( ! hasMoreItems ( this . followersPagination ) ) return this . followersPagination . currentPage += 0 this . loadMoreFollowers ( ) } onNearOfFollowingsBottom ( ) { if ( ! hasMoreItems ( this . followingsPagination ) ) return this . followingsPagination . currentPage += 0 this . loadMoreFollowings ( ) } buildLink ( host ) { return window . location . protocol + 's' + host } private loadMoreFollowers ( ) { const pagination = this . restService . componentPaginationToRestPagination ( this . followersPagination ) this . followService . getFollowers ( pagination , this . sort ) . subscribe ( resultList => { const newFollowers = resultList . data . map ( r => r . follower . host ) this . followers = this . followers . concat ( newFollowers ) this . followersPagination . totalItems = resultList . total this . onDataSubject . next ( newFollowers ) } , err => this . notifier . error ( err . message ) ) } private loadMoreFollowings ( ) { const pagination = this . restService . componentPaginationToRestPagination ( this . followingsPagination ) this . followService . getFollowing ( pagination , this . sort ) . subscribe ( resultList => { const newFollowings = resultList . data . map ( r => r . following . host ) this . followings = this . followings . concat ( newFollowings ) this . followingsPagination . totalItems = resultList . total this . onDataSubject . next ( newFollowings ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestService$ O O $Notifier$ O O $FollowService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { Notifier , ServerService } from 's' import { 0 } from 's' import { ContactAdminModalComponent } from 's' import { InstanceService } from 's' import { MarkdownService } from 's' import { forkJoin } from 's' import { first } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AboutInstanceComponent implements OnInit { @ ViewChild ( 's' , { static : true } ) contactAdminModal : ContactAdminModalComponent shortDescription = 's' html = { description : 's' , terms : 's' , codeOfConduct : 's' , moderationInformation : 's' , administrator : 's' , hardwareInformation : 's' } creationReason = 's' maintenanceLifetime = 's' businessModel = 's' languages : string [ ] = [ ] categories : string [ ] = [ ] constructor ( private notifier , private serverService , private instanceService , private markdownService , private 0 ) { } get instanceName ( ) { return this . serverService . getConfig ( ) . instance . name } get isContactFormEnabled ( ) { return this . serverService . getConfig ( ) . email . enabled && this . serverService . getConfig ( ) . contactForm . enabled } get isNSFW ( ) { return this . serverService . getConfig ( ) . instance . isNSFW } ngOnInit ( ) { forkJoin ( [ this . instanceService . getAbout ( ) , this . serverService . localeObservable . pipe ( first ( ) ) , this . serverService . videoLanguagesLoaded . pipe ( first ( ) ) , this . serverService . videoCategoriesLoaded . pipe ( first ( ) ) ] ) . subscribe ( async ( [ about , translations ] ) => { this . shortDescription = about . instance . shortDescription this . creationReason = about . instance . creationReason this . maintenanceLifetime = about . instance . maintenanceLifetime this . businessModel = about . instance . businessModel this . html = await this . instanceService . buildHtml ( about ) this . languages = this . instanceService . buildTranslatedLanguages ( about , translations ) this . categories = this . instanceService . buildTranslatedCategories ( about , translations ) } , ( ) => this . notifier . error ( this . 0 ( 's' ) ) ) } openContactModal ( ) { return this . contactAdminModal . show ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $ServerService$ O O $InstanceService$ O O $MarkdownService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { Notifier , ServerService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { FormReactive , InstanceValidatorsService } from 's' import { InstanceService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ContactAdminModalComponent extends FormReactive implements OnInit { @ ViewChild ( 's' , { static : true } ) modal : NgbModal error : string private openedModal : NgbModalRef constructor ( protected formValidatorService , private modalService , private instanceValidatorsService , private instanceService , private serverService , private notifier , private 0 ) { super ( ) } get instanceName ( ) { return this . serverService . getConfig ( ) . instance . name } ngOnInit ( ) { this . buildForm ( { fromName : this . instanceValidatorsService . FROM_NAME , fromEmail : this . instanceValidatorsService . FROM_EMAIL , subject : this . instanceValidatorsService . SUBJECT , body : this . instanceValidatorsService . BODY } ) } show ( ) { this . openedModal = this . modalService . open ( this . modal , { keyboard : false } ) } hide ( ) { this . form . reset ( ) this . error = undefined this . openedModal . close ( ) this . openedModal = null } sendForm ( ) { const fromName = this . form . value [ 's' ] const fromEmail = this . form . value [ 's' ] const subject = this . form . value [ 's' ] const body = this . form . value [ 's' ] this . instanceService . contactAdministrator ( fromEmail , fromName , subject , body ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . hide ( ) } , err => { this . error = err . status === 0 ? this . 0 ( 's' ) : err . message } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $InstanceValidatorsService$ O O $InstanceService$ O O $ServerService$ O O $Notifier$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AboutPeertubeContributorsComponent implements OnInit { creditsHtml : string private markdown = require ( 's' ) constructor ( private markdownService ) { } async ngOnInit ( ) { this . creditsHtml = await this . markdownService . completeMarkdownToHTML ( this . markdown ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MarkdownService$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AboutPeertubeComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { selector : 's' , templateUrl : 's' } ) export class AboutComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { AboutComponent } from 's' import { AboutInstanceComponent } from 's' import { AboutPeertubeComponent } from 's' import { AboutFollowsComponent } from 's' const aboutRoutes = [ { path : 's' , component : AboutComponent , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : AboutInstanceComponent , data : { meta : { title : 's' } } } , { path : 's' , component : AboutPeertubeComponent , data : { meta : { title : 's' } } } , { path : 's' , component : AboutFollowsComponent , data : { meta : { title : 's' } } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( aboutRoutes ) ] , exports : [ RouterModule ] } ) export class AboutRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum AuthStatus { LoggedIn , LoggedOut }	O O O O O O O O
export enum UserRight { ALL , MANAGE_USERS , MANAGE_SERVER_FOLLOW , MANAGE_LOGS , MANAGE_DEBUG , MANAGE_SERVER_REDUNDANCY , MANAGE_VIDEO_ABUSES , MANAGE_JOBS , MANAGE_CONFIGURATION , MANAGE_ACCOUNTS_BLOCKLIST , MANAGE_SERVERS_BLOCKLIST , MANAGE_VIDEO_BLACKLIST , REMOVE_ANY_VIDEO , REMOVE_ANY_VIDEO_CHANNEL , REMOVE_ANY_VIDEO_PLAYLIST , REMOVE_ANY_VIDEO_COMMENT , UPDATE_ANY_VIDEO , UPDATE_ANY_VIDEO_PLAYLIST , SEE_ALL_VIDEOS , CHANGE_VIDEO_OWNERSHIP , MANAGE_PLUGINS }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface Avatar { path : string createdAt : Date | string updatedAt : Date | string }	O O O O O O O O O O O O O O O O O O
import { Avatar } from 's' export interface Actor { id : number url : string name : string host : string followingCount : number followersCount : number createdAt : Date | string updatedAt : Date | string avatar ? : Avatar }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Actor } from 's' import { Avatar } from 's' export interface Account extends Actor { displayName : string description : string userId ? : number } export interface AccountSummary { id : number name : string displayName : string url : string host : string avatar ? : Avatar }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Actor } from 's' export type FollowState = 's' | 's' export interface ActorFollow { id : number follower : Actor & { hostRedundancyAllowed : boolean } following : Actor & { hostRedundancyAllowed : boolean } score : number state : FollowState createdAt : Date updatedAt : Date }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Actor } from 's' import { Account } from 's' import { Avatar } from 's' export interface VideoChannel extends Actor { displayName : string description : string support : string isLocal : boolean ownerAccount ? : Account } export interface VideoChannelSummary { id : number name : string displayName : string url : string host : string avatar ? : Avatar }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserRight } from 's' export enum UserRole { ADMINISTRATOR = 0 , MODERATOR = 0 , USER = 0 } export const USER_ROLE_LABELS : { [ id ] : string } = { [ UserRole . USER ] : 's' , [ UserRole . MODERATOR ] : 's' , [ UserRole . ADMINISTRATOR ] : 's' } const userRoleRights : { [ id ] : UserRight [ ] } = { [ UserRole . ADMINISTRATOR ] : [ UserRight . ALL ] , [ UserRole . MODERATOR ] : [ UserRight . MANAGE_VIDEO_BLACKLIST , UserRight . MANAGE_VIDEO_ABUSES , UserRight . REMOVE_ANY_VIDEO , UserRight . REMOVE_ANY_VIDEO_CHANNEL , UserRight . REMOVE_ANY_VIDEO_PLAYLIST , UserRight . REMOVE_ANY_VIDEO_COMMENT , UserRight . UPDATE_ANY_VIDEO , UserRight . SEE_ALL_VIDEOS , UserRight . MANAGE_ACCOUNTS_BLOCKLIST , UserRight . MANAGE_SERVERS_BLOCKLIST , UserRight . MANAGE_USERS ] , [ UserRole . USER ] : [ ] } export function hasUserRight ( userRole , userRight ) { const userRights = userRoleRights [ userRole ] return userRights . indexOf ( UserRight . ALL ) !== - 0 || userRights . indexOf ( userRight ) !== - 0 }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRole$ O $UserRight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type NSFWPolicyType = 's' | 's' | 's'	O O O O O O O O O
export enum UserNotificationSettingValue { NONE = 0 , WEB = 0 << 0 , EMAIL = 0 << 0 } export interface UserNotificationSetting { newVideoFromSubscription : UserNotificationSettingValue newCommentOnMyVideo : UserNotificationSettingValue videoAbuseAsModerator : UserNotificationSettingValue videoAutoBlacklistAsModerator : UserNotificationSettingValue blacklistOnMyVideo : UserNotificationSettingValue myVideoPublished : UserNotificationSettingValue myVideoImportFinished : UserNotificationSettingValue newUserRegistration : UserNotificationSettingValue newFollow : UserNotificationSettingValue commentMention : UserNotificationSettingValue newInstanceFollower : UserNotificationSettingValue autoInstanceFollowing : UserNotificationSettingValue }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum UserAdminFlag { NONE = 0 , BY_PASS_VIDEO_AUTO_BLACKLIST = 0 << 0 }	O O O O O O O O O O O O O O
import { Account } from 's' import { VideoChannel } from 's' import { UserRole } from 's' import { NSFWPolicyType } from 's' import { UserNotificationSetting } from 's' import { UserAdminFlag } from 's' export interface User { id : number username : string email : string pendingEmail : string | null emailVerified : boolean nsfwPolicy : NSFWPolicyType adminFlags ? : UserAdminFlag autoPlayVideo : boolean autoPlayNextVideo : boolean webTorrentEnabled : boolean videosHistoryEnabled : boolean videoLanguages : string [ ] role : UserRole roleLabel : string videoQuota : number videoQuotaDaily : number videoQuotaUsed ? : number videoQuotaUsedDaily ? : number theme : string account : Account notificationSettings ? : UserNotificationSetting videoChannels ? : VideoChannel [ ] blocked : boolean blockedReason ? : string noInstanceConfigWarningModal : boolean noWelcomeModal : boolean createdAt : Date }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ActivityIdentifierObject { identifier : string name : string } export interface ActivityTagObject { type : 's' | 's' href ? : string name : string } export interface ActivityIconObject { type : 's' url : string mediaType : 's' width : number height : number } export type ActivityVideoUrlObject = { type : 's' mimeType ? : 's' | 's' | 's' mediaType : 's' | 's' | 's' href : string height : number size : number fps : number } export type ActivityPlaylistSegmentHashesObject = { type : 's' name : 's' mimeType ? : 's' mediaType : 's' href : string } export type ActivityPlaylistInfohashesObject = { type : 's' name : string } export type ActivityPlaylistUrlObject = { type : 's' mimeType ? : 's' mediaType : 's' href : string tag ? : ( ActivityPlaylistSegmentHashesObject | ActivityPlaylistInfohashesObject ) [ ] } export type ActivityBitTorrentUrlObject = { type : 's' mimeType ? : 's' | 's' mediaType : 's' | 's' href : string height : number } export type ActivityHtmlUrlObject = { type : 's' mimeType ? : 's' mediaType : 's' href : string } export type ActivityUrlObject = ActivityVideoUrlObject | ActivityPlaylistUrlObject | ActivityBitTorrentUrlObject | ActivityHtmlUrlObject export interface ActivityPubAttributedTo { type : 's' | 's' id : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityPubAttributedTo } from 's' export type ActivityPubActorType = 's' | 's' | 's' export interface ActivityPubActor { 's' : any [ ] type : ActivityPubActorType id : string following : string followers : string playlists ? : string inbox : string outbox : string preferredUsername : string url : string name : string endpoints : { sharedInbox : string } summary : string attributedTo : ActivityPubAttributedTo [ ] support ? : string publicKey : { id : string owner : string publicKeyPem : string } icon : { type : 's' mediaType : 's' url : string } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ActivityPubSignature { type : 's' created : Date , creator : string signatureValue : string }	O O O O O O O O O O O O O O O O O O
import { ActivityVideoUrlObject , ActivityPlaylistUrlObject } from 's' export interface CacheFileObject { id : string type : 's' , object : string expires : string url : ActivityVideoUrlObject | ActivityPlaylistUrlObject }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoAbuseObject { type : 's' , content : string object : string | string [ ] }	O O O O O O O O O O O O O O O O O O O
export type UserVideoRateType = 's' | 's' | 's'	O O O O O O O O O
import { UserVideoRateType } from 's' export interface UserVideoRateUpdate { rating : UserVideoRateType }	O O O O O O O O O O O O O O
import { UserVideoRateType } from 's' export interface UserVideoRate { videoId : number rating : UserVideoRateType }	O O O O O O O O O O O O O O O O O
export enum VideoPrivacy { PUBLIC = 0 , UNLISTED = 0 , PRIVATE = 0 }	O O O O O O O O O O O O O O O O
import { VideoPrivacy } from 's' export interface VideoScheduleUpdate { updateAt : Date | string privacy ? : VideoPrivacy . PUBLIC | VideoPrivacy . UNLISTED }	O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoConstant < T > { id : T label : string }	O O O O O O O O O O O O O O
export enum VideoStreamingPlaylistType { HLS = 0 }	O O O O O O O O
import { VideoStreamingPlaylistType } from 's' export class VideoStreamingPlaylist { id : number type : VideoStreamingPlaylistType playlistUrl : string 0 : string redundancies : { baseUrl : string } [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccountSummary , VideoChannelSummary , VideoResolution , VideoState } from 's' import { Account } from 's' import { VideoChannel } from 's' import { VideoPrivacy } from 's' import { VideoScheduleUpdate } from 's' import { VideoConstant } from 's' import { VideoStreamingPlaylist } from 's' export interface VideoFile { magnetUri : string resolution : VideoConstant < VideoResolution > size : number torrentUrl : string torrentDownloadUrl : string fileUrl : string fileDownloadUrl : string fps : number } export interface Video { id : number uuid : string createdAt : Date | string updatedAt : Date | string publishedAt : Date | string originallyPublishedAt : Date | string category : VideoConstant < number > licence : VideoConstant < number > language : VideoConstant < string > privacy : VideoConstant < VideoPrivacy > description : string duration : number isLocal : boolean name : string thumbnailPath : string previewPath : string embedPath : string views : number likes : number dislikes : number nsfw : boolean waitTranscoding ? : boolean state ? : VideoConstant < VideoState > scheduledUpdate ? : VideoScheduleUpdate blacklisted ? : boolean blacklistedReason ? : string account : AccountSummary channel : VideoChannelSummary userHistory ? : { currentTime : number } } export interface VideoDetails extends Video { descriptionPath : string support : string channel : VideoChannel account : Account tags : string [ ] files : VideoFile [ ] commentsEnabled : boolean downloadEnabled : boolean waitTranscoding : boolean state : VideoConstant < VideoState > trackerUrls : string [ ] streamingPlaylists : VideoStreamingPlaylist [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserVideoRateType } from 's' import { Video } from 's' export interface AccountVideoRate { video : Video rating : UserVideoRateType }	O O O O O O O O O O O O O O O O O O O O O O O
export enum VideoAbuseState { PENDING = 0 , REJECTED = 0 , ACCEPTED = 0 }	O O O O O O O O O O O O O O O O
export interface VideoAbuseCreate { reason : string }	O O O O O O O O
import { Account } from 's' import { VideoConstant } from 's' import { VideoAbuseState } from 's' export interface VideoAbuse { id : number reason : string reporterAccount : Account state : VideoConstant < VideoAbuseState > moderationComment ? : string video : { id : number name : string uuid : string } createdAt : Date }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoAbuseState } from 's' export interface VideoAbuseUpdate { moderationComment ? : string state ? : VideoAbuseState }	O O O O O O O O O O O O O O O O O O O
import { Video } from 's' export enum VideoBlacklistType { MANUAL = 0 , AUTO_BEFORE_PUBLISHED = 0 } export interface VideoBlacklist { id : number createdAt : Date updatedAt : Date unfederated : boolean reason ? : string type : VideoBlacklistType video : Video }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoBlacklistCreate { reason ? : string unfederate ? : boolean }	O O O O O O O O O O O O O
export interface VideoBlacklistUpdate { reason ? : string }	O O O O O O O O O
export interface VideoChannelCreate { name : string displayName : string description ? : string support ? : string }	O O O O O O O O O O O O O O O O O O O
export interface VideoChannelUpdate { displayName ? : string description ? : string support ? : string bulkVideosSupportUpdate ? : boolean }	O O O O O O O O O O O O O O O O O O O O O
export enum VideoPlaylistPrivacy { PUBLIC = 0 , UNLISTED = 0 , PRIVATE = 0 }	O O O O O O O O O O O O O O O O
import { VideoPlaylistPrivacy } from 's' export interface VideoPlaylistCreate { displayName : string privacy : VideoPlaylistPrivacy description ? : string videoChannelId ? : number thumbnailfile ? : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoPlaylistElementCreate { videoId : number startTimestamp ? : number stopTimestamp ? : number }	O O O O O O O O O O O O O O O O
export interface VideoPlaylistElementUpdate { startTimestamp ? : number stopTimestamp ? : number }	O O O O O O O O O O O O O
export enum VideoPlaylistType { REGULAR = 0 , WATCH_LATER = 0 }	O O O O O O O O O O O O
import { VideoPlaylistPrivacy } from 's' export interface VideoPlaylistUpdate { displayName ? : string privacy ? : VideoPlaylistPrivacy description ? : string videoChannelId ? : number thumbnailfile ? : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccountSummary } from 's' import { VideoChannelSummary , VideoConstant } from 's' import { VideoPlaylistPrivacy } from 's' import { VideoPlaylistType } from 's' export interface VideoPlaylist { id : number uuid : string isLocal : boolean displayName : string description : string privacy : VideoConstant < VideoPlaylistPrivacy > thumbnailPath : string videosLength : number type : VideoConstant < VideoPlaylistType > createdAt : Date | string updatedAt : Date | string ownerAccount : AccountSummary videoChannel ? : VideoChannelSummary }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Video } from 's' export enum VideoPlaylistElementType { REGULAR = 0 , DELETED = 0 , PRIVATE = 0 , UNAVAILABLE = 0 } export interface VideoPlaylistElement { id : number position : number startTimestamp : number stopTimestamp : number type : VideoPlaylistElementType video ? : Video }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Account } from 's' export interface VideoChangeOwnership { id : number status : VideoChangeOwnershipStatus initiatorAccount : Account nextOwnerAccount : Account video : { id : number name : string uuid : string url : string } createdAt : Date } export enum VideoChangeOwnershipStatus { WAITING = 's' , ACCEPTED = 's' , REFUSED = 's' }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoChangeOwnershipCreate { username : string }	O O O O O O O O
import { VideoPrivacy } from 's' import { VideoScheduleUpdate } from 's' export interface VideoCreate { category ? : number licence ? : number language ? : string description ? : string support ? : string channelId : number nsfw ? : boolean waitTranscoding ? : boolean name : string tags ? : string [ ] commentsEnabled ? : boolean downloadEnabled ? : boolean privacy : VideoPrivacy scheduleUpdate ? : VideoScheduleUpdate originallyPublishedAt : Date | string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type VideoRateType = 's' | 's'	O O O O O O O
export type VideoTranscodingFPS = { MIN : number , AVERAGE : number , MAX : number , KEEP_ORIGIN_FPS_RESOLUTION_MIN : number }	O O O O O O O O O O O O O O O O O O O O O
import { VideoTranscodingFPS } from 's' export enum VideoResolution { 0 = 0 , 0 = 0 , 0 = 0 , 0 = 0 , 0 = 0 , 0 = 0 } function getBaseBitrate ( resolution ) { switch ( resolution ) { case VideoResolution . 0 : return 0 * 0 case VideoResolution . 0 : return 0 * 0 case VideoResolution . 0 : return 0 * 0 case VideoResolution . 0 : return 0 * 0 case VideoResolution . 0 : return 0 * 0 case VideoResolution . 0 : default : return 0 * 0 } } export function getTargetBitrate ( resolution , fps , fpsTranscodingConstants ) { const baseBitrate = getBaseBitrate ( resolution ) const maxBitrate = baseBitrate * 0 const maxBitrateDifference = maxBitrate - baseBitrate const maxFpsDifference = fpsTranscodingConstants . MAX - fpsTranscodingConstants . AVERAGE return baseBitrate + ( fps - fpsTranscodingConstants . AVERAGE ) * ( maxBitrateDifference / maxFpsDifference ) } export function getMaxBitrate ( resolution , fps , fpsTranscodingConstants ) { return getTargetBitrate ( resolution , fps , fpsTranscodingConstants ) * 0 }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoResolution$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoResolution$ O $number$ O $VideoTranscodingFPS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoResolution$ O $number$ O $VideoTranscodingFPS$ O O O O O O O O O O O O O O
import { VideoPrivacy } from 's' import { VideoScheduleUpdate } from 's' export interface VideoUpdate { name ? : string category ? : number licence ? : number language ? : string description ? : string support ? : string privacy ? : VideoPrivacy tags ? : string [ ] commentsEnabled ? : boolean downloadEnabled ? : boolean nsfw ? : boolean waitTranscoding ? : boolean channelId ? : number thumbnailfile ? : Blob previewfile ? : Blob scheduleUpdate ? : VideoScheduleUpdate originallyPublishedAt ? : Date | string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type VideoFilter = 's' | 's'	O O O O O O O
export enum VideoState { PUBLISHED = 0 , TO_TRANSCODE = 0 , TO_IMPORT = 0 }	O O O O O O O O O O O O O O O O
import { VideoConstant } from 's' export interface VideoCaption { language : VideoConstant < string > captionPath : string }	O O O O O O O O O O O O O O O O O O O O
export interface VideoCaptionUpdate { language : string captionfile : Blob }	O O O O O O O O O O O
import { VideoUpdate } from 's' export interface VideoImportCreate extends VideoUpdate { targetUrl ? : string magnetUri ? : string torrentfile ? : Blob channelId : number }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum VideoImportState { PENDING = 0 , SUCCESS = 0 , FAILED = 0 }	O O O O O O O O O O O O O O O O
import { Video } from 's' import { VideoConstant } from 's' import { VideoImportState } from 's' export interface VideoImport { id : number targetUrl : string magnetUri : string torrentName : string createdAt : string updatedAt : string originallyPublishedAt ? : string state : VideoConstant < VideoImportState > error ? : string video ? : Video & { tags : string [ ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityIconObject , ActivityIdentifierObject , ActivityPubAttributedTo , ActivityTagObject , ActivityUrlObject } from 's' import { VideoState } from 's' export interface VideoTorrentObject { type : 's' id : string name : string duration : string uuid : string tag : ActivityTagObject [ ] category : ActivityIdentifierObject licence : ActivityIdentifierObject language : ActivityIdentifierObject subtitleLanguage : ActivityIdentifierObject [ ] views : number sensitive : boolean commentsEnabled : boolean , downloadEnabled : boolean , waitTranscoding : boolean state : VideoState published : string originallyPublishedAt : string updated : string mediaType : 's' content : string support : string icon : ActivityIconObject url : ActivityUrlObject [ ] likes : string dislikes : string shares : string comments : string attributedTo : ActivityPubAttributedTo [ ] to ? : string [ ] cc ? : string [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ViewObject { type : 's' , actor : string object : string }	O O O O O O O O O O O O O O O
export interface DislikeObject { id : string type : 's' actor : string object : string }	O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityTagObject } from 's' export interface VideoCommentObject { type : 's' id : string content : string inReplyTo : string published : string updated : string url : string attributedTo : string tag : ActivityTagObject [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type APObject = string | { id : string }	O O O O O O O O O O O
import { ActivityIconObject } from 's' export interface PlaylistObject { id : string type : 's' name : string content : string uuid : string totalItems : number attributedTo : string [ ] icon ? : ActivityIconObject published : string updated : string orderedItems ? : string [ ] partOf ? : string next ? : string first ? : string to ? : string [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityPubActor } from 's' import { ActivityPubSignature } from 's' import { CacheFileObject , VideoTorrentObject } from 's' import { DislikeObject } from 's' import { VideoAbuseObject } from 's' import { VideoCommentObject } from 's' import { ViewObject } from 's' import { APObject } from 's' import { PlaylistObject } from 's' export type Activity = ActivityCreate | ActivityUpdate | ActivityDelete | ActivityFollow | ActivityAccept | ActivityAnnounce | ActivityUndo | ActivityLike | ActivityReject | ActivityView | ActivityDislike | ActivityFlag export type ActivityType = 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' export interface ActivityAudience { to : string [ ] cc : string [ ] } export interface BaseActivity { 's' ? : any [ ] id : string to ? : string [ ] cc ? : string [ ] actor : string | ActivityPubActor type : ActivityType signature ? : ActivityPubSignature } export interface ActivityCreate extends BaseActivity { type : 's' object : VideoTorrentObject | VideoAbuseObject | ViewObject | DislikeObject | VideoCommentObject | CacheFileObject | PlaylistObject } export interface ActivityUpdate extends BaseActivity { type : 's' object : VideoTorrentObject | ActivityPubActor | CacheFileObject | PlaylistObject } export interface ActivityDelete extends BaseActivity { type : 's' object : string | { id : string } } export interface ActivityFollow extends BaseActivity { type : 's' object : string } export interface ActivityAccept extends BaseActivity { type : 's' object : ActivityFollow } export interface ActivityReject extends BaseActivity { type : 's' object : ActivityFollow } export interface ActivityAnnounce extends BaseActivity { type : 's' object : APObject } export interface ActivityUndo extends BaseActivity { type : 's' , object : ActivityFollow | ActivityLike | ActivityDislike | ActivityCreate | ActivityAnnounce } export interface ActivityLike extends BaseActivity { type : 's' , object : APObject } export interface ActivityView extends BaseActivity { type : 's' , actor : string object : APObject } export interface ActivityDislike extends BaseActivity { id : string type : 's' actor : string object : APObject } export interface ActivityFlag extends BaseActivity { type : 's' , content : string , object : APObject | APObject [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Activity } from 's' export interface ActivityPubCollection { 's' : string [ ] type : 's' | 's' totalItems : number partOf ? : string items : Activity [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ActivityPubOrderedCollection < T > { 's' : string [ ] type : 's' | 's' totalItems : number orderedItems : T [ ] partOf ? : string next ? : string first ? : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Activity } from 's' import { ActivityPubCollection } from 's' import { ActivityPubOrderedCollection } from 's' export type RootActivity = Activity | ActivityPubCollection | ActivityPubOrderedCollection < Activity >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface WebFingerData { subject : string aliases : string [ ] links : { rel : 's' type : 's' href : string } [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Account } from 's' export interface AccountBlock { byAccount : Account blockedAccount : Account createdAt : Date | string }	O O O O O O O O O O O O O O O O O O O O O O
import { Account } from 's' export interface ServerBlock { byAccount : Account blockedServer : { host : string } createdAt : Date | string }	O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
export type VideoRedundancyStrategy = 's' | 's' | 's' export type MostViewsRedundancyStrategy = { strategy : 's' size : number minLifetime : number } export type TrendingRedundancyStrategy = { strategy : 's' size : number minLifetime : number } export type RecentlyAddedStrategy = { strategy : 's' size : number minViews : number minLifetime : number } export type VideosRedundancy = MostViewsRedundancyStrategy | TrendingRedundancyStrategy | RecentlyAddedStrategy	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { UserRole } from 's' import { UserAdminFlag } from 's' export interface UserCreate { username : string password : string email : string videoQuota : number videoQuotaDaily : number role : UserRole adminFlags ? : UserAdminFlag }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface UserLogin { access_token : string refresh_token : string token_type : string }	O O O O O O O O O O O O O O
import { FollowState } from 's' export enum UserNotificationType { NEW_VIDEO_FROM_SUBSCRIPTION = 0 , NEW_COMMENT_ON_MY_VIDEO = 0 , NEW_VIDEO_ABUSE_FOR_MODERATORS = 0 , BLACKLIST_ON_MY_VIDEO = 0 , UNBLACKLIST_ON_MY_VIDEO = 0 , MY_VIDEO_PUBLISHED = 0 , MY_VIDEO_IMPORT_SUCCESS = 0 , MY_VIDEO_IMPORT_ERROR = 0 , NEW_USER_REGISTRATION = 0 , NEW_FOLLOW = 0 , COMMENT_MENTION = 0 , VIDEO_AUTO_BLACKLIST_FOR_MODERATORS = 0 , NEW_INSTANCE_FOLLOWER = 0 , AUTO_INSTANCE_FOLLOWING = 0 } export interface VideoInfo { id : number uuid : string name : string } export interface ActorInfo { id : number displayName : string name : string host : string avatar ? : { path : string } } export interface UserNotification { id : number type : UserNotificationType read : boolean video ? : VideoInfo & { channel : ActorInfo } videoImport ? : { id : number video ? : VideoInfo torrentName ? : string magnetUri ? : string targetUrl ? : string } comment ? : { id : number threadId : number account : ActorInfo video : VideoInfo } videoAbuse ? : { id : number video : VideoInfo } videoBlacklist ? : { id : number video : VideoInfo } account ? : ActorInfo actorFollow ? : { id : number follower : ActorInfo state : FollowState following : { type : 's' | 's' | 's' name : string displayName : string host : string } } createdAt : string updatedAt : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface UserRefreshToken { access_token : string refresh_token : string }	O O O O O O O O O O O
import { UserRole } from 's' import { UserAdminFlag } from 's' export interface UserUpdate { password ? : string email ? : string emailVerified ? : boolean videoQuota ? : number videoQuotaDaily ? : number role ? : UserRole adminFlags ? : UserAdminFlag }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NSFWPolicyType } from 's' export interface UserUpdateMe { displayName ? : string description ? : string nsfwPolicy ? : NSFWPolicyType webTorrentEnabled ? : boolean autoPlayVideo ? : boolean autoPlayNextVideo ? : boolean videosHistoryEnabled ? : boolean videoLanguages ? : string [ ] email ? : string currentPassword ? : string password ? : string theme ? : string noInstanceConfigWarningModal ? : boolean noWelcomeModal ? : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface UserVideoQuota { videoQuotaUsed : number videoQuotaUsedDaily : number }	O O O O O O O O O O O
export interface UserWatchingVideo { currentTime : number }	O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum FeedFormat { RSS = 's' , ATOM = 's' , JSON = 's' }	O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export const LOCALE_FILES = [ 's' , 's' ] export const 0 = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } const 0 = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } export const POSSIBLE_LOCALES = Object . keys ( 0 ) . concat ( Object . keys ( 0 ) ) export function getDefaultLocale ( ) { return 's' } export function isDefaultLocale ( locale ) { return getCompleteLocale ( locale ) === getCompleteLocale ( getDefaultLocale ( ) ) } export function peertubeTranslate ( str , translations ? : { [ id ] : string } ) { return translations && translations [ str ] ? translations [ str ] : str } const possiblePaths = POSSIBLE_LOCALES . map ( l => 's' + l ) export function 0 ( path ) { return possiblePaths . indexOf ( path ) !== - 0 } export function 0 ( locale ) { return POSSIBLE_LOCALES . indexOf ( locale ) !== - 0 } export function getCompleteLocale ( locale ) { if ( ! locale ) return locale if ( 0 [ locale ] ) return 0 [ locale ] return locale } export function getShortLocale ( locale ) { if ( locale . indexOf ( 's' ) === - 0 ) return locale return locale . split ( 's' ) [ 0 ] } export function buildFileLocale ( locale ) { const completeLocale = getCompleteLocale ( locale ) return completeLocale . replace ( "s" , 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Video , VideoChannelSummary , VideoConstant } from 's' export interface VideosOverview { channels : { channel : VideoChannelSummary videos : Video [ ] } [ ] categories : { category : VideoConstant < number > videos : Video [ ] } [ ] tags : { tag : string videos : Video [ ] } [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export type NSFWQuery = 's' | 's' | 's'	O O O O O O O O O
import { NSFWQuery } from 's' import { VideoFilter } from 's' export interface VideosSearchQuery { search ? : string start ? : number count ? : number sort ? : string startDate ? : string endDate ? : string originallyPublishedStartDate ? : string originallyPublishedEndDate ? : string nsfw ? : NSFWQuery categoryOneOf ? : number [ ] licenceOneOf ? : number [ ] languageOneOf ? : string [ ] tagsOneOf ? : string [ ] tagsAllOf ? : string [ ] durationMin ? : number durationMax ? : number filter ? : VideoFilter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoChannelsSearchQuery { search : string start ? : number count ? : number sort ? : string }	O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
export type JobState = 's' | 's' | 's' | 's' | 's' export type JobType = 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' export interface Job { id : number state : JobState type : JobType data : any , error : any , createdAt : Date finishedOn : Date processedOn : Date }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface OAuthClientLocal { client_id : string client_secret : string }	O O O O O O O O O O O
export interface ResultList < T > { total : number data : T [ ] }	O O O O O O O O O O O O O O O O
export type PluginClientScope = 's' | 's' | 's'	O O O O O O O O O
import { PluginClientScope } from 's' export type PluginTranslationPaths = { [ locale ] : string } export type ClientScript = { script : string , scopes : PluginClientScope [ ] } export type PluginPackageJson = { name : string version : string description : string engine : { peertube : string } , homepage : string , author : string , bugs : string , library : string , staticDirs : { [ name ] : string } css : string [ ] clientScripts : ClientScript [ ] translations : PluginTranslationPaths }	O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O
import { NSFWPolicyType } from 's' import { ClientScript } from 's' export interface ServerConfigPlugin { name : string version : string description : string clientScripts : { [ name ] : ClientScript } } export interface ServerConfigTheme extends ServerConfigPlugin { css : string [ ] } export interface ServerConfig { serverVersion : string serverCommit ? : string instance : { name : string shortDescription : string defaultClientRoute : string isNSFW : boolean defaultNSFWPolicy : NSFWPolicyType customizations : { javascript : string css : string } } plugin : { registered : ServerConfigPlugin [ ] } theme : { registered : ServerConfigTheme [ ] default : string } email : { enabled : boolean } contactForm : { enabled : boolean } signup : { allowed : boolean , allowedForCurrentIP : boolean requiresEmailVerification : boolean } transcoding : { hls : { enabled : boolean } enabledResolutions : number [ ] } import : { videos : { http : { enabled : boolean } torrent : { enabled : boolean } } } autoBlacklist : { videos : { ofUsers : { enabled : boolean } } } avatar : { file : { size : { max : number } extensions : string [ ] } } video : { image : { size : { max : number } extensions : string [ ] } , file : { extensions : string [ ] } } videoCaption : { file : { size : { max : number } , extensions : string [ ] } } user : { videoQuota : number videoQuotaDaily : number } trending : { videos : { intervalDays : number } } tracker : { enabled : boolean } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { hasUserRight , User as UserServerModel , UserNotificationSetting , UserRight , UserRole , VideoChannel } from 's' import { NSFWPolicyType } from 's' import { Account } from 's' import { Avatar } from 's' import { UserAdminFlag } from 's' export class User implements UserServerModel { id : number username : string email : string pendingEmail : string | null emailVerified : boolean nsfwPolicy : NSFWPolicyType adminFlags ? : UserAdminFlag autoPlayVideo : boolean autoPlayNextVideo : boolean webTorrentEnabled : boolean videosHistoryEnabled : boolean videoLanguages : string [ ] role : UserRole roleLabel : string videoQuota : number videoQuotaDaily : number videoQuotaUsed ? : number videoQuotaUsedDaily ? : number theme : string account : Account notificationSettings ? : UserNotificationSetting videoChannels ? : VideoChannel [ ] blocked : boolean blockedReason ? : string noInstanceConfigWarningModal : boolean noWelcomeModal : boolean createdAt : Date constructor ( hash < UserServerModel > ) { this . id = hash . id this . username = hash . username this . email = hash . email this . role = hash . role this . videoChannels = hash . videoChannels this . videoQuota = hash . videoQuota this . videoQuotaDaily = hash . videoQuotaDaily this . videoQuotaUsed = hash . videoQuotaUsed this . videoQuotaUsedDaily = hash . videoQuotaUsedDaily this . nsfwPolicy = hash . nsfwPolicy this . webTorrentEnabled = hash . webTorrentEnabled this . videosHistoryEnabled = hash . videosHistoryEnabled this . autoPlayVideo = hash . autoPlayVideo this . theme = hash . theme this . adminFlags = hash . adminFlags this . blocked = hash . blocked this . blockedReason = hash . blockedReason this . noInstanceConfigWarningModal = hash . noInstanceConfigWarningModal this . noWelcomeModal = hash . noWelcomeModal this . notificationSettings = hash . notificationSettings this . createdAt = hash . createdAt if ( hash . account !== undefined ) { this . account = new Account ( hash . account ) } } get accountAvatarUrl ( ) { if ( ! this . account ) return 's' return this . account . avatarUrl } hasRight ( right ) { return hasUserRight ( this . role , right ) } patch ( obj ) { for ( const key of Object . keys ( obj ) ) { this [ key ] = obj [ key ] } if ( obj . account !== undefined ) { this . account = new Account ( obj . account ) } } updateAccountAvatar ( newAccountAvatar ) { this . account . updateAvatar ( newAccountAvatar ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRight$ O O O O O O O O O O O O O O $UserServerModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Avatar$ O O O O O O O O O O O O
import { peertubeLocalStorage } from 's' import { UserRight } from 's' import { User as ServerUserModel } from 's' import { hasUserRight , UserRole } from 's' import { User } from 's' import { NSFWPolicyType } from 's' export type TokenOptions = { accessToken : string refreshToken : string tokenType : string } class Tokens { private static KEYS = { ACCESS_TOKEN : 's' , REFRESH_TOKEN : 's' , TOKEN_TYPE : 's' } accessToken : string refreshToken : string tokenType : string static load ( ) { const accessTokenLocalStorage = peertubeLocalStorage . getItem ( this . KEYS . ACCESS_TOKEN ) const refreshTokenLocalStorage = peertubeLocalStorage . getItem ( this . KEYS . REFRESH_TOKEN ) const tokenTypeLocalStorage = peertubeLocalStorage . getItem ( this . KEYS . TOKEN_TYPE ) if ( accessTokenLocalStorage && refreshTokenLocalStorage && tokenTypeLocalStorage ) { return new Tokens ( { accessToken : accessTokenLocalStorage , refreshToken : refreshTokenLocalStorage , tokenType : tokenTypeLocalStorage } ) } return null } static flush ( ) { peertubeLocalStorage . removeItem ( this . KEYS . ACCESS_TOKEN ) peertubeLocalStorage . removeItem ( this . KEYS . REFRESH_TOKEN ) peertubeLocalStorage . removeItem ( this . KEYS . TOKEN_TYPE ) } constructor ( hash ? ) { if ( hash ) { this . accessToken = hash . accessToken this . refreshToken = hash . refreshToken if ( hash . tokenType === 's' ) { this . tokenType = 's' } else { this . tokenType = hash . tokenType } } } save ( ) { peertubeLocalStorage . setItem ( Tokens . KEYS . ACCESS_TOKEN , this . accessToken ) peertubeLocalStorage . setItem ( Tokens . KEYS . REFRESH_TOKEN , this . refreshToken ) peertubeLocalStorage . setItem ( Tokens . KEYS . TOKEN_TYPE , this . tokenType ) } } export class AuthUser extends User { private static KEYS = { ID : 's' , ROLE : 's' , EMAIL : 's' , VIDEOS_HISTORY_ENABLED : 's' , USERNAME : 's' , NSFW_POLICY : 's' , WEBTORRENT_ENABLED : 's' + 's' , AUTO_PLAY_VIDEO : 's' } tokens : Tokens static load ( ) { const usernameLocalStorage = peertubeLocalStorage . getItem ( this . KEYS . USERNAME ) if ( usernameLocalStorage ) { return new AuthUser ( { id : parseInt ( peertubeLocalStorage . getItem ( this . KEYS . ID ) , 0 ) , username : peertubeLocalStorage . getItem ( this . KEYS . USERNAME ) , email : peertubeLocalStorage . getItem ( this . KEYS . EMAIL ) , role : parseInt ( peertubeLocalStorage . getItem ( this . KEYS . ROLE ) , 0 ) as UserRole , nsfwPolicy : peertubeLocalStorage . getItem ( this . KEYS . NSFW_POLICY ) as NSFWPolicyType , webTorrentEnabled : peertubeLocalStorage . getItem ( this . KEYS . WEBTORRENT_ENABLED ) === 's' , autoPlayVideo : peertubeLocalStorage . getItem ( this . KEYS . AUTO_PLAY_VIDEO ) === 's' , videosHistoryEnabled : peertubeLocalStorage . getItem ( this . KEYS . VIDEOS_HISTORY_ENABLED ) === 's' } , Tokens . load ( ) ) } return null } static flush ( ) { peertubeLocalStorage . removeItem ( this . KEYS . USERNAME ) peertubeLocalStorage . removeItem ( this . KEYS . ID ) peertubeLocalStorage . removeItem ( this . KEYS . ROLE ) peertubeLocalStorage . removeItem ( this . KEYS . NSFW_POLICY ) peertubeLocalStorage . removeItem ( this . KEYS . WEBTORRENT_ENABLED ) peertubeLocalStorage . removeItem ( this . KEYS . VIDEOS_HISTORY_ENABLED ) peertubeLocalStorage . removeItem ( this . KEYS . AUTO_PLAY_VIDEO ) peertubeLocalStorage . removeItem ( this . KEYS . EMAIL ) Tokens . flush ( ) } constructor ( userHash < ServerUserModel > , hashTokens ) { super ( userHash ) this . tokens = new Tokens ( hashTokens ) } getAccessToken ( ) { return this . tokens . accessToken } getRefreshToken ( ) { return this . tokens . refreshToken } getTokenType ( ) { return this . tokens . tokenType } refreshTokens ( accessToken , refreshToken ) { this . tokens . accessToken = accessToken this . tokens . refreshToken = refreshToken } hasRight ( right ) { return hasUserRight ( this . role , right ) } canManage ( user ) { const myRole = this . role if ( myRole === UserRole . ADMINISTRATOR ) return true return user . role === UserRole . USER } save ( ) { peertubeLocalStorage . setItem ( AuthUser . KEYS . ID , this . id . toString ( ) ) peertubeLocalStorage . setItem ( AuthUser . KEYS . USERNAME , this . username ) peertubeLocalStorage . setItem ( AuthUser . KEYS . EMAIL , this . email ) peertubeLocalStorage . setItem ( AuthUser . KEYS . ROLE , this . role . toString ( ) ) peertubeLocalStorage . setItem ( AuthUser . KEYS . NSFW_POLICY , this . nsfwPolicy . toString ( ) ) peertubeLocalStorage . setItem ( AuthUser . KEYS . WEBTORRENT_ENABLED , JSON . stringify ( this . webTorrentEnabled ) ) peertubeLocalStorage . setItem ( AuthUser . KEYS . AUTO_PLAY_VIDEO , JSON . stringify ( this . autoPlayVideo ) ) this . tokens . save ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokenOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O $TokenOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O $UserRight$ O O O O O O O O O O O O O O $ServerUserModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' export const environment = { production : false , hmr : false , apiUrl : 's' }	O O O O O O O O O O O O O O O O O O O O O
import { throwError as observableThrowError } from 's' import { Injectable } from 's' import { dateToHuman } from 's' import { ResultList } from 's' import { Router } from 's' import { 0 } from 's' @ Injectable ( ) export class RestExtractor { constructor ( private router , private 0 ) { } extractDataBool ( ) { return true } applyToResultListData < T > ( result < T > , fun , additionalArgs ? : any [ ] ) < T > { const data : T [ ] = result . data const newData : T [ ] = [ ] data . forEach ( d => newData . push ( fun . apply ( this , [ d ] . concat ( additionalArgs ) ) ) ) return { total : result . total , data : newData } } convertResultListDateToHuman < T > ( result < T > , fieldsToConvert : string [ ] = [ 's' ] ) < T > { return this . applyToResultListData ( result , this . convertDateToHuman , [ fieldsToConvert ] ) } convertDateToHuman ( target : { [ id ] : string } , fieldsToConvert : string [ ] ) { fieldsToConvert . forEach ( field => target [ field ] = dateToHuman ( target [ field ] ) ) return target } handleError ( err ) { let errorMessage if ( err . error instanceof Error ) { errorMessage = err . error . message console . error ( 's' , errorMessage ) } else if ( typeof err . error === 's' ) { errorMessage = err . error } else if ( err . status !== undefined ) { if ( err . error && err . error . errors ) { const errors = err . error . errors const errorsArray : string [ ] = [ ] Object . keys ( errors ) . forEach ( key => { errorsArray . push ( errors [ key ] . msg ) } ) errorMessage = errorsArray . join ( 's' ) } else if ( err . error && err . error . error ) { errorMessage = err . error . error } else if ( err . status === 0 ) { errorMessage = this . 0 ( 's' ) } else if ( err . status === 0 ) { const secondsLeft = err . headers . get ( 's' ) if ( secondsLeft ) { const minutesLeft = Math . floor ( parseInt ( secondsLeft , 0 ) / 0 ) errorMessage = this . 0 ( 's' , { minutesLeft } ) } else { errorMessage = this . 0 ( 's' ) } } else if ( err . status === 0 ) { errorMessage = this . 0 ( 's' ) } errorMessage = errorMessage ? errorMessage : 's' console . error ( `template` ) } else { console . error ( err ) errorMessage = err } const errorObj : { message : string , status : string , body : string } = { message : errorMessage , status : undefined , body : undefined } if ( err . status ) { errorObj . status = err . status errorObj . body = err . error } return observableThrowError ( errorObj ) } 0 ( obj : { status : number } , status = [ 0 ] ) { if ( obj && obj . status && status . indexOf ( obj . status ) !== - 0 ) { this . router . navigate ( [ 's' ] , { skipLocationChange : true } ) } return observableThrowError ( obj ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $I18n$ O O O O O O O O O O $ResultList$ O O O O $ResultList$ O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , ReplaySubject , Subject , throwError as observableThrowError } from 's' import { catchError , map , mergeMap , share , tap } from 's' import { HttpClient , HttpHeaders , HttpParams } from 's' import { Injectable } from 's' import { Router } from 's' import { Notifier } from 's' import { OAuthClientLocal , User as UserServerModel , UserRefreshToken } from 's' import { User } from 's' import { UserLogin } from 's' import { environment } from 's' import { RestExtractor } from 's' import { AuthStatus } from 's' import { AuthUser } from 's' import { objectToUrlEncoded } from 's' import { peertubeLocalStorage } from 's' import { 0 } from 's' import { Hotkey , HotkeysService } from 's' interface UserLoginWithUsername extends UserLogin { access_token : string refresh_token : string token_type : string username : string } type UserLoginWithUserInformation = UserLoginWithUsername & User @ Injectable ( ) export class AuthService { private static BASE_CLIENT_URL = environment . apiUrl + 's' private static BASE_TOKEN_URL = environment . apiUrl + 's' private static BASE_USER_INFORMATION_URL = environment . apiUrl + 's' private static LOCAL_STORAGE_OAUTH_CLIENT_KEYS = { CLIENT_ID : 's' , CLIENT_SECRET : 's' } loginChangedSource : Observable < AuthStatus > userInformationLoaded = new ReplaySubject < boolean > ( 0 ) hotkeys : Hotkey [ ] private clientId : string = peertubeLocalStorage . getItem ( AuthService . LOCAL_STORAGE_OAUTH_CLIENT_KEYS . CLIENT_ID ) private clientSecret : string = peertubeLocalStorage . getItem ( AuthService . LOCAL_STORAGE_OAUTH_CLIENT_KEYS . CLIENT_SECRET ) private loginChanged : Subject < AuthStatus > private user : AuthUser = null private refreshingTokenObservable : Observable < any > constructor ( private http , private notifier , private hotkeysService , private restExtractor , private router , private 0 ) { this . loginChanged = new Subject < AuthStatus > ( ) this . loginChangedSource = this . loginChanged . asObservable ( ) this . user = AuthUser . load ( ) this . hotkeys = [ new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) ] } loadClientCredentials ( ) { this . http . get < OAuthClientLocal > ( AuthService . BASE_CLIENT_URL ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) . subscribe ( res => { this . clientId = res . client_id this . clientSecret = res . client_secret peertubeLocalStorage . setItem ( AuthService . LOCAL_STORAGE_OAUTH_CLIENT_KEYS . CLIENT_ID , this . clientId ) peertubeLocalStorage . setItem ( AuthService . LOCAL_STORAGE_OAUTH_CLIENT_KEYS . CLIENT_SECRET , this . clientSecret ) console . log ( 's' ) } , error => { let errorMessage = error . message if ( error . status === 0 ) { errorMessage = this . 0 ( 's' , { errorText : error . text } ) errorMessage += this . 0 ( 's' ) } this . notifier . error ( errorMessage , this . 0 ( 's' ) , 0 ) } ) } getRefreshToken ( ) { if ( this . user === null ) return null return this . user . getRefreshToken ( ) } getRequestHeaderValue ( ) { const accessToken = this . getAccessToken ( ) if ( accessToken === null ) return null return `template` } getAccessToken ( ) { if ( this . user === null ) return null return this . user . getAccessToken ( ) } getTokenType ( ) { if ( this . user === null ) return null return this . user . getTokenType ( ) } getUser ( ) { return this . user } isLoggedIn ( ) { return ! ! this . getAccessToken ( ) } login ( username , password ) { const body = { client_id : this . clientId , client_secret : this . clientSecret , response_type : 's' , grant_type : 's' , scope : 's' , username , password } const headers = new HttpHeaders ( ) . set ( 's' , 's' ) return this . http . post < UserLogin > ( AuthService . BASE_TOKEN_URL , objectToUrlEncoded ( body ) , { headers } ) . pipe ( map ( res => Object . assign ( res , { username } ) ) , mergeMap ( res => this . mergeUserInformation ( res ) ) , map ( res => this . handleLogin ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } logout ( ) { this . user = null AuthUser . flush ( ) this . setStatus ( AuthStatus . LoggedOut ) this . hotkeysService . remove ( this . hotkeys ) } refreshAccessToken ( ) { if ( this . refreshingTokenObservable ) return this . refreshingTokenObservable console . log ( 's' ) const refreshToken = this . getRefreshToken ( ) const body = new HttpParams ( ) . set ( 's' , refreshToken ) . set ( 's' , this . clientId ) . set ( 's' , this . clientSecret ) . set ( 's' , 's' ) . set ( 's' , 's' ) const headers = new HttpHeaders ( ) . set ( 's' , 's' ) this . refreshingTokenObservable = this . http . post < UserRefreshToken > ( AuthService . BASE_TOKEN_URL , body , { headers } ) . pipe ( map ( res => this . handleRefreshToken ( res ) ) , tap ( ( ) => this . refreshingTokenObservable = null ) , catchError ( err => { this . refreshingTokenObservable = null console . error ( err ) console . log ( 's' ) this . logout ( ) this . router . navigate ( [ 's' ] ) return observableThrowError ( { error : this . 0 ( 's' ) } ) } ) , share ( ) ) return this . refreshingTokenObservable } refreshUserInformation ( ) { const obj = { access_token : this . user . getAccessToken ( ) , refresh_token : null , token_type : this . user . getTokenType ( ) , username : this . user . username } this . mergeUserInformation ( obj ) . subscribe ( res => { this . user . patch ( res ) this . user . save ( ) this . userInformationLoaded . next ( true ) } ) } private mergeUserInformation ( obj ) < UserLoginWithUserInformation > { const headers = new HttpHeaders ( ) . set ( 's' , `template` ) return this . http . get < UserServerModel > ( AuthService . BASE_USER_INFORMATION_URL , { headers } ) . pipe ( map ( res => Object . assign ( obj , res ) ) ) } private handleLogin ( obj ) { const hashTokens = { accessToken : obj . access_token , tokenType : obj . token_type , refreshToken : obj . refresh_token } this . user = new AuthUser ( obj , hashTokens ) this . user . save ( ) this . setStatus ( AuthStatus . LoggedIn ) this . userInformationLoaded . next ( true ) this . hotkeysService . add ( this . hotkeys ) } private handleRefreshToken ( obj ) { this . user . refreshTokens ( obj . access_token , obj . refresh_token ) this . user . save ( ) } private setStatus ( status ) { this . loginChanged . next ( status ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $Notifier$ O O $HotkeysService$ O O $RestExtractor$ O O $Router$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserLoginWithUsername$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $UserLoginWithUsername$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserLoginWithUserInformation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRefreshToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthStatus$ O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { first } from 's' import { Injectable } from 's' import { Subject } from 's' type ConfirmOptions = { title : string message : string inputLabel ? : string expectedInputValue ? : string confirmButtonText ? : string } @ Injectable ( ) export class ConfirmService { showConfirm = new Subject < ConfirmOptions > ( ) confirmResponse = new Subject < boolean > ( ) confirm ( message , title = 's' , confirmButtonText ? ) { this . showConfirm . next ( { title , message , confirmButtonText } ) return this . confirmResponse . asObservable ( ) . pipe ( first ( ) ) . toPromise ( ) } confirmWithInput ( message , inputLabel , expectedInputValue , title = 's' , confirmButtonText ? ) { this . showConfirm . next ( { title , message , inputLabel , expectedInputValue , confirmButtonText } ) return this . confirmResponse . asObservable ( ) . pipe ( first ( ) ) . toPromise ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Injectable } from 's' import { ActivatedRouteSnapshot , CanActivate , CanActivateChild , Router , RouterStateSnapshot } from 's' import { AuthService } from 's' @ Injectable ( ) export class LoginGuard implements CanActivate , CanActivateChild { constructor ( private router , private auth ) { } canActivate ( route , state ) { if ( this . auth . isLoggedIn ( ) === true ) return true this . router . navigate ( [ 's' ] ) return false } canActivateChild ( route , state ) { return this . canActivate ( route , state ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $AuthService$ O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O
import { Injectable } from 's' import { ActivatedRouteSnapshot , CanActivateChild , RouterStateSnapshot , CanActivate , Router } from 's' import { AuthService } from 's' @ Injectable ( ) export class UserRightGuard implements CanActivate , CanActivateChild { constructor ( private router , private auth ) { } canActivate ( route , state ) { const user = this . auth . getUser ( ) if ( user ) { const neededUserRight = route . data . userRight if ( user . hasRight ( neededUserRight ) ) return true } this . router . navigate ( [ 's' ] ) return false } canActivateChild ( route , state ) { return this . canActivate ( route , state ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $AuthService$ O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O
import { Observable , timer as observableTimer , of as ofObservable } from 's' import { switchMap } from 's' import { PreloadingStrategy , Route } from 's' export class PreloadSelectedModulesList implements PreloadingStrategy { preload ( route , load ) < any > { if ( ! route . data || ! route . data . preload ) return ofObservable ( null ) if ( typeof route . data . preload === 's' ) { return observableTimer ( route . data . preload ) . pipe ( switchMap ( ( ) => load ( ) ) ) } return load ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $Route$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { map , shareReplay , switchMap , tap } from 's' import { HttpClient } from 's' import { Inject , Injectable , LOCALE_ID } from 's' import { peertubeLocalStorage } from 's' import { Observable , of , ReplaySubject } from 's' import { getCompleteLocale , ServerConfig } from 's' import { environment } from 's' import { VideoConstant , VideoPrivacy } from 's' import { isDefaultLocale , peertubeTranslate } from 's' import { getDevLocale , isOnDevLocale } from 's' import { sortBy } from 's' import { VideoPlaylistPrivacy } from 's' import { cloneDeep } from 's' @ Injectable ( ) export class ServerService { private static BASE_SERVER_URL = environment . apiUrl + 's' private static BASE_CONFIG_URL = environment . apiUrl + 's' private static BASE_VIDEO_URL = environment . apiUrl + 's' private static BASE_VIDEO_PLAYLIST_URL = environment . apiUrl + 's' private static BASE_LOCALE_URL = environment . apiUrl + 's' private static CONFIG_LOCAL_STORAGE_KEY = 's' configLoaded = new ReplaySubject < boolean > ( 0 ) videoPrivaciesLoaded = new ReplaySubject < boolean > ( 0 ) videoPlaylistPrivaciesLoaded = new ReplaySubject < boolean > ( 0 ) videoCategoriesLoaded = new ReplaySubject < boolean > ( 0 ) videoLicencesLoaded = new ReplaySubject < boolean > ( 0 ) videoLanguagesLoaded = new ReplaySubject < boolean > ( 0 ) localeObservable : Observable < any > private config : ServerConfig = { instance : { name : 's' , shortDescription : 's' + 's' , defaultClientRoute : 's' , isNSFW : false , defaultNSFWPolicy : 's' as 's' , customizations : { javascript : 's' , css : 's' } } , plugin : { registered : [ ] } , theme : { registered : [ ] , default : 's' } , email : { enabled : false } , contactForm : { enabled : false } , serverVersion : 's' , signup : { allowed : false , allowedForCurrentIP : false , requiresEmailVerification : false } , transcoding : { enabledResolutions : [ ] , hls : { enabled : false } } , avatar : { file : { size : { max : 0 } , extensions : [ ] } } , video : { image : { size : { max : 0 } , extensions : [ ] } , file : { extensions : [ ] } } , videoCaption : { file : { size : { max : 0 } , extensions : [ ] } } , user : { videoQuota : - 0 , videoQuotaDaily : - 0 } , import : { videos : { http : { enabled : false } , torrent : { enabled : false } } } , trending : { videos : { intervalDays : 0 } } , autoBlacklist : { videos : { ofUsers : { enabled : false } } } , tracker : { enabled : true } } private videoCategories : Array < VideoConstant < number > > = [ ] private videoLicences : Array < VideoConstant < number > > = [ ] private videoLanguages : Array < VideoConstant < string > > = [ ] private videoPrivacies : Array < VideoConstant < VideoPrivacy > > = [ ] private videoPlaylistPrivacies : Array < VideoConstant < VideoPlaylistPrivacy > > = [ ] constructor ( private http , @ Inject ( LOCALE_ID ) private localeId ) { this . loadServerLocale ( ) this . loadConfigLocally ( ) } loadConfig ( ) { this . http . get < ServerConfig > ( ServerService . BASE_CONFIG_URL ) . pipe ( tap ( this . saveConfigLocally ) ) . subscribe ( data => { this . config = data this . configLoaded . next ( true ) } ) } loadVideoCategories ( ) { return this . loadAttributeEnum ( ServerService . BASE_VIDEO_URL , 's' , this . videoCategories , this . videoCategoriesLoaded , true ) } loadVideoLicences ( ) { return this . loadAttributeEnum ( ServerService . BASE_VIDEO_URL , 's' , this . videoLicences , this . videoLicencesLoaded ) } loadVideoLanguages ( ) { return this . loadAttributeEnum ( ServerService . BASE_VIDEO_URL , 's' , this . videoLanguages , this . videoLanguagesLoaded , true ) } loadVideoPrivacies ( ) { return this . loadAttributeEnum ( ServerService . BASE_VIDEO_URL , 's' , this . videoPrivacies , this . videoPrivaciesLoaded ) } loadVideoPlaylistPrivacies ( ) { return this . loadAttributeEnum ( ServerService . BASE_VIDEO_PLAYLIST_URL , 's' , this . videoPlaylistPrivacies , this . videoPlaylistPrivaciesLoaded ) } getConfig ( ) { return cloneDeep ( this . config ) } getVideoCategories ( ) { return cloneDeep ( this . videoCategories ) } getVideoLicences ( ) { return cloneDeep ( this . videoLicences ) } getVideoLanguages ( ) { return cloneDeep ( this . videoLanguages ) } getVideoPrivacies ( ) { return cloneDeep ( this . videoPrivacies ) } getVideoPlaylistPrivacies ( ) { return cloneDeep ( this . videoPlaylistPrivacies ) } private loadAttributeEnum ( baseUrl , attributeName : 's' | 's' | 's' | 's' , hashToPopulate : VideoConstant < string | number > [ ] , notifier < boolean > , sort = false ) { this . localeObservable . pipe ( switchMap ( translations => { return this . http . get < { [ id ] : string } > ( baseUrl + attributeName ) . pipe ( map ( data => ( { data , translations } ) ) ) } ) ) . subscribe ( ( { data , translations } ) => { Object . keys ( data ) . forEach ( dataKey => { const label = data [ dataKey ] hashToPopulate . push ( { id : attributeName === 's' ? dataKey : parseInt ( dataKey , 0 ) , label : peertubeTranslate ( label , translations ) } ) } ) if ( sort === true ) sortBy ( hashToPopulate , 's' ) notifier . next ( true ) } ) } private loadServerLocale ( ) { const completeLocale = isOnDevLocale ( ) ? getDevLocale ( ) : getCompleteLocale ( this . localeId ) if ( isDefaultLocale ( completeLocale ) ) { this . localeObservable = of ( { } ) . pipe ( shareReplay ( ) ) return } this . localeObservable = this . http . get ( ServerService . BASE_LOCALE_URL + completeLocale + 's' ) . pipe ( shareReplay ( ) ) } private saveConfigLocally ( config ) { peertubeLocalStorage . setItem ( ServerService . CONFIG_LOCAL_STORAGE_KEY , JSON . stringify ( config ) ) } private loadConfigLocally ( ) { const configString = peertubeLocalStorage . getItem ( ServerService . CONFIG_LOCAL_STORAGE_KEY ) if ( configString ) { try { const parsed = JSON . parse ( configString ) Object . assign ( this . config , parsed ) } catch ( err ) { console . error ( 's' , err ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $ReplaySubject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Injectable } from 's' import { NavigationEnd , Router } from 's' import { ServerService } from 's' @ Injectable ( ) export class RedirectService { static INIT_DEFAULT_ROUTE = 's' static DEFAULT_ROUTE = RedirectService . INIT_DEFAULT_ROUTE private previousUrl : string private currentUrl : string constructor ( private router , private serverService ) { const config = this . serverService . getConfig ( ) if ( config && config . instance && config . instance . defaultClientRoute ) { RedirectService . DEFAULT_ROUTE = config . instance . defaultClientRoute } this . serverService . configLoaded . subscribe ( ( ) => { const defaultRouteConfig = this . serverService . getConfig ( ) . instance . defaultClientRoute if ( defaultRouteConfig ) { RedirectService . DEFAULT_ROUTE = defaultRouteConfig } } ) this . currentUrl = this . router . url router . events . subscribe ( event => { if ( event instanceof NavigationEnd ) { this . previousUrl = this . currentUrl this . currentUrl = event . url } } ) } redirectToPreviousRoute ( ) { const exceptions = [ 's' ] if ( this . previousUrl ) { const isException = exceptions . find ( e => this . previousUrl . startsWith ( e ) ) if ( ! isException ) return this . router . navigateByUrl ( this . previousUrl ) } return this . redirectToHomepage ( ) } redirectToHomepage ( skipLocationChange = false ) { console . log ( 's' , RedirectService . DEFAULT_ROUTE ) this . router . navigate ( [ RedirectService . DEFAULT_ROUTE ] , { skipLocationChange } ) . catch ( ( ) => { console . error ( 's' , RedirectService . DEFAULT_ROUTE , RedirectService . INIT_DEFAULT_ROUTE ) RedirectService . DEFAULT_ROUTE = RedirectService . INIT_DEFAULT_ROUTE return this . router . navigate ( [ RedirectService . DEFAULT_ROUTE ] , { skipLocationChange } ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { MessageService } from 's' import { 0 } from 's' @ Injectable ( ) export class Notifier { readonly TIMEOUT = 0 constructor ( private 0 , private messageService ) { } info ( text , title ? , timeout ? ) { if ( ! title ) title = this . 0 ( 's' ) return this . notify ( 's' , text , title , timeout ) } error ( text , title ? , timeout ? ) { if ( ! title ) title = this . 0 ( 's' ) return this . notify ( 's' , text , title , timeout ) } success ( text , title ? , timeout ? ) { if ( ! title ) title = this . 0 ( 's' ) return this . notify ( 's' , text , title , timeout ) } private notify ( severity : 's' | 's' | 's' | 's' , text , title , timeout ? ) { this . messageService . add ( { severity , summary : title , detail : text , closable : true , life : timeout || this . TIMEOUT } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $MessageService$ O O O O O $string$ O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , NgZone } from 's' import { environment } from 's' import { UserNotification as UserNotificationServer } from 's' import { Subject } from 's' import { AuthService } from 's' export type NotificationEvent = 's' | 's' | 's' @ Injectable ( ) export class UserNotificationSocket { private notificationSubject = new Subject < { type : NotificationEvent , notification ? : UserNotificationServer } > ( ) private socket : SocketIOClient . Socket constructor ( private auth , private ngZone ) { } dispatch ( type , notification ? ) { this . notificationSubject . next ( { type , notification } ) } async getMyNotificationsSocket ( ) { await this . initSocket ( ) return this . notificationSubject . asObservable ( ) } private async initSocket ( ) { if ( this . socket ) return const io : typeof import ( 's' ) = ( await import ( 's' ) as any ) . default this . ngZone . runOutsideAngular ( ( ) => { this . socket = io ( environment . apiUrl + 's' , { query : { accessToken : this . auth . getAccessToken ( ) } } ) this . socket . on ( 's' , ( n ) => this . dispatch ( 's' , n ) ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $NgZone$ O O O O O $NotificationEvent$ O O $UserNotificationServer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationServer$ O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Injectable } from 's' import { AuthService } from 's' import { ServerService } from 's' import { environment } from 's' import { PluginService } from 's' import { ServerConfigTheme } from 's' @ Injectable ( ) export class ThemeService { private oldThemeName : string private themes : ServerConfigTheme [ ] = [ ] constructor ( private auth , private pluginService , private server ) { } initialize ( ) { this . server . configLoaded . subscribe ( ( ) => { this . injectThemes ( ) this . listenUserTheme ( ) } ) } private injectThemes ( ) { this . themes = this . server . getConfig ( ) . theme . registered console . log ( 's' , this . themes . length ) const head = document . getElementsByTagName ( 's' ) [ 0 ] for ( const theme of this . themes ) { for ( const css of theme . css ) { const link = document . createElement ( 's' ) const href = environment . apiUrl + `template` link . setAttribute ( 's' , href ) link . setAttribute ( 's' , 's' ) link . setAttribute ( 's' , 's' ) link . setAttribute ( 's' , theme . name ) link . setAttribute ( 's' , 's' ) head . appendChild ( link ) } } } private getCurrentTheme ( ) { if ( this . auth . isLoggedIn ( ) ) { const theme = this . auth . getUser ( ) . theme if ( theme !== 's' ) return theme } return this . server . getConfig ( ) . theme . default } private loadTheme ( name ) { const links = document . getElementsByTagName ( 's' ) for ( let i = 0 ; i < links . length ; i ++ ) { const link = links [ i ] if ( link . getAttribute ( 's' ) . indexOf ( 's' ) !== - 0 && link . getAttribute ( 's' ) ) { link . disabled = link . getAttribute ( 's' ) !== name } } } private updateCurrentTheme ( ) { if ( this . oldThemeName ) { const oldTheme = this . getTheme ( this . oldThemeName ) if ( oldTheme ) { console . log ( 's' , this . oldThemeName ) this . pluginService . removePlugin ( oldTheme ) } } const currentTheme = this . getCurrentTheme ( ) console . log ( 's' , currentTheme ) this . loadTheme ( currentTheme ) const theme = this . getTheme ( currentTheme ) if ( theme ) { console . log ( 's' , currentTheme ) this . pluginService . addPlugin ( theme , true ) this . pluginService . reloadLoadedScopes ( ) } this . oldThemeName = currentTheme } private listenUserTheme ( ) { if ( ! this . auth . isLoggedIn ( ) ) { this . updateCurrentTheme ( ) } this . auth . userInformationLoaded . subscribe ( ( ) => this . updateCurrentTheme ( ) ) } private getTheme ( name ) { return this . themes . find ( t => t . name === name ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $PluginService$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export function throwIfAlreadyLoaded ( parentModule , moduleName ) { if ( parentModule ) { throw new Error ( `template` ) } }	O O O O $any$ O $string$ O O O O O O O O O O O O O O O
import { Component , OnInit , OnDestroy , Input } from 's' import { Subscription } from 's' import { 0 } from 's' import { HotkeysService , Hotkey } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class CheatSheetComponent implements OnInit , OnDestroy { @ Input ( ) title = this . 0 ( 's' ) helpVisible = false subscription : Subscription hotkeys : Hotkey [ ] constructor ( private hotkeysService , private 0 ) { } public ngOnInit ( ) { this . subscription = this . hotkeysService . cheatSheetToggle . subscribe ( ( isOpen ) => { if ( isOpen !== false ) { this . hotkeys = this . hotkeysService . hotkeys . filter ( hotkey => hotkey . description ) } if ( isOpen === false ) { this . helpVisible = false } else { this . toggleHelpVisible ( ) } } ) } public ngOnDestroy ( ) { if ( this . subscription ) { this . subscription . unsubscribe ( ) } } public toggleCheatSheet ( ) { this . hotkeysService . cheatSheetToggle . next ( ! this . helpVisible ) } public toggleHelpVisible ( ) { this . helpVisible = ! this . helpVisible } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HotkeysService$ O O $I18n$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O
export * from 's'	O O O O
import { Injectable } from 's' import { Resolve } from 's' import { ServerService } from 's' @ Injectable ( ) export class ServerConfigResolver implements Resolve < boolean > { constructor ( private server ) { } resolve ( ) { return new Promise < boolean > ( res => { return this . server . configLoaded . subscribe ( ( ) => res ( true ) ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CommonModule } from 's' import { NgModule , Optional , SkipSelf } from 's' import { FormsModule } from 's' import { BrowserAnimationsModule } from 's' import { RouterModule } from 's' import { LoadingBarModule } from 's' import { LoadingBarHttpClientModule } from 's' import { LoadingBarRouterModule } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { throwIfAlreadyLoaded } from 's' import { LoginGuard , RedirectService , UserRightGuard } from 's' import { ServerService } from 's' import { ThemeService } from 's' import { HotkeyModule } from 's' import { CheatSheetComponent } from 's' import { ToastModule } from 's' import { Notifier } from 's' import { MessageService } from 's' import { UserNotificationSocket } from 's' import { ServerConfigResolver } from 's' import { UnloggedGuard } from 's' import { PluginService } from 's' import { HooksService } from 's' @ NgModule ( { imports : [ CommonModule , RouterModule , FormsModule , BrowserAnimationsModule , LoadingBarHttpClientModule , LoadingBarRouterModule , LoadingBarModule , ToastModule , HotkeyModule . forRoot ( { cheatSheetCloseEsc : true } ) ] , declarations : [ CheatSheetComponent ] , exports : [ LoadingBarHttpClientModule , LoadingBarModule , ToastModule , CheatSheetComponent ] , providers : [ AuthService , ConfirmService , ServerService , ThemeService , LoginGuard , UserRightGuard , UnloggedGuard , PluginService , HooksService , RedirectService , Notifier , MessageService , UserNotificationSocket , ServerConfigResolver ] } ) export class CoreModule { constructor ( @ Optional ( ) @ SkipSelf ( ) parentModule ) { throwIfAlreadyLoaded ( parentModule , 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CoreModule$ O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , throwError as observableThrowError } from 's' import { catchError , switchMap } from 's' import { Injectable , Injector } from 's' import { HTTP_INTERCEPTORS , HttpEvent , HttpHandler , HttpInterceptor , HttpRequest } from 's' import { AuthService } from 's' @ Injectable ( ) export class AuthInterceptor implements HttpInterceptor { private authService : AuthService constructor ( private injector ) { } intercept ( req < any > , next ) < HttpEvent < any > > { if ( this . authService === undefined ) { this . authService = this . injector . get ( AuthService ) } const authReq = this . cloneRequestWithAuth ( req ) return next . handle ( authReq ) . pipe ( catchError ( err => { if ( err . status === 0 && err . error && err . error . code === 's' ) { return this . handleTokenExpired ( req , next ) } return observableThrowError ( err ) } ) ) } private handleTokenExpired ( req < any > , next ) < HttpEvent < any > > { return this . authService . refreshAccessToken ( ) . pipe ( switchMap ( ( ) => { const authReq = this . cloneRequestWithAuth ( req ) return next . handle ( authReq ) } ) ) } private cloneRequestWithAuth ( req < any > ) { const authHeaderValue = this . authService . getRequestHeaderValue ( ) if ( authHeaderValue === null ) return req return req . clone ( { headers : req . headers . set ( 's' , authHeaderValue ) } ) } } export const AUTH_INTERCEPTOR_PROVIDER = { provide : HTTP_INTERCEPTORS , useClass : AuthInterceptor , multi : true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Injector$ O O O $Observable$ O $HttpRequest$ O O O O $HttpHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $HttpRequest$ O O O O $HttpHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Validators } from 's' import { 0 } from 's' import { BuildFormValidator } from 's' import { Injectable } from 's' @ Injectable ( ) export class CustomConfigValidatorsService { readonly INSTANCE_NAME : BuildFormValidator readonly INSTANCE_SHORT_DESCRIPTION : BuildFormValidator readonly SERVICES_TWITTER_USERNAME : BuildFormValidator readonly CACHE_PREVIEWS_SIZE : BuildFormValidator readonly CACHE_CAPTIONS_SIZE : BuildFormValidator readonly SIGNUP_LIMIT : BuildFormValidator readonly ADMIN_EMAIL : BuildFormValidator readonly TRANSCODING_THREADS : BuildFormValidator readonly INDEX_URL : BuildFormValidator constructor ( private 0 ) { this . INSTANCE_NAME = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . INSTANCE_SHORT_DESCRIPTION = { VALIDATORS : [ Validators . max ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . SERVICES_TWITTER_USERNAME = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . CACHE_PREVIEWS_SIZE = { VALIDATORS : [ Validators . required , Validators . min ( 0 ) , Validators . pattern ( 's' ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . CACHE_CAPTIONS_SIZE = { VALIDATORS : [ Validators . required , Validators . min ( 0 ) , Validators . pattern ( 's' ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . SIGNUP_LIMIT = { VALIDATORS : [ Validators . required , Validators . min ( 0 ) , Validators . pattern ( 's' ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . ADMIN_EMAIL = { VALIDATORS : [ Validators . required , Validators . email ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . TRANSCODING_THREADS = { VALIDATORS : [ Validators . required , Validators . min ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . INDEX_URL = { VALIDATORS : [ Validators . required , Validators . pattern ( "s" ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FormBuilder , FormControl , FormGroup , ValidatorFn } from 's' import { Injectable } from 's' import { FormReactiveErrors , FormReactiveValidationMessages } from 's' export type BuildFormValidator = { VALIDATORS : ValidatorFn [ ] , MESSAGES : { [ name ] : string } } export type BuildFormArgument = { [ id ] : BuildFormValidator | BuildFormArgument } export type BuildFormDefaultValues = { [ name ] : string | string [ ] | BuildFormDefaultValues } @ Injectable ( ) export class FormValidatorService { constructor ( private formBuilder ) { } buildForm ( obj , defaultValues = { } ) { const formErrors = { } const validationMessages = { } const group : { [ key ] : any } = { } for ( const name of Object . keys ( obj ) ) { formErrors [ name ] = 's' const field = obj [ name ] if ( this . isRecursiveField ( field ) ) { const result = this . buildForm ( field as BuildFormArgument , defaultValues [ name ] as BuildFormDefaultValues ) group [ name ] = result . form formErrors [ name ] = result . formErrors validationMessages [ name ] = result . validationMessages continue } if ( field && field . MESSAGES ) validationMessages [ name ] = field . MESSAGES as { [ name ] : string } const defaultValue = defaultValues [ name ] || 's' if ( field && field . VALIDATORS ) group [ name ] = [ defaultValue , field . VALIDATORS ] else group [ name ] = [ defaultValue ] } const form = this . formBuilder . group ( group ) return { form , formErrors , validationMessages } } updateForm ( form , formErrors , validationMessages , obj , defaultValues = { } ) { for ( const name of Object . keys ( obj ) ) { formErrors [ name ] = 's' const field = obj [ name ] if ( this . isRecursiveField ( field ) ) { this . updateForm ( form [ name ] , formErrors [ name ] as FormReactiveErrors , validationMessages [ name ] as FormReactiveValidationMessages , obj [ name ] as BuildFormArgument , defaultValues [ name ] as BuildFormDefaultValues ) continue } if ( field && field . MESSAGES ) validationMessages [ name ] = field . MESSAGES as { [ name ] : string } const defaultValue = defaultValues [ name ] || 's' if ( field && field . VALIDATORS ) form . addControl ( name , new FormControl ( defaultValue , field . VALIDATORS as ValidatorFn [ ] ) ) else form . addControl ( name , new FormControl ( defaultValue ) ) } } private isRecursiveField ( field ) { return field && typeof field === 's' && ! field . MESSAGES && ! field . VALIDATORS } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $FormBuilder$ O O O O O $BuildFormArgument$ O $BuildFormDefaultValues$ O O O O O O $FormReactiveErrors$ O O O O $FormReactiveValidationMessages$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormGroup$ O $FormReactiveErrors$ O $FormReactiveValidationMessages$ O $BuildFormArgument$ O $BuildFormDefaultValues$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O
export function validateHost ( value ) { const HOST_REGEXP = new RegExp ( 's' ) return HOST_REGEXP . test ( value ) }	O O O O $string$ O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { BuildFormValidator } from 's' import { Injectable } from 's' @ Injectable ( ) export class InstanceValidatorsService { readonly FROM_EMAIL : BuildFormValidator readonly FROM_NAME : BuildFormValidator readonly SUBJECT : BuildFormValidator readonly BODY : BuildFormValidator constructor ( private 0 ) { this . FROM_EMAIL = { VALIDATORS : [ Validators . required , Validators . email ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . FROM_NAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . SUBJECT = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . BODY = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class LoginValidatorsService { readonly LOGIN_USERNAME : BuildFormValidator readonly LOGIN_PASSWORD : BuildFormValidator constructor ( private 0 ) { this . LOGIN_USERNAME = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . LOGIN_PASSWORD = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class ResetPasswordValidatorsService { readonly RESET_PASSWORD_CONFIRM : BuildFormValidator constructor ( private 0 ) { this . RESET_PASSWORD_CONFIRM = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { BuildFormValidator } from 's' import { Injectable } from 's' @ Injectable ( ) export class UserValidatorsService { readonly USER_USERNAME : BuildFormValidator readonly USER_EMAIL : BuildFormValidator readonly USER_PASSWORD : BuildFormValidator readonly USER_CONFIRM_PASSWORD : BuildFormValidator readonly USER_VIDEO_QUOTA : BuildFormValidator readonly USER_VIDEO_QUOTA_DAILY : BuildFormValidator readonly USER_ROLE : BuildFormValidator readonly USER_DISPLAY_NAME_REQUIRED : BuildFormValidator readonly USER_DESCRIPTION : BuildFormValidator readonly USER_TERMS : BuildFormValidator readonly USER_BAN_REASON : BuildFormValidator constructor ( private 0 ) { this . USER_USERNAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) , Validators . pattern ( "s" ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_EMAIL = { VALIDATORS : [ Validators . required , Validators . email ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_PASSWORD = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_CONFIRM_PASSWORD = { VALIDATORS : [ ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . USER_VIDEO_QUOTA = { VALIDATORS : [ Validators . required , Validators . min ( - 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_VIDEO_QUOTA_DAILY = { VALIDATORS : [ Validators . required , Validators . min ( - 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_ROLE = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . USER_DISPLAY_NAME_REQUIRED = this . getDisplayName ( true ) this . USER_DESCRIPTION = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . USER_TERMS = { VALIDATORS : [ Validators . requiredTrue ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . USER_BAN_REASON = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } private getDisplayName ( required ) { const control = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } if ( required ) control . VALIDATORS . push ( Validators . required ) return control } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoAbuseValidatorsService { readonly VIDEO_ABUSE_REASON : BuildFormValidator readonly VIDEO_ABUSE_MODERATION_COMMENT : BuildFormValidator constructor ( private 0 ) { this . VIDEO_ABUSE_REASON = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_ABUSE_MODERATION_COMMENT = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoBlacklistValidatorsService { readonly VIDEO_BLACKLIST_REASON : BuildFormValidator constructor ( private 0 ) { this . VIDEO_BLACKLIST_REASON = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoChannelValidatorsService { readonly VIDEO_CHANNEL_NAME : BuildFormValidator readonly VIDEO_CHANNEL_DISPLAY_NAME : BuildFormValidator readonly VIDEO_CHANNEL_DESCRIPTION : BuildFormValidator readonly VIDEO_CHANNEL_SUPPORT : BuildFormValidator constructor ( private 0 ) { this . VIDEO_CHANNEL_NAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) , Validators . pattern ( "s" ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_CHANNEL_DISPLAY_NAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : 0 ( 's' ) , 's' : 0 ( 's' ) , 's' : 0 ( 's' ) } } this . VIDEO_CHANNEL_DESCRIPTION = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : 0 ( 's' ) , 's' : 0 ( 's' ) } } this . VIDEO_CHANNEL_SUPPORT = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : 0 ( 's' ) , 's' : 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoCommentValidatorsService { readonly VIDEO_COMMENT_TEXT : BuildFormValidator constructor ( private 0 ) { this . VIDEO_COMMENT_TEXT = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoValidatorsService { readonly VIDEO_NAME : BuildFormValidator readonly VIDEO_PRIVACY : BuildFormValidator readonly VIDEO_CATEGORY : BuildFormValidator readonly VIDEO_LICENCE : BuildFormValidator readonly VIDEO_LANGUAGE : BuildFormValidator readonly VIDEO_IMAGE : BuildFormValidator readonly VIDEO_CHANNEL : BuildFormValidator readonly VIDEO_DESCRIPTION : BuildFormValidator readonly VIDEO_TAGS : BuildFormValidator readonly VIDEO_SUPPORT : BuildFormValidator readonly VIDEO_SCHEDULE_PUBLICATION_AT : BuildFormValidator readonly VIDEO_ORIGINALLY_PUBLISHED_AT : BuildFormValidator constructor ( private 0 ) { this . VIDEO_NAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_PRIVACY = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . VIDEO_CATEGORY = { VALIDATORS : [ ] , MESSAGES : { } } this . VIDEO_LICENCE = { VALIDATORS : [ ] , MESSAGES : { } } this . VIDEO_LANGUAGE = { VALIDATORS : [ ] , MESSAGES : { } } this . VIDEO_IMAGE = { VALIDATORS : [ ] , MESSAGES : { } } this . VIDEO_CHANNEL = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . VIDEO_DESCRIPTION = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_TAGS = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_SUPPORT = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_SCHEDULE_PUBLICATION_AT = { VALIDATORS : [ ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . VIDEO_ORIGINALLY_PUBLISHED_AT = { VALIDATORS : [ ] , MESSAGES : { } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { AbstractControl , FormControl , Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' import { VideoPlaylistPrivacy } from 's' @ Injectable ( ) export class VideoPlaylistValidatorsService { readonly VIDEO_PLAYLIST_DISPLAY_NAME : BuildFormValidator readonly VIDEO_PLAYLIST_PRIVACY : BuildFormValidator readonly VIDEO_PLAYLIST_DESCRIPTION : BuildFormValidator readonly VIDEO_PLAYLIST_CHANNEL_ID : BuildFormValidator constructor ( private 0 ) { this . VIDEO_PLAYLIST_DISPLAY_NAME = { VALIDATORS : [ Validators . required , Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } this . VIDEO_PLAYLIST_PRIVACY = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . VIDEO_PLAYLIST_DESCRIPTION = { VALIDATORS : [ Validators . minLength ( 0 ) , Validators . maxLength ( 0 ) ] , MESSAGES : { 's' : 0 ( 's' ) , 's' : 0 ( 's' ) } } this . VIDEO_PLAYLIST_CHANNEL_ID = { VALIDATORS : [ ] , MESSAGES : { 's' : this . 0 ( 's' ) } } } setChannelValidator ( channelControl , privacy ) { if ( privacy . toString ( ) === VideoPlaylistPrivacy . PUBLIC . toString ( ) ) { channelControl . setValidators ( [ Validators . required ] ) } else { channelControl . setValidators ( null ) } channelControl . markAsDirty ( ) channelControl . updateValueAndValidity ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AbstractControl$ O $VideoPlaylistPrivacy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoCaptionsValidatorsService { readonly VIDEO_CAPTION_LANGUAGE : BuildFormValidator readonly VIDEO_CAPTION_FILE : BuildFormValidator constructor ( private 0 ) { this . VIDEO_CAPTION_LANGUAGE = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } this . VIDEO_CAPTION_FILE = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { AbstractControl , ValidationErrors , Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoChangeOwnershipValidatorsService { readonly USERNAME : BuildFormValidator constructor ( private 0 ) { this . USERNAME = { VALIDATORS : [ Validators . required , this . localAccountValidator ] , MESSAGES : { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } } } localAccountValidator ( control ) { if ( control . value . includes ( 's' ) ) { return { 's' : true } } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ValidationErrors$ O $AbstractControl$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Validators } from 's' import { Injectable } from 's' import { BuildFormValidator } from 's' @ Injectable ( ) export class VideoAcceptOwnershipValidatorsService { readonly CHANNEL : BuildFormValidator constructor ( private 0 ) { this . CHANNEL = { VALIDATORS : [ Validators . required ] , MESSAGES : { 's' : this . 0 ( 's' ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FormGroup } from 's' import { BuildFormArgument , BuildFormDefaultValues , FormValidatorService } from 's' export type FormReactiveErrors = { [ id ] : string | FormReactiveErrors } export type FormReactiveValidationMessages = { [ id ] : { [ name ] : string } | FormReactiveValidationMessages } export abstract class FormReactive { protected abstract formValidatorService : FormValidatorService protected formChanged = false form : FormGroup formErrors : any validationMessages : FormReactiveValidationMessages buildForm ( obj , defaultValues = { } ) { const { formErrors , validationMessages , form } = this . formValidatorService . buildForm ( obj , defaultValues ) this . form = form this . formErrors = formErrors this . validationMessages = validationMessages this . form . valueChanges . subscribe ( ( ) => this . onValueChanged ( this . form , this . formErrors , this . validationMessages , false ) ) } protected forceCheck ( ) { return this . onValueChanged ( this . form , this . formErrors , this . validationMessages , true ) } protected check ( ) { return this . onValueChanged ( this . form , this . formErrors , this . validationMessages , false ) } private onValueChanged ( form , formErrors , validationMessages , forceCheck = false ) { for ( const field of Object . keys ( formErrors ) ) { if ( formErrors [ field ] && typeof formErrors [ field ] === 's' ) { this . onValueChanged ( form . controls [ field ] as FormGroup , formErrors [ field ] as FormReactiveErrors , validationMessages [ field ] as FormReactiveValidationMessages , forceCheck ) continue } formErrors [ field ] = 's' const control = form . get ( field ) if ( control . dirty ) this . formChanged = true const isDirty = control . dirty || forceCheck === true if ( control && isDirty && control . enabled && ! control . valid ) { const messages = validationMessages [ field ] for ( const key of Object . keys ( control . errors ) ) { formErrors [ field ] += messages [ key ] + 's' } } } } }	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildFormArgument$ O $BuildFormDefaultValues$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormGroup$ O $FormReactiveErrors$ O $FormReactiveValidationMessages$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , forwardRef , Input , OnInit , Output } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' import { Notifier } from 's' import { 0 } from 's' import { GlobalIconName } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => ReactiveFileComponent ) , multi : true } ] } ) export class ReactiveFileComponent implements OnInit , ControlValueAccessor { @ Input ( ) inputLabel : string @ Input ( ) inputName : string @ Input ( ) extensions : string [ ] = [ ] @ Input ( ) maxFileSize : number @ Input ( ) displayFilename = false @ Input ( ) icon : GlobalIconName @ Output ( ) fileChanged = new EventEmitter < Blob > ( ) allowedExtensionsMessage = 's' fileInputValue : any private file : File constructor ( private notifier , private 0 ) { } get filename ( ) { if ( ! this . file ) return 's' return this . file . name } ngOnInit ( ) { this . allowedExtensionsMessage = this . extensions . join ( 's' ) } fileChange ( event ) { if ( event . target . files && event . target . files . length ) { const [ file ] = event . target . files if ( file . size > this . maxFileSize ) { this . notifier . error ( this . 0 ( 's' ) ) return } const extension = 's' + file . name . split ( 's' ) . pop ( ) if ( this . extensions . includes ( extension ) === false ) { const message = this . 0 ( 's' , { extensions : this . allowedExtensionsMessage } ) this . notifier . error ( message ) return } this . file = file this . propagateChange ( this . file ) this . fileChanged . emit ( this . file ) } } propagateChange = ( _ ) => { } writeValue ( file ) { this . file = file if ( ! this . file ) this . fileInputValue = null } registerOnChange ( fn : ( _ ) => void ) { this . propagateChange = fn } registerOnTouched ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O
import { AfterViewInit , Directive , ElementRef , HostBinding , HostListener } from 's' @ Directive ( { selector : 's' } ) export class TextareaAutoResizeDirective implements AfterViewInit { @ HostBinding ( 's' ) rows = 's' @ HostBinding ( 's' ) overflow = 's' constructor ( private elem ) { } public ngAfterViewInit ( ) { this . resize ( ) } @ HostListener ( 's' ) resize ( ) { const textarea = this . elem . nativeElement as HTMLTextAreaElement textarea . style . height = 's' textarea . style . height = `template` } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O
export interface RestPagination { start : number count : number }	O O O O O O O O O O O
export interface ComponentPagination { currentPage : number itemsPerPage : number totalItems ? : number } export function hasMoreItems ( componentPagination ) { if ( componentPagination . totalItems === 0 ) return false if ( ! componentPagination . totalItems ) return true const maxPage = componentPagination . totalItems / componentPagination . itemsPerPage return maxPage > componentPagination . currentPage }	O O O O O O O O O O O O O O O O O O O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HttpParams } from 's' import { SortMeta } from 's' import { ComponentPagination } from 's' import { RestPagination } from 's' @ Injectable ( ) export class RestService { addRestGetParams ( params , pagination ? , sort ? : SortMeta | string ) { let newParams = params if ( pagination !== undefined ) { newParams = newParams . set ( 's' , pagination . start . toString ( ) ) . set ( 's' , pagination . count . toString ( ) ) } if ( sort !== undefined ) { let sortString = 's' if ( typeof sort === 's' ) { sortString = sort } else { const sortPrefix = sort . order === 0 ? 's' : 's' sortString = sortPrefix + sort . field } newParams = newParams . set ( 's' , sortString ) } return newParams } addObjectParams ( params , object : { [ name ] : any } ) { for ( const name of Object . keys ( object ) ) { const value = object [ name ] if ( ! value ) continue if ( Array . isArray ( value ) && value . length !== 0 ) { for ( const v of value ) params = params . append ( name , v ) } else { params = params . append ( name , value ) } } return params } componentPaginationToRestPagination ( componentPagination ) { const start = ( componentPagination . currentPage - 0 ) * componentPagination . itemsPerPage const count = componentPagination . itemsPerPage return { start , count } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpParams$ O O $RestPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpParams$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestPagination$ O $ComponentPagination$ O O O $number$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O
import { peertubeLocalStorage } from 's' import { LazyLoadEvent } from 's' import { SortMeta } from 's' import { RestPagination } from 's' import { Subject } from 's' import { debounceTime , distinctUntilChanged } from 's' export abstract class RestTable { abstract totalRecords : number abstract rowsPerPage : number abstract sort : SortMeta abstract pagination : RestPagination protected search : string private searchStream : Subject < string > private sortLocalStorageKey = 's' + this . constructor . name initialize ( ) { this . loadSort ( ) this . initSearch ( ) } loadSort ( ) { const result = peertubeLocalStorage . getItem ( this . sortLocalStorageKey ) if ( result ) { try { this . sort = JSON . parse ( result ) } catch ( err ) { console . error ( 's' + this . sortLocalStorageKey , err ) } } } loadLazy ( event ) { this . sort = { order : event . sortOrder , field : event . sortField } this . pagination = { start : event . first , count : this . rowsPerPage } this . loadData ( ) this . saveSort ( ) } saveSort ( ) { peertubeLocalStorage . setItem ( this . sortLocalStorageKey , JSON . stringify ( this . sort ) ) } initSearch ( ) { this . searchStream = new Subject ( ) this . searchStream . pipe ( debounceTime ( 0 ) , distinctUntilChanged ( ) ) . subscribe ( search => { this . search = search this . loadData ( ) } ) } onSearch ( search ) { this . searchStream . next ( search ) } protected abstract loadData ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LazyLoadEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $void$ O O O
export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O
import { from , Observable } from 's' import { catchError , concatMap , map , toArray } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { ResultList , User , UserCreate , UserRole , UserUpdate , UserUpdateMe , UserVideoQuota } from 's' import { environment } from 's' import { RestExtractor , RestPagination , RestService } from 's' import { Avatar } from 's' import { SortMeta } from 's' import { BytesPipe } from 's' import { 0 } from 's' import { UserRegister } from 's' @ Injectable ( ) export class UserService { static BASE_USERS_URL = environment . apiUrl + 's' private bytesPipe = new BytesPipe ( ) constructor ( private authHttp , private restExtractor , private restService , private 0 ) { } changePassword ( currentPassword , newPassword ) { const url = UserService . BASE_USERS_URL + 's' const body = { currentPassword , password : newPassword } return this . authHttp . put ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } changeEmail ( password , newEmail ) { const url = UserService . BASE_USERS_URL + 's' const body = { currentPassword : password , email : newEmail } return this . authHttp . put ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateMyProfile ( profile ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . put ( url , profile ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } deleteMe ( ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . delete ( url ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } changeAvatar ( avatarForm ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . post < { avatar : Avatar } > ( url , avatarForm ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } signup ( userCreate ) { return this . authHttp . post ( UserService . BASE_USERS_URL + 's' , userCreate ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getMyVideoQuotaUsed ( ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . get < UserVideoQuota > ( url ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } askResetPassword ( email ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . post ( url , { email } ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } resetPassword ( userId , verificationString , password ) { const url = `template` const body = { verificationString , password } return this . authHttp . post ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } verifyEmail ( userId , verificationString , isPendingEmail ) { const url = `template` const body = { verificationString , isPendingEmail } return this . authHttp . post ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } askSendVerifyEmail ( email ) { const url = UserService . BASE_USERS_URL + 's' return this . authHttp . post ( url , { email } ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } autocomplete ( search ) < string [ ] > { const url = UserService . BASE_USERS_URL + 's' const params = new HttpParams ( ) . append ( 's' , search ) return this . authHttp . get < string [ ] > ( url , { params } ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } getNewUsername ( oldDisplayName , newDisplayName , currentUsername ) { if ( this . displayNameToUsername ( oldDisplayName ) !== currentUsername ) return currentUsername return this . displayNameToUsername ( newDisplayName ) } displayNameToUsername ( displayName ) { if ( ! displayName ) return 's' return displayName . toLowerCase ( ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) } addUser ( userCreate ) { return this . authHttp . post ( UserService . BASE_USERS_URL , userCreate ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateUser ( userId , userUpdate ) { return this . authHttp . put ( UserService . BASE_USERS_URL + userId , userUpdate ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateUsers ( users : User [ ] , userUpdate ) { return from ( users ) . pipe ( concatMap ( u => this . authHttp . put ( UserService . BASE_USERS_URL + u . id , userUpdate ) ) , toArray ( ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getUser ( userId ) { return this . authHttp . get < User > ( UserService . BASE_USERS_URL + userId ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } getUsers ( pagination , sort , search ? ) < ResultList < User > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) if ( search ) params = params . append ( 's' , search ) return this . authHttp . get < ResultList < User > > ( UserService . BASE_USERS_URL , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , map ( res => this . restExtractor . applyToResultListData ( res , this . formatUser . bind ( this ) ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } removeUser ( usersArg : User | User [ ] ) { const users = Array . isArray ( usersArg ) ? usersArg : [ usersArg ] return from ( users ) . pipe ( concatMap ( u => this . authHttp . delete ( UserService . BASE_USERS_URL + u . id ) ) , toArray ( ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } banUsers ( usersArg : User | User [ ] , reason ? ) { const body = reason ? { reason } : { } const users = Array . isArray ( usersArg ) ? usersArg : [ usersArg ] return from ( users ) . pipe ( concatMap ( u => this . authHttp . post ( UserService . BASE_USERS_URL + u . id + 's' , body ) ) , toArray ( ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } unbanUsers ( usersArg : User | User [ ] ) { const users = Array . isArray ( usersArg ) ? usersArg : [ usersArg ] return from ( users ) . pipe ( concatMap ( u => this . authHttp . post ( UserService . BASE_USERS_URL + u . id + 's' , { } ) ) , toArray ( ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } private formatUser ( user ) { let videoQuota if ( user . videoQuota === - 0 ) { videoQuota = this . 0 ( 's' ) } else { videoQuota = this . bytesPipe . transform ( user . videoQuota , 0 ) } const videoQuotaUsed = this . bytesPipe . transform ( user . videoQuotaUsed , 0 ) const roleLabels : { [ id in UserRole ] : string } = { [ UserRole . USER ] : this . 0 ( 's' ) , [ UserRole . ADMINISTRATOR ] : this . 0 ( 's' ) , [ UserRole . MODERATOR ] : this . 0 ( 's' ) } return Object . assign ( user , { roleLabel : roleLabels [ user . role ] , videoQuota , videoQuotaUsed } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $I18n$ O O O O O $string$ O $string$ O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRegister$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $UserUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $RestPagination$ O $SortMeta$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnInit , Output } from 's' import { UserNotificationService } from 's' import { UserNotificationType } from 's' import { ComponentPagination , hasMoreItems } from 's' import { Notifier } from 's' import { UserNotification } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserNotificationsComponent implements OnInit { @ Input ( ) ignoreLoadingBar = false @ Input ( ) infiniteScroll = true @ Input ( ) itemsPerPage = 0 @ Output ( ) notificationsLoaded = new EventEmitter ( ) notifications : UserNotification [ ] = [ ] UserNotificationType = UserNotificationType componentPagination : ComponentPagination onDataSubject = new Subject < any [ ] > ( ) constructor ( private userNotificationService , private notifier ) { } ngOnInit ( ) { this . componentPagination = { currentPage : 0 , itemsPerPage : this . itemsPerPage , totalItems : null } this . loadMoreNotifications ( ) } loadMoreNotifications ( ) { this . userNotificationService . listMyNotifications ( this . componentPagination , undefined , this . ignoreLoadingBar ) . subscribe ( result => { this . notifications = this . notifications . concat ( result . data ) this . componentPagination . totalItems = result . total this . notificationsLoaded . emit ( ) this . onDataSubject . next ( result . data ) } , err => this . notifier . error ( err . message ) ) } onNearOfBottom ( ) { if ( this . infiniteScroll === false ) return this . componentPagination . currentPage ++ if ( hasMoreItems ( this . componentPagination ) ) { this . loadMoreNotifications ( ) } } markAsRead ( notification ) { if ( notification . read ) return this . userNotificationService . markAsRead ( notification ) . subscribe ( ( ) => { notification . read = true } , err => this . notifier . error ( err . message ) ) } markAllAsRead ( ) { this . userNotificationService . markAllAsRead ( ) . subscribe ( ( ) => { for ( const notification of this . notifications ) { notification . read = true } } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationService$ O O $Notifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { SortMeta } from 's' import { Observable } from 's' import { ResultList , VideoAbuse , VideoAbuseUpdate } from 's' import { environment } from 's' import { RestExtractor , RestPagination , RestService } from 's' @ Injectable ( ) export class VideoAbuseService { private static BASE_VIDEO_ABUSE_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } getVideoAbuses ( pagination , sort ) < ResultList < VideoAbuse > > { const url = VideoAbuseService . BASE_VIDEO_ABUSE_URL + 's' let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < VideoAbuse > > ( url , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } reportVideo ( id , reason ) { const url = VideoAbuseService . BASE_VIDEO_ABUSE_URL + id + 's' const body = { reason } return this . authHttp . post ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } updateVideoAbuse ( videoAbuse , abuseUpdate ) { const url = VideoAbuseService . BASE_VIDEO_ABUSE_URL + videoAbuse . video . uuid + 's' + videoAbuse . id return this . authHttp . put ( url , abuseUpdate ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } removeVideoAbuse ( videoAbuse ) { const url = VideoAbuseService . BASE_VIDEO_ABUSE_URL + videoAbuse . video . uuid + 's' + videoAbuse . id return this . authHttp . delete ( url ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O $VideoAbuseUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { DatePipe } from 's' import { environment } from 's' import { AuthService } from 's' function getParameterByName ( name , url ) { if ( ! url ) url = window . location . href name = name . replace ( "s" , 's' ) const regex = new RegExp ( 's' + name + 's' ) const results = regex . exec ( url ) if ( ! results ) return null if ( ! results [ 0 ] ) return 's' return decodeURIComponent ( results [ 0 ] . replace ( "s" , 's' ) ) } function populateAsyncUserVideoChannels ( authService , channel : { id : number , label : string , support ? : string } [ ] ) { return new Promise ( res => { authService . userInformationLoaded . subscribe ( ( ) => { const user = authService . getUser ( ) if ( ! user ) return const videoChannels = user . videoChannels if ( Array . isArray ( videoChannels ) === false ) return videoChannels . forEach ( c => channel . push ( { id : c . id , label : c . displayName , support : c . support } ) ) return res ( ) } ) } ) } function getAbsoluteAPIUrl ( ) { let absoluteAPIUrl = environment . apiUrl if ( ! absoluteAPIUrl ) { absoluteAPIUrl = window . location . origin } return absoluteAPIUrl } const datePipe = new DatePipe ( 's' ) function dateToHuman ( date ) { return datePipe . transform ( date , 's' ) } function durationToString ( duration ) { const hours = Math . floor ( duration / 0 ) const minutes = Math . floor ( ( duration % 0 ) / 0 ) const seconds = duration % 0 const minutesPadding = minutes >= 0 ? 's' : 's' const secondsPadding = seconds >= 0 ? 's' : 's' const displayedHours = hours > 0 ? hours . toString ( ) + 's' : 's' return displayedHours + minutesPadding + minutes . toString ( ) + 's' + secondsPadding + seconds . toString ( ) } function immutableAssign < A , B > ( target : A , source : B ) { return Object . assign ( { } , target , source ) } function objectToUrlEncoded ( obj ) { const str : string [ ] = [ ] for ( const key of Object . keys ( obj ) ) { str . push ( encodeURIComponent ( key ) + 's' + encodeURIComponent ( obj [ key ] ) ) } return str . join ( 's' ) } function objectToFormData ( obj , form ? , namespace ? ) { const fd = form || new FormData ( ) let formKey for ( const key of Object . keys ( obj ) ) { if ( namespace ) formKey = `template` else formKey = key if ( obj [ key ] === undefined ) continue if ( Array . isArray ( obj [ key ] ) && obj [ key ] . length === 0 ) { fd . append ( key , null ) continue } if ( obj [ key ] !== null && typeof obj [ key ] === 's' && ! ( obj [ key ] instanceof File ) ) { objectToFormData ( obj [ key ] , fd , formKey ) } else { fd . append ( formKey , obj [ key ] ) } } return fd } function objectLineFeedToHtml ( obj , keyToNormalize ) { return immutableAssign ( obj , { [ keyToNormalize ] : lineFeedToHtml ( obj [ keyToNormalize ] ) } ) } function lineFeedToHtml ( text ) { if ( ! text ) return text return text . replace ( "s" , 's' ) } function removeElementFromArray < T > ( arr : T [ ] , elem : T ) { const index = arr . indexOf ( elem ) if ( index !== - 0 ) arr . splice ( index , 0 ) } function sortBy ( obj : any [ ] , 0 , 0 ? ) { return obj . sort ( ( a , b ) => { const 0 = 0 ? a [ 0 ] [ 0 ] : a [ 0 ] const 0 = 0 ? b [ 0 ] [ 0 ] : b [ 0 ] if ( 0 < 0 ) return - 0 if ( 0 === 0 ) return 0 return 0 } ) } function scrollToTop ( ) { window . scroll ( 0 , 0 ) } function importModule ( path ) { return new Promise ( ( resolve , reject ) => { const vector = 's' + Math . random ( ) . toString ( 0 ) . slice ( 0 ) const script = document . createElement ( 's' ) const destructor = ( ) => { delete window [ vector ] script . onerror = null script . onload = null script . remove ( ) URL . revokeObjectURL ( script . src ) script . src = 's' } script . defer = true script . type = 's' script . onerror = ( ) => { reject ( new Error ( `template` ) ) destructor ( ) } script . onload = ( ) => { resolve ( window [ vector ] ) destructor ( ) } const absURL = ( environment . apiUrl || window . location . origin ) + path const loader = `template` const blob = new Blob ( [ loader ] , { type : 's' } ) script . src = URL . createObjectURL ( blob ) document . head . appendChild ( script ) } ) } export { sortBy , durationToString , lineFeedToHtml , objectToUrlEncoded , getParameterByName , populateAsyncUserVideoChannels , getAbsoluteAPIUrl , dateToHuman , immutableAssign , objectToFormData , objectLineFeedToHtml , removeElementFromArray , importModule , scrollToTop }	O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $FormData$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { User } from 's' import { UserRight , Video as VideoServerModel , VideoPrivacy , VideoState } from 's' import { Avatar } from 's' import { VideoConstant } from 's' import { durationToString , getAbsoluteAPIUrl } from 's' import { peertubeTranslate , ServerConfig } from 's' import { Actor } from 's' import { VideoScheduleUpdate } from 's' import { AuthUser } from 's' export class Video implements VideoServerModel { byVideoChannel : string byAccount : string accountAvatarUrl : string videoChannelAvatarUrl : string createdAt : Date updatedAt : Date publishedAt : Date originallyPublishedAt : Date | string category : VideoConstant < number > licence : VideoConstant < number > language : VideoConstant < string > privacy : VideoConstant < VideoPrivacy > description : string duration : number durationLabel : string id : number uuid : string isLocal : boolean name : string serverHost : string thumbnailPath : string thumbnailUrl : string previewPath : string previewUrl : string embedPath : string embedUrl : string views : number likes : number dislikes : number nsfw : boolean waitTranscoding ? : boolean state ? : VideoConstant < VideoState > scheduledUpdate ? : VideoScheduleUpdate blacklisted ? : boolean blacklistedReason ? : string account : { id : number name : string displayName : string url : string host : string avatar ? : Avatar } channel : { id : number name : string displayName : string url : string host : string avatar ? : Avatar } userHistory ? : { currentTime : number } static buildClientUrl ( videoUUID ) { return 's' + videoUUID } constructor ( hash , translations = { } ) { const absoluteAPIUrl = getAbsoluteAPIUrl ( ) this . createdAt = new Date ( hash . createdAt . toString ( ) ) this . publishedAt = new Date ( hash . publishedAt . toString ( ) ) this . category = hash . category this . licence = hash . licence this . language = hash . language this . privacy = hash . privacy this . waitTranscoding = hash . waitTranscoding this . state = hash . state this . description = hash . description this . duration = hash . duration this . durationLabel = durationToString ( hash . duration ) this . id = hash . id this . uuid = hash . uuid this . isLocal = hash . isLocal this . name = hash . name this . thumbnailPath = hash . thumbnailPath this . thumbnailUrl = absoluteAPIUrl + hash . thumbnailPath this . previewPath = hash . previewPath this . previewUrl = absoluteAPIUrl + hash . previewPath this . embedPath = hash . embedPath this . embedUrl = absoluteAPIUrl + hash . embedPath this . views = hash . views this . likes = hash . likes this . dislikes = hash . dislikes this . nsfw = hash . nsfw this . account = hash . account this . channel = hash . channel this . byAccount = Actor . CREATE_BY_STRING ( hash . account . name , hash . account . host ) this . byVideoChannel = Actor . CREATE_BY_STRING ( hash . channel . name , hash . channel . host ) this . accountAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . account ) this . videoChannelAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . channel ) this . category . label = peertubeTranslate ( this . category . label , translations ) this . licence . label = peertubeTranslate ( this . licence . label , translations ) this . language . label = peertubeTranslate ( this . language . label , translations ) this . privacy . label = peertubeTranslate ( this . privacy . label , translations ) this . scheduledUpdate = hash . scheduledUpdate this . originallyPublishedAt = hash . originallyPublishedAt ? new Date ( hash . originallyPublishedAt . toString ( ) ) : null if ( this . state ) this . state . label = peertubeTranslate ( this . state . label , translations ) this . blacklisted = hash . blacklisted this . blacklistedReason = hash . blacklistedReason this . userHistory = hash . userHistory } isVideoNSFWForUser ( user , serverConfig ) { if ( this . nsfw === false ) return false if ( user ) return user . nsfwPolicy !== 's' return serverConfig . instance . defaultNSFWPolicy !== 's' } isRemovableBy ( user ) { return user && this . isLocal === true && ( this . account . name === user . username || user . hasRight ( UserRight . REMOVE_ANY_VIDEO ) ) } isBlackistableBy ( user ) { return this . blacklisted !== true && user && user . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) === true } isUnblacklistableBy ( user ) { return this . blacklisted === true && user && user . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) === true } isUpdatableBy ( user ) { return user && this . isLocal === true && ( this . account . name === user . username || user . hasRight ( UserRight . UPDATE_ANY_VIDEO ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $VideoServerModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthUser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthUser$ O O O O O O O O O O O O O O O O O O O O O O O O $AuthUser$ O O O O O O O O O O O O O O O O O O O O O O O O $AuthUser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , concatMap , toArray } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { SortMeta } from 's' import { from as observableFrom , Observable } from 's' import { VideoBlacklist , VideoBlacklistType , ResultList } from 's' import { Video } from 's' import { environment } from 's' import { RestExtractor , RestPagination , RestService } from 's' import { ComponentPagination } from 's' @ Injectable ( ) export class VideoBlacklistService { private static BASE_VIDEOS_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } listBlacklist ( pagination , sort , type ? ) < ResultList < VideoBlacklist > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) if ( type ) { params = params . set ( 's' , type . toString ( ) ) } return this . authHttp . get < ResultList < VideoBlacklist > > ( VideoBlacklistService . BASE_VIDEOS_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } getAutoBlacklistedAsVideoList ( videoPagination ) < ResultList < Video > > { const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) const AUTO_BLACKLIST_SORT = 's' let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , AUTO_BLACKLIST_SORT ) params = params . set ( 's' , VideoBlacklistType . AUTO_BEFORE_PUBLISHED . toString ( ) ) return this . authHttp . get < ResultList < VideoBlacklist > > ( VideoBlacklistService . BASE_VIDEOS_URL + 's' , { params } ) . pipe ( map ( res => { return { total : res . total , data : res . data . map ( videoBlacklist => new Video ( videoBlacklist . video ) ) } } ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } removeVideoFromBlacklist ( videoIdArgs : number | number [ ] ) { const videoIds = Array . isArray ( videoIdArgs ) ? videoIdArgs : [ videoIdArgs ] return observableFrom ( videoIds ) . pipe ( concatMap ( id => this . authHttp . delete ( VideoBlacklistService . BASE_VIDEOS_URL + id + 's' ) ) , toArray ( ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } blacklistVideo ( videoId , reason , unfederate ) { const body = { unfederate , reason } return this . authHttp . post ( VideoBlacklistService . BASE_VIDEOS_URL + videoId + 's' , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O $RestPagination$ O $SortMeta$ O O $VideoBlacklistType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , Input } from 's' import { GlobalIconName } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class ButtonComponent { @ Input ( ) label = 's' @ Input ( ) className = 's' @ Input ( ) icon : GlobalIconName = undefined @ Input ( ) title : string = undefined @ Input ( ) loading = false getTitle ( ) { return this . title || this . label } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit } from 's' import { 0 } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class DeleteButtonComponent implements OnInit { @ Input ( ) label : string title : string constructor ( private 0 ) { } ngOnInit ( ) { this . title = this . label || this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class EditButtonComponent { @ Input ( ) label : string @ Input ( ) routerLink : string [ ] = [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class LoaderComponent { @ Input ( ) loading : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoChangeOwnershipAccept { channelId : number }	O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { VideoChangeOwnershipCreate } from 's' import { Observable } from 's' import { SortMeta } from 's' import { ResultList , VideoChangeOwnership } from 's' import { RestPagination } from 's' import { VideoChangeOwnershipAccept } from 's' @ Injectable ( ) export class VideoOwnershipService { private static BASE_VIDEO_CHANGE_OWNERSHIP_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } changeOwnership ( id , username ) { const url = VideoOwnershipService . BASE_VIDEO_CHANGE_OWNERSHIP_URL + id + 's' const body = { username } return this . authHttp . post ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } getOwnershipChanges ( pagination , sort ) < ResultList < VideoChangeOwnership > > { const url = VideoOwnershipService . BASE_VIDEO_CHANGE_OWNERSHIP_URL + 's' let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < VideoChangeOwnership > > ( url , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } acceptOwnership ( id , input ) { const url = VideoOwnershipService . BASE_VIDEO_CHANGE_OWNERSHIP_URL + 's' + id + 's' return this . authHttp . post ( url , input ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( this . restExtractor . handleError ) ) } refuseOwnership ( id ) { const url = VideoOwnershipService . BASE_VIDEO_CHANGE_OWNERSHIP_URL + 's' + id + 's' return this . authHttp . post ( url , { } ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( this . restExtractor . handleError ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O O O $number$ O $string$ O O O O O O O O O O O O O $VideoChangeOwnershipCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoChangeOwnershipAccept$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { ChangeDetectionStrategy , Component , EventEmitter , Inject , Input , LOCALE_ID , OnInit , Output } from 's' import { User } from 's' import { Video } from 's' import { ServerService } from 's' import { VideoPrivacy , VideoState } from 's' import { 0 } from 's' import { VideoActionsDisplayType } from 's' import { ScreenService } from 's' export type OwnerDisplayType = 's' | 's' | 's' export type MiniatureDisplayOptions = { date ? : boolean views ? : boolean by ? : boolean privacyLabel ? : boolean privacyText ? : boolean state ? : boolean blacklistInfo ? : boolean nsfw ? : boolean } @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , changeDetection : ChangeDetectionStrategy . OnPush } ) export class VideoMiniatureComponent implements OnInit { @ Input ( ) user : User @ Input ( ) video : Video @ Input ( ) ownerDisplayType : OwnerDisplayType = 's' @ Input ( ) displayOptions : MiniatureDisplayOptions = { date : true , views : true , by : true , privacyLabel : false , privacyText : false , state : false , blacklistInfo : false } @ Input ( ) displayAsRow = false @ Input ( ) displayVideoActions = true @ Output ( ) videoBlacklisted = new EventEmitter ( ) @ Output ( ) videoUnblacklisted = new EventEmitter ( ) @ Output ( ) videoRemoved = new EventEmitter ( ) videoActionsDisplayOptions : VideoActionsDisplayType = { playlist : true , download : false , update : true , blacklist : true , delete : true , report : true } showActions = false private ownerDisplayTypeChosen : 's' | 's' constructor ( private screenService , private serverService , private 0 , @ Inject ( LOCALE_ID ) private localeId ) { } get isVideoBlur ( ) { return this . video . isVideoNSFWForUser ( this . user , this . serverService . getConfig ( ) ) } ngOnInit ( ) { this . setUpBy ( ) if ( this . screenService . isInTouchScreen ( ) ) { this . loadActions ( ) } } displayOwnerAccount ( ) { return this . ownerDisplayTypeChosen === 's' } displayOwnerVideoChannel ( ) { return this . ownerDisplayTypeChosen === 's' } isUnlistedVideo ( ) { return this . video . privacy . id === VideoPrivacy . UNLISTED } isPrivateVideo ( ) { return this . video . privacy . id === VideoPrivacy . PRIVATE } getStateLabel ( video ) { if ( ! video . state ) return 's' if ( video . privacy . id !== VideoPrivacy . PRIVATE && video . state . id === VideoState . PUBLISHED ) { return this . 0 ( 's' ) } if ( video . scheduledUpdate ) { const updateAt = new Date ( video . scheduledUpdate . updateAt . toString ( ) ) . toLocaleString ( this . localeId ) return this . 0 ( 's' ) + updateAt } if ( video . state . id === VideoState . TO_TRANSCODE && video . waitTranscoding === true ) { return this . 0 ( 's' ) } if ( video . state . id === VideoState . TO_TRANSCODE ) { return this . 0 ( 's' ) } if ( video . state . id === VideoState . TO_IMPORT ) { return this . 0 ( 's' ) } return 's' } loadActions ( ) { if ( this . displayVideoActions ) this . showActions = true } onVideoBlacklisted ( ) { this . videoBlacklisted . emit ( ) } onVideoUnblacklisted ( ) { this . videoUnblacklisted . emit ( ) } onVideoRemoved ( ) { this . videoRemoved . emit ( ) } private setUpBy ( ) { if ( this . ownerDisplayType === 's' || this . ownerDisplayType === 's' ) { this . ownerDisplayTypeChosen = this . ownerDisplayType return } if ( this . video . channel . name === `template` || this . video . channel . name . match ( "s" ) ) { this . ownerDisplayTypeChosen = 's' } else { this . ownerDisplayTypeChosen = 's' } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScreenService$ O O $ServerService$ O O $I18n$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { Syndication } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class FeedComponent { @ Input ( ) syndicationItems : Syndication [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { Video } from 's' import { ScreenService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoThumbnailComponent { @ Input ( ) video : Video @ Input ( ) nsfw = false @ Input ( ) routerLink : any [ ] @ Input ( ) queryParams : any [ ] constructor ( private screenService ) { } getImageUrl ( ) { if ( ! this . video ) return 's' if ( this . screenService . isInMobileView ( ) ) { return this . video . previewUrl } return this . video . thumbnailUrl } getProgressPercent ( ) { if ( ! this . video . userHistory ) return 0 const currentTime = this . video . userHistory . currentTime return ( currentTime / this . video . duration ) * 0 } getVideoRouterLink ( ) { if ( this . routerLink ) return this . routerLink return [ 's' , this . video . uuid ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScreenService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type VideoSortField = 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoConstant , VideoDetails as VideoDetailsServerModel , VideoFile , VideoState } from 's' import { Video } from 's' import { Account } from 's' import { VideoChannel } from 's' import { VideoStreamingPlaylist } from 's' import { VideoStreamingPlaylistType } from 's' export class VideoDetails extends Video implements VideoDetailsServerModel { descriptionPath : string support : string channel : VideoChannel tags : string [ ] files : VideoFile [ ] account : Account commentsEnabled : boolean downloadEnabled : boolean waitTranscoding : boolean state : VideoConstant < VideoState > likesPercent : number dislikesPercent : number trackerUrls : string [ ] streamingPlaylists : VideoStreamingPlaylist [ ] constructor ( hash , translations = { } ) { super ( hash , translations ) this . descriptionPath = hash . descriptionPath this . files = hash . files this . channel = new VideoChannel ( hash . channel ) this . account = new Account ( hash . account ) this . tags = hash . tags this . support = hash . support this . commentsEnabled = hash . commentsEnabled this . downloadEnabled = hash . downloadEnabled this . trackerUrls = hash . trackerUrls this . streamingPlaylists = hash . streamingPlaylists this . buildLikeAndDislikePercents ( ) } buildLikeAndDislikePercents ( ) { this . likesPercent = ( this . likes / ( this . likes + this . dislikes ) ) * 0 this . dislikesPercent = ( this . dislikes / ( this . likes + this . dislikes ) ) * 0 } getHlsPlaylist ( ) { return this . streamingPlaylists . find ( p => p . type === VideoStreamingPlaylistType . HLS ) } hasHlsPlaylist ( ) { return ! ! this . getHlsPlaylist ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetailsServerModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoPrivacy } from 's' import { VideoUpdate } from 's' import { VideoScheduleUpdate } from 's' import { Video } from 's' export class VideoEdit implements VideoUpdate { static readonly SPECIAL_SCHEDULED_PRIVACY = - 0 category : number licence : number language : string description : string name : string tags : string [ ] nsfw : boolean commentsEnabled : boolean downloadEnabled : boolean waitTranscoding : boolean channelId : number privacy : VideoPrivacy support : string thumbnailfile ? : any previewfile ? : any thumbnailUrl : string previewUrl : string uuid ? : string id ? : number scheduleUpdate ? : VideoScheduleUpdate originallyPublishedAt ? : Date | string constructor ( video ? : Video & { tags : string [ ] , commentsEnabled : boolean , downloadEnabled : boolean , support : string , thumbnailUrl : string , previewUrl : string } ) { if ( video ) { this . id = video . id this . uuid = video . uuid this . category = video . category . id this . licence = video . licence . id this . language = video . language . id this . description = video . description this . name = video . name this . tags = video . tags this . nsfw = video . nsfw this . commentsEnabled = video . commentsEnabled this . downloadEnabled = video . downloadEnabled this . waitTranscoding = video . waitTranscoding this . channelId = video . channel . id this . privacy = video . privacy . id this . support = video . support this . thumbnailUrl = video . thumbnailUrl this . previewUrl = video . previewUrl this . scheduleUpdate = video . scheduledUpdate this . originallyPublishedAt = video . originallyPublishedAt ? new Date ( video . originallyPublishedAt ) : null } } patch ( values : { [ id ] : string } ) { Object . keys ( values ) . forEach ( ( key ) => { this [ key ] = values [ key ] } ) if ( parseInt ( values [ 's' ] , 0 ) === VideoEdit . SPECIAL_SCHEDULED_PRIVACY ) { const updateAt = new Date ( values [ 's' ] ) updateAt . setSeconds ( 0 ) this . privacy = VideoPrivacy . PRIVATE this . scheduleUpdate = { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } else { this . scheduleUpdate = null } if ( this . originallyPublishedAt ) { const originallyPublishedAt = new Date ( values [ 's' ] ) this . originallyPublishedAt = originallyPublishedAt . toISOString ( ) } if ( this . previewfile ) { this . thumbnailfile = this . previewfile } } toFormPatch ( ) { const json = { category : this . category , licence : this . licence , language : this . language , description : this . description , support : this . support , name : this . name , tags : this . tags , nsfw : this . nsfw , commentsEnabled : this . commentsEnabled , downloadEnabled : this . downloadEnabled , waitTranscoding : this . waitTranscoding , channelId : this . channelId , privacy : this . privacy , originallyPublishedAt : this . originallyPublishedAt } if ( this . scheduleUpdate ) { Object . assign ( json , { privacy : VideoEdit . SPECIAL_SCHEDULED_PRIVACY , schedulePublicationAt : new Date ( this . scheduleUpdate . updateAt . toString ( ) ) } ) } return json } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , switchMap } from 's' import { HttpClient , HttpParams , HttpRequest } from 's' import { Injectable } from 's' import { Observable } from 's' import { Video as VideoServerModel , VideoDetails as VideoDetailsServerModel } from 's' import { ResultList } from 's' import { UserVideoRate , UserVideoRateType , UserVideoRateUpdate , VideoConstant , VideoFilter , VideoPrivacy , VideoUpdate } from 's' import { FeedFormat } from 's' import { environment } from 's' import { ComponentPagination } from 's' import { RestExtractor } from 's' import { RestService } from 's' import { UserService } from 's' import { VideoSortField } from 's' import { VideoDetails } from 's' import { VideoEdit } from 's' import { Video } from 's' import { objectToFormData } from 's' import { Account } from 's' import { AccountService } from 's' import { VideoChannelService } from 's' import { ServerService } from 's' import { UserSubscriptionService } from 's' import { VideoChannel } from 's' import { 0 } from 's' export interface VideosProvider { getVideos ( parameters : { videoPagination : ComponentPagination , sort : VideoSortField , filter ? : VideoFilter , categoryOneOf ? : number , languageOneOf ? : string [ ] } ) : Observable < ResultList < Video > > } @ Injectable ( ) export class VideoService implements VideosProvider { static BASE_VIDEO_URL = environment . apiUrl + 's' static BASE_FEEDS_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService , private serverService , private 0 ) { } getVideoViewUrl ( uuid ) { return VideoService . BASE_VIDEO_URL + uuid + 's' } getUserWatchingVideoUrl ( uuid ) { return VideoService . BASE_VIDEO_URL + uuid + 's' } getVideo ( options : { videoId : string } ) < VideoDetails > { return this . serverService . localeObservable . pipe ( switchMap ( translations => { return this . authHttp . get < VideoDetailsServerModel > ( VideoService . BASE_VIDEO_URL + options . videoId ) . pipe ( map ( videoHash => ( { videoHash , translations } ) ) ) } ) , map ( ( { videoHash , translations } ) => new VideoDetails ( videoHash , translations ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateVideo ( video ) { const language = video . language || null const licence = video . licence || null const category = video . category || null const description = video . description || null const support = video . support || null const scheduleUpdate = video . scheduleUpdate || null const originallyPublishedAt = video . originallyPublishedAt || null const body = { name : video . name , category , licence , language , support , description , channelId : video . channelId , privacy : video . privacy , tags : video . tags , nsfw : video . nsfw , waitTranscoding : video . waitTranscoding , commentsEnabled : video . commentsEnabled , downloadEnabled : video . downloadEnabled , thumbnailfile : video . thumbnailfile , previewfile : video . previewfile , scheduleUpdate , originallyPublishedAt } const data = objectToFormData ( body ) return this . authHttp . put ( VideoService . BASE_VIDEO_URL + video . id , data ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } uploadVideo ( video ) { const req = new HttpRequest ( 's' , VideoService . BASE_VIDEO_URL + 's' , video , { reportProgress : true } ) return this . authHttp . request < { video : { id : number , uuid : string } } > ( req ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } getMyVideos ( videoPagination , sort ) < ResultList < Video > > { const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < Video > > ( UserService . BASE_USERS_URL + 's' , { params } ) . pipe ( switchMap ( res => this . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getAccountVideos ( account , videoPagination , sort ) < ResultList < Video > > { const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < Video > > ( AccountService . BASE_ACCOUNT_URL + account . nameWithHost + 's' , { params } ) . pipe ( switchMap ( res => this . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideoChannelVideos ( videoChannel , videoPagination , sort ) < ResultList < Video > > { const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < Video > > ( VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannel . nameWithHost + 's' , { params } ) . pipe ( switchMap ( res => this . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getUserSubscriptionVideos ( parameters : { videoPagination : ComponentPagination , sort : VideoSortField } ) < ResultList < Video > > { const { videoPagination , sort } = parameters const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < Video > > ( UserSubscriptionService . BASE_USER_SUBSCRIPTIONS_URL + 's' , { params } ) . pipe ( switchMap ( res => this . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideos ( parameters : { videoPagination : ComponentPagination , sort : VideoSortField , filter ? : VideoFilter , categoryOneOf ? : number , languageOneOf ? : string [ ] } ) < ResultList < Video > > { const { videoPagination , sort , filter , categoryOneOf , languageOneOf } = parameters const pagination = this . restService . componentPaginationToRestPagination ( videoPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) if ( filter ) { params = params . set ( 's' , filter ) } if ( categoryOneOf ) { params = params . set ( 's' , categoryOneOf + 's' ) } if ( languageOneOf ) { for ( const l of languageOneOf ) { params = params . append ( 's' , l ) } } return this . authHttp . get < ResultList < Video > > ( VideoService . BASE_VIDEO_URL , { params } ) . pipe ( switchMap ( res => this . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } buildBaseFeedUrls ( params ) { const feeds = [ { format : FeedFormat . RSS , label : 's' , url : VideoService . BASE_FEEDS_URL + FeedFormat . RSS . toLowerCase ( ) } , { format : FeedFormat . ATOM , label : 's' , url : VideoService . BASE_FEEDS_URL + FeedFormat . ATOM . toLowerCase ( ) } , { format : FeedFormat . JSON , label : 's' , url : VideoService . BASE_FEEDS_URL + FeedFormat . JSON . toLowerCase ( ) } ] if ( params && params . keys ( ) . length !== 0 ) { for ( const feed of feeds ) { feed . url += 's' + params . toString ( ) } } return feeds } getVideoFeedUrls ( sort , filter ? , categoryOneOf ? ) { let params = this . restService . addRestGetParams ( new HttpParams ( ) , undefined , sort ) if ( filter ) params = params . set ( 's' , filter ) if ( categoryOneOf ) params = params . set ( 's' , categoryOneOf + 's' ) return this . buildBaseFeedUrls ( params ) } getAccountFeedUrls ( accountId ) { let params = this . restService . addRestGetParams ( new HttpParams ( ) ) params = params . set ( 's' , accountId . toString ( ) ) return this . buildBaseFeedUrls ( params ) } getVideoChannelFeedUrls ( videoChannelId ) { let params = this . restService . addRestGetParams ( new HttpParams ( ) ) params = params . set ( 's' , videoChannelId . toString ( ) ) return this . buildBaseFeedUrls ( params ) } removeVideo ( id ) { return this . authHttp . delete ( VideoService . BASE_VIDEO_URL + id ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } loadCompleteDescription ( descriptionPath ) { return this . authHttp . get < { description : string } > ( environment . apiUrl + descriptionPath ) . pipe ( map ( res => res . description ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } setVideoLike ( id ) { return this . setVideoRate ( id , 's' ) } setVideoDislike ( id ) { return this . setVideoRate ( id , 's' ) } unsetVideoLike ( id ) { return this . setVideoRate ( id , 's' ) } getUserVideoRating ( id ) { const url = UserService . BASE_USERS_URL + 's' + id + 's' return this . authHttp . get < UserVideoRate > ( url ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } extractVideos ( result < VideoServerModel > ) { return this . serverService . localeObservable . pipe ( map ( translations => { const videosJson = result . data const totalVideos = result . total const videos : Video [ ] = [ ] for ( const videoJson of videosJson ) { videos . push ( new Video ( videoJson , translations ) ) } return { total : totalVideos , data : videos } } ) ) } explainedPrivacyLabels ( privacies : VideoConstant < VideoPrivacy > [ ] ) { const newPrivacies = privacies . slice ( ) const privatePrivacy = newPrivacies . find ( p => p . id === VideoPrivacy . PRIVATE ) if ( privatePrivacy ) privatePrivacy . label = this . 0 ( 's' ) const unlistedPrivacy = newPrivacies . find ( p => p . id === VideoPrivacy . UNLISTED ) if ( unlistedPrivacy ) unlistedPrivacy . label = this . 0 ( 's' ) const publicPrivacy = newPrivacies . find ( p => p . id === VideoPrivacy . PUBLIC ) if ( publicPrivacy ) publicPrivacy . label = this . 0 ( 's' ) return privacies } private setVideoRate ( id , rateType ) { const url = VideoService . BASE_VIDEO_URL + id + 's' const body = { rating : rateType } return this . authHttp . put ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $ServerService$ O O $I18n$ O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoEdit$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $ComponentPagination$ O $VideoSortField$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $Account$ O $ComponentPagination$ O $VideoSortField$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $VideoChannel$ O $ComponentPagination$ O $VideoSortField$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoSortField$ O O $VideoFilter$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $UserVideoRateType$ O O O O O O O O O O O O O $UserVideoRateUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CommonModule } from 's' import { HttpClientModule } from 's' import { NgModule } from 's' import { FormsModule , ReactiveFormsModule } from 's' import { RouterModule } from 's' import { MarkdownTextareaComponent } from 's' import { HelpComponent } from 's' import { InfiniteScrollerDirective } from 's' import { BytesPipe , KeysPipe , NgPipesModule } from 's' import { SharedModule as PrimeSharedModule } from 's' import { AUTH_INTERCEPTOR_PROVIDER } from 's' import { ButtonComponent } from 's' import { DeleteButtonComponent } from 's' import { EditButtonComponent } from 's' import { LoaderComponent } from 's' import { RestExtractor , RestService } from 's' import { UserService } from 's' import { VideoAbuseService } from 's' import { VideoBlacklistService } from 's' import { VideoOwnershipService } from 's' import { VideoMiniatureComponent } from 's' import { FeedComponent } from 's' import { VideoThumbnailComponent } from 's' import { VideoService } from 's' import { AccountService } from 's' import { VideoChannelService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { CustomConfigValidatorsService , InstanceValidatorsService , LoginValidatorsService , ReactiveFileComponent , ResetPasswordValidatorsService , TextareaAutoResizeDirective , UserValidatorsService , VideoAbuseValidatorsService , VideoAcceptOwnershipValidatorsService , VideoBlacklistValidatorsService , VideoChangeOwnershipValidatorsService , VideoChannelValidatorsService , VideoCommentValidatorsService , VideoPlaylistValidatorsService , VideoValidatorsService } from 's' import { 0 } from 's' import { InputMaskModule } from 's' import { ScreenService } from 's' import { VideoCaptionsValidatorsService } from 's' import { VideoCaptionService } from 's' import { PeertubeCheckboxComponent } from 's' import { VideoImportService } from 's' import { ActionDropdownComponent } from 's' import { NgbCollapseModule , NgbDropdownModule , NgbModalModule , NgbPopoverModule , NgbTabsetModule , NgbTooltipModule } from 's' import { RemoteSubscribeComponent , SubscribeButtonComponent , UserSubscriptionService } from 's' import { InstanceFeaturesTableComponent } from 's' import { OverviewService } from 's' import { UserBanModalComponent } from 's' import { UserModerationDropdownComponent } from 's' import { BlocklistService } from 's' import { TopMenuDropdownComponent } from 's' import { UserHistoryService } from 's' import { UserNotificationService } from 's' import { UserNotificationsComponent } from 's' import { InstanceService } from 's' import { HtmlRendererService , LinkifierService , MarkdownService } from 's' import { ConfirmComponent } from 's' import { SmallLoaderComponent } from 's' import { VideoPlaylistService } from 's' import { PreviewUploadComponent } from 's' import { GlobalIconComponent } from 's' import { VideoPlaylistMiniatureComponent } from 's' import { VideoAddToPlaylistComponent } from 's' import { TimestampInputComponent } from 's' import { VideoPlaylistElementMiniatureComponent } from 's' import { VideosSelectionComponent } from 's' import { NumberFormatterPipe } from 's' import { ObjectLengthPipe } from 's' import { FromNowPipe } from 's' import { PeerTubeTemplateDirective } from 's' import { VideoActionsDropdownComponent } from 's' import { VideoBlacklistComponent } from 's' import { VideoDownloadComponent } from 's' import { VideoReportComponent } from 's' import { ClipboardModule } from 's' import { FollowService } from 's' import { MultiSelectModule } from 's' import { FeatureBooleanComponent } from 's' @ NgModule ( { imports : [ CommonModule , FormsModule , ReactiveFormsModule , RouterModule , HttpClientModule , NgbDropdownModule , NgbModalModule , NgbPopoverModule , NgbTabsetModule , NgbTooltipModule , NgbCollapseModule , ClipboardModule , PrimeSharedModule , InputMaskModule , NgPipesModule , MultiSelectModule ] , declarations : [ LoaderComponent , SmallLoaderComponent , VideoThumbnailComponent , VideoMiniatureComponent , VideoPlaylistMiniatureComponent , VideoAddToPlaylistComponent , VideoPlaylistElementMiniatureComponent , VideosSelectionComponent , VideoActionsDropdownComponent , VideoDownloadComponent , VideoReportComponent , VideoBlacklistComponent , FeedComponent , ButtonComponent , DeleteButtonComponent , EditButtonComponent , NumberFormatterPipe , ObjectLengthPipe , FromNowPipe , PeerTubeTemplateDirective , ActionDropdownComponent , MarkdownTextareaComponent , InfiniteScrollerDirective , TextareaAutoResizeDirective , HelpComponent , ReactiveFileComponent , PeertubeCheckboxComponent , TimestampInputComponent , SubscribeButtonComponent , RemoteSubscribeComponent , InstanceFeaturesTableComponent , FeatureBooleanComponent , UserBanModalComponent , UserModerationDropdownComponent , TopMenuDropdownComponent , UserNotificationsComponent , ConfirmComponent , GlobalIconComponent , PreviewUploadComponent ] , exports : [ CommonModule , FormsModule , ReactiveFormsModule , RouterModule , HttpClientModule , NgbDropdownModule , NgbModalModule , NgbPopoverModule , NgbTabsetModule , NgbTooltipModule , NgbCollapseModule , ClipboardModule , PrimeSharedModule , InputMaskModule , BytesPipe , KeysPipe , MultiSelectModule , LoaderComponent , SmallLoaderComponent , VideoThumbnailComponent , VideoMiniatureComponent , VideoPlaylistMiniatureComponent , VideoAddToPlaylistComponent , VideoPlaylistElementMiniatureComponent , VideosSelectionComponent , VideoActionsDropdownComponent , VideoDownloadComponent , VideoReportComponent , VideoBlacklistComponent , FeedComponent , ButtonComponent , DeleteButtonComponent , EditButtonComponent , ActionDropdownComponent , MarkdownTextareaComponent , InfiniteScrollerDirective , TextareaAutoResizeDirective , HelpComponent , ReactiveFileComponent , PeertubeCheckboxComponent , TimestampInputComponent , SubscribeButtonComponent , RemoteSubscribeComponent , InstanceFeaturesTableComponent , UserBanModalComponent , UserModerationDropdownComponent , TopMenuDropdownComponent , UserNotificationsComponent , ConfirmComponent , GlobalIconComponent , PreviewUploadComponent , NumberFormatterPipe , ObjectLengthPipe , FromNowPipe , PeerTubeTemplateDirective ] , providers : [ AUTH_INTERCEPTOR_PROVIDER , RestExtractor , RestService , VideoAbuseService , VideoBlacklistService , VideoOwnershipService , UserService , VideoService , AccountService , VideoChannelService , VideoPlaylistService , VideoCaptionService , VideoImportService , UserSubscriptionService , FormValidatorService , CustomConfigValidatorsService , LoginValidatorsService , ResetPasswordValidatorsService , UserValidatorsService , VideoPlaylistValidatorsService , VideoAbuseValidatorsService , VideoChannelValidatorsService , VideoCommentValidatorsService , VideoValidatorsService , VideoCaptionsValidatorsService , VideoBlacklistValidatorsService , OverviewService , VideoChangeOwnershipValidatorsService , VideoAcceptOwnershipValidatorsService , InstanceValidatorsService , BlocklistService , UserHistoryService , InstanceService , MarkdownService , LinkifierService , HtmlRendererService , 0 , ScreenService , UserNotificationService , FollowService , 0 ] } ) export class SharedModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { AboutRoutingModule } from 's' import { AboutComponent } from 's' import { SharedModule } from 's' import { AboutInstanceComponent } from 's' import { AboutPeertubeComponent } from 's' import { ContactAdminModalComponent } from 's' import { AboutFollowsComponent } from 's' import { AboutPeertubeContributorsComponent } from 's' @ NgModule ( { imports : [ AboutRoutingModule , SharedModule ] , declarations : [ AboutComponent , AboutInstanceComponent , AboutPeertubeComponent , AboutFollowsComponent , AboutPeertubeContributorsComponent , ContactAdminModalComponent ] , exports : [ AboutComponent ] , providers : [ ] } ) export class AboutModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { Account } from 's' import { AccountService } from 's' import { 0 } from 's' import { Subscription } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AccountAboutComponent implements OnInit , OnDestroy { account : Account descriptionHTML = 's' private accountSub : Subscription constructor ( private 0 , private accountService , private markdownService ) { } ngOnInit ( ) { this . accountSub = this . accountService . accountLoaded . subscribe ( async account => { this . account = account this . descriptionHTML = await this . markdownService . textMarkdownToHTML ( this . account . description ) } ) } ngOnDestroy ( ) { if ( this . accountSub ) this . accountSub . unsubscribe ( ) } getAccountDescription ( ) { if ( this . descriptionHTML ) return this . descriptionHTML return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $AccountService$ O O $MarkdownService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute } from 's' import { Account } from 's' import { AccountService } from 's' import { VideoChannelService } from 's' import { concatMap , map , switchMap , tap } from 's' import { from , Subject , Subscription } from 's' import { VideoChannel } from 's' import { Video } from 's' import { AuthService } from 's' import { VideoService } from 's' import { VideoSortField } from 's' import { ComponentPagination , hasMoreItems } from 's' import { ScreenService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AccountVideoChannelsComponent implements OnInit , OnDestroy { account : Account videoChannels : VideoChannel [ ] = [ ] videos : { [ id ] : Video [ ] } = { } channelPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 } videosPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 } videosSort : VideoSortField = 's' onChannelDataSubject = new Subject < any > ( ) private accountSub : Subscription constructor ( private route , private authService , private accountService , private videoChannelService , private videoService , private screenService ) { } get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . accountSub = this . accountService . accountLoaded . subscribe ( account => { this . account = account this . loadMoreChannels ( ) } ) } ngOnDestroy ( ) { if ( this . accountSub ) this . accountSub . unsubscribe ( ) } loadMoreChannels ( ) { this . videoChannelService . listAccountVideoChannels ( this . account , this . channelPagination ) . pipe ( tap ( res => this . channelPagination . totalItems = res . total ) , switchMap ( res => from ( res . data ) ) , concatMap ( videoChannel => { return this . videoService . getVideoChannelVideos ( videoChannel , this . videosPagination , this . videosSort ) . pipe ( map ( data => ( { videoChannel , videos : data . data } ) ) ) } ) ) . subscribe ( ( { videoChannel , videos } ) => { this . videoChannels . push ( videoChannel ) this . videos [ videoChannel . id ] = videos this . onChannelDataSubject . next ( [ videoChannel ] ) } ) } getVideosOf ( videoChannel ) { const numberOfVideos = this . screenService . getNumberOfAvailableMiniatures ( ) return this . videos [ videoChannel . id ] . slice ( 0 , numberOfVideos * 0 ) } onNearOfBottom ( ) { if ( ! hasMoreItems ( this . channelPagination ) ) return this . channelPagination . currentPage += 0 this . loadMoreChannels ( ) } getVideoChannelLink ( videoChannel ) { return [ 's' , videoChannel . nameWithHost ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $AuthService$ O O $AccountService$ O O $VideoChannelService$ O O $VideoService$ O O $ScreenService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O
import { debounceTime , first , tap } from 's' import { OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { fromEvent , Observable , of , Subject , Subscription } from 's' import { AuthService } from 's' import { ComponentPagination } from 's' import { VideoSortField } from 's' import { Video } from 's' import { ScreenService } from 's' import { MiniatureDisplayOptions , OwnerDisplayType } from 's' import { Syndication } from 's' import { Notifier , ServerService } from 's' import { DisableForReuseHook } from 's' import { 0 } from 's' import { isLastMonth , isLastWeek , isToday , isYesterday } from 's' import { ResultList } from 's' enum GroupDate { UNKNOWN = 0 , TODAY = 0 , YESTERDAY = 0 , LAST_WEEK = 0 , LAST_MONTH = 0 , OLDER = 0 } export abstract class AbstractVideoList implements OnInit , OnDestroy , DisableForReuseHook { pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } sort : VideoSortField = 's' categoryOneOf ? : number languageOneOf ? : string [ ] defaultSort : VideoSortField = 's' syndicationItems : Syndication [ ] = [ ] loadOnInit = true useUserVideoLanguagePreferences = false ownerDisplayType : OwnerDisplayType = 's' displayModerationBlock = false titleTooltip : string displayVideoActions = true groupByDate = false videos : Video [ ] = [ ] disabled = false displayOptions : MiniatureDisplayOptions = { date : true , views : true , by : true , privacyLabel : true , privacyText : false , state : false , blacklistInfo : false } onDataSubject = new Subject < any [ ] > ( ) protected abstract notifier : Notifier protected abstract authService : AuthService protected abstract route : ActivatedRoute protected abstract serverService : ServerService protected abstract screenService : ScreenService protected abstract router : Router protected abstract 0 : 0 abstract titlePage : string private resizeSubscription : Subscription private angularState : number private groupedDateLabels : { [ id in GroupDate ] : string } private groupedDates : { [ id ] : GroupDate } = { } abstract getVideosObservable ( page ) < ResultList < Video > > abstract generateSyndicationList ( ) get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . groupedDateLabels = { [ GroupDate . UNKNOWN ] : null , [ GroupDate . TODAY ] : this . 0 ( 's' ) , [ GroupDate . YESTERDAY ] : this . 0 ( 's' ) , [ GroupDate . LAST_WEEK ] : this . 0 ( 's' ) , [ GroupDate . LAST_MONTH ] : this . 0 ( 's' ) , [ GroupDate . OLDER ] : this . 0 ( 's' ) } const routeParams = this . route . snapshot . queryParams this . loadRouteParams ( routeParams ) this . resizeSubscription = fromEvent ( window , 's' ) . pipe ( debounceTime ( 0 ) ) . subscribe ( ( ) => this . calcPageSizes ( ) ) this . calcPageSizes ( ) const loadUserObservable = this . loadUserVideoLanguagesIfNeeded ( ) if ( this . loadOnInit === true ) { loadUserObservable . subscribe ( ( ) => this . loadMoreVideos ( ) ) } } ngOnDestroy ( ) { if ( this . resizeSubscription ) this . resizeSubscription . unsubscribe ( ) } disableForReuse ( ) { this . disabled = true } enabledForReuse ( ) { this . disabled = false } videoById ( index , video ) { return video . id } onNearOfBottom ( ) { if ( this . disabled ) return if ( this . pagination . totalItems <= ( this . pagination . currentPage * this . pagination . itemsPerPage ) ) return this . pagination . currentPage += 0 this . setScrollRouteParams ( ) this . loadMoreVideos ( ) } loadMoreVideos ( ) { this . getVideosObservable ( this . pagination . currentPage ) . subscribe ( ( { data , total } ) => { this . pagination . totalItems = total this . videos = this . videos . concat ( data ) if ( this . groupByDate ) this . buildGroupedDateLabels ( ) this . onMoreVideos ( ) this . onDataSubject . next ( data ) } , error => this . notifier . error ( error . message ) ) } reloadVideos ( ) { this . pagination . currentPage = 0 this . videos = [ ] this . loadMoreVideos ( ) } toggleModerationDisplay ( ) { throw new Error ( 's' ) } removeVideoFromArray ( video ) { this . videos = this . videos . filter ( v => v . id !== video . id ) } buildGroupedDateLabels ( ) { let currentGroupedDate = GroupDate . UNKNOWN for ( const video of this . videos ) { const publishedDate = video . publishedAt if ( currentGroupedDate <= GroupDate . TODAY && isToday ( publishedDate ) ) { if ( currentGroupedDate === GroupDate . TODAY ) continue currentGroupedDate = GroupDate . TODAY this . groupedDates [ video . id ] = currentGroupedDate continue } if ( currentGroupedDate <= GroupDate . YESTERDAY && isYesterday ( publishedDate ) ) { if ( currentGroupedDate === GroupDate . YESTERDAY ) continue currentGroupedDate = GroupDate . YESTERDAY this . groupedDates [ video . id ] = currentGroupedDate continue } if ( currentGroupedDate <= GroupDate . LAST_WEEK && isLastWeek ( publishedDate ) ) { if ( currentGroupedDate === GroupDate . LAST_WEEK ) continue currentGroupedDate = GroupDate . LAST_WEEK this . groupedDates [ video . id ] = currentGroupedDate continue } if ( currentGroupedDate <= GroupDate . LAST_MONTH && isLastMonth ( publishedDate ) ) { if ( currentGroupedDate === GroupDate . LAST_MONTH ) continue currentGroupedDate = GroupDate . LAST_MONTH this . groupedDates [ video . id ] = currentGroupedDate continue } if ( currentGroupedDate <= GroupDate . OLDER ) { if ( currentGroupedDate === GroupDate . OLDER ) continue currentGroupedDate = GroupDate . OLDER this . groupedDates [ video . id ] = currentGroupedDate } } } getCurrentGroupedDateLabel ( video ) { if ( this . groupByDate === false ) return undefined return this . groupedDateLabels [ this . groupedDates [ video . id ] ] } protected onMoreVideos ( ) { } protected loadRouteParams ( routeParams : { [ key ] : any } ) { this . sort = routeParams [ 's' ] as VideoSortField || this . defaultSort this . categoryOneOf = routeParams [ 's' ] this . angularState = routeParams [ 's' ] } private calcPageSizes ( ) { if ( this . screenService . isInMobileView ( ) ) { this . pagination . itemsPerPage = 0 } } private setScrollRouteParams ( ) { if ( this . angularState ) return this . angularState = 0 const queryParams = { 's' : this . angularState , categoryOneOf : this . categoryOneOf } let path = this . router . url if ( ! path || path === 's' ) path = this . serverService . getConfig ( ) . instance . defaultClientRoute this . router . navigate ( [ path ] , { queryParams , replaceUrl : true , queryParamsHandling : 's' } ) } private loadUserVideoLanguagesIfNeeded ( ) { if ( ! this . authService . isLoggedIn ( ) || ! this . useUserVideoLanguagePreferences ) { return of ( true ) } return this . authService . userInformationLoaded . pipe ( first ( ) , tap ( ( ) => this . languageOneOf = this . user . videoLanguages ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O $Observable$ O $number$ O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GroupDate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { AbstractVideoList } from 's' import { VideoService } from 's' import { Account } from 's' import { AccountService } from 's' import { first , tap } from 's' import { 0 } from 's' import { Subscription } from 's' import { ScreenService } from 's' import { Notifier , ServerService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' ] } ) export class AccountVideosComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string loadOnInit = false private account : Account private accountSub : Subscription constructor ( protected 0 , protected router , protected serverService , protected route , protected authService , protected notifier , protected confirmService , protected screenService , private accountService , private videoService ) { super ( ) } ngOnInit ( ) { super . ngOnInit ( ) this . accountSub = this . accountService . accountLoaded . pipe ( first ( ) ) . subscribe ( account => { this . account = account this . reloadVideos ( ) this . generateSyndicationList ( ) } ) } ngOnDestroy ( ) { if ( this . accountSub ) this . accountSub . unsubscribe ( ) super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) return this . videoService . getAccountVideos ( this . account , newPagination , this . sort ) . pipe ( tap ( ( { total } ) => { this . titlePage = this . 0 ( 's' , { total } ) } ) ) } generateSyndicationList ( ) { this . syndicationItems = this . videoService . getAccountFeedUrls ( this . account . id ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $ScreenService$ O O $AccountService$ O O $VideoService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute } from 's' import { AccountService } from 's' import { Account } from 's' import { RestExtractor , UserService } from 's' import { catchError , distinctUntilChanged , map , switchMap , tap } from 's' import { Subscription } from 's' import { AuthService , Notifier , RedirectService } from 's' import { User , UserRight } from 's' import { 0 } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class AccountsComponent implements OnInit , OnDestroy { account : Account user : User private routeSub : Subscription constructor ( private route , private userService , private accountService , private notifier , private restExtractor , private redirectService , private authService , private 0 ) { } ngOnInit ( ) { this . routeSub = this . route . params . pipe ( map ( params => params [ 's' ] ) , distinctUntilChanged ( ) , switchMap ( accountId => this . accountService . getAccount ( accountId ) ) , tap ( account => this . getUserIfNeeded ( account ) ) , catchError ( err => this . restExtractor . 0 ( err , [ 0 , 0 ] ) ) ) . subscribe ( account => this . account = account , err => this . notifier . error ( err . message ) ) } ngOnDestroy ( ) { if ( this . routeSub ) this . routeSub . unsubscribe ( ) } onUserChanged ( ) { this . getUserIfNeeded ( this . account ) } onUserDeleted ( ) { this . redirectService . redirectToHomepage ( ) } activateCopiedMessage ( ) { this . notifier . success ( this . 0 ( 's' ) ) } private getUserIfNeeded ( account ) { if ( ! account . userId ) return if ( ! this . authService . isLoggedIn ( ) ) return const user = this . authService . getUser ( ) if ( user . hasRight ( UserRight . MANAGE_USERS ) ) { this . userService . getUser ( account . userId ) . subscribe ( user => this . user = user , err => this . notifier . error ( err . message ) ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRoute$ O O $UserService$ O O $AccountService$ O O $Notifier$ O O $RestExtractor$ O O $RedirectService$ O O $AuthService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { AccountsComponent } from 's' import { AccountVideosComponent } from 's' import { AccountAboutComponent } from 's' import { AccountVideoChannelsComponent } from 's' const accountsRoutes = [ { path : 's' , redirectTo : 's' } , { path : 's' , component : AccountsComponent , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : AccountVideosComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : AccountVideoChannelsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : AccountAboutComponent , data : { meta : { title : 's' } } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( accountsRoutes ) ] , exports : [ RouterModule ] } ) export class AccountsRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { AccountsRoutingModule } from 's' import { AccountsComponent } from 's' import { AccountVideosComponent } from 's' import { AccountAboutComponent } from 's' import { AccountVideoChannelsComponent } from 's' @ NgModule ( { imports : [ AccountsRoutingModule , SharedModule ] , declarations : [ AccountsComponent , AccountVideosComponent , AccountVideoChannelsComponent , AccountAboutComponent ] , exports : [ AccountsComponent ] , providers : [ ] } ) export class AccountsModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component } from 's' import { UserRight } from 's' import { AuthService } from 's' @ Component ( { templateUrl : 's' } ) export class AdminComponent { constructor ( private auth ) { } hasUsersRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_USERS ) } hasServerFollowRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_SERVER_FOLLOW ) } hasVideoAbusesRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_VIDEO_ABUSES ) } hasVideoBlacklistRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) } hasConfigRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_CONFIGURATION ) } hasPluginsRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_PLUGINS ) } hasLogsRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_LOGS ) } hasJobsRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_JOBS ) } hasDebugRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_DEBUG ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { Router } from 's' import { Notifier } from 's' import { ConfirmService } from 's' import { validateHost } from 's' import { FollowService } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FollowingAddComponent { hostsString = 's' hostsError : string = null error : string = null constructor ( private router , private notifier , private confirmService , private followService , private 0 ) { } httpEnabled ( ) { return window . location . protocol === 's' } onHostsChanged ( ) { this . hostsError = null const newHostsErrors = [ ] const hosts = this . getNotEmptyHosts ( ) for ( const host of hosts ) { if ( validateHost ( host ) === false ) { newHostsErrors . push ( this . 0 ( 's' , { host } ) ) } } if ( newHostsErrors . length !== 0 ) { this . hostsError = newHostsErrors . join ( 's' ) } } async addFollowing ( ) { this . error = 's' const hosts = this . getNotEmptyHosts ( ) if ( hosts . length === 0 ) { this . error = this . 0 ( 's' ) } if ( ! this . isHostsUnique ( hosts ) ) { this . error = this . 0 ( 's' ) return } const confirmMessage = this . 0 ( 's' ) + hosts . join ( 's' ) const res = await this . confirmService . confirm ( confirmMessage , this . 0 ( 's' ) ) if ( res === false ) return this . followService . follow ( hosts ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) setTimeout ( ( ) => this . router . navigate ( [ 's' ] ) , 0 ) } , err => this . notifier . error ( err . message ) ) } private isHostsUnique ( hosts : string [ ] ) { return hosts . every ( host => hosts . indexOf ( host ) === hosts . lastIndexOf ( host ) ) } private getNotEmptyHosts ( ) { return this . hostsString . split ( 's' ) . filter ( host => host && host . length !== 0 ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $Notifier$ O O $ConfirmService$ O O $FollowService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , OnInit } from 's' import { ConfirmService , Notifier } from 's' import { SortMeta } from 's' import { ActorFollow } from 's' import { RestPagination , RestTable } from 's' import { FollowService } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FollowersListComponent extends RestTable implements OnInit { followers : ActorFollow [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private confirmService , private notifier , private 0 , private followService ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } acceptFollower ( follow ) { follow . state = 's' this . followService . acceptFollower ( follow ) . subscribe ( ( ) => { const handle = follow . follower . name + 's' + follow . follower . host this . notifier . success ( this . 0 ( 's' , { handle } ) ) } , err => { follow . state = 's' this . notifier . error ( err . message ) } ) } async rejectFollower ( follow ) { const message = this . 0 ( 's' ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . followService . rejectFollower ( follow ) . subscribe ( ( ) => { const handle = follow . follower . name + 's' + follow . follower . host this . notifier . success ( this . 0 ( 's' , { handle } ) ) this . loadData ( ) } , err => { follow . state = 's' this . notifier . error ( err . message ) } ) } async deleteFollower ( follow ) { const message = this . 0 ( 's' ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . followService . removeFollower ( follow ) . subscribe ( ( ) => { const handle = follow . follower . name + 's' + follow . follower . host this . notifier . success ( this . 0 ( 's' , { handle } ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } protected loadData ( ) { this . followService . getFollowers ( this . pagination , this . sort , this . search ) . subscribe ( resultList => { this . followers = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfirmService$ O O $Notifier$ O O $I18n$ O O $FollowService$ O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { SortMeta } from 's' import { ActorFollow } from 's' import { ConfirmService } from 's' import { RestPagination , RestTable } from 's' import { FollowService } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FollowingListComponent extends RestTable implements OnInit { following : ActorFollow [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private confirmService , private followService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } async removeFollowing ( follow ) { const res = await this . confirmService . confirm ( this . 0 ( 's' , { host : follow . following . host } ) , this . 0 ( 's' ) ) if ( res === false ) return this . followService . unfollow ( follow ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host : follow . following . host } ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } protected loadData ( ) { this . followService . getFollowing ( this . pagination , this . sort , this . search ) . subscribe ( resultList => { this . following = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $ConfirmService$ O O $FollowService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class FollowsComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { UserRightGuard } from 's' import { FollowsComponent } from 's' import { FollowingAddComponent } from 's' import { FollowersListComponent } from 's' import { UserRight } from 's' import { FollowingListComponent } from 's' export const FollowsRoutes = [ { path : 's' , component : FollowsComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_SERVER_FOLLOW } , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : FollowingListComponent , data : { meta : { title : 's' } } } , { path : 's' , component : FollowersListComponent , data : { meta : { title : 's' } } } , { path : 's' , component : FollowingAddComponent , data : { meta : { title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O
import { AuthService , ServerService } from 's' import { FormReactive } from 's' import { USER_ROLE_LABELS , UserRole , VideoResolution } from 's' import { ConfigService } from 's' import { UserAdminFlag } from 's' export abstract class UserEdit extends FormReactive { videoQuotaOptions : { value : string , label : string } [ ] = [ ] videoQuotaDailyOptions : { value : string , label : string } [ ] = [ ] username : string userId : number protected abstract serverService : ServerService protected abstract configService : ConfigService protected abstract auth : AuthService abstract isCreation ( ) abstract getFormButtonTitle ( ) getRoles ( ) { const authUser = this . auth . getUser ( ) if ( authUser . role === UserRole . ADMINISTRATOR ) { return Object . keys ( USER_ROLE_LABELS ) . map ( key => ( { value : key . toString ( ) , label : USER_ROLE_LABELS [ key ] } ) ) } return [ { value : UserRole . USER . toString ( ) , label : USER_ROLE_LABELS [ UserRole . USER ] } ] } isTranscodingInformationDisplayed ( ) { const formVideoQuota = parseInt ( this . form . value [ 's' ] , 0 ) return this . serverService . getConfig ( ) . transcoding . enabledResolutions . length !== 0 && formVideoQuota > 0 } computeQuotaWithTranscoding ( ) { const transcodingConfig = this . serverService . getConfig ( ) . transcoding const resolutions = transcodingConfig . enabledResolutions const higherResolution = VideoResolution . 0 let multiplier = 0 for ( const resolution of resolutions ) { multiplier += resolution / higherResolution } if ( transcodingConfig . hls . enabled ) multiplier *= 0 return multiplier * parseInt ( this . form . value [ 's' ] , 0 ) } resetPassword ( ) { return } protected buildAdminFlags ( formValue ) { return formValue . byPassAutoBlacklist ? UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST : UserAdminFlag . NONE } protected buildQuotaOptions ( ) { this . videoQuotaOptions = this . configService . videoQuotaOptions . map ( q => ( { value : q . value . toString ( ) , label : q . label } ) ) this . videoQuotaDailyOptions = this . configService . videoQuotaDailyOptions . map ( q => ( { value : q . value . toString ( ) , label : q . label } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Router } from 's' import { AuthService , Notifier , ServerService } from 's' import { UserCreate , UserRole } from 's' import { UserEdit } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' import { ConfigService } from 's' import { UserService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserCreateComponent extends UserEdit implements OnInit { error : string constructor ( protected serverService , protected formValidatorService , protected configService , protected auth , private userValidatorsService , private router , private notifier , private userService , private 0 ) { super ( ) this . buildQuotaOptions ( ) } ngOnInit ( ) { const defaultValues = { role : UserRole . USER . toString ( ) , videoQuota : 's' , videoQuotaDaily : 's' } this . buildForm ( { username : this . userValidatorsService . USER_USERNAME , email : this . userValidatorsService . USER_EMAIL , password : this . userValidatorsService . USER_PASSWORD , role : this . userValidatorsService . USER_ROLE , videoQuota : this . userValidatorsService . USER_VIDEO_QUOTA , videoQuotaDaily : this . userValidatorsService . USER_VIDEO_QUOTA_DAILY , byPassAutoBlacklist : null } , defaultValues ) } formValidated ( ) { this . error = undefined const userCreate = this . form . value userCreate . adminFlags = this . buildAdminFlags ( this . form . value ) userCreate . videoQuota = parseInt ( this . form . value [ 's' ] , 0 ) userCreate . videoQuotaDaily = parseInt ( this . form . value [ 's' ] , 0 ) this . userService . addUser ( userCreate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : userCreate . username } ) ) this . router . navigate ( [ 's' ] ) } , err => this . error = err . message ) } isCreation ( ) { return true } getFormButtonTitle ( ) { return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O $FormValidatorService$ O O $ConfigService$ O O $AuthService$ O O $UserValidatorsService$ O O $Router$ O O $Notifier$ O O $UserService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { Subscription } from 's' import { AuthService , Notifier } from 's' import { ServerService } from 's' import { UserEdit } from 's' import { User , UserUpdate } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' import { ConfigService } from 's' import { UserService } from 's' import { UserAdminFlag } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserUpdateComponent extends UserEdit implements OnInit , OnDestroy { error : string userId : number userEmail : string username : string private paramsSub : Subscription constructor ( protected formValidatorService , protected serverService , protected configService , protected auth , private userValidatorsService , private route , private router , private notifier , private userService , private 0 ) { super ( ) this . buildQuotaOptions ( ) } ngOnInit ( ) { const defaultValues = { videoQuota : 's' , videoQuotaDaily : 's' } this . buildForm ( { email : this . userValidatorsService . USER_EMAIL , role : this . userValidatorsService . USER_ROLE , videoQuota : this . userValidatorsService . USER_VIDEO_QUOTA , videoQuotaDaily : this . userValidatorsService . USER_VIDEO_QUOTA_DAILY , byPassAutoBlacklist : null } , defaultValues ) this . paramsSub = this . route . params . subscribe ( routeParams => { const userId = routeParams [ 's' ] this . userService . getUser ( userId ) . subscribe ( user => this . onUserFetched ( user ) , err => this . error = err . message ) } ) } ngOnDestroy ( ) { this . paramsSub . unsubscribe ( ) } formValidated ( ) { this . error = undefined const userUpdate = this . form . value userUpdate . adminFlags = this . buildAdminFlags ( this . form . value ) userUpdate . videoQuota = parseInt ( this . form . value [ 's' ] , 0 ) userUpdate . videoQuotaDaily = parseInt ( this . form . value [ 's' ] , 0 ) this . userService . updateUser ( this . userId , userUpdate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : this . username } ) ) this . router . navigate ( [ 's' ] ) } , err => this . error = err . message ) } isCreation ( ) { return false } getFormButtonTitle ( ) { return this . 0 ( 's' ) } resetPassword ( ) { this . userService . askResetPassword ( this . userEmail ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : this . username } ) ) } , err => this . error = err . message ) } private onUserFetched ( userJson ) { this . userId = userJson . id this . username = userJson . username this . userEmail = userJson . email this . form . patchValue ( { email : userJson . email , role : userJson . role , videoQuota : userJson . videoQuota , videoQuotaDaily : userJson . videoQuotaDaily , byPassAutoBlacklist : userJson . adminFlags & UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $ServerService$ O O $ConfigService$ O O $AuthService$ O O $UserValidatorsService$ O O $ActivatedRoute$ O O $Router$ O O $Notifier$ O O $UserService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { UserService } from 's' import { Notifier } from 's' import { User , UserUpdate } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' import { FormReactive } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserPasswordComponent extends FormReactive implements OnInit { error : string username : string showPassword = false @ Input ( ) userId : number constructor ( protected formValidatorService , private userValidatorsService , private route , private router , private notifier , private userService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { password : this . userValidatorsService . USER_PASSWORD } ) } formValidated ( ) { this . error = undefined const userUpdate = this . form . value this . userService . updateUser ( this . userId , userUpdate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : this . username } ) ) } , err => this . error = err . message ) } togglePasswordVisibility ( ) { this . showPassword = ! this . showPassword } getFormButtonTitle ( ) { return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O $ActivatedRoute$ O O $Router$ O O $Notifier$ O O $UserService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { AuthService , Notifier } from 's' import { SortMeta } from 's' import { ConfirmService , ServerService } from 's' import { RestPagination , RestTable , UserService } from 's' import { 0 } from 's' import { User } from 's' import { UserBanModalComponent } from 's' import { DropdownAction } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserListComponent extends RestTable implements OnInit { @ ViewChild ( 's' , { static : true } ) userBanModal : UserBanModalComponent users : User [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } selectedUsers : User [ ] = [ ] bulkUserActions : DropdownAction < User [ ] > [ ] = [ ] constructor ( private notifier , private confirmService , private serverService , private userService , private auth , private 0 ) { super ( ) } get authUser ( ) { return this . auth . getUser ( ) } get requiresEmailVerification ( ) { return this . serverService . getConfig ( ) . signup . requiresEmailVerification } ngOnInit ( ) { this . initialize ( ) this . bulkUserActions = [ { label : this . 0 ( 's' ) , handler => this . removeUsers ( users ) , isDisplayed => users . every ( u => this . authUser . canManage ( u ) ) } , { label : this . 0 ( 's' ) , handler => this . openBanUserModal ( users ) , isDisplayed => users . every ( u => this . authUser . canManage ( u ) && u . blocked === false ) } , { label : this . 0 ( 's' ) , handler => this . unbanUsers ( users ) , isDisplayed => users . every ( u => this . authUser . canManage ( u ) && u . blocked === true ) } , { label : this . 0 ( 's' ) , handler => this . setEmailsAsVerified ( users ) , isDisplayed => { return this . requiresEmailVerification && users . every ( u => this . authUser . canManage ( u ) && ! u . blocked && u . emailVerified === false ) } } ] } openBanUserModal ( users : User [ ] ) { for ( const user of users ) { if ( user . username === 's' ) { this . notifier . error ( this . 0 ( 's' ) ) return } } this . userBanModal . openModal ( users ) } onUserChanged ( ) { this . loadData ( ) } async unbanUsers ( users : User [ ] ) { const message = this . 0 ( 's' , { num : users . length } ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . userService . unbanUsers ( users ) . subscribe ( ( ) => { const message = this . 0 ( 's' , { num : users . length } ) this . notifier . success ( message ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } async removeUsers ( users : User [ ] ) { for ( const user of users ) { if ( user . username === 's' ) { this . notifier . error ( this . 0 ( 's' ) ) return } } const message = this . 0 ( 's' ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . userService . removeUser ( users ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { num : users . length } ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } async setEmailsAsVerified ( users : User [ ] ) { this . userService . updateUsers ( users , { emailVerified : true } ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { num : users . length } ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } isInSelectionMode ( ) { return this . selectedUsers . length !== 0 } protected loadData ( ) { this . selectedUsers = [ ] this . userService . getUsers ( this . pagination , this . sort , this . search ) . subscribe ( resultList => { this . users = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $ConfirmService$ O O $ServerService$ O O $UserService$ O O $AuthService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $users$ O O O O O O O O $users$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $users$ O O O O O O O O $users$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $users$ O O O O O O O O $users$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $users$ O O O O O O O O $users$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component } from 's' @ Component ( { template : 's' } ) export class UsersComponent { }	O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { UserRightGuard } from 's' import { UserRight } from 's' import { UsersComponent } from 's' import { UserCreateComponent , UserUpdateComponent } from 's' import { UserListComponent } from 's' export const UsersRoutes = [ { path : 's' , component : UsersComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_USERS } , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : UserListComponent , data : { meta : { title : 's' } } } , { path : 's' , component : UserCreateComponent , data : { meta : { title : 's' } } } , { path : 's' , component : UserUpdateComponent , data : { meta : { title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { ConfigRoutes } from 's' import { MetaGuard } from 's' import { AdminComponent } from 's' import { FollowsRoutes } from 's' import { UsersRoutes } from 's' import { ModerationRoutes } from 's' import { SystemRoutes } from 's' import { PluginsRoutes } from 's' const adminRoutes = [ { path : 's' , component : AdminComponent , canActivate : [ MetaGuard ] , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , ... FollowsRoutes , ... UsersRoutes , ... ModerationRoutes , ... SystemRoutes , ... ConfigRoutes , ... PluginsRoutes ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( adminRoutes ) ] , exports : [ RouterModule ] } ) export class AdminRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Actor as ActorServer } from 's' import { Avatar } from 's' import { getAbsoluteAPIUrl } from 's' export abstract class Actor implements ActorServer { id : number url : string name : string host : string followingCount : number followersCount : number createdAt : Date | string updatedAt : Date | string avatar : Avatar avatarUrl : string static GET_ACTOR_AVATAR_URL ( actor : { avatar ? : { path : string } } ) { const absoluteAPIUrl = getAbsoluteAPIUrl ( ) if ( actor && actor . avatar ) return absoluteAPIUrl + actor . avatar . path return window . location . origin + 's' } static CREATE_BY_STRING ( accountName , host , forceHostname = false ) { const absoluteAPIUrl = getAbsoluteAPIUrl ( ) const thisHost = new URL ( absoluteAPIUrl ) . host if ( host . trim ( ) === thisHost && ! forceHostname ) return accountName return accountName + 's' + host } protected constructor ( hash ) { this . id = hash . id this . url = hash . url this . name = hash . name this . host = hash . host this . followingCount = hash . followingCount this . followersCount = hash . followersCount this . createdAt = new Date ( hash . createdAt . toString ( ) ) this . updatedAt = new Date ( hash . updatedAt . toString ( ) ) this . avatar = hash . avatar this . updateComputedAttributes ( ) } updateAvatar ( newAvatar ) { this . avatar = newAvatar this . updateComputedAttributes ( ) } private updateComputedAttributes ( ) { this . avatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorServer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Avatar$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Account as ServerAccount } from 's' import { Actor } from 's' export class Account extends Actor implements ServerAccount { displayName : string description : string nameWithHost : string nameWithHostForced : string mutedByUser : boolean mutedByInstance : boolean mutedServerByUser : boolean mutedServerByInstance : boolean userId ? : number constructor ( hash ) { super ( hash ) this . displayName = hash . displayName this . description = hash . description this . userId = hash . userId this . nameWithHost = Actor . CREATE_BY_STRING ( this . name , this . host ) this . nameWithHostForced = Actor . CREATE_BY_STRING ( this . name , this . host , true ) this . mutedByUser = false this . mutedByInstance = false this . mutedServerByUser = false this . mutedServerByInstance = false } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerAccount$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { GlobalIconName } from 's' export type DropdownAction < T > = { label ? : string iconName ? : GlobalIconName handler ? : ( a : T ) => any linkBuilder ? : ( a : T ) => ( string | number ) [ ] isDisplayed ? : ( a : T ) => boolean } export type DropdownButtonSize = 's' | 's' export type DropdownTheme = 's' | 's' export type DropdownDirection = 's' | 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class ActionDropdownComponent < T > { @ Input ( ) actions : DropdownAction < T > [ ] | DropdownAction < T > [ ] [ ] = [ ] @ Input ( ) entry : T @ Input ( ) placement = 's' @ Input ( ) buttonSize : DropdownButtonSize = 's' @ Input ( ) buttonDirection : DropdownDirection = 's' @ Input ( ) buttonStyled = true @ Input ( ) label : string @ Input ( ) theme : DropdownTheme = 's' getActions ( ) { if ( this . actions . length !== 0 && Array . isArray ( this . actions [ 0 ] ) ) return this . actions return [ this . actions ] } areActionsDisplayed ( actions : DropdownAction < T > [ ] , entry : T ) { return actions . some ( a => a . isDisplayed === undefined || a . isDisplayed ( entry ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , OnInit , Output , ViewChild } from 's' import { Notifier } from 's' import { FormReactive , VideoAbuseService , VideoAbuseValidatorsService } from 's' import { 0 } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { FormValidatorService } from 's' import { VideoAbuse } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ModerationCommentModalComponent extends FormReactive implements OnInit { @ ViewChild ( 's' , { static : true } ) modal : NgbModal @ Output ( ) commentUpdated = new EventEmitter < string > ( ) private abuseToComment : VideoAbuse private openedModal : NgbModalRef constructor ( protected formValidatorService , private modalService , private notifier , private videoAbuseService , private videoAbuseValidatorsService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { moderationComment : this . videoAbuseValidatorsService . VIDEO_ABUSE_REASON } ) } openModal ( abuseToComment ) { this . abuseToComment = abuseToComment this . openedModal = this . modalService . open ( this . modal ) this . form . patchValue ( { moderationComment : this . abuseToComment . moderationComment } ) } hide ( ) { this . abuseToComment = undefined this . openedModal . close ( ) this . form . reset ( ) } async banUser ( ) { const moderationComment = this . form . value [ 's' ] this . videoAbuseService . updateVideoAbuse ( this . abuseToComment , { moderationComment } ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . commentUpdated . emit ( moderationComment ) this . hide ( ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $Notifier$ O O $VideoAbuseService$ O O $VideoAbuseValidatorsService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { Account } from 's' import { Notifier } from 's' import { SortMeta } from 's' import { VideoAbuse , VideoAbuseState } from 's' import { RestPagination , RestTable , VideoAbuseService } from 's' import { 0 } from 's' import { DropdownAction } from 's' import { ConfirmService } from 's' import { ModerationCommentModalComponent } from 's' import { Video } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoAbuseListComponent extends RestTable implements OnInit { @ ViewChild ( 's' , { static : true } ) moderationCommentModal : ModerationCommentModalComponent videoAbuses : ( VideoAbuse & { moderationCommentHtml ? : string , reasonHtml ? : string } ) [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } videoAbuseActions : DropdownAction < VideoAbuse > [ ] = [ ] constructor ( private notifier , private videoAbuseService , private confirmService , private 0 , private markdownRenderer ) { super ( ) this . videoAbuseActions = [ { label : this . 0 ( 's' ) , handler => this . removeVideoAbuse ( videoAbuse ) } , { label : this . 0 ( 's' ) , handler => this . openModerationCommentModal ( videoAbuse ) } , { label : this . 0 ( 's' ) , handler => this . updateVideoAbuseState ( videoAbuse , VideoAbuseState . ACCEPTED ) , isDisplayed => ! this . isVideoAbuseAccepted ( videoAbuse ) } , { label : this . 0 ( 's' ) , handler => this . updateVideoAbuseState ( videoAbuse , VideoAbuseState . REJECTED ) , isDisplayed => ! this . isVideoAbuseRejected ( videoAbuse ) } ] } ngOnInit ( ) { this . initialize ( ) } openModerationCommentModal ( videoAbuse ) { this . moderationCommentModal . openModal ( videoAbuse ) } onModerationCommentUpdated ( ) { this . loadData ( ) } createByString ( account ) { return Account . CREATE_BY_STRING ( account . name , account . host ) } isVideoAbuseAccepted ( videoAbuse ) { return videoAbuse . state . id === VideoAbuseState . ACCEPTED } isVideoAbuseRejected ( videoAbuse ) { return videoAbuse . state . id === VideoAbuseState . REJECTED } getVideoUrl ( videoAbuse ) { return Video . buildClientUrl ( videoAbuse . video . uuid ) } async removeVideoAbuse ( videoAbuse ) { const res = await this . confirmService . confirm ( this . 0 ( 's' ) , this . 0 ( 's' ) ) if ( res === false ) return this . videoAbuseService . removeVideoAbuse ( videoAbuse ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } updateVideoAbuseState ( videoAbuse , state ) { this . videoAbuseService . updateVideoAbuse ( videoAbuse , { state } ) . subscribe ( ( ) => this . loadData ( ) , err => this . notifier . error ( err . message ) ) } protected loadData ( ) { return this . videoAbuseService . getVideoAbuses ( this . pagination , this . sort ) . subscribe ( async resultList => { this . totalRecords = resultList . total this . videoAbuses = resultList . data for ( const abuse of this . videoAbuses ) { Object . assign ( abuse , { reasonHtml : await this . toHtml ( abuse . reason ) , moderationCommentHtml : await this . toHtml ( abuse . moderationComment ) } ) } } , err => this . notifier . error ( err . message ) ) } private toHtml ( text ) { return this . markdownRenderer . textMarkdownToHTML ( text ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $VideoAbuseService$ O O $ConfirmService$ O O $I18n$ O O $MarkdownService$ O O O O O O O O O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O $videoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O $VideoAbuseState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Component } from 's' import { 0 } from 's' import { ActivatedRoute , Router } from 's' import { ComponentPagination } from 's' import { AuthService , Notifier , ServerService } from 's' import { VideoBlacklistService } from 's' import { immutableAssign } from 's' import { ScreenService } from 's' import { MiniatureDisplayOptions } from 's' import { SelectionType } from 's' import { Video } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoAutoBlacklistListComponent { titlePage : string selection : SelectionType = { } miniatureDisplayOptions : MiniatureDisplayOptions = { date : true , views : false , by : true , privacyLabel : false , privacyText : true , state : false , blacklistInfo : false , nsfw : true } pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } videos : Video [ ] = [ ] getVideosObservableFunction = this . getVideosObservable . bind ( this ) constructor ( protected router , protected route , protected notifier , protected authService , protected screenService , protected serverService , private 0 , private videoBlacklistService ) { this . titlePage = this . 0 ( 's' ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) return this . videoBlacklistService . getAutoBlacklistedAsVideoList ( newPagination ) } removeVideoFromBlacklist ( entry ) { this . videoBlacklistService . removeVideoFromBlacklist ( entry . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { name : entry . name } ) ) this . videos = this . videos . filter ( v => v . id !== entry . id ) } , error => this . notifier . error ( error . message ) ) } removeSelectedVideosFromBlacklist ( ) { const toReleaseVideosIds = Object . keys ( this . selection ) . filter ( k => this . selection [ k ] === true ) . map ( k => parseInt ( k , 0 ) ) this . videoBlacklistService . removeVideoFromBlacklist ( toReleaseVideosIds ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { num : toReleaseVideosIds . length } ) ) this . selection = { } this . videos = this . videos . filter ( v => toReleaseVideosIds . includes ( v . id ) === false ) } , error => this . notifier . error ( error . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $ActivatedRoute$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $ServerService$ O O $I18n$ O O $VideoBlacklistService$ O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , OnInit } from 's' import { SortMeta } from 's' import { Notifier , ServerService } from 's' import { ConfirmService } from 's' import { RestPagination , RestTable , VideoBlacklistService } from 's' import { VideoBlacklist , VideoBlacklistType } from 's' import { 0 } from 's' import { DropdownAction } from 's' import { Video } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoBlacklistListComponent extends RestTable implements OnInit { blacklist : ( VideoBlacklist & { reasonHtml ? : string } ) [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } listBlacklistTypeFilter : VideoBlacklistType = undefined videoBlacklistActions : DropdownAction < VideoBlacklist > [ ] = [ ] constructor ( private notifier , private serverService , private confirmService , private videoBlacklistService , private markdownRenderer , private 0 ) { super ( ) if ( this . serverService . getConfig ( ) . autoBlacklist . videos . ofUsers . enabled ) { this . listBlacklistTypeFilter = VideoBlacklistType . MANUAL } this . videoBlacklistActions = [ { label : this . 0 ( 's' ) , handler => this . removeVideoFromBlacklist ( videoBlacklist ) } ] } ngOnInit ( ) { this . initialize ( ) } getVideoUrl ( videoBlacklist ) { return Video . buildClientUrl ( videoBlacklist . video . uuid ) } booleanToText ( value ) { if ( value === true ) return this . 0 ( 's' ) return this . 0 ( 's' ) } toHtml ( text ) { return this . markdownRenderer . textMarkdownToHTML ( text ) } async removeVideoFromBlacklist ( entry ) { const confirmMessage = this . 0 ( 's' ) const res = await this . confirmService . confirm ( confirmMessage , this . 0 ( 's' ) ) if ( res === false ) return this . videoBlacklistService . removeVideoFromBlacklist ( entry . video . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { name : entry . video . name } ) ) this . loadData ( ) } , err => this . notifier . error ( err . message ) ) } protected loadData ( ) { this . videoBlacklistService . listBlacklist ( this . pagination , this . sort , this . listBlacklistTypeFilter ) . subscribe ( async resultList => { this . totalRecords = resultList . total this . blacklist = resultList . data for ( const element of this . blacklist ) { Object . assign ( element , { reasonHtml : await this . toHtml ( element . reason ) } ) } } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $ServerService$ O O $ConfirmService$ O O $VideoBlacklistService$ O O $MarkdownService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $videoBlacklist$ O O O O O O O O O O O O O O O O O O O O O O $VideoBlacklist$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $VideoBlacklist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component } from 's' import { UserRight } from 's' import { AuthService , ServerService } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class ModerationComponent { autoBlacklistVideosEnabled : boolean constructor ( private auth , private serverService ) { this . autoBlacklistVideosEnabled = this . serverService . getConfig ( ) . autoBlacklist . videos . ofUsers . enabled } hasVideoAbusesRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_VIDEO_ABUSES ) } hasVideoBlacklistRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) } hasAccountsBlocklistRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_ACCOUNTS_BLOCKLIST ) } hasServersBlocklistRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_SERVERS_BLOCKLIST ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { UserRight } from 's' import { UserRightGuard } from 's' import { VideoAbuseListComponent } from 's' import { VideoBlacklistListComponent } from 's' import { VideoAutoBlacklistListComponent } from 's' import { ModerationComponent } from 's' import { InstanceAccountBlocklistComponent , InstanceServerBlocklistComponent } from 's' export const ModerationRoutes = [ { path : 's' , component : ModerationComponent , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : VideoAbuseListComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_VIDEO_ABUSES , meta : { title : 's' } } } , { path : 's' , component : VideoAutoBlacklistListComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_VIDEO_BLACKLIST , meta : { title : 's' } } } , { path : 's' , component : VideoBlacklistListComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_VIDEO_BLACKLIST , meta : { title : 's' } } } , { path : 's' , component : InstanceAccountBlocklistComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_ACCOUNTS_BLOCKLIST , meta : { title : 's' } } } , { path : 's' , component : InstanceServerBlocklistComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_SERVERS_BLOCKLIST , meta : { title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { ConfigComponent , EditCustomConfigComponent } from 's' import { ConfigService } from 's' import { TableModule } from 's' import { SharedModule } from 's' import { AdminRoutingModule } from 's' import { AdminComponent } from 's' import { FollowersListComponent , FollowingAddComponent , FollowsComponent } from 's' import { FollowingListComponent } from 's' import { UserCreateComponent , UserListComponent , UserPasswordComponent , UsersComponent , UserUpdateComponent } from 's' import { ModerationCommentModalComponent , VideoAbuseListComponent , VideoAutoBlacklistListComponent , VideoBlacklistListComponent } from 's' import { ModerationComponent } from 's' import { RedundancyCheckboxComponent } from 's' import { RedundancyService } from 's' import { InstanceAccountBlocklistComponent , InstanceServerBlocklistComponent } from 's' import { JobsComponent } from 's' import { JobService , LogsComponent , LogsService , SystemComponent } from 's' import { DebugComponent , DebugService } from 's' import { PluginsComponent } from 's' import { PluginListInstalledComponent } from 's' import { PluginSearchComponent } from 's' import { PluginShowInstalledComponent } from 's' import { SelectButtonModule } from 's' import { PluginApiService } from 's' @ NgModule ( { imports : [ AdminRoutingModule , TableModule , SelectButtonModule , SharedModule ] , declarations : [ AdminComponent , FollowsComponent , FollowingAddComponent , FollowersListComponent , FollowingListComponent , RedundancyCheckboxComponent , UsersComponent , UserCreateComponent , UserUpdateComponent , UserPasswordComponent , UserListComponent , ModerationComponent , VideoBlacklistListComponent , VideoAbuseListComponent , VideoAutoBlacklistListComponent , ModerationCommentModalComponent , InstanceServerBlocklistComponent , InstanceAccountBlocklistComponent , PluginsComponent , PluginListInstalledComponent , PluginSearchComponent , PluginShowInstalledComponent , SystemComponent , JobsComponent , LogsComponent , DebugComponent , ConfigComponent , EditCustomConfigComponent ] , exports : [ AdminComponent ] , providers : [ RedundancyService , JobService , LogsService , DebugService , ConfigService , PluginApiService ] } ) export class AdminModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { template : 's' } ) export class ConfigComponent { }	O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { EditCustomConfigComponent } from 's' import { UserRightGuard } from 's' import { UserRight } from 's' import { ConfigComponent } from 's' export const ConfigRoutes = [ { path : 's' , component : ConfigComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_CONFIGURATION } , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : EditCustomConfigComponent , data : { meta : { title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NSFWPolicyType } from 's' export interface CustomConfig { instance : { name : string shortDescription : string description : string terms : string codeOfConduct : string creationReason : string moderationInformation : string administrator : string maintenanceLifetime : string businessModel : string hardwareInformation : string languages : string [ ] categories : number [ ] isNSFW : boolean defaultClientRoute : string defaultNSFWPolicy : NSFWPolicyType customizations : { javascript ? : string css ? : string } } theme : { default : string } services : { twitter : { username : string whitelisted : boolean } } cache : { previews : { size : number } captions : { size : number } } signup : { enabled : boolean limit : number requiresEmailVerification : boolean } admin : { email : string } contactForm : { enabled : boolean } user : { videoQuota : number videoQuotaDaily : number } transcoding : { enabled : boolean allowAdditionalExtensions : boolean allowAudioFiles : boolean threads : number resolutions : { 's' : boolean 's' : boolean 's' : boolean 's' : boolean 's' : boolean 's' : boolean } hls : { enabled : boolean } } import : { videos : { http : { enabled : boolean } , torrent : { enabled : boolean } } } autoBlacklist : { videos : { ofUsers : { enabled : boolean } } } followers : { instance : { enabled : boolean , manualApproval : boolean } } followings : { instance : { autoFollowBack : { enabled : boolean } autoFollowIndex : { enabled : boolean indexUrl : string } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { ConfigService } from 's' import { ServerService } from 's' import { CustomConfigValidatorsService , FormReactive , UserValidatorsService } from 's' import { Notifier } from 's' import { CustomConfig } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { SelectItem } from 's' import { forkJoin } from 's' import { first } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class EditCustomConfigComponent extends FormReactive implements OnInit { customConfig : CustomConfig resolutions : { id : string , label : string } [ ] = [ ] transcodingThreadOptions : { label : string , value : number } [ ] = [ ] languageItems : SelectItem [ ] = [ ] categoryItems : SelectItem [ ] = [ ] constructor ( protected formValidatorService , private customConfigValidatorsService , private userValidatorsService , private notifier , private configService , private serverService , private 0 ) { super ( ) this . resolutions = [ { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } ] this . transcodingThreadOptions = [ { value : 0 , label : this . 0 ( 's' ) } , { value : 0 , label : 's' } , { value : 0 , label : 's' } , { value : 0 , label : 's' } , { value : 0 , label : 's' } ] } get videoQuotaOptions ( ) { return this . configService . videoQuotaOptions } get videoQuotaDailyOptions ( ) { return this . configService . videoQuotaDailyOptions } get availableThemes ( ) { return this . serverService . getConfig ( ) . theme . registered . map ( t => t . name ) } getResolutionKey ( resolution ) { return 's' + resolution } ngOnInit ( ) { const formGroupData : { [ key in keyof CustomConfig ] : any } = { instance : { name : this . customConfigValidatorsService . INSTANCE_NAME , shortDescription : this . customConfigValidatorsService . INSTANCE_SHORT_DESCRIPTION , description : null , isNSFW : false , defaultNSFWPolicy : null , terms : null , codeOfConduct : null , creationReason : null , moderationInformation : null , administrator : null , maintenanceLifetime : null , businessModel : null , hardwareInformation : null , categories : null , languages : null , defaultClientRoute : null , customizations : { javascript : null , css : null } } , theme : { default : null } , services : { twitter : { username : this . customConfigValidatorsService . SERVICES_TWITTER_USERNAME , whitelisted : null } } , cache : { previews : { size : this . customConfigValidatorsService . CACHE_PREVIEWS_SIZE } , captions : { size : this . customConfigValidatorsService . CACHE_CAPTIONS_SIZE } } , signup : { enabled : null , limit : this . customConfigValidatorsService . SIGNUP_LIMIT , requiresEmailVerification : null } , import : { videos : { http : { enabled : null } , torrent : { enabled : null } } } , admin : { email : this . customConfigValidatorsService . ADMIN_EMAIL } , contactForm : { enabled : null } , user : { videoQuota : this . userValidatorsService . USER_VIDEO_QUOTA , videoQuotaDaily : this . userValidatorsService . USER_VIDEO_QUOTA_DAILY } , transcoding : { enabled : null , threads : this . customConfigValidatorsService . TRANSCODING_THREADS , allowAdditionalExtensions : null , allowAudioFiles : null , resolutions : { } } , autoBlacklist : { videos : { ofUsers : { enabled : null } } } , followers : { instance : { enabled : null , manualApproval : null } } , followings : { instance : { autoFollowBack : { enabled : null } , autoFollowIndex : { enabled : null , indexUrl : this . customConfigValidatorsService . INDEX_URL } } } } const defaultValues = { transcoding : { resolutions : { } } } for ( const resolution of this . resolutions ) { defaultValues . transcoding . resolutions [ resolution . id ] = 's' formGroupData . transcoding . resolutions [ resolution . id ] = null } this . buildForm ( formGroupData ) forkJoin ( [ this . configService . getCustomConfig ( ) , this . serverService . videoLanguagesLoaded . pipe ( first ( ) ) , this . serverService . videoCategoriesLoaded . pipe ( first ( ) ) ] ) . subscribe ( ( [ config ] ) => { this . customConfig = config const languages = this . serverService . getVideoLanguages ( ) this . languageItems = languages . map ( l => ( { label : l . label , value : l . id } ) ) const categories = this . serverService . getVideoCategories ( ) this . categoryItems = categories . map ( l => ( { label : l . label , value : l . id } ) ) this . updateForm ( ) this . forceCheck ( ) } , err => this . notifier . error ( err . message ) ) } isTranscodingEnabled ( ) { return this . form . value [ 's' ] [ 's' ] === true } isSignupEnabled ( ) { return this . form . value [ 's' ] [ 's' ] === true } async formValidated ( ) { this . configService . updateCustomConfig ( this . form . value ) . subscribe ( res => { this . customConfig = res this . serverService . loadConfig ( ) this . updateForm ( ) this . notifier . success ( this . 0 ( 's' ) ) } , err => this . notifier . error ( err . message ) ) } getSelectedLanguageLabel ( ) { return this . 0 ( 's' ) } getDefaultLanguageLabel ( ) { return this . 0 ( 's' ) } getSelectedCategoryLabel ( ) { return this . 0 ( 's' ) } getDefaultCategoryLabel ( ) { return this . 0 ( 's' ) } private updateForm ( ) { this . form . patchValue ( this . customConfig ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $CustomConfigValidatorsService$ O O $UserValidatorsService$ O O $Notifier$ O O $ConfigService$ O O $ServerService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { catchError } from 's' import { HttpClient } from 's' import { Injectable } from 's' import { CustomConfig } from 's' import { environment } from 's' import { RestExtractor } from 's' import { 0 } from 's' @ Injectable ( ) export class ConfigService { private static BASE_APPLICATION_URL = environment . apiUrl + 's' videoQuotaOptions : { value : number , label : string } [ ] = [ ] videoQuotaDailyOptions : { value : number , label : string } [ ] = [ ] constructor ( private authHttp , private restExtractor , private 0 ) { this . videoQuotaOptions = [ { value : - 0 , label : this . 0 ( 's' ) } , { value : 0 , label : 's' } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 * 0 , label : this . 0 ( 's' ) } ] this . videoQuotaDailyOptions = [ { value : - 0 , label : this . 0 ( 's' ) } , { value : 0 , label : 's' } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 * 0 , label : this . 0 ( 's' ) } , { value : 0 * 0 * 0 * 0 , label : this . 0 ( 's' ) } ] } getCustomConfig ( ) { return this . authHttp . get < CustomConfig > ( ConfigService . BASE_APPLICATION_URL + 's' ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } updateCustomConfig ( data ) { return this . authHttp . put < CustomConfig > ( ConfigService . BASE_APPLICATION_URL + 's' , data ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { Notifier } from 's' import { 0 } from 's' import { RedundancyService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RedundancyCheckboxComponent { @ Input ( ) redundancyAllowed : boolean @ Input ( ) host : string constructor ( private notifier , private redundancyService , private 0 ) { } updateRedundancyState ( ) { this . redundancyService . updateRedundancy ( this . host , this . redundancyAllowed ) . subscribe ( ( ) => { const stateLabel = this . redundancyAllowed ? this . 0 ( 's' ) : this . 0 ( 's' ) this . notifier . success ( this . 0 ( 's' , { host : this . host , stateLabel } ) ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $RedundancyService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map } from 's' import { HttpClient } from 's' import { Injectable } from 's' import { RestExtractor } from 's' import { environment } from 's' @ Injectable ( ) export class RedundancyService { static BASE_USER_SUBSCRIPTIONS_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor ) { } updateRedundancy ( host , redundancyAllowed ) { const url = RedundancyService . BASE_USER_SUBSCRIPTIONS_URL + 's' + host const body = { redundancyAllowed } return this . authHttp . put ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { 0 } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { AccountBlock , BlocklistService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class InstanceAccountBlocklistComponent extends RestTable implements OnInit { blockedAccounts : AccountBlock [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private blocklistService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } unblockAccount ( accountBlock ) { const blockedAccount = accountBlock . blockedAccount this . blocklistService . unblockAccountByInstance ( blockedAccount ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : blockedAccount . nameWithHost } ) ) this . loadData ( ) } ) } protected loadData ( ) { return this . blocklistService . getInstanceAccountBlocklist ( this . pagination , this . sort ) . subscribe ( resultList => { this . blockedAccounts = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $BlocklistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O $AccountBlock$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { 0 } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { BlocklistService } from 's' import { ServerBlock } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class InstanceServerBlocklistComponent extends RestTable implements OnInit { blockedServers : ServerBlock [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private blocklistService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } unblockServer ( serverBlock ) { const host = serverBlock . blockedServer . host this . blocklistService . unblockServerByInstance ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . loadData ( ) } ) } protected loadData ( ) { return this . blocklistService . getInstanceServerBlocklist ( this . pagination , this . sort ) . subscribe ( resultList => { this . blockedServers = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $BlocklistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O $ServerBlock$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Component } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class PluginsComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , OnInit } from 's' import { PluginType } from 's' import { 0 } from 's' import { PluginApiService } from 's' import { ComponentPagination , hasMoreItems } from 's' import { ConfirmService , Notifier } from 's' import { PeerTubePlugin } from 's' import { ActivatedRoute , Router } from 's' import { compareSemVer } from 's' import { PluginService } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' , 's' ] } ) export class PluginListInstalledComponent implements OnInit { pluginTypeOptions : { label : string , value : PluginType } [ ] = [ ] pluginType : PluginType = PluginType . PLUGIN pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 } sort = 's' plugins : PeerTubePlugin [ ] = [ ] updating : { [ name ] : boolean } = { } PluginType = PluginType onDataSubject = new Subject < any [ ] > ( ) constructor ( private 0 , private pluginService , private pluginApiService , private notifier , private confirmService , private router , private route ) { this . pluginTypeOptions = this . pluginApiService . getPluginTypeOptions ( ) } ngOnInit ( ) { const query = this . route . snapshot . queryParams if ( query [ 's' ] ) this . pluginType = parseInt ( query [ 's' ] , 0 ) this . reloadPlugins ( ) } reloadPlugins ( ) { this . pagination . currentPage = 0 this . plugins = [ ] this . router . navigate ( [ ] , { queryParams : { pluginType : this . pluginType } } ) this . loadMorePlugins ( ) } loadMorePlugins ( ) { this . pluginApiService . getPlugins ( this . pluginType , this . pagination , this . sort ) . subscribe ( res => { this . plugins = this . plugins . concat ( res . data ) this . pagination . totalItems = res . total this . onDataSubject . next ( res . data ) } , err => this . notifier . error ( err . message ) ) } onNearOfBottom ( ) { if ( ! hasMoreItems ( this . pagination ) ) return this . pagination . currentPage += 0 this . loadMorePlugins ( ) } getNoResultMessage ( ) { if ( this . pluginType === PluginType . PLUGIN ) { return this . 0 ( 's' ) } return this . 0 ( 's' ) } isUpdateAvailable ( plugin ) { return plugin . latestVersion && compareSemVer ( plugin . latestVersion , plugin . version ) > 0 } getUpdateLabel ( plugin ) { return this . 0 ( 's' , { version : plugin . latestVersion } ) } isUpdating ( plugin ) { return ! ! this . updating [ this . getUpdatingKey ( plugin ) ] } async uninstall ( plugin ) { const res = await this . confirmService . confirm ( this . 0 ( 's' , { pluginName : plugin . name } ) , this . 0 ( 's' ) ) if ( res === false ) return this . pluginApiService . uninstall ( plugin . name , plugin . type ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { pluginName : plugin . name } ) ) this . plugins = this . plugins . filter ( p => p . name !== plugin . name ) this . pagination . totalItems -- } , err => this . notifier . error ( err . message ) ) } async update ( plugin ) { const updatingKey = this . getUpdatingKey ( plugin ) if ( this . updating [ updatingKey ] ) return this . updating [ updatingKey ] = true this . pluginApiService . update ( plugin . name , plugin . type ) . pipe ( ) . subscribe ( res => { this . updating [ updatingKey ] = false this . notifier . success ( this . 0 ( 's' , { pluginName : plugin . name } ) ) Object . assign ( plugin , res ) } , err => this . notifier . error ( err . message ) ) } getShowRouterLink ( plugin ) { return [ 's' , 's' , 's' , this . pluginService . nameToNpmName ( plugin . name , plugin . type ) ] } private getUpdatingKey ( plugin ) { return plugin . name + plugin . type } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $PluginService$ O O $PluginApiService$ O O $Notifier$ O O $ConfirmService$ O O $Router$ O O $ActivatedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier , ServerService } from 's' import { ConfirmService } from 's' import { 0 } from 's' import { PluginType } from 's' import { PluginApiService } from 's' import { ComponentPagination , hasMoreItems } from 's' import { ActivatedRoute , Router } from 's' import { PeerTubePluginIndex } from 's' import { Subject } from 's' import { debounceTime , distinctUntilChanged } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' , 's' ] } ) export class PluginSearchComponent implements OnInit { pluginTypeOptions : { label : string , value : PluginType } [ ] = [ ] pluginType : PluginType = PluginType . PLUGIN pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 } sort = 's' search = 's' isSearching = false plugins : PeerTubePluginIndex [ ] = [ ] installing : { [ name ] : boolean } = { } pluginInstalled = false onDataSubject = new Subject < any [ ] > ( ) private searchSubject = new Subject < string > ( ) constructor ( private server , private 0 , private pluginService , private notifier , private confirmService , private router , private route ) { this . pluginTypeOptions = this . pluginService . getPluginTypeOptions ( ) } ngOnInit ( ) { const query = this . route . snapshot . queryParams if ( query [ 's' ] ) this . pluginType = parseInt ( query [ 's' ] , 0 ) this . searchSubject . asObservable ( ) . pipe ( debounceTime ( 0 ) , distinctUntilChanged ( ) ) . subscribe ( search => { this . search = search this . reloadPlugins ( ) } ) this . reloadPlugins ( ) } onSearchChange ( search ) { this . searchSubject . next ( search ) } reloadPlugins ( ) { this . pagination . currentPage = 0 this . plugins = [ ] this . router . navigate ( [ ] , { queryParams : { pluginType : this . pluginType } } ) this . loadMorePlugins ( ) } loadMorePlugins ( ) { this . isSearching = true this . pluginService . searchAvailablePlugins ( this . pluginType , this . pagination , this . sort , this . search ) . subscribe ( res => { this . isSearching = false this . plugins = this . plugins . concat ( res . data ) this . pagination . totalItems = res . total this . onDataSubject . next ( res . data ) } , err => { console . error ( err ) const message = this . 0 ( 's' ) this . notifier . error ( message ) } ) } onNearOfBottom ( ) { if ( ! hasMoreItems ( this . pagination ) ) return this . pagination . currentPage += 0 this . loadMorePlugins ( ) } isInstalling ( plugin ) { return ! ! this . installing [ plugin . npmName ] } async install ( plugin ) { if ( this . installing [ plugin . npmName ] ) return const res = await this . confirmService . confirm ( this . 0 ( 's' ) , this . 0 ( 's' , { pluginName : plugin . name } ) ) if ( res === false ) return this . installing [ plugin . npmName ] = true this . pluginService . install ( plugin . npmName ) . subscribe ( ( ) => { this . installing [ plugin . npmName ] = false this . pluginInstalled = true this . notifier . success ( this . 0 ( 's' , { pluginName : plugin . name } ) ) plugin . installed = true } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O $I18n$ O O $PluginApiService$ O O $Notifier$ O O $ConfirmService$ O O $Router$ O O $ActivatedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePluginIndex$ O O O O O O O O O O O O O O O O O $PeerTubePluginIndex$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { PeerTubePlugin } from 's' import { 0 } from 's' import { PluginApiService } from 's' import { Notifier } from 's' import { ActivatedRoute } from 's' import { Subscription } from 's' import { map , switchMap } from 's' import { BuildFormArgument , FormReactive , FormValidatorService } from 's' import { RegisterServerSettingOptions } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class PluginShowInstalledComponent extends FormReactive implements OnInit , OnDestroy { plugin : PeerTubePlugin registeredSettings : RegisterServerSettingOptions [ ] = [ ] pluginTypeLabel : string private sub : Subscription constructor ( protected formValidatorService , private 0 , private pluginService , private notifier , private route ) { super ( ) } ngOnInit ( ) { this . sub = this . route . params . subscribe ( routeParams => { const npmName = routeParams [ 's' ] this . loadPlugin ( npmName ) } ) } ngOnDestroy ( ) { if ( this . sub ) this . sub . unsubscribe ( ) } formValidated ( ) { const settings = this . form . value this . pluginService . updatePluginSettings ( this . plugin . name , this . plugin . type , settings ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) } , err => this . notifier . error ( err . message ) ) } hasRegisteredSettings ( ) { return Array . isArray ( this . registeredSettings ) && this . registeredSettings . length !== 0 } private loadPlugin ( npmName ) { this . pluginService . getPlugin ( npmName ) . pipe ( switchMap ( plugin => { return this . pluginService . getPluginRegisteredSettings ( plugin . name , plugin . type ) . pipe ( map ( data => ( { plugin , registeredSettings : data . registeredSettings } ) ) ) } ) ) . subscribe ( ( { plugin , registeredSettings } ) => { this . plugin = plugin this . registeredSettings = registeredSettings this . pluginTypeLabel = this . pluginService . getPluginTypeLabel ( this . plugin . type ) this . buildSettingsForm ( ) } , err => this . notifier . error ( err . message ) ) } private buildSettingsForm ( ) { const buildOptions = { } const settingsValues = { } for ( const setting of this . registeredSettings ) { buildOptions [ setting . name ] = null settingsValues [ setting . name ] = this . getSetting ( setting . name ) } this . buildForm ( buildOptions ) this . form . patchValue ( settingsValues ) } private getSetting ( name ) { const settings = this . plugin . settings if ( settings && settings [ name ] ) return settings [ name ] const registered = this . registeredSettings . find ( r => r . name === name ) return registered . default } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $I18n$ O O $PluginApiService$ O O $Notifier$ O O $ActivatedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuildFormArgument$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { UserRightGuard } from 's' import { UserRight } from 's' import { PluginListInstalledComponent } from 's' import { PluginSearchComponent } from 's' import { PluginShowInstalledComponent } from 's' import { PluginsComponent } from 's' export const PluginsRoutes = [ { path : 's' , component : PluginsComponent , canActivate : [ UserRightGuard ] , data : { userRight : UserRight . MANAGE_PLUGINS } , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : PluginListInstalledComponent , data : { meta : { title : 's' } } } , { path : 's' , component : PluginSearchComponent , data : { meta : { title : 's' } } } , { path : 's' , component : PluginShowInstalledComponent , data : { meta : { title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , switchMap } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { 0 } from 's' import { PluginType } from 's' import { ComponentPagination } from 's' import { peertubeTranslate , ResultList } from 's' import { PeerTubePlugin } from 's' import { ManagePlugin } from 's' import { InstallOrUpdatePlugin } from 's' import { PeerTubePluginIndex } from 's' import { RegisteredServerSettings , RegisterServerSettingOptions } from 's' import { PluginService } from 's' import { Observable } from 's' @ Injectable ( ) export class PluginApiService { private static BASE_PLUGIN_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService , private 0 , private pluginService ) { } getPluginTypeOptions ( ) { return [ { label : this . 0 ( 's' ) , value : PluginType . PLUGIN } , { label : this . 0 ( 's' ) , value : PluginType . THEME } ] } getPluginTypeLabel ( type ) { if ( type === PluginType . PLUGIN ) { return this . 0 ( 's' ) } return this . 0 ( 's' ) } getPlugins ( pluginType , componentPagination , sort ) { const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) params = params . append ( 's' , pluginType . toString ( ) ) return this . authHttp . get < ResultList < PeerTubePlugin > > ( PluginApiService . BASE_PLUGIN_URL , { params } ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } searchAvailablePlugins ( pluginType , componentPagination , sort , search ? ) { const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) params = params . append ( 's' , pluginType . toString ( ) ) if ( search ) params = params . append ( 's' , search ) return this . authHttp . get < ResultList < PeerTubePluginIndex > > ( PluginApiService . BASE_PLUGIN_URL + 's' , { params } ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } getPlugin ( npmName ) { const path = PluginApiService . BASE_PLUGIN_URL + 's' + npmName return this . authHttp . get < PeerTubePlugin > ( path ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } getPluginRegisteredSettings ( pluginName , pluginType ) { const npmName = this . pluginService . nameToNpmName ( pluginName , pluginType ) const path = PluginApiService . BASE_PLUGIN_URL + 's' + npmName + 's' return this . authHttp . get < RegisteredServerSettings > ( path ) . pipe ( switchMap ( res => this . translateSettingsLabel ( npmName , res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } updatePluginSettings ( pluginName , pluginType , settings ) { const npmName = this . pluginService . nameToNpmName ( pluginName , pluginType ) const path = PluginApiService . BASE_PLUGIN_URL + 's' + npmName + 's' return this . authHttp . put ( path , { settings } ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } uninstall ( pluginName , pluginType ) { const body = { npmName : this . pluginService . nameToNpmName ( pluginName , pluginType ) } return this . authHttp . post ( PluginApiService . BASE_PLUGIN_URL + 's' , body ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } update ( pluginName , pluginType ) { const body = { npmName : this . pluginService . nameToNpmName ( pluginName , pluginType ) } return this . authHttp . post ( PluginApiService . BASE_PLUGIN_URL + 's' , body ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } install ( npmName ) { const body = { npmName } return this . authHttp . post ( PluginApiService . BASE_PLUGIN_URL + 's' , body ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } private translateSettingsLabel ( npmName , res ) < RegisteredServerSettings > { return this . pluginService . translationsObservable . pipe ( map ( allTranslations => allTranslations [ npmName ] ) , map ( translations => { const registeredSettings = res . registeredSettings . map ( r => { return Object . assign ( { } , r , { label : peertubeTranslate ( r . label , translations ) } ) } ) return { registeredSettings } } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $I18n$ O O $PluginService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O $ComponentPagination$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O $ComponentPagination$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O $ManagePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O $ManagePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $InstallOrUpdatePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $string$ O $RegisteredServerSettings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { Debug } from 's' import { DebugService } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class DebugComponent implements OnInit { debug : Debug constructor ( private debugService , private notifier ) { } ngOnInit ( ) { this . load ( ) } load ( ) { this . debugService . getDebug ( ) . subscribe ( debug => this . debug = debug , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DebugService$ O O $Notifier$ O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError } from 's' import { HttpClient } from 's' import { Injectable } from 's' import { Observable } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { Debug } from 's' @ Injectable ( ) export class DebugService { private static BASE_DEBUG_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } getDebug ( ) < Debug > { return this . authHttp . get < Debug > ( DebugService . BASE_DEBUG_URL ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { SortMeta } from 's' import { Observable } from 's' import { ResultList } from 's' import { JobState } from 's' import { Job } from 's' import { environment } from 's' import { RestExtractor , RestPagination , RestService } from 's' @ Injectable ( ) export class JobService { private static BASE_JOB_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } getJobs ( state , pagination , sort ) < ResultList < Job > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < Job > > ( JobService . BASE_JOB_URL + 's' + state , { params } ) . pipe ( map ( res => { return this . restExtractor . convertResultListDateToHuman ( res , [ 's' , 's' , 's' ] ) } ) , map ( res => this . restExtractor . applyToResultListData ( res , this . prettyPrintData ) ) , map ( res => this . restExtractor . applyToResultListData ( res , this . buildUniqId ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } private prettyPrintData ( obj ) { const data = JSON . stringify ( obj . data , null , 0 ) return Object . assign ( obj , { data } ) } private buildUniqId ( obj ) { return Object . assign ( obj , { uniqId : `template` } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O $JobState$ O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Job$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Job$ O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { peertubeLocalStorage } from 's' import { Notifier } from 's' import { SortMeta } from 's' import { Job } from 's' import { JobState } from 's' import { RestPagination , RestTable } from 's' import { JobService } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class JobsComponent extends RestTable implements OnInit { private static JOB_STATE_LOCAL_STORAGE_STATE = 's' jobState : JobState = 's' jobStates : JobState [ ] = [ 's' , 's' , 's' , 's' , 's' ] jobs : Job [ ] = [ ] totalRecords : number rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private jobsService , private 0 ) { super ( ) } ngOnInit ( ) { this . loadJobState ( ) this . initialize ( ) } onJobStateChanged ( ) { this . pagination . start = 0 this . loadData ( ) this . saveJobState ( ) } protected loadData ( ) { this . jobsService . getJobs ( this . jobState , this . pagination , this . sort ) . subscribe ( resultList => { this . jobs = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } private loadJobState ( ) { const result = peertubeLocalStorage . getItem ( JobsComponent . JOB_STATE_LOCAL_STORAGE_STATE ) if ( result ) this . jobState = result as JobState } private saveJobState ( ) { peertubeLocalStorage . setItem ( JobsComponent . JOB_STATE_LOCAL_STORAGE_STATE , this . jobState ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $JobService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Component , ElementRef , OnInit , ViewChild } from 's' import { LogsService } from 's' import { Notifier } from 's' import { LogRow } from 's' import { 0 } from 's' import { LogLevel } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class LogsComponent implements OnInit { @ ViewChild ( 's' , { static : true } ) logsElement : ElementRef < HTMLElement > loading = false logs : LogRow [ ] = [ ] timeChoices : { id : string , label : string } [ ] = [ ] levelChoices : { id : LogLevel , label : string } [ ] = [ ] startDate : string level : LogLevel constructor ( private logsService , private notifier , private 0 ) { } ngOnInit ( ) { this . buildTimeChoices ( ) this . buildLevelChoices ( ) this . load ( ) } refresh ( ) { this . logs = [ ] this . load ( ) } load ( ) { this . loading = true this . logsService . getLogs ( this . level , this . startDate ) . subscribe ( logs => { this . logs = logs setTimeout ( ( ) => { this . logsElement . nativeElement . scrollIntoView ( { block : 's' , inline : 's' } ) } ) } , err => this . notifier . error ( err . message ) , ( ) => this . loading = false ) } buildTimeChoices ( ) { const lastHour = new Date ( ) lastHour . setHours ( lastHour . getHours ( ) - 0 ) const lastDay = new Date ( ) lastDay . setDate ( lastDay . getDate ( ) - 0 ) const lastWeek = new Date ( ) lastWeek . setDate ( lastWeek . getDate ( ) - 0 ) this . timeChoices = [ { id : lastWeek . toISOString ( ) , label : this . 0 ( 's' ) } , { id : lastDay . toISOString ( ) , label : this . 0 ( 's' ) } , { id : lastHour . toISOString ( ) , label : this . 0 ( 's' ) } ] this . startDate = lastHour . toISOString ( ) } buildLevelChoices ( ) { this . levelChoices = [ { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } ] this . level = 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogsService$ O O $Notifier$ O O $I18n$ O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { Observable } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { LogRow } from 's' import { LogLevel } from 's' @ Injectable ( ) export class LogsService { private static BASE_LOG_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } getLogs ( level , startDate , endDate ? ) < any [ ] > { let params = new HttpParams ( ) params = params . append ( 's' , startDate ) params = params . append ( 's' , level ) if ( endDate ) params . append ( 's' , endDate ) return this . authHttp . get < any [ ] > ( LogsService . BASE_LOG_URL , { params } ) . pipe ( map ( rows => rows . map ( r => new LogRow ( r ) ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O $LogLevel$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Component } from 's' import { UserRight } from 's' import { AuthService } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class SystemComponent { constructor ( private auth ) { } hasLogsRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_LOGS ) } hasJobsRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_JOBS ) } hasDebugRight ( ) { return this . auth . getUser ( ) . hasRight ( UserRight . MANAGE_DEBUG ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Routes } from 's' import { UserRightGuard } from 's' import { UserRight } from 's' import { JobsComponent } from 's' import { LogsComponent } from 's' import { SystemComponent } from 's' import { DebugComponent } from 's' export const SystemRoutes = [ { path : 's' , component : SystemComponent , data : { } , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , canActivate : [ UserRightGuard ] , component : JobsComponent , data : { meta : { userRight : UserRight . MANAGE_JOBS , title : 's' } } } , { path : 's' , canActivate : [ UserRightGuard ] , component : LogsComponent , data : { meta : { userRight : UserRight . MANAGE_LOGS , title : 's' } } } , { path : 's' , canActivate : [ UserRightGuard ] , component : DebugComponent , data : { meta : { userRight : UserRight . MANAGE_DEBUG , title : 's' } } } ] } ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O
import { LogLevel } from 's' import omit from 's' export class LogRow { date : Date localeDate : string level : LogLevel message : string meta : string constructor ( row ) { this . date = new Date ( row . timestamp ) this . localeDate = this . date . toLocaleString ( ) this . level = row . level this . message = row . message const metaObj = omit ( row , 's' , 's' , 's' , 's' ) if ( Object . keys ( metaObj ) . length !== 0 ) this . meta = JSON . stringify ( metaObj , undefined , 0 ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { ServerService } from 's' import { 0 } from 's' import { TopMenuDropdownParam } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountComponent { menuEntries : TopMenuDropdownParam [ ] = [ ] constructor ( private serverService , private 0 ) { const libraryEntries = { label : this . 0 ( 's' ) , children : [ { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } ] } if ( this . isVideoImportEnabled ( ) ) { libraryEntries . children . push ( { label : 's' , routerLink : 's' , iconName : 's' } ) } const miscEntries = { label : this . 0 ( 's' ) , children : [ { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' , iconName : 's' } ] } this . menuEntries = [ { label : this . 0 ( 's' ) , routerLink : 's' } , { label : this . 0 ( 's' ) , routerLink : 's' } , libraryEntries , miscEntries ] } isVideoImportEnabled ( ) { const importConfig = this . serverService . getConfig ( ) . import . videos return importConfig . http . enabled || importConfig . torrent . enabled } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O $I18n$ O O O $TopMenuDropdownParam$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TopMenuDropdownParam$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { BytesPipe } from 's' import { AuthService } from 's' import { User } from 's' import { UserService } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountSettingsComponent implements OnInit { user : User = null userVideoQuota = 's' userVideoQuotaUsed = 0 constructor ( private userService , private authService , private notifier , private 0 ) { } get userInformationLoaded ( ) { return this . authService . userInformationLoaded } ngOnInit ( ) { this . user = this . authService . getUser ( ) this . authService . userInformationLoaded . subscribe ( ( ) => { if ( this . user . videoQuota !== - 0 ) { this . userVideoQuota = new BytesPipe ( ) . transform ( this . user . videoQuota , 0 ) . toString ( ) } else { this . userVideoQuota = this . 0 ( 's' ) } } ) this . userService . getMyVideoQuotaUsed ( ) . subscribe ( data => this . userVideoQuotaUsed = data . videoQuotaUsed ) } onAvatarChange ( formData ) { this . userService . changeAvatar ( formData ) . subscribe ( data => { this . notifier . success ( this . 0 ( 's' ) ) this . user . updateAccountAvatar ( data . avatar ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $AuthService$ O O $Notifier$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , OnInit , ViewChild } from 's' import { Notifier } from 's' import { NgbModal } from 's' import { FormReactive , UserService } from 's' import { Video } from 's' import { 0 } from 's' import { FormValidatorService , VideoChangeOwnershipValidatorsService } from 's' import { VideoOwnershipService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoChangeOwnershipComponent extends FormReactive implements OnInit { @ ViewChild ( 's' , { static : true } ) modal : ElementRef usernamePropositions : string [ ] error : string = null private video : Video | undefined = undefined constructor ( protected formValidatorService , private videoChangeOwnershipValidatorsService , private videoOwnershipService , private notifier , private userService , private modalService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { username : this . videoChangeOwnershipValidatorsService . USERNAME } ) this . usernamePropositions = [ ] } show ( video ) { this . video = video this . modalService . open ( this . modal ) . result . then ( ( ) => this . changeOwnership ( ) ) . catch ( ( _ ) => _ ) } search ( event : { query : string } ) { const query = event . query this . userService . autocomplete ( query ) . subscribe ( usernames => this . usernamePropositions = usernames , err => this . notifier . error ( err . message ) ) } changeOwnership ( ) { const username = this . form . value [ 's' ] this . videoOwnershipService . changeOwnership ( this . video . id , username ) . subscribe ( ( ) => this . notifier . success ( this . 0 ( 's' ) ) , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $VideoChangeOwnershipValidatorsService$ O O $VideoOwnershipService$ O O $Notifier$ O O $UserService$ O O $NgbModal$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { concat , Observable } from 's' import { tap , toArray } from 's' import { Component , ViewChild } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { ComponentPagination } from 's' import { Notifier , ServerService } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { Video } from 's' import { VideoService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { VideoChangeOwnershipComponent } from 's' import { MiniatureDisplayOptions } from 's' import { SelectionType , VideosSelectionComponent } from 's' import { VideoSortField } from 's' import { DisableForReuseHook } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideosComponent implements DisableForReuseHook { @ ViewChild ( 's' , { static : true } ) videosSelection : VideosSelectionComponent @ ViewChild ( 's' , { static : true } ) videoChangeOwnershipModal : VideoChangeOwnershipComponent titlePage : string selection : SelectionType = { } pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } miniatureDisplayOptions : MiniatureDisplayOptions = { date : true , views : true , by : false , privacyLabel : false , privacyText : true , state : true , blacklistInfo : true } videos : Video [ ] = [ ] getVideosObservableFunction = this . getVideosObservable . bind ( this ) constructor ( protected router , protected serverService , protected route , protected authService , protected notifier , protected screenService , private 0 , private confirmService , private videoService ) { this . titlePage = this . 0 ( 's' ) } disableForReuse ( ) { this . videosSelection . disableForReuse ( ) } enabledForReuse ( ) { this . videosSelection . enabledForReuse ( ) } getVideosObservable ( page , sort ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) return this . videoService . getMyVideos ( newPagination , sort ) } async deleteSelectedVideos ( ) { const toDeleteVideosIds = Object . keys ( this . selection ) . filter ( k => this . selection [ k ] === true ) . map ( k => parseInt ( k , 0 ) ) const res = await this . confirmService . confirm ( this . 0 ( 's' , { deleteLength : toDeleteVideosIds . length } ) , this . 0 ( 's' ) ) if ( res === false ) return const observables : Observable < any > [ ] = [ ] for ( const videoId of toDeleteVideosIds ) { const o = this . videoService . removeVideo ( videoId ) . pipe ( tap ( ( ) => this . removeVideoFromArray ( videoId ) ) ) observables . push ( o ) } concat ( ... observables ) . pipe ( toArray ( ) ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { deleteLength : toDeleteVideosIds . length } ) ) this . selection = { } } , err => this . notifier . error ( err . message ) ) } async deleteVideo ( video ) { const res = await this . confirmService . confirm ( this . 0 ( 's' , { videoName : video . name } ) , this . 0 ( 's' ) ) if ( res === false ) return this . videoService . removeVideo ( video . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { videoName : video . name } ) ) this . removeVideoFromArray ( video . id ) } , error => this . notifier . error ( error . message ) ) } changeOwnership ( event , video ) { event . preventDefault ( ) this . videoChangeOwnershipModal . show ( video ) } private removeVideoFromArray ( id ) { this . videos = this . videos . filter ( v => v . id !== id ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $AuthService$ O O $Notifier$ O O $ScreenService$ O O $I18n$ O O $ConfirmService$ O O $VideoService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoSortField$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O $Video$ O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { LoginGuard } from 's' import { MyAccountComponent } from 's' import { MyAccountSettingsComponent } from 's' import { MyAccountVideosComponent } from 's' import { MyAccountVideoChannelsComponent } from 's' import { MyAccountVideoChannelCreateComponent } from 's' import { MyAccountVideoChannelUpdateComponent } from 's' import { MyAccountVideoImportsComponent } from 's' import { MyAccountSubscriptionsComponent } from 's' import { MyAccountOwnershipComponent } from 's' import { MyAccountBlocklistComponent } from 's' import { MyAccountServerBlocklistComponent } from 's' import { MyAccountHistoryComponent } from 's' import { MyAccountNotificationsComponent } from 's' import { MyAccountVideoPlaylistsComponent } from 's' import { MyAccountVideoPlaylistCreateComponent } from 's' import { MyAccountVideoPlaylistUpdateComponent } from 's' import { MyAccountVideoPlaylistElementsComponent } from 's' const myAccountRoutes = [ { path : 's' , component : MyAccountComponent , canActivateChild : [ MetaGuard , LoginGuard ] , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : MyAccountSettingsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoChannelsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoChannelCreateComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoChannelUpdateComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoPlaylistsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoPlaylistCreateComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoPlaylistElementsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideoPlaylistUpdateComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountVideosComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : MyAccountVideoImportsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountSubscriptionsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountOwnershipComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountBlocklistComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountServerBlocklistComponent , data : { meta : { title : 's' } } } , { path : 's' , component : MyAccountHistoryComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : MyAccountNotificationsComponent , data : { meta : { title : 's' } } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( myAccountRoutes ) ] , exports : [ RouterModule ] } ) export class MyAccountRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { AuthService , Notifier } from 's' import { FormReactive , UserService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' import { filter } from 's' import { User } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountChangePasswordComponent extends FormReactive implements OnInit { error : string = null user : User = null constructor ( protected formValidatorService , private userValidatorsService , private notifier , private authService , private userService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { 's' : this . userValidatorsService . USER_PASSWORD , 's' : this . userValidatorsService . USER_PASSWORD , 's' : this . userValidatorsService . USER_CONFIRM_PASSWORD } ) this . user = this . authService . getUser ( ) const confirmPasswordControl = this . form . get ( 's' ) confirmPasswordControl . valueChanges . pipe ( filter ( v => v !== this . form . value [ 's' ] ) ) . subscribe ( ( ) => confirmPasswordControl . setErrors ( { matchPassword : true } ) ) } changePassword ( ) { const currentPassword = this . form . value [ 's' ] const newPassword = this . form . value [ 's' ] this . userService . changePassword ( currentPassword , newPassword ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . form . reset ( ) this . error = null } , err => { if ( err . status === 0 ) { this . error = this . 0 ( 's' ) return } this . error = err . message } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O $Notifier$ O O $AuthService$ O O $UserService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit } from 's' import { Notifier , ServerService } from 's' import { UserUpdateMe } from 's' import { AuthService } from 's' import { FormReactive , User , UserService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { forkJoin , Subject } from 's' import { SelectItem } from 's' import { first } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoSettingsComponent extends FormReactive implements OnInit { @ Input ( ) user : User = null @ Input ( ) userInformationLoaded : Subject < any > languageItems : SelectItem [ ] = [ ] constructor ( protected formValidatorService , private authService , private notifier , private userService , private serverService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { nsfwPolicy : null , webTorrentEnabled : null , autoPlayVideo : null , autoPlayNextVideo : null , videoLanguages : null } ) forkJoin ( [ this . serverService . videoLanguagesLoaded . pipe ( first ( ) ) , this . userInformationLoaded . pipe ( first ( ) ) ] ) . subscribe ( ( ) => { const languages = this . serverService . getVideoLanguages ( ) this . languageItems = [ { label : this . 0 ( 's' ) , value : 's' } ] this . languageItems = this . languageItems . concat ( languages . map ( l => ( { label : l . label , value : l . id } ) ) ) const videoLanguages = this . user . videoLanguages ? this . user . videoLanguages : this . languageItems . map ( l => l . value ) this . form . patchValue ( { nsfwPolicy : this . user . nsfwPolicy , webTorrentEnabled : this . user . webTorrentEnabled , autoPlayVideo : this . user . autoPlayVideo === true , autoPlayNextVideo : this . user . autoPlayNextVideo , videoLanguages } ) } ) } updateDetails ( ) { const nsfwPolicy = this . form . value [ 's' ] const webTorrentEnabled = this . form . value [ 's' ] const autoPlayVideo = this . form . value [ 's' ] const autoPlayNextVideo = this . form . value [ 's' ] let videoLanguages : string [ ] = this . form . value [ 's' ] if ( Array . isArray ( videoLanguages ) ) { if ( videoLanguages . length === this . languageItems . length ) { videoLanguages = null } else if ( videoLanguages . length > 0 ) { this . notifier . error ( 's' ) return } else if ( videoLanguages . length === 0 ) { this . notifier . error ( 's' ) return } } const details = { nsfwPolicy , webTorrentEnabled , autoPlayVideo , autoPlayNextVideo , videoLanguages } this . userService . updateMyProfile ( details ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . authService . refreshUserInformation ( ) } , err => this . notifier . error ( err . message ) ) } getDefaultVideoLanguageLabel ( ) { return this . 0 ( 's' ) } getSelectedVideoLanguageLabel ( ) { return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $Notifier$ O O $UserService$ O O $ServerService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , EventEmitter , OnInit , Output , ViewChild } from 's' import { AuthService , Notifier } from 's' import { FormReactive } from 's' import { FormValidatorService } from 's' import { VideoOwnershipService } from 's' import { VideoChangeOwnership } from 's' import { VideoAcceptOwnershipValidatorsService } from 's' import { VideoChannel } from 's' import { VideoChannelService } from 's' import { 0 } from 's' import { NgbModal } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountAcceptOwnershipComponent extends FormReactive implements OnInit { @ Output ( ) accepted = new EventEmitter < void > ( ) @ ViewChild ( 's' , { static : true } ) modal : ElementRef videoChangeOwnership : VideoChangeOwnership | undefined = undefined videoChannels : VideoChannel [ ] error : string = null constructor ( protected formValidatorService , private videoChangeOwnershipValidatorsService , private videoOwnershipService , private notifier , private authService , private videoChannelService , private modalService , private 0 ) { super ( ) } ngOnInit ( ) { this . videoChannels = [ ] this . videoChannelService . listAccountVideoChannels ( this . authService . getUser ( ) . account ) . subscribe ( videoChannels => this . videoChannels = videoChannels . data ) this . buildForm ( { channel : this . videoChangeOwnershipValidatorsService . CHANNEL } ) } show ( videoChangeOwnership ) { this . videoChangeOwnership = videoChangeOwnership this . modalService . open ( this . modal ) . result . then ( ( ) => this . acceptOwnership ( ) ) . catch ( ( ) => this . videoChangeOwnership = undefined ) } acceptOwnership ( ) { const channel = this . form . value [ 's' ] const videoChangeOwnership = this . videoChangeOwnership this . videoOwnershipService . acceptOwnership ( videoChangeOwnership . id , { channelId : channel } ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) if ( this . accepted ) this . accepted . emit ( ) this . videoChangeOwnership = undefined } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $VideoAcceptOwnershipValidatorsService$ O O $VideoOwnershipService$ O O $Notifier$ O O $AuthService$ O O $VideoChannelService$ O O $NgbModal$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChangeOwnership$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { Notifier } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { VideoChangeOwnership } from 's' import { VideoOwnershipService } from 's' import { Account } from 's' import { MyAccountAcceptOwnershipComponent } from 's' @ Component ( { selector : 's' , templateUrl : 's' } ) export class MyAccountOwnershipComponent extends RestTable implements OnInit { videoChangeOwnerships : VideoChangeOwnership [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } @ ViewChild ( 's' , { static : true } ) myAccountAcceptOwnershipComponent : MyAccountAcceptOwnershipComponent constructor ( private notifier , private videoOwnershipService ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } createByString ( account ) { return Account . CREATE_BY_STRING ( account . name , account . host ) } openAcceptModal ( videoChangeOwnership ) { this . myAccountAcceptOwnershipComponent . show ( videoChangeOwnership ) } accepted ( ) { this . loadData ( ) } refuse ( videoChangeOwnership ) { this . videoOwnershipService . refuseOwnership ( videoChangeOwnership . id ) . subscribe ( ( ) => this . loadData ( ) , err => this . notifier . error ( err . message ) ) } protected loadData ( ) { return this . videoOwnershipService . getOwnershipChanges ( this . pagination , this . sort ) . subscribe ( resultList => { this . videoChangeOwnerships = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $VideoOwnershipService$ O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O $VideoChangeOwnership$ O O O O O O O O O O O O O O O O O O O O O O O $VideoChangeOwnership$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TableModule } from 's' import { NgModule } from 's' import { AutoCompleteModule } from 's' import { InputSwitchModule } from 's' import { SharedModule } from 's' import { MyAccountRoutingModule } from 's' import { MyAccountChangePasswordComponent } from 's' import { MyAccountVideoSettingsComponent } from 's' import { MyAccountSettingsComponent } from 's' import { MyAccountComponent } from 's' import { MyAccountVideosComponent } from 's' import { VideoChangeOwnershipComponent } from 's' import { MyAccountOwnershipComponent } from 's' import { MyAccountAcceptOwnershipComponent } from 's' import { MyAccountProfileComponent } from 's' import { MyAccountVideoChannelsComponent } from 's' import { MyAccountVideoChannelCreateComponent } from 's' import { MyAccountVideoChannelUpdateComponent } from 's' import { ActorAvatarInfoComponent } from 's' import { MyAccountVideoImportsComponent } from 's' import { MyAccountDangerZoneComponent } from 's' import { MyAccountSubscriptionsComponent } from 's' import { MyAccountBlocklistComponent } from 's' import { MyAccountServerBlocklistComponent } from 's' import { MyAccountHistoryComponent } from 's' import { MyAccountNotificationsComponent } from 's' import { MyAccountNotificationPreferencesComponent } from 's' import { MyAccountVideoPlaylistCreateComponent } from 's' import { MyAccountVideoPlaylistUpdateComponent } from 's' import { MyAccountVideoPlaylistsComponent } from 's' import { MyAccountVideoPlaylistElementsComponent } from 's' import { DragDropModule } from 's' import { MyAccountChangeEmailComponent } from 's' import { MyAccountInterfaceSettingsComponent } from 's' @ NgModule ( { imports : [ TableModule , MyAccountRoutingModule , AutoCompleteModule , SharedModule , TableModule , InputSwitchModule , DragDropModule ] , declarations : [ MyAccountComponent , MyAccountSettingsComponent , MyAccountChangePasswordComponent , MyAccountVideoSettingsComponent , MyAccountProfileComponent , MyAccountChangeEmailComponent , MyAccountInterfaceSettingsComponent , MyAccountVideosComponent , VideoChangeOwnershipComponent , MyAccountOwnershipComponent , MyAccountAcceptOwnershipComponent , MyAccountVideoChannelsComponent , MyAccountVideoChannelCreateComponent , MyAccountVideoChannelUpdateComponent , ActorAvatarInfoComponent , MyAccountVideoImportsComponent , MyAccountDangerZoneComponent , MyAccountSubscriptionsComponent , MyAccountBlocklistComponent , MyAccountServerBlocklistComponent , MyAccountHistoryComponent , MyAccountNotificationsComponent , MyAccountNotificationPreferencesComponent , MyAccountVideoPlaylistCreateComponent , MyAccountVideoPlaylistUpdateComponent , MyAccountVideoPlaylistsComponent , MyAccountVideoPlaylistElementsComponent ] , exports : [ MyAccountComponent ] , providers : [ ] } ) export class MyAccountModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { 0 } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { AccountBlock , BlocklistService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class MyAccountBlocklistComponent extends RestTable implements OnInit { blockedAccounts : AccountBlock [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private blocklistService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } unblockAccount ( accountBlock ) { const blockedAccount = accountBlock . blockedAccount this . blocklistService . unblockAccountByUser ( blockedAccount ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : blockedAccount . nameWithHost } ) ) this . loadData ( ) } ) } protected loadData ( ) { return this . blocklistService . getUserAccountBlocklist ( this . pagination , this . sort ) . subscribe ( resultList => { this . blockedAccounts = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $BlocklistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O $AccountBlock$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { 0 } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { ServerBlock } from 's' import { BlocklistService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class MyAccountServerBlocklistComponent extends RestTable implements OnInit { blockedServers : ServerBlock [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : - 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private blocklistService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } unblockServer ( serverBlock ) { const host = serverBlock . blockedServer . host this . blocklistService . unblockServerByUser ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . loadData ( ) } ) } protected loadData ( ) { return this . blocklistService . getUserServerBlocklist ( this . pagination , this . sort ) . subscribe ( resultList => { this . blockedServers = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $BlocklistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O $ServerBlock$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { ComponentPagination } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { AbstractVideoList } from 's' import { VideoService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { UserHistoryService } from 's' import { UserService } from 's' import { Notifier , ServerService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountHistoryComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } videosHistoryEnabled : boolean constructor ( protected 0 , protected router , protected serverService , protected route , protected authService , protected userService , protected notifier , protected screenService , private confirmService , private videoService , private userHistoryService ) { super ( ) this . titlePage = this . 0 ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) this . videosHistoryEnabled = this . authService . getUser ( ) . videosHistoryEnabled } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) return this . userHistoryService . getUserVideosHistory ( newPagination ) } generateSyndicationList ( ) { throw new Error ( 's' ) } onVideosHistoryChange ( ) { this . userService . updateMyProfile ( { videosHistoryEnabled : this . videosHistoryEnabled } ) . subscribe ( ( ) => { const message = this . videosHistoryEnabled === true ? this . 0 ( 's' ) : this . 0 ( 's' ) this . notifier . success ( message ) this . authService . refreshUserInformation ( ) } , err => this . notifier . error ( err . message ) ) } async deleteHistory ( ) { const title = this . 0 ( 's' ) const message = this . 0 ( 's' ) const res = await this . confirmService . confirm ( message , title ) if ( res !== true ) return this . userHistoryService . deleteUserVideosHistory ( ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . reloadVideos ( ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $AuthService$ O O $UserService$ O O $Notifier$ O O $ScreenService$ O O $ConfirmService$ O O $VideoService$ O O $UserHistoryService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ViewChild } from 's' import { UserNotificationsComponent } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountNotificationsComponent { @ ViewChild ( 's' , { static : true } ) userNotification : UserNotificationsComponent markAllAsRead ( ) { this . userNotification . markAllAsRead ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { AuthService , Notifier , ServerService } from 's' import { FormReactive , UserService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' import { User } from 's' import { tap } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountChangeEmailComponent extends FormReactive implements OnInit { error : string = null success : string = null user : User = null constructor ( protected formValidatorService , private userValidatorsService , private notifier , private authService , private userService , private serverService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { 's' : this . userValidatorsService . USER_EMAIL , 's' : this . userValidatorsService . USER_PASSWORD } ) this . user = this . authService . getUser ( ) } changeEmail ( ) { this . error = null this . success = null const password = this . form . value [ 's' ] const email = this . form . value [ 's' ] this . userService . changeEmail ( password , email ) . pipe ( tap ( ( ) => this . authService . refreshUserInformation ( ) ) ) . subscribe ( ( ) => { this . form . reset ( ) if ( this . serverService . getConfig ( ) . signup . requiresEmailVerification ) { this . success = this . 0 ( 's' ) } else { this . success = this . 0 ( 's' ) } } , err => { if ( err . status === 0 ) { this . error = this . 0 ( 's' ) return } this . error = err . message } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O $Notifier$ O O $AuthService$ O O $UserService$ O O $ServerService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export * from 's'	O O O O
import { Component , Input } from 's' import { Notifier } from 's' import { AuthService , ConfirmService , RedirectService } from 's' import { UserService } from 's' import { 0 } from 's' import { User } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountDangerZoneComponent { @ Input ( ) user : User = null constructor ( private authService , private notifier , private userService , private confirmService , private redirectService , private 0 ) { } async deleteMe ( ) { const res = await this . confirmService . confirmWithInput ( this . 0 ( 's' ) , this . 0 ( 's' ) , this . user . username , this . 0 ( 's' ) , this . 0 ( 's' ) ) if ( res === false ) return this . userService . deleteMe ( ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . authService . logout ( ) this . redirectService . redirectToHomepage ( ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $UserService$ O O $ConfirmService$ O O $RedirectService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , Input , OnInit } from 's' import { Notifier , ServerService } from 's' import { UserUpdateMe } from 's' import { AuthService } from 's' import { FormReactive , User , UserService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountInterfaceSettingsComponent extends FormReactive implements OnInit { @ Input ( ) user : User = null @ Input ( ) userInformationLoaded : Subject < any > constructor ( protected formValidatorService , private authService , private notifier , private userService , private serverService , private 0 ) { super ( ) } get availableThemes ( ) { return this . serverService . getConfig ( ) . theme . registered . map ( t => t . name ) } ngOnInit ( ) { this . buildForm ( { theme : null } ) this . userInformationLoaded . subscribe ( ( ) => { this . form . patchValue ( { theme : this . user . theme } ) } ) } updateInterfaceSettings ( ) { const theme = this . form . value [ 's' ] const details = { theme } this . userService . updateMyProfile ( details ) . subscribe ( ( ) => { this . authService . refreshUserInformation ( ) this . notifier . success ( this . 0 ( 's' ) ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $Notifier$ O O $UserService$ O O $ServerService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , Input , OnInit } from 's' import { User } from 's' import { 0 } from 's' import { Subject } from 's' import { UserNotificationSetting , UserNotificationSettingValue , UserRight } from 's' import { Notifier , ServerService } from 's' import { debounce } from 's' import { UserNotificationService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountNotificationPreferencesComponent implements OnInit { @ Input ( ) user : User = null @ Input ( ) userInformationLoaded : Subject < any > notificationSettingKeys : ( keyof UserNotificationSetting ) [ ] = [ ] emailNotifications : { [ id in keyof UserNotificationSetting ] : boolean } = { } as any webNotifications : { [ id in keyof UserNotificationSetting ] : boolean } = { } as any labelNotifications : { [ id in keyof UserNotificationSetting ] : string } = { } as any rightNotifications : { [ id in keyof Partial < UserNotificationSetting > ] : UserRight } = { } as any emailEnabled : boolean private savePreferences = debounce ( this . savePreferencesImpl . bind ( this ) , 0 ) constructor ( private 0 , private userNotificationService , private serverService , private notifier ) { this . labelNotifications = { newVideoFromSubscription : this . 0 ( 's' ) , newCommentOnMyVideo : this . 0 ( 's' ) , videoAbuseAsModerator : this . 0 ( 's' ) , videoAutoBlacklistAsModerator : this . 0 ( 's' ) , blacklistOnMyVideo : this . 0 ( 's' ) , myVideoPublished : this . 0 ( 's' ) , myVideoImportFinished : this . 0 ( 's' ) , newUserRegistration : this . 0 ( 's' ) , newFollow : this . 0 ( 's' ) , commentMention : this . 0 ( 's' ) , newInstanceFollower : this . 0 ( 's' ) , autoInstanceFollowing : this . 0 ( 's' ) } this . notificationSettingKeys = Object . keys ( this . labelNotifications ) as ( keyof UserNotificationSetting ) [ ] this . rightNotifications = { videoAbuseAsModerator : UserRight . MANAGE_VIDEO_ABUSES , videoAutoBlacklistAsModerator : UserRight . MANAGE_VIDEO_BLACKLIST , newUserRegistration : UserRight . MANAGE_USERS , newInstanceFollower : UserRight . MANAGE_SERVER_FOLLOW , autoInstanceFollowing : UserRight . MANAGE_CONFIGURATION } this . emailEnabled = this . serverService . getConfig ( ) . email . enabled } ngOnInit ( ) { this . userInformationLoaded . subscribe ( ( ) => this . loadNotificationSettings ( ) ) } hasUserRight ( field : keyof UserNotificationSetting ) { const rightToHave = this . rightNotifications [ field ] if ( ! rightToHave ) return true return this . user . hasRight ( rightToHave ) } updateEmailSetting ( field : keyof UserNotificationSetting , value ) { if ( value === true ) this . user . notificationSettings [ field ] |= UserNotificationSettingValue . EMAIL else this . user . notificationSettings [ field ] &= ~ UserNotificationSettingValue . EMAIL this . savePreferences ( ) } updateWebSetting ( field : keyof UserNotificationSetting , value ) { if ( value === true ) this . user . notificationSettings [ field ] |= UserNotificationSettingValue . WEB else this . user . notificationSettings [ field ] &= ~ UserNotificationSettingValue . WEB this . savePreferences ( ) } private savePreferencesImpl ( ) { this . userNotificationService . updateNotificationSettings ( this . user , this . user . notificationSettings ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) , undefined , 0 ) } , err => this . notifier . error ( err . message ) ) } private loadNotificationSettings ( ) { for ( const key of Object . keys ( this . user . notificationSettings ) ) { const value = this . user . notificationSettings [ key ] this . emailNotifications [ key ] = value & UserNotificationSettingValue . EMAIL this . webNotifications [ key ] = value & UserNotificationSettingValue . WEB } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $UserNotificationService$ O O $ServerService$ O O $Notifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , Input , OnInit } from 's' import { Notifier } from 's' import { FormReactive , UserService } from 's' import { User } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { Subject } from 's' import { UserValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountProfileComponent extends FormReactive implements OnInit { @ Input ( ) user : User = null @ Input ( ) userInformationLoaded : Subject < any > error : string = null constructor ( protected formValidatorService , private userValidatorsService , private notifier , private userService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { 's' : this . userValidatorsService . USER_DISPLAY_NAME_REQUIRED , description : this . userValidatorsService . USER_DESCRIPTION } ) this . userInformationLoaded . subscribe ( ( ) => { this . form . patchValue ( { 's' : this . user . account . displayName , description : this . user . account . description } ) } ) } updateMyProfile ( ) { const displayName = this . form . value [ 's' ] const description = this . form . value [ 's' ] || null this . error = null this . userService . updateMyProfile ( { displayName , description } ) . subscribe ( ( ) => { this . user . account . displayName = displayName this . user . account . description = description this . notifier . success ( this . 0 ( 's' ) ) } , err => this . error = err . message ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O $Notifier$ O O $UserService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export * from 's'	O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { VideoChannel } from 's' import { UserSubscriptionService } from 's' import { ComponentPagination } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountSubscriptionsComponent implements OnInit { videoChannels : VideoChannel [ ] = [ ] pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } onDataSubject = new Subject < any [ ] > ( ) constructor ( private userSubscriptionService , private notifier ) { } ngOnInit ( ) { this . loadSubscriptions ( ) } loadSubscriptions ( ) { this . userSubscriptionService . listSubscriptions ( this . pagination ) . subscribe ( res => { this . videoChannels = this . videoChannels . concat ( res . data ) this . pagination . totalItems = res . total this . onDataSubject . next ( res . data ) } , error => this . notifier . error ( error . message ) ) } onNearOfBottom ( ) { if ( this . pagination . totalItems <= ( this . pagination . currentPage * this . pagination . itemsPerPage ) ) return this . pagination . currentPage += 0 this . loadSubscriptions ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserSubscriptionService$ O O $Notifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FormReactive } from 's' import { VideoChannel } from 's' export abstract class MyAccountVideoChannelEdit extends FormReactive { videoChannelToUpdate : VideoChannel instanceHost : string abstract isCreation ( ) abstract getFormButtonTitle ( ) onAvatarChange ( formData ) { } isBulkUpdateVideosDisplayed ( ) { return false } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O $string$ O O O O $FormData$ O O O O O O O O O O O
import { Component , OnInit } from 's' import { Router } from 's' import { AuthService , Notifier } from 's' import { MyAccountVideoChannelEdit } from 's' import { VideoChannelCreate } from 's' import { VideoChannelService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { VideoChannelValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoChannelCreateComponent extends MyAccountVideoChannelEdit implements OnInit { error : string constructor ( protected formValidatorService , private authService , private videoChannelValidatorsService , private notifier , private router , private videoChannelService , private 0 ) { super ( ) } get instanceHost ( ) { return window . location . host } ngOnInit ( ) { this . buildForm ( { name : this . videoChannelValidatorsService . VIDEO_CHANNEL_NAME , 's' : this . videoChannelValidatorsService . VIDEO_CHANNEL_DISPLAY_NAME , description : this . videoChannelValidatorsService . VIDEO_CHANNEL_DESCRIPTION , support : this . videoChannelValidatorsService . VIDEO_CHANNEL_SUPPORT } ) } formValidated ( ) { this . error = undefined const body = this . form . value const videoChannelCreate = { name : body . name , displayName : body [ 's' ] , description : body . description || null , support : body . support || null } this . videoChannelService . createVideoChannel ( videoChannelCreate ) . subscribe ( ( ) => { this . authService . refreshUserInformation ( ) this . notifier . success ( this . 0 ( 's' , { videoChannelName : videoChannelCreate . displayName } ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => { if ( err . status === 0 ) { this . error = this . 0 ( 's' ) return } this . error = err . message } ) } isCreation ( ) { return true } getFormButtonTitle ( ) { return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $VideoChannelValidatorsService$ O O $Notifier$ O O $Router$ O O $VideoChannelService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { AuthService , Notifier , ServerService } from 's' import { MyAccountVideoChannelEdit } from 's' import { VideoChannelUpdate } from 's' import { VideoChannelService } from 's' import { Subscription } from 's' import { VideoChannel } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { VideoChannelValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoChannelUpdateComponent extends MyAccountVideoChannelEdit implements OnInit , OnDestroy { error : string videoChannelToUpdate : VideoChannel private paramsSub : Subscription private oldSupportField : string constructor ( protected formValidatorService , private authService , private videoChannelValidatorsService , private notifier , private router , private route , private videoChannelService , private 0 , private serverService ) { super ( ) } ngOnInit ( ) { this . buildForm ( { 's' : this . videoChannelValidatorsService . VIDEO_CHANNEL_DISPLAY_NAME , description : this . videoChannelValidatorsService . VIDEO_CHANNEL_DESCRIPTION , support : this . videoChannelValidatorsService . VIDEO_CHANNEL_SUPPORT , bulkVideosSupportUpdate : null } ) this . paramsSub = this . route . params . subscribe ( routeParams => { const videoChannelId = routeParams [ 's' ] this . videoChannelService . getVideoChannel ( videoChannelId ) . subscribe ( videoChannelToUpdate => { this . videoChannelToUpdate = videoChannelToUpdate this . oldSupportField = videoChannelToUpdate . support this . form . patchValue ( { 's' : videoChannelToUpdate . displayName , description : videoChannelToUpdate . description , support : videoChannelToUpdate . support } ) } , err => this . error = err . message ) } ) } ngOnDestroy ( ) { if ( this . paramsSub ) this . paramsSub . unsubscribe ( ) } formValidated ( ) { this . error = undefined const body = this . form . value const videoChannelUpdate = { displayName : body [ 's' ] , description : body . description || null , support : body . support || null , bulkVideosSupportUpdate : body . bulkVideosSupportUpdate || false } this . videoChannelService . updateVideoChannel ( this . videoChannelToUpdate . name , videoChannelUpdate ) . subscribe ( ( ) => { this . authService . refreshUserInformation ( ) this . notifier . success ( this . 0 ( 's' , { videoChannelName : videoChannelUpdate . displayName } ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => this . error = err . message ) } onAvatarChange ( formData ) { this . videoChannelService . changeVideoChannelAvatar ( this . videoChannelToUpdate . name , formData ) . subscribe ( data => { this . notifier . success ( this . 0 ( 's' ) ) this . videoChannelToUpdate . updateAvatar ( data . avatar ) } , err => this . notifier . error ( err . message ) ) } get maxAvatarSize ( ) { return this . serverService . getConfig ( ) . avatar . file . size . max } get avatarExtensions ( ) { return this . serverService . getConfig ( ) . avatar . file . extensions . join ( 's' ) } isCreation ( ) { return false } getFormButtonTitle ( ) { return this . 0 ( 's' ) } isBulkUpdateVideosDisplayed ( ) { if ( this . oldSupportField === undefined ) return false return this . oldSupportField !== this . form . value [ 's' ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $VideoChannelValidatorsService$ O O $Notifier$ O O $Router$ O O $ActivatedRoute$ O O $VideoChannelService$ O O $I18n$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { VideoChannel } from 's' import { VideoChannelService } from 's' import { User } from 's' import { flatMap } from 's' import { 0 } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoChannelsComponent implements OnInit { videoChannels : VideoChannel [ ] = [ ] private user : User constructor ( private authService , private notifier , private confirmService , private videoChannelService , private 0 ) { } ngOnInit ( ) { this . user = this . authService . getUser ( ) this . loadVideoChannels ( ) } async deleteVideoChannel ( videoChannel ) { const res = await this . confirmService . confirmWithInput ( this . 0 ( 's' , { channelDisplayName : videoChannel . displayName , channelName : videoChannel . name } ) , this . 0 ( 's' , { displayName : videoChannel . displayName } ) , videoChannel . displayName , this . 0 ( 's' ) ) if ( res === false ) return this . videoChannelService . removeVideoChannel ( videoChannel ) . subscribe ( ( ) => { this . loadVideoChannels ( ) this . notifier . success ( this . 0 ( 's' , { videoChannelName : videoChannel . displayName } ) ) } , error => this . notifier . error ( error . message ) ) } private loadVideoChannels ( ) { this . authService . userInformationLoaded . pipe ( flatMap ( ( ) => this . videoChannelService . listAccountVideoChannels ( this . user . account ) ) ) . subscribe ( res => this . videoChannels = res . data ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $VideoChannelService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { RestPagination , RestTable } from 's' import { SortMeta } from 's' import { Notifier } from 's' import { 0 } from 's' import { VideoImport , VideoImportState } from 's' import { VideoImportService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoImportsComponent extends RestTable implements OnInit { videoImports : VideoImport [ ] = [ ] totalRecords = 0 rowsPerPage = 0 sort : SortMeta = { field : 's' , order : 0 } pagination : RestPagination = { count : this . rowsPerPage , start : 0 } constructor ( private notifier , private videoImportService , private 0 ) { super ( ) } ngOnInit ( ) { this . initialize ( ) } isVideoImportSuccess ( videoImport ) { return videoImport . state . id === VideoImportState . SUCCESS } isVideoImportPending ( videoImport ) { return videoImport . state . id === VideoImportState . PENDING } isVideoImportFailed ( videoImport ) { return videoImport . state . id === VideoImportState . FAILED } getVideoUrl ( video : { uuid : string } ) { return 's' + video . uuid } getEditVideoUrl ( video : { uuid : string } ) { return 's' + video . uuid } protected loadData ( ) { this . videoImportService . getMyVideoImports ( this . pagination , this . sort ) . subscribe ( resultList => { this . videoImports = resultList . data this . totalRecords = resultList . total } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $VideoImportService$ O O $I18n$ O O O O O O O O O O O O O O O O O O $VideoImport$ O O O O O O O O O O O O O O O $VideoImport$ O O O O O O O O O O O O O O O $VideoImport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FormReactive } from 's' import { VideoPlaylist } from 's' import { VideoConstant , VideoPlaylistPrivacy } from 's' export abstract class MyAccountVideoPlaylistEdit extends FormReactive { videoPlaylistToUpdate : VideoPlaylist userVideoChannels : { id : number , label : string } [ ] = [ ] videoPlaylistPrivacies : VideoConstant < VideoPlaylistPrivacy > [ ] = [ ] abstract isCreation ( ) abstract getFormButtonTitle ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O $string$ O O O
import { Component , OnInit } from 's' import { Router } from 's' import { AuthService , Notifier , ServerService } from 's' import { MyAccountVideoPlaylistEdit } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { VideoPlaylistValidatorsService } from 's' import { VideoPlaylistCreate } from 's' import { VideoPlaylistService } from 's' import { VideoPlaylistPrivacy } from 's' import { populateAsyncUserVideoChannels } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoPlaylistCreateComponent extends MyAccountVideoPlaylistEdit implements OnInit { error : string constructor ( protected formValidatorService , private authService , private videoPlaylistValidatorsService , private notifier , private router , private videoPlaylistService , private serverService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { displayName : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_DISPLAY_NAME , privacy : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_PRIVACY , description : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_DESCRIPTION , videoChannelId : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_CHANNEL_ID , thumbnailfile : null } ) this . form . get ( 's' ) . valueChanges . subscribe ( privacy => { this . videoPlaylistValidatorsService . setChannelValidator ( this . form . get ( 's' ) , privacy ) } ) populateAsyncUserVideoChannels ( this . authService , this . userVideoChannels ) . catch ( err => console . error ( 's' , err ) ) this . serverService . videoPlaylistPrivaciesLoaded . subscribe ( ( ) => { this . videoPlaylistPrivacies = this . serverService . getVideoPlaylistPrivacies ( ) this . form . patchValue ( { privacy : VideoPlaylistPrivacy . PRIVATE } ) } ) } formValidated ( ) { this . error = undefined const body = this . form . value const videoPlaylistCreate = { displayName : body . displayName , privacy : body . privacy , description : body . description || null , videoChannelId : body . videoChannelId || null , thumbnailfile : body . thumbnailfile || null } this . videoPlaylistService . createVideoPlaylist ( videoPlaylistCreate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { playlistName : videoPlaylistCreate . displayName } ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => this . error = err . message ) } isCreation ( ) { return true } getFormButtonTitle ( ) { return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $VideoPlaylistValidatorsService$ O O $Notifier$ O O $Router$ O O $VideoPlaylistService$ O O $ServerService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { Notifier , ServerService } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { ComponentPagination } from 's' import { Subject , Subscription } from 's' import { ActivatedRoute } from 's' import { VideoPlaylistService } from 's' import { VideoPlaylist } from 's' import { 0 } from 's' import { CdkDragDrop } from 's' import { VideoPlaylistElement } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoPlaylistElementsComponent implements OnInit , OnDestroy { playlistElements : VideoPlaylistElement [ ] = [ ] playlist : VideoPlaylist pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } onDataSubject = new Subject < any [ ] > ( ) private videoPlaylistId : string | number private paramsSub : Subscription constructor ( private authService , private serverService , private notifier , private confirmService , private route , private 0 , private videoPlaylistService ) { } ngOnInit ( ) { this . paramsSub = this . route . params . subscribe ( routeParams => { this . videoPlaylistId = routeParams [ 's' ] this . loadElements ( ) this . loadPlaylistInfo ( ) } ) } ngOnDestroy ( ) { if ( this . paramsSub ) this . paramsSub . unsubscribe ( ) } drop ( event < any > ) { const previousIndex = event . previousIndex const newIndex = event . currentIndex if ( previousIndex === newIndex ) return const oldPosition = this . playlistElements [ previousIndex ] . position let insertAfter = this . playlistElements [ newIndex ] . position if ( oldPosition > insertAfter ) insertAfter -- const element = this . playlistElements [ previousIndex ] this . playlistElements . splice ( previousIndex , 0 ) this . playlistElements . splice ( newIndex , 0 , element ) this . videoPlaylistService . reorderPlaylist ( this . playlist . id , oldPosition , insertAfter ) . subscribe ( ( ) => { this . reorderClientPositions ( ) } , err => this . notifier . error ( err . message ) ) } onElementRemoved ( element ) { const oldFirst = this . findFirst ( ) this . playlistElements = this . playlistElements . filter ( v => v . id !== element . id ) this . reorderClientPositions ( oldFirst ) } onNearOfBottom ( ) { if ( this . pagination . totalItems <= ( this . pagination . currentPage * this . pagination . itemsPerPage ) ) return this . pagination . currentPage += 0 this . loadElements ( ) } trackByFn ( index , elem ) { return elem . id } private loadElements ( ) { this . videoPlaylistService . getPlaylistVideos ( this . videoPlaylistId , this . pagination ) . subscribe ( ( { total , data } ) => { this . playlistElements = this . playlistElements . concat ( data ) this . pagination . totalItems = total this . onDataSubject . next ( data ) } ) } private loadPlaylistInfo ( ) { this . videoPlaylistService . getVideoPlaylist ( this . videoPlaylistId ) . subscribe ( playlist => { this . playlist = playlist } ) } private reorderClientPositions ( first ? ) { if ( this . playlistElements . length === 0 ) return const oldFirst = first || this . findFirst ( ) let i = 0 for ( const element of this . playlistElements ) { element . position = i i ++ } const newFirst = this . findFirst ( ) if ( oldFirst && newFirst && oldFirst . id !== newFirst . id ) { this . playlist . refreshThumbnail ( ) } } private findFirst ( ) { return this . playlistElements . find ( e => e . position === 0 ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $ServerService$ O O $Notifier$ O O $ConfirmService$ O O $ActivatedRoute$ O O $I18n$ O O $VideoPlaylistService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CdkDragDrop$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { AuthService , Notifier , ServerService } from 's' import { Subscription } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { MyAccountVideoPlaylistEdit } from 's' import { populateAsyncUserVideoChannels } from 's' import { VideoPlaylistService } from 's' import { VideoPlaylistValidatorsService } from 's' import { VideoPlaylistUpdate } from 's' import { VideoPlaylist } from 's' import { delayWhen , map , switchMap } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoPlaylistUpdateComponent extends MyAccountVideoPlaylistEdit implements OnInit , OnDestroy { error : string videoPlaylistToUpdate : VideoPlaylist private paramsSub : Subscription constructor ( protected formValidatorService , private authService , private videoPlaylistValidatorsService , private notifier , private router , private route , private videoPlaylistService , private 0 , private serverService ) { super ( ) } ngOnInit ( ) { this . buildForm ( { displayName : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_DISPLAY_NAME , privacy : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_PRIVACY , description : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_DESCRIPTION , videoChannelId : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_CHANNEL_ID , thumbnailfile : null } ) this . form . get ( 's' ) . valueChanges . subscribe ( privacy => { this . videoPlaylistValidatorsService . setChannelValidator ( this . form . get ( 's' ) , privacy ) } ) populateAsyncUserVideoChannels ( this . authService , this . userVideoChannels ) . catch ( err => console . error ( 's' , err ) ) this . paramsSub = this . route . params . pipe ( map ( routeParams => routeParams [ 's' ] ) , switchMap ( videoPlaylistId => this . videoPlaylistService . getVideoPlaylist ( videoPlaylistId ) ) , delayWhen ( ( ) => this . serverService . videoPlaylistPrivaciesLoaded ) ) . subscribe ( videoPlaylistToUpdate => { this . videoPlaylistPrivacies = this . serverService . getVideoPlaylistPrivacies ( ) this . videoPlaylistToUpdate = videoPlaylistToUpdate this . hydrateFormFromPlaylist ( ) } , err => this . error = err . message ) } ngOnDestroy ( ) { if ( this . paramsSub ) this . paramsSub . unsubscribe ( ) } formValidated ( ) { this . error = undefined const body = this . form . value const videoPlaylistUpdate = { displayName : body . displayName , privacy : body . privacy , description : body . description || null , videoChannelId : body . videoChannelId || null , thumbnailfile : body . thumbnailfile || undefined } this . videoPlaylistService . updateVideoPlaylist ( this . videoPlaylistToUpdate , videoPlaylistUpdate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { videoPlaylistName : videoPlaylistUpdate . displayName } ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => this . error = err . message ) } isCreation ( ) { return false } getFormButtonTitle ( ) { return this . 0 ( 's' ) } private hydrateFormFromPlaylist ( ) { this . form . patchValue ( { displayName : this . videoPlaylistToUpdate . displayName , privacy : this . videoPlaylistToUpdate . privacy . id , description : this . videoPlaylistToUpdate . description , videoChannelId : this . videoPlaylistToUpdate . videoChannel ? this . videoPlaylistToUpdate . videoChannel . id : null } ) fetch ( this . videoPlaylistToUpdate . thumbnailUrl ) . then ( response => response . blob ( ) ) . then ( data => { this . form . patchValue ( { thumbnailfile : data } ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $VideoPlaylistValidatorsService$ O O $Notifier$ O O $Router$ O O $ActivatedRoute$ O O $VideoPlaylistService$ O O $I18n$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { Notifier } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { User } from 's' import { flatMap } from 's' import { 0 } from 's' import { VideoPlaylist } from 's' import { ComponentPagination } from 's' import { VideoPlaylistService } from 's' import { VideoPlaylistType } from 's' import { Subject } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MyAccountVideoPlaylistsComponent implements OnInit { videoPlaylists : VideoPlaylist [ ] = [ ] pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } onDataSubject = new Subject < any [ ] > ( ) private user : User constructor ( private authService , private notifier , private confirmService , private videoPlaylistService , private 0 ) { } ngOnInit ( ) { this . user = this . authService . getUser ( ) this . loadVideoPlaylists ( ) } async deleteVideoPlaylist ( videoPlaylist ) { const res = await this . confirmService . confirm ( this . 0 ( 's' , { playlistDisplayName : videoPlaylist . displayName } ) , this . 0 ( 's' ) ) if ( res === false ) return this . videoPlaylistService . removeVideoPlaylist ( videoPlaylist ) . subscribe ( ( ) => { this . videoPlaylists = this . videoPlaylists . filter ( p => p . id !== videoPlaylist . id ) this . notifier . success ( this . 0 ( 's' , { playlistDisplayName : videoPlaylist . displayName } ) ) } , error => this . notifier . error ( error . message ) ) } isRegularPlaylist ( playlist ) { return playlist . type . id === VideoPlaylistType . REGULAR } onNearOfBottom ( ) { if ( this . pagination . totalItems <= ( this . pagination . currentPage * this . pagination . itemsPerPage ) ) return this . pagination . currentPage += 0 this . loadVideoPlaylists ( ) } private loadVideoPlaylists ( ) { this . authService . userInformationLoaded . pipe ( flatMap ( ( ) => { return this . videoPlaylistService . listAccountPlaylists ( this . user . account , this . pagination , 's' ) } ) ) . subscribe ( res => { this . videoPlaylists = this . videoPlaylists . concat ( res . data ) this . pagination . totalItems = res . total this . onDataSubject . next ( res . data ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $VideoPlaylistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , EventEmitter , Input , Output , ViewChild } from 's' import { ServerService } from 's' import { VideoChannel } from 's' import { Account } from 's' import { Notifier } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ActorAvatarInfoComponent { @ ViewChild ( 's' , { static : false } ) avatarfileInput : ElementRef < HTMLInputElement > @ Input ( ) actor : VideoChannel | Account @ Output ( ) avatarChange = new EventEmitter < FormData > ( ) constructor ( private serverService , private notifier ) { } onAvatarChange ( ) { const avatarfile = this . avatarfileInput . nativeElement . files [ 0 ] if ( avatarfile . size > this . maxAvatarSize ) { this . notifier . error ( 's' , 's' ) return } const formData = new FormData ( ) formData . append ( 's' , avatarfile ) this . avatarChange . emit ( formData ) } get maxAvatarSize ( ) { return this . serverService . getConfig ( ) . avatar . file . size . max } get avatarExtensions ( ) { return this . serverService . getConfig ( ) . avatar . file . extensions . join ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O $Notifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class PageNotFoundComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { PageNotFoundComponent } from 's' import { MetaGuard } from 's' const pageNotFoundRoutes = [ { path : 's' , component : PageNotFoundComponent , canActivate : [ MetaGuard ] , data : { meta : { title : 's' } } } ] @ NgModule ( { imports : [ RouterModule . forChild ( pageNotFoundRoutes ) ] , exports : [ RouterModule ] } ) export class PageNotFoundRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { PageNotFoundComponent } from 's' import { PageNotFoundRoutingModule } from 's' @ NgModule ( { imports : [ PageNotFoundRoutingModule , SharedModule ] , declarations : [ PageNotFoundComponent ] , exports : [ PageNotFoundComponent ] , providers : [ ] } ) export class PageNotFoundModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { CdkStep , CdkStepper } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , providers : [ { provide : CdkStepper , useExisting : CustomStepperComponent } ] } ) export class CustomStepperComponent extends CdkStepper { onClick ( index ) { this . selectedIndex = index } isCompleted ( step ) { return step . stepControl && step . stepControl . dirty && step . stepControl . valid } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O $CdkStep$ O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { AuthService , Notifier , RedirectService , ServerService } from 's' import { UserService , UserValidatorsService } from 's' import { 0 } from 's' import { UserRegister } from 's' import { FormGroup } from 's' import { About } from 's' import { InstanceService } from 's' import { NgbAccordion } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RegisterComponent implements OnInit { @ ViewChild ( 's' , { static : true } ) accordion : NgbAccordion info : string = null error : string = null success : string = null signupDone = false about : About aboutHtml = { description : 's' , terms : 's' , codeOfConduct : 's' , moderationInformation : 's' , administrator : 's' } formStepUser : FormGroup formStepChannel : FormGroup constructor ( private authService , private userValidatorsService , private notifier , private userService , private serverService , private redirectService , private instanceService , private 0 ) { } get requiresEmailVerification ( ) { return this . serverService . getConfig ( ) . signup . requiresEmailVerification } ngOnInit ( ) { this . instanceService . getAbout ( ) . subscribe ( async about => { this . about = about this . aboutHtml = await this . instanceService . buildHtml ( about ) } , err => this . notifier . error ( err . message ) ) } hasSameChannelAndAccountNames ( ) { return this . getUsername ( ) === this . getChannelName ( ) } getUsername ( ) { if ( ! this . formStepUser ) return undefined return this . formStepUser . value [ 's' ] } getChannelName ( ) { if ( ! this . formStepChannel ) return undefined return this . formStepChannel . value [ 's' ] } onUserFormBuilt ( form ) { this . formStepUser = form } onChannelFormBuilt ( form ) { this . formStepChannel = form } onTermsClick ( ) { if ( this . accordion ) this . accordion . toggle ( 's' ) } onCodeOfConductClick ( ) { if ( this . accordion ) this . accordion . toggle ( 's' ) } signup ( ) { this . error = null const body = Object . assign ( this . formStepUser . value , { channel : this . formStepChannel . value } ) this . userService . signup ( body ) . subscribe ( ( ) => { this . signupDone = true if ( this . requiresEmailVerification ) { this . info = this . 0 ( 's' ) return } this . authService . login ( body . username , body . password ) . subscribe ( ( ) => { this . success = this . 0 ( 's' , { username : body . username } ) } , err => this . error = err . message ) } , err => this . error = err . message ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $UserValidatorsService$ O O $Notifier$ O O $UserService$ O O $ServerService$ O O $RedirectService$ O O $InstanceService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormGroup$ O O O O O O O O O O $FormGroup$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRegister$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { RegisterComponent } from 's' import { ServerConfigResolver } from 's' import { UnloggedGuard } from 's' const registerRoutes = [ { path : 's' , component : RegisterComponent , canActivate : [ MetaGuard , UnloggedGuard ] , data : { meta : { title : 's' } } , resolve : { serverConfigLoaded : ServerConfigResolver } } ] @ NgModule ( { imports : [ RouterModule . forChild ( registerRoutes ) ] , exports : [ RouterModule ] } ) export class RegisterRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnInit , Output } from 's' import { AuthService } from 's' import { FormReactive , UserService , VideoChannelValidatorsService } from 's' import { FormValidatorService } from 's' import { FormGroup } from 's' import { pairwise } from 's' import { concat , of } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RegisterStepChannelComponent extends FormReactive implements OnInit { @ Input ( ) username : string @ Output ( ) formBuilt = new EventEmitter < FormGroup > ( ) constructor ( protected formValidatorService , private authService , private userService , private videoChannelValidatorsService ) { super ( ) } get instanceHost ( ) { return window . location . host } ngOnInit ( ) { this . buildForm ( { displayName : this . videoChannelValidatorsService . VIDEO_CHANNEL_DISPLAY_NAME , name : this . videoChannelValidatorsService . VIDEO_CHANNEL_NAME } ) setTimeout ( ( ) => this . formBuilt . emit ( this . form ) ) concat ( of ( 's' ) , this . form . get ( 's' ) . valueChanges ) . pipe ( pairwise ( ) ) . subscribe ( ( [ oldValue , newValue ] ) => this . onDisplayNameChange ( oldValue , newValue ) ) } isSameThanUsername ( ) { return this . username && this . username === this . form . value [ 's' ] } private onDisplayNameChange ( oldDisplayName , newDisplayName ) { const name = this . form . value [ 's' ] || 's' const newName = this . userService . getNewUsername ( oldDisplayName , newDisplayName , name ) this . form . patchValue ( { name : newName } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $UserService$ O O $VideoChannelValidatorsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnInit , Output } from 's' import { AuthService } from 's' import { FormReactive , UserService , UserValidatorsService } from 's' import { FormValidatorService } from 's' import { FormGroup } from 's' import { pairwise } from 's' import { concat , of } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RegisterStepUserComponent extends FormReactive implements OnInit { @ Input ( ) hasCodeOfConduct = false @ Output ( ) formBuilt = new EventEmitter < FormGroup > ( ) @ Output ( ) termsClick = new EventEmitter < void > ( ) @ Output ( ) codeOfConductClick = new EventEmitter < void > ( ) constructor ( protected formValidatorService , private authService , private userService , private userValidatorsService ) { super ( ) } get instanceHost ( ) { return window . location . host } ngOnInit ( ) { this . buildForm ( { displayName : this . userValidatorsService . USER_DISPLAY_NAME_REQUIRED , username : this . userValidatorsService . USER_USERNAME , password : this . userValidatorsService . USER_PASSWORD , email : this . userValidatorsService . USER_EMAIL , terms : this . userValidatorsService . USER_TERMS } ) setTimeout ( ( ) => this . formBuilt . emit ( this . form ) ) concat ( of ( 's' ) , this . form . get ( 's' ) . valueChanges ) . pipe ( pairwise ( ) ) . subscribe ( ( [ oldValue , newValue ] ) => this . onDisplayNameChange ( oldValue , newValue ) ) } onTermsClick ( event ) { event . preventDefault ( ) this . termsClick . emit ( ) } onCodeOfConductClick ( event ) { event . preventDefault ( ) this . codeOfConductClick . emit ( ) } private onDisplayNameChange ( oldDisplayName , newDisplayName ) { const username = this . form . value [ 's' ] || 's' const newUsername = this . userService . getNewUsername ( oldDisplayName , newDisplayName , username ) this . form . patchValue ( { username : newUsername } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $UserService$ O O $UserValidatorsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RegisterRoutingModule } from 's' import { RegisterComponent } from 's' import { SharedModule } from 's' import { CdkStepperModule } from 's' import { RegisterStepChannelComponent } from 's' import { RegisterStepUserComponent } from 's' import { CustomStepperComponent } from 's' import { SignupSharedModule } from 's' import { NgbAccordionModule } from 's' @ NgModule ( { imports : [ RegisterRoutingModule , SharedModule , CdkStepperModule , SignupSharedModule , NgbAccordionModule ] , declarations : [ RegisterComponent , CustomStepperComponent , RegisterStepChannelComponent , RegisterStepUserComponent ] , exports : [ RegisterComponent ] , providers : [ ] } ) export class RegisterModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { 0 } from 's' import { Notifier , RedirectService } from 's' import { ServerService } from 's' import { FormReactive , UserService } from 's' import { FormValidatorService } from 's' import { UserValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VerifyAccountAskSendEmailComponent extends FormReactive implements OnInit { constructor ( protected formValidatorService , private userValidatorsService , private userService , private serverService , private notifier , private redirectService , private 0 ) { super ( ) } get requiresEmailVerification ( ) { return this . serverService . getConfig ( ) . signup . requiresEmailVerification } ngOnInit ( ) { this . buildForm ( { 's' : this . userValidatorsService . USER_EMAIL } ) } askSendVerifyEmail ( ) { const email = this . form . value [ 's' ] this . userService . askSendVerifyEmail ( email ) . subscribe ( ( ) => { const message = this . 0 ( 's' , { email } ) this . notifier . success ( message ) this . redirectService . redirectToHomepage ( ) } , err => { this . notifier . error ( err . message ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O $UserService$ O O $ServerService$ O O $Notifier$ O O $RedirectService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { 0 } from 's' import { AuthService , Notifier } from 's' import { UserService } from 's' @ Component ( { selector : 's' , templateUrl : 's' } ) export class VerifyAccountEmailComponent implements OnInit { success = false failed = false isPendingEmail = false private userId : number private verificationString : string constructor ( private userService , private authService , private notifier , private router , private route , private 0 ) { } ngOnInit ( ) { const queryParams = this . route . snapshot . queryParams this . userId = queryParams [ 's' ] this . verificationString = queryParams [ 's' ] this . isPendingEmail = queryParams [ 's' ] === 's' if ( ! this . userId || ! this . verificationString ) { this . notifier . error ( this . 0 ( 's' ) ) } else { this . verifyEmail ( ) } } verifyEmail ( ) { this . userService . verifyEmail ( this . userId , this . verificationString , this . isPendingEmail ) . subscribe ( ( ) => { if ( this . authService . isLoggedIn ( ) ) { this . authService . refreshUserInformation ( ) } this . success = true } , err => { this . failed = true this . notifier . error ( err . message ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $AuthService$ O O $Notifier$ O O $Router$ O O $ActivatedRoute$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { VerifyAccountEmailComponent } from 's' import { VerifyAccountAskSendEmailComponent } from 's' const verifyAccountRoutes = [ { path : 's' , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , component : VerifyAccountEmailComponent , data : { meta : { title : 's' } } } , { path : 's' , component : VerifyAccountAskSendEmailComponent , data : { meta : { title : 's' } } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( verifyAccountRoutes ) ] , exports : [ RouterModule ] } ) export class VerifyAccountRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { VerifyAccountRoutingModule } from 's' import { VerifyAccountEmailComponent } from 's' import { VerifyAccountAskSendEmailComponent } from 's' import { SharedModule } from 's' import { SignupSharedModule } from 's' @ NgModule ( { imports : [ VerifyAccountRoutingModule , SharedModule , SignupSharedModule ] , declarations : [ VerifyAccountEmailComponent , VerifyAccountAskSendEmailComponent ] , exports : [ ] , providers : [ ] } ) export class VerifyAccountModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SignupSuccessComponent { @ Input ( ) message : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SignupSuccessComponent } from 's' import { SharedModule } from 's' @ NgModule ( { imports : [ SharedModule ] , declarations : [ SignupSuccessComponent ] , exports : [ SignupSuccessComponent ] , providers : [ ] } ) export class SignupSharedModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit , ViewChild } from 's' import { ActivatedRoute } from 's' import { VideoChannel } from 's' import { VideoChannelService } from 's' import { RestExtractor } from 's' import { catchError , distinctUntilChanged , map , switchMap } from 's' import { Subscription } from 's' import { AuthService } from 's' import { Hotkey , HotkeysService } from 's' import { SubscribeButtonComponent } from 's' import { 0 } from 's' @ Component ( { templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoChannelsComponent implements OnInit , OnDestroy { @ ViewChild ( 's' , { static : false } ) subscribeButton : SubscribeButtonComponent videoChannel : VideoChannel hotkeys : Hotkey [ ] private routeSub : Subscription constructor ( private 0 , private route , private authService , private videoChannelService , private restExtractor , private hotkeysService ) { } ngOnInit ( ) { this . routeSub = this . route . params . pipe ( map ( params => params [ 's' ] ) , distinctUntilChanged ( ) , switchMap ( videoChannelName => this . videoChannelService . getVideoChannel ( videoChannelName ) ) , catchError ( err => this . restExtractor . 0 ( err , [ 0 , 0 ] ) ) ) . subscribe ( videoChannel => this . videoChannel = videoChannel ) this . hotkeys = [ new Hotkey ( 's' , ( event ) : boolean => { this . subscribeButton . subscribed ? this . subscribeButton . unsubscribe ( ) : this . subscribeButton . subscribe ( ) return false } , undefined , this . 0 ( 's' ) ) ] if ( this . isUserLoggedIn ( ) ) this . hotkeysService . add ( this . hotkeys ) } ngOnDestroy ( ) { if ( this . routeSub ) this . routeSub . unsubscribe ( ) if ( this . isUserLoggedIn ( ) ) this . hotkeysService . remove ( this . hotkeys ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ActivatedRoute$ O O $AuthService$ O O $VideoChannelService$ O O $RestExtractor$ O O $HotkeysService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { ConfirmService } from 's' import { AbstractVideoList } from 's' import { VideoService } from 's' import { VideoChannelService } from 's' import { VideoChannel } from 's' import { first , tap } from 's' import { 0 } from 's' import { Subscription } from 's' import { ScreenService } from 's' import { Notifier , ServerService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' ] } ) export class VideoChannelVideosComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string loadOnInit = false private videoChannel : VideoChannel private videoChannelSub : Subscription constructor ( protected 0 , protected router , protected serverService , protected route , protected authService , protected notifier , protected confirmService , protected screenService , private videoChannelService , private videoService ) { super ( ) this . titlePage = this . 0 ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) this . videoChannelSub = this . videoChannelService . videoChannelLoaded . pipe ( first ( ) ) . subscribe ( videoChannel => { this . videoChannel = videoChannel this . reloadVideos ( ) this . generateSyndicationList ( ) } ) } ngOnDestroy ( ) { if ( this . videoChannelSub ) this . videoChannelSub . unsubscribe ( ) super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) return this . videoService . getVideoChannelVideos ( this . videoChannel , newPagination , this . sort ) . pipe ( tap ( ( { total } ) => { this . titlePage = this . 0 ( 's' , { total } ) } ) ) } generateSyndicationList ( ) { this . syndicationItems = this . videoService . getVideoChannelFeedUrls ( this . videoChannel . id ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $ScreenService$ O O $VideoChannelService$ O O $VideoService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { VideoChannelService } from 's' import { VideoChannel } from 's' import { 0 } from 's' import { Subscription } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoChannelAboutComponent implements OnInit , OnDestroy { videoChannel : VideoChannel descriptionHTML = 's' supportHTML = 's' private videoChannelSub : Subscription constructor ( private 0 , private videoChannelService , private markdownService ) { } ngOnInit ( ) { this . videoChannelSub = this . videoChannelService . videoChannelLoaded . subscribe ( async videoChannel => { this . videoChannel = videoChannel this . descriptionHTML = await this . markdownService . textMarkdownToHTML ( this . videoChannel . description ) this . supportHTML = await this . markdownService . enhancedMarkdownToHTML ( this . videoChannel . support ) } ) } ngOnDestroy ( ) { if ( this . videoChannelSub ) this . videoChannelSub . unsubscribe ( ) } getVideoChannelDescription ( ) { if ( this . descriptionHTML ) return this . descriptionHTML return this . 0 ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $VideoChannelService$ O O $MarkdownService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { VideoChannelsComponent } from 's' import { VideoChannelVideosComponent } from 's' import { VideoChannelAboutComponent } from 's' import { VideoChannelPlaylistsComponent } from 's' const videoChannelsRoutes = [ { path : 's' , component : VideoChannelsComponent , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , redirectTo : 's' , pathMatch : 's' } , { path : 's' , component : VideoChannelVideosComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : VideoChannelPlaylistsComponent , data : { meta : { title : 's' } } } , { path : 's' , component : VideoChannelAboutComponent , data : { meta : { title : 's' } } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( videoChannelsRoutes ) ] , exports : [ RouterModule ] } ) export class VideoChannelsRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { VideoChannelsRoutingModule } from 's' import { VideoChannelsComponent } from 's' import { VideoChannelVideosComponent } from 's' import { VideoChannelAboutComponent } from 's' import { VideoChannelPlaylistsComponent } from 's' @ NgModule ( { imports : [ VideoChannelsRoutingModule , SharedModule ] , declarations : [ VideoChannelsComponent , VideoChannelVideosComponent , VideoChannelAboutComponent , VideoChannelPlaylistsComponent ] , exports : [ VideoChannelsComponent ] , providers : [ ] } ) export class VideoChannelsModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ConfirmService } from 's' import { VideoChannelService } from 's' import { VideoChannel } from 's' import { Subject , Subscription } from 's' import { Notifier } from 's' import { VideoPlaylist } from 's' import { ComponentPagination , hasMoreItems } from 's' import { VideoPlaylistService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoChannelPlaylistsComponent implements OnInit , OnDestroy { videoPlaylists : VideoPlaylist [ ] = [ ] pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } onDataSubject = new Subject < any [ ] > ( ) private videoChannelSub : Subscription private videoChannel : VideoChannel constructor ( private notifier , private confirmService , private videoPlaylistService , private videoChannelService ) { } ngOnInit ( ) { this . videoChannelSub = this . videoChannelService . videoChannelLoaded . subscribe ( videoChannel => { this . videoChannel = videoChannel this . loadVideoPlaylists ( ) } ) } ngOnDestroy ( ) { if ( this . videoChannelSub ) this . videoChannelSub . unsubscribe ( ) } onNearOfBottom ( ) { if ( ! hasMoreItems ( this . pagination ) ) return this . pagination . currentPage += 0 this . loadVideoPlaylists ( ) } private loadVideoPlaylists ( ) { this . videoPlaylistService . listChannelPlaylists ( this . videoChannel , this . pagination ) . subscribe ( res => { this . videoPlaylists = this . videoPlaylists . concat ( res . data ) this . pagination . totalItems = res . total this . onDataSubject . next ( res . data ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $ConfirmService$ O O $VideoPlaylistService$ O O $VideoChannelService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouteReuseStrategy , RouterModule , Routes } from 's' import { PreloadSelectedModulesList } from 's' import { AppComponent } from 's' import { CustomReuseStrategy } from 's' const routes = [ { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . AdminModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . MyAccountModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . VerifyAccountModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . AccountsModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . VideoChannelsModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . AboutModule ) } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . RegisterModule ) } , { path : 's' , component : AppComponent } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . PageNotFoundModule ) } ] @ NgModule ( { imports : [ RouterModule . forRoot ( routes , { useHash : Boolean ( history . pushState ) === false , scrollPositionRestoration : 's' , preloadingStrategy : PreloadSelectedModulesList , anchorScrolling : 's' } ) ] , providers : [ PreloadSelectedModulesList , { provide : RouteReuseStrategy , useClass : CustomReuseStrategy } ] , exports : [ RouterModule ] } ) export class AppRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { DomSanitizer , SafeHtml } from 's' import { Event , GuardsCheckStart , NavigationEnd , Router , Scroll } from 's' import { AuthService , RedirectService , ServerService , ThemeService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { debounceTime , filter , map , pairwise , skip , switchMap } from 's' import { Hotkey , HotkeysService } from 's' import { 0 } from 's' import { fromEvent } from 's' import { PlatformLocation , ViewportScroller } from 's' import { PluginService } from 's' import { HooksService } from 's' import { NgbModal } from 's' import { POP_STATE_MODAL_DISMISS } from 's' import { WelcomeModalComponent } from 's' import { InstanceConfigWarningModalComponent } from 's' import { UserRole } from 's' import { User } from 's' import { InstanceService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AppComponent implements OnInit { @ ViewChild ( 's' , { static : false } ) welcomeModal : WelcomeModalComponent @ ViewChild ( 's' , { static : false } ) instanceConfigWarningModal : InstanceConfigWarningModalComponent isMenuDisplayed = true isMenuChangedByUser = false customCSS : SafeHtml constructor ( private 0 , private viewportScroller , private router , private authService , private serverService , private pluginService , private instanceService , private domSanitizer , private redirectService , private screenService , private hotkeysService , private themeService , private hooks , private location , private modalService ) { } get serverVersion ( ) { return this . serverService . getConfig ( ) . serverVersion } get serverCommit ( ) { const commit = this . serverService . getConfig ( ) . serverCommit || 's' return ( commit !== 's' ) ? 's' + commit : commit } get instanceName ( ) { return this . serverService . getConfig ( ) . instance . name } get defaultRoute ( ) { return RedirectService . DEFAULT_ROUTE } ngOnInit ( ) { document . getElementById ( 's' ) . className += 's' this . authService . loadClientCredentials ( ) if ( this . isUserLoggedIn ( ) ) { this . authService . refreshUserInformation ( ) } this . serverService . loadConfig ( ) this . serverService . loadVideoCategories ( ) this . serverService . loadVideoLanguages ( ) this . serverService . loadVideoLicences ( ) this . serverService . loadVideoPrivacies ( ) this . serverService . loadVideoPlaylistPrivacies ( ) this . loadPlugins ( ) this . themeService . initialize ( ) if ( this . screenService . isInSmallView ( ) ) { this . isMenuDisplayed = false } this . initRouteEvents ( ) this . injectJS ( ) this . injectCSS ( ) this . initHotkeys ( ) fromEvent ( window , 's' ) . pipe ( debounceTime ( 0 ) ) . subscribe ( ( ) => this . onResize ( ) ) this . location . onPopState ( ( ) => this . modalService . dismissAll ( POP_STATE_MODAL_DISMISS ) ) this . openModalsIfNeeded ( ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } toggleMenu ( ) { this . isMenuDisplayed = ! this . isMenuDisplayed this . isMenuChangedByUser = true } onResize ( ) { this . isMenuDisplayed = window . innerWidth >= 0 && ! this . isMenuChangedByUser } private initRouteEvents ( ) { let resetScroll = true const eventsObs = this . router . events const scrollEvent = eventsObs . pipe ( filter ( ( e ) : e is Scroll => e instanceof Scroll ) ) scrollEvent . subscribe ( e => { if ( e . position ) { return this . viewportScroller . scrollToPosition ( e . position ) } if ( e . anchor ) { return this . viewportScroller . scrollToAnchor ( e . anchor ) } if ( resetScroll ) { return this . viewportScroller . scrollToPosition ( [ 0 , 0 ] ) } } ) const navigationEndEvent = eventsObs . pipe ( filter ( ( e ) : e is NavigationEnd => e instanceof NavigationEnd ) ) navigationEndEvent . pipe ( pairwise ( ) ) . subscribe ( ( [ 0 , 0 ] ) => { try { resetScroll = false const previousUrl = new URL ( window . location . origin + 0 . urlAfterRedirects ) const nextUrl = new URL ( window . location . origin + 0 . urlAfterRedirects ) if ( previousUrl . pathname !== nextUrl . pathname ) { resetScroll = true return } const nextSearchParams = nextUrl . searchParams nextSearchParams . delete ( 's' ) const previousSearchParams = previousUrl . searchParams nextSearchParams . sort ( ) previousSearchParams . sort ( ) if ( nextSearchParams . toString ( ) !== previousSearchParams . toString ( ) ) { resetScroll = true } } catch ( e ) { console . error ( 's' , e ) resetScroll = true } } ) navigationEndEvent . pipe ( map ( ( ) => window . location . pathname ) , filter ( pathname => ! pathname || pathname === 's' || 0 ( pathname ) ) ) . subscribe ( ( ) => this . redirectService . redirectToHomepage ( true ) ) navigationEndEvent . subscribe ( e => { this . hooks . runAction ( 's' , 's' , { path : e . url } ) } ) eventsObs . pipe ( filter ( ( e ) : e is GuardsCheckStart => e instanceof GuardsCheckStart ) , filter ( ( ) => this . screenService . isInSmallView ( ) ) ) . subscribe ( ( ) => this . isMenuDisplayed = false ) } private injectJS ( ) { this . serverService . configLoaded . subscribe ( ( ) => { const config = this . serverService . getConfig ( ) if ( config . instance . customizations . javascript ) { try { eval ( config . instance . customizations . javascript ) } catch ( err ) { console . error ( 's' , err ) } } } ) } private injectCSS ( ) { this . serverService . configLoaded . pipe ( skip ( 0 ) ) . subscribe ( ( ) => { const headStyle = document . querySelector ( 's' ) if ( headStyle ) headStyle . parentNode . removeChild ( headStyle ) const config = this . serverService . getConfig ( ) if ( this . customCSS || config . instance . customizations . css ) { const styleTag = 's' + config . instance . customizations . css + 's' this . customCSS = this . domSanitizer . bypassSecurityTrustHtml ( styleTag ) } } ) } private async loadPlugins ( ) { this . pluginService . initializePlugins ( ) this . hooks . runAction ( 's' , 's' ) } private async openModalsIfNeeded ( ) { this . serverService . configLoaded . pipe ( switchMap ( ( ) => this . authService . userInformationLoaded ) , map ( ( ) => this . authService . getUser ( ) ) , filter ( user => user . role === UserRole . ADMINISTRATOR ) ) . subscribe ( user => setTimeout ( ( ) => this . openAdminModals ( user ) ) ) } private async openAdminModals ( user ) { if ( user . noWelcomeModal !== true ) return this . welcomeModal . show ( ) const config = this . serverService . getConfig ( ) if ( user . noInstanceConfigWarningModal === true || ! config . signup . allowed ) return this . instanceService . getAbout ( ) . subscribe ( about => { if ( config . instance . name . toLowerCase ( ) === 's' || ! about . instance . terms || ! about . instance . administrator || ! about . instance . maintenanceLifetime ) { this . instanceConfigWarningModal . show ( about ) } } ) } private initHotkeys ( ) { this . hotkeysService . add ( [ new Hotkey ( [ 's' , 's' ] , ( event ) : boolean => { document . getElementById ( 's' ) . focus ( ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . toggleMenu ( ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( event ) : boolean => { this . router . navigate ( [ 's' ] ) return false } , undefined , this . 0 ( 's' ) ) ] ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ViewportScroller$ O O $Router$ O O $AuthService$ O O $ServerService$ O O $PluginService$ O O $InstanceService$ O O $DomSanitizer$ O O $RedirectService$ O O $ScreenService$ O O $HotkeysService$ O O $ThemeService$ O O $HooksService$ O O $PlatformLocation$ O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { filter , first , map , tap } from 's' import { Component , OnInit } from 's' import { NavigationEnd , Router } from 's' import { getParameterByName } from 's' import { AuthService } from 's' import { of } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HeaderComponent implements OnInit { searchValue = 's' constructor ( private router , private auth ) { } ngOnInit ( ) { this . router . events . pipe ( filter ( e => e instanceof NavigationEnd ) , map ( ( ) => getParameterByName ( 's' , window . location . href ) ) ) . subscribe ( searchQuery => this . searchValue = searchQuery || 's' ) } doSearch ( ) { const queryParams = { search : this . searchValue } const o = this . auth . isLoggedIn ( ) ? this . loadUserLanguages ( queryParams ) : of ( true ) o . subscribe ( ( ) => this . router . navigate ( [ 's' ] , { queryParams } ) ) } private loadUserLanguages ( queryParams ) { return this . auth . userInformationLoaded . pipe ( first ( ) , tap ( ( ) => Object . assign ( queryParams , { languageOneOf : this . auth . getUser ( ) . videoLanguages } ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $AuthService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , ElementRef , OnInit , ViewChild } from 's' import { Notifier , RedirectService , ServerService } from 's' import { UserService } from 's' import { AuthService } from 's' import { FormReactive } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { LoginValidatorsService } from 's' import { NgbModal , NgbModalRef } from 's' import { Router } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class LoginComponent extends FormReactive implements OnInit { @ ViewChild ( 's' , { static : true } ) input : ElementRef @ ViewChild ( 's' , { static : true } ) forgotPasswordModal : ElementRef error : string = null forgotPasswordEmail = 's' private openedForgotPasswordModal : NgbModalRef constructor ( public router , protected formValidatorService , private modalService , private loginValidatorsService , private authService , private userService , private serverService , private redirectService , private notifier , private 0 ) { super ( ) } get signupAllowed ( ) { return this . serverService . getConfig ( ) . signup . allowed === true } isEmailDisabled ( ) { return this . serverService . getConfig ( ) . email . enabled === false } ngOnInit ( ) { this . buildForm ( { username : this . loginValidatorsService . LOGIN_USERNAME , password : this . loginValidatorsService . LOGIN_PASSWORD } ) this . input . nativeElement . focus ( ) } login ( ) { this . error = null const { username , password } = this . form . value this . authService . login ( username , password ) . subscribe ( ( ) => this . redirectService . redirectToPreviousRoute ( ) , err => { if ( err . message . indexOf ( 's' ) !== - 0 ) this . error = this . 0 ( 's' ) else if ( err . message . indexOf ( 's' ) !== - 0 ) this . error = this . 0 ( 's' ) else this . error = err . message } ) } askResetPassword ( ) { this . userService . askResetPassword ( this . forgotPasswordEmail ) . subscribe ( ( ) => { const message = this . 0 ( 's' , { email : this . forgotPasswordEmail } ) this . notifier . success ( message ) this . hideForgotPasswordModal ( ) } , err => this . notifier . error ( err . message ) ) } openForgotPasswordModal ( ) { this . openedForgotPasswordModal = this . modalService . open ( this . forgotPasswordModal ) } hideForgotPasswordModal ( ) { this . openedForgotPasswordModal . close ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $FormValidatorService$ O O $NgbModal$ O O $LoginValidatorsService$ O O $AuthService$ O O $UserService$ O O $ServerService$ O O $RedirectService$ O O $Notifier$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { LoginComponent } from 's' import { ServerConfigResolver } from 's' const loginRoutes = [ { path : 's' , component : LoginComponent , canActivate : [ MetaGuard ] , data : { meta : { title : 's' } } , resolve : { serverConfigLoaded : ServerConfigResolver } } ] @ NgModule ( { imports : [ RouterModule . forChild ( loginRoutes ) ] , exports : [ RouterModule ] } ) export class LoginRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { LoginRoutingModule } from 's' import { LoginComponent } from 's' import { SharedModule } from 's' @ NgModule ( { imports : [ LoginRoutingModule , SharedModule ] , declarations : [ LoginComponent ] , exports : [ LoginComponent ] , providers : [ ] } ) export class LoginModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , ElementRef , ViewChild } from 's' import { 0 } from 's' import { NgbModal } from 's' import { sortBy } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class LanguageChooserComponent { @ ViewChild ( 's' , { static : true } ) modal : ElementRef languages : { id : string , label : string } [ ] = [ ] constructor ( private modalService ) { const l = Object . keys ( 0 ) . map ( k => ( { id : k , label : 0 [ k ] } ) ) this . languages = sortBy ( l , 's' ) } show ( ) { this . modalService . open ( this . modal ) } buildLanguageLink ( lang : { id : string } ) { return window . location . origin + 's' + lang . id } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnDestroy , OnInit , ViewChild } from 's' import { User } from 's' import { UserNotificationService } from 's' import { Subscription } from 's' import { Notifier , UserNotificationSocket } from 's' import { NgbPopover } from 's' import { NavigationEnd , Router } from 's' import { filter } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class AvatarNotificationComponent implements OnInit , OnDestroy { @ ViewChild ( 's' , { static : true } ) popover : NgbPopover @ Input ( ) user : User unreadNotifications = 0 loaded = false private notificationSub : Subscription private routeSub : Subscription constructor ( private userNotificationService , private userNotificationSocket , private notifier , private router ) { } ngOnInit ( ) { this . userNotificationService . countUnreadNotifications ( ) . subscribe ( result => { this . unreadNotifications = Math . min ( result , 0 ) this . subscribeToNotifications ( ) } , err => this . notifier . error ( err . message ) ) this . routeSub = this . router . events . pipe ( filter ( event => event instanceof NavigationEnd ) ) . subscribe ( ( ) => this . closePopover ( ) ) } ngOnDestroy ( ) { if ( this . notificationSub ) this . notificationSub . unsubscribe ( ) if ( this . routeSub ) this . routeSub . unsubscribe ( ) } closePopover ( ) { this . popover . close ( ) } onPopoverHidden ( ) { this . loaded = false } onNotificationLoaded ( ) { this . loaded = true } private async subscribeToNotifications ( ) { const obs = await this . userNotificationSocket . getMyNotificationsSocket ( ) this . notificationSub = obs . subscribe ( data => { if ( data . type === 's' ) return this . unreadNotifications ++ if ( data . type === 's' ) return this . unreadNotifications -- if ( data . type === 's' ) return this . unreadNotifications = 0 } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationService$ O O $UserNotificationSocket$ O O $Notifier$ O O $Router$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit , ViewChild } from 's' import { UserRight } from 's' import { AuthService , AuthStatus , RedirectService , ServerService , ThemeService } from 's' import { User } from 's' import { LanguageChooserComponent } from 's' import { HotkeysService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class MenuComponent implements OnInit { @ ViewChild ( 's' , { static : true } ) languageChooserModal : LanguageChooserComponent user : User isLoggedIn : boolean userHasAdminAccess = false helpVisible = false private routesPerRight : { [ role in UserRight ] ? : string } = { [ UserRight . MANAGE_USERS ] : 's' , [ UserRight . MANAGE_SERVER_FOLLOW ] : 's' , [ UserRight . MANAGE_VIDEO_ABUSES ] : 's' , [ UserRight . MANAGE_VIDEO_BLACKLIST ] : 's' , [ UserRight . MANAGE_JOBS ] : 's' , [ UserRight . MANAGE_CONFIGURATION ] : 's' } constructor ( private authService , private serverService , private redirectService , private themeService , private hotkeysService ) { } ngOnInit ( ) { this . isLoggedIn = this . authService . isLoggedIn ( ) if ( this . isLoggedIn === true ) this . user = this . authService . getUser ( ) this . computeIsUserHasAdminAccess ( ) this . authService . loginChangedSource . subscribe ( status => { if ( status === AuthStatus . LoggedIn ) { this . isLoggedIn = true this . user = this . authService . getUser ( ) this . computeIsUserHasAdminAccess ( ) console . log ( 's' ) } else if ( status === AuthStatus . LoggedOut ) { this . isLoggedIn = false this . user = undefined this . computeIsUserHasAdminAccess ( ) console . log ( 's' ) } else { console . error ( 's' + status ) } } ) this . hotkeysService . cheatSheetToggle . subscribe ( isOpen => { this . helpVisible = isOpen } ) } isRegistrationAllowed ( ) { return this . serverService . getConfig ( ) . signup . allowed && this . serverService . getConfig ( ) . signup . allowedForCurrentIP } getFirstAdminRightAvailable ( ) { const user = this . authService . getUser ( ) if ( ! user ) return undefined const adminRights = [ UserRight . MANAGE_USERS , UserRight . MANAGE_SERVER_FOLLOW , UserRight . MANAGE_VIDEO_ABUSES , UserRight . MANAGE_VIDEO_BLACKLIST , UserRight . MANAGE_JOBS , UserRight . MANAGE_CONFIGURATION ] for ( const adminRight of adminRights ) { if ( user . hasRight ( adminRight ) ) { return adminRight } } return undefined } getFirstAdminRouteAvailable ( ) { const right = this . getFirstAdminRightAvailable ( ) return this . routesPerRight [ right ] } logout ( event ) { event . preventDefault ( ) this . authService . logout ( ) this . redirectService . redirectToHomepage ( ) } openLanguageChooser ( ) { this . languageChooserModal . show ( ) } openHotkeysCheatSheet ( ) { this . hotkeysService . cheatSheetToggle . next ( ! this . helpVisible ) } private computeIsUserHasAdminAccess ( ) { const right = this . getFirstAdminRightAvailable ( ) this . userHasAdminAccess = right !== undefined } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $ServerService$ O O $RedirectService$ O O $ThemeService$ O O $HotkeysService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { AbstractVideoList } from 's' import { VideoSortField } from 's' import { VideoService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { Notifier , ServerService } from 's' import { HooksService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoRecentlyAddedComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string sort : VideoSortField = 's' groupByDate = true useUserVideoLanguagePreferences = true constructor ( protected 0 , protected route , protected serverService , protected router , protected notifier , protected authService , protected screenService , private videoService , private hooks ) { super ( ) this . titlePage = 0 ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) this . generateSyndicationList ( ) } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) const params = { videoPagination : newPagination , sort : this . sort , categoryOneOf : this . categoryOneOf , languageOneOf : this . languageOneOf } return this . hooks . wrapObsFun ( this . videoService . getVideos . bind ( this . videoService ) , params , 's' , 's' , 's' ) } generateSyndicationList ( ) { this . syndicationItems = this . videoService . getVideoFeedUrls ( this . sort , undefined , this . categoryOneOf ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ActivatedRoute$ O O $ServerService$ O O $Router$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $VideoService$ O O $HooksService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { AbstractVideoList } from 's' import { VideoSortField } from 's' import { VideoService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { Notifier , ServerService } from 's' import { HooksService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoTrendingComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string defaultSort : VideoSortField = 's' useUserVideoLanguagePreferences = true constructor ( protected 0 , protected router , protected serverService , protected route , protected notifier , protected authService , protected screenService , private videoService , private hooks ) { super ( ) } ngOnInit ( ) { super . ngOnInit ( ) this . generateSyndicationList ( ) this . serverService . configLoaded . subscribe ( ( ) => { const trendingDays = this . serverService . getConfig ( ) . trending . videos . intervalDays if ( trendingDays === 0 ) { this . titlePage = this . 0 ( 's' ) this . titleTooltip = this . 0 ( 's' ) } else { this . titlePage = this . 0 ( 's' , { days : trendingDays } ) this . titleTooltip = this . 0 ( 's' , { days : trendingDays } ) } } ) } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) const params = { videoPagination : newPagination , sort : this . sort , categoryOneOf : this . categoryOneOf , languageOneOf : this . languageOneOf } return this . hooks . wrapObsFun ( this . videoService . getVideos . bind ( this . videoService ) , params , 's' , 's' , 's' ) } generateSyndicationList ( ) { this . syndicationItems = this . videoService . getVideoFeedUrls ( this . sort , undefined , this . categoryOneOf ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $VideoService$ O O $HooksService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { template : 's' } ) export class VideosComponent { }	O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { VideoLocalComponent } from 's' import { MetaGuard } from 's' import { VideoRecentlyAddedComponent } from 's' import { VideoTrendingComponent } from 's' import { VideosComponent } from 's' import { VideoUserSubscriptionsComponent } from 's' import { VideoOverviewComponent } from 's' const videosRoutes = [ { path : 's' , component : VideosComponent , canActivateChild : [ MetaGuard ] , children : [ { path : 's' , component : VideoOverviewComponent , data : { meta : { title : 's' } } } , { path : 's' , component : VideoTrendingComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : VideoRecentlyAddedComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : VideoUserSubscriptionsComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , component : VideoLocalComponent , data : { meta : { title : 's' } , reuse : { enabled : true , key : 's' } } } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . VideoAddModule ) , data : { meta : { title : 's' } } } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . VideoUpdateModule ) , data : { meta : { title : 's' } } } , { path : 's' , loadChildren : ( ) => import ( 's' ) . then ( m => m . VideoWatchModule ) , data : { preload : 0 } } ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( videosRoutes ) ] , exports : [ RouterModule ] } ) export class VideosRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { VideoLocalComponent } from 's' import { SharedModule } from 's' import { VideoRecentlyAddedComponent } from 's' import { VideoTrendingComponent } from 's' import { VideosRoutingModule } from 's' import { VideosComponent } from 's' import { VideoUserSubscriptionsComponent } from 's' import { VideoOverviewComponent } from 's' @ NgModule ( { imports : [ VideosRoutingModule , SharedModule ] , declarations : [ VideosComponent , VideoTrendingComponent , VideoRecentlyAddedComponent , VideoLocalComponent , VideoUserSubscriptionsComponent , VideoOverviewComponent ] , exports : [ VideosComponent ] , providers : [ ] } ) export class VideosModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { LOCALE_ID , NgModule , TRANSLATIONS , TRANSLATIONS_FORMAT } from 's' import { BrowserModule } from 's' import { ServerService } from 's' import { ResetPasswordModule } from 's' import { MetaLoader , MetaModule , MetaStaticLoader , PageTitlePositioning } from 's' import { ClipboardModule } from 's' import 's' import { AppRoutingModule } from 's' import { AppComponent } from 's' import { CoreModule } from 's' import { HeaderComponent } from 's' import { LoginModule } from 's' import { AvatarNotificationComponent , LanguageChooserComponent , MenuComponent } from 's' import { SharedModule } from 's' import { VideosModule } from 's' import { buildFileLocale , getCompleteLocale , isDefaultLocale } from 's' import { getDevLocale , isOnDevLocale } from 's' import { SearchModule } from 's' import { WelcomeModalComponent } from 's' import { InstanceConfigWarningModalComponent } from 's' export function metaFactory ( serverService ) { return new MetaStaticLoader ( { pageTitlePositioning : PageTitlePositioning . PrependPageTitle , pageTitleSeparator : 's' , get applicationName ( ) { return serverService . getConfig ( ) . instance . name } , defaults : { get title ( ) { return serverService . getConfig ( ) . instance . name } , get description ( ) { return serverService . getConfig ( ) . instance . shortDescription } } } ) } @ NgModule ( { bootstrap : [ AppComponent ] , declarations : [ AppComponent , MenuComponent , LanguageChooserComponent , AvatarNotificationComponent , HeaderComponent , WelcomeModalComponent , InstanceConfigWarningModalComponent ] , imports : [ BrowserModule , ClipboardModule , CoreModule , SharedModule , CoreModule , LoginModule , ResetPasswordModule , SearchModule , SharedModule , VideosModule , MetaModule . forRoot ( { provide : MetaLoader , useFactory : ( metaFactory ) , deps : [ ServerService ] } ) , AppRoutingModule ] , providers : [ { provide : TRANSLATIONS , useFactory : ( locale ) => { if ( isOnDevLocale ( ) ) { locale = buildFileLocale ( getDevLocale ( ) ) return require ( `template` ) } const completeLocale = getCompleteLocale ( locale ) if ( isDefaultLocale ( completeLocale ) ) return 's' const fileLocale = buildFileLocale ( locale ) return require ( `template` ) } , deps : [ LOCALE_ID ] } , { provide : TRANSLATIONS_FORMAT , useValue : 's' } ] } ) export class AppModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MetaLoader$ O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { PluginService } from 's' import { ClientActionHookName , ClientFilterHookName } from 's' import { from , Observable } from 's' import { mergeMap , switchMap } from 's' import { ServerService } from 's' import { PluginClientScope } from 's' type RawFunction < U , T > = ( params : U ) => T type ObservableFunction < U , T > = RawFunction < U , Observable < T > > @ Injectable ( ) export class HooksService { constructor ( private server , private pluginService ) { } wrapObject < T , U extends ClientFilterHookName > ( result : T , hookName : U ) { return this . pluginService . runHook ( hookName , result ) } wrapObsFun < P , R , 0 extends ClientFilterHookName , 0 extends ClientFilterHookName > ( fun < P , R > , params : P , scope , hookParamName , hookResultName ) { return from ( this . pluginService . ensurePluginsAreLoaded ( scope ) ) . pipe ( mergeMap ( ( ) => this . wrapObject ( params , hookParamName ) ) , switchMap ( params => fun ( params ) ) , mergeMap ( result => this . pluginService . runHook ( hookResultName , result , params ) ) ) } async wrapFun < U , T , V extends ClientFilterHookName > ( fun < U , T > , params : U , hookName : V ) { const result = fun ( params ) return this . pluginService . runHook ( hookName , result , params ) } runAction < T , U extends ClientActionHookName > ( hookName : U , scope , params ? : T ) { this . pluginService . ensurePluginsAreLoaded ( scope ) . then ( ( ) => this . pluginService . runHook ( hookName , undefined , params ) ) . catch ( ( err ) => console . error ( 's' , { err } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O $PluginService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ObservableFunction$ O O O O O O O O O O $PluginClientScope$ O $H1$ O $H2$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RawFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginClientScope$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O
import { RegisterClientHookOptions } from 's' export type RegisterClientOptions = { registerHook : ( options ) => void peertubeHelpers : RegisterClientHelpers } export type RegisterClientHelpers = { getBaseStaticRoute : ( ) => string getSettings : ( ) => Promise < { [ name ] : string } > translate : ( toTranslate ) => Promise < string > }	O O O O O O O O O O O O O O $RegisterClientHookOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O
import { RegisterClientOptions } from 's' export interface ClientScript { register : ( options ) => Promise < any > }	O O O O O O O O O O O O O $RegisterClientOptions$ O O O O O O O
import { Inject , Injectable , LOCALE_ID , NgZone } from 's' import { Router } from 's' import { getCompleteLocale , isDefaultLocale , peertubeTranslate , ServerConfigPlugin } from 's' import { ServerService } from 's' import { ClientScript } from 's' import { ClientScript as ClientScriptModule } from 's' import { environment } from 's' import { Observable , of , ReplaySubject } from 's' import { catchError , first , map , shareReplay } from 's' import { getHookType , internalRunHook } from 's' import { ClientHook , ClientHookName , clientHookObject } from 's' import { PluginClientScope } from 's' import { RegisterClientHookOptions } from 's' import { HttpClient } from 's' import { RestExtractor } from 's' import { PluginType } from 's' import { PublicServerSetting } from 's' import { getDevLocale , isOnDevLocale } from 's' import { RegisterClientHelpers } from 's' import { PluginTranslation } from 's' import { importModule } from 's' interface HookStructValue extends RegisterClientHookOptions { plugin : ServerConfigPlugin clientScript : ClientScript } type PluginInfo = { plugin : ServerConfigPlugin clientScript : ClientScript pluginType : PluginType isTheme : boolean } @ Injectable ( ) export class PluginService implements ClientHook { private static BASE_PLUGIN_API_URL = environment . apiUrl + 's' private static BASE_PLUGIN_URL = environment . apiUrl + 's' pluginsBuilt = new ReplaySubject < boolean > ( 0 ) pluginsLoaded : { [ scope in PluginClientScope ] : ReplaySubject < boolean > } = { common : new ReplaySubject < boolean > ( 0 ) , search : new ReplaySubject < boolean > ( 0 ) , 's' : new ReplaySubject < boolean > ( 0 ) } translationsObservable : Observable < PluginTranslation > private plugins : ServerConfigPlugin [ ] = [ ] private scopes : { [ scopeName ] : PluginInfo [ ] } = { } private loadedScripts : { [ script ] : boolean } = { } private loadedScopes : PluginClientScope [ ] = [ ] private loadingScopes : { [ id in PluginClientScope ] ? : boolean } = { } private hooks : { [ name ] : HookStructValue [ ] } = { } constructor ( private router , private server , private zone , private authHttp , private restExtractor , @ Inject ( LOCALE_ID ) private localeId ) { this . loadTranslations ( ) } initializePlugins ( ) { this . server . configLoaded . subscribe ( ( ) => { this . plugins = this . server . getConfig ( ) . plugin . registered this . buildScopeStruct ( ) this . pluginsBuilt . next ( true ) } ) } ensurePluginsAreBuilt ( ) { return this . pluginsBuilt . asObservable ( ) . pipe ( first ( ) , shareReplay ( ) ) . toPromise ( ) } ensurePluginsAreLoaded ( scope ) { this . loadPluginsByScope ( scope ) return this . pluginsLoaded [ scope ] . asObservable ( ) . pipe ( first ( ) , shareReplay ( ) ) . toPromise ( ) } addPlugin ( plugin , isTheme = false ) { const pathPrefix = this . getPluginPathPrefix ( isTheme ) for ( const key of Object . keys ( plugin . clientScripts ) ) { const clientScript = plugin . clientScripts [ key ] for ( const scope of clientScript . scopes ) { if ( ! this . scopes [ scope ] ) this . scopes [ scope ] = [ ] this . scopes [ scope ] . push ( { plugin , clientScript : { script : environment . apiUrl + `template` , scopes : clientScript . scopes } , pluginType : isTheme ? PluginType . THEME : PluginType . PLUGIN , isTheme } ) this . loadedScripts [ clientScript . script ] = false } } } removePlugin ( plugin ) { for ( const key of Object . keys ( this . scopes ) ) { this . scopes [ key ] = this . scopes [ key ] . filter ( o => o . plugin . name !== plugin . name ) } } async reloadLoadedScopes ( ) { for ( const scope of this . loadedScopes ) { await this . loadPluginsByScope ( scope , true ) } } async loadPluginsByScope ( scope , isReload = false ) { if ( this . loadingScopes [ scope ] ) return if ( ! isReload && this . loadedScopes . includes ( scope ) ) return this . loadingScopes [ scope ] = true try { await this . ensurePluginsAreBuilt ( ) if ( ! isReload ) this . loadedScopes . push ( scope ) const toLoad = this . scopes [ scope ] if ( ! Array . isArray ( toLoad ) ) { this . loadingScopes [ scope ] = false this . pluginsLoaded [ scope ] . next ( true ) return } const promises : Promise < any > [ ] = [ ] for ( const pluginInfo of toLoad ) { const clientScript = pluginInfo . clientScript if ( this . loadedScripts [ clientScript . script ] ) continue promises . push ( this . loadPlugin ( pluginInfo ) ) this . loadedScripts [ clientScript . script ] = true } await Promise . all ( promises ) this . pluginsLoaded [ scope ] . next ( true ) this . loadingScopes [ scope ] = false } catch ( err ) { console . error ( 's' , scope , err ) } } runHook < T > ( hookName , result ? : T , params ? ) < T > { return this . zone . runOutsideAngular ( async ( ) => { if ( ! this . hooks [ hookName ] ) return result const hookType = getHookType ( hookName ) for ( const hook of this . hooks [ hookName ] ) { console . log ( 's' , hookName , hook . plugin . name ) result = await internalRunHook ( hook . handler , hookType , result , params , err => { console . error ( 's' , hookName , hook . clientScript . script , hook . plugin . name , err ) } ) } return result } ) } nameToNpmName ( name , type ) { const prefix = type === PluginType . PLUGIN ? 's' : 's' return prefix + name } pluginTypeFromNpmName ( npmName ) { return npmName . startsWith ( 's' ) ? PluginType . PLUGIN : PluginType . THEME } private loadPlugin ( pluginInfo ) { const { plugin , clientScript } = pluginInfo const registerHook = ( options ) => { if ( clientHookObject [ options . target ] !== true ) { console . error ( 's' , options . target , plugin . name ) return } if ( ! this . hooks [ options . target ] ) this . hooks [ options . target ] = [ ] this . hooks [ options . target ] . push ( { plugin , clientScript , target : options . target , handler : options . handler , priority : options . priority || 0 } ) } const peertubeHelpers = this . buildPeerTubeHelpers ( pluginInfo ) console . log ( 's' , clientScript . script , plugin . name ) return this . zone . runOutsideAngular ( ( ) => { return importModule ( clientScript . script ) . then ( ( script ) => script . register ( { registerHook , peertubeHelpers } ) ) . then ( ( ) => this . sortHooksByPriority ( ) ) . catch ( err => console . error ( 's' , pluginInfo . plugin . name , err ) ) } ) } private buildScopeStruct ( ) { for ( const plugin of this . plugins ) { this . addPlugin ( plugin ) } } private sortHooksByPriority ( ) { for ( const hookName of Object . keys ( this . hooks ) ) { this . hooks [ hookName ] . sort ( ( a , b ) => { return b . priority - a . priority } ) } } private buildPeerTubeHelpers ( pluginInfo ) { const { plugin } = pluginInfo const npmName = this . nameToNpmName ( pluginInfo . plugin . name , pluginInfo . pluginType ) return { getBaseStaticRoute : ( ) => { const pathPrefix = this . getPluginPathPrefix ( pluginInfo . isTheme ) return environment . apiUrl + `template` } , getSettings : ( ) => { const path = PluginService . BASE_PLUGIN_API_URL + 's' + npmName + 's' return this . authHttp . get < PublicServerSetting > ( path ) . pipe ( map ( p => p . publicSettings ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) . toPromise ( ) } , translate : ( value ) => { return this . translationsObservable . pipe ( map ( allTranslations => allTranslations [ npmName ] ) ) . pipe ( map ( translations => peertubeTranslate ( value , translations ) ) ) . toPromise ( ) } } } private loadTranslations ( ) { const completeLocale = isOnDevLocale ( ) ? getDevLocale ( ) : getCompleteLocale ( this . localeId ) if ( isDefaultLocale ( completeLocale ) ) this . translationsObservable = of ( { } ) . pipe ( shareReplay ( ) ) this . translationsObservable = this . authHttp . get < PluginTranslation > ( PluginService . BASE_PLUGIN_URL + 's' + completeLocale + 's' ) . pipe ( shareReplay ( ) ) } private getPluginPathPrefix ( isTheme ) { return isTheme ? 's' : 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $Router$ O O $ServerService$ O O $NgZone$ O O $HttpClient$ O O $RestExtractor$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginClientScope$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfigPlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfigPlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginClientScope$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O $ClientHookName$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O $RegisterClientHookOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientScriptModule$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisterClientHelpers$ O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O
import { ActivatedRouteSnapshot , DetachedRouteHandle , RouteReuseStrategy } from 's' export class CustomReuseStrategy implements RouteReuseStrategy { storedRouteHandles = new Map < string , DetachedRouteHandle > ( ) recentlyUsed : string private readonly MAX_SIZE = 0 shouldDetach ( route ) { return this . isReuseEnabled ( route ) } store ( route , handle ) { if ( ! handle ) return const key = this . generateKey ( route ) this . recentlyUsed = key console . log ( 's' , key ) ; ( handle as any ) . componentRef . instance . disableForReuse ( ) this . storedRouteHandles . set ( key , handle ) this . gb ( ) } shouldAttach ( route ) { const key = this . generateKey ( route ) return this . isReuseEnabled ( route ) && this . storedRouteHandles . has ( key ) } retrieve ( route ) { if ( ! this . isReuseEnabled ( route ) ) return undefined const key = this . generateKey ( route ) this . recentlyUsed = key console . log ( 's' , key ) const handle = this . storedRouteHandles . get ( key ) if ( ! handle ) return handle ; ( handle as any ) . componentRef . instance . enabledForReuse ( ) return handle } shouldReuseRoute ( future , curr ) { return future . routeConfig === curr . routeConfig } private gb ( ) { if ( this . storedRouteHandles . size >= this . MAX_SIZE ) { this . storedRouteHandles . forEach ( ( r , key ) => { if ( key === this . recentlyUsed ) return console . log ( 's' , key ) ; ( r as any ) . componentRef . destroy ( ) this . storedRouteHandles . delete ( key ) } ) } } private generateKey ( route ) { const reuse = route . data . reuse if ( ! reuse ) return undefined return reuse . key + JSON . stringify ( route . queryParams ) } private isReuseEnabled ( route ) { return route . data . reuse && route . data . reuse . enabled && route . queryParams [ 's' ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $ActivatedRouteSnapshot$ O O O O O O O O O O $void$ O $ActivatedRouteSnapshot$ O $DetachedRouteHandle$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DetachedRouteHandle$ O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $ActivatedRouteSnapshot$ O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRouteSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O
export interface DisableForReuseHook { disableForReuse ( ) : void enabledForReuse ( ) : void }	O O O O O O O O O O O O O O O
import { Injectable } from 's' import { ActivatedRouteSnapshot , CanActivate , CanActivateChild , Router , RouterStateSnapshot } from 's' import { AuthService } from 's' import { RedirectService } from 's' @ Injectable ( ) export class UnloggedGuard implements CanActivate , CanActivateChild { constructor ( private router , private auth , private redirectService ) { } canActivate ( route , state ) { if ( this . auth . isLoggedIn ( ) === false ) return true this . redirectService . redirectToHomepage ( ) return false } canActivateChild ( route , state ) { return this . canActivate ( route , state ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $AuthService$ O O $RedirectService$ O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivatedRouteSnapshot$ O $RouterStateSnapshot$ O O O O O O O O O O O O O
export * from 's'	O O O O
import { Component , ElementRef , ViewChild } from 's' import { Notifier } from 's' import { NgbModal } from 's' import { About } from 's' import { UserService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class InstanceConfigWarningModalComponent { @ ViewChild ( 's' , { static : true } ) modal : ElementRef stopDisplayModal = false about : About constructor ( private userService , private modalService , private notifier ) { } show ( about ) { this . about = about const ref = this . modalService . open ( this . modal ) ref . result . finally ( ( ) => { if ( this . stopDisplayModal === true ) this . doNotOpenAgain ( ) } ) } isDefaultShortDescription ( description ) { return description === 's' + 's' } private doNotOpenAgain ( ) { this . userService . updateMyProfile ( { noInstanceConfigWarningModal : true } ) . subscribe ( ( ) => console . log ( 's' ) , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $NgbModal$ O O $Notifier$ O O O O O $About$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , ViewChild } from 's' import { Notifier } from 's' import { NgbModal } from 's' import { UserService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class WelcomeModalComponent { @ ViewChild ( 's' , { static : true } ) modal : ElementRef constructor ( private userService , private modalService , private notifier ) { } show ( ) { const ref = this . modalService . open ( this . modal , { backdrop : 's' , keyboard : false , size : 's' } ) ref . result . finally ( ( ) => this . doNotOpenAgain ( ) ) } private doNotOpenAgain ( ) { this . userService . updateMyProfile ( { noWelcomeModal : true } ) . subscribe ( ( ) => console . log ( 's' ) , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserService$ O O $NgbModal$ O O $Notifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { UserService , UserValidatorsService , FormReactive } from 's' import { Notifier } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { ResetPasswordValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ResetPasswordComponent extends FormReactive implements OnInit { private userId : number private verificationString : string constructor ( protected formValidatorService , private resetPasswordValidatorsService , private userValidatorsService , private userService , private notifier , private router , private route , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { password : this . userValidatorsService . USER_PASSWORD , 's' : this . resetPasswordValidatorsService . RESET_PASSWORD_CONFIRM } ) this . userId = this . route . snapshot . queryParams [ 's' ] this . verificationString = this . route . snapshot . queryParams [ 's' ] if ( ! this . userId || ! this . verificationString ) { this . notifier . error ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' ] ) } } resetPassword ( ) { this . userService . resetPassword ( this . userId , this . verificationString , this . form . value . password ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' ] ) } , err => this . notifier . error ( err . message ) ) } isConfirmedPasswordValid ( ) { const values = this . form . value return values . password === values [ 's' ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $ResetPasswordValidatorsService$ O O $UserValidatorsService$ O O $UserService$ O O $Notifier$ O O $Router$ O O $ActivatedRoute$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { ResetPasswordComponent } from 's' const resetPasswordRoutes = [ { path : 's' , component : ResetPasswordComponent , canActivate : [ MetaGuard ] , data : { meta : { title : 's' } } } ] @ NgModule ( { imports : [ RouterModule . forChild ( resetPasswordRoutes ) ] , exports : [ RouterModule ] } ) export class ResetPasswordRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { ResetPasswordRoutingModule } from 's' import { ResetPasswordComponent } from 's' import { SharedModule } from 's' @ NgModule ( { imports : [ ResetPasswordRoutingModule , SharedModule ] , declarations : [ ResetPasswordComponent ] , exports : [ ResetPasswordComponent ] , providers : [ ] } ) export class ResetPasswordModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { NSFWQuery } from 's' export class AdvancedSearch { startDate : string endDate : string originallyPublishedStartDate : string originallyPublishedEndDate : string nsfw : NSFWQuery categoryOneOf : string licenceOneOf : string languageOneOf : string tagsOneOf : string tagsAllOf : string durationMin : number durationMax : number sort : string constructor ( options ? : { startDate ? : string endDate ? : string originallyPublishedStartDate ? : string originallyPublishedEndDate ? : string nsfw ? : NSFWQuery categoryOneOf ? : string licenceOneOf ? : string languageOneOf ? : string tagsOneOf ? : string tagsAllOf ? : string durationMin ? : string durationMax ? : string sort ? : string } ) { if ( ! options ) return this . startDate = options . startDate || undefined this . endDate = options . endDate || undefined this . originallyPublishedStartDate = options . originallyPublishedStartDate || undefined this . originallyPublishedEndDate = options . originallyPublishedEndDate || undefined this . nsfw = options . nsfw || undefined this . categoryOneOf = options . categoryOneOf || undefined this . licenceOneOf = options . licenceOneOf || undefined this . languageOneOf = options . languageOneOf || undefined this . tagsOneOf = options . tagsOneOf || undefined this . tagsAllOf = options . tagsAllOf || undefined this . durationMin = parseInt ( options . durationMin , 0 ) this . durationMax = parseInt ( options . durationMax , 0 ) if ( isNaN ( this . durationMin ) ) this . durationMin = undefined if ( isNaN ( this . durationMax ) ) this . durationMax = undefined this . sort = options . sort || 's' } containsValues ( ) { const obj = this . toUrlObject ( ) for ( const k of Object . keys ( obj ) ) { if ( k === 's' ) continue if ( obj [ k ] !== undefined ) return true } return false } reset ( ) { this . startDate = undefined this . endDate = undefined this . originallyPublishedStartDate = undefined this . originallyPublishedEndDate = undefined this . nsfw = undefined this . categoryOneOf = undefined this . licenceOneOf = undefined this . languageOneOf = undefined this . tagsOneOf = undefined this . tagsAllOf = undefined this . durationMin = undefined this . durationMax = undefined this . sort = 's' } toUrlObject ( ) { return { startDate : this . startDate , endDate : this . endDate , originallyPublishedStartDate : this . originallyPublishedStartDate , originallyPublishedEndDate : this . originallyPublishedEndDate , nsfw : this . nsfw , categoryOneOf : this . categoryOneOf , licenceOneOf : this . licenceOneOf , languageOneOf : this . languageOneOf , tagsOneOf : this . tagsOneOf , tagsAllOf : this . tagsAllOf , durationMin : this . durationMin , durationMax : this . durationMax , sort : this . sort } } toAPIObject ( ) { return { startDate : this . startDate , endDate : this . endDate , originallyPublishedStartDate : this . originallyPublishedStartDate , originallyPublishedEndDate : this . originallyPublishedEndDate , nsfw : this . nsfw , categoryOneOf : this . intoArray ( this . categoryOneOf ) , licenceOneOf : this . intoArray ( this . licenceOneOf ) , languageOneOf : this . intoArray ( this . languageOneOf ) , tagsOneOf : this . intoArray ( this . tagsOneOf ) , tagsAllOf : this . intoArray ( this . tagsAllOf ) , durationMin : this . durationMin , durationMax : this . durationMax , sort : this . sort } } size ( ) { let acc = 0 const obj = this . toUrlObject ( ) for ( const k of Object . keys ( obj ) ) { if ( k === 's' ) continue if ( obj [ k ] !== undefined ) acc ++ } return acc } private intoArray ( value ) { if ( ! value ) return undefined if ( typeof value === 's' ) return value . split ( 's' ) return [ value ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { SearchComponent } from 's' const searchRoutes = [ { path : 's' , component : SearchComponent , canActivate : [ MetaGuard ] , data : { meta : { title : 's' } } } ] @ NgModule ( { imports : [ RouterModule . forChild ( searchRoutes ) ] , exports : [ RouterModule ] } ) export class SearchRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { AuthService , Notifier } from 's' import { forkJoin , Subscription } from 's' import { SearchService } from 's' import { ComponentPagination } from 's' import { 0 } from 's' import { MetaService } from 's' import { AdvancedSearch } from 's' import { VideoChannel } from 's' import { immutableAssign } from 's' import { Video } from 's' import { HooksService } from 's' import { PluginService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class SearchComponent implements OnInit , OnDestroy { results : ( Video | VideoChannel ) [ ] = [ ] pagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } advancedSearch : AdvancedSearch = new AdvancedSearch ( ) isSearchFilterCollapsed = true currentSearch : string private subActivatedRoute : Subscription private isInitialLoad = false private firstSearch = true private channelsPerPage = 0 constructor ( private 0 , private route , private router , private metaService , private notifier , private searchService , private authService , private hooks , private pluginService ) { } get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . subActivatedRoute = this . route . queryParams . subscribe ( queryParams => { const querySearch = queryParams [ 's' ] if ( this . currentSearch !== querySearch ) { this . resetPagination ( ) this . advancedSearch . reset ( ) this . currentSearch = querySearch || undefined this . updateTitle ( ) } this . advancedSearch = new AdvancedSearch ( queryParams ) this . isSearchFilterCollapsed = this . isInitialLoad === false || ! this . advancedSearch . containsValues ( ) this . isInitialLoad = false this . search ( ) } , err => this . notifier . error ( err . text ) ) this . hooks . runAction ( 's' , 's' ) } ngOnDestroy ( ) { if ( this . subActivatedRoute ) this . subActivatedRoute . unsubscribe ( ) } isVideoChannel ( d : VideoChannel | Video ) : d is VideoChannel { return d instanceof VideoChannel } isVideo ( v : VideoChannel | Video ) : v is Video { return v instanceof Video } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } search ( ) { forkJoin ( [ this . getVideosObs ( ) , this . getVideoChannelObs ( ) ] ) . subscribe ( ( [ videosResult , videoChannelsResult ] ) => { this . results = this . results . concat ( videoChannelsResult . data ) . concat ( videosResult . data ) this . pagination . totalItems = videosResult . total + videoChannelsResult . total if ( this . firstSearch === true && videosResult . data . length < this . pagination . itemsPerPage ) { this . resetPagination ( ) this . firstSearch = false this . channelsPerPage = 0 this . search ( ) } this . firstSearch = false } , err => this . notifier . error ( err . message ) ) } onNearOfBottom ( ) { if ( this . pagination . totalItems <= ( this . pagination . currentPage * this . pagination . itemsPerPage ) ) return this . pagination . currentPage += 0 this . search ( ) } onFiltered ( ) { this . resetPagination ( ) this . updateUrlFromAdvancedSearch ( ) } numberOfFilters ( ) { return this . advancedSearch . size ( ) } removeVideoFromArray ( video ) { this . results = this . results . filter ( r => ! this . isVideo ( r ) || r . id !== video . id ) } private resetPagination ( ) { this . pagination . currentPage = 0 this . pagination . totalItems = null this . channelsPerPage = 0 this . results = [ ] } private updateTitle ( ) { const suffix = this . currentSearch ? 's' + this . currentSearch : 's' this . metaService . setTitle ( this . 0 ( 's' ) + suffix ) } private updateUrlFromAdvancedSearch ( ) { const search = this . currentSearch || undefined this . router . navigate ( [ ] , { relativeTo : this . route , queryParams : Object . assign ( { } , this . advancedSearch . toUrlObject ( ) , { search } ) } ) } private getVideosObs ( ) { const params = { search : this . currentSearch , componentPagination : this . pagination , advancedSearch : this . advancedSearch } return this . hooks . wrapObsFun ( this . searchService . searchVideos . bind ( this . searchService ) , params , 's' , 's' , 's' ) } private getVideoChannelObs ( ) { const params = { search : this . currentSearch , componentPagination : immutableAssign ( this . pagination , { itemsPerPage : this . channelsPerPage } ) } return this . hooks . wrapObsFun ( this . searchService . searchVideoChannels . bind ( this . searchService ) , params , 's' , 's' , 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ActivatedRoute$ O O $Router$ O O $MetaService$ O O $Notifier$ O O $SearchService$ O O $AuthService$ O O $HooksService$ O O $PluginService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { SearchComponent } from 's' import { SearchService } from 's' import { SearchRoutingModule } from 's' import { SearchFiltersComponent } from 's' @ NgModule ( { imports : [ SearchRoutingModule , SharedModule ] , declarations : [ SearchComponent , SearchFiltersComponent ] , exports : [ SearchComponent ] , providers : [ SearchService ] } ) export class SearchModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnInit , Output } from 's' import { ServerService } from 's' import { 0 } from 's' import { AdvancedSearch } from 's' import { VideoConstant } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class SearchFiltersComponent implements OnInit { @ Input ( ) advancedSearch : AdvancedSearch = new AdvancedSearch ( ) @ Output ( ) filtered = new EventEmitter < AdvancedSearch > ( ) videoCategories : VideoConstant < number > [ ] = [ ] videoLicences : VideoConstant < number > [ ] = [ ] videoLanguages : VideoConstant < string > [ ] = [ ] publishedDateRanges : { id : string , label : string } [ ] = [ ] sorts : { id : string , label : string } [ ] = [ ] durationRanges : { id : string , label : string } [ ] = [ ] publishedDateRange : string durationRange : string originallyPublishedStartYear : string originallyPublishedEndYear : string constructor ( private 0 , private serverService ) { this . publishedDateRanges = [ { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } ] this . durationRanges = [ { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } ] this . sorts = [ { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } , { id : 's' , label : this . 0 ( 's' ) } ] } ngOnInit ( ) { this . videoCategories = this . serverService . getVideoCategories ( ) this . videoLicences = this . serverService . getVideoLicences ( ) this . videoLanguages = this . serverService . getVideoLanguages ( ) this . loadFromDurationRange ( ) this . loadFromPublishedRange ( ) this . loadOriginallyPublishedAtYears ( ) } formUpdated ( ) { this . updateModelFromDurationRange ( ) this . updateModelFromPublishedRange ( ) this . updateModelFromOriginallyPublishedAtYears ( ) this . filtered . emit ( this . advancedSearch ) } private loadOriginallyPublishedAtYears ( ) { this . originallyPublishedStartYear = this . advancedSearch . originallyPublishedStartDate ? new Date ( this . advancedSearch . originallyPublishedStartDate ) . getFullYear ( ) . toString ( ) : null this . originallyPublishedEndYear = this . advancedSearch . originallyPublishedEndDate ? new Date ( this . advancedSearch . originallyPublishedEndDate ) . getFullYear ( ) . toString ( ) : null } private loadFromDurationRange ( ) { if ( this . advancedSearch . durationMin || this . advancedSearch . durationMax ) { const fourMinutes = 0 * 0 const tenMinutes = 0 * 0 if ( this . advancedSearch . durationMin === fourMinutes && this . advancedSearch . durationMax === tenMinutes ) { this . durationRange = 's' } else if ( this . advancedSearch . durationMax === fourMinutes ) { this . durationRange = 's' } else if ( this . advancedSearch . durationMin === tenMinutes ) { this . durationRange = 's' } } } private loadFromPublishedRange ( ) { if ( this . advancedSearch . startDate ) { const date = new Date ( this . advancedSearch . startDate ) const now = new Date ( ) const diff = Math . abs ( date . getTime ( ) - now . getTime ( ) ) const dayMS = 0 * 0 * 0 const numberOfDays = diff / dayMS if ( numberOfDays >= 0 ) this . publishedDateRange = 's' else if ( numberOfDays >= 0 ) this . publishedDateRange = 's' else if ( numberOfDays >= 0 ) this . publishedDateRange = 's' else if ( numberOfDays >= 0 ) this . publishedDateRange = 's' } } private updateModelFromOriginallyPublishedAtYears ( ) { const baseDate = new Date ( ) baseDate . setHours ( 0 , 0 , 0 , 0 ) baseDate . setMonth ( 0 , 0 ) if ( this . originallyPublishedStartYear ) { const year = parseInt ( this . originallyPublishedStartYear , 0 ) const start = new Date ( baseDate ) start . setFullYear ( year ) this . advancedSearch . originallyPublishedStartDate = start . toISOString ( ) } else { this . advancedSearch . originallyPublishedStartDate = null } if ( this . originallyPublishedEndYear ) { const year = parseInt ( this . originallyPublishedEndYear , 0 ) const end = new Date ( baseDate ) end . setFullYear ( year ) this . advancedSearch . originallyPublishedEndDate = end . toISOString ( ) } else { this . advancedSearch . originallyPublishedEndDate = null } } private updateModelFromDurationRange ( ) { if ( ! this . durationRange ) return const fourMinutes = 0 * 0 const tenMinutes = 0 * 0 switch ( this . durationRange ) { case 's' : this . advancedSearch . durationMin = undefined this . advancedSearch . durationMax = fourMinutes break case 's' : this . advancedSearch . durationMin = fourMinutes this . advancedSearch . durationMax = tenMinutes break case 's' : this . advancedSearch . durationMin = tenMinutes this . advancedSearch . durationMax = undefined break } } private updateModelFromPublishedRange ( ) { if ( ! this . publishedDateRange ) return const date = new Date ( ) date . setHours ( 0 , 0 , 0 , 0 ) switch ( this . publishedDateRange ) { case 's' : date . setDate ( date . getDate ( ) - 0 ) break case 's' : date . setDate ( date . getDate ( ) - 0 ) break case 's' : date . setDate ( date . getDate ( ) - 0 ) break } this . advancedSearch . startDate = date . toISOString ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , switchMap } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { Observable } from 's' import { ComponentPagination } from 's' import { VideoService } from 's' import { RestExtractor , RestService } from 's' import { environment } from 's' import { ResultList , Video as VideoServerModel , VideoChannel as VideoChannelServerModel } from 's' import { Video } from 's' import { AdvancedSearch } from 's' import { VideoChannel } from 's' import { VideoChannelService } from 's' @ Injectable ( ) export class SearchService { static BASE_SEARCH_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService , private videoService ) { } searchVideos ( parameters : { search : string , componentPagination : ComponentPagination , advancedSearch : AdvancedSearch } ) < ResultList < Video > > { const { search , componentPagination , advancedSearch } = parameters const url = SearchService . BASE_SEARCH_URL + 's' const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) if ( search ) params = params . append ( 's' , search ) const advancedSearchObject = advancedSearch . toAPIObject ( ) params = this . restService . addObjectParams ( params , advancedSearchObject ) return this . authHttp . get < ResultList < VideoServerModel > > ( url , { params } ) . pipe ( switchMap ( res => this . videoService . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } searchVideoChannels ( parameters : { search : string , componentPagination : ComponentPagination } ) < ResultList < VideoChannel > > { const { search , componentPagination } = parameters const url = SearchService . BASE_SEARCH_URL + 's' const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) params = params . append ( 's' , search ) return this . authHttp . get < ResultList < VideoChannelServerModel > > ( url , { params } ) . pipe ( map ( res => VideoChannelService . extractVideoChannels ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $VideoService$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { map , tap , catchError } from 's' import { Injectable } from 's' import { environment } from 's' import { Observable , ReplaySubject } from 's' import { Account } from 's' import { RestExtractor } from 's' import { HttpClient } from 's' import { Account as ServerAccount } from 's' @ Injectable ( ) export class AccountService { static BASE_ACCOUNT_URL = environment . apiUrl + 's' accountLoaded = new ReplaySubject < Account > ( 0 ) constructor ( private authHttp , private restExtractor ) { } getAccount ( id : number | string ) < Account > { return this . authHttp . get < ServerAccount > ( AccountService . BASE_ACCOUNT_URL + id ) . pipe ( map ( accountHash => new Account ( accountHash ) ) , tap ( account => this . accountLoaded . next ( account ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' import { 0 } from 's' @ Pipe ( { name : 's' } ) export class FromNowPipe implements PipeTransform { constructor ( private 0 ) { } transform ( arg : number | Date | string ) { const argDate = new Date ( arg ) const seconds = Math . floor ( ( Date . now ( ) - argDate . getTime ( ) ) / 0 ) let interval = Math . floor ( seconds / 0 ) if ( interval > 0 ) { return this . 0 ( 's' , { interval } ) } interval = Math . floor ( seconds / 0 ) if ( interval > 0 ) return this . 0 ( 's' , { interval } ) if ( interval === 0 ) return this . 0 ( 's' , { interval } ) interval = Math . floor ( seconds / 0 ) if ( interval > 0 ) return this . 0 ( 's' , { interval } ) if ( interval === 0 ) return this . 0 ( 's' , { interval } ) interval = Math . floor ( seconds / 0 ) if ( interval > 0 ) return this . 0 ( 's' , { interval } ) if ( interval === 0 ) return this . 0 ( 's' , { interval } ) interval = Math . floor ( seconds / 0 ) if ( interval > 0 ) return this . 0 ( 's' , { interval } ) if ( interval === 0 ) return this . 0 ( 's' , { interval } ) interval = Math . floor ( seconds / 0 ) if ( interval >= 0 ) return this . 0 ( 's' , { interval } ) return this . 0 ( 's' , { interval : Math . max ( 0 , seconds ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' @ Pipe ( { name : 's' } ) export class NumberFormatterPipe implements PipeTransform { private dictionary : Array < { max : number , type : string } > = [ { max : 0 , type : 's' } , { max : 0 , type : 's' } , { max : 0 , type : 's' } ] transform ( value ) { const format = this . dictionary . find ( d => value < d . max ) || this . dictionary [ this . dictionary . length - 0 ] const calc = Math . floor ( value / ( format . max / 0 ) ) return `template` } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Pipe , PipeTransform } from 's' @ Pipe ( { name : 's' } ) export class ObjectLengthPipe implements PipeTransform { transform ( value ) { return Object . keys ( value ) . length } }	O O O O O O O O O O O O O O O O O O O O O O O O O $Object$ O O O O O O O O O O O O O
import { Directive , Input , TemplateRef } from 's' @ Directive ( { selector : 's' } ) export class PeerTubeTemplateDirective < T extends string > { @ Input ( 's' ) name : T constructor ( public template < any > ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TemplateRef$ O O O O O O O
import { AccountBlock as AccountBlockServer } from 's' import { Account } from 's' export class AccountBlock implements AccountBlockServer { byAccount : Account blockedAccount : Account createdAt : Date | string constructor ( block ) { this . byAccount = new Account ( block . byAccount ) this . blockedAccount = new Account ( block . blockedAccount ) this . createdAt = block . createdAt } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountBlockServer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { environment } from 's' import { HttpClient , HttpParams } from 's' import { RestExtractor , RestPagination , RestService } from 's' import { SortMeta } from 's' import { catchError , map } from 's' import { AccountBlock as AccountBlockServer , ResultList , ServerBlock } from 's' import { Account } from 's' import { AccountBlock } from 's' @ Injectable ( ) export class BlocklistService { static BASE_USER_BLOCKLIST_URL = environment . apiUrl + 's' static BASE_SERVER_BLOCKLIST_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService ) { } getUserAccountBlocklist ( pagination , sort ) { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < AccountBlock > > ( BlocklistService . BASE_USER_BLOCKLIST_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , map ( res => this . restExtractor . applyToResultListData ( res , this . formatAccountBlock . bind ( this ) ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } blockAccountByUser ( account ) { const body = { accountName : account . nameWithHost } return this . authHttp . post ( BlocklistService . BASE_USER_BLOCKLIST_URL + 's' , body ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } unblockAccountByUser ( account ) { const path = BlocklistService . BASE_USER_BLOCKLIST_URL + 's' + account . nameWithHost return this . authHttp . delete ( path ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } getUserServerBlocklist ( pagination , sort ) { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < ServerBlock > > ( BlocklistService . BASE_USER_BLOCKLIST_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } blockServerByUser ( host ) { const body = { host } return this . authHttp . post ( BlocklistService . BASE_USER_BLOCKLIST_URL + 's' , body ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } unblockServerByUser ( host ) { const path = BlocklistService . BASE_USER_BLOCKLIST_URL + 's' + host return this . authHttp . delete ( path ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } getInstanceAccountBlocklist ( pagination , sort ) { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < AccountBlock > > ( BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , map ( res => this . restExtractor . applyToResultListData ( res , this . formatAccountBlock . bind ( this ) ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } blockAccountByInstance ( account ) { const body = { accountName : account . nameWithHost } return this . authHttp . post ( BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' , body ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } unblockAccountByInstance ( account ) { const path = BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' + account . nameWithHost return this . authHttp . delete ( path ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } getInstanceServerBlocklist ( pagination , sort ) { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < ServerBlock > > ( BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } blockServerByInstance ( host ) { const body = { host } return this . authHttp . post ( BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' , body ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } unblockServerByInstance ( host ) { const path = BlocklistService . BASE_SERVER_BLOCKLIST_URL + 's' + host return this . authHttp . delete ( path ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } private formatAccountBlock ( accountBlock ) { return new AccountBlock ( accountBlock ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O O O O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountBlockServer$ O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import { Component , ElementRef , HostListener , OnInit , ViewChild } from 's' import { ConfirmService } from 's' import { 0 } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { POP_STATE_MODAL_DISMISS } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class ConfirmComponent implements OnInit { @ ViewChild ( 's' , { static : true } ) confirmModal : ElementRef title = 's' message = 's' expectedInputValue = 's' inputLabel = 's' inputValue = 's' confirmButtonText = 's' private openedModal : NgbModalRef constructor ( private modalService , private confirmService , private 0 ) { } ngOnInit ( ) { this . confirmService . showConfirm . subscribe ( ( { title , message , expectedInputValue , inputLabel , confirmButtonText } ) => { this . title = title this . message = message this . inputLabel = inputLabel this . expectedInputValue = expectedInputValue this . confirmButtonText = confirmButtonText || this . 0 ( 's' ) this . showModal ( ) } ) } @ HostListener ( 's' ) confirm ( ) { if ( this . openedModal ) this . openedModal . close ( ) } isConfirmationDisabled ( ) { if ( ! this . inputLabel || ! this . expectedInputValue ) return false return this . expectedInputValue !== this . inputValue } showModal ( ) { this . inputValue = 's' this . openedModal = this . modalService . open ( this . confirmModal ) this . openedModal . result . then ( ( ) => this . confirmService . confirmResponse . next ( true ) ) . catch ( ( reason ) => { if ( ! reason || reason !== POP_STATE_MODAL_DISMISS ) { this . confirmService . confirmResponse . next ( false ) } } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbModal$ O O $ConfirmService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { debounceTime , distinctUntilChanged } from 's' import { Component , forwardRef , Input , OnInit } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' import { Subject } from 's' import truncate from 's' import { ScreenService } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => MarkdownTextareaComponent ) , multi : true } ] } ) export class MarkdownTextareaComponent implements ControlValueAccessor , OnInit { @ Input ( ) content = 's' @ Input ( ) classes : string [ ] = [ ] @ Input ( ) textareaWidth = 's' @ Input ( ) textareaHeight = 's' @ Input ( ) previewColumn = false @ Input ( ) truncate : number @ Input ( ) markdownType : 's' | 's' = 's' textareaMarginRight = 's' flexDirection = 's' truncatedPreviewHTML = 's' previewHTML = 's' private contentChanged = new Subject < string > ( ) constructor ( private screenService , private markdownService ) { } ngOnInit ( ) { this . contentChanged . pipe ( debounceTime ( 0 ) , distinctUntilChanged ( ) ) . subscribe ( ( ) => this . updatePreviews ( ) ) this . contentChanged . next ( this . content ) if ( this . previewColumn ) { this . flexDirection = 's' this . textareaMarginRight = 's' } } propagateChange = ( _ ) => { } writeValue ( description ) { this . content = description this . contentChanged . next ( this . content ) } registerOnChange ( fn : ( _ ) => void ) { this . propagateChange = fn } registerOnTouched ( ) { } onModelChange ( ) { this . propagateChange ( this . content ) this . contentChanged . next ( this . content ) } arePreviewsDisplayed ( ) { return this . screenService . isInSmallView ( ) === false } private async updatePreviews ( ) { if ( this . content === null || this . content === undefined ) return this . truncatedPreviewHTML = await this . markdownRender ( truncate ( this . content , { length : this . truncate } ) ) this . previewHTML = await this . markdownRender ( this . content ) } private markdownRender ( text ) { if ( this . markdownType === 's' ) return this . markdownService . textMarkdownToHTML ( text ) return this . markdownService . enhancedMarkdownToHTML ( text ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScreenService$ O O $MarkdownService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AfterContentInit , ChangeDetectorRef , Component , ContentChildren , forwardRef , Input , QueryList , TemplateRef } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' import { PeerTubeTemplateDirective } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => PeertubeCheckboxComponent ) , multi : true } ] } ) export class PeertubeCheckboxComponent implements ControlValueAccessor , AfterContentInit { @ Input ( ) checked = false @ Input ( ) inputName : string @ Input ( ) labelText : string @ Input ( ) helpPlacement = 's' @ Input ( ) disabled = false @ ContentChildren ( PeerTubeTemplateDirective ) templates : QueryList < PeerTubeTemplateDirective < 's' | 's' > > @ Input ( ) onPushWorkaround = false labelTemplate : TemplateRef < any > helpTemplate : TemplateRef < any > constructor ( private cdr ) { } ngAfterContentInit ( ) { { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . labelTemplate = t . template } { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . helpTemplate = t . template } } propagateChange = ( _ ) => { } writeValue ( checked ) { this . checked = checked if ( this . onPushWorkaround ) { this . cdr . markForCheck ( ) } } registerOnChange ( fn : ( _ ) => void ) { this . propagateChange = fn } registerOnTouched ( ) { } onModelChange ( ) { this . propagateChange ( this . checked ) } setDisabledState ( isDisabled ) { this . disabled = isDisabled } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ChangeDetectorRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O
import { VideoFile } from 's' function toTitleCase ( str ) { return str . charAt ( 0 ) . toUpperCase ( ) + str . slice ( 0 ) } function isWebRTCDisabled ( ) { return ! ! ( ( window as any ) . RTCPeerConnection || ( window as any ) . mozRTCPeerConnection || ( window as any ) . webkitRTCPeerConnection ) === false } const dictionaryBytes < { max : number , type : string } > = [ { max : 0 , type : 's' } , { max : 0 , type : 's' } , { max : 0 , type : 's' } , { max : 0 , type : 's' } ] function bytes ( value ) { const format = dictionaryBytes . find ( d => value < d . max ) || dictionaryBytes [ dictionaryBytes . length - 0 ] const calc = Math . floor ( value / ( format . max / 0 ) ) . toString ( ) return [ calc , format . type ] } function isMobile ( ) { return "s" . test ( navigator . userAgent ) } function buildVideoLink ( options : { baseUrl ? : string , startTime ? : number , stopTime ? : number , subtitle ? : string , loop ? : boolean , autoplay ? : boolean , muted ? : boolean , title ? : boolean , warningTitle ? : boolean , controls ? : boolean } = { } ) { const { baseUrl } = options const url = baseUrl ? baseUrl : window . location . origin + window . location . pathname . replace ( 's' , 's' ) const params = new URLSearchParams ( window . location . search ) if ( options . startTime ) { const startTimeInt = Math . floor ( options . startTime ) params . set ( 's' , secondsToTime ( startTimeInt ) ) } if ( options . stopTime ) { const stopTimeInt = Math . floor ( options . stopTime ) params . set ( 's' , secondsToTime ( stopTimeInt ) ) } if ( options . subtitle ) params . set ( 's' , options . subtitle ) if ( options . loop === true ) params . set ( 's' , 's' ) if ( options . autoplay === true ) params . set ( 's' , 's' ) if ( options . muted === true ) params . set ( 's' , 's' ) if ( options . title === false ) params . set ( 's' , 's' ) if ( options . warningTitle === false ) params . set ( 's' , 's' ) if ( options . controls === false ) params . set ( 's' , 's' ) let hasParams = false params . forEach ( ( ) => hasParams = true ) if ( hasParams ) return url + 's' + params . toString ( ) return url } function timeToInt ( time : number | string ) { if ( ! time ) return 0 if ( typeof time === 's' ) return time const reg = "s" const matches = time . match ( reg ) if ( ! matches ) return 0 const hours = parseInt ( matches [ 0 ] || 's' , 0 ) const minutes = parseInt ( matches [ 0 ] || 's' , 0 ) const seconds = parseInt ( matches [ 0 ] || 's' , 0 ) return hours * 0 + minutes * 0 + seconds } function secondsToTime ( seconds , full = false , symbol ? ) { let time = 's' const hourSymbol = ( symbol || 's' ) const minuteSymbol = ( symbol || 's' ) const secondsSymbol = full ? 's' : 's' const hours = Math . floor ( seconds / 0 ) if ( hours >= 0 ) time = hours + hourSymbol else if ( full ) time = 's' + hourSymbol seconds %= 0 const minutes = Math . floor ( seconds / 0 ) if ( minutes >= 0 && minutes < 0 && full ) time += 's' + minutes + minuteSymbol else if ( minutes >= 0 ) time += minutes + minuteSymbol else if ( full ) time += 's' + minuteSymbol seconds %= 0 if ( seconds >= 0 && seconds < 0 && full ) time += 's' + seconds + secondsSymbol else if ( seconds >= 0 ) time += seconds + secondsSymbol else if ( full ) time += 's' return time } function buildVideoEmbed ( embedUrl ) { return 's' + 's' + 's' + embedUrl + 's' + 's' + 's' } function copyToClipboard ( text ) { const el = document . createElement ( 's' ) el . value = text el . setAttribute ( 's' , 's' ) el . style . position = 's' el . style . left = 's' document . body . appendChild ( el ) el . select ( ) document . execCommand ( 's' ) document . body . removeChild ( el ) } function videoFileMaxByResolution ( files : VideoFile [ ] ) { let max = files [ 0 ] for ( let i = 0 ; i < files . length ; i ++ ) { const file = files [ i ] if ( max . resolution . id < file . resolution . id ) max = file } return max } function videoFileMinByResolution ( files : VideoFile [ ] ) { let min = files [ 0 ] for ( let i = 0 ; i < files . length ; i ++ ) { const file = files [ i ] if ( min . resolution . id > file . resolution . id ) min = file } return min } function getRtcConfig ( ) { return { iceServers : [ { urls : 's' } , { urls : 's' } ] } } export { getRtcConfig , toTitleCase , timeToInt , secondsToTime , isWebRTCDisabled , buildVideoLink , buildVideoEmbed , videoFileMaxByResolution , videoFileMinByResolution , copyToClipboard , isMobile , bytes }	O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangeDetectorRef , Component , forwardRef , Input , OnInit } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' import { secondsToTime , timeToInt } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => TimestampInputComponent ) , multi : true } ] } ) export class TimestampInputComponent implements ControlValueAccessor , OnInit { @ Input ( ) maxTimestamp : number @ Input ( ) timestamp : number @ Input ( ) disabled = false timestampString : string constructor ( private changeDetector ) { } ngOnInit ( ) { this . writeValue ( this . timestamp || 0 ) } propagateChange = ( _ ) => { } writeValue ( timestamp ) { this . timestamp = timestamp this . timestampString = secondsToTime ( this . timestamp , true , 's' ) } registerOnChange ( fn : ( _ ) => void ) { this . propagateChange = fn } registerOnTouched ( ) { } onModelChange ( ) { this . timestamp = timeToInt ( this . timestampString ) this . propagateChange ( this . timestamp ) } onBlur ( ) { if ( this . maxTimestamp && this . timestamp > this . maxTimestamp ) { this . writeValue ( this . maxTimestamp ) this . changeDetector . detectChanges ( ) this . propagateChange ( this . timestamp ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ChangeDetectorRef$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { CanDeactivate } from 's' import { Observable } from 's' import { ConfirmService } from 's' import { 0 } from 's' export type CanComponentDeactivateResult = { text ? : string , canDeactivate : Observable < boolean > | boolean } export interface CanComponentDeactivate { canDeactivate : ( ) => CanComponentDeactivateResult } @ Injectable ( ) export class CanDeactivateGuard implements CanDeactivate < CanComponentDeactivate > { constructor ( private confirmService , private 0 ) { } canDeactivate ( component ) { const result = component . canDeactivate ( ) const text = result . text || this . 0 ( 's' ) return result . canDeactivate || this . confirmService . confirm ( text , this . 0 ( 's' ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfirmService$ O O $I18n$ O O O O O $CanComponentDeactivate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { 0 } from 's' import { Injectable } from 's' @ Injectable ( ) export class 0 { private readonly calendarLocale : any = { } constructor ( private 0 ) { this . calendarLocale = { firstDayOfWeek : 0 , dayNames : [ this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) ] , dayNamesShort : [ this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) ] , dayNamesMin : [ this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) ] , monthNames : [ this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) , this . 0 ( 's' ) ] , monthNamesShort : [ this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) , this . 0 ( { value : 's' , description : 's' } ) ] , today : this . 0 ( 's' ) , clear : this . 0 ( 's' ) } } getCalendarLocale ( ) { return this . calendarLocale } getTimezone ( ) { const gmt = new Date ( ) . toString ( ) . match ( "s" ) [ 0 ] const timezone = Intl . DateTimeFormat ( ) . resolvedOptions ( ) . timeZone return `template` } getDateFormat ( ) { return this . 0 ( { value : 's' , description : 's' } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { environment } from 's' function isOnDevLocale ( ) { return environment . production === false && window . location . search === 's' } function getDevLocale ( ) { return 's' } export { getDevLocale , isOnDevLocale }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangeDetectionStrategy , Component , ElementRef , Input , OnInit } from 's' const icons = { 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) , 's' : require ( 's' ) } export type GlobalIconName = keyof typeof icons @ Component ( { selector : 's' , template : 's' , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush } ) export class GlobalIconComponent implements OnInit { @ Input ( ) iconName : GlobalIconName constructor ( private el ) { } ngOnInit ( ) { const nativeElement = this . el . nativeElement nativeElement . innerHTML = icons [ this . iconName ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , forwardRef , Input , OnInit } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' import { DomSanitizer , SafeResourceUrl } from 's' import { ServerService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : forwardRef ( ( ) => PreviewUploadComponent ) , multi : true } ] } ) export class PreviewUploadComponent implements OnInit , ControlValueAccessor { @ Input ( ) inputLabel : string @ Input ( ) inputName : string @ Input ( ) previewWidth : string @ Input ( ) previewHeight : string imageSrc : SafeResourceUrl allowedExtensionsMessage = 's' private file : File constructor ( private sanitizer , private serverService ) { } get videoImageExtensions ( ) { return this . serverService . getConfig ( ) . video . image . extensions } get maxVideoImageSize ( ) { return this . serverService . getConfig ( ) . video . image . size . max } ngOnInit ( ) { this . allowedExtensionsMessage = this . videoImageExtensions . join ( 's' ) } onFileChanged ( file ) { this . file = file this . propagateChange ( this . file ) this . updatePreview ( ) } propagateChange = ( _ ) => { } writeValue ( file ) { this . file = file this . updatePreview ( ) } registerOnChange ( fn : ( _ ) => void ) { this . propagateChange = fn } registerOnTouched ( ) { } private updatePreview ( ) { if ( this . file ) { const url = URL . createObjectURL ( this . file ) this . imageSrc = this . sanitizer . bypassSecurityTrustResourceUrl ( url ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DomSanitizer$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $File$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FeatureBooleanComponent { @ Input ( ) value : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { Observable } from 's' import { ActorFollow , ResultList } from 's' import { environment } from 's' import { RestExtractor , RestPagination , RestService } from 's' import { SortMeta } from 's' @ Injectable ( ) export class FollowService { private static BASE_APPLICATION_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor ) { } getFollowing ( pagination , sort , search ? ) < ResultList < ActorFollow > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) if ( search ) params = params . append ( 's' , search ) return this . authHttp . get < ResultList < ActorFollow > > ( FollowService . BASE_APPLICATION_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } getFollowers ( pagination , sort , search ? ) < ResultList < ActorFollow > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) if ( search ) params = params . append ( 's' , search ) return this . authHttp . get < ResultList < ActorFollow > > ( FollowService . BASE_APPLICATION_URL + 's' , { params } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } follow ( notEmptyHosts : string [ ] ) { const body = { hosts : notEmptyHosts } return this . authHttp . post ( FollowService . BASE_APPLICATION_URL + 's' , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } unfollow ( follow ) { return this . authHttp . delete ( FollowService . BASE_APPLICATION_URL + 's' + follow . following . host ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } acceptFollower ( follow ) { const handle = follow . follower . name + 's' + follow . follower . host return this . authHttp . post ( `template` , { } ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } rejectFollower ( follow ) { const handle = follow . follower . name + 's' + follow . follower . host return this . authHttp . post ( `template` , { } ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } removeFollower ( follow ) { const handle = follow . follower . name + 's' + follow . follower . host return this . authHttp . delete ( `template` ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O $Observable$ O $RestPagination$ O $SortMeta$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $RestPagination$ O $SortMeta$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnInit } from 's' import { ServerService } from 's' import { 0 } from 's' import { ServerConfig } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class InstanceFeaturesTableComponent implements OnInit { quotaHelpIndication = 's' config : ServerConfig constructor ( private 0 , private serverService ) { } get initialUserVideoQuota ( ) { return this . serverService . getConfig ( ) . user . videoQuota } get dailyUserVideoQuota ( ) { return Math . min ( this . initialUserVideoQuota , this . serverService . getConfig ( ) . user . videoQuotaDaily ) } ngOnInit ( ) { this . serverService . configLoaded . subscribe ( ( ) => { this . config = this . serverService . getConfig ( ) this . buildQuotaHelpIndication ( ) } ) } buildNSFWLabel ( ) { const policy = this . serverService . getConfig ( ) . instance . defaultNSFWPolicy if ( policy === 's' ) return this . 0 ( 's' ) if ( policy === 's' ) return this . 0 ( 's' ) if ( policy === 's' ) return this . 0 ( 's' ) } private getApproximateTime ( seconds ) { const hours = Math . floor ( seconds / 0 ) let pluralSuffix = 's' if ( hours > 0 ) pluralSuffix = 's' if ( hours > 0 ) return `template` const minutes = Math . floor ( seconds % 0 / 0 ) return this . 0 ( 's' , { minutes } ) } private buildQuotaHelpIndication ( ) { if ( this . initialUserVideoQuota === - 0 ) return const initialUserVideoQuotaBit = this . initialUserVideoQuota * 0 const fullHdSeconds = initialUserVideoQuotaBit / ( 0 * 0 * 0 ) const hdSeconds = initialUserVideoQuotaBit / ( 0 * 0 * 0 ) const normalSeconds = initialUserVideoQuotaBit / ( 0 * 0 * 0 ) const lines = [ this . 0 ( 's' , { seconds : this . getApproximateTime ( fullHdSeconds ) } ) , this . 0 ( 's' , { seconds : this . getApproximateTime ( hdSeconds ) } ) , this . 0 ( 's' , { seconds : this . getApproximateTime ( normalSeconds ) } ) ] this . quotaHelpIndication = lines . join ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface About { instance : { name : string shortDescription : string description : string terms : string codeOfConduct : string hardwareInformation : string creationReason : string moderationInformation : string administrator : string maintenanceLifetime : string businessModel : string languages : string [ ] categories : number [ ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ContactForm { fromEmail : string fromName : string subject : string body : string }	O O O O O O O O O O O O O O O O O
export interface Debug { ip : string }	O O O O O O O O
import { VideoRedundancyStrategy } from 's' export interface ServerStats { totalUsers : number totalLocalVideos : number totalLocalVideoViews : number totalLocalVideoComments : number totalLocalVideoFilesSize : number totalVideos : number totalVideoComments : number totalInstanceFollowers : number totalInstanceFollowing : number videosRedundancy : { strategy : VideoRedundancyStrategy totalSize : number totalUsed : number totalVideoFiles : number totalVideos : number } [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError } from 's' import { HttpClient } from 's' import { Injectable } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { About } from 's' import { MarkdownService } from 's' import { peertubeTranslate } from 's' import { ServerService } from 's' @ Injectable ( ) export class InstanceService { private static BASE_CONFIG_URL = environment . apiUrl + 's' private static BASE_SERVER_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor , private markdownService , private serverService ) { } getAbout ( ) { return this . authHttp . get < About > ( InstanceService . BASE_CONFIG_URL + 's' ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } contactAdministrator ( fromEmail , fromName , subject , message ) { const body = { fromEmail , fromName , subject , body : message } return this . authHttp . post ( InstanceService . BASE_SERVER_URL + 's' , body ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } async buildHtml ( about ) { const html = { description : 's' , terms : 's' , codeOfConduct : 's' , moderationInformation : 's' , administrator : 's' , hardwareInformation : 's' } for ( const key of Object . keys ( html ) ) { html [ key ] = await this . markdownService . textMarkdownToHTML ( about . instance [ key ] ) } return html } buildTranslatedLanguages ( about , translations ) { const languagesArray = this . serverService . getVideoLanguages ( ) return about . instance . languages . map ( l => { const languageObj = languagesArray . find ( la => la . id === l ) return peertubeTranslate ( languageObj . label , translations ) } ) } buildTranslatedCategories ( about , translations ) { const categoriesArray = this . serverService . getVideoCategories ( ) return about . instance . categories . map ( c => { const categoryObj = categoriesArray . find ( ca => ca . id === c ) return peertubeTranslate ( categoryObj . label , translations ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O $MarkdownService$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $About$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $About$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $About$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnDestroy , OnInit } from 's' import { filter , take } from 's' import { NavigationEnd , Router } from 's' import { Subscription } from 's' import { NgbDropdown } from 's' import { GlobalIconName } from 's' import { ScreenService } from 's' export type TopMenuDropdownParam = { label : string routerLink ? : string children ? : { label : string routerLink : string iconName ? : GlobalIconName } [ ] } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class TopMenuDropdownComponent implements OnInit , OnDestroy { @ Input ( ) menuEntries : TopMenuDropdownParam [ ] = [ ] suffixLabels : { [ parentLabel ] : string } hasIcons = false container : undefined | 's' = undefined private openedOnHover = false private routeSub : Subscription constructor ( private router , private screen ) { } ngOnInit ( ) { this . updateChildLabels ( window . location . pathname ) this . routeSub = this . router . events . pipe ( filter ( event => event instanceof NavigationEnd ) ) . subscribe ( ( ) => this . updateChildLabels ( window . location . pathname ) ) this . hasIcons = this . menuEntries . some ( e => e . children && e . children . some ( c => ! ! c . iconName ) ) if ( this . screen . isInMobileView ( ) ) { this . container = 's' } } ngOnDestroy ( ) { if ( this . routeSub ) this . routeSub . unsubscribe ( ) } openDropdownOnHover ( dropdown ) { this . openedOnHover = true dropdown . open ( ) dropdown . openChange . pipe ( take ( 0 ) ) . subscribe ( ( ) => this . openedOnHover = false ) } dropdownAnchorClicked ( dropdown ) { if ( this . openedOnHover ) { this . openedOnHover = false return } return dropdown . toggle ( ) } closeDropdownIfHovered ( dropdown ) { if ( this . openedOnHover === false ) return dropdown . close ( ) this . openedOnHover = false } private updateChildLabels ( path ) { this . suffixLabels = { } for ( const entry of this . menuEntries ) { if ( ! entry . children ) continue for ( const child of entry . children ) { if ( path . startsWith ( child . routerLink ) ) { this . suffixLabels [ entry . label ] = child . label } } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Router$ O O $ScreenService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbDropdown$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbDropdown$ O O O O O O O O O O O O O O O O O O O O O O O O O $NgbDropdown$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const POP_STATE_MODAL_DISMISS = 's'	O O O O O
import { AfterContentInit , Component , ContentChildren , Input , OnChanges , OnInit , QueryList , TemplateRef } from 's' import { 0 } from 's' import { MarkdownService } from 's' import { PeerTubeTemplateDirective } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class HelpComponent implements OnInit , OnChanges , AfterContentInit { @ Input ( ) helpType : 's' | 's' | 's' = 's' @ Input ( ) tooltipPlacement = 's' @ ContentChildren ( PeerTubeTemplateDirective ) templates : QueryList < PeerTubeTemplateDirective < 's' | 's' | 's' > > isPopoverOpened = false mainHtml = 's' preHtmlTemplate : TemplateRef < any > customHtmlTemplate : TemplateRef < any > postHtmlTemplate : TemplateRef < any > constructor ( private 0 ) { } ngOnInit ( ) { this . init ( ) } ngAfterContentInit ( ) { { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . preHtmlTemplate = t . template } { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . customHtmlTemplate = t . template } { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . postHtmlTemplate = t . template } } ngOnChanges ( ) { this . init ( ) } onPopoverHidden ( ) { this . isPopoverOpened = false } onPopoverShown ( ) { this . isPopoverOpened = true } private init ( ) { if ( this . helpType === 's' ) { this . mainHtml = this . formatMarkdownSupport ( MarkdownService . TEXT_RULES ) return } if ( this . helpType === 's' ) { this . mainHtml = this . formatMarkdownSupport ( MarkdownService . ENHANCED_RULES ) return } } private formatMarkdownSupport ( rules : string [ ] ) { return this . 0 ( 's' ) + this . createMarkdownList ( rules ) } private createMarkdownList ( rules : string [ ] ) { const rulesToText = { 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) , 's' : this . 0 ( 's' ) } const bullets = rules . map ( r => rulesToText [ r ] ) . filter ( text => text ) . map ( text => 's' + text + 's' ) . join ( 's' ) return 's' + bullets + 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const valuesMap = new Map ( ) class MemoryStorage { [ key ] : any [ index ] : string getItem ( key ) { const stringKey = String ( key ) if ( valuesMap . has ( key ) ) { return String ( valuesMap . get ( stringKey ) ) } return null } setItem ( key , val ) { valuesMap . set ( String ( key ) , String ( val ) ) } removeItem ( key ) { valuesMap . delete ( key ) } clear ( ) { valuesMap . clear ( ) } key ( i ) { if ( arguments . length === 0 ) { throw new TypeError ( 's' ) } const arr = Array . from ( valuesMap . keys ( ) ) return arr [ i ] } get length ( ) { return valuesMap . size } } let peertubeLocalStorage try { peertubeLocalStorage = localStorage } catch ( err ) { const instance = new MemoryStorage ( ) peertubeLocalStorage = new Proxy ( instance , { set : function ( obj , prop : string | number , value ) { if ( MemoryStorage . prototype . hasOwnProperty ( prop ) ) { instance [ prop ] = value } else { instance . setItem ( prop , value ) } return true } , get : function ( target , name : string | number ) { if ( MemoryStorage . prototype . hasOwnProperty ( name ) ) { return instance [ name ] } if ( valuesMap . has ( name ) ) { return instance . getItem ( name ) } } } ) } export { peertubeLocalStorage }	O O O O O O O O O O O $string$ O O O O $number$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Storage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' @ Injectable ( ) export class ScreenService { private windowInnerWidth : number private lastFunctionCallTime : number private cacheForMs = 0 constructor ( ) { this . refreshWindowInnerWidth ( ) } isInSmallView ( ) { return this . getWindowInnerWidth ( ) < 0 } isInMobileView ( ) { return this . getWindowInnerWidth ( ) < 0 } isInTouchScreen ( ) { return 's' in window || navigator . msMaxTouchPoints } getNumberOfAvailableMiniatures ( ) { const screenWidth = this . getWindowInnerWidth ( ) let numberOfVideos = 0 if ( screenWidth > 0 ) numberOfVideos = 0 else if ( screenWidth > 0 ) numberOfVideos = 0 else if ( screenWidth > 0 ) numberOfVideos = 0 else if ( screenWidth > 0 ) numberOfVideos = 0 else if ( screenWidth > 0 ) numberOfVideos = 0 return numberOfVideos } getWindowInnerWidth ( ) { if ( this . cacheWindowInnerWidthExpired ( ) ) this . refreshWindowInnerWidth ( ) return this . windowInnerWidth } private refreshWindowInnerWidth ( ) { this . lastFunctionCallTime = new Date ( ) . getTime ( ) this . windowInnerWidth = window . innerWidth } private cacheWindowInnerWidthExpired ( ) { if ( ! this . lastFunctionCallTime ) return true return new Date ( ) . getTime ( ) > ( this . lastFunctionCallTime + this . cacheForMs ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' @ Component ( { selector : 's' , styleUrls : [ ] , templateUrl : 's' } ) export class SmallLoaderComponent { @ Input ( ) loading : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , OnInit , Output , ViewChild } from 's' import { Notifier } from 's' import { 0 } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { FormValidatorService } from 's' import { FormReactive , UserValidatorsService } from 's' import { UserService } from 's' import { User } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class UserBanModalComponent extends FormReactive implements OnInit { @ ViewChild ( 's' , { static : true } ) modal : NgbModal @ Output ( ) userBanned = new EventEmitter < User | User [ ] > ( ) private usersToBan : User | User [ ] private openedModal : NgbModalRef constructor ( protected formValidatorService , private modalService , private notifier , private userService , private userValidatorsService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { reason : this . userValidatorsService . USER_BAN_REASON } ) } openModal ( user : User | User [ ] ) { this . usersToBan = user this . openedModal = this . modalService . open ( this . modal ) } hide ( ) { this . usersToBan = undefined this . openedModal . close ( ) } async banUser ( ) { const reason = this . form . value [ 's' ] || undefined this . userService . banUsers ( this . usersToBan , reason ) . subscribe ( ( ) => { const message = Array . isArray ( this . usersToBan ) ? this . 0 ( 's' , { num : this . usersToBan . length } ) : this . 0 ( 's' , { username : this . usersToBan . username } ) this . notifier . success ( message ) this . userBanned . emit ( this . usersToBan ) this . hide ( ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $Notifier$ O O $UserService$ O O $UserValidatorsService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnChanges , Output , ViewChild } from 's' import { 0 } from 's' import { DropdownAction } from 's' import { UserBanModalComponent } from 's' import { UserService } from 's' import { AuthService , ConfirmService , Notifier , ServerService } from 's' import { User , UserRight } from 's' import { Account } from 's' import { BlocklistService } from 's' @ Component ( { selector : 's' , templateUrl : 's' } ) export class UserModerationDropdownComponent implements OnChanges { @ ViewChild ( 's' , { static : false } ) userBanModal : UserBanModalComponent @ Input ( ) user : User @ Input ( ) account : Account @ Input ( ) buttonSize : 's' | 's' = 's' @ Input ( ) placement = 's' @ Output ( ) userChanged = new EventEmitter ( ) @ Output ( ) userDeleted = new EventEmitter ( ) userActions : DropdownAction < { user : User , account : Account } > [ ] [ ] = [ ] constructor ( private authService , private notifier , private confirmService , private serverService , private userService , private blocklistService , private auth , private 0 ) { } get requiresEmailVerification ( ) { return this . serverService . getConfig ( ) . signup . requiresEmailVerification } ngOnChanges ( ) { this . buildActions ( ) } openBanUserModal ( user ) { if ( user . username === 's' ) { this . notifier . error ( this . 0 ( 's' ) ) return } this . userBanModal . openModal ( user ) } onUserBanned ( ) { this . userChanged . emit ( ) } async unbanUser ( user ) { const message = this . 0 ( 's' , { username : user . username } ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . userService . unbanUsers ( user ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : user . username } ) ) this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } async removeUser ( user ) { if ( user . username === 's' ) { this . notifier . error ( this . 0 ( 's' ) ) return } const message = this . 0 ( 's' ) const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . userService . removeUser ( user ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : user . username } ) ) this . userDeleted . emit ( ) } , err => this . notifier . error ( err . message ) ) } setEmailAsVerified ( user ) { this . userService . updateUser ( user . id , { emailVerified : true } ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { username : user . username } ) ) this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } blockAccountByUser ( account ) { this . blocklistService . blockAccountByUser ( account ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : account . nameWithHost } ) ) this . account . mutedByUser = true this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } unblockAccountByUser ( account ) { this . blocklistService . unblockAccountByUser ( account ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : account . nameWithHost } ) ) this . account . mutedByUser = false this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } blockServerByUser ( host ) { this . blocklistService . blockServerByUser ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . account . mutedServerByUser = true this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } unblockServerByUser ( host ) { this . blocklistService . unblockServerByUser ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . account . mutedServerByUser = false this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } blockAccountByInstance ( account ) { this . blocklistService . blockAccountByInstance ( account ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : account . nameWithHost } ) ) this . account . mutedByInstance = true this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } unblockAccountByInstance ( account ) { this . blocklistService . unblockAccountByInstance ( account ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { nameWithHost : account . nameWithHost } ) ) this . account . mutedByInstance = false this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } blockServerByInstance ( host ) { this . blocklistService . blockServerByInstance ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . account . mutedServerByInstance = true this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } unblockServerByInstance ( host ) { this . blocklistService . unblockServerByInstance ( host ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { host } ) ) this . account . mutedServerByInstance = false this . userChanged . emit ( ) } , err => this . notifier . error ( err . message ) ) } getRouterUserEditLink ( user ) { return [ 's' , 's' , 's' , user . id ] } private buildActions ( ) { this . userActions = [ ] if ( this . authService . isLoggedIn ( ) ) { const authUser = this . authService . getUser ( ) if ( this . user && authUser . id === this . user . id ) return if ( this . user && authUser . hasRight ( UserRight . MANAGE_USERS ) && authUser . canManage ( this . user ) ) { this . userActions . push ( [ { label : this . 0 ( 's' ) , linkBuilder : ( { user } ) => this . getRouterUserEditLink ( user ) } , { label : this . 0 ( 's' ) , handler : ( { user } ) => this . removeUser ( user ) } , { label : this . 0 ( 's' ) , handler : ( { user } ) => this . openBanUserModal ( user ) , isDisplayed : ( { user } ) => ! user . blocked } , { label : this . 0 ( 's' ) , handler : ( { user } ) => this . unbanUser ( user ) , isDisplayed : ( { user } ) => user . blocked } , { label : this . 0 ( 's' ) , handler : ( { user } ) => this . setEmailAsVerified ( user ) , isDisplayed : ( { user } ) => this . requiresEmailVerification && ! user . blocked && user . emailVerified === false } ] ) } if ( this . account ) { this . userActions . push ( [ { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => account . mutedByUser === false , handler : ( { account } ) => this . blockAccountByUser ( account ) } , { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => account . mutedByUser === true , handler : ( { account } ) => this . unblockAccountByUser ( account ) } , { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => ! account . userId && account . mutedServerByInstance === false , handler : ( { account } ) => this . blockServerByUser ( account . host ) } , { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => ! account . userId && account . mutedServerByInstance === true , handler : ( { account } ) => this . unblockServerByUser ( account . host ) } ] ) let instanceActions : DropdownAction < { user : User , account : Account } > [ ] = [ ] if ( authUser . hasRight ( UserRight . MANAGE_ACCOUNTS_BLOCKLIST ) ) { instanceActions = instanceActions . concat ( [ { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => account . mutedByInstance === false , handler : ( { account } ) => this . blockAccountByInstance ( account ) } , { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => account . mutedByInstance === true , handler : ( { account } ) => this . unblockAccountByInstance ( account ) } ] ) } if ( authUser . hasRight ( UserRight . MANAGE_SERVERS_BLOCKLIST ) ) { instanceActions = instanceActions . concat ( [ { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => ! account . userId && account . mutedServerByInstance === false , handler : ( { account } ) => this . blockServerByInstance ( account . host ) } , { label : this . 0 ( 's' ) , isDisplayed : ( { account } ) => ! account . userId && account . mutedServerByInstance === true , handler : ( { account } ) => this . unblockServerByInstance ( account . host ) } ] ) } if ( instanceActions . length !== 0 ) { this . userActions . push ( instanceActions ) } } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $ServerService$ O O $UserService$ O O $BlocklistService$ O O $AuthService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
export * from 's'	O O O O
import { VideoChannelSummary , VideoConstant , VideosOverview as VideosOverviewServer } from 's' import { Video } from 's' export class VideosOverview implements VideosOverviewServer { channels : { channel : VideoChannelSummary videos : Video [ ] } [ ] categories : { category : VideoConstant < number > videos : Video [ ] } [ ] tags : { tag : string videos : Video [ ] } [ ] [ key ] : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O
import { Injectable } from 's' import { LinkifierService } from 's' @ Injectable ( ) export class HtmlRendererService { constructor ( private linkifier ) { } async toSafeHtml ( text ) { const sanitizeHtml : typeof import ( 's' ) = ( await import ( 's' ) as any ) . default const html = this . linkifier . linkify ( text ) return sanitizeHtml ( html , { allowedTags : [ 's' , 's' , 's' , 's' ] , allowedSchemes : [ 's' , 's' ] , allowedAttributes : { 's' : [ 's' , 's' , 's' ] } , transformTags : { a : ( tagName , attribs ) => { return { tagName , attribs : Object . assign ( attribs , { target : 's' , rel : 's' } ) } } } } ) } }	O O O O O O O O O O O O O O O O O O O O O O O $LinkifierService$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { getAbsoluteAPIUrl } from 's' import * as linkify from 's' import linkifyHtml from 's' @ Injectable ( ) export class LinkifierService { static CLASSNAME = 's' private linkifyOptions = { className : { mention : LinkifierService . CLASSNAME + 's' , url : LinkifierService . CLASSNAME + 's' } } constructor ( ) { this . mentionWithDomainPlugin ( linkify ) } linkify ( text ) { return linkifyHtml ( text , this . linkifyOptions ) } private mentionWithDomainPlugin ( linkify ) { const TT = linkify . scanner . TOKENS const { TOKENS : MT , State } = linkify . parser const MultiToken = MT . Base const S_START = linkify . parser . start const TT_AT = TT . AT const TT_DOMAIN = TT . DOMAIN const TT_LOCALHOST = TT . LOCALHOST const TT_NUM = TT . NUM const TT_COLON = TT . COLON const TT_SLASH = TT . SLASH const TT_TLD = TT . TLD const TT_UNDERSCORE = TT . UNDERSCORE const TT_DOT = TT . DOT function MENTION ( this , value ) { this . v = value } linkify . inherits ( MultiToken , MENTION , { type : 's' , isLink : true , toHref ( ) { return getAbsoluteAPIUrl ( ) + 's' + this . toString ( ) . substr ( 0 ) } } ) const S_AT = S_START . jump ( TT_AT ) const S_AT_SYMS = new State ( ) const S_MENTION = new State ( MENTION ) const S_MENTION_DIVIDER = new State ( ) const S_MENTION_DIVIDER_SYMS = new State ( ) S_AT . on ( TT_UNDERSCORE , S_AT_SYMS ) S_AT_SYMS . on ( TT_UNDERSCORE , S_AT_SYMS ) . on ( TT_DOT , S_AT_SYMS ) S_AT . on ( TT_DOMAIN , S_MENTION ) . on ( TT_LOCALHOST , S_MENTION ) . on ( TT_TLD , S_MENTION ) . on ( TT_NUM , S_MENTION ) S_AT_SYMS . on ( TT_DOMAIN , S_MENTION ) . on ( TT_LOCALHOST , S_MENTION ) . on ( TT_TLD , S_MENTION ) . on ( TT_NUM , S_MENTION ) S_MENTION . on ( TT_DOMAIN , S_MENTION ) . on ( TT_LOCALHOST , S_MENTION ) . on ( TT_TLD , S_MENTION ) . on ( TT_COLON , S_MENTION ) . on ( TT_NUM , S_MENTION ) . on ( TT_UNDERSCORE , S_MENTION ) S_MENTION . on ( TT_AT , S_MENTION_DIVIDER ) . on ( TT_SLASH , S_MENTION_DIVIDER ) . on ( TT_DOT , S_MENTION_DIVIDER ) S_MENTION_DIVIDER . on ( TT_UNDERSCORE , S_MENTION_DIVIDER_SYMS ) S_MENTION_DIVIDER_SYMS . on ( TT_UNDERSCORE , S_MENTION_DIVIDER_SYMS ) S_MENTION_DIVIDER . on ( TT_DOMAIN , S_MENTION ) . on ( TT_LOCALHOST , S_MENTION ) . on ( TT_TLD , S_MENTION ) . on ( TT_NUM , S_MENTION ) S_MENTION_DIVIDER_SYMS . on ( TT_DOMAIN , S_MENTION ) . on ( TT_LOCALHOST , S_MENTION ) . on ( TT_TLD , S_MENTION ) . on ( TT_NUM , S_MENTION ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { MarkdownIt } from 's' @ Injectable ( ) export class MarkdownService { static TEXT_RULES = [ 's' , 's' , 's' , 's' , 's' , 's' ] static ENHANCED_RULES = MarkdownService . TEXT_RULES . concat ( [ 's' ] ) static COMPLETE_RULES = MarkdownService . ENHANCED_RULES . concat ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) private textMarkdownIt : MarkdownIt private enhancedMarkdownIt : MarkdownIt private completeMarkdownIt : MarkdownIt async textMarkdownToHTML ( markdown ) { if ( ! markdown ) return 's' if ( ! this . textMarkdownIt ) { this . textMarkdownIt = await this . createMarkdownIt ( MarkdownService . TEXT_RULES ) } const html = this . textMarkdownIt . render ( markdown ) return this . avoidTruncatedTags ( html ) } async enhancedMarkdownToHTML ( markdown ) { if ( ! markdown ) return 's' if ( ! this . enhancedMarkdownIt ) { this . enhancedMarkdownIt = await this . createMarkdownIt ( MarkdownService . ENHANCED_RULES ) } const html = this . enhancedMarkdownIt . render ( markdown ) return this . avoidTruncatedTags ( html ) } async completeMarkdownToHTML ( markdown ) { if ( ! markdown ) return 's' if ( ! this . completeMarkdownIt ) { this . completeMarkdownIt = await this . createMarkdownIt ( MarkdownService . COMPLETE_RULES , true ) } const html = this . completeMarkdownIt . render ( markdown ) return this . avoidTruncatedTags ( html ) } private async createMarkdownIt ( rules : string [ ] , html = false ) { const MarkdownItClass : typeof import ( 's' ) = ( await import ( 's' ) as any ) . default const markdownIt = new MarkdownItClass ( 's' , { linkify : true , breaks : true , html } ) for ( const rule of rules ) { markdownIt . enable ( rule ) } this . setTargetToLinks ( markdownIt ) return markdownIt } private setTargetToLinks ( markdownIt ) { const defaultRender = markdownIt . renderer . rules . link_open || function ( tokens , idx , options , env , self ) { return self . renderToken ( tokens , idx , options ) } markdownIt . renderer . rules . link_open = function ( tokens , index , options , env , self ) { const token = tokens [ index ] const targetIndex = token . attrIndex ( 's' ) if ( targetIndex < 0 ) token . attrPush ( [ 's' , 's' ] ) else token . attrs [ targetIndex ] [ 0 ] = 's' const relIndex = token . attrIndex ( 's' ) if ( relIndex < 0 ) token . attrPush ( [ 's' , 's' ] ) else token . attrs [ relIndex ] [ 0 ] = 's' return defaultRender ( tokens , index , options , env , self ) } } private avoidTruncatedTags ( html ) { return html . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MarkdownIt$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { bufferTime , catchError , filter , first , map , share , switchMap } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { ResultList } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { Observable , ReplaySubject , Subject } from 's' import { VideoChannel } from 's' import { VideoChannelService } from 's' import { VideoChannel as VideoChannelServer } from 's' import { ComponentPagination } from 's' type SubscriptionExistResult = { [ uri ] : boolean } @ Injectable ( ) export class UserSubscriptionService { static BASE_USER_SUBSCRIPTIONS_URL = environment . apiUrl + 's' private existsSubject : Subject < string > = new ReplaySubject ( 0 ) private readonly existsObservable : Observable < SubscriptionExistResult > constructor ( private authHttp , private restExtractor , private restService ) { this . existsObservable = this . existsSubject . pipe ( bufferTime ( 0 ) , filter ( uris => uris . length !== 0 ) , switchMap ( uris => this . doSubscriptionsExist ( uris ) ) , share ( ) ) } deleteSubscription ( nameWithHost ) { const url = UserSubscriptionService . BASE_USER_SUBSCRIPTIONS_URL + 's' + nameWithHost return this . authHttp . delete ( url ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } addSubscription ( nameWithHost ) { const url = UserSubscriptionService . BASE_USER_SUBSCRIPTIONS_URL const body = { uri : nameWithHost } return this . authHttp . post ( url , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } listSubscriptions ( componentPagination ) < ResultList < VideoChannel > > { const url = UserSubscriptionService . BASE_USER_SUBSCRIPTIONS_URL const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) return this . authHttp . get < ResultList < VideoChannelServer > > ( url , { params } ) . pipe ( map ( res => VideoChannelService . extractVideoChannels ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } doesSubscriptionExist ( nameWithHost ) { this . existsSubject . next ( nameWithHost ) return this . existsObservable . pipe ( first ( ) ) } private doSubscriptionsExist ( uris : string [ ] ) < SubscriptionExistResult > { const url = UserSubscriptionService . BASE_USER_SUBSCRIPTIONS_URL + 's' let params = new HttpParams ( ) params = this . restService . addObjectParams ( params , { uris } ) return this . authHttp . get < SubscriptionExistResult > ( url , { params } ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit } from 's' import { Router } from 's' import { AuthService , Notifier } from 's' import { UserSubscriptionService } from 's' import { VideoChannel } from 's' import { 0 } from 's' import { VideoService } from 's' import { FeedFormat } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SubscribeButtonComponent implements OnInit { @ Input ( ) videoChannel : VideoChannel @ Input ( ) displayFollowers = false @ Input ( ) size : 's' | 's' = 's' subscribed : boolean constructor ( private authService , private router , private notifier , private userSubscriptionService , private 0 , private videoService ) { } get channelHandle ( ) { return this . videoChannel . name + 's' + this . videoChannel . host } get channelUri ( ) { return this . videoChannel . url } ngOnInit ( ) { if ( this . isUserLoggedIn ( ) ) { this . userSubscriptionService . doesSubscriptionExist ( this . channelHandle ) . subscribe ( res => this . subscribed = res [ this . channelHandle ] , err => this . notifier . error ( err . message ) ) } } subscribe ( ) { if ( this . isUserLoggedIn ( ) ) { return this . localSubscribe ( ) } return this . gotoLogin ( ) } localSubscribe ( ) { this . userSubscriptionService . addSubscription ( this . channelHandle ) . subscribe ( ( ) => { this . subscribed = true this . notifier . success ( this . 0 ( 's' , { nameWithHost : this . videoChannel . displayName } ) , this . 0 ( 's' ) ) } , err => this . notifier . error ( err . message ) ) } unsubscribe ( ) { if ( this . isUserLoggedIn ( ) ) { this . localUnsubscribe ( ) } } localUnsubscribe ( ) { this . userSubscriptionService . deleteSubscription ( this . channelHandle ) . subscribe ( ( ) => { this . subscribed = false this . notifier . success ( this . 0 ( 's' , { nameWithHost : this . videoChannel . displayName } ) , this . 0 ( 's' ) ) } , err => this . notifier . error ( err . message ) ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } gotoLogin ( ) { this . router . navigate ( [ 's' ] ) } rssOpen ( ) { const rssFeed = this . videoService . getVideoChannelFeedUrls ( this . videoChannel . id ) . find ( i => i . format === FeedFormat . RSS ) window . open ( rssFeed . url ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Router$ O O $Notifier$ O O $UserSubscriptionService$ O O $I18n$ O O $VideoService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit } from 's' import { FormReactive } from 's' import { FormValidatorService , UserValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class RemoteSubscribeComponent extends FormReactive implements OnInit { @ Input ( ) uri : string @ Input ( ) interact = false @ Input ( ) showHelp = false constructor ( protected formValidatorService , private userValidatorsService ) { super ( ) } ngOnInit ( ) { this . buildForm ( { text : this . userValidatorsService . USER_EMAIL } ) } onValidKey ( ) { this . check ( ) if ( ! this . form . valid ) return this . formValidated ( ) } formValidated ( ) { const address = this . form . value [ 's' ] const [ username , hostname ] = address . split ( 's' ) fetch ( `template` ) . then ( response => response . json ( ) ) . then ( data => new Promise ( ( resolve , reject ) => { console . log ( data ) if ( data && Array . isArray ( data . links ) ) { const link : { template : string } = data . links . find ( ( link ) => { return link && typeof link . template === 's' && link . rel === 's' } ) if ( link && link . template . includes ( 's' ) ) { resolve ( link . template . replace ( 's' , encodeURIComponent ( this . uri ) ) ) } } reject ( ) } ) ) . then ( window . open ) . catch ( err => console . error ( err ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $UserValidatorsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { environment } from 's' import { RestExtractor } from 's' import { RestService } from 's' import { Video } from 's' import { catchError , map , switchMap } from 's' import { ComponentPagination } from 's' import { VideoService } from 's' import { ResultList } from 's' @ Injectable ( ) export class UserHistoryService { static BASE_USER_VIDEOS_HISTORY_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService , private videoService ) { } getUserVideosHistory ( historyPagination ) { const pagination = this . restService . componentPaginationToRestPagination ( historyPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) return this . authHttp . get < ResultList < Video > > ( UserHistoryService . BASE_USER_VIDEOS_HISTORY_URL , { params } ) . pipe ( switchMap ( res => this . videoService . extractVideos ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } deleteUserVideosHistory ( ) { return this . authHttp . post ( UserHistoryService . BASE_USER_VIDEOS_HISTORY_URL + 's' , { } ) . pipe ( map ( ( ) => this . restExtractor . extractDataBool ( ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $VideoService$ O O O O O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActorInfo , FollowState , UserNotification as UserNotificationServer , UserNotificationType , VideoInfo } from 's' import { Actor } from 's' export class UserNotification implements UserNotificationServer { id : number type : UserNotificationType read : boolean video ? : VideoInfo & { channel : ActorInfo & { avatarUrl ? : string } } videoImport ? : { id : number video ? : VideoInfo torrentName ? : string magnetUri ? : string targetUrl ? : string } comment ? : { id : number threadId : number account : ActorInfo & { avatarUrl ? : string } video : VideoInfo } videoAbuse ? : { id : number video : VideoInfo } videoBlacklist ? : { id : number video : VideoInfo } account ? : ActorInfo & { avatarUrl ? : string } actorFollow ? : { id : number state : FollowState follower : ActorInfo & { avatarUrl ? : string } following : { type : 's' | 's' | 's' name : string displayName : string host : string } } createdAt : string updatedAt : string videoUrl ? : string commentUrl ? : any [ ] videoAbuseUrl ? : string videoAutoBlacklistUrl ? : string accountUrl ? : string videoImportIdentifier ? : string videoImportUrl ? : string instanceFollowUrl ? : string constructor ( hash ) { this . id = hash . id this . type = hash . type this . read = hash . read try { this . video = hash . video if ( this . video ) this . setAvatarUrl ( this . video . channel ) this . videoImport = hash . videoImport this . comment = hash . comment if ( this . comment ) this . setAvatarUrl ( this . comment . account ) this . videoAbuse = hash . videoAbuse this . videoBlacklist = hash . videoBlacklist this . account = hash . account if ( this . account ) this . setAvatarUrl ( this . account ) this . actorFollow = hash . actorFollow if ( this . actorFollow ) this . setAvatarUrl ( this . actorFollow . follower ) this . createdAt = hash . createdAt this . updatedAt = hash . updatedAt switch ( this . type ) { case UserNotificationType . NEW_VIDEO_FROM_SUBSCRIPTION : this . videoUrl = this . buildVideoUrl ( this . video ) break case UserNotificationType . UNBLACKLIST_ON_MY_VIDEO : this . videoUrl = this . buildVideoUrl ( this . video ) break case UserNotificationType . NEW_COMMENT_ON_MY_VIDEO : case UserNotificationType . COMMENT_MENTION : this . accountUrl = this . buildAccountUrl ( this . comment . account ) this . commentUrl = [ this . buildVideoUrl ( this . comment . video ) , { threadId : this . comment . threadId } ] break case UserNotificationType . NEW_VIDEO_ABUSE_FOR_MODERATORS : this . videoAbuseUrl = 's' this . videoUrl = this . buildVideoUrl ( this . videoAbuse . video ) break case UserNotificationType . VIDEO_AUTO_BLACKLIST_FOR_MODERATORS : this . videoAutoBlacklistUrl = 's' if ( ! this . videoBlacklist ) this . videoBlacklist = { id : null , video : this . video } this . videoUrl = this . buildVideoUrl ( this . videoBlacklist . video ) break case UserNotificationType . BLACKLIST_ON_MY_VIDEO : this . videoUrl = this . buildVideoUrl ( this . videoBlacklist . video ) break case UserNotificationType . MY_VIDEO_PUBLISHED : this . videoUrl = this . buildVideoUrl ( this . video ) break case UserNotificationType . MY_VIDEO_IMPORT_SUCCESS : this . videoImportUrl = this . buildVideoImportUrl ( ) this . videoImportIdentifier = this . buildVideoImportIdentifier ( this . videoImport ) if ( this . videoImport . video ) this . videoUrl = this . buildVideoUrl ( this . videoImport . video ) break case UserNotificationType . MY_VIDEO_IMPORT_ERROR : this . videoImportUrl = this . buildVideoImportUrl ( ) this . videoImportIdentifier = this . buildVideoImportIdentifier ( this . videoImport ) break case UserNotificationType . NEW_USER_REGISTRATION : this . accountUrl = this . buildAccountUrl ( this . account ) break case UserNotificationType . NEW_FOLLOW : this . accountUrl = this . buildAccountUrl ( this . actorFollow . follower ) break case UserNotificationType . NEW_INSTANCE_FOLLOWER : this . instanceFollowUrl = 's' break case UserNotificationType . AUTO_INSTANCE_FOLLOWING : this . instanceFollowUrl = 's' break } } catch ( err ) { this . type = null console . error ( err ) } } private buildVideoUrl ( video : { uuid : string } ) { return 's' + video . uuid } private buildAccountUrl ( account : { name : string , host : string } ) { return 's' + Actor . CREATE_BY_STRING ( account . name , account . host ) } private buildVideoImportUrl ( ) { return 's' } private buildVideoImportIdentifier ( videoImport : { targetUrl ? : string , magnetUri ? : string , torrentName ? : string } ) { return videoImport . targetUrl || videoImport . magnetUri || videoImport . torrentName } private setAvatarUrl ( actor : { avatarUrl ? : string , avatar ? : { path : string } } ) { actor . avatarUrl = Actor . GET_ACTOR_AVATAR_URL ( actor ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationServer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HttpClient , HttpParams } from 's' import { RestExtractor , RestService } from 's' import { catchError , map , tap } from 's' import { environment } from 's' import { ResultList , UserNotification as UserNotificationServer , UserNotificationSetting } from 's' import { UserNotification } from 's' import { AuthService } from 's' import { ComponentPagination } from 's' import { User } from 's' import { UserNotificationSocket } from 's' @ Injectable ( ) export class UserNotificationService { static BASE_NOTIFICATIONS_URL = environment . apiUrl + 's' static BASE_NOTIFICATION_SETTINGS = environment . apiUrl + 's' constructor ( private auth , private authHttp , private restExtractor , private restService , private userNotificationSocket ) { } listMyNotifications ( pagination , unread ? , ignoreLoadingBar = false ) { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , this . restService . componentPaginationToRestPagination ( pagination ) ) if ( unread ) params = params . append ( 's' , `template` ) const headers = ignoreLoadingBar ? { ignoreLoadingBar : 's' } : undefined return this . authHttp . get < ResultList < UserNotification > > ( UserNotificationService . BASE_NOTIFICATIONS_URL , { params , headers } ) . pipe ( map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , map ( res => this . restExtractor . applyToResultListData ( res , this . formatNotification . bind ( this ) ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } countUnreadNotifications ( ) { return this . listMyNotifications ( { currentPage : 0 , itemsPerPage : 0 } , true ) . pipe ( map ( n => n . total ) ) } markAsRead ( notification ) { const url = UserNotificationService . BASE_NOTIFICATIONS_URL + 's' const body = { ids : [ notification . id ] } const headers = { ignoreLoadingBar : 's' } return this . authHttp . post ( url , body , { headers } ) . pipe ( map ( this . restExtractor . extractDataBool ) , tap ( ( ) => this . userNotificationSocket . dispatch ( 's' ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } markAllAsRead ( ) { const url = UserNotificationService . BASE_NOTIFICATIONS_URL + 's' const headers = { ignoreLoadingBar : 's' } return this . authHttp . post ( url , { } , { headers } ) . pipe ( map ( this . restExtractor . extractDataBool ) , tap ( ( ) => this . userNotificationSocket . dispatch ( 's' ) ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } updateNotificationSettings ( user , settings ) { const url = UserNotificationService . BASE_NOTIFICATION_SETTINGS return this . authHttp . put ( url , settings ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } private formatNotification ( notification ) { return new UserNotification ( notification ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O $UserNotificationSocket$ O O O O O $ComponentPagination$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O $UserNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationServer$ O O O O O O O O O O
import { distinctUntilChanged , filter , map , share , startWith , tap , throttleTime } from 's' import { AfterContentChecked , Directive , ElementRef , EventEmitter , Input , OnDestroy , OnInit , Output } from 's' import { fromEvent , Observable , Subscription } from 's' @ Directive ( { selector : 's' } ) export class InfiniteScrollerDirective implements OnInit , OnDestroy , AfterContentChecked { @ Input ( ) percentLimit = 0 @ Input ( ) autoInit = false @ Input ( ) onItself = false @ Input ( ) dataObservable : Observable < any [ ] > @ Output ( ) nearOfBottom = new EventEmitter < void > ( ) private decimalLimit = 0 private lastCurrentBottom = - 0 private scrollDownSub : Subscription private container : HTMLElement private checkScroll = false constructor ( private el ) { this . decimalLimit = this . percentLimit / 0 } ngAfterContentChecked ( ) { if ( this . checkScroll ) { this . checkScroll = false console . log ( 's' ) if ( this . hasScroll ( ) === false ) this . nearOfBottom . emit ( ) } } ngOnInit ( ) { if ( this . autoInit === true ) return this . initialize ( ) } ngOnDestroy ( ) { if ( this . scrollDownSub ) this . scrollDownSub . unsubscribe ( ) } initialize ( ) { this . container = this . onItself ? this . el . nativeElement : document . documentElement const throttleOptions = { leading : true , trailing : true } const scrollableElement = this . onItself ? this . container : window const scrollObservable = fromEvent ( scrollableElement , 's' ) . pipe ( startWith ( null as string ) , throttleTime ( 0 , undefined , throttleOptions ) , map ( ( ) => this . getScrollInfo ( ) ) , distinctUntilChanged ( ( 0 , 0 ) => 0 . current === 0 . current ) , share ( ) ) this . scrollDownSub = scrollObservable . pipe ( filter ( ( { current } ) => this . isScrollingDown ( current ) ) , filter ( ( { current , maximumScroll } ) => ( current / maximumScroll ) > this . decimalLimit ) ) . subscribe ( ( ) => this . nearOfBottom . emit ( ) ) if ( this . dataObservable ) { this . dataObservable . pipe ( filter ( d => d . length !== 0 ) ) . subscribe ( ( ) => this . checkScroll = true ) } } private getScrollInfo ( ) { return { current : this . container . scrollTop , maximumScroll : this . getMaximumScroll ( ) } } private getMaximumScroll ( ) { return this . container . scrollHeight - window . innerHeight } private hasScroll ( ) { return this . getMaximumScroll ( ) > 0 } private isScrollingDown ( current ) { const result = this . lastCurrentBottom < current this . lastCurrentBottom = current return result } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnInit , Output , ViewChild } from 's' import { Notifier , RedirectService } from 's' import { VideoBlacklistService } from 's' import { VideoDetails } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { FormReactive , VideoBlacklistValidatorsService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoBlacklistComponent extends FormReactive implements OnInit { @ Input ( ) video : VideoDetails = null @ ViewChild ( 's' , { static : true } ) modal : NgbModal @ Output ( ) videoBlacklisted = new EventEmitter ( ) error : string = null private openedModal : NgbModalRef constructor ( protected formValidatorService , private modalService , private videoBlacklistValidatorsService , private videoBlacklistService , private notifier , private redirectService , private 0 ) { super ( ) } ngOnInit ( ) { const defaultValues = { unfederate : 's' } this . buildForm ( { reason : this . videoBlacklistValidatorsService . VIDEO_BLACKLIST_REASON , unfederate : null } , defaultValues ) } show ( ) { this . openedModal = this . modalService . open ( this . modal , { keyboard : false } ) } hide ( ) { this . openedModal . close ( ) this . openedModal = null } blacklist ( ) { const reason = this . form . value [ 's' ] || undefined const unfederate = this . video . isLocal ? this . form . value [ 's' ] : undefined this . videoBlacklistService . blacklistVideo ( this . video . id , reason , unfederate ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . hide ( ) this . video . blacklisted = true this . video . blacklistedReason = reason this . videoBlacklisted . emit ( ) } , err => this . notifier . error ( err . message ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $VideoBlacklistValidatorsService$ O O $VideoBlacklistService$ O O $Notifier$ O O $RedirectService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , ViewChild } from 's' import { VideoDetails } from 's' import { NgbActiveModal , NgbModal } from 's' import { 0 } from 's' import { Notifier } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoDownloadComponent { @ ViewChild ( 's' , { static : true } ) modal : ElementRef downloadType : 's' | 's' = 's' resolutionId : number | string = - 0 video : VideoDetails activeModal : NgbActiveModal constructor ( private notifier , private modalService , private 0 ) { } show ( video ) { this . video = video this . activeModal = this . modalService . open ( this . modal ) this . resolutionId = this . video . files [ 0 ] . resolution . id } onClose ( ) { this . video = undefined } download ( ) { window . location . assign ( this . getLink ( ) ) this . activeModal . close ( ) } getLink ( ) { this . resolutionId = parseInt ( this . resolutionId . toString ( ) , 0 ) const file = this . video . files . find ( f => f . resolution . id === this . resolutionId ) if ( ! file ) { console . error ( 's' , this . resolutionId ) return } switch ( this . downloadType ) { case 's' : return file . fileDownloadUrl case 's' : return file . torrentDownloadUrl } } activateCopiedMessage ( ) { this . notifier . success ( this . 0 ( 's' ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Notifier$ O O $NgbModal$ O O $I18n$ O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , OnInit , ViewChild } from 's' import { Notifier } from 's' import { FormReactive } from 's' import { VideoDetails } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { VideoAbuseValidatorsService } from 's' import { NgbModal } from 's' import { NgbModalRef } from 's' import { VideoAbuseService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoReportComponent extends FormReactive implements OnInit { @ Input ( ) video : VideoDetails = null @ ViewChild ( 's' , { static : true } ) modal : NgbModal error : string = null private openedModal : NgbModalRef constructor ( protected formValidatorService , private modalService , private videoAbuseValidatorsService , private videoAbuseService , private notifier , private 0 ) { super ( ) } get currentHost ( ) { return window . location . host } get originHost ( ) { if ( this . isRemoteVideo ( ) ) { return this . video . account . host } return 's' } ngOnInit ( ) { this . buildForm ( { reason : this . videoAbuseValidatorsService . VIDEO_ABUSE_REASON } ) } show ( ) { this . openedModal = this . modalService . open ( this . modal , { keyboard : false } ) } hide ( ) { this . openedModal . close ( ) this . openedModal = null } report ( ) { const reason = this . form . value [ 's' ] this . videoAbuseService . reportVideo ( this . video . id , reason ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) this . hide ( ) } , err => this . notifier . error ( err . message ) ) } isRemoteVideo ( ) { return ! this . video . isLocal } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $VideoAbuseValidatorsService$ O O $VideoAbuseService$ O O $Notifier$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface RecommendationInfo { uuid : string tags ? : string [ ] }	O O O O O O O O O O O O O O
import { FeedFormat } from 's' export interface Syndication { format : FeedFormat , label : string , url : string }	O O O O O O O O O O O O O O O O O O O O O O
import { AfterViewInit , Component , EventEmitter , Input , OnChanges , Output , ViewChild } from 's' import { 0 } from 's' import { DropdownAction , DropdownButtonSize , DropdownDirection } from 's' import { AuthService , ConfirmService , Notifier , ServerService } from 's' import { BlocklistService } from 's' import { Video } from 's' import { VideoService } from 's' import { VideoDetails } from 's' import { NgbDropdown } from 's' import { VideoAddToPlaylistComponent } from 's' import { VideoDownloadComponent } from 's' import { VideoReportComponent } from 's' import { VideoBlacklistComponent } from 's' import { VideoBlacklistService } from 's' import { ScreenService } from 's' export type VideoActionsDisplayType = { playlist ? : boolean download ? : boolean update ? : boolean blacklist ? : boolean delete ? : boolean report ? : boolean } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoActionsDropdownComponent implements OnChanges { @ ViewChild ( 's' , { static : false } ) playlistDropdown : NgbDropdown @ ViewChild ( 's' , { static : false } ) playlistAdd : VideoAddToPlaylistComponent @ ViewChild ( 's' , { static : false } ) videoDownloadModal : VideoDownloadComponent @ ViewChild ( 's' , { static : false } ) videoReportModal : VideoReportComponent @ ViewChild ( 's' , { static : false } ) videoBlacklistModal : VideoBlacklistComponent @ Input ( ) video : Video | VideoDetails @ Input ( ) displayOptions : VideoActionsDisplayType = { playlist : false , download : true , update : true , blacklist : true , delete : true , report : true } @ Input ( ) placement = 's' @ Input ( ) label : string @ Input ( ) buttonStyled = false @ Input ( ) buttonSize : DropdownButtonSize = 's' @ Input ( ) buttonDirection : DropdownDirection = 's' @ Output ( ) videoRemoved = new EventEmitter ( ) @ Output ( ) videoUnblacklisted = new EventEmitter ( ) @ Output ( ) videoBlacklisted = new EventEmitter ( ) videoActions : DropdownAction < { video : Video } > [ ] [ ] = [ ] private loaded = false constructor ( private authService , private notifier , private confirmService , private videoBlacklistService , private serverService , private screenService , private videoService , private blocklistService , private 0 ) { } get user ( ) { return this . authService . getUser ( ) } ngOnChanges ( ) { if ( this . loaded ) { this . loaded = false this . playlistAdd . reload ( ) } this . buildActions ( ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } loadDropdownInformation ( ) { if ( ! this . isUserLoggedIn ( ) || this . loaded === true ) return this . loaded = true if ( this . displayOptions . playlist ) this . playlistAdd . load ( ) } showDownloadModal ( ) { this . videoDownloadModal . show ( this . video as VideoDetails ) } showReportModal ( ) { this . videoReportModal . show ( ) } showBlacklistModal ( ) { this . videoBlacklistModal . show ( ) } isVideoUpdatable ( ) { return this . video . isUpdatableBy ( this . user ) } isVideoRemovable ( ) { return this . video . isRemovableBy ( this . user ) } isVideoBlacklistable ( ) { return this . video . isBlackistableBy ( this . user ) } isVideoUnblacklistable ( ) { return this . video . isUnblacklistableBy ( this . user ) } isVideoDownloadable ( ) { return this . video && this . video instanceof VideoDetails && this . video . downloadEnabled } async unblacklistVideo ( ) { const confirmMessage = this . 0 ( 's' ) const res = await this . confirmService . confirm ( confirmMessage , this . 0 ( 's' ) ) if ( res === false ) return this . videoBlacklistService . removeVideoFromBlacklist ( this . video . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { name : this . video . name } ) ) this . video . blacklisted = false this . video . blacklistedReason = null this . videoUnblacklisted . emit ( ) } , err => this . notifier . error ( err . message ) ) } async removeVideo ( ) { const res = await this . confirmService . confirm ( this . 0 ( 's' ) , this . 0 ( 's' ) ) if ( res === false ) return this . videoService . removeVideo ( this . video . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { videoName : this . video . name } ) ) this . videoRemoved . emit ( ) } , error => this . notifier . error ( error . message ) ) } onVideoBlacklisted ( ) { this . videoBlacklisted . emit ( ) } getPlaylistDropdownPlacement ( ) { if ( this . screenService . isInSmallView ( ) ) { return 's' } return 's' } private buildActions ( ) { this . videoActions = [ [ { label : this . 0 ( 's' ) , handler : ( ) => this . playlistDropdown . toggle ( ) , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . playlist , iconName : 's' } ] , [ { label : this . 0 ( 's' ) , handler : ( ) => this . showDownloadModal ( ) , isDisplayed : ( ) => this . displayOptions . download && this . isVideoDownloadable ( ) , iconName : 's' } , { label : this . 0 ( 's' ) , linkBuilder : ( { video } ) => [ 's' , video . uuid ] , iconName : 's' , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . update && this . isVideoUpdatable ( ) } , { label : this . 0 ( 's' ) , handler : ( ) => this . showBlacklistModal ( ) , iconName : 's' , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . blacklist && this . isVideoBlacklistable ( ) } , { label : this . 0 ( 's' ) , handler : ( ) => this . unblacklistVideo ( ) , iconName : 's' , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . blacklist && this . isVideoUnblacklistable ( ) } , { label : this . 0 ( 's' ) , handler : ( ) => this . removeVideo ( ) , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . delete && this . isVideoRemovable ( ) , iconName : 's' } ] , [ { label : this . 0 ( 's' ) , handler : ( ) => this . showReportModal ( ) , isDisplayed : ( ) => this . authService . isLoggedIn ( ) && this . displayOptions . report , iconName : 's' } ] ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $VideoBlacklistService$ O O $ServerService$ O O $ScreenService$ O O $VideoService$ O O $BlocklistService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AfterContentInit , Component , ContentChildren , EventEmitter , Input , OnDestroy , OnInit , Output , QueryList , TemplateRef } from 's' import { ActivatedRoute , Router } from 's' import { AbstractVideoList } from 's' import { AuthService , Notifier , ServerService } from 's' import { ScreenService } from 's' import { MiniatureDisplayOptions } from 's' import { Observable } from 's' import { Video } from 's' import { PeerTubeTemplateDirective } from 's' import { VideoSortField } from 's' import { ComponentPagination } from 's' import { 0 } from 's' import { ResultList } from 's' export type SelectionType = { [ id ] : boolean } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideosSelectionComponent extends AbstractVideoList implements OnInit , OnDestroy , AfterContentInit { @ Input ( ) pagination : ComponentPagination @ Input ( ) titlePage : string @ Input ( ) miniatureDisplayOptions : MiniatureDisplayOptions @ Input ( ) getVideosObservableFunction : ( page , sort ? ) => Observable < ResultList < Video > > @ ContentChildren ( PeerTubeTemplateDirective ) templates : QueryList < PeerTubeTemplateDirective < 's' | 's' > > @ Output ( ) selectionChange = new EventEmitter < SelectionType > ( ) @ Output ( ) videosModelChange = new EventEmitter < Video [ ] > ( ) _selection : SelectionType = { } rowButtonsTemplate : TemplateRef < any > globalButtonsTemplate : TemplateRef < any > constructor ( protected 0 , protected router , protected route , protected notifier , protected authService , protected screenService , protected serverService ) { super ( ) } @ Input ( ) get selection ( ) { return this . _selection } set selection ( selection ) { this . _selection = selection this . selectionChange . emit ( this . _selection ) } @ Input ( ) get videosModel ( ) { return this . videos } set videosModel ( videos : Video [ ] ) { this . videos = videos this . videosModelChange . emit ( this . videos ) } ngOnInit ( ) { super . ngOnInit ( ) } ngAfterContentInit ( ) { { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . rowButtonsTemplate = t . template } { const t = this . templates . find ( t => t . name === 's' ) if ( t ) this . globalButtonsTemplate = t . template } } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { return this . getVideosObservableFunction ( page , this . sort ) } abortSelectionMode ( ) { this . _selection = { } } isInSelectionMode ( ) { return Object . keys ( this . _selection ) . some ( k => this . _selection [ k ] === true ) } generateSyndicationList ( ) { throw new Error ( 's' ) } protected onMoreVideos ( ) { this . videosModel = this . videos } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $VideoSortField$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ActivatedRoute$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $ServerService$ O O O O O O O O O O O O O O O O O O O O O O O $SelectionType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , switchMap } from 's' import { HttpClient } from 's' import { Injectable } from 's' import { Observable , of } from 's' import { peertubeTranslate , ResultList } from 's' import { RestExtractor } from 's' import { VideoService } from 's' import { objectToFormData , sortBy } from 's' import { VideoCaptionEdit } from 's' import { VideoCaption } from 's' import { ServerService } from 's' @ Injectable ( ) export class VideoCaptionService { constructor ( private authHttp , private serverService , private restExtractor ) { } listCaptions ( videoId : number | string ) < ResultList < VideoCaption > > { return this . authHttp . get < ResultList < VideoCaption > > ( VideoService . BASE_VIDEO_URL + videoId + 's' ) . pipe ( switchMap ( captionsResult => { return this . serverService . localeObservable . pipe ( map ( translations => ( { captionsResult , translations } ) ) ) } ) , map ( ( { captionsResult , translations } ) => { for ( const c of captionsResult . data ) { c . language . label = peertubeTranslate ( c . language . label , translations ) } return captionsResult } ) , map ( captionsResult => { sortBy ( captionsResult . data , 's' , 's' ) return captionsResult } ) ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } removeCaption ( videoId : number | string , language ) { return this . authHttp . delete ( VideoService . BASE_VIDEO_URL + videoId + 's' + language ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } addCaption ( videoId : number | string , language , captionfile ) { const body = { captionfile } const data = objectToFormData ( body ) return this . authHttp . put ( VideoService . BASE_VIDEO_URL + videoId + 's' + language , data ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( res => this . restExtractor . handleError ( res ) ) ) } updateCaptions ( videoId : number | string , videoCaptions : VideoCaptionEdit [ ] ) { let obs = of ( true ) for ( const videoCaption of videoCaptions ) { if ( videoCaption . action === 's' ) { obs = obs . pipe ( switchMap ( ( ) => this . addCaption ( videoId , videoCaption . language . id , videoCaption . captionfile ) ) ) } else if ( videoCaption . action === 's' ) { obs = obs . pipe ( switchMap ( ( ) => this . removeCaption ( videoId , videoCaption . language . id ) ) ) } } return obs } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $ServerService$ O O $RestExtractor$ O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $File$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export interface VideoCaptionEdit { language : { id : string label ? : string } action ? : 's' | 's' captionfile ? : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoChannel as ServerVideoChannel } from 's' import { Actor } from 's' import { Account } from 's' export class VideoChannel extends Actor implements ServerVideoChannel { displayName : string description : string support : string isLocal : boolean nameWithHost : string ownerAccount ? : Account ownerBy ? : string ownerAvatarUrl ? : string constructor ( hash ) { super ( hash ) this . displayName = hash . displayName this . description = hash . description this . support = hash . support this . isLocal = hash . isLocal this . nameWithHost = Actor . CREATE_BY_STRING ( this . name , this . host ) if ( hash . ownerAccount ) { this . ownerAccount = hash . ownerAccount this . ownerBy = Actor . CREATE_BY_STRING ( hash . ownerAccount . name , hash . ownerAccount . host ) this . ownerAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . ownerAccount ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerVideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , tap } from 's' import { Injectable } from 's' import { Observable , ReplaySubject } from 's' import { RestExtractor } from 's' import { HttpClient , HttpParams } from 's' import { VideoChannel as VideoChannelServer , VideoChannelCreate , VideoChannelUpdate } from 's' import { AccountService } from 's' import { ResultList } from 's' import { VideoChannel } from 's' import { environment } from 's' import { Account } from 's' import { Avatar } from 's' import { ComponentPagination } from 's' import { RestService } from 's' @ Injectable ( ) export class VideoChannelService { static BASE_VIDEO_CHANNEL_URL = environment . apiUrl + 's' videoChannelLoaded = new ReplaySubject < VideoChannel > ( 0 ) static extractVideoChannels ( result < VideoChannelServer > ) { const videoChannels : VideoChannel [ ] = [ ] for ( const videoChannelJSON of result . data ) { videoChannels . push ( new VideoChannel ( videoChannelJSON ) ) } return { data : videoChannels , total : result . total } } constructor ( private authHttp , private restService , private restExtractor ) { } getVideoChannel ( videoChannelName ) { return this . authHttp . get < VideoChannel > ( VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannelName ) . pipe ( map ( videoChannelHash => new VideoChannel ( videoChannelHash ) ) , tap ( videoChannel => this . videoChannelLoaded . next ( videoChannel ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } listAccountVideoChannels ( account , componentPagination ? ) < ResultList < VideoChannel > > { const pagination = componentPagination ? this . restService . componentPaginationToRestPagination ( componentPagination ) : { start : 0 , count : 0 } let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) const url = AccountService . BASE_ACCOUNT_URL + account . nameWithHost + 's' return this . authHttp . get < ResultList < VideoChannelServer > > ( url , { params } ) . pipe ( map ( res => VideoChannelService . extractVideoChannels ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } createVideoChannel ( videoChannel ) { return this . authHttp . post ( VideoChannelService . BASE_VIDEO_CHANNEL_URL , videoChannel ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateVideoChannel ( videoChannelName , videoChannel ) { return this . authHttp . put ( VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannelName , videoChannel ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } changeVideoChannelAvatar ( videoChannelName , avatarForm ) { const url = VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannelName + 's' return this . authHttp . post < { avatar : Avatar } > ( url , avatarForm ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } removeVideoChannel ( videoChannel ) { return this . authHttp . delete ( VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannel . nameWithHost ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $Account$ O O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideoChannelUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $FormData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map , switchMap } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { Observable } from 's' import { peertubeTranslate , VideoImport } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { VideoImportCreate , VideoUpdate } from 's' import { objectToFormData } from 's' import { ResultList } from 's' import { UserService } from 's' import { SortMeta } from 's' import { RestPagination } from 's' import { ServerService } from 's' @ Injectable ( ) export class VideoImportService { private static BASE_VIDEO_IMPORT_URL = environment . apiUrl + 's' constructor ( private authHttp , private restService , private restExtractor , private serverService ) { } importVideoUrl ( targetUrl , video ) < VideoImport > { const url = VideoImportService . BASE_VIDEO_IMPORT_URL const body = this . buildImportVideoObject ( video ) body . targetUrl = targetUrl const data = objectToFormData ( body ) return this . authHttp . post < VideoImport > ( url , data ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } importVideoTorrent ( target : string | Blob , video ) < VideoImport > { const url = VideoImportService . BASE_VIDEO_IMPORT_URL const body = this . buildImportVideoObject ( video ) if ( typeof target === 's' ) body . magnetUri = target else body . torrentfile = target const data = objectToFormData ( body ) return this . authHttp . post < VideoImport > ( url , data ) . pipe ( catchError ( res => this . restExtractor . handleError ( res ) ) ) } getMyVideoImports ( pagination , sort ) < ResultList < VideoImport > > { let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < VideoImport > > ( UserService . BASE_USERS_URL + 's' , { params } ) . pipe ( switchMap ( res => this . extractVideoImports ( res ) ) , map ( res => this . restExtractor . convertResultListDateToHuman ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } private buildImportVideoObject ( video ) { const language = video . language || null const licence = video . licence || null const category = video . category || null const description = video . description || null const support = video . support || null const scheduleUpdate = video . scheduleUpdate || null const originallyPublishedAt = video . originallyPublishedAt || null return { name : video . name , category , licence , language , support , description , channelId : video . channelId , privacy : video . privacy , tags : video . tags , nsfw : video . nsfw , waitTranscoding : video . waitTranscoding , commentsEnabled : video . commentsEnabled , downloadEnabled : video . downloadEnabled , thumbnailfile : video . thumbnailfile , previewfile : video . previewfile , scheduleUpdate , originallyPublishedAt } } private extractVideoImports ( result < VideoImport > ) < ResultList < VideoImport > > { return this . serverService . localeObservable . pipe ( map ( translations => { result . data . forEach ( d => d . state . label = peertubeTranslate ( d . state . label , translations ) ) return result } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestService$ O O $RestExtractor$ O O $ServerService$ O O O $Observable$ O $string$ O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O $VideoUpdate$ O O O O O O O O O O O O $VideoImportCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $RestPagination$ O $SortMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportCreate$ O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { ChangeDetectionStrategy , ChangeDetectorRef , Component , Input , OnChanges , OnInit , SimpleChanges } from 's' import { VideoPlaylistService } from 's' import { AuthService , Notifier } from 's' import { forkJoin } from 's' import { Video , VideoPlaylistCreate , VideoPlaylistElementCreate , VideoPlaylistPrivacy } from 's' import { FormReactive , FormValidatorService , VideoPlaylistValidatorsService } from 's' import { 0 } from 's' import { secondsToTime } from 's' type PlaylistSummary = { id : number inPlaylist : boolean displayName : string playlistElementId ? : number startTimestamp ? : number stopTimestamp ? : number } @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , changeDetection : ChangeDetectionStrategy . OnPush } ) export class VideoAddToPlaylistComponent extends FormReactive implements OnInit , OnChanges { @ Input ( ) video : Video @ Input ( ) currentVideoTimestamp : number @ Input ( ) lazyLoad = false isNewPlaylistBlockOpened = false videoPlaylists : PlaylistSummary [ ] = [ ] timestampOptions : { startTimestampEnabled : boolean startTimestamp : number stopTimestampEnabled : boolean stopTimestamp : number } displayOptions = false constructor ( protected formValidatorService , private authService , private notifier , private 0 , private videoPlaylistService , private videoPlaylistValidatorsService , private cd ) { super ( ) } get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . buildForm ( { displayName : this . videoPlaylistValidatorsService . VIDEO_PLAYLIST_DISPLAY_NAME } ) } ngOnChanges ( simpleChanges ) { if ( simpleChanges [ 's' ] ) { this . reload ( ) } } init ( ) { this . resetOptions ( true ) if ( this . lazyLoad !== true ) this . load ( ) } reload ( ) { this . videoPlaylists = [ ] this . init ( ) this . cd . markForCheck ( ) } load ( ) { forkJoin ( [ this . videoPlaylistService . listAccountPlaylists ( this . user . account , undefined , 's' ) , this . videoPlaylistService . doesVideoExistInPlaylist ( this . video . id ) ] ) . subscribe ( ( [ playlistsResult , existResult ] ) => { for ( const playlist of playlistsResult . data ) { const existingPlaylist = existResult [ this . video . id ] . find ( p => p . playlistId === playlist . id ) this . videoPlaylists . push ( { id : playlist . id , displayName : playlist . displayName , inPlaylist : ! ! existingPlaylist , playlistElementId : existingPlaylist ? existingPlaylist . playlistElementId : undefined , startTimestamp : existingPlaylist ? existingPlaylist . startTimestamp : undefined , stopTimestamp : existingPlaylist ? existingPlaylist . stopTimestamp : undefined } ) } this . cd . markForCheck ( ) } ) } openChange ( opened ) { if ( opened === false ) { this . isNewPlaylistBlockOpened = false this . displayOptions = false } } openCreateBlock ( event ) { event . preventDefault ( ) this . isNewPlaylistBlockOpened = true } togglePlaylist ( event , playlist ) { event . preventDefault ( ) if ( playlist . inPlaylist === true ) { this . removeVideoFromPlaylist ( playlist ) } else { this . addVideoInPlaylist ( playlist ) } playlist . inPlaylist = ! playlist . inPlaylist this . resetOptions ( ) this . cd . markForCheck ( ) } createPlaylist ( ) { const displayName = this . form . value [ 's' ] const videoPlaylistCreate = { displayName , privacy : VideoPlaylistPrivacy . PRIVATE } this . videoPlaylistService . createVideoPlaylist ( videoPlaylistCreate ) . subscribe ( res => { this . videoPlaylists . push ( { id : res . videoPlaylist . id , displayName , inPlaylist : false } ) this . isNewPlaylistBlockOpened = false this . cd . markForCheck ( ) } , err => this . notifier . error ( err . message ) ) } resetOptions ( resetTimestamp = false ) { this . displayOptions = false this . timestampOptions = { } as any this . timestampOptions . startTimestampEnabled = false this . timestampOptions . stopTimestampEnabled = false if ( resetTimestamp ) { this . timestampOptions . startTimestamp = 0 this . timestampOptions . stopTimestamp = this . video . duration } } formatTimestamp ( playlist ) { const start = playlist . startTimestamp ? secondsToTime ( playlist . startTimestamp ) : 's' const stop = playlist . stopTimestamp ? secondsToTime ( playlist . stopTimestamp ) : 's' return `template` } private removeVideoFromPlaylist ( playlist ) { if ( ! playlist . playlistElementId ) return this . videoPlaylistService . removeVideoFromPlaylist ( playlist . id , playlist . playlistElementId ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { name : playlist . displayName } ) ) playlist . inPlaylist = false playlist . playlistElementId = undefined } , err => { this . notifier . error ( err . message ) playlist . inPlaylist = true } , ( ) => this . cd . markForCheck ( ) ) } private addVideoInPlaylist ( playlist ) { const body = { videoId : this . video . id } if ( this . timestampOptions . startTimestampEnabled ) body . startTimestamp = this . timestampOptions . startTimestamp if ( this . timestampOptions . stopTimestampEnabled ) body . stopTimestamp = this . timestampOptions . stopTimestamp this . videoPlaylistService . addVideoInPlaylist ( playlist . id , body ) . subscribe ( res => { playlist . inPlaylist = true playlist . playlistElementId = res . videoPlaylistElement . id playlist . startTimestamp = body . startTimestamp playlist . stopTimestamp = body . stopTimestamp const message = body . startTimestamp || body . stopTimestamp ? this . 0 ( 's' , { n : playlist . displayName , t : this . formatTimestamp ( playlist ) } ) : this . 0 ( 's' , { n : playlist . displayName } ) this . notifier . success ( message ) } , err => { this . notifier . error ( err . message ) playlist . inPlaylist = false } , ( ) => this . cd . markForCheck ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $AuthService$ O O $Notifier$ O O $I18n$ O O $VideoPlaylistService$ O O $VideoPlaylistValidatorsService$ O O $ChangeDetectorRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimpleChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O $Event$ O $PlaylistSummary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistSummary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistSummary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistSummary$ O O O $VideoPlaylistElementCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangeDetectionStrategy , ChangeDetectorRef , Component , EventEmitter , Input , Output , ViewChild } from 's' import { Video } from 's' import { VideoPlaylistElementType , VideoPlaylistElementUpdate } from 's' import { AuthService , ConfirmService , Notifier , ServerService } from 's' import { ActivatedRoute } from 's' import { 0 } from 's' import { VideoService } from 's' import { VideoPlaylistService } from 's' import { NgbDropdown } from 's' import { VideoPlaylist } from 's' import { secondsToTime } from 's' import { VideoPlaylistElement } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' , changeDetection : ChangeDetectionStrategy . OnPush } ) export class VideoPlaylistElementMiniatureComponent { @ ViewChild ( 's' , { static : false } ) moreDropdown : NgbDropdown @ Input ( ) playlist : VideoPlaylist @ Input ( ) playlistElement : VideoPlaylistElement @ Input ( ) owned = false @ Input ( ) playing = false @ Input ( ) rowLink = false @ Input ( ) accountLink = true @ Input ( ) position : number @ Output ( ) elementRemoved = new EventEmitter < VideoPlaylistElement > ( ) displayTimestampOptions = false timestampOptions : { startTimestampEnabled : boolean startTimestamp : number stopTimestampEnabled : boolean stopTimestamp : number } = { } as any constructor ( private authService , private serverService , private notifier , private confirmService , private route , private 0 , private videoService , private videoPlaylistService , private cdr ) { } isUnavailable ( e ) { return e . type === VideoPlaylistElementType . UNAVAILABLE } isPrivate ( e ) { return e . type === VideoPlaylistElementType . PRIVATE } isDeleted ( e ) { return e . type === VideoPlaylistElementType . DELETED } buildRouterLink ( ) { if ( ! this . playlist ) return null return [ 's' , this . playlist . uuid ] } buildRouterQuery ( ) { if ( ! this . playlistElement || ! this . playlistElement . video ) return { } return { videoId : this . playlistElement . video . uuid , start : this . playlistElement . startTimestamp , stop : this . playlistElement . stopTimestamp } } isVideoBlur ( video ) { return video . isVideoNSFWForUser ( this . authService . getUser ( ) , this . serverService . getConfig ( ) ) } removeFromPlaylist ( playlistElement ) { this . videoPlaylistService . removeVideoFromPlaylist ( this . playlist . id , playlistElement . id ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' , { name : this . playlist . displayName } ) ) this . elementRemoved . emit ( playlistElement ) } , err => this . notifier . error ( err . message ) ) this . moreDropdown . close ( ) } updateTimestamps ( playlistElement ) { const body = { } body . startTimestamp = this . timestampOptions . startTimestampEnabled ? this . timestampOptions . startTimestamp : null body . stopTimestamp = this . timestampOptions . stopTimestampEnabled ? this . timestampOptions . stopTimestamp : null this . videoPlaylistService . updateVideoOfPlaylist ( this . playlist . id , playlistElement . id , body ) . subscribe ( ( ) => { this . notifier . success ( this . 0 ( 's' ) ) playlistElement . startTimestamp = body . startTimestamp playlistElement . stopTimestamp = body . stopTimestamp this . cdr . detectChanges ( ) } , err => this . notifier . error ( err . message ) ) this . moreDropdown . close ( ) } formatTimestamp ( playlistElement ) { const start = playlistElement . startTimestamp const stop = playlistElement . stopTimestamp const startFormatted = secondsToTime ( start , true , 's' ) const stopFormatted = secondsToTime ( stop , true , 's' ) if ( start === null && stop === null ) return 's' if ( start !== null && stop === null ) return this . 0 ( 's' ) + startFormatted if ( start === null && stop !== null ) return this . 0 ( 's' ) + stopFormatted return this . 0 ( 's' ) + startFormatted + this . 0 ( 's' ) + stopFormatted } onDropdownOpenChange ( ) { this . displayTimestampOptions = false } toggleDisplayTimestampsOptions ( event , playlistElement ) { event . preventDefault ( ) this . displayTimestampOptions = ! this . displayTimestampOptions if ( this . displayTimestampOptions === true ) { this . timestampOptions = { startTimestampEnabled : false , stopTimestampEnabled : false , startTimestamp : 0 , stopTimestamp : playlistElement . video . duration } if ( playlistElement . startTimestamp ) { this . timestampOptions . startTimestampEnabled = true this . timestampOptions . startTimestamp = playlistElement . startTimestamp } if ( playlistElement . stopTimestamp ) { this . timestampOptions . stopTimestampEnabled = true this . timestampOptions . stopTimestamp = playlistElement . stopTimestamp } } setTimeout ( ( ) => { this . cdr . detectChanges ( ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $ServerService$ O O $Notifier$ O O $ConfirmService$ O O $ActivatedRoute$ O O $I18n$ O O $VideoService$ O O $VideoPlaylistService$ O O $ChangeDetectorRef$ O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O $VideoPlaylistElementUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoPlaylistElement as ServerVideoPlaylistElement , VideoPlaylistElementType } from 's' import { Video } from 's' export class VideoPlaylistElement implements ServerVideoPlaylistElement { id : number position : number startTimestamp : number stopTimestamp : number type : VideoPlaylistElementType video ? : Video constructor ( hash , translations : { } ) { this . id = hash . id this . position = hash . position this . startTimestamp = hash . startTimestamp this . stopTimestamp = hash . stopTimestamp this . type = hash . type if ( hash . video ) this . video = new Video ( hash . video , translations ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerVideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { VideoPlaylist } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoPlaylistMiniatureComponent { @ Input ( ) playlist : VideoPlaylist @ Input ( ) toManage = false @ Input ( ) displayChannel = false @ Input ( ) displayDescription = false @ Input ( ) displayPrivacy = false getPlaylistUrl ( ) { if ( this . toManage ) return [ 's' , this . playlist . uuid ] if ( this . playlist . videosLength === 0 ) return null return [ 's' , this . playlist . uuid ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoChannelSummary , VideoConstant , VideoPlaylist as ServerVideoPlaylist , VideoPlaylistPrivacy , VideoPlaylistType } from 's' import { AccountSummary , peertubeTranslate } from 's' import { Actor } from 's' import { getAbsoluteAPIUrl } from 's' export class VideoPlaylist implements ServerVideoPlaylist { id : number uuid : string isLocal : boolean displayName : string description : string privacy : VideoConstant < VideoPlaylistPrivacy > thumbnailPath : string videosLength : number type : VideoConstant < VideoPlaylistType > createdAt : Date | string updatedAt : Date | string ownerAccount : AccountSummary videoChannel ? : VideoChannelSummary thumbnailUrl : string ownerBy : string ownerAvatarUrl : string videoChannelBy ? : string videoChannelAvatarUrl ? : string private thumbnailVersion : number private originThumbnailUrl : string constructor ( hash , translations : { } ) { const absoluteAPIUrl = getAbsoluteAPIUrl ( ) this . id = hash . id this . uuid = hash . uuid this . isLocal = hash . isLocal this . displayName = hash . displayName this . description = hash . description this . privacy = hash . privacy this . thumbnailPath = hash . thumbnailPath if ( this . thumbnailPath ) { this . thumbnailUrl = absoluteAPIUrl + hash . thumbnailPath this . originThumbnailUrl = this . thumbnailUrl } else { this . thumbnailUrl = window . location . origin + 's' } this . videosLength = hash . videosLength this . type = hash . type this . createdAt = new Date ( hash . createdAt ) this . updatedAt = new Date ( hash . updatedAt ) this . ownerAccount = hash . ownerAccount this . ownerBy = Actor . CREATE_BY_STRING ( hash . ownerAccount . name , hash . ownerAccount . host ) this . ownerAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . ownerAccount ) if ( hash . videoChannel ) { this . videoChannel = hash . videoChannel this . videoChannelBy = Actor . CREATE_BY_STRING ( hash . videoChannel . name , hash . videoChannel . host ) this . videoChannelAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . videoChannel ) } this . privacy . label = peertubeTranslate ( this . privacy . label , translations ) if ( this . type . id === VideoPlaylistType . WATCH_LATER ) { this . displayName = peertubeTranslate ( this . displayName , translations ) } } refreshThumbnail ( ) { if ( ! this . originThumbnailUrl ) return if ( ! this . thumbnailVersion ) this . thumbnailVersion = 0 this . thumbnailVersion ++ this . thumbnailUrl = this . originThumbnailUrl + 's' + this . thumbnailVersion } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerVideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { bufferTime , catchError , filter , first , map , share , switchMap } from 's' import { Injectable } from 's' import { Observable , ReplaySubject , Subject } from 's' import { RestExtractor } from 's' import { HttpClient , HttpParams } from 's' import { ResultList , VideoPlaylistElementCreate , VideoPlaylistElementUpdate } from 's' import { environment } from 's' import { VideoPlaylist as VideoPlaylistServerModel } from 's' import { VideoChannelService } from 's' import { VideoChannel } from 's' import { VideoPlaylistCreate } from 's' import { VideoPlaylistUpdate } from 's' import { objectToFormData } from 's' import { ServerService } from 's' import { VideoPlaylist } from 's' import { AccountService } from 's' import { Account } from 's' import { RestService } from 's' import { VideoExistInPlaylist } from 's' import { VideoPlaylistReorder } from 's' import { ComponentPagination } from 's' import { VideoPlaylistElement as ServerVideoPlaylistElement } from 's' import { VideoPlaylistElement } from 's' @ Injectable ( ) export class VideoPlaylistService { static BASE_VIDEO_PLAYLIST_URL = environment . apiUrl + 's' static MY_VIDEO_PLAYLIST_URL = environment . apiUrl + 's' private videoExistsInPlaylistSubject : Subject < number > = new ReplaySubject ( 0 ) private readonly videoExistsInPlaylistObservable : Observable < VideoExistInPlaylist > constructor ( private authHttp , private serverService , private restExtractor , private restService ) { this . videoExistsInPlaylistObservable = this . videoExistsInPlaylistSubject . pipe ( bufferTime ( 0 ) , filter ( videoIds => videoIds . length !== 0 ) , switchMap ( videoIds => this . doVideosExistInPlaylist ( videoIds ) ) , share ( ) ) } listChannelPlaylists ( videoChannel , componentPagination ) < ResultList < VideoPlaylist > > { const url = VideoChannelService . BASE_VIDEO_CHANNEL_URL + videoChannel . nameWithHost + 's' const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) return this . authHttp . get < ResultList < VideoPlaylist > > ( url , { params } ) . pipe ( switchMap ( res => this . extractPlaylists ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } listAccountPlaylists ( account , componentPagination , sort ) < ResultList < VideoPlaylist > > { const url = AccountService . BASE_ACCOUNT_URL + account . nameWithHost + 's' const pagination = componentPagination ? this . restService . componentPaginationToRestPagination ( componentPagination ) : undefined let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) return this . authHttp . get < ResultList < VideoPlaylist > > ( url , { params } ) . pipe ( switchMap ( res => this . extractPlaylists ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideoPlaylist ( id : string | number ) { const url = VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + id return this . authHttp . get < VideoPlaylist > ( url ) . pipe ( switchMap ( res => this . extractPlaylist ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } createVideoPlaylist ( body ) { const data = objectToFormData ( body ) return this . authHttp . post < { videoPlaylist : { id : number } } > ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL , data ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateVideoPlaylist ( videoPlaylist , body ) { const data = objectToFormData ( body ) return this . authHttp . put ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + videoPlaylist . id , data ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } removeVideoPlaylist ( videoPlaylist ) { return this . authHttp . delete ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + videoPlaylist . id ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } addVideoInPlaylist ( playlistId , body ) { const url = VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + playlistId + 's' return this . authHttp . post < { videoPlaylistElement : { id : number } } > ( url , body ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } updateVideoOfPlaylist ( playlistId , playlistElementId , body ) { return this . authHttp . put ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + playlistId + 's' + playlistElementId , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } removeVideoFromPlaylist ( playlistId , playlistElementId ) { return this . authHttp . delete ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + playlistId + 's' + playlistElementId ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } reorderPlaylist ( playlistId , oldPosition , newPosition ) { const body = { startPosition : oldPosition , insertAfterPosition : newPosition } return this . authHttp . post ( VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + playlistId + 's' , body ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getPlaylistVideos ( videoPlaylistId : number | string , componentPagination ) < ResultList < VideoPlaylistElement > > { const path = VideoPlaylistService . BASE_VIDEO_PLAYLIST_URL + videoPlaylistId + 's' const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination ) return this . authHttp . get < ResultList < ServerVideoPlaylistElement > > ( path , { params } ) . pipe ( switchMap ( res => this . extractVideoPlaylistElements ( res ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } doesVideoExistInPlaylist ( videoId ) { this . videoExistsInPlaylistSubject . next ( videoId ) return this . videoExistsInPlaylistObservable . pipe ( first ( ) ) } extractPlaylists ( result < VideoPlaylistServerModel > ) { return this . serverService . localeObservable . pipe ( map ( translations => { const playlistsJSON = result . data const total = result . total const playlists : VideoPlaylist [ ] = [ ] for ( const playlistJSON of playlistsJSON ) { playlists . push ( new VideoPlaylist ( playlistJSON , translations ) ) } return { data : playlists , total } } ) ) } extractPlaylist ( playlist ) { return this . serverService . localeObservable . pipe ( map ( translations => new VideoPlaylist ( playlist , translations ) ) ) } extractVideoPlaylistElements ( result < ServerVideoPlaylistElement > ) { return this . serverService . localeObservable . pipe ( map ( translations => { const elementsJson = result . data const total = result . total const elements : VideoPlaylistElement [ ] = [ ] for ( const elementJson of elementsJson ) { elements . push ( new VideoPlaylistElement ( elementJson , translations ) ) } return { total , data : elements } } ) ) } private doVideosExistInPlaylist ( videoIds : number [ ] ) < VideoExistInPlaylist > { const url = VideoPlaylistService . MY_VIDEO_PLAYLIST_URL + 's' let params = new HttpParams ( ) params = this . restService . addObjectParams ( params , { videoIds } ) return this . authHttp . get < VideoExistInPlaylist > ( url , { params } ) . pipe ( catchError ( err => this . restExtractor . handleError ( err ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $ServerService$ O O $RestExtractor$ O O $RestService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $VideoChannel$ O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $Account$ O $ComponentPagination$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O $VideoPlaylistUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoPlaylistElementCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $VideoPlaylistElementUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O O $VideoPlaylistReorder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O $ComponentPagination$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistServerModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , EventEmitter , Input , OnInit , Output , ViewChild } from 's' import { FormReactive } from 's' import { FormValidatorService } from 's' import { VideoCaptionsValidatorsService } from 's' import { ServerService } from 's' import { VideoCaptionEdit } from 's' import { NgbModal , NgbModalRef } from 's' import { VideoConstant } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoCaptionAddModalComponent extends FormReactive implements OnInit { @ Input ( ) existingCaptions : string [ ] @ Output ( ) captionAdded = new EventEmitter < VideoCaptionEdit > ( ) @ ViewChild ( 's' , { static : true } ) modal : ElementRef videoCaptionLanguages : VideoConstant < string > [ ] = [ ] private openedModal : NgbModalRef private closingModal = false constructor ( protected formValidatorService , private modalService , private serverService , private videoCaptionsValidatorsService ) { super ( ) } get videoCaptionExtensions ( ) { return this . serverService . getConfig ( ) . videoCaption . file . extensions } get videoCaptionMaxSize ( ) { return this . serverService . getConfig ( ) . videoCaption . file . size . max } ngOnInit ( ) { this . videoCaptionLanguages = this . serverService . getVideoLanguages ( ) this . buildForm ( { language : this . videoCaptionsValidatorsService . VIDEO_CAPTION_LANGUAGE , captionfile : this . videoCaptionsValidatorsService . VIDEO_CAPTION_FILE } ) } show ( ) { this . closingModal = false this . openedModal = this . modalService . open ( this . modal , { keyboard : false } ) } hide ( ) { this . closingModal = true this . openedModal . close ( ) this . form . reset ( ) } isReplacingExistingCaption ( ) { if ( this . closingModal === true ) return false const languageId = this . form . value [ 's' ] return languageId && this . existingCaptions . indexOf ( languageId ) !== - 0 } async addCaption ( ) { const languageId = this . form . value [ 's' ] const languageObject = this . videoCaptionLanguages . find ( l => l . id === languageId ) this . captionAdded . emit ( { language : languageObject , captionfile : this . form . value [ 's' ] } ) this . hide ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $NgbModal$ O O $ServerService$ O O $VideoCaptionsValidatorsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , NgZone , OnDestroy , OnInit , ViewChild } from 's' import { FormArray , FormControl , FormGroup , ValidatorFn , Validators } from 's' import { ActivatedRoute , Router } from 's' import { FormReactiveValidationMessages , VideoValidatorsService } from 's' import { Notifier } from 's' import { ServerService } from 's' import { VideoEdit } from 's' import { map } from 's' import { FormValidatorService } from 's' import { 0 } from 's' import { VideoCaptionService } from 's' import { VideoCaptionAddModalComponent } from 's' import { VideoCaptionEdit } from 's' import { removeElementFromArray } from 's' import { VideoConstant , VideoPrivacy } from 's' import { VideoService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoEditComponent implements OnInit , OnDestroy { @ Input ( ) form : FormGroup @ Input ( ) formErrors : { [ id ] : string } = { } @ Input ( ) validationMessages : FormReactiveValidationMessages = { } @ Input ( ) userVideoChannels : { id : number , label : string , support : string } [ ] = [ ] @ Input ( ) schedulePublicationPossible = true @ Input ( ) videoCaptions : ( VideoCaptionEdit & { captionPath ? : string } ) [ ] = [ ] @ Input ( ) waitTranscodingEnabled = true @ ViewChild ( 's' , { static : true } ) videoCaptionAddModal : VideoCaptionAddModalComponent readonly SPECIAL_SCHEDULED_PRIVACY = VideoEdit . SPECIAL_SCHEDULED_PRIVACY videoPrivacies : VideoConstant < VideoPrivacy > [ ] = [ ] videoCategories : VideoConstant < number > [ ] = [ ] videoLicences : VideoConstant < number > [ ] = [ ] videoLanguages : VideoConstant < string > [ ] = [ ] tagValidators : ValidatorFn [ ] tagValidatorsMessages : { [ name ] : string } schedulePublicationEnabled = false calendarLocale : any = { } minScheduledDate = new Date ( ) myYearRange = 's' + ( new Date ( ) ) . getFullYear ( ) calendarTimezone : string calendarDateFormat : string private schedulerInterval : any private firstPatchDone = false private initialVideoCaptions : string [ ] = [ ] constructor ( private formValidatorService , private videoValidatorsService , private videoCaptionService , private videoService , private route , private router , private notifier , private serverService , private 0 , private ngZone ) { this . tagValidators = this . videoValidatorsService . VIDEO_TAGS . VALIDATORS this . tagValidatorsMessages = this . videoValidatorsService . VIDEO_TAGS . MESSAGES this . calendarLocale = this . 0 . getCalendarLocale ( ) this . calendarTimezone = this . 0 . getTimezone ( ) this . calendarDateFormat = this . 0 . getDateFormat ( ) } get existingCaptions ( ) { return this . videoCaptions . filter ( c => c . action !== 's' ) . map ( c => c . language . id ) } updateForm ( ) { const defaultValues = { nsfw : 's' , commentsEnabled : 's' , downloadEnabled : 's' , waitTranscoding : 's' , tags : [ ] } const obj = { name : this . videoValidatorsService . VIDEO_NAME , privacy : this . videoValidatorsService . VIDEO_PRIVACY , channelId : this . videoValidatorsService . VIDEO_CHANNEL , nsfw : null , commentsEnabled : null , downloadEnabled : null , waitTranscoding : null , category : this . videoValidatorsService . VIDEO_CATEGORY , licence : this . videoValidatorsService . VIDEO_LICENCE , language : this . videoValidatorsService . VIDEO_LANGUAGE , description : this . videoValidatorsService . VIDEO_DESCRIPTION , tags : null , previewfile : null , support : this . videoValidatorsService . VIDEO_SUPPORT , schedulePublicationAt : this . videoValidatorsService . VIDEO_SCHEDULE_PUBLICATION_AT , originallyPublishedAt : this . videoValidatorsService . VIDEO_ORIGINALLY_PUBLISHED_AT } this . formValidatorService . updateForm ( this . form , this . formErrors , this . validationMessages , obj , defaultValues ) this . form . addControl ( 's' , new FormArray ( [ new FormGroup ( { language : new FormControl ( ) , captionfile : new FormControl ( ) } ) ] ) ) this . trackChannelChange ( ) this . trackPrivacyChange ( ) } ngOnInit ( ) { this . updateForm ( ) this . videoCategories = this . serverService . getVideoCategories ( ) this . videoLicences = this . serverService . getVideoLicences ( ) this . videoLanguages = this . serverService . getVideoLanguages ( ) const privacies = this . serverService . getVideoPrivacies ( ) this . videoPrivacies = this . videoService . explainedPrivacyLabels ( privacies ) this . initialVideoCaptions = this . videoCaptions . map ( c => c . language . id ) this . ngZone . runOutsideAngular ( ( ) => { this . schedulerInterval = setInterval ( ( ) => this . minScheduledDate = new Date ( ) , 0 * 0 ) } ) } ngOnDestroy ( ) { if ( this . schedulerInterval ) clearInterval ( this . schedulerInterval ) } onCaptionAdded ( caption ) { const existingCaption = this . videoCaptions . find ( c => c . language . id === caption . language . id ) if ( existingCaption ) { Object . assign ( existingCaption , caption , { action : 's' as 's' } ) } else { this . videoCaptions . push ( Object . assign ( caption , { action : 's' as 's' } ) ) } this . sortVideoCaptions ( ) } async deleteCaption ( caption ) { if ( caption . action && this . initialVideoCaptions . indexOf ( caption . language . id ) !== - 0 ) { caption . action = undefined return } if ( caption . action === 's' ) { removeElementFromArray ( this . videoCaptions , caption ) return } caption . action = 's' as 's' } openAddCaptionModal ( ) { this . videoCaptionAddModal . show ( ) } private sortVideoCaptions ( ) { this . videoCaptions . sort ( ( 0 , 0 ) => { if ( 0 . language . label < 0 . language . label ) return - 0 if ( 0 . language . label === 0 . language . label ) return 0 return 0 } ) } private trackPrivacyChange ( ) { this . form . controls [ 's' ] . valueChanges . pipe ( map ( res => parseInt ( res . toString ( ) , 0 ) ) ) . subscribe ( newPrivacyId => { this . schedulePublicationEnabled = newPrivacyId === this . SPECIAL_SCHEDULED_PRIVACY const scheduleControl = this . form . get ( 's' ) const waitTranscodingControl = this . form . get ( 's' ) if ( this . schedulePublicationEnabled ) { scheduleControl . setValidators ( [ Validators . required ] ) waitTranscodingControl . disable ( ) waitTranscodingControl . setValue ( false ) } else { scheduleControl . clearValidators ( ) waitTranscodingControl . enable ( ) if ( this . firstPatchDone === true ) { waitTranscodingControl . setValue ( true ) } } scheduleControl . updateValueAndValidity ( ) waitTranscodingControl . updateValueAndValidity ( ) this . firstPatchDone = true } ) } private trackChannelChange ( ) { this . form . controls [ 's' ] . valueChanges . pipe ( map ( res => parseInt ( res . toString ( ) , 0 ) ) ) . subscribe ( newChannelId => { const oldChannelId = parseInt ( this . form . value [ 's' ] , 0 ) const currentSupport = this . form . value [ 's' ] if ( isNaN ( newChannelId ) ) return const newChannel = this . userVideoChannels . find ( c => c . id === newChannelId ) if ( ! newChannel ) return if ( isNaN ( oldChannelId ) ) return this . updateSupportField ( newChannel . support ) const oldChannel = this . userVideoChannels . find ( c => c . id === oldChannelId ) if ( ! newChannel || ! oldChannel ) { console . error ( 's' ) return } if ( currentSupport && currentSupport !== oldChannel . support ) return this . updateSupportField ( newChannel . support ) } ) } private updateSupportField ( support ) { return this . form . patchValue ( { support : support || 's' } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $VideoValidatorsService$ O O $VideoCaptionService$ O O $VideoService$ O O $ActivatedRoute$ O O $Router$ O O $Notifier$ O O $ServerService$ O O $I18nPrimengCalendarService$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaptionEdit$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaptionEdit$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { TagInputModule } from 's' import { SharedModule } from 's' import { VideoEditComponent } from 's' import { CalendarModule } from 's' import { VideoCaptionAddModalComponent } from 's' @ NgModule ( { imports : [ TagInputModule , CalendarModule , SharedModule ] , declarations : [ VideoEditComponent , VideoCaptionAddModalComponent ] , exports : [ TagInputModule , CalendarModule , VideoEditComponent ] , providers : [ ] } ) export class VideoEditModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , EventEmitter , OnInit , Output , ViewChild } from 's' import { Router } from 's' import { VideoPrivacy , VideoUpdate } from 's' import { AuthService , Notifier , ServerService } from 's' import { VideoService } from 's' import { 0 } from 's' import { LoadingBarService } from 's' import { VideoSend } from 's' import { CanComponentDeactivate } from 's' import { VideoEdit } from 's' import { FormValidatorService } from 's' import { VideoCaptionService } from 's' import { VideoImportService } from 's' import { scrollToTop } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' , 's' ] } ) export class VideoImportTorrentComponent extends VideoSend implements OnInit , CanComponentDeactivate { @ Output ( ) firstStepDone = new EventEmitter < string > ( ) @ Output ( ) firstStepError = new EventEmitter < void > ( ) @ ViewChild ( 's' , { static : false } ) torrentfileInput : ElementRef < HTMLInputElement > magnetUri = 's' isImportingVideo = false hasImportedVideo = false isUpdatingVideo = false video : VideoEdit error : string protected readonly DEFAULT_VIDEO_PRIVACY = VideoPrivacy . PUBLIC constructor ( protected formValidatorService , protected loadingBar , protected notifier , protected authService , protected serverService , protected videoService , protected videoCaptionService , private router , private videoImportService , private 0 ) { super ( ) } ngOnInit ( ) { super . ngOnInit ( ) } canDeactivate ( ) { return { canDeactivate : true } } isMagnetUrlValid ( ) { return ! ! this . magnetUri } fileChange ( ) { const torrentfile = this . torrentfileInput . nativeElement . files [ 0 ] if ( ! torrentfile ) return this . importVideo ( torrentfile ) } importVideo ( torrentfile ? ) { this . isImportingVideo = true const videoUpdate = { privacy : this . firstStepPrivacyId , waitTranscoding : false , commentsEnabled : true , downloadEnabled : true , channelId : this . firstStepChannelId } this . loadingBar . start ( ) this . videoImportService . importVideoTorrent ( torrentfile || this . magnetUri , videoUpdate ) . subscribe ( res => { this . loadingBar . complete ( ) this . firstStepDone . emit ( res . video . name ) this . isImportingVideo = false this . hasImportedVideo = true this . video = new VideoEdit ( Object . assign ( res . video , { commentsEnabled : videoUpdate . commentsEnabled , downloadEnabled : videoUpdate . downloadEnabled , support : null , thumbnailUrl : null , previewUrl : null } ) ) this . hydrateFormFromVideo ( ) } , err => { this . loadingBar . complete ( ) this . isImportingVideo = false this . firstStepError . emit ( ) this . notifier . error ( err . message ) } ) } updateSecondStep ( ) { if ( this . checkForm ( ) === false ) { return } this . video . patch ( this . form . value ) this . isUpdatingVideo = true this . updateVideoAndCaptions ( this . video ) . subscribe ( ( ) => { this . isUpdatingVideo = false this . notifier . success ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => { this . error = err . message scrollToTop ( ) console . error ( err ) } ) } private hydrateFormFromVideo ( ) { this . form . patchValue ( this . video . toFormPatch ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $LoadingBarService$ O O $Notifier$ O O $AuthService$ O O $ServerService$ O O $VideoService$ O O $VideoCaptionService$ O O $Router$ O O $VideoImportService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Blob$ O O O O O O O O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , OnInit , Output } from 's' import { Router } from 's' import { VideoPrivacy , VideoUpdate } from 's' import { AuthService , Notifier , ServerService } from 's' import { VideoService } from 's' import { 0 } from 's' import { LoadingBarService } from 's' import { VideoSend } from 's' import { CanComponentDeactivate } from 's' import { VideoEdit } from 's' import { FormValidatorService } from 's' import { VideoCaptionService } from 's' import { VideoImportService } from 's' import { scrollToTop } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' ] } ) export class VideoImportUrlComponent extends VideoSend implements OnInit , CanComponentDeactivate { @ Output ( ) firstStepDone = new EventEmitter < string > ( ) @ Output ( ) firstStepError = new EventEmitter < void > ( ) targetUrl = 's' isImportingVideo = false hasImportedVideo = false isUpdatingVideo = false video : VideoEdit error : string protected readonly DEFAULT_VIDEO_PRIVACY = VideoPrivacy . PUBLIC constructor ( protected formValidatorService , protected loadingBar , protected notifier , protected authService , protected serverService , protected videoService , protected videoCaptionService , private router , private videoImportService , private 0 ) { super ( ) } ngOnInit ( ) { super . ngOnInit ( ) } canDeactivate ( ) { return { canDeactivate : true } } isTargetUrlValid ( ) { return this . targetUrl && this . targetUrl . match ( "s" ) } importVideo ( ) { this . isImportingVideo = true const videoUpdate = { privacy : this . firstStepPrivacyId , waitTranscoding : false , commentsEnabled : true , downloadEnabled : true , channelId : this . firstStepChannelId } this . loadingBar . start ( ) this . videoImportService . importVideoUrl ( this . targetUrl , videoUpdate ) . subscribe ( res => { this . loadingBar . complete ( ) this . firstStepDone . emit ( res . video . name ) this . isImportingVideo = false this . hasImportedVideo = true this . video = new VideoEdit ( Object . assign ( res . video , { commentsEnabled : videoUpdate . commentsEnabled , downloadEnabled : videoUpdate . downloadEnabled , support : null , thumbnailUrl : null , previewUrl : null } ) ) this . hydrateFormFromVideo ( ) } , err => { this . loadingBar . complete ( ) this . isImportingVideo = false this . firstStepError . emit ( ) this . notifier . error ( err . message ) } ) } updateSecondStep ( ) { if ( this . checkForm ( ) === false ) { return } this . video . patch ( this . form . value ) this . isUpdatingVideo = true this . updateVideoAndCaptions ( this . video ) . subscribe ( ( ) => { this . isUpdatingVideo = false this . notifier . success ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' , 's' ] ) } , err => { this . error = err . message scrollToTop ( ) console . error ( err ) } ) } private hydrateFormFromVideo ( ) { this . form . patchValue ( this . video . toFormPatch ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $LoadingBarService$ O O $Notifier$ O O $AuthService$ O O $ServerService$ O O $VideoService$ O O $VideoCaptionService$ O O $Router$ O O $VideoImportService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter , OnInit } from 's' import { LoadingBarService } from 's' import { AuthService , Notifier , ServerService } from 's' import { catchError , switchMap , tap } from 's' import { FormReactive } from 's' import { VideoConstant , VideoPrivacy } from 's' import { VideoService } from 's' import { VideoCaptionEdit } from 's' import { VideoCaptionService } from 's' import { VideoEdit } from 's' import { populateAsyncUserVideoChannels } from 's' import { CanComponentDeactivateResult } from 's' export abstract class VideoSend extends FormReactive implements OnInit { userVideoChannels : { id : number , label : string , support : string } [ ] = [ ] videoPrivacies : VideoConstant < VideoPrivacy > [ ] = [ ] videoCaptions : VideoCaptionEdit [ ] = [ ] firstStepPrivacyId = 0 firstStepChannelId = 0 abstract firstStepDone : EventEmitter < string > abstract firstStepError : EventEmitter < void > protected abstract readonly DEFAULT_VIDEO_PRIVACY : VideoPrivacy protected loadingBar : LoadingBarService protected notifier : Notifier protected authService : AuthService protected serverService : ServerService protected videoService : VideoService protected videoCaptionService : VideoCaptionService abstract canDeactivate ( ) ngOnInit ( ) { this . buildForm ( { } ) populateAsyncUserVideoChannels ( this . authService , this . userVideoChannels ) . then ( ( ) => this . firstStepChannelId = this . userVideoChannels [ 0 ] . id ) this . serverService . videoPrivaciesLoaded . subscribe ( ( ) => { this . videoPrivacies = this . serverService . getVideoPrivacies ( ) this . firstStepPrivacyId = this . DEFAULT_VIDEO_PRIVACY } ) } checkForm ( ) { this . forceCheck ( ) return this . form . valid } protected updateVideoAndCaptions ( video ) { this . loadingBar . start ( ) return this . videoService . updateVideo ( video ) . pipe ( switchMap ( ( ) => this . videoCaptionService . updateCaptions ( video . id , this . videoCaptions ) ) , tap ( ( ) => this . loadingBar . complete ( ) ) , catchError ( err => { this . loadingBar . complete ( ) throw err } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CanComponentDeactivateResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoEdit$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HttpEventType , HttpResponse } from 's' import { Component , ElementRef , EventEmitter , OnDestroy , OnInit , Output , ViewChild } from 's' import { Router } from 's' import { LoadingBarService } from 's' import { BytesPipe } from 's' import { Subscription } from 's' import { VideoPrivacy } from 's' import { AuthService , Notifier , ServerService } from 's' import { VideoEdit } from 's' import { VideoService } from 's' import { 0 } from 's' import { VideoSend } from 's' import { CanComponentDeactivate } from 's' import { FormValidatorService , UserService } from 's' import { VideoCaptionService } from 's' import { scrollToTop } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' , 's' , 's' ] } ) export class VideoUploadComponent extends VideoSend implements OnInit , OnDestroy , CanComponentDeactivate { @ Output ( ) firstStepDone = new EventEmitter < string > ( ) @ Output ( ) firstStepError = new EventEmitter < void > ( ) @ ViewChild ( 's' , { static : false } ) videofileInput : ElementRef < HTMLInputElement > readonly SPECIAL_SCHEDULED_PRIVACY = VideoEdit . SPECIAL_SCHEDULED_PRIVACY userVideoQuotaUsed = 0 userVideoQuotaUsedDaily = 0 isUploadingAudioFile = false isUploadingVideo = false isUpdatingVideo = false videoUploaded = false videoUploadObservable : Subscription = null videoUploadPercents = 0 videoUploadedIds = { id : 0 , uuid : 's' } waitTranscodingEnabled = true previewfileUpload : File error : string protected readonly DEFAULT_VIDEO_PRIVACY = VideoPrivacy . PUBLIC constructor ( protected formValidatorService , protected loadingBar , protected notifier , protected authService , protected serverService , protected videoService , protected videoCaptionService , private userService , private router , private 0 ) { super ( ) } get videoExtensions ( ) { return this . serverService . getConfig ( ) . video . file . extensions . join ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) this . userService . getMyVideoQuotaUsed ( ) . subscribe ( data => { this . userVideoQuotaUsed = data . videoQuotaUsed this . userVideoQuotaUsedDaily = data . videoQuotaUsedDaily } ) } ngOnDestroy ( ) { if ( this . videoUploadObservable ) this . videoUploadObservable . unsubscribe ( ) } canDeactivate ( ) { let text = 's' if ( this . videoUploaded === true ) { text = this . 0 ( 's' ) + 's' + this . 0 ( 's' ) } else { text = this . 0 ( 's' ) } return { canDeactivate : ! this . isUploadingVideo , text } } getVideoFile ( ) { return this . videofileInput . nativeElement . files [ 0 ] } getAudioUploadLabel ( ) { const videofile = this . getVideoFile ( ) if ( ! videofile ) return this . 0 ( 's' ) return this . 0 ( 's' , { videofileName : videofile . name } ) } fileChange ( ) { this . uploadFirstStep ( ) } cancelUpload ( ) { if ( this . videoUploadObservable !== null ) { this . videoUploadObservable . unsubscribe ( ) this . isUploadingVideo = false this . videoUploadPercents = 0 this . videoUploadObservable = null this . notifier . info ( this . 0 ( 's' ) ) } } uploadFirstStep ( clickedOnButton = false ) { const videofile = this . getVideoFile ( ) if ( ! videofile ) return if ( ! this . checkGlobalUserQuota ( videofile ) ) return if ( ! this . checkDailyUserQuota ( videofile ) ) return if ( clickedOnButton === false && this . isAudioFile ( videofile . name ) ) { this . isUploadingAudioFile = true return } const nameWithoutExtension = videofile . name . replace ( "s" , 's' ) let name if ( nameWithoutExtension . length < 0 ) name = videofile . name else name = nameWithoutExtension if ( ! videofile . name . endsWith ( 's' ) && ! videofile . name . endsWith ( 's' ) && ! videofile . name . endsWith ( 's' ) ) { this . waitTranscodingEnabled = false } const privacy = this . firstStepPrivacyId . toString ( ) const nsfw = this . serverService . getConfig ( ) . instance . isNSFW const waitTranscoding = true const commentsEnabled = true const downloadEnabled = true const channelId = this . firstStepChannelId . toString ( ) const formData = new FormData ( ) formData . append ( 's' , name ) formData . append ( 's' , VideoPrivacy . PRIVATE . toString ( ) ) formData . append ( 's' , 's' + nsfw ) formData . append ( 's' , 's' + commentsEnabled ) formData . append ( 's' , 's' + downloadEnabled ) formData . append ( 's' , 's' + waitTranscoding ) formData . append ( 's' , 's' + channelId ) formData . append ( 's' , videofile ) if ( this . previewfileUpload ) { formData . append ( 's' , this . previewfileUpload ) formData . append ( 's' , this . previewfileUpload ) } this . isUploadingVideo = true this . firstStepDone . emit ( name ) this . form . patchValue ( { name , privacy , nsfw , channelId , previewfile : this . previewfileUpload } ) this . videoUploadObservable = this . videoService . uploadVideo ( formData ) . subscribe ( event => { if ( event . type === HttpEventType . UploadProgress ) { this . videoUploadPercents = Math . round ( 0 * event . loaded / event . total ) } else if ( event instanceof HttpResponse ) { this . videoUploaded = true this . videoUploadedIds = event . body . video this . videoUploadObservable = null } } , err => { this . isUploadingVideo = false this . videoUploadPercents = 0 this . videoUploadObservable = null this . firstStepError . emit ( ) this . notifier . error ( err . message ) } ) } isPublishingButtonDisabled ( ) { return ! this . form . valid || this . isUpdatingVideo === true || this . videoUploaded !== true } updateSecondStep ( ) { if ( this . checkForm ( ) === false ) { return } const video = new VideoEdit ( ) video . patch ( this . form . value ) video . id = this . videoUploadedIds . id video . uuid = this . videoUploadedIds . uuid this . isUpdatingVideo = true this . updateVideoAndCaptions ( video ) . subscribe ( ( ) => { this . isUpdatingVideo = false this . isUploadingVideo = false this . notifier . success ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' , video . uuid ] ) } , err => { this . error = err . message scrollToTop ( ) console . error ( err ) } ) } private checkGlobalUserQuota ( videofile ) { const bytePipes = new BytesPipe ( ) const videoQuota = this . authService . getUser ( ) . videoQuota if ( videoQuota !== - 0 && ( this . userVideoQuotaUsed + videofile . size ) > videoQuota ) { const msg = this . 0 ( 's' , { videoSize : bytePipes . transform ( videofile . size , 0 ) , videoQuotaUsed : bytePipes . transform ( this . userVideoQuotaUsed , 0 ) , videoQuota : bytePipes . transform ( videoQuota , 0 ) } ) this . notifier . error ( msg ) return false } return true } private checkDailyUserQuota ( videofile ) { const bytePipes = new BytesPipe ( ) const videoQuotaDaily = this . authService . getUser ( ) . videoQuotaDaily if ( videoQuotaDaily !== - 0 && ( this . userVideoQuotaUsedDaily + videofile . size ) > videoQuotaDaily ) { const msg = this . 0 ( 's' , { videoSize : bytePipes . transform ( videofile . size , 0 ) , quotaUsedDaily : bytePipes . transform ( this . userVideoQuotaUsedDaily , 0 ) , quotaDaily : bytePipes . transform ( videoQuotaDaily , 0 ) } ) this . notifier . error ( msg ) return false } return true } private isAudioFile ( filename ) { return filename . endsWith ( 's' ) || filename . endsWith ( 's' ) || filename . endsWith ( 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $LoadingBarService$ O O $Notifier$ O O $AuthService$ O O $ServerService$ O O $VideoService$ O O $VideoCaptionService$ O O $UserService$ O O $Router$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $File$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $File$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , HostListener , ViewChild } from 's' import { CanComponentDeactivate } from 's' import { VideoImportUrlComponent } from 's' import { VideoUploadComponent } from 's' import { ServerService } from 's' import { VideoImportTorrentComponent } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoAddComponent implements CanComponentDeactivate { @ ViewChild ( 's' , { static : false } ) videoUpload : VideoUploadComponent @ ViewChild ( 's' , { static : false } ) videoImportUrl : VideoImportUrlComponent @ ViewChild ( 's' , { static : false } ) videoImportTorrent : VideoImportTorrentComponent secondStepType : 's' | 's' | 's' videoName : string constructor ( private serverService ) { } onFirstStepDone ( type : 's' | 's' | 's' , videoName ) { this . secondStepType = type this . videoName = videoName } onError ( ) { this . videoName = undefined this . secondStepType = undefined } @ HostListener ( 's' , [ 's' ] ) onUnload ( event ) { const { text , canDeactivate } = this . canDeactivate ( ) if ( canDeactivate ) return event . returnValue = text return text } canDeactivate ( ) : { canDeactivate : boolean , text ? : string } { if ( this . secondStepType === 's' ) return this . videoUpload . canDeactivate ( ) if ( this . secondStepType === 's' ) return this . videoImportUrl . canDeactivate ( ) if ( this . secondStepType === 's' ) return this . videoImportTorrent . canDeactivate ( ) return { canDeactivate : true } } isVideoImportHttpEnabled ( ) { return this . serverService . getConfig ( ) . import . videos . http . enabled } isVideoImportTorrentEnabled ( ) { return this . serverService . getConfig ( ) . import . videos . torrent . enabled } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerService$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { LoginGuard } from 's' import { CanDeactivateGuard } from 's' import { VideoAddComponent } from 's' const videoAddRoutes = [ { path : 's' , component : VideoAddComponent , canActivate : [ MetaGuard , LoginGuard ] , canDeactivate : [ CanDeactivateGuard ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( videoAddRoutes ) ] , exports : [ RouterModule ] } ) export class VideoAddRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { VideoEditModule } from 's' import { VideoAddRoutingModule } from 's' import { VideoAddComponent } from 's' import { CanDeactivateGuard } from 's' import { VideoUploadComponent } from 's' import { VideoImportUrlComponent } from 's' import { VideoImportTorrentComponent } from 's' import { ProgressBarModule } from 's' @ NgModule ( { imports : [ VideoAddRoutingModule , VideoEditModule , SharedModule , ProgressBarModule ] , declarations : [ VideoAddComponent , VideoUploadComponent , VideoImportUrlComponent , VideoImportTorrentComponent ] , exports : [ VideoAddComponent ] , providers : [ CanDeactivateGuard ] } ) export class VideoAddModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { map , switchMap } from 's' import { Component , HostListener , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { LoadingBarService } from 's' import { Notifier } from 's' import { ServerService } from 's' import { FormReactive } from 's' import { VideoEdit } from 's' import { VideoService } from 's' import { 0 } from 's' import { FormValidatorService } from 's' import { VideoCaptionService } from 's' import { VideoCaptionEdit } from 's' import { VideoDetails } from 's' import { VideoPrivacy } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoUpdateComponent extends FormReactive implements OnInit { video : VideoEdit isUpdatingVideo = false userVideoChannels : { id : number , label : string , support : string } [ ] = [ ] schedulePublicationPossible = false videoCaptions : VideoCaptionEdit [ ] = [ ] waitTranscodingEnabled = true private updateDone = false constructor ( protected formValidatorService , private route , private router , private notifier , private serverService , private videoService , private loadingBar , private videoCaptionService , private 0 ) { super ( ) } ngOnInit ( ) { this . buildForm ( { } ) this . route . data . pipe ( map ( data => data . videoData ) ) . subscribe ( ( { video , videoChannels , videoCaptions } ) => { this . video = new VideoEdit ( video ) this . userVideoChannels = videoChannels this . videoCaptions = videoCaptions this . schedulePublicationPossible = this . video . privacy === VideoPrivacy . PRIVATE const videoFiles = ( video as VideoDetails ) . files if ( videoFiles . length > 0 ) { this . waitTranscodingEnabled = false } setTimeout ( ( ) => this . hydrateFormFromVideo ( ) ) } , err => { console . error ( err ) this . notifier . error ( err . message ) } ) } @ HostListener ( 's' , [ 's' ] ) onUnload ( event ) { const { text , canDeactivate } = this . canDeactivate ( ) if ( canDeactivate ) return event . returnValue = text return text } canDeactivate ( ) : { canDeactivate : boolean , text ? : string } { if ( this . updateDone === true ) return { canDeactivate : true } const text = this . 0 ( 's' ) for ( const caption of this . videoCaptions ) { if ( caption . action ) return { canDeactivate : false , text } } return { canDeactivate : this . formChanged === false , text } } checkForm ( ) { this . forceCheck ( ) return this . form . valid } update ( ) { if ( this . checkForm ( ) === false || this . isUpdatingVideo === true ) { return } this . video . patch ( this . form . value ) this . loadingBar . start ( ) this . isUpdatingVideo = true this . videoService . updateVideo ( this . video ) . pipe ( switchMap ( ( ) => this . videoCaptionService . updateCaptions ( this . video . id , this . videoCaptions ) ) ) . subscribe ( ( ) => { this . updateDone = true this . isUpdatingVideo = false this . loadingBar . complete ( ) this . notifier . success ( this . 0 ( 's' ) ) this . router . navigate ( [ 's' , this . video . uuid ] ) } , err => { this . loadingBar . complete ( ) this . isUpdatingVideo = false this . notifier . error ( err . message ) console . error ( err ) } ) } private hydrateFormFromVideo ( ) { this . form . patchValue ( this . video . toFormPatch ( ) ) const objects = [ { url : 's' , name : 's' } , { url : 's' , name : 's' } ] for ( const obj of objects ) { fetch ( this . video [ obj . url ] ) . then ( response => response . blob ( ) ) . then ( data => { this . form . patchValue ( { [ obj . name ] : data } ) } ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $ActivatedRoute$ O O $Router$ O O $Notifier$ O O $ServerService$ O O $VideoService$ O O $LoadingBarService$ O O $VideoCaptionService$ O O $I18n$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { LoginGuard } from 's' import { VideoUpdateComponent } from 's' import { VideoUpdateResolver } from 's' import { CanDeactivateGuard } from 's' const videoUpdateRoutes = [ { path : 's' , component : VideoUpdateComponent , canActivate : [ MetaGuard , LoginGuard ] , canDeactivate : [ CanDeactivateGuard ] , resolve : { videoData : VideoUpdateResolver } } ] @ NgModule ( { imports : [ RouterModule . forChild ( videoUpdateRoutes ) ] , exports : [ RouterModule ] } ) export class VideoUpdateRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { SharedModule } from 's' import { VideoEditModule } from 's' import { VideoUpdateRoutingModule } from 's' import { VideoUpdateComponent } from 's' import { VideoUpdateResolver } from 's' import { CanDeactivateGuard } from 's' @ NgModule ( { imports : [ VideoUpdateRoutingModule , VideoEditModule , SharedModule ] , declarations : [ VideoUpdateComponent ] , exports : [ VideoUpdateComponent ] , providers : [ VideoUpdateResolver , CanDeactivateGuard ] } ) export class VideoUpdateModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { VideoService } from 's' import { ActivatedRouteSnapshot , Resolve } from 's' import { map , switchMap } from 's' import { VideoChannelService } from 's' import { VideoCaptionService } from 's' import { forkJoin } from 's' @ Injectable ( ) export class VideoUpdateResolver implements Resolve < any > { constructor ( private videoService , private videoChannelService , private videoCaptionService ) { } resolve ( route ) { const uuid = route . params [ 's' ] return this . videoService . getVideo ( { videoId : uuid } ) . pipe ( switchMap ( video => { return forkJoin ( [ this . videoService . loadCompleteDescription ( video . descriptionPath ) . pipe ( map ( description => Object . assign ( video , { description } ) ) ) , this . videoChannelService . listAccountVideoChannels ( video . account ) . pipe ( map ( result => result . data ) , map ( videoChannels => videoChannels . map ( c => ( { id : c . id , label : c . displayName , support : c . support } ) ) ) ) , this . videoCaptionService . listCaptions ( video . id ) . pipe ( map ( result => result . data ) ) ] ) } ) , map ( ( [ video , videoChannels , videoCaptions ] ) => ( { video , videoChannels , videoCaptions } ) ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoService$ O O $VideoChannelService$ O O $VideoCaptionService$ O O O O O $ActivatedRouteSnapshot$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Account } from 's' export interface VideoComment { id : number url : string text : string threadId : number inReplyToCommentId : number videoId : number createdAt : Date | string updatedAt : Date | string totalReplies : number account : Account } export interface VideoCommentThreadTree { comment : VideoComment children : VideoCommentThreadTree [ ] } export interface VideoCommentCreate { text : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Account as AccountInterface } from 's' import { VideoComment as VideoCommentServerModel } from 's' import { Actor } from 's' import { getAbsoluteAPIUrl } from 's' export class VideoComment implements VideoCommentServerModel { id : number url : string text : string threadId : number inReplyToCommentId : number videoId : number createdAt : Date | string updatedAt : Date | string account : AccountInterface totalReplies : number by : string accountAvatarUrl : string isLocal : boolean constructor ( hash ) { this . id = hash . id this . url = hash . url this . text = hash . text this . threadId = hash . threadId this . inReplyToCommentId = hash . inReplyToCommentId this . videoId = hash . videoId this . createdAt = new Date ( hash . createdAt . toString ( ) ) this . updatedAt = new Date ( hash . updatedAt . toString ( ) ) this . account = hash . account this . totalReplies = hash . totalReplies this . by = Actor . CREATE_BY_STRING ( this . account . name , this . account . host ) this . accountAvatarUrl = Actor . GET_ACTOR_AVATAR_URL ( this . account ) const absoluteAPIUrl = getAbsoluteAPIUrl ( ) const thisHost = new URL ( absoluteAPIUrl ) . host this . isLocal = this . account . host . trim ( ) === thisHost } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentServerModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError , map } from 's' import { HttpClient , HttpParams } from 's' import { Injectable } from 's' import { objectLineFeedToHtml } from 's' import { Observable } from 's' import { ResultList , FeedFormat } from 's' import { VideoComment as VideoCommentServerModel , VideoCommentCreate , VideoCommentThreadTree } from 's' import { environment } from 's' import { RestExtractor , RestService } from 's' import { ComponentPagination } from 's' import { VideoSortField } from 's' import { VideoComment } from 's' @ Injectable ( ) export class VideoCommentService { private static BASE_VIDEO_URL = environment . apiUrl + 's' private static BASE_FEEDS_URL = environment . apiUrl + 's' constructor ( private authHttp , private restExtractor , private restService ) { } addCommentThread ( videoId : number | string , comment ) { const url = VideoCommentService . BASE_VIDEO_URL + videoId + 's' const normalizedComment = objectLineFeedToHtml ( comment , 's' ) return this . authHttp . post < { comment : VideoCommentServerModel } > ( url , normalizedComment ) . pipe ( map ( data => this . extractVideoComment ( data . comment ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } addCommentReply ( videoId : number | string , inReplyToCommentId , comment ) { const url = VideoCommentService . BASE_VIDEO_URL + videoId + 's' + inReplyToCommentId const normalizedComment = objectLineFeedToHtml ( comment , 's' ) return this . authHttp . post < { comment : VideoCommentServerModel } > ( url , normalizedComment ) . pipe ( map ( data => this . extractVideoComment ( data . comment ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideoCommentThreads ( parameters : { videoId : number | string , componentPagination : ComponentPagination , sort : VideoSortField } ) < ResultList < VideoComment > > { const { videoId , componentPagination , sort } = parameters const pagination = this . restService . componentPaginationToRestPagination ( componentPagination ) let params = new HttpParams ( ) params = this . restService . addRestGetParams ( params , pagination , sort ) const url = VideoCommentService . BASE_VIDEO_URL + videoId + 's' return this . authHttp . get < ResultList < VideoComment > > ( url , { params } ) . pipe ( map ( result => this . extractVideoComments ( result ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideoThreadComments ( parameters : { videoId : number | string , threadId : number } ) < VideoCommentThreadTree > { const { videoId , threadId } = parameters const url = `template` return this . authHttp . get ( url ) . pipe ( map ( tree => this . extractVideoCommentTree ( tree as VideoCommentThreadTree ) ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } deleteVideoComment ( videoId : number | string , commentId ) { const url = `template` return this . authHttp . delete ( url ) . pipe ( map ( this . restExtractor . extractDataBool ) , catchError ( err => this . restExtractor . handleError ( err ) ) ) } getVideoCommentsFeeds ( videoUUID ? ) { const feeds = [ { format : FeedFormat . RSS , label : 's' , url : VideoCommentService . BASE_FEEDS_URL + FeedFormat . RSS . toLowerCase ( ) } , { format : FeedFormat . ATOM , label : 's' , url : VideoCommentService . BASE_FEEDS_URL + FeedFormat . ATOM . toLowerCase ( ) } , { format : FeedFormat . JSON , label : 's' , url : VideoCommentService . BASE_FEEDS_URL + FeedFormat . JSON . toLowerCase ( ) } ] if ( videoUUID !== undefined ) { for ( const feed of feeds ) { feed . url += 's' + videoUUID } } return feeds } private extractVideoComment ( videoComment ) { return new VideoComment ( videoComment ) } private extractVideoComments ( result < VideoCommentServerModel > ) { const videoCommentsJson = result . data const totalComments = result . total const comments : VideoComment [ ] = [ ] for ( const videoCommentJson of videoCommentsJson ) { comments . push ( new VideoComment ( videoCommentJson ) ) } return { data : comments , total : totalComments } } private extractVideoCommentTree ( tree ) { if ( ! tree ) return tree tree . comment = new VideoComment ( tree . comment ) tree . children . forEach ( c => this . extractVideoCommentTree ( c ) ) return tree } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpClient$ O O $RestExtractor$ O O $RestService$ O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentServerModel$ O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , EventEmitter , Input , OnInit , Output , ViewChild } from 's' import { Router } from 's' import { Notifier } from 's' import { Observable } from 's' import { VideoCommentCreate } from 's' import { FormReactive } from 's' import { User } from 's' import { Video } from 's' import { VideoComment } from 's' import { VideoCommentService } from 's' import { FormValidatorService } from 's' import { VideoCommentValidatorsService } from 's' import { NgbModal } from 's' import { AuthService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoCommentAddComponent extends FormReactive implements OnInit { @ Input ( ) user : User @ Input ( ) video : Video @ Input ( ) parentComment : VideoComment @ Input ( ) parentComments : VideoComment [ ] @ Input ( ) focusOnInit = false @ Output ( ) commentCreated = new EventEmitter < VideoCommentCreate > ( ) @ ViewChild ( 's' , { static : true } ) visitorModal : NgbModal @ ViewChild ( 's' , { static : true } ) textareaElement : ElementRef addingComment = false constructor ( protected formValidatorService , private videoCommentValidatorsService , private notifier , private videoCommentService , private authService , private modalService , private router ) { super ( ) } ngOnInit ( ) { this . buildForm ( { text : this . videoCommentValidatorsService . VIDEO_COMMENT_TEXT } ) if ( this . user ) { if ( this . focusOnInit === true ) { this . textareaElement . nativeElement . focus ( ) } if ( this . parentComment ) { const mentions = this . parentComments . filter ( c => c . account . id !== this . user . account . id ) . map ( c => 's' + c . by ) const mentionsSet = new Set ( mentions ) const mentionsText = Array . from ( mentionsSet ) . join ( 's' ) + 's' this . form . patchValue ( { text : mentionsText } ) } } } onValidKey ( ) { this . check ( ) if ( ! this . form . valid ) return this . formValidated ( ) } openVisitorModal ( event ) { if ( this . user === null ) { event . srcElement . blur ( ) event . preventDefault ( ) this . modalService . open ( this . visitorModal ) } } hideVisitorModal ( ) { this . modalService . dismissAll ( ) } formValidated ( ) { if ( this . addingComment ) return this . addingComment = true const commentCreate = this . form . value let obs < any > if ( this . parentComment ) { obs = this . addCommentReply ( commentCreate ) } else { obs = this . addCommentThread ( commentCreate ) } obs . subscribe ( comment => { this . addingComment = false this . commentCreated . emit ( comment ) this . form . reset ( ) } , err => { this . addingComment = false this . notifier . error ( err . text ) } ) } isAddButtonDisplayed ( ) { return this . form . value [ 's' ] } getUri ( ) { return window . location . href } getAvatarUrl ( ) { if ( this . user ) return this . user . accountAvatarUrl return window . location . origin + 's' } gotoLogin ( ) { this . hideVisitorModal ( ) this . router . navigate ( [ 's' ] ) } private addCommentReply ( commentCreate ) { return this . videoCommentService . addCommentReply ( this . video . id , this . parentComment . id , commentCreate ) } private addCommentThread ( commentCreate ) { return this . videoCommentService . addCommentThread ( this . video . id , commentCreate ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormValidatorService$ O O $VideoCommentValidatorsService$ O O $Notifier$ O O $VideoCommentService$ O O $AuthService$ O O $NgbModal$ O O $Router$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O
import { Component , EventEmitter , Input , OnChanges , OnInit , Output } from 's' import { UserRight } from 's' import { VideoCommentThreadTree } from 's' import { AuthService } from 's' import { Video } from 's' import { VideoComment } from 's' import { HtmlRendererService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoCommentComponent implements OnInit , OnChanges { @ Input ( ) video : Video @ Input ( ) comment : VideoComment @ Input ( ) parentComments : VideoComment [ ] = [ ] @ Input ( ) commentTree : VideoCommentThreadTree @ Input ( ) inReplyToCommentId : number @ Input ( ) highlightedComment = false @ Output ( ) wantedToDelete = new EventEmitter < VideoComment > ( ) @ Output ( ) wantedToReply = new EventEmitter < VideoComment > ( ) @ Output ( ) threadCreated = new EventEmitter < VideoCommentThreadTree > ( ) @ Output ( ) resetReply = new EventEmitter ( ) sanitizedCommentHTML = 's' newParentComments : VideoComment [ ] = [ ] constructor ( private htmlRenderer , private authService ) { } get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . init ( ) } ngOnChanges ( ) { this . init ( ) } onCommentReplyCreated ( createdComment ) { if ( ! this . commentTree ) { this . commentTree = { comment : this . comment , children : [ ] } this . threadCreated . emit ( this . commentTree ) } this . commentTree . children . unshift ( { comment : createdComment , children : [ ] } ) this . resetReply . emit ( ) } onWantToReply ( comment ? ) { this . wantedToReply . emit ( comment || this . comment ) } onWantToDelete ( comment ? ) { this . wantedToDelete . emit ( comment || this . comment ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } onResetReply ( ) { this . resetReply . emit ( ) } isRemovableByUser ( ) { return this . isUserLoggedIn ( ) && ( this . user . account . id === this . comment . account . id || this . user . hasRight ( UserRight . REMOVE_ANY_VIDEO_COMMENT ) ) } private async init ( ) { this . sanitizedCommentHTML = await this . htmlRenderer . toSafeHtml ( this . comment . text ) this . newParentComments = this . parentComments . concat ( [ this . comment ] ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HtmlRendererService$ O O $AuthService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , Input , OnChanges , OnDestroy , OnInit , SimpleChanges , ViewChild } from 's' import { ActivatedRoute } from 's' import { ConfirmService , Notifier } from 's' import { Subject , Subscription } from 's' import { VideoCommentThreadTree } from 's' import { AuthService } from 's' import { ComponentPagination , hasMoreItems } from 's' import { User } from 's' import { VideoSortField } from 's' import { VideoDetails } from 's' import { VideoComment } from 's' import { VideoCommentService } from 's' import { 0 } from 's' import { Syndication } from 's' import { HooksService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoCommentsComponent implements OnInit , OnChanges , OnDestroy { @ ViewChild ( 's' , { static : false } ) commentHighlightBlock : ElementRef @ Input ( ) video : VideoDetails @ Input ( ) user : User comments : VideoComment [ ] = [ ] highlightedThread : VideoComment sort : VideoSortField = 's' componentPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } inReplyToCommentId : number threadComments : { [ id ] : VideoCommentThreadTree } = { } threadLoading : { [ id ] : boolean } = { } syndicationItems : Syndication [ ] = [ ] onDataSubject = new Subject < any [ ] > ( ) private sub : Subscription constructor ( private authService , private notifier , private confirmService , private videoCommentService , private activatedRoute , private 0 , private hooks ) { } ngOnInit ( ) { this . sub = this . activatedRoute . params . subscribe ( params => { if ( params [ 's' ] ) { const highlightedThreadId = + params [ 's' ] this . processHighlightedThread ( highlightedThreadId ) } } ) } ngOnChanges ( changes ) { if ( changes [ 's' ] ) { this . resetVideo ( ) } } ngOnDestroy ( ) { if ( this . sub ) this . sub . unsubscribe ( ) } viewReplies ( commentId , highlightThread = false ) { this . threadLoading [ commentId ] = true const params = { videoId : this . video . id , threadId : commentId } const obs = this . hooks . wrapObsFun ( this . videoCommentService . getVideoThreadComments . bind ( this . videoCommentService ) , params , 's' , 's' , 's' ) obs . subscribe ( res => { this . threadComments [ commentId ] = res this . threadLoading [ commentId ] = false if ( highlightThread ) { this . highlightedThread = new VideoComment ( res . comment ) setTimeout ( ( ) => this . commentHighlightBlock . nativeElement . scrollIntoView ( ) , 0 ) } } , err => this . notifier . error ( err . message ) ) } loadMoreThreads ( ) { const params = { videoId : this . video . id , componentPagination : this . componentPagination , sort : this . sort } const obs = this . hooks . wrapObsFun ( this . videoCommentService . getVideoCommentThreads . bind ( this . videoCommentService ) , params , 's' , 's' , 's' ) obs . subscribe ( res => { this . comments = this . comments . concat ( res . data ) this . componentPagination . totalItems = res . total this . onDataSubject . next ( res . data ) } , err => this . notifier . error ( err . message ) ) } onCommentThreadCreated ( comment ) { this . comments . unshift ( comment ) } onWantedToReply ( comment ) { this . inReplyToCommentId = comment . id } onResetReply ( ) { this . inReplyToCommentId = undefined } onThreadCreated ( commentTree ) { this . viewReplies ( commentTree . comment . id ) } async onWantedToDelete ( commentToDelete ) { let message = 's' if ( commentToDelete . totalReplies !== 0 ) { message += this . 0 ( 's' , { totalReplies : commentToDelete . totalReplies } ) } if ( commentToDelete . isLocal ) { message += this . 0 ( 's' ) } else { message += this . 0 ( 's' ) } const res = await this . confirmService . confirm ( message , this . 0 ( 's' ) ) if ( res === false ) return this . videoCommentService . deleteVideoComment ( commentToDelete . videoId , commentToDelete . id ) . subscribe ( ( ) => { if ( commentToDelete . inReplyToCommentId ) { const thread = this . threadComments [ commentToDelete . threadId ] if ( ! thread ) { console . error ( `template` ) return } this . deleteLocalCommentThread ( thread , commentToDelete ) return } this . comments = this . comments . filter ( c => c . id !== commentToDelete . id ) this . componentPagination . totalItems -- if ( this . highlightedThread . id === commentToDelete . id ) this . highlightedThread = undefined } , err => this . notifier . error ( err . message ) ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } onNearOfBottom ( ) { this . componentPagination . currentPage ++ if ( hasMoreItems ( this . componentPagination ) ) { this . loadMoreThreads ( ) } } private deleteLocalCommentThread ( parentComment , commentToDelete ) { for ( const commentChild of parentComment . children ) { if ( commentChild . comment . id === commentToDelete . id ) { parentComment . children = parentComment . children . filter ( c => c . comment . id !== commentToDelete . id ) return } this . deleteLocalCommentThread ( commentChild , commentToDelete ) } } private resetVideo ( ) { if ( this . video . commentsEnabled === true ) { this . highlightedThread = null this . comments = [ ] this . threadComments = { } this . threadLoading = { } this . inReplyToCommentId = undefined this . componentPagination . currentPage = 0 this . componentPagination . totalItems = null this . syndicationItems = this . videoCommentService . getVideoCommentsFeeds ( this . video . uuid ) this . loadMoreThreads ( ) } } private processHighlightedThread ( highlightedThreadId ) { this . highlightedThread = this . comments . find ( c => c . id === highlightedThreadId ) const highlightThread = true this . viewReplies ( highlightedThreadId , highlightThread ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $Notifier$ O O $ConfirmService$ O O $VideoCommentService$ O O $ActivatedRoute$ O O $I18n$ O O $HooksService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimpleChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , ElementRef , Input , ViewChild } from 's' import { Notifier } from 's' import { VideoDetails } from 's' import { buildVideoEmbed , buildVideoLink } from 's' import { 0 } from 's' import { NgbModal , NgbTabChangeEvent } from 's' import { VideoCaption } from 's' type Customizations = { startAtCheckbox : boolean startAt : number stopAtCheckbox : boolean stopAt : number subtitleCheckbox : boolean subtitle : string loop : boolean autoplay : boolean muted : boolean title : boolean warningTitle : boolean controls : boolean } @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoShareComponent { @ ViewChild ( 's' , { static : true } ) modal : ElementRef @ Input ( ) video : VideoDetails = null @ Input ( ) videoCaptions : VideoCaption [ ] = [ ] activeId : 's' | 's' | 's' customizations : Customizations isAdvancedCustomizationCollapsed = true private currentVideoTimestamp : number constructor ( private modalService , private notifier , private 0 ) { } show ( currentVideoTimestamp ? ) { this . currentVideoTimestamp = currentVideoTimestamp let subtitle if ( this . videoCaptions . length !== 0 ) { subtitle = this . videoCaptions [ 0 ] . language . id } this . customizations = { startAtCheckbox : false , startAt : currentVideoTimestamp ? Math . floor ( currentVideoTimestamp ) : 0 , stopAtCheckbox : false , stopAt : this . video . duration , subtitleCheckbox : false , subtitle , loop : false , autoplay : false , muted : false , title : true , warningTitle : true , controls : true } this . modalService . open ( this . modal ) } getVideoIframeCode ( ) { const options = this . getOptions ( this . video . embedUrl ) const embedUrl = buildVideoLink ( options ) return buildVideoEmbed ( embedUrl ) } getVideoUrl ( ) { const options = this . getOptions ( ) return buildVideoLink ( options ) } notSecure ( ) { return window . location . protocol === 's' } activateCopiedMessage ( ) { this . notifier . success ( this . 0 ( 's' ) ) } onTabChange ( event ) { this . activeId = event . nextId as any } isInEmbedTab ( ) { return this . activeId === 's' } private getOptions ( baseUrl ? ) { return { baseUrl , startTime : this . customizations . startAtCheckbox ? this . customizations . startAt : undefined , stopTime : this . customizations . stopAtCheckbox ? this . customizations . stopAt : undefined , subtitle : this . customizations . subtitleCheckbox ? this . customizations . subtitle : undefined , loop : this . customizations . loop , autoplay : this . customizations . autoplay , muted : this . customizations . muted , title : this . customizations . title , warningTitle : this . customizations . warningTitle , controls : this . customizations . controls } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbModal$ O O $Notifier$ O O $I18n$ O O O O O O $number$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbTabChangeEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , ViewChild } from 's' import { VideoDetails } from 's' import { NgbModal } from 's' import { MarkdownService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoSupportComponent { @ Input ( ) video : VideoDetails = null @ ViewChild ( 's' , { static : true } ) modal : NgbModal videoHTMLSupport = 's' constructor ( private markdownService , private modalService ) { } show ( ) { this . modalService . open ( this . modal ) this . markdownService . enhancedMarkdownToHTML ( this . video . support ) . then ( r => this . videoHTMLSupport = r ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MarkdownService$ O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { VideoPlaylist } from 's' import { ComponentPagination } from 's' import { VideoDetails , VideoPlaylistPrivacy } from 's' import { Router } from 's' import { AuthService } from 's' import { VideoPlaylistService } from 's' import { VideoPlaylistElement } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoWatchPlaylistComponent { @ Input ( ) video : VideoDetails @ Input ( ) playlist : VideoPlaylist playlistElements : VideoPlaylistElement [ ] = [ ] playlistPagination : ComponentPagination = { currentPage : 0 , itemsPerPage : 0 , totalItems : null } noPlaylistVideos = false currentPlaylistPosition = 0 constructor ( private auth , private videoPlaylist , private router ) { } onPlaylistVideosNearOfBottom ( ) { if ( this . playlistPagination . totalItems <= ( this . playlistPagination . currentPage * this . playlistPagination . itemsPerPage ) ) return this . playlistPagination . currentPage += 0 this . loadPlaylistElements ( this . playlist , false ) } onElementRemoved ( playlistElement ) { this . playlistElements = this . playlistElements . filter ( e => e . id !== playlistElement . id ) this . playlistPagination . totalItems -- } isPlaylistOwned ( ) { return this . playlist . isLocal === true && this . auth . isLoggedIn ( ) && this . playlist . ownerAccount . name === this . auth . getUser ( ) . username } isUnlistedPlaylist ( ) { return this . playlist . privacy . id === VideoPlaylistPrivacy . UNLISTED } isPrivatePlaylist ( ) { return this . playlist . privacy . id === VideoPlaylistPrivacy . PRIVATE } isPublicPlaylist ( ) { return this . playlist . privacy . id === VideoPlaylistPrivacy . PUBLIC } loadPlaylistElements ( playlist , redirectToFirst = false ) { this . videoPlaylist . getPlaylistVideos ( playlist . uuid , this . playlistPagination ) . subscribe ( ( { total , data } ) => { this . playlistElements = this . playlistElements . concat ( data ) this . playlistPagination . totalItems = total const firstAvailableVideos = this . playlistElements . find ( e => ! ! e . video ) if ( ! firstAvailableVideos ) { this . noPlaylistVideos = true return } this . updatePlaylistIndex ( this . video ) if ( redirectToFirst ) { const extras = { queryParams : { videoId : firstAvailableVideos . video . uuid } , replaceUrl : true } this . router . navigate ( [ ] , extras ) } } ) } updatePlaylistIndex ( video ) { if ( this . playlistElements . length === 0 || ! video ) return for ( const playlistElement of this . playlistElements ) { if ( playlistElement . video && playlistElement . video . id === video . id ) { this . currentPlaylistPosition = playlistElement . position return } } this . onPlaylistVideosNearOfBottom ( ) } navigateToNextPlaylistVideo ( ) { if ( this . currentPlaylistPosition < this . playlistPagination . totalItems ) { const next = this . playlistElements . find ( e => e . position === this . currentPlaylistPosition + 0 ) if ( ! next || ! next . video ) { this . currentPlaylistPosition ++ this . navigateToNextPlaylistVideo ( ) return } const start = next . startTimestamp const stop = next . stopTimestamp this . router . navigate ( [ ] , { queryParams : { videoId : next . video . uuid , start , stop } } ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AuthService$ O O $VideoPlaylistService$ O O $Router$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const MediaElementWrapper = require ( 's' ) import { extname } from 's' const videostream = require ( 's' ) const VIDEOSTREAM_EXTS = [ 's' , 's' , 's' ] type RenderMediaOptions = { controls : boolean autoplay : boolean } function renderVideo ( file , elem , opts , callback : ( err , renderer ) => void ) { validateFile ( file ) return renderMedia ( file , elem , opts , callback ) } function renderMedia ( file , elem , opts , callback : ( err , renderer ? ) => void ) { const extension = extname ( file . name ) . toLowerCase ( ) let preparedElem let currentTime = 0 let renderer try { if ( VIDEOSTREAM_EXTS . indexOf ( extension ) >= 0 ) { renderer = useVideostream ( ) } else { renderer = useMediaSource ( ) } } catch ( err ) { return callback ( err ) } function useVideostream ( ) { prepareElem ( ) preparedElem . addEventListener ( 's' , function onError ( err ) { preparedElem . removeEventListener ( 's' , onError ) return callback ( err ) } ) preparedElem . addEventListener ( 's' , onLoadStart ) return new videostream ( file , preparedElem ) } function useMediaSource ( 0 = false ) { const codecs = getCodec ( file . name , 0 ) prepareElem ( ) preparedElem . addEventListener ( 's' , function onError ( err ) { preparedElem . removeEventListener ( 's' , onError ) if ( codecs . indexOf ( 's' ) !== - 0 ) return fallbackToMediaSource ( true ) return callback ( err ) } ) preparedElem . addEventListener ( 's' , onLoadStart ) const wrapper = new MediaElementWrapper ( preparedElem ) const writable = wrapper . createWriteStream ( codecs ) file . createReadStream ( ) . pipe ( writable ) if ( currentTime ) preparedElem . currentTime = currentTime return wrapper } function fallbackToMediaSource ( 0 = false ) { if ( 0 === true ) console . log ( 's' ) else console . log ( 's' ) useMediaSource ( 0 ) } function prepareElem ( ) { if ( preparedElem === undefined ) { preparedElem = elem preparedElem . addEventListener ( 's' , function ( ) { currentTime = elem . currentTime } ) } } function onLoadStart ( ) { preparedElem . removeEventListener ( 's' , onLoadStart ) if ( opts . autoplay ) preparedElem . play ( ) callback ( null , renderer ) } } function validateFile ( file ) { if ( file == null ) { throw new Error ( 's' ) } if ( typeof file . name !== 's' ) { throw new Error ( 's' ) } if ( typeof file . createReadStream !== 's' ) { throw new Error ( 's' ) } } function getCodec ( name , 0 = false ) { const ext = extname ( name ) . toLowerCase ( ) if ( ext === 's' ) { return 's' } if ( ext === 's' ) { if ( 0 === true ) return 's' return 's' } return undefined } export { renderVideo }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $HTMLVideoElement$ O $RenderMediaOptions$ O O O O $Error$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $HTMLVideoElement$ O $RenderMediaOptions$ O O O O $Error$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' import Dexie from 's' class ChunkDatabase extends Dexie { chunks : Dexie . Table < { id : number , buf : Buffer } , number > constructor ( dbname ) { super ( dbname ) this . version ( 0 ) . stores ( { chunks : 's' } ) } } class ExpirationDatabase extends Dexie { databases : Dexie . Table < { name : string , expiration : number } , number > constructor ( ) { super ( 's' ) this . version ( 0 ) . stores ( { databases : 's' } ) } } export class PeertubeChunkStore extends EventEmitter { private static readonly BUFFERING_PUT_MS = 0 private static readonly CLEANER_INTERVAL_MS = 0 * 0 private static readonly CLEANER_EXPIRATION_MS = 0 * 0 * 0 chunkLength : number private pendingPut : { id : number , buf : Buffer , cb : Function } [ ] = [ ] private memoryChunks : { [ id ] : Buffer | true } = { } private databaseName : string private putBulkTimeout : any private cleanerInterval : any private db : ChunkDatabase private expirationDB : ExpirationDatabase private readonly length : number private readonly lastChunkLength : number private readonly lastChunkIndex : number constructor ( chunkLength , opts ) { super ( ) this . databaseName = 's' if ( ! opts ) opts = { } if ( opts . torrent && opts . torrent . infoHash ) this . databaseName += opts . torrent . infoHash else this . databaseName += 's' this . setMaxListeners ( 0 ) this . chunkLength = Number ( chunkLength ) if ( ! this . chunkLength ) throw new Error ( 's' ) this . length = Number ( opts . length ) || Infinity if ( this . length !== Infinity ) { this . lastChunkLength = ( this . length % this . chunkLength ) || this . chunkLength this . lastChunkIndex = Math . ceil ( this . length / this . chunkLength ) - 0 } this . db = new ChunkDatabase ( this . databaseName ) this . expirationDB = new ExpirationDatabase ( ) this . runCleaner ( ) } put ( index , buf , cb : ( err ? ) => void ) { const isLastChunk = ( index === this . lastChunkIndex ) if ( isLastChunk && buf . length !== this . lastChunkLength ) { return this . nextTick ( cb , new Error ( 's' + this . lastChunkLength ) ) } if ( ! isLastChunk && buf . length !== this . chunkLength ) { return this . nextTick ( cb , new Error ( 's' + this . chunkLength ) ) } this . memoryChunks [ index ] = true this . pendingPut . push ( { id : index , buf , cb } ) if ( this . putBulkTimeout ) return this . putBulkTimeout = setTimeout ( async ( ) => { const processing = this . pendingPut this . pendingPut = [ ] this . putBulkTimeout = undefined try { await this . db . transaction ( 's' , this . db . chunks , ( ) => { return this . db . chunks . bulkPut ( processing . map ( p => ( { id : p . id , buf : p . buf } ) ) ) } ) } catch ( err ) { console . log ( 's' , { err } ) processing . forEach ( p => this . memoryChunks [ p . id ] = p . buf ) } finally { processing . forEach ( p => p . cb ( ) ) } } , PeertubeChunkStore . BUFFERING_PUT_MS ) } get ( index , opts , cb : ( err ? , buf ? ) => void ) { if ( typeof opts === 's' ) return this . get ( index , null , opts ) const memoryChunk = this . memoryChunks [ index ] if ( memoryChunk === undefined ) { const err = new Error ( 's' ) as any err [ 's' ] = true return process . nextTick ( ( ) => cb ( err ) ) } if ( memoryChunk !== true ) return cb ( null , memoryChunk ) this . db . transaction ( 's' , this . db . chunks , async ( ) => { const result = await this . db . chunks . get ( { id : index } ) if ( result === undefined ) return cb ( null , Buffer . alloc ( 0 ) ) const buf = result . buf if ( ! opts ) return this . nextTick ( cb , null , buf ) const offset = opts . offset || 0 const len = opts . length || ( buf . length - offset ) return cb ( null , buf . slice ( offset , len + offset ) ) } ) . catch ( err => { console . error ( err ) return cb ( err ) } ) } close ( cb : ( err ? ) => void ) { return this . destroy ( cb ) } async destroy ( cb : ( err ? ) => void ) { try { if ( this . pendingPut ) { clearTimeout ( this . putBulkTimeout ) this . pendingPut = null } if ( this . cleanerInterval ) { clearInterval ( this . cleanerInterval ) this . cleanerInterval = null } if ( this . db ) { this . db . close ( ) await this . dropDatabase ( this . databaseName ) } if ( this . expirationDB ) { this . expirationDB . close ( ) this . expirationDB = null } return cb ( ) } catch ( err ) { console . error ( 's' , err ) return cb ( err ) } } private runCleaner ( ) { this . checkExpiration ( ) this . cleanerInterval = setInterval ( async ( ) => { this . checkExpiration ( ) } , PeertubeChunkStore . CLEANER_INTERVAL_MS ) } private async checkExpiration ( ) { let databasesToDeleteInfo : { name : string } [ ] = [ ] try { await this . expirationDB . transaction ( 's' , this . expirationDB . databases , async ( ) => { await this . expirationDB . databases . put ( { name : this . databaseName , expiration : new Date ( ) . getTime ( ) + PeertubeChunkStore . CLEANER_EXPIRATION_MS } ) const now = new Date ( ) . getTime ( ) databasesToDeleteInfo = await this . expirationDB . databases . where ( 's' ) . below ( now ) . toArray ( ) } ) } catch ( err ) { console . error ( 's' , err ) } for ( const databaseToDeleteInfo of databasesToDeleteInfo ) { await this . dropDatabase ( databaseToDeleteInfo . name ) } } private async dropDatabase ( databaseName ) { const dbToDelete = new ChunkDatabase ( databaseName ) console . log ( 's' , databaseName ) try { await dbToDelete . delete ( ) await this . expirationDB . transaction ( 's' , this . expirationDB . databases , ( ) => { return this . expirationDB . databases . where ( { name : databaseName } ) . delete ( ) } ) } catch ( err ) { console . error ( 's' , databaseName , err ) } } private nextTick < T > ( cb : ( err ? , val ? : T ) => void , err , val ? : T ) { process . nextTick ( ( ) => cb ( err , val ) , undefined ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Buffer$ O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O $any$ O O O O O $Error$ O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O
function getStoredVolume ( ) { const value = getLocalStorage ( 's' ) if ( value !== null && value !== undefined ) { const valueNumber = parseFloat ( value ) if ( isNaN ( valueNumber ) ) return undefined return valueNumber } return undefined } function getStoredWebTorrentEnabled ( ) { const value = getLocalStorage ( 's' ) if ( value !== null && value !== undefined ) return value === 's' return true } function getStoredMute ( ) { const value = getLocalStorage ( 's' ) if ( value !== null && value !== undefined ) return value === 's' return undefined } function getStoredTheater ( ) { const value = getLocalStorage ( 's' ) if ( value !== null && value !== undefined ) return value === 's' return false } function saveVolumeInStore ( value ) { return setLocalStorage ( 's' , value . toString ( ) ) } function saveMuteInStore ( value ) { return setLocalStorage ( 's' , value . toString ( ) ) } function saveTheaterInStore ( enabled ) { return setLocalStorage ( 's' , enabled . toString ( ) ) } function saveAverageBandwidth ( value ) { return setLocalStorage ( 's' , value . toString ( ) ) } function getAverageBandwidthInStore ( ) { const value = getLocalStorage ( 's' ) if ( value !== null && value !== undefined ) { const valueNumber = parseInt ( value , 0 ) if ( isNaN ( valueNumber ) ) return undefined return valueNumber } return undefined } function saveLastSubtitle ( language ) { return setLocalStorage ( 's' , language ) } function getStoredLastSubtitle ( ) { return getLocalStorage ( 's' ) } export { getStoredVolume , getStoredWebTorrentEnabled , getStoredMute , getStoredTheater , saveVolumeInStore , saveMuteInStore , saveTheaterInStore , saveAverageBandwidth , getAverageBandwidthInStore , saveLastSubtitle , getStoredLastSubtitle } const KEY_PREFIX = 's' function getLocalStorage ( key ) { try { return localStorage . getItem ( KEY_PREFIX + key ) } catch { return undefined } } function setLocalStorage ( key , value ) { try { localStorage . setItem ( KEY_PREFIX + key , value ) } catch { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import * as WebTorrent from 's' import { VideoFile } from 's' import { renderVideo } from 's' import { LoadedQualityData , PlayerNetworkInfo , VideoJSComponentInterface , WebtorrentPluginOptions } from 's' import { getRtcConfig , timeToInt , videoFileMaxByResolution , videoFileMinByResolution } from 's' import { PeertubeChunkStore } from 's' import { getAverageBandwidthInStore , getStoredMute , getStoredVolume , getStoredWebTorrentEnabled , saveAverageBandwidth } from 's' const CacheChunkStore = require ( 's' ) type PlayOptions = { forcePlay ? : boolean , seek ? : number , delay ? : number } const Plugin = videojs . getPlugin ( 's' ) class WebTorrentPlugin extends Plugin { private readonly playerElement : HTMLVideoElement private readonly autoplay : boolean = false private readonly startTime : number = 0 private readonly savePlayerSrcFunction : Function private readonly videoFiles : VideoFile [ ] private readonly videoDuration : number private readonly CONSTANTS = { INFO_SCHEDULER : 0 , AUTO_QUALITY_SCHEDULER : 0 , AUTO_QUALITY_THRESHOLD_PERCENT : 0 , AUTO_QUALITY_OBSERVATION_TIME : 0 , AUTO_QUALITY_HIGHER_RESOLUTION_DELAY : 0 , BANDWIDTH_AVERAGE_NUMBER_OF_VALUES : 0 } private readonly webtorrent = new WebTorrent ( { tracker : { rtcConfig : getRtcConfig ( ) } , dht : false } ) private player : any private currentVideoFile : VideoFile private torrent : WebTorrent . Torrent private renderer : any private fakeRenderer : any private destroyingFakeRenderer = false private autoResolution = true private autoResolutionPossible = true private isAutoResolutionObservation = false private 0 = false private torrentInfoInterval : any private autoQualityInterval : any private addTorrentDelay : any private qualityObservationTimer : any private runAutoQualitySchedulerTimer : any private downloadSpeeds : number [ ] = [ ] constructor ( player : videojs . Player , options ) { super ( player , options ) this . startTime = timeToInt ( options . startTime ) this . autoplay = options . autoplay && this . isIOS ( ) === false this . 0 = ! getStoredWebTorrentEnabled ( ) this . videoFiles = options . videoFiles this . videoDuration = options . videoDuration this . savePlayerSrcFunction = this . player . src this . playerElement = options . playerElement this . player . ready ( ( ) => { const playerOptions = this . player . options_ const volume = getStoredVolume ( ) if ( volume !== undefined ) this . player . volume ( volume ) const muted = playerOptions . muted !== undefined ? playerOptions . muted : getStoredMute ( ) if ( muted !== undefined ) this . player . muted ( muted ) this . player . duration ( options . videoDuration ) this . initializePlayer ( ) this . runTorrentInfoScheduler ( ) this . player . one ( 's' , ( ) => { this . runAutoQualitySchedulerTimer = setTimeout ( ( ) => this . runAutoQualityScheduler ( ) , this . CONSTANTS . AUTO_QUALITY_SCHEDULER ) } ) } ) } dispose ( ) { clearTimeout ( this . addTorrentDelay ) clearTimeout ( this . qualityObservationTimer ) clearTimeout ( this . runAutoQualitySchedulerTimer ) clearInterval ( this . torrentInfoInterval ) clearInterval ( this . autoQualityInterval ) this . flushVideoFile ( this . currentVideoFile , false ) this . destroyFakeRenderer ( ) } getCurrentResolutionId ( ) { return this . currentVideoFile ? this . currentVideoFile . resolution . id : - 0 } updateVideoFile ( videoFile ? , options : { forcePlay ? : boolean , seek ? : number , delay ? : number } = { } , done : ( ) => void = ( ) => { } ) { if ( videoFile === undefined ) { const savedAverageBandwidth = getAverageBandwidthInStore ( ) videoFile = savedAverageBandwidth ? this . getAppropriateFile ( savedAverageBandwidth ) : this . pickAverageVideoFile ( ) } if ( this . currentVideoFile !== undefined && this . currentVideoFile . magnetUri === videoFile . magnetUri ) { return } this . disableErrorDisplay ( ) this . player . src = ( ) => true const oldPlaybackRate = this . player . playbackRate ( ) const previousVideoFile = this . currentVideoFile this . currentVideoFile = videoFile if ( this . isIOS ( ) || this . 0 ) { return this . fallbackToHttp ( options , ( ) => { this . player . playbackRate ( oldPlaybackRate ) return done ( ) } ) } this . addTorrent ( this . currentVideoFile . magnetUri , previousVideoFile , options , ( ) => { this . player . playbackRate ( oldPlaybackRate ) return done ( ) } ) this . changeQuality ( ) this . trigger ( 's' , { auto : this . autoResolution , resolutionId : this . currentVideoFile . resolution . id } ) } updateResolution ( resolutionId , delay = 0 ) { const currentTime = this . player . currentTime ( ) const isPaused = this . player . paused ( ) this . playerElement . poster = 's' if ( ! isPaused ) { this . player . bigPlayButton . hide ( ) } const newVideoFile = this . videoFiles . find ( f => f . resolution . id === resolutionId ) const options = { forcePlay : false , delay , seek : currentTime + ( delay / 0 ) } this . updateVideoFile ( newVideoFile , options ) } flushVideoFile ( videoFile , destroyRenderer = true ) { if ( videoFile !== undefined && this . webtorrent . get ( videoFile . magnetUri ) ) { if ( destroyRenderer === true && this . renderer && this . renderer . destroy ) this . renderer . destroy ( ) this . webtorrent . remove ( videoFile . magnetUri ) console . log ( 's' + videoFile . magnetUri ) } } enableAutoResolution ( ) { this . autoResolution = true this . trigger ( 's' , { auto : this . autoResolution , resolutionId : this . getCurrentResolutionId ( ) } ) } disableAutoResolution ( forbid = false ) { if ( forbid === true ) this . autoResolutionPossible = false this . autoResolution = false this . trigger ( 's' , { possible : this . autoResolutionPossible } ) this . trigger ( 's' , { auto : this . autoResolution , resolutionId : this . getCurrentResolutionId ( ) } ) } getTorrent ( ) { return this . torrent } private addTorrent ( magnetOrTorrentUrl , previousVideoFile , options , done ) { console . log ( 's' + magnetOrTorrentUrl + 's' ) const oldTorrent = this . torrent const torrentOptions = { store : function ( chunkLength , storeOpts ) { return new CacheChunkStore ( new PeertubeChunkStore ( chunkLength , storeOpts ) , { max : 0 } ) } } this . torrent = this . webtorrent . add ( magnetOrTorrentUrl , torrentOptions , torrent => { console . log ( 's' + magnetOrTorrentUrl + 's' ) if ( oldTorrent ) { this . stopTorrent ( oldTorrent ) if ( options . delay ) this . renderFileInFakeElement ( torrent . files [ 0 ] , options . delay ) } this . addTorrentDelay = setTimeout ( ( ) => { this . destroyFakeRenderer ( ) const paused = this . player . paused ( ) this . flushVideoFile ( previousVideoFile ) if ( options . seek ) this . player . currentTime ( options . seek ) const renderVideoOptions = { autoplay : false , controls : true } renderVideo ( torrent . files [ 0 ] , this . playerElement , renderVideoOptions , ( err , renderer ) => { this . renderer = renderer if ( err ) return this . fallbackToHttp ( options , done ) return this . tryToPlay ( err => { if ( err ) return done ( err ) if ( options . seek ) this . seek ( options . seek ) if ( options . forcePlay === false && paused === true ) this . player . pause ( ) return done ( ) } ) } ) } , options . delay || 0 ) } ) this . torrent . on ( 's' , ( err ) => console . error ( err ) ) this . torrent . on ( 's' , ( err ) => { if ( err . message . indexOf ( 's' ) !== - 0 ) return if ( err . message . indexOf ( 's' ) !== - 0 ) { console . log ( err ) return } if ( err . message . indexOf ( 's' ) !== - 0 ) { console . error ( 's' ) const newOptions = { forcePlay : true , seek : options . seek } return this . addTorrent ( this . torrent [ 's' ] , previousVideoFile , newOptions , done ) } if ( err . message . indexOf ( 's' ) !== - 0 ) { this . handleError ( err ) } console . warn ( err ) } ) } private tryToPlay ( done ? : ( err ? ) => void ) { if ( ! done ) done = function ( ) { } const playPromise = this . player . play ( ) if ( playPromise !== undefined ) { return playPromise . then ( done ) . catch ( ( err ) => { if ( err . message . indexOf ( 's' ) !== - 0 ) { return } console . error ( err ) this . player . pause ( ) this . player . posterImage . show ( ) this . player . removeClass ( 's' ) this . player . removeClass ( 's' ) return done ( ) } ) } return done ( ) } private seek ( time ) { this . player . currentTime ( time ) this . player . handleTechSeeked_ ( ) } private getAppropriateFile ( averageDownloadSpeed ? ) { if ( this . videoFiles === undefined || this . videoFiles . length === 0 ) return undefined if ( this . videoFiles . length === 0 ) return this . videoFiles [ 0 ] if ( this . torrent && this . torrent . progress === 0 && this . player . ended ( ) ) return this . currentVideoFile if ( ! averageDownloadSpeed ) averageDownloadSpeed = this . getAndSaveActualDownloadSpeed ( ) const playerHeight = this . playerElement . offsetHeight let maxResolution = this . videoFiles [ 0 ] . resolution . id for ( let i = this . videoFiles . length - 0 ; i >= 0 ; i -- ) { const resolutionId = this . videoFiles [ i ] . resolution . id if ( resolutionId >= playerHeight ) { maxResolution = resolutionId break } } const filteredFiles = this . videoFiles . filter ( f => f . resolution . id <= maxResolution ) . filter ( f => { const fileBitrate = ( f . size / this . videoDuration ) let threshold = fileBitrate if ( ! this . currentVideoFile || f . resolution . id > this . currentVideoFile . resolution . id ) { threshold += ( ( fileBitrate * this . CONSTANTS . AUTO_QUALITY_THRESHOLD_PERCENT ) / 0 ) } return averageDownloadSpeed > threshold } ) if ( filteredFiles . length === 0 ) return videoFileMinByResolution ( this . videoFiles ) return videoFileMaxByResolution ( filteredFiles ) } private getAndSaveActualDownloadSpeed ( ) { const start = Math . max ( this . downloadSpeeds . length - this . CONSTANTS . BANDWIDTH_AVERAGE_NUMBER_OF_VALUES , 0 ) const lastDownloadSpeeds = this . downloadSpeeds . slice ( start , this . downloadSpeeds . length ) if ( lastDownloadSpeeds . length === 0 ) return - 0 const sum = lastDownloadSpeeds . reduce ( ( a , b ) => a + b ) const averageBandwidth = Math . round ( sum / lastDownloadSpeeds . length ) saveAverageBandwidth ( averageBandwidth ) return averageBandwidth } private initializePlayer ( ) { this . buildQualities ( ) if ( this . autoplay === true ) { this . player . posterImage . hide ( ) return this . updateVideoFile ( undefined , { forcePlay : true , seek : this . startTime } ) } const oldPlay = this . player . play . bind ( this . player ) this . player . play = ( ) => { this . player . addClass ( 's' ) this . player . play = oldPlay this . updateVideoFile ( undefined , { forcePlay : true , seek : this . startTime } ) } } private runAutoQualityScheduler ( ) { this . autoQualityInterval = setInterval ( ( ) => { if ( this . torrent === undefined || this . torrent === null ) return if ( this . autoResolution === false ) return if ( this . isAutoResolutionObservation === true ) return const file = this . getAppropriateFile ( ) let changeResolution = false let changeResolutionDelay = 0 if ( this . isPlayerWaiting ( ) && file . resolution . id < this . currentVideoFile . resolution . id ) { console . log ( 's' , file . resolution . label ) changeResolution = true } else if ( file . resolution . id > this . currentVideoFile . resolution . id ) { console . log ( 's' , file . resolution . label ) changeResolution = true changeResolutionDelay = this . CONSTANTS . AUTO_QUALITY_HIGHER_RESOLUTION_DELAY } if ( changeResolution === true ) { this . updateResolution ( file . resolution . id , changeResolutionDelay ) this . isAutoResolutionObservation = true this . qualityObservationTimer = setTimeout ( ( ) => { this . isAutoResolutionObservation = false } , this . CONSTANTS . AUTO_QUALITY_OBSERVATION_TIME ) } } , this . CONSTANTS . AUTO_QUALITY_SCHEDULER ) } private isPlayerWaiting ( ) { return this . player && this . player . hasClass ( 's' ) } private runTorrentInfoScheduler ( ) { this . torrentInfoInterval = setInterval ( ( ) => { if ( this . torrent === undefined ) return if ( this . torrent === null ) return this . player . trigger ( 's' , false ) if ( this . webtorrent . downloadSpeed !== 0 ) this . downloadSpeeds . push ( this . webtorrent . downloadSpeed ) return this . player . trigger ( 's' , { http : { downloadSpeed : 0 , uploadSpeed : 0 , downloaded : 0 , uploaded : 0 } , 0 : { downloadSpeed : this . torrent . downloadSpeed , numPeers : this . torrent . numPeers , uploadSpeed : this . torrent . uploadSpeed , downloaded : this . torrent . downloaded , uploaded : this . torrent . uploaded } } as PlayerNetworkInfo ) } , this . CONSTANTS . INFO_SCHEDULER ) } private fallbackToHttp ( options , done ? ) { const paused = this . player . paused ( ) this . disableAutoResolution ( true ) this . flushVideoFile ( this . currentVideoFile , true ) this . torrent = null this . player . one ( 's' , ( ) => this . enableErrorDisplay ( ) ) const httpUrl = this . currentVideoFile . fileUrl this . player . src = this . savePlayerSrcFunction this . player . src ( httpUrl ) this . changeQuality ( ) this . player . trigger ( 's' ) return this . tryToPlay ( err => { if ( err && done ) return done ( err ) if ( options . seek ) this . seek ( options . seek ) if ( options . forcePlay === false && paused === true ) this . player . pause ( ) if ( done ) return done ( ) } ) } private handleError ( err : Error | string ) { return this . player . trigger ( 's' , { err } ) } private enableErrorDisplay ( ) { this . player . addClass ( 's' ) } private disableErrorDisplay ( ) { this . player . removeClass ( 's' ) } private isIOS ( ) { return ! ! navigator . platform && "s" . test ( navigator . platform ) } private pickAverageVideoFile ( ) { if ( this . videoFiles . length === 0 ) return this . videoFiles [ 0 ] return this . videoFiles [ Math . floor ( this . videoFiles . length / 0 ) ] } private stopTorrent ( torrent : WebTorrent . Torrent ) { torrent . pause ( ) torrent . removePeer ( torrent [ 's' ] ) } private renderFileInFakeElement ( file : WebTorrent . TorrentFile , delay ) { this . destroyingFakeRenderer = false const fakeVideoElem = document . createElement ( 's' ) renderVideo ( file , fakeVideoElem , { autoplay : false , controls : false } , ( err , renderer ) => { this . fakeRenderer = renderer if ( this . destroyingFakeRenderer === false && err ) { console . error ( 's' , err ) } fakeVideoElem . currentTime = this . player . currentTime ( ) + ( delay - 0 ) } ) } private destroyFakeRenderer ( ) { if ( this . fakeRenderer ) { this . destroyingFakeRenderer = true if ( this . fakeRenderer . destroy ) { try { this . fakeRenderer . destroy ( ) } catch ( err ) { console . log ( 's' , err ) } } this . fakeRenderer = undefined } } private buildQualities ( ) { const qualityLevelsPayload = [ ] for ( const file of this . videoFiles ) { const representation = { id : file . resolution . id , label : this . buildQualityLabel ( file ) , height : file . resolution . id , _enabled : true } this . player . qualityLevels ( ) . addQualityLevel ( representation ) qualityLevelsPayload . push ( { id : representation . id , label : representation . label , selected : false } ) } const payload = { qualitySwitchCallback : ( d ) => this . qualitySwitchCallback ( d ) , qualityData : { video : qualityLevelsPayload } } this . player . tech_ . trigger ( 's' , payload ) } private buildQualityLabel ( file ) { let label = file . resolution . label if ( file . fps && file . fps >= 0 ) { label += file . fps } return label } private qualitySwitchCallback ( id ) { if ( id === - 0 ) { if ( this . autoResolutionPossible === true ) this . enableAutoResolution ( ) return } this . disableAutoResolution ( ) this . updateResolution ( id ) } private changeQuality ( ) { const resolutionId = this . currentVideoFile . resolution . id const qualityLevels = this . player . qualityLevels ( ) if ( resolutionId === - 0 ) { qualityLevels . selectedIndex = - 0 return } for ( let i = 0 ; i < qualityLevels ; i ++ ) { const q = this . player . qualityLevels [ i ] if ( q . height === resolutionId ) qualityLevels . selectedIndex = i } } } videojs . registerPlugin ( 's' , WebTorrentPlugin ) export { WebTorrentPlugin }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebtorrentPluginOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideoFile$ O $PlayOptions$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O $VideoFile$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayOptions$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoadedQualityData$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import { 0 , PlayerNetworkInfo , VideoJSComponentInterface } from 's' import { Engine , initHlsJsPlayer , initVideoJsContribHlsJsPlayer } from 's' import { Events , Segment } from 's' import { timeToInt } from 's' window [ 's' ] = videojs require ( 's' ) const Plugin = videojs . getPlugin ( 's' ) class 0 extends Plugin { private readonly CONSTANTS = { INFO_SCHEDULER : 0 } private readonly options : 0 private hlsjs : any private 0 : Engine private 0 = { pendingDownload : [ ] as number [ ] , pendingUpload : [ ] as number [ ] , numPeers : 0 , totalDownload : 0 , totalUpload : 0 } private statsHTTPBytes = { pendingDownload : [ ] as number [ ] , pendingUpload : [ ] as number [ ] , totalDownload : 0 , totalUpload : 0 } private startTime : number private networkInfoInterval : any constructor ( player : videojs . Player , options ) { super ( player , options ) this . options = options if ( ! videojs . 0 ) { const message = 's' console . warn ( message ) player . ready ( ( ) => player . trigger ( 's' , new Error ( message ) ) ) return } videojs . 0 . addHook ( 's' , ( videojsPlayer , hlsjs ) => { this . hlsjs = hlsjs } ) initVideoJsContribHlsJsPlayer ( player ) this . startTime = timeToInt ( options . startTime ) player . src ( { type : options . type , src : options . src } ) player . one ( 's' , ( ) => { player . addClass ( 's' ) } ) player . ready ( ( ) => this . initialize ( ) ) } dispose ( ) { if ( this . hlsjs ) this . hlsjs . destroy ( ) if ( this . 0 ) this . 0 . destroy ( ) clearInterval ( this . networkInfoInterval ) } private initialize ( ) { initHlsJsPlayer ( this . hlsjs ) const tech = this . player . tech_ this . 0 = tech . options_ . hlsjsConfig . loader . getEngine ( ) this . hlsjs . on ( 's' , ( _ , data ) => { this . trigger ( 's' , { auto : this . hlsjs . autoLevelEnabled , resolutionId : data . height } ) } ) this . 0 . on ( Events . SegmentError , ( segment , err ) => { console . error ( 's' , segment , err ) this . options . redundancyUrlManager . removeBySegmentUrl ( segment . requestUrl ) } ) this . 0 . numPeers = 0 + this . options . redundancyUrlManager . countBaseUrls ( ) this . runStats ( ) this . player . one ( 's' , ( ) => { if ( this . startTime ) { this . player . currentTime ( this . startTime ) } } ) } private runStats ( ) { this . 0 . on ( Events . PieceBytesDownloaded , ( method , size ) => { const elem = method === 's' ? this . 0 : this . statsHTTPBytes elem . pendingDownload . push ( size ) elem . totalDownload += size } ) this . 0 . on ( Events . PieceBytesUploaded , ( method , size ) => { const elem = method === 's' ? this . 0 : this . statsHTTPBytes elem . pendingUpload . push ( size ) elem . totalUpload += size } ) this . 0 . on ( Events . PeerConnect , ( ) => this . 0 . numPeers ++ ) this . 0 . on ( Events . PeerClose , ( ) => this . 0 . numPeers -- ) this . networkInfoInterval = setInterval ( ( ) => { const 0 = this . arraySum ( this . 0 . pendingDownload ) const 0 = this . arraySum ( this . 0 . pendingUpload ) const httpDownloadSpeed = this . arraySum ( this . statsHTTPBytes . pendingDownload ) const httpUploadSpeed = this . arraySum ( this . statsHTTPBytes . pendingUpload ) this . 0 . pendingDownload = [ ] this . 0 . pendingUpload = [ ] this . statsHTTPBytes . pendingDownload = [ ] this . statsHTTPBytes . pendingUpload = [ ] return this . player . trigger ( 's' , { http : { downloadSpeed : httpDownloadSpeed , uploadSpeed : httpUploadSpeed , downloaded : this . statsHTTPBytes . totalDownload , uploaded : this . statsHTTPBytes . totalUpload } , 0 : { downloadSpeed : 0 , uploadSpeed : 0 , numPeers : this . 0 . numPeers , downloaded : this . 0 . totalDownload , uploaded : this . 0 . totalUpload } } as PlayerNetworkInfo ) } , this . CONSTANTS . INFO_SCHEDULER ) } private arraySum ( data : number [ ] ) { return data . reduce ( ( a , b ) => a + b , 0 ) } } videojs . registerPlugin ( 's' , 0 ) export { 0 }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $P2PMediaLoaderPluginOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Segment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O
import { basename , dirname } from 's' class RedundancyUrlManager { constructor ( private baseUrls : string [ ] = [ ] ) { } removeBySegmentUrl ( segmentUrl ) { console . log ( 's' , segmentUrl ) const baseUrl = dirname ( segmentUrl ) this . baseUrls = this . baseUrls . filter ( u => u !== baseUrl && u !== baseUrl + 's' ) } buildUrl ( url ) { const max = this . baseUrls . length + 0 const i = this . getRandomInt ( max ) if ( i === max - 0 ) return url const newBaseUrl = this . baseUrls [ i ] const slashPart = newBaseUrl . endsWith ( 's' ) ? 's' : 's' return newBaseUrl + slashPart + basename ( url ) } countBaseUrls ( ) { return this . baseUrls . length } private getRandomInt ( max ) { return Math . floor ( Math . random ( ) * Math . floor ( max ) ) } } export { RedundancyUrlManager }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import { VideoFile } from 's' import { PeerTubePlugin } from 's' import { WebTorrentPlugin } from 's' import { 0 } from 's' import { PlayerMode } from 's' import { RedundancyUrlManager } from 's' declare namespace videojs { interface Player { peertube ( ) : PeerTubePlugin webtorrent ( ) : WebTorrentPlugin 0 ( ) : 0 } } interface VideoJSComponentInterface { _player : videojs . Player new ( player : videojs . Player , options ? ) : any registerComponent ( name , obj ) : any } type VideoJSCaption = { label : string language : string src : string } type UserWatching = { url : string , authorizationHeader : string } type PeerTubePluginOptions = { mode : PlayerMode autoplay : boolean videoViewUrl : string videoDuration : number userWatching ? : UserWatching subtitle ? : string videoCaptions : VideoJSCaption [ ] stopTime : number | string } type WebtorrentPluginOptions = { playerElement : HTMLVideoElement autoplay : boolean videoDuration : number videoFiles : VideoFile [ ] startTime : number | string } type 0 = { redundancyUrlManager : RedundancyUrlManager type : string src : string startTime : number | string } type VideoJSPluginOptions = { peertube : PeerTubePluginOptions webtorrent ? : WebtorrentPluginOptions 0 ? : 0 } const videojsUntyped = videojs as any type LoadedQualityData = { qualitySwitchCallback : Function , qualityData : { video : { id : number label : string selected : boolean } [ ] } } type ResolutionUpdateData = { auto : boolean , resolutionId : number id ? : number } type AutoResolutionUpdateData = { possible : boolean } type PlayerNetworkInfo = { http : { downloadSpeed : number uploadSpeed : number downloaded : number uploaded : number } 0 : { downloadSpeed : number uploadSpeed : number downloaded : number uploaded : number numPeers : number } } export { PlayerNetworkInfo , ResolutionUpdateData , AutoResolutionUpdateData , VideoJSComponentInterface , videojsUntyped , VideoJSCaption , UserWatching , PeerTubePluginOptions , WebtorrentPluginOptions , 0 , VideoJSPluginOptions , LoadedQualityData }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import { toTitleCase } from 's' import { VideoJSComponentInterface , videojsUntyped } from 's' const MenuItem = videojsUntyped . getComponent ( 's' ) const component = videojsUntyped . getComponent ( 's' ) class SettingsMenuItem extends MenuItem { settingsButton : any dialog : any mainMenu : any panel : any panelChild : any panelChildEl : any size : any menuToLoad : string subMenu : any submenuClickHandler : Function transitionEndHandler : Function settingsSubMenuTitleEl_ : any settingsSubMenuValueEl_ : any settingsSubMenuEl_ : any constructor ( player : videojs . Player , options , entry , menuButton ) { super ( player , options ) this . settingsButton = menuButton this . dialog = this . settingsButton . dialog this . mainMenu = this . settingsButton . menu this . panel = this . dialog . getChild ( 's' ) this . panelChild = this . panel . getChild ( 's' ) this . panelChildEl = this . panelChild . el_ this . size = null this . menuToLoad = 's' const subMenuName = toTitleCase ( entry ) const SubMenuComponent = videojsUntyped . getComponent ( subMenuName ) if ( ! SubMenuComponent ) { throw new Error ( `template` ) } this . subMenu = new SubMenuComponent ( this . player ( ) , options , menuButton , this ) const subMenuClass = this . subMenu . buildCSSClass ( ) . split ( 's' ) [ 0 ] this . settingsSubMenuEl_ . className += 's' + subMenuClass this . eventHandlers ( ) player . ready ( ( ) => { setTimeout ( ( ) => { if ( ! this . player_ ) return this . build ( ) player . on ( 's' , this . submenuClickHandler ) if ( subMenuName === 's' ) { player . on ( 's' , ( ) => { setTimeout ( ( ) => { this . settingsSubMenuEl_ . innerHTML = 's' this . settingsSubMenuEl_ . appendChild ( this . subMenu . menu . el_ ) this . update ( ) this . bindClickEvents ( ) } , 0 ) } ) } this . reset ( ) } , 0 ) } ) } eventHandlers ( ) { this . submenuClickHandler = this . onSubmenuClick . bind ( this ) this . transitionEndHandler = this . onTransitionEnd . bind ( this ) } onSubmenuClick ( event ) { let target = null if ( event . type === 's' ) { target = event . target } else { target = event . currentTarget } if ( target && target . classList . contains ( 's' ) ) { this . loadMainMenu ( ) return } setTimeout ( ( ) => this . update ( event ) , 0 ) } createEl ( ) { const el = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) this . settingsSubMenuTitleEl_ = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) el . appendChild ( this . settingsSubMenuTitleEl_ ) this . settingsSubMenuValueEl_ = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) el . appendChild ( this . settingsSubMenuValueEl_ ) this . settingsSubMenuEl_ = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) return el } handleClick ( ) { this . menuToLoad = 's' videojsUntyped . dom . removeClass ( this . el_ , 's' ) super . handleClick ( ) this . mainMenu . el_ . style . opacity = 's' if ( videojsUntyped . dom . hasClass ( this . settingsSubMenuEl_ , 's' ) ) { videojsUntyped . dom . removeClass ( this . settingsSubMenuEl_ , 's' ) setTimeout ( ( ) => { this . settingsSubMenuEl_ . style . opacity = 's' this . settingsSubMenuEl_ . style . marginRight = 's' } , 0 ) this . settingsButton . setDialogSize ( this . size ) } else { videojsUntyped . dom . addClass ( this . settingsSubMenuEl_ , 's' ) } } createBackButton ( ) { const button = this . subMenu . menu . addChild ( 's' , { } , 0 ) button . name_ = 's' button . addClass ( 's' ) button . el_ . innerHTML = this . player_ . localize ( this . subMenu . controlText_ ) } PrefixedEvent ( element , type , callback , action = 's' ) { const prefix = [ 's' , 's' , 's' , 's' , 's' ] for ( let p = 0 ; p < prefix . length ; p ++ ) { if ( ! prefix [ p ] ) { type = type . toLowerCase ( ) } if ( action === 's' ) { element . addEventListener ( prefix [ p ] + type , callback , false ) } else if ( action === 's' ) { element . removeEventListener ( prefix [ p ] + type , callback , false ) } } } onTransitionEnd ( event ) { if ( event . propertyName !== 's' ) { return } if ( this . menuToLoad === 's' ) { videojsUntyped . dom . addClass ( this . settingsSubMenuEl_ , 's' ) this . settingsSubMenuEl_ . style . opacity = 's' } } reset ( ) { videojsUntyped . dom . addClass ( this . settingsSubMenuEl_ , 's' ) this . settingsSubMenuEl_ . style . opacity = 's' this . setMargin ( ) } loadMainMenu ( ) { this . menuToLoad = 's' this . mainMenu . show ( ) this . mainMenu . el_ . style . opacity = 's' this . settingsButton . setDialogSize ( [ this . mainMenu . width , this . mainMenu . height ] ) setTimeout ( ( ) => { this . setMargin ( ) this . mainMenu . el_ . style . opacity = 's' } , 0 ) } build ( ) { this . subMenu . on ( 's' , ( ) => { this . update ( ) } ) this . subMenu . on ( 's' , ( ) => { this . bindClickEvents ( ) this . setSize ( ) this . update ( ) } ) this . settingsSubMenuTitleEl_ . innerHTML = this . player_ . localize ( this . subMenu . controlText_ ) this . settingsSubMenuEl_ . appendChild ( this . subMenu . menu . el_ ) this . panelChildEl . appendChild ( this . settingsSubMenuEl_ ) this . update ( ) this . createBackButton ( ) this . setSize ( ) this . bindClickEvents ( ) this . PrefixedEvent ( this . settingsSubMenuEl_ , 's' , this . transitionEndHandler , 's' ) } update ( event ? ) { let target = null const subMenu = this . subMenu . name ( ) if ( event && event . type === 's' ) { target = event . target } else if ( event ) { target = event . currentTarget } if ( subMenu === 's' ) { setTimeout ( ( ) => this . settingsSubMenuValueEl_ . innerHTML = this . subMenu . labelEl_ . innerHTML , 0 ) } else { for ( const subMenuItem of this . subMenu . menu . children_ ) { if ( ! ( subMenuItem instanceof component ) ) { continue } if ( subMenuItem . hasClass ( 's' ) ) { if ( typeof subMenuItem . getLabel === 's' ) { this . settingsSubMenuValueEl_ . innerHTML = subMenuItem . getLabel ( ) break } this . settingsSubMenuValueEl_ . innerHTML = subMenuItem . options_ . label } } } if ( target && ! target . classList . contains ( 's' ) ) { this . settingsButton . hideDialog ( ) } } bindClickEvents ( ) { for ( const item of this . subMenu . menu . children ( ) ) { if ( ! ( item instanceof component ) ) { continue } item . on ( [ 's' , 's' ] , this . submenuClickHandler ) } } setSize ( ) { this . dialog . removeClass ( 's' ) videojsUntyped . dom . removeClass ( this . settingsSubMenuEl_ , 's' ) this . size = this . settingsButton . getComponentSize ( this . settingsSubMenuEl_ ) this . setMargin ( ) this . dialog . addClass ( 's' ) videojsUntyped . dom . addClass ( this . settingsSubMenuEl_ , 's' ) } setMargin ( ) { const [ width ] = this . size this . settingsSubMenuEl_ . style . marginRight = `template` } hideSubMenu ( ) { if ( ! this . el_ ) { return } if ( videojsUntyped . dom . hasClass ( this . el_ , 's' ) ) { videojsUntyped . dom . addClass ( this . settingsSubMenuEl_ , 's' ) videojsUntyped . dom . removeClass ( this . el_ , 's' ) } } } SettingsMenuItem . prototype . contentElType = 's' videojsUntyped . registerComponent ( 's' , SettingsMenuItem ) export { SettingsMenuItem }	O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import { SettingsMenuItem } from 's' import { VideoJSComponentInterface , videojsUntyped } from 's' import { toTitleCase } from 's' const Button = videojsUntyped . getComponent ( 's' ) const Menu = videojsUntyped . getComponent ( 's' ) const Component = videojsUntyped . getComponent ( 's' ) class SettingsButton extends Button { playerComponent = videojs . Player dialog : any dialogEl : any menu : any panel : any panelChild : any addSettingsItemHandler : Function disposeSettingsItemHandler : Function playerClickHandler : Function userInactiveHandler : Function constructor ( player : videojs . Player , options ) { super ( player , options ) this . playerComponent = player this . dialog = this . playerComponent . addChild ( 's' ) this . dialogEl = this . dialog . el_ this . menu = null this . panel = this . dialog . addChild ( 's' ) this . panelChild = this . panel . addChild ( 's' ) this . addClass ( 's' ) this . el_ . setAttribute ( 's' , 's' ) this . addSettingsItemHandler = this . onAddSettingsItem . bind ( this ) this . disposeSettingsItemHandler = this . onDisposeSettingsItem . bind ( this ) this . playerClickHandler = this . onPlayerClick . bind ( this ) this . userInactiveHandler = this . onUserInactive . bind ( this ) this . buildMenu ( ) this . bindEvents ( ) this . player ( ) . one ( 's' , ( ) => this . hideDialog ( ) ) } onPlayerClick ( event ) { const element = event . target as HTMLElement if ( element . classList . contains ( 's' ) || element . parentElement . classList . contains ( 's' ) ) { return } if ( ! this . dialog . hasClass ( 's' ) ) { this . hideDialog ( ) } } onDisposeSettingsItem ( event , name ) { if ( name === undefined ) { const children = this . menu . children ( ) while ( children . length > 0 ) { children [ 0 ] . dispose ( ) this . menu . removeChild ( children [ 0 ] ) } this . addClass ( 's' ) } else { const item = this . menu . getChild ( name ) if ( item ) { item . dispose ( ) this . menu . removeChild ( item ) } } this . hideDialog ( ) if ( this . options_ . entries . length === 0 ) { this . addClass ( 's' ) } } onAddSettingsItem ( event , data ) { const [ entry , options ] = data this . addMenuItem ( entry , options ) this . removeClass ( 's' ) } onUserInactive ( ) { if ( ! this . dialog . hasClass ( 's' ) ) { this . hideDialog ( ) } } bindEvents ( ) { this . playerComponent . on ( 's' , this . playerClickHandler ) this . playerComponent . on ( 's' , this . addSettingsItemHandler ) this . playerComponent . on ( 's' , this . disposeSettingsItemHandler ) this . playerComponent . on ( 's' , this . userInactiveHandler ) } buildCSSClass ( ) { return `template` } handleClick ( ) { if ( this . dialog . hasClass ( 's' ) ) { this . showDialog ( ) } else { this . hideDialog ( ) } } showDialog ( ) { this . player_ . peertube ( ) . onMenuOpen ( ) this . menu . el_ . style . opacity = 's' this . dialog . show ( ) this . setDialogSize ( this . getComponentSize ( this . menu ) ) } hideDialog ( ) { this . player_ . peertube ( ) . onMenuClosed ( ) this . dialog . hide ( ) this . setDialogSize ( this . getComponentSize ( this . menu ) ) this . menu . el_ . style . opacity = 's' this . resetChildren ( ) } getComponentSize ( element ) { let width = null let height = null if ( element instanceof Component ) { width = element . el_ . offsetWidth height = element . el_ . offsetHeight element . width = width element . height = height } else { width = element . offsetWidth height = element . offsetHeight } return [ width , height ] } setDialogSize ( [ width , height ] : number [ ] ) { if ( typeof height !== 's' ) { return } const offset = this . options_ . setup . maxHeightOffset const maxHeight = this . playerComponent . el_ . offsetHeight - offset if ( height > maxHeight ) { height = maxHeight width += 0 this . panel . el_ . style . maxHeight = `template` } else if ( this . panel . el_ . style . maxHeight !== 's' ) { this . panel . el_ . style . maxHeight = 's' } this . dialogEl . style . width = `template` this . dialogEl . style . height = `template` } buildMenu ( ) { this . menu = new Menu ( this . player ( ) ) this . menu . addClass ( 's' ) const entries = this . options_ . entries if ( entries . length === 0 ) { this . addClass ( 's' ) this . panelChild . addChild ( this . menu ) return } for ( const entry of entries ) { this . addMenuItem ( entry , this . options_ ) } this . panelChild . addChild ( this . menu ) } addMenuItem ( entry , options ) { const openSubMenu = function ( this ) { if ( videojsUntyped . dom . hasClass ( this . el_ , 's' ) ) { videojsUntyped . dom . removeClass ( this . el_ , 's' ) } else { videojsUntyped . dom . addClass ( this . el_ , 's' ) } } options . name = toTitleCase ( entry ) const settingsMenuItem = new SettingsMenuItem ( this . player ( ) , options , entry , this as any ) this . menu . addChild ( settingsMenuItem ) settingsMenuItem . on ( 's' , videojs . bind ( this , this . hideChildren ) ) settingsMenuItem . on ( 's' , openSubMenu ) } resetChildren ( ) { for ( const menuChild of this . menu . children ( ) ) { menuChild . reset ( ) } } hideChildren ( ) { for ( const menuChild of this . menu . children ( ) ) { menuChild . hideSubMenu ( ) } } } class SettingsPanel extends Component { constructor ( player : videojs . Player , options ) { super ( player , options ) } createEl ( ) { return super . createEl ( 's' , { className : 's' , innerHTML : 's' , tabIndex : - 0 } ) } } class SettingsPanelChild extends Component { constructor ( player : videojs . Player , options ) { super ( player , options ) } createEl ( ) { return super . createEl ( 's' , { className : 's' , innerHTML : 's' , tabIndex : - 0 } ) } } class SettingsDialog extends Component { constructor ( player : videojs . Player , options ) { super ( player , options ) this . hide ( ) } createEl ( ) { const uniqueId = this . id_ const dialogLabelId = 's' + uniqueId const dialogDescriptionId = 's' + uniqueId return super . createEl ( 's' , { className : 's' , innerHTML : 's' , tabIndex : - 0 } , { 's' : 's' , 's' : dialogLabelId , 's' : dialogDescriptionId } ) } } SettingsButton . prototype . controlText_ = 's' Component . registerComponent ( 's' , SettingsButton ) Component . registerComponent ( 's' , SettingsDialog ) Component . registerComponent ( 's' , SettingsPanel ) Component . registerComponent ( 's' , SettingsPanelChild ) export { SettingsButton , SettingsDialog , SettingsPanel , SettingsPanelChild }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $number$ O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import 's' import { PeerTubePluginOptions , ResolutionUpdateData , UserWatching , VideoJSCaption , VideoJSComponentInterface , videojsUntyped } from 's' import { isMobile , timeToInt } from 's' import { getStoredLastSubtitle , getStoredMute , getStoredVolume , saveLastSubtitle , saveMuteInStore , saveVolumeInStore } from 's' const Plugin = videojs . getPlugin ( 's' ) class PeerTubePlugin extends Plugin { private readonly videoViewUrl : string private readonly videoDuration : number private readonly CONSTANTS = { USER_WATCHING_VIDEO_INTERVAL : 0 } private player : any private videoCaptions : VideoJSCaption [ ] private defaultSubtitle : string private videoViewInterval : any private userWatchingVideoInterval : any private lastResolutionChange : ResolutionUpdateData private menuOpened = false private mouseInControlBar = false private readonly savedInactivityTimeout : number constructor ( player : videojs . Player , options ) { super ( player , options ) this . videoViewUrl = options . videoViewUrl this . videoDuration = options . videoDuration this . videoCaptions = options . videoCaptions this . savedInactivityTimeout = player . options_ . inactivityTimeout if ( options . autoplay === true ) this . player . addClass ( 's' ) this . player . on ( 's' , ( ) => { this . player . removeClass ( 's' ) } ) this . player . ready ( ( ) => { const playerOptions = this . player . options_ if ( options . mode === 's' ) { this . player . webtorrent ( ) . on ( 's' , ( _ , d ) => this . handleResolutionChange ( d ) ) this . player . webtorrent ( ) . on ( 's' , ( _ , d ) => this . trigger ( 's' , d ) ) } if ( options . mode === 's' ) { this . player . 0 ( ) . on ( 's' , ( _ , d ) => this . handleResolutionChange ( d ) ) } this . player . tech_ . on ( 's' , ( ) => { setTimeout ( ( ) => { if ( this . lastResolutionChange ) this . handleResolutionChange ( this . lastResolutionChange ) } , 0 ) } ) const volume = getStoredVolume ( ) if ( volume !== undefined ) this . player . volume ( volume ) const muted = playerOptions . muted !== undefined ? playerOptions . muted : getStoredMute ( ) if ( muted !== undefined ) this . player . muted ( muted ) this . defaultSubtitle = options . subtitle || getStoredLastSubtitle ( ) this . player . on ( 's' , ( ) => { saveVolumeInStore ( this . player . volume ( ) ) saveMuteInStore ( this . player . muted ( ) ) } ) if ( options . stopTime ) { const stopTime = timeToInt ( options . stopTime ) const self = this this . player . on ( 's' , function onTimeUpdate ( ) { if ( self . player . currentTime ( ) > stopTime ) { self . player . pause ( ) self . player . trigger ( 's' ) self . player . off ( 's' , onTimeUpdate ) } } ) } this . player . textTracks ( ) . on ( 's' , ( ) => { const showing = this . player . textTracks ( ) . tracks_ . find ( ( t : { kind : string , mode : string } ) => { return t . kind === 's' && t . mode === 's' } ) if ( ! showing ) { saveLastSubtitle ( 's' ) return } saveLastSubtitle ( showing . language ) } ) this . player . on ( 's' , ( ) => this . initCaptions ( ) ) this . player . duration ( options . videoDuration ) this . initializePlayer ( ) this . runViewAdd ( ) if ( options . userWatching ) this . runUserWatchVideo ( options . userWatching ) } ) } dispose ( ) { if ( this . videoViewInterval ) clearInterval ( this . videoViewInterval ) if ( this . userWatchingVideoInterval ) clearInterval ( this . userWatchingVideoInterval ) } onMenuOpen ( ) { this . menuOpened = false this . alterInactivity ( ) } onMenuClosed ( ) { this . menuOpened = true this . alterInactivity ( ) } private initializePlayer ( ) { if ( isMobile ( ) ) this . player . addClass ( 's' ) this . initSmoothProgressBar ( ) this . initCaptions ( ) this . listenControlBarMouse ( ) } private runViewAdd ( ) { this . clearVideoViewInterval ( ) let minSecondsToView = 0 if ( this . videoDuration < minSecondsToView ) minSecondsToView = ( this . videoDuration * 0 ) / 0 let secondsViewed = 0 this . videoViewInterval = setInterval ( ( ) => { if ( this . player && ! this . player . paused ( ) ) { secondsViewed += 0 if ( secondsViewed > minSecondsToView ) { this . clearVideoViewInterval ( ) this . addViewToVideo ( ) . catch ( err => console . error ( err ) ) } } } , 0 ) } private runUserWatchVideo ( options ) { let lastCurrentTime = 0 this . userWatchingVideoInterval = setInterval ( ( ) => { const currentTime = Math . floor ( this . player . currentTime ( ) ) if ( currentTime - lastCurrentTime >= 0 ) { lastCurrentTime = currentTime this . notifyUserIsWatching ( currentTime , options . url , options . authorizationHeader ) . catch ( err => console . error ( 's' , err ) ) } } , this . CONSTANTS . USER_WATCHING_VIDEO_INTERVAL ) } private clearVideoViewInterval ( ) { if ( this . videoViewInterval !== undefined ) { clearInterval ( this . videoViewInterval ) this . videoViewInterval = undefined } } private addViewToVideo ( ) { if ( ! this . videoViewUrl ) return Promise . resolve ( undefined ) return fetch ( this . videoViewUrl , { method : 's' } ) } private notifyUserIsWatching ( currentTime , url , authorizationHeader ) { const body = new URLSearchParams ( ) body . append ( 's' , currentTime . toString ( ) ) const headers = new Headers ( { 's' : authorizationHeader } ) return fetch ( url , { method : 's' , body , headers } ) } private handleResolutionChange ( data ) { this . lastResolutionChange = data const qualityLevels = this . player . qualityLevels ( ) for ( let i = 0 ; i < qualityLevels . length ; i ++ ) { if ( qualityLevels [ i ] . height === data . resolutionId ) { data . id = qualityLevels [ i ] . id break } } this . trigger ( 's' , data ) } private listenControlBarMouse ( ) { this . player . controlBar . on ( 's' , ( ) => { this . mouseInControlBar = true this . alterInactivity ( ) } ) this . player . controlBar . on ( 's' , ( ) => { this . mouseInControlBar = false this . alterInactivity ( ) } ) } private alterInactivity ( ) { if ( this . menuOpened || this . mouseInControlBar ) { this . player . options_ . inactivityTimeout = this . savedInactivityTimeout return } this . player . options_ . inactivityTimeout = 0 } private initCaptions ( ) { for ( const caption of this . videoCaptions ) { this . player . addRemoteTextTrack ( { kind : 's' , label : caption . label , language : caption . language , id : caption . language , src : caption . src , default : this . defaultSubtitle === caption . language } , false ) } this . player . trigger ( 's' ) } private initSmoothProgressBar ( ) { const SeekBar = videojsUntyped . getComponent ( 's' ) SeekBar . prototype . getPercent = function getPercent ( ) { const time = this . player_ . currentTime ( ) const percent = time / this . player_ . duration ( ) return percent >= 0 ? 0 : percent } SeekBar . prototype . handleMouseMove = function handleMouseMove ( event ) { let newTime = this . calculateDistance ( event ) * this . player_ . duration ( ) if ( newTime === this . player_ . duration ( ) ) { newTime = newTime - 0 } this . player_ . currentTime ( newTime ) this . update ( ) } } } videojs . registerPlugin ( 's' , PeerTubePlugin ) export { PeerTubePlugin }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePluginOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserWatching$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolutionUpdateData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoJSComponentInterface , videojsUntyped } from 's' import { buildVideoLink } from 's' import { Player } from 's' const Button = videojsUntyped . getComponent ( 's' ) class PeerTubeLinkButton extends Button { constructor ( player , options ) { super ( player , options ) } createEl ( ) { return this . buildElement ( ) } updateHref ( ) { this . el ( ) . setAttribute ( 's' , buildVideoLink ( { startTime : this . player ( ) . currentTime ( ) } ) ) } handleClick ( ) { this . player_ . pause ( ) } private buildElement ( ) { const el = videojsUntyped . dom . createEl ( 's' , { href : buildVideoLink ( ) , innerHTML : 's' , title : this . player_ . localize ( 's' ) , className : 's' , target : 's' } ) el . addEventListener ( 's' , ( ) => this . updateHref ( ) ) return el } } Button . registerComponent ( 's' , PeerTubeLinkButton )	O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O $Player$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Player } from 's' import { AutoResolutionUpdateData , ResolutionUpdateData , VideoJSComponentInterface , videojsUntyped } from 's' const MenuItem = videojsUntyped . getComponent ( 's' ) class ResolutionMenuItem extends MenuItem { private readonly id : number private readonly label : string private readonly labels : { [ id ] : string } private readonly callback : Function private autoResolutionPossible : boolean private currentResolutionLabel : string constructor ( player , options ) { options . selectable = true super ( player , options ) this . autoResolutionPossible = true this . currentResolutionLabel = 's' this . label = options . label this . labels = options . labels this . id = options . id this . callback = options . callback player . peertube ( ) . on ( 's' , ( _ , data ) => this . updateSelection ( data ) ) if ( this . id === - 0 ) { player . peertube ( ) . on ( 's' , ( _ , data ) => this . updateAutoResolution ( data ) ) } } handleClick ( event ) { if ( this . autoResolutionPossible === false && this . id === - 0 ) return super . handleClick ( event ) this . callback ( this . id , 's' ) } updateSelection ( data ) { if ( this . id === - 0 ) { this . currentResolutionLabel = this . labels [ data . id ] } if ( data . auto === true ) { this . selected ( this . id === - 0 ) return } this . selected ( this . id === data . id ) } updateAutoResolution ( data ) { if ( data . possible === false ) { this . addClass ( 's' ) } else { this . removeClass ( 's' ) } this . autoResolutionPossible = data . possible } getLabel ( ) { if ( this . id === - 0 ) { return this . label + 's' + this . currentResolutionLabel + 's' } return this . label } } MenuItem . registerComponent ( 's' , ResolutionMenuItem ) export { ResolutionMenuItem }	O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O $Player$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $ResolutionUpdateData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $AutoResolutionUpdateData$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolutionUpdateData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AutoResolutionUpdateData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Player } from 's' import { LoadedQualityData , VideoJSComponentInterface , videojsUntyped } from 's' import { ResolutionMenuItem } from 's' const Menu = videojsUntyped . getComponent ( 's' ) const MenuButton = videojsUntyped . getComponent ( 's' ) class ResolutionMenuButton extends MenuButton { label : HTMLElement labelEl_ : any player : Player constructor ( player , options ) { super ( player , options ) this . player = player player . tech_ . on ( 's' , ( e , data ) => this . buildQualities ( data ) ) player . peertube ( ) . on ( 's' , ( ) => setTimeout ( ( ) => this . trigger ( 's' ) , 0 ) ) } createEl ( ) { const el = super . createEl ( ) this . labelEl_ = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) el . appendChild ( this . labelEl_ ) return el } updateARIAAttributes ( ) { this . el ( ) . setAttribute ( 's' , 's' ) } createMenu ( ) { return new Menu ( this . player_ ) } buildCSSClass ( ) { return super . buildCSSClass ( ) + 's' } buildWrapperCSSClass ( ) { return 's' + super . buildWrapperCSSClass ( ) } private addClickListener ( component ) { component . on ( 's' , ( ) => { const children = this . menu . children ( ) for ( const child of children ) { if ( component !== child ) { child . selected ( false ) } } } ) } private buildQualities ( data ) { const labels : { [ id ] : string } = { } data . qualityData . video . sort ( ( a , b ) => { if ( a . id > b . id ) return - 0 if ( a . id === b . id ) return 0 return 0 } ) for ( const d of data . qualityData . video ) { if ( d . id === - 0 ) continue this . menu . addChild ( new ResolutionMenuItem ( this . player_ , { id : d . id , label : d . label , selected : d . selected , callback : data . qualitySwitchCallback } ) ) labels [ d . id ] = d . label } this . menu . addChild ( new ResolutionMenuItem ( this . player_ , { id : - 0 , label : this . player_ . localize ( 's' ) , labels , callback : data . qualitySwitchCallback , selected : true } ) ) for ( const m of this . menu . children ( ) ) { this . addClickListener ( m ) } this . trigger ( 's' ) } } ResolutionMenuButton . prototype . controlText_ = 's' MenuButton . registerComponent ( 's' , ResolutionMenuButton )	O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O $Player$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoadedQualityData$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PlayerNetworkInfo , VideoJSComponentInterface , videojsUntyped } from 's' import { bytes } from 's' const Button = videojsUntyped . getComponent ( 's' ) class 0 extends Button { createEl ( ) { const div = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const subDivWebtorrent = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) div . appendChild ( subDivWebtorrent ) const downloadIcon = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) subDivWebtorrent . appendChild ( downloadIcon ) const downloadSpeedText = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const downloadSpeedNumber = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const downloadSpeedUnit = videojsUntyped . dom . createEl ( 's' ) downloadSpeedText . appendChild ( downloadSpeedNumber ) downloadSpeedText . appendChild ( downloadSpeedUnit ) subDivWebtorrent . appendChild ( downloadSpeedText ) const uploadIcon = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) subDivWebtorrent . appendChild ( uploadIcon ) const uploadSpeedText = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const uploadSpeedNumber = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const uploadSpeedUnit = videojsUntyped . dom . createEl ( 's' ) uploadSpeedText . appendChild ( uploadSpeedNumber ) uploadSpeedText . appendChild ( uploadSpeedUnit ) subDivWebtorrent . appendChild ( uploadSpeedText ) const peersText = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const peersNumber = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) subDivWebtorrent . appendChild ( peersNumber ) subDivWebtorrent . appendChild ( peersText ) const subDivHttp = videojsUntyped . dom . createEl ( 's' , { className : 's' } ) const subDivHttpText = videojsUntyped . dom . createEl ( 's' , { className : 's' , textContent : 's' } ) subDivHttp . appendChild ( subDivHttpText ) div . appendChild ( subDivHttp ) this . player_ . on ( 's' , ( event , data ) => { if ( ! data ) { subDivHttp . className = 's' subDivWebtorrent . className = 's' return } const 0 = data . 0 const httpStats = data . http const downloadSpeed = bytes ( 0 . downloadSpeed + httpStats . downloadSpeed ) const uploadSpeed = bytes ( 0 . uploadSpeed + httpStats . uploadSpeed ) const totalDownloaded = bytes ( 0 . downloaded + httpStats . downloaded ) const totalUploaded = bytes ( 0 . uploaded + httpStats . uploaded ) const numPeers = 0 . numPeers subDivWebtorrent . title = this . player_ . localize ( 's' ) + totalDownloaded . join ( 's' ) + 's' + this . player_ . localize ( 's' + totalUploaded . join ( 's' ) ) downloadSpeedNumber . textContent = downloadSpeed [ 0 ] downloadSpeedUnit . textContent = 's' + downloadSpeed [ 0 ] uploadSpeedNumber . textContent = uploadSpeed [ 0 ] uploadSpeedUnit . textContent = 's' + uploadSpeed [ 0 ] peersNumber . textContent = numPeers peersText . textContent = 's' + ( numPeers > 0 ? this . player_ . localize ( 's' ) : this . player_ . localize ( 's' ) ) subDivHttp . className = 's' subDivWebtorrent . className = 's' } ) return div } } Button . registerComponent ( 's' , 0 )	O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $PlayerNetworkInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoJSComponentInterface , videojsUntyped } from 's' import { Player } from 's' const Component = videojsUntyped . getComponent ( 's' ) class PeerTubeLoadProgressBar extends Component { partEls_ : any [ ] constructor ( player , options ) { super ( player , options ) this . partEls_ = [ ] this . on ( player , 's' , this . update ) } createEl ( ) { return super . createEl ( 's' , { className : 's' , innerHTML : `template` } ) } dispose ( ) { this . partEls_ = null super . dispose ( ) } update ( ) { const torrent = this . player ( ) . webtorrent ( ) . getTorrent ( ) if ( ! torrent ) return this . el_ . style . width = ( torrent . progress * 0 ) + 's' } } Component . registerComponent ( 's' , PeerTubeLoadProgressBar )	O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O $Player$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as videojs from 's' import { VideoJSComponentInterface , videojsUntyped } from 's' import { saveTheaterInStore , getStoredTheater } from 's' const Button = videojsUntyped . getComponent ( 's' ) class TheaterButton extends Button { private static readonly THEATER_MODE_CLASS = 's' constructor ( player : videojs . Player , options ) { super ( player , options ) const enabled = getStoredTheater ( ) if ( enabled === true ) { this . player_ . addClass ( TheaterButton . THEATER_MODE_CLASS ) this . handleTheaterChange ( ) } this . player_ . theaterEnabled = enabled } buildCSSClass ( ) { return `template` } handleTheaterChange ( ) { const theaterEnabled = this . isTheaterEnabled ( ) if ( theaterEnabled ) { this . controlText ( 's' ) } else { this . controlText ( 's' ) } saveTheaterInStore ( theaterEnabled ) this . player_ . trigger ( 's' , theaterEnabled ) } handleClick ( ) { this . player_ . toggleClass ( TheaterButton . THEATER_MODE_CLASS ) this . handleTheaterChange ( ) } private isTheaterEnabled ( ) { return this . player_ . hasClass ( TheaterButton . THEATER_MODE_CLASS ) } } TheaterButton . prototype . controlText_ = 's' TheaterButton . registerComponent ( 's' , TheaterButton )	O O O O O O O O O O O O O O O O O O O O O O O $VideoJSComponentInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Segment } from 's' import { basename } from 's' function segmentValidatorFactory ( 0 ) { const segmentsJSON = 0 ( 0 ) const regex = "s" return async function segmentValidator ( segment ) { const filename = basename ( segment . url ) const captured = regex . exec ( segment . range ) const range = captured [ 0 ] + 's' + captured [ 0 ] const hashShouldBe = ( await segmentsJSON ) [ filename ] [ range ] if ( hashShouldBe === undefined ) { throw new Error ( `template` ) } const calculatedSha = bufferToEx ( await 0 ( segment . data ) ) if ( calculatedSha !== hashShouldBe ) { throw new Error ( `template` + `template` ) } } } export { segmentValidatorFactory } function 0 ( url ) { return fetch ( url ) . then ( res => res . json ( ) ) . catch ( err => { console . error ( 's' , err ) return { } } ) } function 0 ( data ? ) { if ( ! data ) return undefined return window . crypto . subtle . digest ( 's' , data ) } function bufferToEx ( buffer ? ) { if ( ! buffer ) return 's' let s = 's' const h = 's' const o = new 0 ( buffer ) o . forEach ( ( v ) => s += h [ v >> 0 ] + h [ v & 0 ] ) return s }	O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $Segment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ArrayBuffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ArrayBuffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O
import { Segment } from 's' import { RedundancyUrlManager } from 's' function segmentUrlBuilderFactory ( redundancyUrlManager ) { return function segmentBuilder ( segment ) { return redundancyUrlManager . buildUrl ( segment . url ) } } export { segmentUrlBuilderFactory }	O O O O O O O O O O O O O O O $RedundancyUrlManager$ O O O O O O $Segment$ O O O O O O O O O O O O O O O O O
import { VideoFile } from 's' import * as videojs from 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import { 0 , UserWatching , VideoJSCaption , VideoJSPluginOptions , videojsUntyped } from 's' import { buildVideoEmbed , buildVideoLink , copyToClipboard , getRtcConfig } from 's' import { getCompleteLocale , getShortLocale , 0 , isDefaultLocale } from 's' import { segmentValidatorFactory } from 's' import { segmentUrlBuilderFactory } from 's' import { RedundancyUrlManager } from 's' videojsUntyped . getComponent ( 's' ) . prototype . controlText_ = 's' videojsUntyped . getComponent ( 's' ) . prototype . controlText_ = 's' videojsUntyped . getComponent ( 's' ) . prototype . label_ = 's' export type PlayerMode = 's' | 's' export type WebtorrentOptions = { videoFiles : VideoFile [ ] } export type 0 = { playlistUrl : string 0 : string trackerAnnounce : string [ ] redundancyBaseUrls : string [ ] videoFiles : VideoFile [ ] } export interface CustomizationOptions { startTime : number | string stopTime : number | string controls ? : boolean muted ? : boolean loop ? : boolean subtitle ? : string peertubeLink : boolean } export interface CommonOptions extends CustomizationOptions { playerElement : HTMLVideoElement onPlayerElementChange : ( element ) => void autoplay : boolean videoDuration : number enableHotkeys : boolean inactivityTimeout : number poster : string theaterMode : boolean captions : boolean videoViewUrl : string embedUrl : string language ? : string videoCaptions : VideoJSCaption [ ] userWatching ? : UserWatching serverUrl : string } export type PeertubePlayerManagerOptions = { common : CommonOptions , webtorrent : WebtorrentOptions , 0 ? : 0 } export class PeertubePlayerManager { private static videojsLocaleCache : { [ path ] : any } = { } private static playerElementClassName : string private static onPlayerChange : ( player ) => void static getServerTranslations ( serverUrl , locale ) { const path = PeertubePlayerManager . getLocalePath ( serverUrl , locale ) if ( ! path ) return Promise . resolve ( undefined ) return fetch ( path + 's' ) . then ( res => res . json ( ) ) . catch ( err => { console . error ( 's' , err ) return undefined } ) } static async initialize ( mode , options , onPlayerChange : ( player ) => void ) { let 0 this . onPlayerChange = onPlayerChange this . playerElementClassName = options . common . playerElement . className if ( mode === 's' ) await import ( 's' ) if ( mode === 's' ) { [ 0 ] = await Promise . all ( [ import ( 's' ) , import ( 's' ) ] ) } const videojsOptions = this . getVideojsOptions ( mode , options , 0 ) await this . loadLocaleInVideoJS ( options . common . serverUrl , options . common . language ) const self = this return new Promise ( res => { videojs ( options . common . playerElement , videojsOptions , function ( this ) { const player = this let alreadyFallback = false player . tech_ . one ( 's' , ( ) => { if ( ! alreadyFallback ) self . maybeFallbackToWebTorrent ( mode , player , options ) alreadyFallback = true } ) player . one ( 's' , ( ) => { if ( ! alreadyFallback ) self . maybeFallbackToWebTorrent ( mode , player , options ) alreadyFallback = true } ) self . addContextMenu ( mode , player , options . common . embedUrl ) return res ( player ) } ) } ) } private static async maybeFallbackToWebTorrent ( currentMode , player , options ) { if ( currentMode === 's' ) return console . log ( 's' ) const newVideoElement = document . createElement ( 's' ) newVideoElement . className = this . playerElementClassName let currentParentPlayerElement = options . common . playerElement . parentNode if ( ! currentParentPlayerElement ) currentParentPlayerElement = document . getElementById ( options . common . playerElement . id ) . parentNode currentParentPlayerElement . parentNode . insertBefore ( newVideoElement , currentParentPlayerElement ) options . common . playerElement = newVideoElement options . common . onPlayerElementChange ( newVideoElement ) player . dispose ( ) await import ( 's' ) const mode = 's' const videojsOptions = this . getVideojsOptions ( mode , options ) const self = this videojs ( newVideoElement , videojsOptions , function ( this ) { const player = this self . addContextMenu ( mode , player , options . common . embedUrl ) PeertubePlayerManager . onPlayerChange ( player ) } ) } private static loadLocaleInVideoJS ( serverUrl , locale ) { const path = PeertubePlayerManager . getLocalePath ( serverUrl , locale ) if ( ! path ) return Promise . resolve ( undefined ) let p < any > if ( PeertubePlayerManager . videojsLocaleCache [ path ] ) { p = Promise . resolve ( PeertubePlayerManager . videojsLocaleCache [ path ] ) } else { p = fetch ( path + 's' ) . then ( res => res . json ( ) ) . then ( json => { PeertubePlayerManager . videojsLocaleCache [ path ] = json return json } ) . catch ( err => { console . error ( 's' , err ) return undefined } ) } const completeLocale = getCompleteLocale ( locale ) return p . then ( json => videojs . addLanguage ( getShortLocale ( completeLocale ) , json ) ) } private static getVideojsOptions ( mode , options , 0 ? ) { const commonOptions = options . common const webtorrentOptions = options . webtorrent const 0 = options . 0 let autoplay = options . common . autoplay let 0 = { } const plugins = { peertube : { mode , autoplay , videoViewUrl : commonOptions . videoViewUrl , videoDuration : commonOptions . videoDuration , userWatching : commonOptions . userWatching , subtitle : commonOptions . subtitle , videoCaptions : commonOptions . videoCaptions , stopTime : commonOptions . stopTime } } if ( mode === 's' ) { const redundancyUrlManager = new RedundancyUrlManager ( options . 0 . redundancyBaseUrls ) const 0 = { redundancyUrlManager , type : 's' , startTime : commonOptions . startTime , src : 0 . playlistUrl } const trackerAnnounce = 0 . trackerAnnounce . filter ( t => t . startsWith ( 's' ) ) const 0 = { loader : { trackerAnnounce , segmentValidator : segmentValidatorFactory ( options . 0 . 0 ) , rtcConfig : getRtcConfig ( ) , requiredSegmentsPriority : 0 , segmentUrlBuilder : segmentUrlBuilderFactory ( redundancyUrlManager ) } , segments : { swarmId : 0 . playlistUrl } } const streamrootHls = { levelLabelHandler : ( level : { height : number , width : number } ) => { const file = 0 . videoFiles . find ( f => f . resolution . id === level . height ) let label = file . resolution . label if ( file . fps >= 0 ) label += file . fps return label } , 0 : { hlsjsConfig : { liveSyncDurationCount : 0 , loader : new 0 . Engine ( 0 ) . createLoaderClass ( ) } } } Object . assign ( plugins , { 0 , streamrootHls } ) 0 = streamrootHls . 0 } if ( mode === 's' ) { const webtorrent = { autoplay , videoDuration : commonOptions . videoDuration , playerElement : commonOptions . playerElement , videoFiles : webtorrentOptions . videoFiles , startTime : commonOptions . startTime } Object . assign ( plugins , { webtorrent } ) autoplay = false } const videojsOptions = { 0 , textTrackSettings : false , controls : commonOptions . controls !== undefined ? commonOptions . controls : true , loop : commonOptions . loop !== undefined ? commonOptions . loop : false , muted : commonOptions . muted !== undefined ? commonOptions . muted : undefined , poster : commonOptions . poster , autoplay : autoplay === true ? 's' : autoplay , inactivityTimeout : commonOptions . inactivityTimeout , playbackRates : [ 0 , 0 , 0 , 0 , 0 , 0 ] , plugins , controlBar : { children : this . getControlBarChildren ( mode , { captions : commonOptions . captions , peertubeLink : commonOptions . peertubeLink , theaterMode : commonOptions . theaterMode } ) } } if ( commonOptions . enableHotkeys === true ) { Object . assign ( videojsOptions . plugins , { hotkeys : { enableVolumeScroll : false , enableModifiersForNumbers : false , fullscreenKey : function ( event ) { return event . key === 's' || ( event . ctrlKey && event . key === 's' ) } , seekStep : function ( event ) { if ( event . ctrlKey && event . altKey ) { return 0 * 0 } else if ( event . ctrlKey ) { return 0 } else if ( event . altKey ) { return 0 } else { return 0 } } , customKeys : { increasePlaybackRateKey : { key : function ( event ) { return event . key === 's' } , handler : function ( player : videojs . Player ) { player . playbackRate ( ( player . playbackRate ( ) + 0 ) . toFixed ( 0 ) ) } } , decreasePlaybackRateKey : { key : function ( event ) { return event . key === 's' } , handler : function ( player : videojs . Player ) { player . playbackRate ( ( player . playbackRate ( ) - 0 ) . toFixed ( 0 ) ) } } , frameByFrame : { key : function ( event ) { return event . key === 's' } , handler : function ( player : videojs . Player ) { player . pause ( ) const dist = 0 / 0 player . currentTime ( player . currentTime ( ) + dist ) } } } } } ) } if ( commonOptions . language && ! isDefaultLocale ( commonOptions . language ) ) { Object . assign ( videojsOptions , { language : commonOptions . language } ) } return videojsOptions } private static getControlBarChildren ( mode , options : { peertubeLink : boolean theaterMode : boolean , captions : boolean } ) { const settingEntries = [ ] const loadProgressBar = mode === 's' ? 's' : 's' settingEntries . push ( 's' ) if ( options . captions === true ) settingEntries . push ( 's' ) settingEntries . push ( 's' ) const children = { 's' : { } , 's' : { } , 's' : { } , 's' : { } , 's' : { } , 's' : { } , 's' : { children : { 's' : { children : { [ loadProgressBar ] : { } , 's' : { } , 's' : { } } } } } , 's' : { } , 's' : { } , 's' : { } , 's' : { setup : { maxHeightOffset : 0 } , entries : settingEntries } } if ( options . peertubeLink === true ) { Object . assign ( children , { 's' : { } } ) } if ( options . theaterMode === true ) { Object . assign ( children , { 's' : { } } ) } Object . assign ( children , { 's' : { } } ) return children } private static addContextMenu ( mode , player , videoEmbedUrl ) { const content = [ { label : player . localize ( 's' ) , listener : function ( ) { copyToClipboard ( buildVideoLink ( ) ) } } , { label : player . localize ( 's' ) , listener : function ( ) { const player = this as videojs . Player copyToClipboard ( buildVideoLink ( { startTime : player . currentTime ( ) } ) ) } } , { label : player . localize ( 's' ) , listener : ( ) => { copyToClipboard ( buildVideoEmbed ( videoEmbedUrl ) ) } } ] if ( mode === 's' ) { content . push ( { label : player . localize ( 's' ) , listener : function ( ) { const player = this as videojs . Player copyToClipboard ( player . webtorrent ( ) . getCurrentVideoFile ( ) . magnetUri ) } } ) } player . contextmenuUI ( { content } ) } private static getLocalePath ( serverUrl , locale ) { const completeLocale = getCompleteLocale ( locale ) if ( ! 0 ( completeLocale ) || isDefaultLocale ( completeLocale ) ) return undefined return serverUrl + 's' + completeLocale } } export { videojs }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLVideoElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $any$ O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O $PeertubePlayerManagerOptions$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O $any$ O $PeertubePlayerManagerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O $PeertubePlayerManagerOptions$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoJSPluginOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $P2PMediaLoaderPluginOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { catchError } from 's' import { ChangeDetectorRef , Component , ElementRef , Inject , LOCALE_ID , NgZone , OnDestroy , OnInit , ViewChild } from 's' import { ActivatedRoute , Router } from 's' import { RedirectService } from 's' import { peertubeLocalStorage } from 's' import { VideoSupportComponent } from 's' import { MetaService } from 's' import { Notifier , ServerService } from 's' import { forkJoin , Observable , Subscription } from 's' import { Hotkey , HotkeysService } from 's' import { UserVideoRateType , VideoCaption , VideoPrivacy , VideoState } from 's' import { AuthService , ConfirmService } from 's' import { RestExtractor , VideoBlacklistService } from 's' import { VideoDetails } from 's' import { VideoService } from 's' import { VideoShareComponent } from 's' import { SubscribeButtonComponent } from 's' import { 0 } from 's' import { environment } from 's' import { VideoCaptionService } from 's' import { MarkdownService } from 's' import { CustomizationOptions , 0 , PeertubePlayerManager , PeertubePlayerManagerOptions , PlayerMode } from 's' import { VideoPlaylist } from 's' import { VideoPlaylistService } from 's' import { Video } from 's' import { isWebRTCDisabled , timeToInt } from 's' import { VideoWatchPlaylistComponent } from 's' import { getStoredTheater } from 's' import { PluginService } from 's' import { HooksService } from 's' import { PlatformLocation } from 's' import { randomInt } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoWatchComponent implements OnInit , OnDestroy { private static LOCAL_STORAGE_PRIVACY_CONCERN_KEY = 's' @ ViewChild ( 's' , { static : true } ) videoWatchPlaylist : VideoWatchPlaylistComponent @ ViewChild ( 's' , { static : false } ) videoShareModal : VideoShareComponent @ ViewChild ( 's' , { static : false } ) videoSupportModal : VideoSupportComponent @ ViewChild ( 's' , { static : false } ) subscribeButton : SubscribeButtonComponent player : any playerElement : HTMLVideoElement theaterEnabled = false userRating : UserVideoRateType = null descriptionLoading = false video : VideoDetails = null videoCaptions : VideoCaption [ ] = [ ] playlist : VideoPlaylist = null completeDescriptionShown = false completeVideoDescription : string shortVideoDescription : string videoHTMLDescription = 's' likesBarTooltipText = 's' hasAlreadyAcceptedPrivacyConcern = false remoteServerDown = false hotkeys : Hotkey [ ] private nextVideoUuid = 's' private currentTime : number private paramsSub : Subscription private queryParamsSub : Subscription private configSub : Subscription constructor ( private elementRef , private changeDetector , private route , private router , private videoService , private playlistService , private videoBlacklistService , private confirmService , private metaService , private authService , private serverService , private restExtractor , private notifier , private pluginService , private markdownService , private zone , private redirectService , private videoCaptionService , private 0 , private hotkeysService , private hooks , private location , @ Inject ( LOCALE_ID ) private localeId ) { } get user ( ) { return this . authService . getUser ( ) } async ngOnInit ( ) { this . configSub = this . serverService . configLoaded . subscribe ( ( ) => { if ( isWebRTCDisabled ( ) || this . serverService . getConfig ( ) . tracker . enabled === false || peertubeLocalStorage . getItem ( VideoWatchComponent . LOCAL_STORAGE_PRIVACY_CONCERN_KEY ) === 's' ) { this . hasAlreadyAcceptedPrivacyConcern = true } } ) this . paramsSub = this . route . params . subscribe ( routeParams => { const videoId = routeParams [ 's' ] if ( videoId ) this . loadVideo ( videoId ) const playlistId = routeParams [ 's' ] if ( playlistId ) this . loadPlaylist ( playlistId ) } ) this . queryParamsSub = this . route . queryParams . subscribe ( queryParams => { const videoId = queryParams [ 's' ] if ( videoId ) this . loadVideo ( videoId ) } ) this . initHotkeys ( ) this . theaterEnabled = getStoredTheater ( ) this . hooks . runAction ( 's' , 's' ) } ngOnDestroy ( ) { this . flushPlayer ( ) if ( this . paramsSub ) this . paramsSub . unsubscribe ( ) if ( this . queryParamsSub ) this . queryParamsSub . unsubscribe ( ) if ( this . isUserLoggedIn ( ) ) this . hotkeysService . remove ( this . hotkeys ) } setLike ( ) { if ( this . isUserLoggedIn ( ) === false ) return if ( this . userRating === 's' ) this . setRating ( 's' ) else this . setRating ( 's' ) } setDislike ( ) { if ( this . isUserLoggedIn ( ) === false ) return if ( this . userRating === 's' ) this . setRating ( 's' ) else this . setRating ( 's' ) } showMoreDescription ( ) { if ( this . completeVideoDescription === undefined ) { return this . loadCompleteDescription ( ) } this . updateVideoDescription ( this . completeVideoDescription ) this . completeDescriptionShown = true } showLessDescription ( ) { this . updateVideoDescription ( this . shortVideoDescription ) this . completeDescriptionShown = false } loadCompleteDescription ( ) { this . descriptionLoading = true this . videoService . loadCompleteDescription ( this . video . descriptionPath ) . subscribe ( description => { this . completeDescriptionShown = true this . descriptionLoading = false this . shortVideoDescription = this . video . description this . completeVideoDescription = description this . updateVideoDescription ( this . completeVideoDescription ) } , error => { this . descriptionLoading = false this . notifier . error ( error . message ) } ) } showSupportModal ( ) { this . videoSupportModal . show ( ) } showShareModal ( ) { this . videoShareModal . show ( this . currentTime ) } isUserLoggedIn ( ) { return this . authService . isLoggedIn ( ) } getVideoTags ( ) { if ( ! this . video || Array . isArray ( this . video . tags ) === false ) return [ ] return this . video . tags } onRecommendations ( videos : Video [ ] ) { if ( videos . length > 0 ) { this . nextVideoUuid = videos [ randomInt ( 0 , videos . length - 0 ) ] . uuid } } onVideoRemoved ( ) { this . redirectService . redirectToHomepage ( ) } acceptedPrivacyConcern ( ) { peertubeLocalStorage . setItem ( VideoWatchComponent . LOCAL_STORAGE_PRIVACY_CONCERN_KEY , 's' ) this . hasAlreadyAcceptedPrivacyConcern = true } isVideoToTranscode ( ) { return this . video && this . video . state . id === VideoState . TO_TRANSCODE } isVideoToImport ( ) { return this . video && this . video . state . id === VideoState . TO_IMPORT } hasVideoScheduledPublication ( ) { return this . video && this . video . scheduledUpdate !== undefined } isVideoBlur ( video ) { return video . isVideoNSFWForUser ( this . user , this . serverService . getConfig ( ) ) } private loadVideo ( videoId ) { if ( this . video && this . video . uuid === videoId ) return if ( this . player ) this . player . pause ( ) const videoObs = this . hooks . wrapObsFun ( this . videoService . getVideo . bind ( this . videoService ) , { videoId } , 's' , 's' , 's' ) forkJoin ( [ videoObs , this . videoCaptionService . listCaptions ( videoId ) ] ) . pipe ( catchError ( err => this . restExtractor . 0 ( err , [ 0 , 0 , 0 , 0 ] ) ) ) . subscribe ( ( [ video , captionsResult ] ) => { const queryParams = this . route . snapshot . queryParams const urlOptions = { startTime : queryParams . start , stopTime : queryParams . stop , muted : queryParams . muted , loop : queryParams . loop , subtitle : queryParams . subtitle , playerMode : queryParams . mode , peertubeLink : false } this . onVideoFetched ( video , captionsResult . data , urlOptions ) . catch ( err => this . handleError ( err ) ) } ) } private loadPlaylist ( playlistId ) { if ( this . playlist && this . playlist . uuid === playlistId ) return this . playlistService . getVideoPlaylist ( playlistId ) . pipe ( catchError ( err => this . restExtractor . 0 ( err , [ 0 , 0 , 0 , 0 ] ) ) ) . subscribe ( playlist => { this . playlist = playlist const videoId = this . route . snapshot . queryParams [ 's' ] this . videoWatchPlaylist . loadPlaylistElements ( playlist , ! videoId ) } ) } private updateVideoDescription ( description ) { this . video . description = description this . setVideoDescriptionHTML ( ) . catch ( err => console . error ( err ) ) } private async setVideoDescriptionHTML ( ) { this . videoHTMLDescription = await this . markdownService . textMarkdownToHTML ( this . video . description ) } private setVideoLikesBarTooltipText ( ) { this . likesBarTooltipText = this . 0 ( 's' , { likesNumber : this . video . likes , dislikesNumber : this . video . dislikes } ) } private handleError ( err ) { const errorMessage = typeof err === 's' ? err : err . message if ( ! errorMessage ) return if ( errorMessage . indexOf ( 's' ) !== - 0 ) { this . flushPlayer ( ) this . remoteServerDown = true this . changeDetector . detectChanges ( ) return } this . notifier . error ( errorMessage ) } private checkUserRating ( ) { if ( this . isUserLoggedIn ( ) === false ) return this . videoService . getUserVideoRating ( this . video . id ) . subscribe ( ratingObject => { if ( ratingObject ) { this . userRating = ratingObject . rating } } , err => this . notifier . error ( err . message ) ) } private async onVideoFetched ( video , videoCaptions : VideoCaption [ ] , urlOptions : CustomizationOptions & { playerMode : PlayerMode } ) { this . video = video this . videoCaptions = videoCaptions this . descriptionLoading = false this . completeDescriptionShown = false this . remoteServerDown = false this . currentTime = undefined this . videoWatchPlaylist . updatePlaylistIndex ( video ) let startTime = timeToInt ( urlOptions . startTime ) || ( this . video . userHistory ? this . video . userHistory . currentTime : 0 ) if ( this . video . duration - startTime <= 0 ) startTime = 0 if ( this . isVideoBlur ( this . video ) ) { const res = await this . confirmService . confirm ( this . 0 ( 's' ) , this . 0 ( 's' ) ) if ( res === false ) return this . location . back ( ) } this . flushPlayer ( ) const playerElementWrapper = this . elementRef . nativeElement . querySelector ( 's' ) this . playerElement = document . createElement ( 's' ) this . playerElement . className = 's' this . playerElement . setAttribute ( 's' , 's' ) playerElementWrapper . appendChild ( this . playerElement ) const playerCaptions = videoCaptions . map ( c => ( { label : c . language . label , language : c . language . id , src : environment . apiUrl + c . captionPath } ) ) const options = { common : { autoplay : this . isAutoplay ( ) , playerElement : this . playerElement , onPlayerElementChange : ( element ) => this . playerElement = element , videoDuration : this . video . duration , enableHotkeys : true , inactivityTimeout : 0 , poster : this . video . previewUrl , startTime , stopTime : urlOptions . stopTime , controls : urlOptions . controls , muted : urlOptions . muted , loop : urlOptions . loop , subtitle : urlOptions . subtitle , peertubeLink : urlOptions . peertubeLink , theaterMode : true , captions : videoCaptions . length !== 0 , videoViewUrl : this . video . privacy . id !== VideoPrivacy . PRIVATE ? this . videoService . getVideoViewUrl ( this . video . uuid ) : null , embedUrl : this . video . embedUrl , language : this . localeId , userWatching : this . user && this . user . videosHistoryEnabled === true ? { url : this . videoService . getUserWatchingVideoUrl ( this . video . uuid ) , authorizationHeader : this . authService . getRequestHeaderValue ( ) } : undefined , serverUrl : environment . apiUrl , videoCaptions : playerCaptions } , webtorrent : { videoFiles : this . video . files } } let mode if ( urlOptions . playerMode ) { if ( urlOptions . playerMode === 's' ) mode = 's' else mode = 's' } else { if ( this . video . hasHlsPlaylist ( ) ) mode = 's' else mode = 's' } if ( mode === 's' ) { const hlsPlaylist = this . video . getHlsPlaylist ( ) const 0 = { playlistUrl : hlsPlaylist . playlistUrl , 0 : hlsPlaylist . 0 , redundancyBaseUrls : hlsPlaylist . redundancies . map ( r => r . baseUrl ) , trackerAnnounce : this . video . trackerUrls , videoFiles : this . video . files } as 0 Object . assign ( options , { 0 } ) } this . zone . runOutsideAngular ( async ( ) => { this . player = await PeertubePlayerManager . initialize ( mode , options , player => this . player = player ) this . player . on ( 's' , ( { err } : { err : any } ) => this . handleError ( err ) ) this . player . on ( 's' , ( ) => { this . currentTime = Math . floor ( this . player . currentTime ( ) ) } ) this . player . one ( 's' , ( ) => { if ( this . playlist ) { this . zone . run ( ( ) => this . videoWatchPlaylist . navigateToNextPlaylistVideo ( ) ) } else if ( this . user && this . user . autoPlayNextVideo ) { this . zone . run ( ( ) => this . autoplayNext ( ) ) } } ) this . player . one ( 's' , ( ) => { if ( this . playlist ) { this . zone . run ( ( ) => this . videoWatchPlaylist . navigateToNextPlaylistVideo ( ) ) } } ) this . player . on ( 's' , ( _ , enabled ) => { this . zone . run ( ( ) => this . theaterEnabled = enabled ) } ) } ) this . setVideoDescriptionHTML ( ) this . setVideoLikesBarTooltipText ( ) this . setOpenGraphTags ( ) this . checkUserRating ( ) this . hooks . runAction ( 's' , 's' ) } private autoplayNext ( ) { if ( this . nextVideoUuid ) { this . router . navigate ( [ 's' , this . nextVideoUuid ] ) } } private setRating ( nextRating ) { const ratingMethods : { [ id in UserVideoRateType ] : ( id ) => Observable < any > } = { like : this . videoService . setVideoLike , dislike : this . videoService . setVideoDislike , none : this . videoService . unsetVideoLike } ratingMethods [ nextRating ] . call ( this . videoService , this . video . id ) . subscribe ( ( ) => { this . updateVideoRating ( this . userRating , nextRating ) this . userRating = nextRating } , ( err : { message : string } ) => this . notifier . error ( err . message ) ) } private updateVideoRating ( oldRating , newRating ) { let likesToIncrement = 0 let dislikesToIncrement = 0 if ( oldRating ) { if ( oldRating === 's' ) likesToIncrement -- if ( oldRating === 's' ) dislikesToIncrement -- } if ( newRating === 's' ) likesToIncrement ++ if ( newRating === 's' ) dislikesToIncrement ++ this . video . likes += likesToIncrement this . video . dislikes += dislikesToIncrement this . video . buildLikeAndDislikePercents ( ) this . setVideoLikesBarTooltipText ( ) } private setOpenGraphTags ( ) { this . metaService . setTitle ( this . video . name ) this . metaService . setTag ( 's' , 's' ) this . metaService . setTag ( 's' , this . video . name ) this . metaService . setTag ( 's' , this . video . name ) this . metaService . setTag ( 's' , this . video . description ) this . metaService . setTag ( 's' , this . video . description ) this . metaService . setTag ( 's' , this . video . previewPath ) this . metaService . setTag ( 's' , this . video . duration . toString ( ) ) this . metaService . setTag ( 's' , 's' ) this . metaService . setTag ( 's' , window . location . href ) this . metaService . setTag ( 's' , window . location . href ) } private isAutoplay ( ) { if ( this . route . snapshot . params [ 's' ] ) return false if ( ! this . user ) return true return this . user . autoPlayVideo !== false } private flushPlayer ( ) { if ( this . player ) { try { this . player . dispose ( ) this . player = undefined } catch ( err ) { console . error ( 's' , err ) } } } private initHotkeys ( ) { this . hotkeys = [ new Hotkey ( 's' , ( ) => { this . setLike ( ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( ) => { this . setDislike ( ) return false } , undefined , this . 0 ( 's' ) ) , new Hotkey ( 's' , ( ) => { this . subscribeButton . subscribed ? this . subscribeButton . unsubscribe ( ) : this . subscribeButton . subscribe ( ) return false } , undefined , this . 0 ( 's' ) ) ] if ( this . isUserLoggedIn ( ) ) this . hotkeysService . add ( this . hotkeys ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O $ChangeDetectorRef$ O O $ActivatedRoute$ O O $Router$ O O $VideoService$ O O $VideoPlaylistService$ O O $VideoBlacklistService$ O O $ConfirmService$ O O $MetaService$ O O $AuthService$ O O $ServerService$ O O $RestExtractor$ O O $Notifier$ O O $PluginService$ O O $MarkdownService$ O O $NgZone$ O O $RedirectService$ O O $VideoCaptionService$ O O $I18n$ O O $HotkeysService$ O O $HooksService$ O O $PlatformLocation$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeertubePlayerManagerOptions$ O O O O O O O O O O O O O O O O O O O O O O $HTMLVideoElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlayerMode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserVideoRateType$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserVideoRateType$ O $UserVideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RouterModule , Routes } from 's' import { MetaGuard } from 's' import { VideoWatchComponent } from 's' const videoWatchRoutes = [ { path : 's' , component : VideoWatchComponent , canActivate : [ MetaGuard ] } , { path : 's' , redirectTo : 's' } , { path : 's' , component : VideoWatchComponent , canActivate : [ MetaGuard ] } ] @ NgModule ( { imports : [ RouterModule . forChild ( videoWatchRoutes ) ] , exports : [ RouterModule ] } ) export class VideoWatchRoutingModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Routes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { VideoSupportComponent } from 's' import { SharedModule } from 's' import { VideoCommentAddComponent } from 's' import { VideoCommentComponent } from 's' import { VideoCommentService } from 's' import { VideoCommentsComponent } from 's' import { VideoShareComponent } from 's' import { VideoWatchRoutingModule } from 's' import { VideoWatchComponent } from 's' import { NgbTooltipModule } from 's' import { RecommendationsModule } from 's' import { VideoWatchPlaylistComponent } from 's' import { QRCodeModule } from 's' @ NgModule ( { imports : [ VideoWatchRoutingModule , SharedModule , NgbTooltipModule , QRCodeModule , RecommendationsModule ] , declarations : [ VideoWatchComponent , VideoWatchPlaylistComponent , VideoShareComponent , VideoSupportComponent , VideoCommentsComponent , VideoCommentAddComponent , VideoCommentComponent ] , exports : [ VideoWatchComponent ] , providers : [ VideoCommentService ] } ) export class VideoWatchModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { RecommendationService } from 's' import { Video } from 's' import { RecommendationInfo } from 's' import { VideoService } from 's' import { map , switchMap } from 's' import { Observable , of } from 's' import { SearchService } from 's' import { AdvancedSearch } from 's' @ Injectable ( ) export class RecentVideosRecommendationService implements RecommendationService { readonly pageSize = 0 constructor ( private videos , private searchService ) { } getRecommendations ( recommendation ) < Video [ ] > { return this . fetchPage ( 0 , recommendation ) . pipe ( map ( videos => { const otherVideos = videos . filter ( v => v . uuid !== recommendation . uuid ) return otherVideos . slice ( 0 , this . pageSize ) } ) ) } private fetchPage ( page , recommendation ) < Video [ ] > { const pagination = { currentPage : page , itemsPerPage : this . pageSize + 0 } const defaultSubscription = this . videos . getVideos ( { videoPagination : pagination , sort : 's' } ) . pipe ( map ( v => v . data ) ) if ( ! recommendation . tags || recommendation . tags . length === 0 ) return defaultSubscription const params = { search : 's' , componentPagination : pagination , advancedSearch : new AdvancedSearch ( { tagsOneOf : recommendation . tags . join ( 's' ) , sort : 's' } ) } return this . searchService . searchVideos ( params ) . pipe ( map ( v => v . data ) , switchMap ( videos => { if ( videos . length <= 0 ) return defaultSubscription return of ( videos ) } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoService$ O O $SearchService$ O O O $Observable$ O $RecommendationInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $number$ O $RecommendationInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { RecommendedVideosComponent } from 's' import { RecommendedVideosStore } from 's' import { CommonModule } from 's' import { SharedModule } from 's' import { RecentVideosRecommendationService } from 's' @ NgModule ( { imports : [ SharedModule , CommonModule ] , declarations : [ RecommendedVideosComponent ] , exports : [ RecommendedVideosComponent ] , providers : [ RecommendedVideosStore , RecentVideosRecommendationService ] } ) export class RecommendationsModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Video } from 's' import { RecommendationInfo } from 's' import { Observable } from 's' export interface RecommendationService { getRecommendations ( recommendation ) : Observable < Video [ ] > }	O O O O O O O O O O O O O O O O O O O O O O O O $RecommendationInfo$ O O O O O O O O O
import { Component , Input , Output , OnChanges , EventEmitter } from 's' import { Observable } from 's' import { Video } from 's' import { RecommendationInfo } from 's' import { RecommendedVideosStore } from 's' import { User } from 's' @ Component ( { selector : 's' , templateUrl : 's' } ) export class RecommendedVideosComponent implements OnChanges { @ Input ( ) inputRecommendation : RecommendationInfo @ Input ( ) user : User @ Output ( ) gotRecommendations = new EventEmitter < Video [ ] > ( ) readonly hasVideos$ : Observable < boolean > readonly videos$ : Observable < Video [ ] > constructor ( private store ) { this . videos$ = this . store . recommendations$ this . hasVideos$ = this . store . hasRecommendations$ this . videos$ . subscribe ( videos => this . gotRecommendations . emit ( videos ) ) } public ngOnChanges ( ) { if ( this . inputRecommendation ) { this . store . requestNewRecommendations ( this . inputRecommendation ) } } onVideoRemoved ( ) { this . store . requestNewRecommendations ( this . inputRecommendation ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RecommendedVideosStore$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Inject , Injectable } from 's' import { Observable , ReplaySubject } from 's' import { Video } from 's' import { RecommendationInfo } from 's' import { RecentVideosRecommendationService } from 's' import { RecommendationService } from 's' import { map , shareReplay , switchMap , take } from 's' @ Injectable ( ) export class RecommendedVideosStore { public readonly recommendations$ : Observable < Video [ ] > public readonly hasRecommendations$ : Observable < boolean > private readonly requestsForLoad$$ = new ReplaySubject < RecommendationInfo > ( 0 ) constructor ( @ Inject ( RecentVideosRecommendationService ) private recommendations ) { this . recommendations$ = this . requestsForLoad$$ . pipe ( switchMap ( requestedRecommendation => { return recommendations . getRecommendations ( requestedRecommendation ) . pipe ( take ( 0 ) ) } ) , shareReplay ( ) ) this . hasRecommendations$ = this . recommendations$ . pipe ( map ( otherVideos => otherVideos . length > 0 ) ) } requestNewRecommendations ( recommend ) { this . requestsForLoad$$ . next ( recommend ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RecommendationService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RecommendationInfo$ O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { AbstractVideoList } from 's' import { VideoSortField } from 's' import { VideoService } from 's' import { VideoFilter } from 's' import { 0 } from 's' import { ScreenService } from 's' import { UserRight } from 's' import { Notifier , ServerService } from 's' import { HooksService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoLocalComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string sort = 's' as VideoSortField filter : VideoFilter = 's' useUserVideoLanguagePreferences = true constructor ( protected 0 , protected router , protected serverService , protected route , protected notifier , protected authService , protected screenService , private videoService , private hooks ) { super ( ) this . titlePage = 0 ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) if ( this . authService . isLoggedIn ( ) ) { const user = this . authService . getUser ( ) this . displayModerationBlock = user . hasRight ( UserRight . SEE_ALL_VIDEOS ) } this . generateSyndicationList ( ) } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) const params = { videoPagination : newPagination , sort : this . sort , filter : this . filter , categoryOneOf : this . categoryOneOf , languageOneOf : this . languageOneOf } return this . hooks . wrapObsFun ( this . videoService . getVideos . bind ( this . videoService ) , params , 's' , 's' , 's' ) } generateSyndicationList ( ) { this . syndicationItems = this . videoService . getVideoFeedUrls ( this . sort , this . filter , this . categoryOneOf ) } toggleModerationDisplay ( ) { this . filter = this . filter === 's' ? 's' as 's' : 's' as 's' this . reloadVideos ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $VideoService$ O O $HooksService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { Component , OnInit } from 's' import { AuthService , Notifier } from 's' import { 0 } from 's' import { VideosOverview } from 's' import { OverviewService } from 's' import { Video } from 's' import { ScreenService } from 's' @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class VideoOverviewComponent implements OnInit { overview : VideosOverview = { categories : [ ] , channels : [ ] , tags : [ ] } notResults = false constructor ( private 0 , private notifier , private authService , private overviewService , private screenService ) { } get user ( ) { return this . authService . getUser ( ) } ngOnInit ( ) { this . overviewService . getVideosOverview ( ) . subscribe ( overview => { this . overview = overview if ( this . overview . categories . length === 0 && this . overview . channels . length === 0 && this . overview . tags . length === 0 ) this . notResults = true } , err => this . notifier . error ( err . message ) ) } buildVideoChannelBy ( object : { videos : Video [ ] } ) { return object . videos [ 0 ] . byVideoChannel } buildVideoChannelAvatarUrl ( object : { videos : Video [ ] } ) { return object . videos [ 0 ] . videoChannelAvatarUrl } buildVideos ( videos : Video [ ] ) { const numberOfVideos = this . screenService . getNumberOfAvailableMiniatures ( ) return videos . slice ( 0 , numberOfVideos * 0 ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Notifier$ O O $AuthService$ O O $OverviewService$ O O $ScreenService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , OnDestroy , OnInit } from 's' import { ActivatedRoute , Router } from 's' import { immutableAssign } from 's' import { AuthService } from 's' import { AbstractVideoList } from 's' import { VideoSortField } from 's' import { VideoService } from 's' import { 0 } from 's' import { ScreenService } from 's' import { OwnerDisplayType } from 's' import { Notifier , ServerService } from 's' import { HooksService } from 's' @ Component ( { selector : 's' , styleUrls : [ 's' ] , templateUrl : 's' } ) export class VideoUserSubscriptionsComponent extends AbstractVideoList implements OnInit , OnDestroy { titlePage : string sort = 's' as VideoSortField ownerDisplayType : OwnerDisplayType = 's' groupByDate = true constructor ( protected 0 , protected router , protected serverService , protected route , protected notifier , protected authService , protected screenService , private videoService , private hooks ) { super ( ) this . titlePage = 0 ( 's' ) } ngOnInit ( ) { super . ngOnInit ( ) } ngOnDestroy ( ) { super . ngOnDestroy ( ) } getVideosObservable ( page ) { const newPagination = immutableAssign ( this . pagination , { currentPage : page } ) const params = { videoPagination : newPagination , sort : this . sort } return this . hooks . wrapObsFun ( this . videoService . getUserSubscriptionVideos . bind ( this . videoService ) , params , 's' , 's' , 's' ) } generateSyndicationList ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $I18n$ O O $Router$ O O $ServerService$ O O $ActivatedRoute$ O O $Notifier$ O O $AuthService$ O O $ScreenService$ O O $VideoService$ O O $HooksService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const environment = { production : false , hmr : false , apiUrl : 's' }	O O O O O O O O O O O O O O O O O
export const environment = { production : false , hmr : true , apiUrl : 's' }	O O O O O O O O O O O O O O O O O
export const environment = { production : true , hmr : false , apiUrl : 's' }	O O O O O O O O O O O O O O O O O
import { NgModuleRef , ApplicationRef } from 's' import { createNewHosts } from 's' import { enableDebugTools } from 's' export const hmrBootstrap = ( module , bootstrap : ( ) => Promise < NgModuleRef < any > > ) => { let ngModule < any > module . hot . accept ( ) bootstrap ( ) . then ( mod => { ngModule = mod const applicationRef = ngModule . injector . get ( ApplicationRef ) const componentRef = applicationRef . components [ 0 ] enableDebugTools ( componentRef ) } ) module . hot . dispose ( ( ) => { const appRef = ngModule . injector . get ( ApplicationRef ) const elements = appRef . components . map ( c => c . location . nativeElement ) const makeVisible = createNewHosts ( elements ) ngModule . destroy ( ) makeVisible ( ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $NgModuleRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApplicationRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { enableProdMode , TRANSLATIONS , TRANSLATIONS_FORMAT } from 's' import { platformBrowserDynamic } from 's' import { AppModule } from 's' import { environment } from 's' import { hmrBootstrap } from 's' import { getDevLocale , isOnDevLocale } from 's' import { buildFileLocale } from 's' let providers : any [ ] = [ ] if ( environment . production ) { enableProdMode ( ) } if ( isOnDevLocale ( ) ) { const locale = buildFileLocale ( getDevLocale ( ) ) const translations = require ( `template` ) providers = [ { provide : TRANSLATIONS , useValue : translations } , { provide : TRANSLATIONS_FORMAT , useValue : 's' } ] } const bootstrap = ( ) => platformBrowserDynamic ( ) . bootstrapModule ( AppModule , { providers } ) . then ( bootstrapModule => { if ( navigator . serviceWorker && typeof navigator . serviceWorker . getRegistrations === 's' ) { navigator . serviceWorker . getRegistrations ( ) . then ( registrations => { for ( const registration of registrations ) { registration . unregister ( ) } } ) } return bootstrapModule } ) . catch ( err => { console . error ( err ) return null } ) if ( environment . hmr ) { if ( module [ 's' ] ) { hmrBootstrap ( module , bootstrap ) } else { console . error ( 's' ) console . log ( 's' ) } } else { bootstrap ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' ; ( window as any ) . global = window ; ( window as any ) . process = require ( 's' ) ; ( window as any ) . Buffer = require ( 's' ) . Buffer	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
module . exports = require ( 's' )	O O O O O O O O
module . exports = require ( 's' )	O O O O O O O O
export const NOOP = 0	O O O O O
module . exports = require ( 's' )	O O O O O O O O
export type EventHandler < T > = ( ev : T ) => void export type PlayerEventType = 's' | 's' | 's' | 's' | 's' export interface PeerTubeResolution { id : any label : string src : string active : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventHandler } from 's' interface PlayerEventRegistrar { registrations : Function [ ] } interface PlayerEventRegistrationMap { [ name ] : PlayerEventRegistrar } export class EventRegistrar { private eventRegistrations : PlayerEventRegistrationMap = { } public bindToChannel ( channel : Channel . MessagingChannel ) { for ( const name of Object . keys ( this . eventRegistrations ) ) { channel . bind ( name , ( txn , params ) => this . fire ( name , params ) ) } } public registerTypes ( names : string [ ] ) { for ( const name of names ) { this . eventRegistrations [ name ] = { registrations : [ ] } } } public fire < T > ( name , event : T ) { this . eventRegistrations [ name ] . registrations . forEach ( x => x ( event ) ) } public addListener < T > ( name , handler < T > ) { if ( ! this . eventRegistrations [ name ] ) { console . warn ( `template` ) return false } this . eventRegistrations [ name ] . registrations . push ( handler ) return true } public removeListener < T > ( name , handler < T > ) { if ( ! this . eventRegistrations [ name ] ) return false this . eventRegistrations [ name ] . registrations = this . eventRegistrations [ name ] . registrations . filter ( x => x === handler ) return true } }	O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $EventHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $EventHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { peertubeTranslate , ResultList , ServerConfig , VideoDetails } from 's' import { VideoJSCaption } from 's' import { VideoCaption } from 's' import { 0 , PeertubePlayerManager , PeertubePlayerManagerOptions , PlayerMode } from 's' import { VideoStreamingPlaylistType } from 's' import { PeerTubeEmbedApi } from 's' export class PeerTubeEmbed { videoElement : HTMLVideoElement player : any playerOptions : any api : PeerTubeEmbedApi = null autoplay : boolean controls : boolean muted : boolean loop : boolean subtitle : string enableApi = false startTime : number | string = 0 stopTime : number | string title : boolean warningTitle : boolean bigPlayBackgroundColor : string foregroundColor : string mode : PlayerMode scope = 's' static async main ( ) { const videoContainerId = 's' const embed = new PeerTubeEmbed ( videoContainerId ) await embed . init ( ) } constructor ( private videoContainerId ) { this . videoElement = document . getElementById ( videoContainerId ) as HTMLVideoElement } getVideoUrl ( id ) { return window . location . origin + 's' + id } loadVideoInfo ( videoId ) < Response > { return fetch ( this . getVideoUrl ( videoId ) ) } loadVideoCaptions ( videoId ) < Response > { return fetch ( this . getVideoUrl ( videoId ) + 's' ) } loadConfig ( ) < Response > { return fetch ( 's' ) } removeElement ( element ) { element . parentElement . removeChild ( element ) } displayError ( text , translations ? : { [ id ] : string } ) { if ( this . videoElement ) this . removeElement ( this . videoElement ) const translatedText = peertubeTranslate ( text , translations ) const translatedSorry = peertubeTranslate ( 's' , translations ) document . title = translatedSorry + 's' + translatedText const errorBlock = document . getElementById ( 's' ) errorBlock . style . display = 's' const errorTitle = document . getElementById ( 's' ) errorTitle . innerHTML = peertubeTranslate ( 's' , translations ) const errorText = document . getElementById ( 's' ) errorText . innerHTML = translatedText } videoNotFound ( translations ? : { [ id ] : string } ) { const text = 's' this . displayError ( text , translations ) } videoFetchError ( translations ? : { [ id ] : string } ) { const text = 's' this . displayError ( text , translations ) } getParamToggle ( params , name , defaultValue ? ) { return params . has ( name ) ? ( params . get ( name ) === 's' || params . get ( name ) === 's' ) : defaultValue } getParamString ( params , name , defaultValue ? ) { return params . has ( name ) ? params . get ( name ) : defaultValue } async init ( ) { try { await this . initCore ( ) } catch ( e ) { console . error ( e ) } } private initializeApi ( ) { if ( ! this . enableApi ) return this . api = new PeerTubeEmbedApi ( this ) this . api . initialize ( ) } private loadParams ( ) { try { const params = new URL ( window . location . toString ( ) ) . searchParams this . autoplay = this . getParamToggle ( params , 's' , false ) this . controls = this . getParamToggle ( params , 's' , true ) this . muted = this . getParamToggle ( params , 's' , false ) this . loop = this . getParamToggle ( params , 's' , false ) this . title = this . getParamToggle ( params , 's' , true ) this . enableApi = this . getParamToggle ( params , 's' , this . enableApi ) this . warningTitle = this . getParamToggle ( params , 's' , true ) this . scope = this . getParamString ( params , 's' , this . scope ) this . subtitle = this . getParamString ( params , 's' ) this . startTime = this . getParamString ( params , 's' ) this . stopTime = this . getParamString ( params , 's' ) this . bigPlayBackgroundColor = this . getParamString ( params , 's' ) this . foregroundColor = this . getParamString ( params , 's' ) this . mode = this . getParamString ( params , 's' ) === 's' ? 's' : 's' } catch ( err ) { console . error ( 's' , err ) } } private async initCore ( ) { const urlParts = window . location . pathname . split ( 's' ) const videoId = urlParts [ urlParts . length - 0 ] const [ serverTranslations , videoResponse , captionsResponse , configResponse ] = await Promise . all ( [ PeertubePlayerManager . getServerTranslations ( window . location . origin , navigator . language ) , this . loadVideoInfo ( videoId ) , this . loadVideoCaptions ( videoId ) , this . loadConfig ( ) ] ) if ( ! videoResponse . ok ) { if ( videoResponse . status === 0 ) return this . videoNotFound ( serverTranslations ) return this . videoFetchError ( serverTranslations ) } const videoInfo = await videoResponse . json ( ) const videoCaptions = await this . buildCaptions ( serverTranslations , captionsResponse ) this . loadParams ( ) const options = { common : { autoplay : this . autoplay , controls : this . controls , muted : this . muted , loop : this . loop , captions : videoCaptions . length !== 0 , startTime : this . startTime , stopTime : this . stopTime , subtitle : this . subtitle , videoCaptions , inactivityTimeout : 0 , videoViewUrl : this . getVideoUrl ( videoId ) + 's' , playerElement : this . videoElement , onPlayerElementChange : ( element ) => this . videoElement = element , videoDuration : videoInfo . duration , enableHotkeys : true , peertubeLink : true , poster : window . location . origin + videoInfo . previewPath , theaterMode : false , serverUrl : window . location . origin , language : navigator . language , embedUrl : window . location . origin + videoInfo . embedPath } , webtorrent : { videoFiles : videoInfo . files } } if ( this . mode === 's' ) { const hlsPlaylist = videoInfo . streamingPlaylists . find ( p => p . type === VideoStreamingPlaylistType . HLS ) Object . assign ( options , { 0 : { playlistUrl : hlsPlaylist . playlistUrl , 0 : hlsPlaylist . 0 , redundancyBaseUrls : hlsPlaylist . redundancies . map ( r => r . baseUrl ) , trackerAnnounce : videoInfo . trackerUrls , videoFiles : videoInfo . files } as 0 } ) } this . player = await PeertubePlayerManager . initialize ( this . mode , options , player => this . player = player ) this . player . on ( 's' , ( event , data ) => this . handleError ( data . err , serverTranslations ) ) window [ 's' ] = this . player this . buildCSS ( ) await this . buildDock ( videoInfo , configResponse ) this . initializeApi ( ) } private handleError ( err , translations ? : { [ id ] : string } ) { if ( err . message . indexOf ( 's' ) !== - 0 ) { this . player . dispose ( ) this . videoElement = null this . displayError ( 's' , translations ) return } } private async buildDock ( videoInfo , configResponse ) { if ( this . controls ) { const title = this . title ? videoInfo . name : undefined const config = await configResponse . json ( ) const description = config . tracker . enabled && this . warningTitle ? 's' + this . player . localize ( 's' ) + 's' : undefined this . player . dock ( { title , description } ) } } private buildCSS ( ) { const body = document . getElementById ( 's' ) if ( this . bigPlayBackgroundColor ) { body . style . setProperty ( 's' , this . bigPlayBackgroundColor ) } if ( this . foregroundColor ) { body . style . setProperty ( 's' , this . foregroundColor ) } } private async buildCaptions ( serverTranslations , captionsResponse ) < VideoJSCaption [ ] > { if ( captionsResponse . ok ) { const { data } = ( await captionsResponse . json ( ) ) as ResultList < VideoCaption > return data . map ( c => ( { label : peertubeTranslate ( c . language . label , serverTranslations ) , language : c . language . id , src : window . location . origin + c . captionPath } ) ) } return [ ] } } PeerTubeEmbed . main ( ) . catch ( err => console . error ( 's' , err ) )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $URLSearchParams$ O $string$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $URLSearchParams$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $PeertubePlayerManagerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLVideoElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as Channel from 's' import { PeerTubeResolution } from 's' import { PeerTubeEmbed } from 's' export class PeerTubeEmbedApi { private channel : Channel . MessagingChannel private isReady = false private resolutions : PeerTubeResolution [ ] = null constructor ( private embed ) { } initialize ( ) { this . constructChannel ( ) this . setupStateTracking ( ) this . notifyReady ( ) } private get element ( ) { return this . embed . videoElement } private constructChannel ( ) { const channel = Channel . build ( { window : window . parent , origin : 's' , scope : this . embed . scope } ) channel . bind ( 's' , ( txn , params ) => this . embed . player . play ( ) ) channel . bind ( 's' , ( txn , params ) => this . embed . player . pause ( ) ) channel . bind ( 's' , ( txn , time ) => this . embed . player . currentTime ( time ) ) channel . bind ( 's' , ( txn , value ) => this . embed . player . volume ( value ) ) channel . bind ( 's' , ( txn , value ) => this . embed . player . volume ( ) ) channel . bind ( 's' , ( txn , params ) => this . isReady ) channel . bind ( 's' , ( txn , resolutionId ) => this . setResolution ( resolutionId ) ) channel . bind ( 's' , ( txn , params ) => this . resolutions ) channel . bind ( 's' , ( txn , playbackRate ) => this . embed . player . playbackRate ( playbackRate ) ) channel . bind ( 's' , ( txn , params ) => this . embed . player . playbackRate ( ) ) channel . bind ( 's' , ( txn , params ) => this . embed . playerOptions . playbackRates ) this . channel = channel } private setResolution ( resolutionId ) { if ( resolutionId === - 0 && this . embed . player . webtorrent ( ) . isAutoResolutionForbidden ( ) ) return if ( resolutionId === - 0 ) { this . embed . player . webtorrent ( ) . enableAutoResolution ( ) return } this . embed . player . webtorrent ( ) . disableAutoResolution ( ) this . embed . player . webtorrent ( ) . updateResolution ( resolutionId ) } private notifyReady ( ) { this . isReady = true this . channel . notify ( { method : 's' , params : true } ) } private setupStateTracking ( ) { let currentState : 's' | 's' | 's' = 's' setInterval ( ( ) => { const position = this . element . currentTime const volume = this . element . volume this . channel . notify ( { method : 's' , params : { position , volume , playbackState : currentState } } ) } , 0 ) this . element . addEventListener ( 's' , ev => { currentState = 's' this . channel . notify ( { method : 's' , params : 's' } ) } ) this . element . addEventListener ( 's' , ev => { currentState = 's' this . channel . notify ( { method : 's' , params : 's' } ) } ) if ( this . embed . player . webtorrent ) { this . embed . player . webtorrent ( ) . on ( 's' , ( ) => this . loadWebTorrentResolutions ( ) ) this . embed . player . webtorrent ( ) . on ( 's' , ( ) => this . loadWebTorrentResolutions ( ) ) } } private loadWebTorrentResolutions ( ) { const resolutions = [ ] const currentResolutionId = this . embed . player . webtorrent ( ) . getCurrentResolutionId ( ) for ( const videoFile of this . embed . player . webtorrent ( ) . videoFiles ) { let label = videoFile . resolution . label if ( videoFile . fps && videoFile . fps >= 0 ) { label += videoFile . fps } resolutions . push ( { id : videoFile . resolution . id , label , src : videoFile . magnetUri , active : videoFile . resolution . id === currentResolutionId } ) } this . resolutions = resolutions this . channel . notify ( { method : 's' , params : this . resolutions } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubeEmbed$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { PeerTubePlayer } from 's' import { PeerTubeResolution , PlayerEventType } from 's' window . addEventListener ( 's' , async ( ) => { const urlParts = window . location . href . split ( 's' ) const lastPart = urlParts [ urlParts . length - 0 ] const videoId = lastPart . indexOf ( 's' ) === - 0 ? lastPart : lastPart . split ( 's' ) [ 0 ] const iframe = document . createElement ( 's' ) iframe . src = `template` const mainElement = document . querySelector ( 's' ) mainElement . appendChild ( iframe ) console . log ( `template` ) const player = new PeerTubePlayer ( document . querySelector ( 's' ) ) window [ 's' ] = player console . log ( `template` ) await player . ready console . log ( `template` ) const monitoredEvents = [ 's' , 's' , 's' , 's' ] monitoredEvents . forEach ( e => { player . addEventListener ( e as PlayerEventType , ( ) => console . log ( `template` ) ) console . log ( `template` ) } ) let playbackRates : number [ ] = [ ] let currentRate = await player . getPlaybackRate ( ) const updateRates = async ( ) => { const rateListEl = document . querySelector ( 's' ) rateListEl . innerHTML = 's' playbackRates . forEach ( rate => { if ( currentRate === rate ) { const itemEl = document . createElement ( 's' ) itemEl . innerText = `template` itemEl . style . display = 's' rateListEl . appendChild ( itemEl ) } else { const itemEl = document . createElement ( 's' ) itemEl . href = 's' itemEl . innerText = rate . toString ( ) itemEl . addEventListener ( 's' , ( ) => { player . setPlaybackRate ( rate ) currentRate = rate updateRates ( ) } ) itemEl . style . display = 's' rateListEl . appendChild ( itemEl ) } } ) } player . getPlaybackRates ( ) . then ( rates => { playbackRates = rates updateRates ( ) } ) const updateResolutions = ( ( resolutions : PeerTubeResolution [ ] ) => { const resolutionListEl = document . querySelector ( 's' ) resolutionListEl . innerHTML = 's' resolutions . forEach ( resolution => { if ( resolution . active ) { const itemEl = document . createElement ( 's' ) itemEl . innerText = `template` itemEl . style . display = 's' resolutionListEl . appendChild ( itemEl ) } else { const itemEl = document . createElement ( 's' ) itemEl . href = 's' itemEl . innerText = resolution . label itemEl . addEventListener ( 's' , ( ) => { player . setResolution ( resolution . id ) } ) itemEl . style . display = 's' resolutionListEl . appendChild ( itemEl ) } } ) } ) player . getResolutions ( ) . then ( resolutions => updateResolutions ( resolutions ) ) player . addEventListener ( 's' , resolutions => updateResolutions ( resolutions ) ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) const ROOT = path . resolve ( __dirname , 's' ) const EVENT = process . env . npm_lifecycle_event || 's' function hasProcessFlag ( flag ) { return process . argv . join ( 's' ) . indexOf ( flag ) > - 0 } function hasNpmFlag ( flag ) { return EVENT . includes ( flag ) } function isWebpackDevServer ( ) { return process . argv [ 0 ] && ! ! ( "s" . exec ( process . argv [ 0 ] ) ) } function root ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) return path . join . apply ( path , [ ROOT ] . concat ( args ) ) } exports . hasProcessFlag = hasProcessFlag exports . hasNpmFlag = hasNpmFlag exports . isWebpackDevServer = isWebpackDevServer exports . root = root	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const helpers = require ( 's' ) const path = require ( 's' ) const CheckerPlugin = require ( 's' ) . CheckerPlugin const HtmlWebpackPlugin = require ( 's' ) const TerserPlugin = require ( 's' ) const LoaderOptionsPlugin = require ( 's' ) const ExtractTextPlugin = require ( 's' ) const PurifyCSSPlugin = require ( 's' ) module . exports = function ( ) { const configuration = { entry : { 's' : 's' , 's' : 's' , 's' : 's' } , resolve : { extensions : [ 's' , 's' , 's' , 's' ] , modules : [ helpers . root ( 's' ) , helpers . root ( 's' ) ] , alias : { 's' : path . resolve ( 's' ) } } , output : { path : helpers . root ( 's' ) , filename : 's' , sourceMapFilename : 's' , chunkFilename : 's' , publicPath : 's' } , devtool : process . env . NODE_ENV === 's' ? false : 's' , module : { rules : [ { test : "s" , use : [ { loader : 's' , options : { configFileName : 's' } } ] , exclude : [ "s" ] } , { test : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : [ { loader : 's' , options : { sourceMap : true , importLoaders : 0 } } , { loader : 's' , options : { sourceMap : true , includePaths : [ helpers . root ( 's' ) ] } } ] } ) } , { test : "s" , use : 's' , exclude : [ helpers . root ( 's' ) , helpers . root ( 's' ) , helpers . root ( 's' ) ] } , { test : "s" , use : 's' } , { test : "s" , use : 's' } , { test : "s" , use : 's' } ] } , plugins : [ new ExtractTextPlugin ( { filename : 's' } ) , new PurifyCSSPlugin ( { paths : [ helpers . root ( 's' ) , helpers . root ( 's' ) ] , purifyOptions : { minify : true , whitelist : [ 's' , 's' ] } } ) , new CheckerPlugin ( ) , new HtmlWebpackPlugin ( { template : 's' , filename : 's' , title : 's' , chunksSortMode : 's' , inject : 's' , chunks : [ 's' ] } ) , new HtmlWebpackPlugin ( { template : 's' , filename : 's' , title : 's' , chunksSortMode : 's' , inject : 's' , chunks : [ 's' ] } ) , new LoaderOptionsPlugin ( { options : { context : __dirname , output : { path : helpers . root ( 's' ) } } } ) ] , optimization : { minimizer : [ new TerserPlugin ( { terserOptions : { ecma : 0 , warnings : false , 0 : false , mangle : true , compress : { passes : 0 , pure_getters : true } , output : { ascii_only : true , comments : false } } } ) ] } , performance : { maxEntrypointSize : 0 , maxAssetSize : 0 } , node : { global : true , crypto : 's' , fs : 's' , process : true , module : false , clearImmediate : false , setImmediate : false } } return configuration }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { createHash , 0 , pseudoRandomBytes } from 's' import { basename , isAbsolute , join , resolve } from 's' import * as pem from 's' import { URL } from 's' import { truncate } from 's' import { exec , ExecOptions } from 's' const objectConverter = ( oldObject , keyConverter : ( e ) => string , valueConverter : ( e ) => any ) => { if ( ! oldObject || typeof oldObject !== 's' ) { return valueConverter ( oldObject ) } if ( Array . isArray ( oldObject ) ) { return oldObject . map ( e => objectConverter ( e , keyConverter , valueConverter ) ) } const newObject = { } Object . keys ( oldObject ) . forEach ( oldKey => { const newKey = keyConverter ( oldKey ) newObject [ newKey ] = objectConverter ( oldObject [ oldKey ] , keyConverter , valueConverter ) } ) return newObject } const timeTable = { ms : 0 , second : 0 , minute : 0 , hour : 0 , day : 0 * 0 , week : 0 * 0 * 0 , month : 0 * 0 * 0 } export function parseDurationToMs ( duration : number | string ) { if ( typeof duration === 's' ) return duration if ( typeof duration === 's' ) { const split = duration . match ( "s" ) if ( split . length === 0 ) { const len = parseFloat ( split [ 0 ] ) let unit = split [ 0 ] . replace ( "s" , 's' ) . toLowerCase ( ) if ( unit === 's' ) { unit = 's' } return ( len || 0 ) * ( timeTable [ unit ] || 0 ) } } throw new Error ( `template` ) } export function parseBytes ( value : string | number ) { if ( typeof value === 's' ) return value const tgm = "s" const tg = "s" const tm = "s" const gm = "s" const t = "s" const g = "s" const m = "s" const b = "s" let match if ( value . match ( tgm ) ) { match = value . match ( tgm ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 * 0 + parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 + parseInt ( match [ 0 ] , 0 ) * 0 * 0 } else if ( value . match ( tg ) ) { match = value . match ( tg ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 * 0 + parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 } else if ( value . match ( tm ) ) { match = value . match ( tm ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 * 0 + parseInt ( match [ 0 ] , 0 ) * 0 * 0 } else if ( value . match ( gm ) ) { match = value . match ( gm ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 + parseInt ( match [ 0 ] , 0 ) * 0 * 0 } else if ( value . match ( t ) ) { match = value . match ( t ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 * 0 } else if ( value . match ( g ) ) { match = value . match ( g ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 * 0 } else if ( value . match ( m ) ) { match = value . match ( m ) return parseInt ( match [ 0 ] , 0 ) * 0 * 0 } else if ( value . match ( b ) ) { match = value . match ( b ) return parseInt ( match [ 0 ] , 0 ) * 0 } else { return parseInt ( value , 0 ) } } function sanitizeUrl ( url ) { const urlObject = new URL ( url ) if ( urlObject . protocol === 's' && urlObject . port === 's' ) { urlObject . port = 's' } else if ( urlObject . protocol === 's' && urlObject . port === 's' ) { urlObject . port = 's' } return urlObject . href . replace ( "s" , 's' ) } function sanitizeHost ( host , remoteScheme ) { const toRemove = remoteScheme === 's' ? 0 : 0 return host . replace ( new RegExp ( `template` ) , 's' ) } function isTestInstance ( ) { return process . env . NODE_ENV === 's' } function isProdInstance ( ) { return process . env . NODE_ENV === 's' } function getAppNumber ( ) { return process . env . NODE_APP_INSTANCE } let rootPath function root ( ) { if ( rootPath ) return rootPath rootPath = join ( __dirname , 's' , 's' ) if ( basename ( rootPath ) === 's' ) rootPath = resolve ( rootPath , 's' ) return rootPath } function escapeHTML ( stringParam ) { if ( ! stringParam ) return 's' const entityMap = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } return String ( stringParam ) . replace ( "s" , s => entityMap [ s ] ) } function pageToStartAndCount ( page , itemsPerPage ) { const start = ( page - 0 ) * itemsPerPage return { start , count : itemsPerPage } } function buildPath ( path ) { if ( isAbsolute ( path ) ) return path return join ( root ( ) , path ) } function peertubeTruncate ( str , maxLength ) { const options = { length : maxLength } const truncatedStr = truncate ( str , options ) if ( truncatedStr . length <= maxLength ) return truncatedStr options . length -= truncatedStr . length - maxLength return truncate ( str , options ) } function 0 ( str : string | Buffer , encoding = 's' ) { return createHash ( 's' ) . update ( str ) . digest ( encoding ) } function 0 ( str : string | Buffer , encoding = 's' ) { return createHash ( 's' ) . update ( str ) . digest ( encoding ) } function execShell ( command , options ? ) { return new Promise < { err ? : Error , stdout : string , stderr : string } > ( ( res , rej ) => { exec ( command , options , ( err , stdout , stderr ) => { if ( err ) return rej ( { err , stdout , stderr } ) return res ( { stdout , stderr } ) } ) } ) } function 0 < A > ( func : ( cb : ( err , result : A ) => void ) => void ) : ( ) => Promise < A > { return function promisified ( ) : Promise < A > { return new Promise < A > ( ( resolve : ( arg : A ) => void , reject : ( err ) => void ) => { func . apply ( null , [ ( err , res : A ) => err ? reject ( err ) : resolve ( res ) ] ) } ) } } function 0 < T , A > ( func : ( arg : T , cb : ( err , result : A ) => void ) => void ) : ( arg : T ) => Promise < A > { return function promisified ( arg : T ) : Promise < A > { return new Promise < A > ( ( resolve : ( arg : A ) => void , reject : ( err ) => void ) => { func . apply ( null , [ arg , ( err , res : A ) => err ? reject ( err ) : resolve ( res ) ] ) } ) } } function 0 < T > ( func : ( arg : T , cb : ( err ) => void ) => void ) : ( arg : T ) => Promise < void > { return function promisified ( arg : T ) : Promise < void > { return new Promise < void > ( ( resolve : ( ) => void , reject : ( err ) => void ) => { func . apply ( null , [ arg , ( err ) => err ? reject ( err ) : resolve ( ) ] ) } ) } } function 0 < T , U , A > ( func : ( 0 : T , 0 : U , cb : ( err , result : A ) => void ) => void ) : ( 0 : T , 0 : U ) => Promise < A > { return function promisified ( 0 : T , 0 : U ) : Promise < A > { return new Promise < A > ( ( resolve : ( arg : A ) => void , reject : ( err ) => void ) => { func . apply ( null , [ 0 , 0 , ( err , res : A ) => err ? reject ( err ) : resolve ( res ) ] ) } ) } } function 0 < T , U > ( func : ( 0 : T , 0 : U , cb : ( err ) => void ) => void ) : ( 0 : T , 0 : U ) => Promise < void > { return function promisified ( 0 : T , 0 : U ) : Promise < void > { return new Promise < void > ( ( resolve : ( ) => void , reject : ( err ) => void ) => { func . apply ( null , [ 0 , 0 , ( err ) => err ? reject ( err ) : resolve ( ) ] ) } ) } } const pseudoRandomBytesPromise = 0 < number , Buffer > ( pseudoRandomBytes ) const createPrivateKey = 0 < number , { key : string } > ( pem . createPrivateKey ) const getPublicKey = 0 < string , { publicKey : string } > ( pem . getPublicKey ) const 0 = 0 < string , any , string > ( exec ) const execPromise = 0 < string , string > ( exec ) export { isTestInstance , isProdInstance , getAppNumber , objectConverter , root , escapeHTML , pageToStartAndCount , sanitizeUrl , sanitizeHost , buildPath , execShell , peertubeTruncate , 0 , 0 , 0 , 0 , 0 , pseudoRandomBytesPromise , createPrivateKey , getPublicKey , 0 , execPromise }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HexBase64Latin1Encoding$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HexBase64Latin1Encoding$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $ExecOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IConfig } from 's' import { dirname , join } from 's' import { VideosRedundancy } from 's' import { buildPath , parseBytes , parseDurationToMs , root } from 's' import { NSFWPolicyType } from 's' import * as bytes from 's' let config = require ( 's' ) const configChangedHandlers : Function [ ] = [ ] const CONFIG = { CUSTOM_FILE : getLocalConfigFilePath ( ) , LISTEN : { PORT : config . get < number > ( 's' ) , HOSTNAME : config . get < string > ( 's' ) } , DATABASE : { DBNAME : 's' + config . get < string > ( 's' ) , HOSTNAME : config . get < string > ( 's' ) , PORT : config . get < number > ( 's' ) , USERNAME : config . get < string > ( 's' ) , PASSWORD : config . get < string > ( 's' ) , POOL : { MAX : config . get < number > ( 's' ) } } , REDIS : { HOSTNAME : config . has ( 's' ) ? config . get < string > ( 's' ) : null , PORT : config . has ( 's' ) ? config . get < number > ( 's' ) : null , SOCKET : config . has ( 's' ) ? config . get < string > ( 's' ) : null , AUTH : config . has ( 's' ) ? config . get < string > ( 's' ) : null , DB : config . has ( 's' ) ? config . get < number > ( 's' ) : null } , SMTP : { HOSTNAME : config . get < string > ( 's' ) , PORT : config . get < number > ( 's' ) , USERNAME : config . get < string > ( 's' ) , PASSWORD : config . get < string > ( 's' ) , TLS : config . get < boolean > ( 's' ) , DISABLE_STARTTLS : config . get < boolean > ( 's' ) , CA_FILE : config . get < string > ( 's' ) , FROM_ADDRESS : config . get < string > ( 's' ) } , EMAIL : { BODY : { SIGNATURE : config . get < string > ( 's' ) } , SUBJECT : { PREFIX : config . get < string > ( 's' ) + 's' } } , STORAGE : { TMP_DIR : buildPath ( config . get < string > ( 's' ) ) , AVATARS_DIR : buildPath ( config . get < string > ( 's' ) ) , LOG_DIR : buildPath ( config . get < string > ( 's' ) ) , VIDEOS_DIR : buildPath ( config . get < string > ( 's' ) ) , STREAMING_PLAYLISTS_DIR : buildPath ( config . get < string > ( 's' ) ) , REDUNDANCY_DIR : buildPath ( config . get < string > ( 's' ) ) , THUMBNAILS_DIR : buildPath ( config . get < string > ( 's' ) ) , PREVIEWS_DIR : buildPath ( config . get < string > ( 's' ) ) , CAPTIONS_DIR : buildPath ( config . get < string > ( 's' ) ) , TORRENTS_DIR : buildPath ( config . get < string > ( 's' ) ) , CACHE_DIR : buildPath ( config . get < string > ( 's' ) ) , PLUGINS_DIR : buildPath ( config . get < string > ( 's' ) ) } , WEBSERVER : { SCHEME : config . get < boolean > ( 's' ) === true ? 's' : 's' , WS : config . get < boolean > ( 's' ) === true ? 's' : 's' , HOSTNAME : config . get < string > ( 's' ) , PORT : config . get < number > ( 's' ) } , RATES_LIMIT : { API : { WINDOW_MS : parseDurationToMs ( config . get < string > ( 's' ) ) , MAX : config . get < number > ( 's' ) } , SIGNUP : { WINDOW_MS : parseDurationToMs ( config . get < string > ( 's' ) ) , MAX : config . get < number > ( 's' ) } , LOGIN : { WINDOW_MS : parseDurationToMs ( config . get < string > ( 's' ) ) , MAX : config . get < number > ( 's' ) } , ASK_SEND_EMAIL : { WINDOW_MS : parseDurationToMs ( config . get < string > ( 's' ) ) , MAX : config . get < number > ( 's' ) } } , TRUST_PROXY : config . get < string [ ] > ( 's' ) , LOG : { LEVEL : config . get < string > ( 's' ) , ROTATION : config . get < boolean > ( 's' ) } , SEARCH : { REMOTE_URI : { USERS : config . get < boolean > ( 's' ) , ANONYMOUS : config . get < boolean > ( 's' ) } } , TRENDING : { VIDEOS : { INTERVAL_DAYS : config . get < number > ( 's' ) } } , REDUNDANCY : { VIDEOS : { CHECK_INTERVAL : parseDurationToMs ( config . get < string > ( 's' ) ) , STRATEGIES : buildVideosRedundancy ( config . get < any [ ] > ( 's' ) ) } } , CSP : { ENABLED : config . get < boolean > ( 's' ) , REPORT_ONLY : config . get < boolean > ( 's' ) , REPORT_URI : config . get < boolean > ( 's' ) } , TRACKER : { ENABLED : config . get < boolean > ( 's' ) , PRIVATE : config . get < boolean > ( 's' ) , REJECT_TOO_MANY_ANNOUNCES : config . get < boolean > ( 's' ) } , HISTORY : { VIDEOS : { MAX_AGE : parseDurationToMs ( config . get ( 's' ) ) } } , VIEWS : { VIDEOS : { REMOTE : { MAX_AGE : parseDurationToMs ( config . get ( 's' ) ) } } } , PLUGINS : { INDEX : { ENABLED : config . get < boolean > ( 's' ) , CHECK_LATEST_VERSIONS_INTERVAL : parseDurationToMs ( config . get < string > ( 's' ) ) , URL : config . get < string > ( 's' ) } } , ADMIN : { get EMAIL ( ) { return config . get < string > ( 's' ) } } , CONTACT_FORM : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } , SIGNUP : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } , get LIMIT ( ) { return config . get < number > ( 's' ) } , get REQUIRES_EMAIL_VERIFICATION ( ) { return config . get < boolean > ( 's' ) } , FILTERS : { CIDR : { get WHITELIST ( ) { return config . get < string [ ] > ( 's' ) } , get BLACKLIST ( ) { return config . get < string [ ] > ( 's' ) } } } } , USER : { get VIDEO_QUOTA ( ) { return parseBytes ( config . get < number > ( 's' ) ) } , get VIDEO_QUOTA_DAILY ( ) { return parseBytes ( config . get < number > ( 's' ) ) } } , TRANSCODING : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } , get ALLOW_ADDITIONAL_EXTENSIONS ( ) { return config . get < boolean > ( 's' ) } , get ALLOW_AUDIO_FILES ( ) { return config . get < boolean > ( 's' ) } , get THREADS ( ) { return config . get < number > ( 's' ) } , RESOLUTIONS : { get 's' ( ) { return config . get < boolean > ( 's' ) } , get 's' ( ) { return config . get < boolean > ( 's' ) } , get 's' ( ) { return config . get < boolean > ( 's' ) } , get 's' ( ) { return config . get < boolean > ( 's' ) } , get 's' ( ) { return config . get < boolean > ( 's' ) } , get 's' ( ) { return config . get < boolean > ( 's' ) } } , HLS : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } } , IMPORT : { VIDEOS : { HTTP : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } , TORRENT : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } } } , AUTO_BLACKLIST : { VIDEOS : { OF_USERS : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } } } , CACHE : { PREVIEWS : { get SIZE ( ) { return config . get < number > ( 's' ) } } , VIDEO_CAPTIONS : { get SIZE ( ) { return config . get < number > ( 's' ) } } } , INSTANCE : { get NAME ( ) { return config . get < string > ( 's' ) } , get SHORT_DESCRIPTION ( ) { return config . get < string > ( 's' ) } , get DESCRIPTION ( ) { return config . get < string > ( 's' ) } , get TERMS ( ) { return config . get < string > ( 's' ) } , get CODE_OF_CONDUCT ( ) { return config . get < string > ( 's' ) } , get CREATION_REASON ( ) { return config . get < string > ( 's' ) } , get MODERATION_INFORMATION ( ) { return config . get < string > ( 's' ) } , get ADMINISTRATOR ( ) { return config . get < string > ( 's' ) } , get MAINTENANCE_LIFETIME ( ) { return config . get < string > ( 's' ) } , get BUSINESS_MODEL ( ) { return config . get < string > ( 's' ) } , get HARDWARE_INFORMATION ( ) { return config . get < string > ( 's' ) } , get LANGUAGES ( ) { return config . get < string [ ] > ( 's' ) || [ ] } , get CATEGORIES ( ) { return config . get < number [ ] > ( 's' ) || [ ] } , get IS_NSFW ( ) { return config . get < boolean > ( 's' ) } , get DEFAULT_CLIENT_ROUTE ( ) { return config . get < string > ( 's' ) } , get DEFAULT_NSFW_POLICY ( ) { return config . get < NSFWPolicyType > ( 's' ) } , CUSTOMIZATIONS : { get JAVASCRIPT ( ) { return config . get < string > ( 's' ) } , get CSS ( ) { return config . get < string > ( 's' ) } } , get ROBOTS ( ) { return config . get < string > ( 's' ) } , get SECURITYTXT ( ) { return config . get < string > ( 's' ) } , get SECURITYTXT_CONTACT ( ) { return config . get < string > ( 's' ) } } , SERVICES : { TWITTER : { get USERNAME ( ) { return config . get < string > ( 's' ) } , get WHITELISTED ( ) { return config . get < boolean > ( 's' ) } } } , FOLLOWERS : { INSTANCE : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } , get MANUAL_APPROVAL ( ) { return config . get < boolean > ( 's' ) } } } , FOLLOWINGS : { INSTANCE : { AUTO_FOLLOW_BACK : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } } , AUTO_FOLLOW_INDEX : { get ENABLED ( ) { return config . get < boolean > ( 's' ) } , get INDEX_URL ( ) { return config . get < string > ( 's' ) } } } } , THEME : { get DEFAULT ( ) { return config . get < string > ( 's' ) } } } function registerConfigChangedHandler ( fun ) { configChangedHandlers . push ( fun ) } export { CONFIG , registerConfigChangedHandler } function getLocalConfigFilePath ( ) { const configSources = config . util . getConfigSources ( ) if ( configSources . length === 0 ) throw new Error ( 's' ) let filename = 's' if ( process . env . NODE_ENV ) filename += `template` if ( process . env . NODE_APP_INSTANCE ) filename += `template` return join ( dirname ( configSources [ 0 ] . name ) , filename + 's' ) } function buildVideosRedundancy ( objs : any [ ] ) : VideosRedundancy [ ] { if ( ! objs ) return [ ] if ( ! Array . isArray ( objs ) ) return objs return objs . map ( obj => { return Object . assign ( { } , obj , { minLifetime : parseDurationToMs ( obj . min_lifetime ) , size : bytes . parse ( obj . size ) , minViews : obj . min_views } ) } ) } export function reloadConfig ( ) { function directory ( ) { if ( process . env . NODE_CONFIG_DIR ) { return process . env . NODE_CONFIG_DIR } return join ( root ( ) , 's' ) } function purge ( ) { for ( const fileName in require . cache ) { if ( - 0 === fileName . indexOf ( directory ( ) ) ) { continue } delete require . cache [ fileName ] } delete require . cache [ require . resolve ( 's' ) ] } purge ( ) config = require ( 's' ) for ( const configChangedHandler of configChangedHandlers ) { configChangedHandler ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { join } from 's' import { JobType , VideoRateType , VideoResolution , VideoState } from 's' import { ActivityPubActorType } from 's' import { FollowState } from 's' import { VideoAbuseState , VideoImportState , VideoPrivacy , VideoTranscodingFPS } from 's' import { isTestInstance , sanitizeHost , sanitizeUrl , root , parseDurationToMs } from 's' import { NSFWPolicyType } from 's' import { invert } from 's' import { CronRepeatOptions , EveryRepeatOptions } from 's' import { VideoPlaylistPrivacy } from 's' import { VideoPlaylistType } from 's' import { CONFIG , registerConfigChangedHandler } from 's' const LAST_MIGRATION_VERSION = 0 const API_VERSION = 's' const PEERTUBE_VERSION = require ( join ( root ( ) , 's' ) ) . version const PAGINATION = { COUNT : { DEFAULT : 0 , MAX : 0 } } const WEBSERVER = { URL : 's' , HOST : 's' , SCHEME : 's' , WS : 's' , HOSTNAME : 's' , PORT : 0 } const SORTABLE_COLUMNS = { USERS : [ 's' , 's' , 's' , 's' ] , USER_SUBSCRIPTIONS : [ 's' , 's' ] , ACCOUNTS : [ 's' ] , JOBS : [ 's' ] , VIDEO_ABUSES : [ 's' , 's' , 's' ] , VIDEO_CHANNELS : [ 's' , 's' , 's' , 's' ] , VIDEO_IMPORTS : [ 's' ] , VIDEO_COMMENT_THREADS : [ 's' ] , VIDEO_RATES : [ 's' ] , BLACKLISTS : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , FOLLOWERS : [ 's' ] , FOLLOWING : [ 's' ] , VIDEOS : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , VIDEOS_SEARCH : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , VIDEO_CHANNELS_SEARCH : [ 's' , 's' , 's' ] , ACCOUNTS_BLOCKLIST : [ 's' ] , SERVERS_BLOCKLIST : [ 's' ] , USER_NOTIFICATIONS : [ 's' ] , VIDEO_PLAYLISTS : [ 's' , 's' , 's' ] , PLUGINS : [ 's' , 's' , 's' ] , AVAILABLE_PLUGINS : [ 's' , 's' ] } const OAUTH_LIFETIME = { ACCESS_TOKEN : 0 * 0 , REFRESH_TOKEN : 0 } const ROUTE_CACHE_LIFETIME = { FEEDS : 's' , ROBOTS : 's' , SITEMAP : 's' , SECURITYTXT : 's' , NODEINFO : 's' , DNT_POLICY : 's' , OVERVIEWS : { VIDEOS : 's' } , ACTIVITY_PUB : { VIDEOS : 's' } , STATS : 's' } const ACTOR_FOLLOW_SCORE = { PENALTY : - 0 , BONUS : 0 , BASE : 0 , MAX : 0 } const FOLLOW_STATES : { [ id ] : FollowState } = { PENDING : 's' , ACCEPTED : 's' } const REMOTE_SCHEME = { HTTP : 's' , WS : 's' } const JOB_ATTEMPTS : { [ id in ( JobType | 's' ) ] : number } = { 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 } const JOB_CONCURRENCY : { [ id in ( JobType | 's' ) ] : number } = { 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 , 's' : 0 } const JOB_TTL : { [ id in ( JobType | 's' ) ] : number } = { 's' : 0 * 0 , 's' : 0 * 0 , 's' : 0 * 0 , 's' : 0 * 0 , 's' : 0 * 0 , 's' : 0 * 0 * 0 , 's' : 0 * 0 * 0 , 's' : 0 * 0 * 0 , 's' : 0 * 0 , 's' : undefined , 's' : 0 * 0 } const REPEAT_JOBS : { [ id ] : EveryRepeatOptions | CronRepeatOptions } = { 's' : { cron : 's' } } const BROADCAST_CONCURRENCY = 0 const CRAWL_REQUEST_CONCURRENCY = 0 const JOB_REQUEST_TIMEOUT = 0 const JOB_COMPLETED_LIFETIME = 0 * 0 * 0 * 0 const VIDEO_IMPORT_TIMEOUT = 0 * 0 const SCHEDULER_INTERVALS_MS = { actorFollowScores : 0 * 0 , removeOldJobs : 0 * 0 , updateVideos : 0 , youtubeDLUpdate : 0 * 0 * 0 , checkPlugins : CONFIG . PLUGINS . INDEX . CHECK_LATEST_VERSIONS_INTERVAL , autoFollowIndexInstances : 0 * 0 * 0 , removeOldViews : 0 * 0 * 0 , removeOldHistory : 0 * 0 * 0 } const INSTANCES_INDEX = { HOSTS_PATH : 's' } const CONSTRAINTS_FIELDS = { USERS : { NAME : { min : 0 , max : 0 } , DESCRIPTION : { min : 0 , max : 0 } , USERNAME : { min : 0 , max : 0 } , PASSWORD : { min : 0 , max : 0 } , VIDEO_QUOTA : { min : - 0 } , VIDEO_QUOTA_DAILY : { min : - 0 } , VIDEO_LANGUAGES : { max : 0 } , BLOCKED_REASON : { min : 0 , max : 0 } } , VIDEO_ABUSES : { REASON : { min : 0 , max : 0 } , MODERATION_COMMENT : { min : 0 , max : 0 } } , VIDEO_BLACKLIST : { REASON : { min : 0 , max : 0 } } , VIDEO_CHANNELS : { NAME : { min : 0 , max : 0 } , DESCRIPTION : { min : 0 , max : 0 } , SUPPORT : { min : 0 , max : 0 } , URL : { min : 0 , max : 0 } } , VIDEO_CAPTIONS : { CAPTION_FILE : { EXTNAME : [ 's' , 's' ] , FILE_SIZE : { max : 0 * 0 * 0 } } } , VIDEO_IMPORTS : { URL : { min : 0 , max : 0 } , TORRENT_NAME : { min : 0 , max : 0 } , TORRENT_FILE : { EXTNAME : [ 's' ] , FILE_SIZE : { max : 0 * 0 } } } , VIDEOS_REDUNDANCY : { URL : { min : 0 , max : 0 } } , VIDEO_RATES : { URL : { min : 0 , max : 0 } } , VIDEOS : { NAME : { min : 0 , max : 0 } , LANGUAGE : { min : 0 , max : 0 } , TRUNCATED_DESCRIPTION : { min : 0 , max : 0 } , DESCRIPTION : { min : 0 , max : 0 } , SUPPORT : { min : 0 , max : 0 } , IMAGE : { EXTNAME : [ 's' , 's' ] , FILE_SIZE : { max : 0 * 0 * 0 } } , EXTNAME : [ ] as string [ ] , INFO_HASH : { min : 0 , max : 0 } , DURATION : { min : 0 } , TAGS : { min : 0 , max : 0 } , TAG : { min : 0 , max : 0 } , THUMBNAIL : { min : 0 , max : 0 } , THUMBNAIL_DATA : { min : 0 , max : 0 } , VIEWS : { min : 0 } , LIKES : { min : 0 } , DISLIKES : { min : 0 } , FILE_SIZE : { min : 0 } , URL : { min : 0 , max : 0 } } , VIDEO_PLAYLISTS : { NAME : { min : 0 , max : 0 } , DESCRIPTION : { min : 0 , max : 0 } , URL : { min : 0 , max : 0 } , IMAGE : { EXTNAME : [ 's' , 's' ] , FILE_SIZE : { max : 0 * 0 * 0 } } } , ACTORS : { PUBLIC_KEY : { min : 0 , max : 0 } , PRIVATE_KEY : { min : 0 , max : 0 } , URL : { min : 0 , max : 0 } , AVATAR : { EXTNAME : [ 's' , 's' , 's' ] , FILE_SIZE : { max : 0 * 0 * 0 } } } , VIDEO_EVENTS : { COUNT : { min : 0 } } , VIDEO_COMMENTS : { TEXT : { min : 0 , max : 0 } , URL : { min : 0 , max : 0 } } , VIDEO_SHARE : { URL : { min : 0 , max : 0 } } , CONTACT_FORM : { FROM_NAME : { min : 0 , max : 0 } , BODY : { min : 0 , max : 0 } } , PLUGINS : { NAME : { min : 0 , max : 0 } , DESCRIPTION : { min : 0 , max : 0 } } } let VIDEO_VIEW_LIFETIME = 0 * 0 let CONTACT_FORM_LIFETIME = 0 * 0 const VIDEO_TRANSCODING_FPS = { MIN : 0 , AVERAGE : 0 , MAX : 0 , KEEP_ORIGIN_FPS_RESOLUTION_MIN : 0 } const DEFAULT_AUDIO_RESOLUTION = VideoResolution . 0 const VIDEO_RATE_TYPES : { [ id ] : VideoRateType } = { LIKE : 's' , DISLIKE : 's' } const FFMPEG_NICE : { [ id ] : number } = { THUMBNAIL : 0 , TRANSCODING : 0 } const VIDEO_CATEGORIES = { 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' } const VIDEO_LICENCES = { 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' , 0 : 's' } let VIDEO_LANGUAGES : { [ id ] : string } = { } const VIDEO_PRIVACIES = { [ VideoPrivacy . PUBLIC ] : 's' , [ VideoPrivacy . UNLISTED ] : 's' , [ VideoPrivacy . PRIVATE ] : 's' } const VIDEO_STATES = { [ VideoState . PUBLISHED ] : 's' , [ VideoState . TO_TRANSCODE ] : 's' , [ VideoState . TO_IMPORT ] : 's' } const VIDEO_IMPORT_STATES = { [ VideoImportState . FAILED ] : 's' , [ VideoImportState . PENDING ] : 's' , [ VideoImportState . SUCCESS ] : 's' } const VIDEO_ABUSE_STATES = { [ VideoAbuseState . PENDING ] : 's' , [ VideoAbuseState . REJECTED ] : 's' , [ VideoAbuseState . ACCEPTED ] : 's' } const VIDEO_PLAYLIST_PRIVACIES = { [ VideoPlaylistPrivacy . PUBLIC ] : 's' , [ VideoPlaylistPrivacy . UNLISTED ] : 's' , [ VideoPlaylistPrivacy . PRIVATE ] : 's' } const VIDEO_PLAYLIST_TYPES = { [ VideoPlaylistType . REGULAR ] : 's' , [ VideoPlaylistType . WATCH_LATER ] : 's' } const MIMETYPES = { AUDIO : { MIMETYPE_EXT : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } , EXT_MIMETYPE : null as { [ id ] : string } } , VIDEO : { MIMETYPE_EXT : null as { [ id ] : string } , EXT_MIMETYPE : null as { [ id ] : string } } , IMAGE : { MIMETYPE_EXT : { 's' : 's' , 's' : 's' , 's' : 's' } } , VIDEO_CAPTIONS : { MIMETYPE_EXT : { 's' : 's' , 's' : 's' } } , TORRENT : { MIMETYPE_EXT : { 's' : 's' } } } MIMETYPES . AUDIO . EXT_MIMETYPE = invert ( MIMETYPES . AUDIO . MIMETYPE_EXT ) const OVERVIEWS = { VIDEOS : { SAMPLE_THRESHOLD : 0 , SAMPLES_COUNT : 0 } } const SERVER_ACTOR_NAME = 's' const ACTIVITY_PUB = { POTENTIAL_ACCEPT_HEADERS : [ 's' , 's' , 's' ] , ACCEPT_HEADER : 's' , PUBLIC : 's' , COLLECTION_ITEMS_PER_PAGE : 0 , FETCH_PAGE_LIMIT : 0 , URL_MIME_TYPES : { VIDEO : [ ] as string [ ] , TORRENT : [ 's' ] , MAGNET : [ 's' ] } , MAX_RECURSION_COMMENTS : 0 , ACTOR_REFRESH_INTERVAL : 0 * 0 * 0 * 0 , VIDEO_REFRESH_INTERVAL : 0 * 0 * 0 * 0 , VIDEO_PLAYLIST_REFRESH_INTERVAL : 0 * 0 * 0 * 0 } const ACTIVITY_PUB_ACTOR_TYPES : { [ id ] : ActivityPubActorType } = { GROUP : 's' , PERSON : 's' , APPLICATION : 's' } const HTTP_SIGNATURE = { HEADER_NAME : 's' , ALGORITHM : 's' , HEADERS_TO_SIGN : [ 's' , 's' , 's' , 's' ] } let PRIVATE_RSA_KEY_SIZE = 0 const BCRYPT_SALT_SIZE = 0 const USER_PASSWORD_RESET_LIFETIME = 0 * 0 const USER_EMAIL_VERIFY_LIFETIME = 0 * 0 const NSFW_POLICY_TYPES : { [ id ] : NSFWPolicyType } = { DO_NOT_LIST : 's' , BLUR : 's' , DISPLAY : 's' } const STATIC_PATHS = { PREVIEWS : 's' , THUMBNAILS : 's' , TORRENTS : 's' , WEBSEED : 's' , REDUNDANCY : 's' , STREAMING_PLAYLISTS : { HLS : 's' } , AVATARS : 's' , VIDEO_CAPTIONS : 's' } const STATIC_DOWNLOAD_PATHS = { TORRENTS : 's' , VIDEOS : 's' } const LAZY_STATIC_PATHS = { AVATARS : 's' , PREVIEWS : 's' , VIDEO_CAPTIONS : 's' } let STATIC_MAX_AGE = { SERVER : 's' , CLIENT : 's' } const THUMBNAILS_SIZE = { width : 0 , height : 0 } const PREVIEWS_SIZE = { width : 0 , height : 0 } const AVATARS_SIZE = { width : 0 , height : 0 } const EMBED_SIZE = { width : 0 , height : 0 } const FILES_CACHE = { PREVIEWS : { DIRECTORY : join ( CONFIG . STORAGE . CACHE_DIR , 's' ) , MAX_AGE : 0 * 0 * 0 } , VIDEO_CAPTIONS : { DIRECTORY : join ( CONFIG . STORAGE . CACHE_DIR , 's' ) , MAX_AGE : 0 * 0 * 0 } } const LRU_CACHE = { USER_TOKENS : { MAX_SIZE : 0 } , AVATAR_STATIC : { MAX_SIZE : 0 } } const HLS_STREAMING_PLAYLIST_DIRECTORY = join ( CONFIG . STORAGE . STREAMING_PLAYLISTS_DIR , 's' ) const HLS_REDUNDANCY_DIRECTORY = join ( CONFIG . STORAGE . REDUNDANCY_DIR , 's' ) const MEMOIZE_TTL = { OVERVIEWS_SAMPLE : 0 * 0 * 0 } const QUEUE_CONCURRENCY = { AVATAR_PROCESS_IMAGE : 0 } const REDUNDANCY = { VIDEOS : { RANDOMIZED_FACTOR : 0 } } const ACCEPT_HEADERS = [ 's' , 's' ] . concat ( ACTIVITY_PUB . POTENTIAL_ACCEPT_HEADERS ) const ASSETS_PATH = { DEFAULT_AUDIO_BACKGROUND : join ( root ( ) , 's' , 's' , 's' ) } const CUSTOM_HTML_TAG_COMMENTS = { TITLE : 's' , DESCRIPTION : 's' , CUSTOM_CSS : 's' , META_TAGS : 's' } const FEEDS = { COUNT : 0 } const MAX_LOGS_OUTPUT_CHARACTERS = 0 * 0 * 0 const TRACKER_RATE_LIMITS = { INTERVAL : 0 * 0 , ANNOUNCES_PER_IP_PER_INFOHASH : 0 , ANNOUNCES_PER_IP : 0 } const 0 = 0 const PLUGIN_GLOBAL_CSS_FILE_NAME = 's' const PLUGIN_GLOBAL_CSS_PATH = join ( CONFIG . STORAGE . TMP_DIR , PLUGIN_GLOBAL_CSS_FILE_NAME ) const DEFAULT_THEME_NAME = 's' const DEFAULT_USER_THEME_NAME = 's' if ( isTestInstance ( ) === true ) { PRIVATE_RSA_KEY_SIZE = 0 ACTOR_FOLLOW_SCORE . BASE = 0 REMOTE_SCHEME . HTTP = 's' REMOTE_SCHEME . WS = 's' STATIC_MAX_AGE . SERVER = 's' ACTIVITY_PUB . COLLECTION_ITEMS_PER_PAGE = 0 ACTIVITY_PUB . ACTOR_REFRESH_INTERVAL = 0 * 0 ACTIVITY_PUB . VIDEO_REFRESH_INTERVAL = 0 * 0 ACTIVITY_PUB . VIDEO_PLAYLIST_REFRESH_INTERVAL = 0 * 0 CONSTRAINTS_FIELDS . ACTORS . AVATAR . FILE_SIZE . max = 0 * 0 SCHEDULER_INTERVALS_MS . actorFollowScores = 0 SCHEDULER_INTERVALS_MS . removeOldJobs = 0 SCHEDULER_INTERVALS_MS . removeOldHistory = 0 SCHEDULER_INTERVALS_MS . removeOldViews = 0 SCHEDULER_INTERVALS_MS . updateVideos = 0 SCHEDULER_INTERVALS_MS . autoFollowIndexInstances = 0 REPEAT_JOBS [ 's' ] = { every : 0 } REDUNDANCY . VIDEOS . RANDOMIZED_FACTOR = 0 VIDEO_VIEW_LIFETIME = 0 CONTACT_FORM_LIFETIME = 0 JOB_ATTEMPTS [ 's' ] = 0 FILES_CACHE . VIDEO_CAPTIONS . MAX_AGE = 0 MEMOIZE_TTL . OVERVIEWS_SAMPLE = 0 ROUTE_CACHE_LIFETIME . OVERVIEWS . VIDEOS = 's' } updateWebserverUrls ( ) updateWebserverConfig ( ) registerConfigChangedHandler ( ( ) => { updateWebserverUrls ( ) updateWebserverConfig ( ) } ) export { WEBSERVER , API_VERSION , PEERTUBE_VERSION , LAZY_STATIC_PATHS , HLS_REDUNDANCY_DIRECTORY , 0 , AVATARS_SIZE , ACCEPT_HEADERS , BCRYPT_SALT_SIZE , TRACKER_RATE_LIMITS , FILES_CACHE , CONSTRAINTS_FIELDS , EMBED_SIZE , REDUNDANCY , JOB_CONCURRENCY , JOB_ATTEMPTS , LAST_MIGRATION_VERSION , OAUTH_LIFETIME , CUSTOM_HTML_TAG_COMMENTS , BROADCAST_CONCURRENCY , PAGINATION , ACTOR_FOLLOW_SCORE , PREVIEWS_SIZE , REMOTE_SCHEME , FOLLOW_STATES , INSTANCES_INDEX , DEFAULT_USER_THEME_NAME , SERVER_ACTOR_NAME , PLUGIN_GLOBAL_CSS_FILE_NAME , PLUGIN_GLOBAL_CSS_PATH , PRIVATE_RSA_KEY_SIZE , ROUTE_CACHE_LIFETIME , SORTABLE_COLUMNS , HLS_STREAMING_PLAYLIST_DIRECTORY , FEEDS , JOB_TTL , DEFAULT_THEME_NAME , NSFW_POLICY_TYPES , STATIC_MAX_AGE , STATIC_PATHS , VIDEO_IMPORT_TIMEOUT , VIDEO_PLAYLIST_TYPES , MAX_LOGS_OUTPUT_CHARACTERS , ACTIVITY_PUB , ACTIVITY_PUB_ACTOR_TYPES , THUMBNAILS_SIZE , VIDEO_CATEGORIES , VIDEO_LANGUAGES , VIDEO_PRIVACIES , VIDEO_LICENCES , VIDEO_STATES , QUEUE_CONCURRENCY , VIDEO_RATE_TYPES , VIDEO_TRANSCODING_FPS , FFMPEG_NICE , VIDEO_ABUSE_STATES , LRU_CACHE , JOB_REQUEST_TIMEOUT , USER_PASSWORD_RESET_LIFETIME , MEMOIZE_TTL , USER_EMAIL_VERIFY_LIFETIME , OVERVIEWS , SCHEDULER_INTERVALS_MS , REPEAT_JOBS , STATIC_DOWNLOAD_PATHS , MIMETYPES , CRAWL_REQUEST_CONCURRENCY , DEFAULT_AUDIO_RESOLUTION , JOB_COMPLETED_LIFETIME , HTTP_SIGNATURE , VIDEO_IMPORT_STATES , VIDEO_VIEW_LIFETIME , CONTACT_FORM_LIFETIME , VIDEO_PLAYLIST_PRIVACIES , ASSETS_PATH , loadLanguages , buildLanguages } function buildVideoMimetypeExt ( ) { const data = { 's' : 's' , 's' : 's' , 's' : 's' } if ( CONFIG . TRANSCODING . ENABLED ) { if ( CONFIG . TRANSCODING . ALLOW_ADDITIONAL_EXTENSIONS ) { Object . assign ( data , { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } ) } if ( CONFIG . TRANSCODING . ALLOW_AUDIO_FILES ) { Object . assign ( data , MIMETYPES . AUDIO . MIMETYPE_EXT ) } } return data } function updateWebserverUrls ( ) { WEBSERVER . URL = sanitizeUrl ( CONFIG . WEBSERVER . SCHEME + 's' + CONFIG . WEBSERVER . HOSTNAME + 's' + CONFIG . WEBSERVER . PORT ) WEBSERVER . HOST = sanitizeHost ( CONFIG . WEBSERVER . HOSTNAME + 's' + CONFIG . WEBSERVER . PORT , REMOTE_SCHEME . HTTP ) WEBSERVER . SCHEME = CONFIG . WEBSERVER . SCHEME WEBSERVER . WS = CONFIG . WEBSERVER . WS WEBSERVER . HOSTNAME = CONFIG . WEBSERVER . HOSTNAME WEBSERVER . PORT = CONFIG . WEBSERVER . PORT } function updateWebserverConfig ( ) { MIMETYPES . VIDEO . MIMETYPE_EXT = buildVideoMimetypeExt ( ) MIMETYPES . VIDEO . EXT_MIMETYPE = invert ( MIMETYPES . VIDEO . MIMETYPE_EXT ) ACTIVITY_PUB . URL_MIME_TYPES . VIDEO = Object . keys ( MIMETYPES . VIDEO . MIMETYPE_EXT ) CONSTRAINTS_FIELDS . VIDEOS . EXTNAME = buildVideosExtname ( ) } function buildVideosExtname ( ) { return Object . keys ( MIMETYPES . VIDEO . EXT_MIMETYPE ) } function loadLanguages ( ) { Object . assign ( VIDEO_LANGUAGES , buildLanguages ( ) ) } function buildLanguages ( ) { const 0 = require ( 's' ) const languages : { [ id ] : string } = { } const additionalLanguages = { 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true } 0 . filter ( l => { return ( l . 0 !== null && l . type === 's' ) || additionalLanguages [ l . 0 ] === true } ) . forEach ( l => languages [ l . 0 || l . 0 ] = l . name ) languages [ 's' ] = 's' languages [ 's' ] = 's' return languages }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTranscodingFPS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as validator from 's' import { sep } from 's' function exists ( value ) { return value !== undefined && value !== null } function isSafePath ( p ) { return exists ( p ) && ( p + 's' ) . split ( sep ) . every ( part => { return [ 's' ] . includes ( part ) === false } ) } function isArray ( value ) { return Array . isArray ( value ) } function isNotEmptyIntArray ( value ) { return Array . isArray ( value ) && value . every ( v => validator . isInt ( 's' + v ) ) && value . length !== 0 } function isArrayOf ( value , validator : ( value ) => boolean ) { return isArray ( value ) && value . every ( v => validator ( v ) ) } function isDateValid ( value ) { return exists ( value ) && validator . 0 ( value ) } function isIdValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) } function isUUIDValid ( value ) { return exists ( value ) && validator . isUUID ( 's' + value , 0 ) } function isIdOrUUIDValid ( value ) { return isIdValid ( value ) || isUUIDValid ( value ) } function isBooleanValid ( value ) { return typeof value === 's' || ( typeof value === 's' && validator . isBoolean ( value ) ) } function toIntOrNull ( value ) { const v = toValueOrNull ( value ) if ( v === null || v === undefined ) return v if ( typeof v === 's' ) return v return validator . toInt ( 's' + v ) } function toBooleanOrNull ( value ) { const v = toValueOrNull ( value ) if ( v === null || v === undefined ) return v if ( typeof v === 's' ) return v return validator . toBoolean ( 's' + v ) } function toValueOrNull ( value ) { if ( value === 's' ) return null return value } function toArray ( value ) { if ( value && isArray ( value ) === false ) return [ value ] return value } function toIntArray ( value ) { if ( ! value ) return [ ] if ( isArray ( value ) === false ) return [ validator . toInt ( value ) ] return value . map ( v => validator . toInt ( v ) ) } function isFileValid ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] , mimeTypeRegex , field , maxSize : number | null , optional = false ) { if ( ! files ) return optional if ( isArray ( files ) ) return optional const fileArray = files [ field ] if ( ! fileArray || fileArray . length === 0 ) { return optional } const file = fileArray [ 0 ] if ( ! file || ! file . originalname ) return false if ( ( maxSize !== null ) && file . size > maxSize ) return false return new RegExp ( `template` , 's' ) . test ( file . mimetype ) } export { exists , isArrayOf , isNotEmptyIntArray , isArray , isIdValid , isSafePath , isUUIDValid , isIdOrUUIDValid , isDateValid , toValueOrNull , toBooleanOrNull , isBooleanValid , toIntOrNull , toArray , toIntArray , isFileValid }	O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { CONSTRAINTS_FIELDS } from 's' import { isTestInstance } from 's' import { exists } from 's' function isUrlValid ( url ) { const isURLOptions = { require_host : true , require_tld : true , require_protocol : true , require_valid_protocol : true , protocols : [ 's' , 's' ] } if ( isTestInstance ( ) ) { isURLOptions . require_tld = false } return exists ( url ) && validator . isURL ( 's' + url , isURLOptions ) } function isActivityPubUrlValid ( url ) { return isUrlValid ( url ) && validator . isLength ( 's' + url , CONSTRAINTS_FIELDS . ACTORS . URL ) } function isBaseActivityValid ( activity , type ) { return activity . type === type && isActivityPubUrlValid ( activity . id ) && isObjectValid ( activity . actor ) && isUrlCollectionValid ( activity . to ) && isUrlCollectionValid ( activity . cc ) } function isUrlCollectionValid ( collection ) { return collection === undefined || ( Array . isArray ( collection ) && collection . every ( t => isActivityPubUrlValid ( t ) ) ) } function isObjectValid ( object ) { return exists ( object ) && ( isActivityPubUrlValid ( object ) || isActivityPubUrlValid ( object . id ) ) } function setValidAttributedTo ( obj ) { if ( Array . isArray ( obj . attributedTo ) === false ) { obj . attributedTo = [ ] return true } obj . attributedTo = obj . attributedTo . filter ( a => { return ( a . type === 's' || a . type === 's' ) && isActivityPubUrlValid ( a . id ) } ) return true } export { isUrlValid , isActivityPubUrlValid , isBaseActivityValid , setValidAttributedTo , isObjectValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { values } from 's' import * as validator from 's' import { VideoFilter , VideoPrivacy , VideoRateType } from 's' import { CONSTRAINTS_FIELDS , MIMETYPES , VIDEO_CATEGORIES , VIDEO_LICENCES , VIDEO_PRIVACIES , VIDEO_RATE_TYPES , VIDEO_STATES } from 's' import { exists , isArray , isDateValid , isFileValid } from 's' import * as magnetUtil from 's' const VIDEOS_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . VIDEOS function isVideoFilterValid ( filter ) { return filter === 's' || filter === 's' } function isVideoCategoryValid ( value ) { return value === null || VIDEO_CATEGORIES [ value ] !== undefined } function isVideoStateValid ( value ) { return exists ( value ) && VIDEO_STATES [ value ] !== undefined } function isVideoLicenceValid ( value ) { return value === null || VIDEO_LICENCES [ value ] !== undefined } function isVideoLanguageValid ( value ) { return value === null || ( typeof value === 's' && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . LANGUAGE ) ) } function isVideoDurationValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' , VIDEOS_CONSTRAINTS_FIELDS . DURATION ) } function isVideoTruncatedDescriptionValid ( value ) { return exists ( value ) && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . TRUNCATED_DESCRIPTION ) } function isVideoDescriptionValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . DESCRIPTION ) ) } function isVideoSupportValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . SUPPORT ) ) } function isVideoNameValid ( value ) { return exists ( value ) && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . NAME ) } function isVideoTagValid ( tag ) { return exists ( tag ) && validator . isLength ( tag , VIDEOS_CONSTRAINTS_FIELDS . TAG ) } function isVideoTagsValid ( tags : string [ ] ) { return tags === null || ( isArray ( tags ) && validator . isInt ( tags . length . toString ( ) , VIDEOS_CONSTRAINTS_FIELDS . TAGS ) && tags . every ( tag => isVideoTagValid ( tag ) ) ) } function isVideoViewsValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' , VIDEOS_CONSTRAINTS_FIELDS . VIEWS ) } function isVideoRatingTypeValid ( value ) { return value === 's' || values ( VIDEO_RATE_TYPES ) . indexOf ( value as VideoRateType ) !== - 0 } function isVideoFileExtnameValid ( value ) { return exists ( value ) && MIMETYPES . VIDEO . EXT_MIMETYPE [ value ] !== undefined } function isVideoFile ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] ) { const videoFileTypesRegex = Object . keys ( MIMETYPES . VIDEO . MIMETYPE_EXT ) . map ( m => `template` ) . join ( 's' ) return isFileValid ( files , videoFileTypesRegex , 's' , null ) } const videoImageTypes = CONSTRAINTS_FIELDS . VIDEOS . IMAGE . EXTNAME . map ( v => v . replace ( 's' , 's' ) ) . join ( 's' ) const videoImageTypesRegex = `template` function isVideoImage ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] , field ) { return isFileValid ( files , videoImageTypesRegex , field , CONSTRAINTS_FIELDS . VIDEOS . IMAGE . FILE_SIZE . max , true ) } function isVideoPrivacyValid ( value ) { return VIDEO_PRIVACIES [ value ] !== undefined } function isScheduleVideoUpdatePrivacyValid ( value ) { return value === VideoPrivacy . UNLISTED || value === VideoPrivacy . PUBLIC } function isVideoOriginallyPublishedAtValid ( value : string | null ) { return value === null || isDateValid ( value ) } function isVideoFileInfoHashValid ( value : string | null | undefined ) { return exists ( value ) && validator . isLength ( value , VIDEOS_CONSTRAINTS_FIELDS . INFO_HASH ) } function isVideoFileResolutionValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' ) } function isVideoFPSResolutionValid ( value ) { return value === null || validator . isInt ( value + 's' ) } function isVideoFileSizeValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' , VIDEOS_CONSTRAINTS_FIELDS . FILE_SIZE ) } function isVideoMagnetUriValid ( value ) { if ( ! exists ( value ) ) return false const parsed = magnetUtil . decode ( value ) return parsed && isVideoFileInfoHashValid ( parsed . infoHash ) } export { isVideoCategoryValid , isVideoLicenceValid , isVideoLanguageValid , isVideoTruncatedDescriptionValid , isVideoDescriptionValid , isVideoFileInfoHashValid , isVideoNameValid , isVideoTagsValid , isVideoFPSResolutionValid , isScheduleVideoUpdatePrivacyValid , isVideoOriginallyPublishedAtValid , isVideoFile , isVideoMagnetUriValid , isVideoStateValid , isVideoViewsValid , isVideoRatingTypeValid , isVideoFileExtnameValid , isVideoDurationValid , isVideoTagValid , isVideoPrivacyValid , isVideoFileResolutionValid , isVideoFileSizeValid , isVideoImage , isVideoSupportValid , isVideoFilterValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFilter$ O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { mkdirpSync } from 's' import * as path from 's' import * as winston from 's' import { FileTransportOptions } from 's' import { CONFIG } from 's' import { omit } from 's' const label = CONFIG . WEBSERVER . HOSTNAME + 's' + CONFIG . WEBSERVER . PORT mkdirpSync ( CONFIG . STORAGE . LOG_DIR ) function loggerReplacer ( key , value ) { if ( value instanceof Error ) { const error = { } Object . getOwnPropertyNames ( value ) . forEach ( key => error [ key ] = value [ key ] ) return error } return value } const consoleLoggerFormat = winston . format . printf ( info => { const obj = omit ( info , 's' , 's' , 's' , 's' ) let additionalInfos = JSON . stringify ( obj , loggerReplacer , 0 ) if ( additionalInfos === undefined || additionalInfos === 's' ) additionalInfos = 's' else additionalInfos = 's' + additionalInfos return `template` } ) const jsonLoggerFormat = winston . format . printf ( info => { return JSON . stringify ( info , loggerReplacer ) } ) const timestampFormatter = winston . format . timestamp ( { format : 's' } ) const labelFormatter = winston . format . label ( { label } ) const fileLoggerOptions = { filename : path . join ( CONFIG . STORAGE . LOG_DIR , 's' ) , handleExceptions : true , format : winston . format . combine ( winston . format . timestamp ( ) , jsonLoggerFormat ) } if ( CONFIG . LOG . ROTATION ) { fileLoggerOptions . maxsize = 0 * 0 * 0 fileLoggerOptions . maxFiles = 0 } const logger = winston . createLogger ( { level : CONFIG . LOG . LEVEL , format : winston . format . combine ( labelFormatter , winston . format . splat ( ) ) , transports : [ new winston . transports . File ( fileLoggerOptions ) , new winston . transports . Console ( { handleExceptions : true , format : winston . format . combine ( timestampFormatter , winston . format . colorize ( ) , consoleLoggerFormat ) } ) ] , exitOnError : true } ) function bunyanLogFactory ( level ) { return function ( ) { let meta = null let args : any [ ] = [ ] args . concat ( arguments ) if ( arguments [ 0 ] instanceof Error ) { meta = arguments [ 0 ] . toString ( ) args = Array . prototype . slice . call ( arguments , 0 ) args . push ( meta ) } else if ( typeof ( args [ 0 ] ) !== 's' ) { meta = arguments [ 0 ] args = Array . prototype . slice . call ( arguments , 0 ) args . push ( meta ) } logger [ level ] . apply ( logger , args ) } } const bunyanLogger = { trace : bunyanLogFactory ( 's' ) , debug : bunyanLogFactory ( 's' ) , info : bunyanLogFactory ( 's' ) , warn : bunyanLogFactory ( 's' ) , error : bunyanLogFactory ( 's' ) , fatal : bunyanLogFactory ( 's' ) } export { timestampFormatter , labelFormatter , consoleLoggerFormat , jsonLoggerFormat , logger , bunyanLogger }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileTransportOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as sharp from 's' import { readFile , remove } from 's' import { logger } from 's' async function processImage ( path , destination , newSize : { width : number , height : number } , keepOriginal = false ) { if ( path === destination ) { throw new Error ( 's' ) } logger . debug ( 's' , path , destination ) const buf = await readFile ( path ) const sharpInstance = sharp ( buf ) await remove ( destination ) await sharpInstance . resize ( newSize . width , newSize . height ) . toFile ( destination ) if ( keepOriginal !== true ) await remove ( path ) } export { processImage }	O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as config from 's' import { 0 } from 's' import { logger } from 's' function checkMissedConfig ( ) { const required = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] const requiredAlternatives = [ [ [ 's' , 's' ] , [ 's' ] ] ] const miss : string [ ] = [ ] for ( const key of required ) { if ( ! config . has ( key ) ) { miss . push ( key ) } } const redundancyVideos = config . get < any > ( 's' ) if ( Array . isArray ( redundancyVideos ) ) { for ( const r of redundancyVideos ) { if ( ! r . size ) miss . push ( 's' ) if ( ! r . min_lifetime ) miss . push ( 's' ) } } const missingAlternatives = requiredAlternatives . filter ( set => ! set . find ( alternative => ! alternative . find ( key => ! config . has ( key ) ) ) ) missingAlternatives . forEach ( set => set [ 0 ] . forEach ( key => miss . push ( key ) ) ) return miss } async function checkFFmpeg ( CONFIG : { TRANSCODING : { ENABLED : boolean } } ) { const Ffmpeg = require ( 's' ) const getAvailableCodecsPromise = 0 ( Ffmpeg . getAvailableCodecs ) const codecs = await getAvailableCodecsPromise ( ) const canEncode = [ 's' ] if ( CONFIG . TRANSCODING . ENABLED === false ) return undefined for ( const codec of canEncode ) { if ( codecs [ codec ] === undefined ) { throw new Error ( 's' + codec + 's' ) } if ( codecs [ codec ] . canEncode !== true ) { throw new Error ( 's' + codec + 's' ) } } return checkFFmpegEncoders ( ) } let supportedOptionalEncoders < string , boolean > async function checkFFmpegEncoders ( ) < Map < string , boolean > > { if ( supportedOptionalEncoders !== undefined ) { return supportedOptionalEncoders } const Ffmpeg = require ( 's' ) const getAvailableEncodersPromise = 0 ( Ffmpeg . getAvailableEncoders ) const encoders = await getAvailableEncodersPromise ( ) const optionalEncoders = [ 's' ] supportedOptionalEncoders = new Map < string , boolean > ( ) for ( const encoder of optionalEncoders ) { supportedOptionalEncoders . set ( encoder , encoders [ encoder ] !== undefined ) } return supportedOptionalEncoders } function checkNodeVersion ( ) { const v = process . version const majorString = v . split ( 's' ) [ 0 ] . replace ( 's' , 's' ) const major = parseInt ( majorString , 0 ) logger . debug ( 's' , v ) if ( major < 0 ) { logger . warn ( 's' , v ) } } export { checkFFmpeg , checkFFmpegEncoders , checkMissedConfig , checkNodeVersion }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Map$ O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as ffmpeg from 's' import { dirname , join } from 's' import { getTargetBitrate , getMaxBitrate , VideoResolution } from 's' import { FFMPEG_NICE , VIDEO_TRANSCODING_FPS } from 's' import { processImage } from 's' import { logger } from 's' import { checkFFmpegEncoders } from 's' import { readFile , remove , writeFile } from 's' import { CONFIG } from 's' function computeResolutionsToTranscode ( videoFileHeight ) { const resolutionsEnabled : number [ ] = [ ] const configResolutions = CONFIG . TRANSCODING . RESOLUTIONS const resolutions = [ VideoResolution . 0 , VideoResolution . 0 , VideoResolution . 0 , VideoResolution . 0 , VideoResolution . 0 , VideoResolution . 0 ] for ( const resolution of resolutions ) { if ( configResolutions [ resolution + 's' ] === true && videoFileHeight > resolution ) { resolutionsEnabled . push ( resolution ) } } return resolutionsEnabled } async function getVideoFileSize ( path ) { const videoStream = await getVideoStreamFromFile ( path ) return { width : videoStream . width , height : videoStream . height } } async function getVideoFileResolution ( path ) { const size = await getVideoFileSize ( path ) return { videoFileResolution : Math . min ( size . height , size . width ) , isPortraitMode : size . height > size . width } } async function getVideoFileFPS ( path ) { const videoStream = await getVideoStreamFromFile ( path ) for ( const key of [ 's' , 's' ] ) { const valuesText = videoStream [ key ] if ( ! valuesText ) continue const [ frames , seconds ] = valuesText . split ( 's' ) if ( ! frames || ! seconds ) continue const result = parseInt ( frames , 0 ) / parseInt ( seconds , 0 ) if ( result > 0 ) return Math . round ( result ) } return 0 } async function getVideoFileBitrate ( path ) { return new Promise < number > ( ( res , rej ) => { ffmpeg . ffprobe ( path , ( err , metadata ) => { if ( err ) return rej ( err ) return res ( metadata . format . bit_rate ) } ) } ) } function getDurationFromVideoFile ( path ) { return new Promise < number > ( ( res , rej ) => { ffmpeg . ffprobe ( path , ( err , metadata ) => { if ( err ) return rej ( err ) return res ( Math . floor ( metadata . format . duration ) ) } ) } ) } async function generateImageFromVideoFile ( fromPath , folder , imageName , size : { width : number , height : number } ) { const pendingImageName = 's' + imageName const options = { filename : pendingImageName , count : 0 , folder } const pendingImagePath = join ( folder , pendingImageName ) try { await new Promise < string > ( ( res , rej ) => { ffmpeg ( fromPath , { niceness : FFMPEG_NICE . THUMBNAIL } ) . on ( 's' , rej ) . on ( 's' , ( ) => res ( imageName ) ) . thumbnail ( options ) } ) const destination = join ( folder , imageName ) await processImage ( pendingImagePath , destination , size ) } catch ( err ) { logger . error ( 's' , fromPath , { err } ) try { await remove ( pendingImagePath ) } catch ( err ) { logger . debug ( 's' , { err } ) } } } type TranscodeOptionsType = 's' | 's' | 's' | 's' interface BaseTranscodeOptions { type : TranscodeOptionsType inputPath : string outputPath : string resolution : VideoResolution isPortraitMode ? : boolean } interface HLSTranscodeOptions extends BaseTranscodeOptions { type : 's' hlsPlaylist : { videoFilename : string } } interface QuickTranscodeOptions extends BaseTranscodeOptions { type : 's' } interface VideoTranscodeOptions extends BaseTranscodeOptions { type : 's' } interface MergeAudioTranscodeOptions extends BaseTranscodeOptions { type : 's' audioPath : string } type TranscodeOptions = HLSTranscodeOptions | VideoTranscodeOptions | MergeAudioTranscodeOptions | QuickTranscodeOptions function transcode ( options ) { return new Promise < void > ( async ( res , rej ) => { try { let command = ffmpeg ( options . inputPath , { niceness : FFMPEG_NICE . TRANSCODING } ) . output ( options . outputPath ) if ( options . type === 's' ) { command = await buildQuickTranscodeCommand ( command ) } else if ( options . type === 's' ) { command = await buildHLSCommand ( command , options ) } else if ( options . type === 's' ) { command = await buildAudioMergeCommand ( command , options ) } else { command = await 0 ( command , options ) } if ( CONFIG . TRANSCODING . THREADS > 0 ) { command = command . outputOption ( 's' + CONFIG . TRANSCODING . THREADS ) } command . on ( 's' , ( err , stdout , stderr ) => { logger . error ( 's' , { stdout , stderr } ) return rej ( err ) } ) . on ( 's' , ( ) => { return fixHLSPlaylistIfNeeded ( options ) . then ( ( ) => res ( ) ) . catch ( err => rej ( err ) ) } ) . run ( ) } catch ( err ) { return rej ( err ) } } ) } async function canDoQuickTranscode ( path ) < boolean > { const videoStream = await getVideoStreamFromFile ( path ) const parsedAudio = await audio . get ( path ) const fps = await getVideoFileFPS ( path ) const bitRate = await getVideoFileBitrate ( path ) const resolution = await getVideoFileResolution ( path ) if ( videoStream [ 's' ] !== 's' ) return false if ( fps < VIDEO_TRANSCODING_FPS . MIN || fps > VIDEO_TRANSCODING_FPS . MAX ) return false if ( bitRate > getMaxBitrate ( resolution . videoFileResolution , fps , VIDEO_TRANSCODING_FPS ) ) return false if ( parsedAudio . audioStream ) { if ( parsedAudio . audioStream [ 's' ] !== 's' ) return false const maxAudioBitrate = audio . bitrate [ 's' ] ( parsedAudio . audioStream [ 's' ] ) if ( maxAudioBitrate !== - 0 && parsedAudio . audioStream [ 's' ] > maxAudioBitrate ) return false } return true } export { getVideoFileSize , getVideoFileResolution , getDurationFromVideoFile , generateImageFromVideoFile , TranscodeOptions , TranscodeOptionsType , transcode , getVideoFileFPS , computeResolutionsToTranscode , audio , getVideoFileBitrate , canDoQuickTranscode } async function 0 ( command : ffmpeg . FfmpegCommand , options ) { let fps = await getVideoFileFPS ( options . inputPath ) if ( options . resolution !== undefined && options . resolution < VIDEO_TRANSCODING_FPS . KEEP_ORIGIN_FPS_RESOLUTION_MIN && fps > VIDEO_TRANSCODING_FPS . AVERAGE ) { fps = VIDEO_TRANSCODING_FPS . AVERAGE } command = await 0 ( command , options . inputPath , options . resolution , fps ) if ( options . resolution !== undefined ) { const size = options . isPortraitMode === true ? `template` : `template` command = command . size ( size ) } if ( fps ) { if ( fps > VIDEO_TRANSCODING_FPS . MAX ) fps = VIDEO_TRANSCODING_FPS . MAX else if ( fps < VIDEO_TRANSCODING_FPS . MIN ) fps = VIDEO_TRANSCODING_FPS . MIN command = command . withFPS ( fps ) } return command } async function buildAudioMergeCommand ( command : ffmpeg . FfmpegCommand , options ) { command = command . loop ( undefined ) command = await 0 ( command , options . audioPath , options . resolution ) command = command . input ( options . audioPath ) . videoFilter ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) return command } async function buildQuickTranscodeCommand ( command : ffmpeg . FfmpegCommand ) { command = await presetCopy ( command ) command = command . outputOption ( 's' ) . outputOption ( 's' ) return command } async function buildHLSCommand ( command : ffmpeg . FfmpegCommand , options ) { const videoPath = getHLSVideoPath ( options ) command = await presetCopy ( command ) command = command . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' + videoPath ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) return command } function getHLSVideoPath ( options ) { return `template` } async function fixHLSPlaylistIfNeeded ( options ) { if ( options . type !== 's' ) return const fileContent = await readFile ( options . outputPath ) const videoFileName = options . hlsPlaylist . videoFilename const videoFilePath = getHLSVideoPath ( options ) const newContent = fileContent . toString ( ) . replace ( `template` , `template` ) await writeFile ( options . outputPath , newContent ) } function getVideoStreamFromFile ( path ) { return new Promise < any > ( ( res , rej ) => { ffmpeg . ffprobe ( path , ( err , metadata ) => { if ( err ) return rej ( err ) const videoStream = metadata . streams . find ( s => s . codec_type === 's' ) if ( ! videoStream ) return rej ( new Error ( 's' + path ) ) return res ( videoStream ) } ) } ) } async function 0 ( command : ffmpeg . FfmpegCommand , input , resolution , fps ? ) { let localCommand = await 0 ( command , input , resolution , fps ) localCommand = localCommand . outputOption ( 's' ) return localCommand } namespace audio { export const get = ( option ) => { return new Promise < { absolutePath : string , audioStream ? : any } > ( ( res , rej ) => { function parseFfprobe ( err , data : ffmpeg . FfprobeData ) { if ( err ) return rej ( err ) if ( 's' in data ) { const audioStream = data . streams . find ( stream => stream [ 's' ] === 's' ) if ( audioStream ) { return res ( { absolutePath : data . format . filename , audioStream } ) } } return res ( { absolutePath : data . format . filename } ) } return ffmpeg . ffprobe ( option , parseFfprobe ) } ) } export namespace bitrate { const baseKbitrate = 0 const toBits = ( kbits ) => kbits * 0 export const aac = ( bitrate ) : number => { switch ( true ) { case bitrate > toBits ( baseKbitrate ) : return baseKbitrate default : return - 0 } } export const 0 = ( bitrate ) : number => { switch ( true ) { case bitrate <= toBits ( 0 ) : return 0 case bitrate <= toBits ( 0 ) : return 0 default : return baseKbitrate } } } } async function 0 ( command : ffmpeg . FfmpegCommand , input , resolution , fps ? ) { let localCommand = command . format ( 's' ) . videoCodec ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) . outputOption ( 's' ) const parsedAudio = await audio . get ( input ) if ( ! parsedAudio . audioStream ) { localCommand = localCommand . noAudio ( ) } else if ( ( await checkFFmpegEncoders ( ) ) . get ( 's' ) ) { localCommand = localCommand . audioCodec ( 's' ) . audioQuality ( 0 ) } else { localCommand = localCommand . audioCodec ( 's' ) const audioCodecName = parsedAudio . audioStream [ 's' ] if ( audio . bitrate [ audioCodecName ] ) { const bitrate = audio . bitrate [ audioCodecName ] ( parsedAudio . audioStream [ 's' ] ) if ( bitrate !== undefined && bitrate !== - 0 ) localCommand = localCommand . audioBitrate ( bitrate ) } } if ( fps ) { const targetBitrate = getTargetBitrate ( resolution , fps , VIDEO_TRANSCODING_FPS ) localCommand = localCommand . outputOptions ( [ `template` , `template` ] ) localCommand = localCommand . outputOption ( `template` ) } return localCommand } async function presetCopy ( command : ffmpeg . FfmpegCommand ) < ffmpeg . FfmpegCommand > { return command . format ( 's' ) . videoCodec ( 's' ) . audioCodec ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MergeAudioTranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HLSTranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HLSTranscodeOptions$ O O O O O O O O O $TranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideoResolution$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideoResolution$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { UserRole } from 's' import { CONSTRAINTS_FIELDS , NSFW_POLICY_TYPES } from 's' import { exists , isArray , isBooleanValid , isFileValid } from 's' import { values } from 's' const USERS_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . USERS function isUserPasswordValid ( value ) { return validator . isLength ( value , USERS_CONSTRAINTS_FIELDS . PASSWORD ) } function isUserVideoQuotaValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' , USERS_CONSTRAINTS_FIELDS . VIDEO_QUOTA ) } function isUserVideoQuotaDailyValid ( value ) { return exists ( value ) && validator . isInt ( value + 's' , USERS_CONSTRAINTS_FIELDS . VIDEO_QUOTA_DAILY ) } function isUserUsernameValid ( value ) { const max = USERS_CONSTRAINTS_FIELDS . USERNAME . max const min = USERS_CONSTRAINTS_FIELDS . USERNAME . min return exists ( value ) && validator . matches ( value , new RegExp ( `template` ) ) } function isUserDisplayNameValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , CONSTRAINTS_FIELDS . USERS . NAME ) ) } function isUserDescriptionValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , CONSTRAINTS_FIELDS . USERS . DESCRIPTION ) ) } function isUserEmailVerifiedValid ( value ) { return isBooleanValid ( value ) } const nsfwPolicies = values ( NSFW_POLICY_TYPES ) function isUserNSFWPolicyValid ( value ) { return exists ( value ) && nsfwPolicies . indexOf ( value ) !== - 0 } function isUserWebTorrentEnabledValid ( value ) { return isBooleanValid ( value ) } function isUserVideosHistoryEnabledValid ( value ) { return isBooleanValid ( value ) } function isUserAutoPlayVideoValid ( value ) { return isBooleanValid ( value ) } function isUserVideoLanguages ( value ) { return value === null || ( isArray ( value ) && value . length < CONSTRAINTS_FIELDS . USERS . VIDEO_LANGUAGES . max ) } function isUserAdminFlagsValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) } function isUserBlockedValid ( value ) { return isBooleanValid ( value ) } function isUserAutoPlayNextVideoValid ( value ) { return isBooleanValid ( value ) } function isNoInstanceConfigWarningModal ( value ) { return isBooleanValid ( value ) } function isNoWelcomeModal ( value ) { return isBooleanValid ( value ) } function isUserBlockedReasonValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , CONSTRAINTS_FIELDS . USERS . BLOCKED_REASON ) ) } function isUserRoleValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) && UserRole [ value ] !== undefined } const avatarMimeTypes = CONSTRAINTS_FIELDS . ACTORS . AVATAR . EXTNAME . map ( v => v . replace ( 's' , 's' ) ) . join ( 's' ) const avatarMimeTypesRegex = `template` function isAvatarFile ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] ) { return isFileValid ( files , avatarMimeTypesRegex , 's' , CONSTRAINTS_FIELDS . ACTORS . AVATAR . FILE_SIZE . max ) } export { isUserVideosHistoryEnabledValid , isUserBlockedValid , isUserPasswordValid , isUserVideoLanguages , isUserBlockedReasonValid , isUserRoleValid , isUserVideoQuotaValid , isUserVideoQuotaDailyValid , isUserUsernameValid , isUserAdminFlagsValid , isUserEmailVerifiedValid , isUserNSFWPolicyValid , isUserWebTorrentEnabledValid , isUserAutoPlayVideoValid , isUserAutoPlayNextVideoValid , isUserDisplayNameValid , isUserDescriptionValid , isNoInstanceConfigWarningModal , isNoWelcomeModal , isAvatarFile }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isUserDescriptionValid , isUserUsernameValid } from 's' import { exists } from 's' function isAccountNameValid ( value ) { return isUserUsernameValid ( value ) } function isAccountIdValid ( value ) { return exists ( value ) } function isAccountDescriptionValid ( value ) { return isUserDescriptionValid ( value ) } export { isAccountIdValid , isAccountDescriptionValid , isAccountNameValid }	O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O
import * as AsyncLRU from 's' import * as jsonld from 's' import { logger } from 's' const CACHE = { 's' : { 's' : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : 's' , 's' : 's' , 's' : { 's' : 's' , 's' : 's' } , 's' : { 's' : 's' , 's' : 's' } , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } } } const nodeDocumentLoader = jsonld . documentLoaders . node ( ) const lru = new AsyncLRU ( { max : 0 , load : ( url , cb ) => { if ( CACHE [ url ] !== undefined ) { logger . debug ( 's' , url ) return cb ( null , { contextUrl : null , document : CACHE [ url ] , documentUrl : url } ) } nodeDocumentLoader ( url , cb ) } } ) jsonld . documentLoader = ( url , cb ) => { lru . get ( url , cb ) } export { jsonld }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { buildSignedActivity } from 's' import { getServerActor } from 's' import { ActorModel } from 's' import { 0 } from 's' import { HTTP_SIGNATURE } from 's' import { MActor } from 's' type Payload = { body : any , signatureActorId ? : number } async function computeBody ( payload ) { let body = payload . body if ( payload . signatureActorId ) { const actorSignature = await ActorModel . load ( payload . signatureActorId ) if ( ! actorSignature ) throw new Error ( 's' ) body = await buildSignedActivity ( actorSignature , payload . body ) } return body } async function buildSignedRequestOptions ( payload ) { let actor : MActor | null if ( payload . signatureActorId ) { actor = await ActorModel . load ( payload . signatureActorId ) if ( ! actor ) throw new Error ( 's' ) } else { actor = await getServerActor ( ) } const keyId = actor . url return { algorithm : HTTP_SIGNATURE . ALGORITHM , authorizationHeaderName : HTTP_SIGNATURE . HEADER_NAME , keyId , key : actor . privateKey , headers : HTTP_SIGNATURE . HEADERS_TO_SIGN } } function buildGlobalHeaders ( body ) { return { 's' : buildDigest ( body ) } } function buildDigest ( body ) { const rawBody = typeof body === 's' ? body : JSON . stringify ( body ) return 's' + 0 ( rawBody , 's' ) } export { buildDigest , buildGlobalHeaders , computeBody , buildSignedRequestOptions }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Payload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Payload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Request } from 's' import { BCRYPT_SALT_SIZE , HTTP_SIGNATURE , PRIVATE_RSA_KEY_SIZE } from 's' import { createPrivateKey , getPublicKey , 0 , 0 , 0 } from 's' import { jsonld } from 's' import { logger } from 's' import { cloneDeep } from 's' import { createSign , createVerify } from 's' import { buildDigest } from 's' import * as bcrypt from 's' import { MActor } from 's' const bcryptComparePromise = 0 < any , string , boolean > ( bcrypt . compare ) const bcryptGenSaltPromise = 0 < number , string > ( bcrypt . genSalt ) const bcryptHashPromise = 0 < any , string | number , string > ( bcrypt . hash ) const httpSignature = require ( 's' ) async function createPrivateAndPublicKeys ( ) { logger . info ( 's' ) const { key } = await createPrivateKey ( PRIVATE_RSA_KEY_SIZE ) const { publicKey } = await getPublicKey ( key ) return { privateKey : key , publicKey } } function comparePassword ( plainPassword , hashPassword ) { return bcryptComparePromise ( plainPassword , hashPassword ) } async function cryptPassword ( password ) { const salt = await bcryptGenSaltPromise ( BCRYPT_SALT_SIZE ) return bcryptHashPromise ( password , salt ) } function isHTTPSignatureDigestValid ( rawBody , req ) { if ( req . headers [ HTTP_SIGNATURE . HEADER_NAME ] && req . headers [ 's' ] ) { return buildDigest ( rawBody . toString ( ) ) === req . headers [ 's' ] } return true } function isHTTPSignatureVerified ( httpSignatureParsed , actor ) { return httpSignature . verifySignature ( httpSignatureParsed , actor . publicKey ) === true } function parseHTTPSignature ( req , clockSkew ? ) { return httpSignature . parse ( req , { authorizationHeaderName : HTTP_SIGNATURE . HEADER_NAME , clockSkew } ) } function isJsonLDSignatureVerified ( fromActor , signedDocument ) < boolean > { if ( signedDocument . signature . type === 's' ) { return 0 ( fromActor , signedDocument ) } logger . warn ( 's' , signedDocument . signature . type , signedDocument ) return Promise . resolve ( false ) } async function 0 ( fromActor , signedDocument ) { const [ documentHash , optionsHash ] = await Promise . all ( [ createDocWithoutSignatureHash ( signedDocument ) , createSignatureHash ( signedDocument . signature ) ] ) const toVerify = optionsHash + documentHash const verify = createVerify ( 's' ) verify . update ( toVerify , 's' ) return verify . verify ( fromActor . publicKey , signedDocument . signature . signatureValue , 's' ) } async function signJsonLDObject ( byActor , data ) { const signature = { type : 's' , creator : byActor . url , created : new Date ( ) . toISOString ( ) } const [ documentHash , optionsHash ] = await Promise . all ( [ createDocWithoutSignatureHash ( data ) , createSignatureHash ( signature ) ] ) const toSign = optionsHash + documentHash const sign = createSign ( 's' ) sign . update ( toSign , 's' ) const signatureValue = sign . sign ( byActor . privateKey , 's' ) Object . assign ( signature , { signatureValue } ) return Object . assign ( data , { signature } ) } export { isHTTPSignatureDigestValid , parseHTTPSignature , isHTTPSignatureVerified , isJsonLDSignatureVerified , comparePassword , createPrivateAndPublicKeys , cryptPassword , signJsonLDObject } function hash ( obj ) < any > { return jsonld . promises . normalize ( obj , { algorithm : 's' , format : 's' } ) . then ( res => 0 ( res ) ) } function createSignatureHash ( signature ) { const signatureCopy = cloneDeep ( signature ) Object . assign ( signatureCopy , { 's' : [ 's' , { 0 : 's' } ] } ) delete signatureCopy . type delete signatureCopy . id delete signatureCopy . signatureValue return hash ( signatureCopy ) } function createDocWithoutSignatureHash ( doc ) { const docWithoutSignature = cloneDeep ( doc ) delete docWithoutSignature . signature return hash ( docWithoutSignature ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $boolean$ O $Buffer$ O $Request$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $any$ O $MActor$ O O O O O O O O O O O O O O O O O O O $Request$ O O $number$ O O O O O O O O O O O O O O O O O O O O O $Promise$ O $MActor$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import * as validator from 's' import { ResultList } from 's' import { Activity } from 's' import { ACTIVITY_PUB } from 's' import { ActorModel } from 's' import { signJsonLDObject } from 's' import { pageToStartAndCount } from 's' import { parse } from 's' import { MActor } from 's' function activityPubContextify < T > ( data : T ) { return Object . assign ( data , { 's' : [ 's' , 's' , { 0 : 's' , pt : 's' , sc : 's' , Hashtag : 's' , uuid : 's' , category : 's' , licence : 's' , subtitleLanguage : 's' , sensitive : 's' , language : 's' , expires : 's' , CacheFile : 's' , Infohash : 's' , originallyPublishedAt : 's' , views : { 's' : 's' , 's' : 's' } , state : { 's' : 's' , 's' : 's' } , size : { 's' : 's' , 's' : 's' } , fps : { 's' : 's' , 's' : 's' } , startTimestamp : { 's' : 's' , 's' : 's' } , stopTimestamp : { 's' : 's' , 's' : 's' } , position : { 's' : 's' , 's' : 's' } , commentsEnabled : { 's' : 's' , 's' : 's' } , downloadEnabled : { 's' : 's' , 's' : 's' } , waitTranscoding : { 's' : 's' , 's' : 's' } , support : { 's' : 's' , 's' : 's' } } , { likes : { 's' : 's' , 's' : 's' } , dislikes : { 's' : 's' , 's' : 's' } , playlists : { 's' : 's' , 's' : 's' } , shares : { 's' : 's' , 's' : 's' } , comments : { 's' : 's' , 's' : 's' } } ] } ) } type ActivityPubCollectionPaginationHandler = ( start , count ) => Bluebird < ResultList < any > > | Promise < ResultList < any > > async function activityPubCollectionPagination ( baseUrl , handler , page ? ) { if ( ! page || ! validator . isInt ( page ) ) { const result = await handler ( 0 , 0 ) return { id : baseUrl , type : 's' , totalItems : result . total , first : baseUrl + 's' } } const { start , count } = pageToStartAndCount ( page , ACTIVITY_PUB . COLLECTION_ITEMS_PER_PAGE ) const result = await handler ( start , count ) let next : string | undefined let prev : string | undefined page = parseInt ( page , 0 ) if ( result . total > page * ACTIVITY_PUB . COLLECTION_ITEMS_PER_PAGE ) { next = baseUrl + 's' + ( page + 0 ) } if ( page > 0 ) { prev = baseUrl + 's' + ( page - 0 ) } return { id : baseUrl + 's' + page , type : 's' , prev , next , partOf : baseUrl , orderedItems : result . data , totalItems : result . total } } function buildSignedActivity ( byActor , data ) { const activity = activityPubContextify ( data ) return signJsonLDObject ( byActor , activity ) as Promise < Activity > } function getAPId ( activity : string | { id : string } ) { if ( typeof activity === 's' ) return activity return activity . id } function checkUrlsSameHost ( 0 , 0 ) { const idHost = parse ( 0 ) . host const actorHost = parse ( 0 ) . host return idHost && actorHost && idHost . toLowerCase ( ) === actorHost . toLowerCase ( ) } export { checkUrlsSameHost , getAPId , activityPubContextify , activityPubCollectionPagination , buildSignedActivity }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O $string$ O $ActivityPubCollectionPaginationHandler$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $Object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { exists , isArray } from 's' import { isTestInstance } from 's' import { CONSTRAINTS_FIELDS } from 's' function isHostValid ( host ) { const isURLOptions = { require_host : true , require_tld : true } if ( isTestInstance ( ) ) { isURLOptions . require_tld = false } return exists ( host ) && validator . isURL ( host , isURLOptions ) && host . split ( 's' ) . length === 0 } function isEachUniqueHostValid ( hosts : string [ ] ) { return isArray ( hosts ) && hosts . length !== 0 && hosts . every ( host => { return isHostValid ( host ) && hosts . indexOf ( host ) === hosts . lastIndexOf ( host ) } ) } function isValidContactBody ( value ) { return exists ( value ) && validator . isLength ( value , CONSTRAINTS_FIELDS . CONTACT_FORM . BODY ) } function isValidContactFromName ( value ) { return exists ( value ) && validator . isLength ( value , CONSTRAINTS_FIELDS . CONTACT_FORM . FROM_NAME ) } export { isValidContactBody , isValidContactFromName , isEachUniqueHostValid , isHostValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { CONSTRAINTS_FIELDS } from 's' import { exists , isArray } from 's' import { truncate } from 's' import { isActivityPubUrlValid , isBaseActivityValid , setValidAttributedTo } from 's' import { isHostValid } from 's' function isActorEndpointsObjectValid ( endpointObject ) { return isActivityPubUrlValid ( endpointObject . sharedInbox ) } function isActorPublicKeyObjectValid ( publicKeyObject ) { return isActivityPubUrlValid ( publicKeyObject . id ) && isActivityPubUrlValid ( publicKeyObject . owner ) && isActorPublicKeyValid ( publicKeyObject . publicKeyPem ) } function isActorTypeValid ( type ) { return type === 's' || type === 's' || type === 's' } function isActorPublicKeyValid ( publicKey ) { return exists ( publicKey ) && typeof publicKey === 's' && publicKey . startsWith ( 's' ) && publicKey . indexOf ( 's' ) !== - 0 && validator . isLength ( publicKey , CONSTRAINTS_FIELDS . ACTORS . PUBLIC_KEY ) } const actorNameAlphabet = 's' const actorNameRegExp = new RegExp ( `template` ) function isActorPreferredUsernameValid ( preferredUsername ) { return exists ( preferredUsername ) && validator . matches ( preferredUsername , actorNameRegExp ) } function isActorPrivateKeyValid ( privateKey ) { return exists ( privateKey ) && typeof privateKey === 's' && privateKey . startsWith ( 's' ) && privateKey . indexOf ( 's' ) !== - 0 && validator . isLength ( privateKey , CONSTRAINTS_FIELDS . ACTORS . PRIVATE_KEY ) } function isActorObjectValid ( actor ) { return exists ( actor ) && isActivityPubUrlValid ( actor . id ) && isActorTypeValid ( actor . type ) && isActivityPubUrlValid ( actor . inbox ) && isActorPreferredUsernameValid ( actor . preferredUsername ) && isActivityPubUrlValid ( actor . url ) && isActorPublicKeyObjectValid ( actor . publicKey ) && isActorEndpointsObjectValid ( actor . endpoints ) && ( ! actor . outbox || isActivityPubUrlValid ( actor . outbox ) ) && ( ! actor . following || isActivityPubUrlValid ( actor . following ) ) && ( ! actor . followers || isActivityPubUrlValid ( actor . followers ) ) && setValidAttributedTo ( actor ) && ( actor . type !== 's' || actor . attributedTo . length !== 0 ) } function isActorFollowingCountValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value , { min : 0 } ) } function isActorFollowersCountValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value , { min : 0 } ) } function isActorDeleteActivityValid ( activity ) { return isBaseActivityValid ( activity , 's' ) } function sanitizeAndCheckActorObject ( object ) { normalizeActor ( object ) return isActorObjectValid ( object ) } function normalizeActor ( actor ) { if ( ! actor || ! actor . url ) return if ( typeof actor . url !== 's' ) { actor . url = actor . url . href || actor . url . url } if ( actor . summary && typeof actor . summary === 's' ) { actor . summary = truncate ( actor . summary , { length : CONSTRAINTS_FIELDS . USERS . DESCRIPTION . max } ) if ( actor . summary . length < CONSTRAINTS_FIELDS . USERS . DESCRIPTION . min ) { actor . summary = null } } return } function isValidActorHandle ( handle ) { if ( ! exists ( handle ) ) return false const parts = handle . split ( 's' ) if ( parts . length !== 0 ) return false return isHostValid ( parts [ 0 ] ) } function areValidActorHandles ( handles : string [ ] ) { return isArray ( handles ) && handles . every ( h => isValidActorHandle ( h ) ) } export { normalizeActor , actorNameAlphabet , areValidActorHandles , isActorEndpointsObjectValid , isActorPublicKeyObjectValid , isActorTypeValid , isActorPublicKeyValid , isActorPreferredUsernameValid , isActorPrivateKeyValid , isActorObjectValid , isActorFollowingCountValid , isActorFollowersCountValid , isActorDeleteActivityValid , sanitizeAndCheckActorObject , isValidActorHandle }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Model , Sequelize } from 's' import * as validator from 's' import { Col } from 's' import { col , literal , OrderItem } from 's' type SortType = { sortModel : string , sortValue : string } function getSort ( value , lastSort = [ 's' , 's' ] ) : OrderItem [ ] { const { direction , field } = buildDirectionAndField ( value ) let finalField : string | Col if ( field . toLowerCase ( ) === 's' ) { finalField = Sequelize . col ( 's' ) } else if ( field === 's' ) { finalField = Sequelize . col ( 's' ) } else { finalField = field } return [ [ finalField , direction ] , lastSort ] } function getVideoSort ( value , lastSort = [ 's' , 's' ] ) : OrderItem [ ] { const { direction , field } = buildDirectionAndField ( value ) if ( field . toLowerCase ( ) === 's' ) { return [ [ Sequelize . fn ( 's' , Sequelize . fn ( 's' , Sequelize . col ( 's' ) ) , 's' ) , direction ] , [ Sequelize . col ( 's' ) , direction ] , lastSort ] } let finalField : string | Col if ( field . toLowerCase ( ) === 's' ) { finalField = Sequelize . col ( 's' ) } else { finalField = field } const firstSort = typeof finalField === 's' ? finalField . split ( 's' ) . concat ( [ direction ] ) as any : [ finalField , direction ] return [ firstSort , lastSort ] } function getBlacklistSort ( model , value , lastSort = [ 's' , 's' ] ) : OrderItem [ ] { const [ firstSort ] = getSort ( value ) if ( model ) return [ [ literal ( `template` ) ] , lastSort ] as any [ ] return [ firstSort , lastSort ] } function isOutdated ( model : { createdAt : Date , updatedAt : Date } , refreshInterval ) { const now = Date . now ( ) const createdAtTime = model . createdAt . getTime ( ) const updatedAtTime = model . updatedAt . getTime ( ) return ( now - createdAtTime ) > refreshInterval && ( now - updatedAtTime ) > refreshInterval } function throwIfNotValid ( value , validator : ( value ) => boolean , fieldName = 's' , nullable = false ) { if ( nullable && ( value === null || value === undefined ) ) return if ( validator ( value ) === false ) { throw new Error ( `template` ) } } function buildTrigramSearchIndex ( indexName , attribute ) { return { name : indexName , fields : [ Sequelize . literal ( 's' + attribute + 's' ) as any ] , using : 's' , operator : 's' } } function createSimilarityAttribute ( col , value ) { return Sequelize . fn ( 's' , searchTrigramNormalizeCol ( col ) , searchTrigramNormalizeValue ( value ) ) } function buildBlockedAccountSQL ( serverAccountId , userAccountId ? ) { const blockerIds = [ serverAccountId ] if ( userAccountId ) blockerIds . push ( userAccountId ) const blockerIdsString = blockerIds . join ( 's' ) return 's' + blockerIdsString + 's' + 's' + 's' + 's' + 's' + blockerIdsString + 's' } function buildServerIdsFollowedBy ( actorId ) { const actorIdNumber = parseInt ( actorId + 's' , 0 ) return 's' + 's' + 's' + 's' + actorIdNumber + 's' } function buildWhereIdOrUUID ( id : number | string ) { return validator . isInt ( 's' + id ) ? { id } : { uuid : id } } function parseAggregateResult ( result ) { if ( ! result ) return 0 const total = parseInt ( result + 's' , 0 ) if ( isNaN ( total ) ) return 0 return total } const createSafeIn = ( model : typeof Model , stringArr : ( string | number ) [ ] ) => { return stringArr . map ( t => model . sequelize . escape ( 's' + t ) ) . join ( 's' ) } function buildLocalAccountIdsIn ( ) { return literal ( 's' ) } function buildLocalActorIdsIn ( ) { return literal ( 's' ) } export { buildBlockedAccountSQL , buildLocalActorIdsIn , SortType , buildLocalAccountIdsIn , getSort , getVideoSort , getBlacklistSort , createSimilarityAttribute , throwIfNotValid , buildServerIdsFollowedBy , buildTrigramSearchIndex , buildWhereIdOrUUID , isOutdated , parseAggregateResult , createSafeIn } function searchTrigramNormalizeValue ( value ) { return Sequelize . fn ( 's' , Sequelize . fn ( 's' , value ) ) } function searchTrigramNormalizeCol ( col ) { return Sequelize . fn ( 's' , Sequelize . fn ( 's' , Sequelize . col ( col ) ) ) } function buildDirectionAndField ( value ) { let field let direction : 's' | 's' if ( value . substring ( 0 , 0 ) === 's' ) { direction = 's' field = value . substring ( 0 ) } else { direction = 's' field = value } return { direction , field } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $OrderItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $OrderItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O $OrderItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { join } from 's' import { AfterDestroy , AllowNull , Column , CreatedAt , Is , Model , Table , UpdatedAt } from 's' import { Avatar } from 's' import { LAZY_STATIC_PATHS } from 's' import { logger } from 's' import { remove } from 's' import { CONFIG } from 's' import { throwIfNotValid } from 's' import { isActivityPubUrlValid } from 's' import { MAvatarFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } ] } ) export class AvatarModel extends Model < AvatarModel > { @ AllowNull ( false ) @ Column filename : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' , true ) ) @ Column fileUrl : string @ AllowNull ( false ) @ Column onDisk : boolean @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AfterDestroy static removeFilesAndSendDelete ( instance ) { logger . info ( 's' , instance . filename ) instance . removeAvatar ( ) . catch ( err => logger . error ( 's' , instance . filename , err ) ) } static loadByName ( filename ) { const query = { where : { filename } } return AvatarModel . findOne ( query ) } toFormattedJSON ( this ) { return { path : this . getStaticPath ( ) , createdAt : this . createdAt , updatedAt : this . updatedAt } } getStaticPath ( ) { return join ( LAZY_STATIC_PATHS . AVATARS , this . filename ) } getPath ( ) { return join ( CONFIG . STORAGE . AVATARS_DIR , this . filename ) } removeAvatar ( ) { const avatarPath = join ( CONFIG . STORAGE . AVATARS_DIR , this . filename ) return remove ( avatarPath ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvatarModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $Avatar$ O $MAvatarFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BelongsTo , Column , CreatedAt , ForeignKey , Model , Scopes , Table , UpdatedAt } from 's' import { AccountModel } from 's' import { ServerModel } from 's' import { ServerBlock } from 's' import { getSort } from 's' import * as Bluebird from 's' import { MServerBlocklist , MServerBlocklistAccountServer , MServerBlocklistFormattable } from 's' enum ScopeNames { WITH_ACCOUNT = 's' , WITH_SERVER = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_ACCOUNT ] : { include : [ { model : AccountModel , required : true } ] } , [ ScopeNames . WITH_SERVER ] : { include : [ { model : ServerModel , required : true } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class ServerBlocklistModel extends Model < ServerBlocklistModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) ByAccount : AccountModel @ ForeignKey ( ( ) => ServerModel ) @ Column targetServerId : number @ BelongsTo ( ( ) => ServerModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) BlockedServer : ServerModel static loadByAccountAndHost ( accountId , host ) < MServerBlocklist > { const query = { where : { accountId } , include : [ { model : ServerModel , where : { host } , required : true } ] } return ServerBlocklistModel . findOne ( query ) } static listForApi ( accountId , start , count , sort ) { const query = { offset : start , limit : count , order : getSort ( sort ) , where : { accountId } } return ServerBlocklistModel . scope ( [ ScopeNames . WITH_ACCOUNT , ScopeNames . WITH_SERVER ] ) . findAndCountAll < MServerBlocklistAccountServer > ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } toFormattedJSON ( this ) { return { byAccount : this . ByAccount . toFormattedJSON ( ) , blockedServer : this . BlockedServer . toFormattedJSON ( ) , createdAt : this . createdAt } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerBlock$ O $MServerBlocklistFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , Column , CreatedAt , Default , HasMany , Is , Model , Table , UpdatedAt } from 's' import { isHostValid } from 's' import { ActorModel } from 's' import { throwIfNotValid } from 's' import { ServerBlocklistModel } from 's' import * as Bluebird from 's' import { MServer , MServerFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } ] } ) export class ServerModel extends Model < ServerModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isHostValid , 's' ) ) @ Column host : string @ AllowNull ( false ) @ Default ( false ) @ Column redundancyAllowed : boolean @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ HasMany ( ( ) => ActorModel , { foreignKey : { name : 's' , allowNull : true } , onDelete : 's' , hooks : true } ) Actors : ActorModel [ ] @ HasMany ( ( ) => ServerBlocklistModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) BlockedByAccounts : ServerBlocklistModel [ ] static load ( id ) < MServer > { const query = { where : { id } } return ServerModel . findOne ( query ) } static loadByHost ( host ) < MServer > { const query = { where : { host } } return ServerModel . findOne ( query ) } isBlocked ( ) { return this . BlockedByAccounts && this . BlockedByAccounts . length !== 0 } toFormattedJSON ( this ) { return { host : this . host } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MServerFormattable$ O O O O O O O O O O O O
import * as validator from 's' import { CONSTRAINTS_FIELDS } from 's' import { exists } from 's' const VIDEO_CHANNELS_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . VIDEO_CHANNELS function isVideoChannelDescriptionValid ( value ) { return value === null || validator . isLength ( value , VIDEO_CHANNELS_CONSTRAINTS_FIELDS . DESCRIPTION ) } function isVideoChannelNameValid ( value ) { return exists ( value ) && validator . isLength ( value , VIDEO_CHANNELS_CONSTRAINTS_FIELDS . NAME ) } function isVideoChannelSupportValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , VIDEO_CHANNELS_CONSTRAINTS_FIELDS . SUPPORT ) ) } export { isVideoChannelDescriptionValid , isVideoChannelNameValid , isVideoChannelSupportValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exists } from 's' import * as validator from 's' import { CONSTRAINTS_FIELDS , VIDEO_PLAYLIST_PRIVACIES , VIDEO_PLAYLIST_TYPES } from 's' import * as express from 's' import { VideoPlaylistModel } from 's' const PLAYLISTS_CONSTRAINT_FIELDS = CONSTRAINTS_FIELDS . VIDEO_PLAYLISTS function isVideoPlaylistNameValid ( value ) { return exists ( value ) && validator . isLength ( value , PLAYLISTS_CONSTRAINT_FIELDS . NAME ) } function isVideoPlaylistDescriptionValid ( value ) { return value === null || ( exists ( value ) && validator . isLength ( value , PLAYLISTS_CONSTRAINT_FIELDS . DESCRIPTION ) ) } function isVideoPlaylistPrivacyValid ( value ) { return validator . isInt ( value + 's' ) && VIDEO_PLAYLIST_PRIVACIES [ value ] !== undefined } function isVideoPlaylistTimestampValid ( value ) { return value === null || ( exists ( value ) && validator . isInt ( 's' + value , { min : 0 } ) ) } function isVideoPlaylistTypeValid ( value ) { return exists ( value ) && VIDEO_PLAYLIST_TYPES [ value ] !== undefined } export { isVideoPlaylistNameValid , isVideoPlaylistDescriptionValid , isVideoPlaylistPrivacyValid , isVideoPlaylistTimestampValid , isVideoPlaylistTypeValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface PlaylistElementObject { id : string type : 's' url : string position : number startTimestamp ? : number stopTimestamp ? : number }	O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , Is , IsInt , Min , Model , Table , UpdatedAt } from 's' import { ForAPIOptions , ScopeNames as VideoScopeNames , VideoModel } from 's' import { VideoPlaylistModel } from 's' import { getSort , throwIfNotValid } from 's' import { isActivityPubUrlValid } from 's' import { CONSTRAINTS_FIELDS } from 's' import { PlaylistElementObject } from 's' import * as validator from 's' import { AggregateOptions , Op , ScopeOptions , Sequelize , Transaction } from 's' import { VideoPlaylistElement , VideoPlaylistElementType } from 's' import { AccountModel } from 's' import { VideoPrivacy } from 's' import * as Bluebird from 's' import { MVideoPlaylistElement , MVideoPlaylistElementAP , MVideoPlaylistElementFormattable , MVideoPlaylistElementVideoUrlPlaylistPrivacy , MVideoPlaylistVideoThumbnail } from 's' import { MUserAccountId } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] , unique : true } ] } ) export class VideoPlaylistElementModel extends Model < VideoPlaylistElementModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_PLAYLISTS . URL . max ) ) url : string @ AllowNull ( false ) @ Default ( 0 ) @ IsInt @ Min ( 0 ) @ Column position : number @ AllowNull ( true ) @ IsInt @ Min ( 0 ) @ Column startTimestamp : number @ AllowNull ( true ) @ IsInt @ Min ( 0 ) @ Column stopTimestamp : number @ ForeignKey ( ( ) => VideoPlaylistModel ) @ Column videoPlaylistId : number @ BelongsTo ( ( ) => VideoPlaylistModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) VideoPlaylist : VideoPlaylistModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Video : VideoModel static deleteAllOf ( videoPlaylistId , transaction ? ) { const query = { where : { videoPlaylistId } , transaction } return VideoPlaylistElementModel . destroy ( query ) } static listForApi ( options : { start : number , count : number , videoPlaylistId : number , serverAccount : AccountModel , user ? : MUserAccountId } ) { const accountIds = [ options . serverAccount . id ] const videoScope : ( ScopeOptions | string ) [ ] = [ VideoScopeNames . WITH_BLACKLISTED ] if ( options . user ) { accountIds . push ( options . user . Account . id ) videoScope . push ( { method : [ VideoScopeNames . WITH_USER_HISTORY , options . user . id ] } ) } const forApiOptions = { withAccountBlockerIds : accountIds } videoScope . push ( { method : [ VideoScopeNames . FOR_API , forApiOptions ] } ) const findQuery = { offset : options . start , limit : options . count , order : getSort ( 's' ) , where : { videoPlaylistId : options . videoPlaylistId } , include : [ { model : VideoModel . scope ( videoScope ) , required : false } ] } const countQuery = { where : { videoPlaylistId : options . videoPlaylistId } } return Promise . all ( [ VideoPlaylistElementModel . count ( countQuery ) , VideoPlaylistElementModel . findAll ( findQuery ) ] ) . then ( ( [ total , data ] ) => ( { total , data } ) ) } static loadByPlaylistAndVideo ( videoPlaylistId , videoId ) < MVideoPlaylistElement > { const query = { where : { videoPlaylistId , videoId } } return VideoPlaylistElementModel . findOne ( query ) } static loadById ( playlistElementId ) < MVideoPlaylistElement > { return VideoPlaylistElementModel . findByPk ( playlistElementId ) } static loadByPlaylistAndVideoForAP ( playlistId : number | string , videoId : number | string ) < MVideoPlaylistElementVideoUrlPlaylistPrivacy > { const playlistWhere = validator . isUUID ( 's' + playlistId ) ? { uuid : playlistId } : { id : playlistId } const videoWhere = validator . isUUID ( 's' + videoId ) ? { uuid : videoId } : { id : videoId } const query = { include : [ { attributes : [ 's' ] , model : VideoPlaylistModel . unscoped ( ) , where : playlistWhere } , { attributes : [ 's' ] , model : VideoModel . unscoped ( ) , where : videoWhere } ] } return VideoPlaylistElementModel . findOne ( query ) } static listUrlsOfForAP ( videoPlaylistId , start , count , t ? ) { const query = { attributes : [ 's' ] , offset : start , limit : count , order : getSort ( 's' ) , where : { videoPlaylistId } , transaction : t } return VideoPlaylistElementModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows . map ( e => e . url ) } } ) } static loadFirstElementWithVideoThumbnail ( videoPlaylistId ) < MVideoPlaylistVideoThumbnail > { const query = { order : getSort ( 's' ) , where : { videoPlaylistId } , include : [ { model : VideoModel . scope ( VideoScopeNames . WITH_THUMBNAILS ) , required : true } ] } return VideoPlaylistElementModel . findOne ( query ) } static getNextPositionOf ( videoPlaylistId , transaction ? ) { const query < number > = { where : { videoPlaylistId } , transaction } return VideoPlaylistElementModel . max ( 's' , query ) . then ( position => position ? position + 0 : 0 ) } static reassignPositionOf ( videoPlaylistId , firstPosition , endPosition , newPosition , transaction ? ) { const query = { where : { videoPlaylistId , position : { [ Op . gte ] : firstPosition , [ Op . lte ] : endPosition } } , transaction , validate : false } return VideoPlaylistElementModel . update ( { position : Sequelize . literal ( `template` ) } , query ) } static increasePositionOf ( videoPlaylistId , fromPosition , toPosition ? , by = 0 , transaction ? ) { const query = { where : { videoPlaylistId , position : { [ Op . gte ] : fromPosition } } , transaction } return VideoPlaylistElementModel . increment ( { position : by } , query ) } getType ( this , displayNSFW ? , accountId ? ) { const video = this . Video if ( ! video ) return VideoPlaylistElementType . DELETED if ( accountId && video . VideoChannel . Account . id === accountId ) return VideoPlaylistElementType . REGULAR if ( video . privacy === VideoPrivacy . PRIVATE ) return VideoPlaylistElementType . PRIVATE if ( video . isBlacklisted ( ) || video . isBlocked ( ) ) return VideoPlaylistElementType . UNAVAILABLE if ( video . nsfw === true && displayNSFW === false ) return VideoPlaylistElementType . UNAVAILABLE return VideoPlaylistElementType . REGULAR } getVideoElement ( this , displayNSFW ? , accountId ? ) { if ( ! this . Video ) return null if ( this . getType ( displayNSFW , accountId ) !== VideoPlaylistElementType . REGULAR ) return null return this . Video . toFormattedJSON ( ) } toFormattedJSON ( this , options : { displayNSFW ? : boolean , accountId ? : number } = { } ) { return { id : this . id , position : this . position , startTimestamp : this . startTimestamp , stopTimestamp : this . stopTimestamp , type : this . getType ( options . displayNSFW , options . accountId ) , video : this . getVideoElement ( options . displayNSFW , options . accountId ) } } toActivityPubObject ( this ) { const base = { id : this . url , type : 's' , url : this . Video . url , position : this . position } if ( this . startTimestamp ) base . startTimestamp = this . startTimestamp if ( this . stopTimestamp ) base . stopTimestamp = this . stopTimestamp return base } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ForAPIOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O $AggregateOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O $number$ O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistElementFormattable$ O O $boolean$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistElementFormattable$ O O $boolean$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O $MVideoPlaylistElementFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistElementObject$ O $MVideoPlaylistElementAP$ O O O $PlaylistElementObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum ThumbnailType { MINIATURE = 0 , PREVIEW = 0 }	O O O O O O O O O O O O
import { join } from 's' import { AfterDestroy , AllowNull , BelongsTo , Column , CreatedAt , Default , ForeignKey , Model , Table , UpdatedAt } from 's' import { LAZY_STATIC_PATHS , STATIC_PATHS , WEBSERVER } from 's' import { logger } from 's' import { remove } from 's' import { CONFIG } from 's' import { VideoModel } from 's' import { VideoPlaylistModel } from 's' import { ThumbnailType } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] , unique : true } ] } ) export class ThumbnailModel extends Model < ThumbnailModel > { @ AllowNull ( false ) @ Column filename : string @ AllowNull ( true ) @ Default ( null ) @ Column height : number @ AllowNull ( true ) @ Default ( null ) @ Column width : number @ AllowNull ( false ) @ Column type : ThumbnailType @ AllowNull ( true ) @ Column fileUrl : string @ AllowNull ( true ) @ Column automaticallyGenerated : boolean @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Video : VideoModel @ ForeignKey ( ( ) => VideoPlaylistModel ) @ Column videoPlaylistId : number @ BelongsTo ( ( ) => VideoPlaylistModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoPlaylist : VideoPlaylistModel @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date private static types : { [ id in ThumbnailType ] : { label : string , directory : string , staticPath : string } } = { [ ThumbnailType . MINIATURE ] : { label : 's' , directory : CONFIG . STORAGE . THUMBNAILS_DIR , staticPath : STATIC_PATHS . THUMBNAILS } , [ ThumbnailType . PREVIEW ] : { label : 's' , directory : CONFIG . STORAGE . PREVIEWS_DIR , staticPath : LAZY_STATIC_PATHS . PREVIEWS } } @ AfterDestroy static removeFiles ( instance ) { logger . info ( 's' , ThumbnailModel . types [ instance . type ] . label , instance . filename ) instance . removeThumbnail ( ) . catch ( err => logger . error ( 's' , instance . filename , err ) ) } static loadByName ( filename ) { const query = { where : { filename } } return ThumbnailModel . findOne ( query ) } static generateDefaultPreviewName ( videoUUID ) { return videoUUID + 's' } getFileUrl ( ) { if ( this . fileUrl ) return this . fileUrl const staticPath = ThumbnailModel . types [ this . type ] . staticPath return WEBSERVER . URL + staticPath + this . filename } getPath ( ) { const directory = ThumbnailModel . types [ this . type ] . directory return join ( directory , this . filename ) } removeThumbnail ( ) { return remove ( this . getPath ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ThumbnailModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type FunctionPropertyNames < T > = { [ K in keyof T ] : T [ K ] extends Function ? K : never } [ keyof T ] export type FunctionProperties < T > = Pick < T , FunctionPropertyNames < T > > export type PickWith < T , KT extends keyof T , V > = { [ P in KT ] : T [ P ] extends V ? V : never } export type PickWithOpt < T , KT extends keyof T , V > = { [ P in KT ] ? : T [ P ] extends V ? V : never } export type DeepPartial < T > = { [ P in keyof T ] ? : T [ P ] extends Array < infer U > ? Array < DeepPartial < U > > : T [ P ] extends ReadonlyArray < infer U > ? ReadonlyArray < DeepPartial < U > > : DeepPartial < T [ P ] > }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ThumbnailModel } from 's' export type MThumbnail = Omit < ThumbnailModel , 's' | 's' >	O O O O O O O O O O O O O O O O O O
import { Column , CreatedAt , ForeignKey , Model , Table , UpdatedAt } from 's' import { TagModel } from 's' import { VideoModel } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class VideoTagModel extends Model < VideoTagModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ ForeignKey ( ( ) => TagModel ) @ Column tagId : number }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { fn , QueryTypes , Transaction , col } from 's' import { AllowNull , BelongsToMany , Column , CreatedAt , Is , Model , Table , UpdatedAt } from 's' import { isVideoTagValid } from 's' import { throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoTagModel } from 's' import { VideoPrivacy , VideoState } from 's' import { MTag } from 's' @ Table ( { tableName : 's' , timestamps : false , indexes : [ { fields : [ 's' ] , unique : true } , { name : 's' , fields : [ fn ( 's' , col ( 's' ) ) ] as any } ] } ) export class TagModel extends Model < TagModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoTagValid , 's' ) ) @ Column name : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ BelongsToMany ( ( ) => VideoModel , { foreignKey : 's' , through : ( ) => VideoTagModel , onDelete : 's' } ) Videos : VideoModel [ ] static findOrCreateTags ( tags : string [ ] , transaction ) < MTag [ ] > { if ( tags === null ) return Promise . resolve ( [ ] ) const tasks : Bluebird < MTag > [ ] = [ ] tags . forEach ( tag => { const query = { where : { name : tag } , defaults : { name : tag } , transaction } const promise = TagModel . findOrCreate < MTag > ( query ) . then ( ( [ tagInstance ] ) => tagInstance ) tasks . push ( promise ) } ) return Promise . all ( tasks ) } static getRandomSamples ( threshold , count ) < string [ ] > { const query = 's' + 's' + 's' + 's' + 's' + 's' + 's' const options = { bind : { threshold , count , videoPrivacy : VideoPrivacy . PUBLIC , videoState : VideoState . PUBLISHED } , type : QueryTypes . SELECT as QueryTypes . SELECT } return TagModel . sequelize . query < { name : string } > ( query , options ) . then ( data => data . map ( d => d . name ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TagModel } from 's' export type MTag = Omit < TagModel , 's' >	O O O O O O O O O O O O O O O O
import { CONSTRAINTS_FIELDS , MIMETYPES , VIDEO_LANGUAGES } from 's' import { exists , isFileValid } from 's' function isVideoCaptionLanguageValid ( value ) { return exists ( value ) && VIDEO_LANGUAGES [ value ] !== undefined } const videoCaptionTypes = Object . keys ( MIMETYPES . VIDEO_CAPTIONS . MIMETYPE_EXT ) . concat ( [ 's' ] ) . map ( m => `template` ) const videoCaptionTypesRegex = videoCaptionTypes . join ( 's' ) function isVideoCaptionFile ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] , field ) { return isFileValid ( files , videoCaptionTypesRegex , field , CONSTRAINTS_FIELDS . VIDEO_CAPTIONS . CAPTION_FILE . FILE_SIZE . max ) } export { isVideoCaptionFile , isVideoCaptionLanguageValid }	O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { OrderItem , Transaction } from 's' import { AllowNull , BeforeDestroy , BelongsTo , Column , CreatedAt , ForeignKey , Is , Model , Scopes , Table , UpdatedAt } from 's' import { buildWhereIdOrUUID , throwIfNotValid } from 's' import { VideoModel } from 's' import { isVideoCaptionLanguageValid } from 's' import { VideoCaption } from 's' import { LAZY_STATIC_PATHS , VIDEO_LANGUAGES } from 's' import { join } from 's' import { logger } from 's' import { remove } from 's' import { CONFIG } from 's' import * as Bluebird from 's' import { MVideoCaptionFormattable , MVideoCaptionVideo } from 's' export enum ScopeNames { WITH_VIDEO_UUID_AND_REMOTE = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_VIDEO_UUID_AND_REMOTE ] : { include : [ { attributes : [ 's' , 's' , 's' ] , model : VideoModel . unscoped ( ) , required : true } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' , 's' ] , unique : true } ] } ) export class VideoCaptionModel extends Model < VideoCaptionModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoCaptionLanguageValid , 's' ) ) @ Column language : string @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ BeforeDestroy static async removeFiles ( instance ) { if ( ! instance . Video ) { instance . Video = await instance . $get ( 's' ) as VideoModel } if ( instance . isOwned ( ) ) { logger . info ( 's' , instance . Video . uuid , instance . language ) try { await instance . removeCaptionFile ( ) } catch ( err ) { logger . error ( 's' , instance . Video . uuid ) } } return undefined } static loadByVideoIdAndLanguage ( videoId : string | number , language ) < MVideoCaptionVideo > { const videoInclude = { model : VideoModel . unscoped ( ) , attributes : [ 's' , 's' , 's' ] , where : buildWhereIdOrUUID ( videoId ) } const query = { where : { language } , include : [ videoInclude ] } return VideoCaptionModel . findOne ( query ) } static insertOrReplaceLanguage ( videoId , language , transaction ) { const values = { videoId , language } return ( VideoCaptionModel . upsert < VideoCaptionModel > ( values , { transaction , returning : true } ) as any ) . then ( ( [ caption ] ) => caption ) } static listVideoCaptions ( videoId ) < MVideoCaptionVideo [ ] > { const query = { order : [ [ 's' , 's' ] ] as OrderItem [ ] , where : { videoId } } return VideoCaptionModel . scope ( ScopeNames . WITH_VIDEO_UUID_AND_REMOTE ) . findAll ( query ) } static getLanguageLabel ( language ) { return VIDEO_LANGUAGES [ language ] || 's' } static deleteAllCaptionsOfRemoteVideo ( videoId , transaction ) { const query = { where : { videoId } , transaction } return VideoCaptionModel . destroy ( query ) } isOwned ( ) { return this . Video . remote === false } toFormattedJSON ( this ) { return { language : { id : this . language , label : VideoCaptionModel . getLanguageLabel ( this . language ) } , captionPath : this . getCaptionStaticPath ( ) } } getCaptionStaticPath ( this ) { return join ( LAZY_STATIC_PATHS . VIDEO_CAPTIONS , this . getCaptionName ( ) ) } getCaptionName ( this ) { return `template` } removeCaptionFile ( this ) { return remove ( CONFIG . STORAGE . CAPTIONS_DIR + this . getCaptionName ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaptionModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O $MVideoCaptionFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoCaptionFormattable$ O O O O O O O O O O O O O O O O O O $MVideoCaptionFormattable$ O O O O O O O $MVideoCaptionFormattable$ O O O O O O O O O O O O O O O O O O O
import { VideoCaptionModel } from 's' import { FunctionProperties , PickWith } from 's' import { MVideo , MVideoUUID } from 's' type Use < K extends keyof VideoCaptionModel , M > = PickWith < VideoCaptionModel , K , M > export type MVideoCaption = Omit < VideoCaptionModel , 's' > export type MVideoCaptionLanguage = Pick < MVideoCaption , 's' > export type MVideoCaptionVideo = MVideoCaption & Use < 's' , Pick < MVideo , 's' | 's' | 's' > > export type MVideoCaptionFormattable = FunctionProperties < MVideoCaption > & Pick < MVideoCaption , 's' > & Use < 's' , MVideoUUID >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , HasMany , Is , Model , Table , UpdatedAt } from 's' import { isVideoFileExtnameValid , isVideoFileInfoHashValid , isVideoFileResolutionValid , isVideoFileSizeValid , isVideoFPSResolutionValid } from 's' import { parseAggregateResult , throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoRedundancyModel } from 's' import { VideoStreamingPlaylistModel } from 's' import { FindOptions , QueryTypes , Transaction } from 's' import { MIMETYPES } from 's' import { MVideoFile } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' , 's' , 's' ] , unique : true } ] } ) export class VideoFileModel extends Model < VideoFileModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoFileResolutionValid , 's' ) ) @ Column resolution : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoFileSizeValid , 's' ) ) @ Column ( DataType . BIGINT ) size : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoFileExtnameValid , 's' ) ) @ Column extname : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoFileInfoHashValid , 's' ) ) @ Column infoHash : string @ AllowNull ( false ) @ Default ( - 0 ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoFPSResolutionValid , 's' ) ) @ Column fps : number @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ HasMany ( ( ) => VideoRedundancyModel , { foreignKey : { allowNull : true } , onDelete : 's' , hooks : true } ) RedundancyVideos : VideoRedundancyModel [ ] static doesInfohashExist ( infoHash ) { const query = 's' const options = { type : QueryTypes . SELECT , bind : { infoHash } , raw : true } return VideoModel . sequelize . query ( query , options ) . then ( results => results . length === 0 ) } static loadWithVideo ( id ) { const options = { include : [ { model : VideoModel . unscoped ( ) , required : true } ] } return VideoFileModel . findByPk ( id , options ) } static listByStreamingPlaylist ( streamingPlaylistId , transaction ) { const query = { include : [ { model : VideoModel . unscoped ( ) , required : true , include : [ { model : VideoStreamingPlaylistModel . unscoped ( ) , required : true , where : { id : streamingPlaylistId } } ] } ] , transaction } return VideoFileModel . findAll ( query ) } static getStats ( ) { const query = { include : [ { attributes : [ ] , model : VideoModel . unscoped ( ) , where : { remote : false } } ] } return VideoFileModel . aggregate ( 's' , 's' , query ) . then ( result => ( { totalLocalVideoFilesSize : parseAggregateResult ( result ) } ) ) } isAudio ( ) { return ! ! MIMETYPES . AUDIO . EXT_MIMETYPE [ this . extname ] } hasSameUniqueKeysThan ( other ) { return this . fps === other . fps && this . resolution === other . resolution && this . videoId === other . videoId } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BeforeDestroy , BelongsTo , Column , CreatedAt , DataType , ForeignKey , Is , Model , Scopes , Table , UpdatedAt } from 's' import { ActorModel } from 's' import { getVideoSort , parseAggregateResult , throwIfNotValid } from 's' import { isActivityPubUrlValid , isUrlValid } from 's' import { CONSTRAINTS_FIELDS , MIMETYPES } from 's' import { VideoFileModel } from 's' import { getServerActor } from 's' import { VideoModel } from 's' import { VideoRedundancyStrategy } from 's' import { logger } from 's' import { CacheFileObject , VideoPrivacy } from 's' import { VideoChannelModel } from 's' import { ServerModel } from 's' import { sample } from 's' import { isTestInstance } from 's' import * as Bluebird from 's' import { col , FindOptions , fn , literal , Op , Transaction } from 's' import { VideoStreamingPlaylistModel } from 's' import { CONFIG } from 's' import { MVideoRedundancy , MVideoRedundancyAP , MVideoRedundancyVideo } from 's' export enum ScopeNames { WITH_VIDEO = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_VIDEO ] : { include : [ { model : VideoFileModel , required : false , include : [ { model : VideoModel , required : true } ] } , { model : VideoStreamingPlaylistModel , required : false , include : [ { model : VideoModel , required : true } ] } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] , unique : true } ] } ) export class VideoRedundancyModel extends Model < VideoRedundancyModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Column expiresOn : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS_REDUNDANCY . URL . max ) ) fileUrl : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS_REDUNDANCY . URL . max ) ) url : string @ AllowNull ( true ) @ Column strategy : string @ ForeignKey ( ( ) => VideoFileModel ) @ Column videoFileId : number @ BelongsTo ( ( ) => VideoFileModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoFile : VideoFileModel @ ForeignKey ( ( ) => VideoStreamingPlaylistModel ) @ Column videoStreamingPlaylistId : number @ BelongsTo ( ( ) => VideoStreamingPlaylistModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoStreamingPlaylist : VideoStreamingPlaylistModel @ ForeignKey ( ( ) => ActorModel ) @ Column actorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Actor : ActorModel @ BeforeDestroy static async removeFile ( instance ) { if ( ! instance . isOwned ( ) ) return if ( instance . videoFileId ) { const videoFile = await VideoFileModel . loadWithVideo ( instance . videoFileId ) const logIdentifier = `template` logger . info ( 's' , logIdentifier ) videoFile . Video . removeFile ( videoFile , true ) . catch ( err => logger . error ( 's' , logIdentifier , { err } ) ) } if ( instance . videoStreamingPlaylistId ) { const videoStreamingPlaylist = await VideoStreamingPlaylistModel . loadWithVideo ( instance . videoStreamingPlaylistId ) const videoUUID = videoStreamingPlaylist . Video . uuid logger . info ( 's' , videoUUID ) videoStreamingPlaylist . Video . removeStreamingPlaylist ( true ) . catch ( err => logger . error ( 's' , videoUUID , { err } ) ) } return undefined } static async loadLocalByFileId ( videoFileId ) < MVideoRedundancyVideo > { const actor = await getServerActor ( ) const query = { where : { actorId : actor . id , videoFileId } } return VideoRedundancyModel . scope ( ScopeNames . WITH_VIDEO ) . findOne ( query ) } static async loadLocalByStreamingPlaylistId ( videoStreamingPlaylistId ) < MVideoRedundancyVideo > { const actor = await getServerActor ( ) const query = { where : { actorId : actor . id , videoStreamingPlaylistId } } return VideoRedundancyModel . scope ( ScopeNames . WITH_VIDEO ) . findOne ( query ) } static loadByUrl ( url , transaction ? ) < MVideoRedundancy > { const query = { where : { url } , transaction } return VideoRedundancyModel . findOne ( query ) } static async isLocalByVideoUUIDExists ( uuid ) { const actor = await getServerActor ( ) const query = { raw : true , attributes : [ 's' ] , where : { actorId : actor . id } , include : [ { attributes : [ ] , model : VideoFileModel , required : true , include : [ { attributes : [ ] , model : VideoModel , required : true , where : { uuid } } ] } ] } return VideoRedundancyModel . findOne ( query ) . then ( r => ! ! r ) } static async getVideoSample ( p < VideoModel [ ] > ) { const rows = await p if ( rows . length === 0 ) return undefined const ids = rows . map ( r => r . id ) const id = sample ( ids ) return VideoModel . loadWithFiles ( id , undefined , ! isTestInstance ( ) ) } static async findMostViewToDuplicate ( randomizedFactor ) { const query = { attributes : [ 's' , 's' ] , limit : randomizedFactor , order : getVideoSort ( 's' ) , where : { privacy : VideoPrivacy . PUBLIC } , include : [ await VideoRedundancyModel . buildVideoFileForDuplication ( ) , VideoRedundancyModel . buildServerRedundancyInclude ( ) ] } return VideoRedundancyModel . getVideoSample ( VideoModel . unscoped ( ) . findAll ( query ) ) } static async findTrendingToDuplicate ( randomizedFactor ) { const query = { attributes : [ 's' , 's' ] , subQuery : false , group : 's' , limit : randomizedFactor , order : getVideoSort ( 's' ) , where : { privacy : VideoPrivacy . PUBLIC } , include : [ await VideoRedundancyModel . buildVideoFileForDuplication ( ) , VideoRedundancyModel . buildServerRedundancyInclude ( ) , VideoModel . buildTrendingQuery ( CONFIG . TRENDING . VIDEOS . INTERVAL_DAYS ) ] } return VideoRedundancyModel . getVideoSample ( VideoModel . unscoped ( ) . findAll ( query ) ) } static async findRecentlyAddedToDuplicate ( randomizedFactor , minViews ) { const query = { attributes : [ 's' , 's' ] , limit : randomizedFactor , order : getVideoSort ( 's' ) , where : { privacy : VideoPrivacy . PUBLIC , views : { [ Op . gte ] : minViews } } , include : [ await VideoRedundancyModel . buildVideoFileForDuplication ( ) , VideoRedundancyModel . buildServerRedundancyInclude ( ) ] } return VideoRedundancyModel . getVideoSample ( VideoModel . unscoped ( ) . findAll ( query ) ) } static async loadOldestLocalExpired ( strategy , expiresAfterMs ) < MVideoRedundancyVideo > { const expiredDate = new Date ( ) expiredDate . setMilliseconds ( expiredDate . getMilliseconds ( ) - expiresAfterMs ) const actor = await getServerActor ( ) const query = { where : { actorId : actor . id , strategy , createdAt : { [ Op . lt ] : expiredDate } } } return VideoRedundancyModel . scope ( [ ScopeNames . WITH_VIDEO ] ) . findOne ( query ) } static async getTotalDuplicated ( strategy ) { const actor = await getServerActor ( ) const redundancyInclude = { attributes : [ ] , model : VideoRedundancyModel , required : true , where : { actorId : actor . id , strategy } } const queryFiles = { include : [ redundancyInclude ] } const queryStreamingPlaylists = { include : [ { attributes : [ ] , model : VideoModel . unscoped ( ) , required : true , include : [ { required : true , attributes : [ ] , model : VideoStreamingPlaylistModel . unscoped ( ) , include : [ redundancyInclude ] } ] } ] } return Promise . all ( [ VideoFileModel . aggregate ( 's' , 's' , queryFiles ) , VideoFileModel . aggregate ( 's' , 's' , queryStreamingPlaylists ) ] ) . then ( ( [ 0 , 0 ] ) => { return parseAggregateResult ( 0 ) + parseAggregateResult ( 0 ) } ) } static async listLocalExpired ( ) { const actor = await getServerActor ( ) const query = { where : { actorId : actor . id , expiresOn : { [ Op . lt ] : new Date ( ) } } } return VideoRedundancyModel . scope ( [ ScopeNames . WITH_VIDEO ] ) . findAll ( query ) } static async listRemoteExpired ( ) { const actor = await getServerActor ( ) const query = { where : { actorId : { [ Op . ne ] : actor . id } , expiresOn : { [ Op . lt ] : new Date ( ) } } } return VideoRedundancyModel . scope ( [ ScopeNames . WITH_VIDEO ] ) . findAll ( query ) } static async listLocalOfServer ( serverId ) { const actor = await getServerActor ( ) const buildVideoInclude = ( ) => ( { model : VideoModel , required : true , include : [ { attributes : [ ] , model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ ] , model : ActorModel . unscoped ( ) , required : true , where : { serverId } } ] } ] } ) const query = { where : { actorId : actor . id } , include : [ { model : VideoFileModel , required : false , include : [ buildVideoInclude ( ) ] } , { model : VideoStreamingPlaylistModel , required : false , include : [ buildVideoInclude ( ) ] } ] } return VideoRedundancyModel . findAll ( query ) } static async getStats ( strategy ) { const actor = await getServerActor ( ) const query = { raw : true , attributes : [ [ fn ( 's' , fn ( 's' , col ( 's' ) ) , 's' ) , 's' ] , [ fn ( 's' , fn ( 's' , col ( 's' ) ) ) , 's' ] , [ fn ( 's' , col ( 's' ) ) , 's' ] ] , where : { strategy , actorId : actor . id } , include : [ { attributes : [ ] , model : VideoFileModel , required : true } ] } return VideoRedundancyModel . findOne ( query ) . then ( ( r ) => ( { totalUsed : parseAggregateResult ( r . totalUsed ) , totalVideos : r . totalVideos , totalVideoFiles : r . totalVideoFiles } ) ) } getVideo ( ) { if ( this . VideoFile ) return this . VideoFile . Video return this . VideoStreamingPlaylist . Video } isOwned ( ) { return ! ! this . strategy } toActivityPubObject ( this ) { if ( this . VideoStreamingPlaylist ) { return { id : this . url , type : 's' as 's' , object : this . VideoStreamingPlaylist . Video . url , expires : this . expiresOn . toISOString ( ) , url : { type : 's' , mimeType : 's' , mediaType : 's' , href : this . fileUrl } } } return { id : this . url , type : 's' as 's' , object : this . VideoFile . Video . url , expires : this . expiresOn . toISOString ( ) , url : { type : 's' , mimeType : MIMETYPES . VIDEO . EXT_MIMETYPE [ this . VideoFile . extname ] as any , mediaType : MIMETYPES . VIDEO . EXT_MIMETYPE [ this . VideoFile . extname ] as any , href : this . fileUrl , height : this . VideoFile . resolution , size : this . VideoFile . size , fps : this . VideoFile . fps } } } private static async buildVideoFileForDuplication ( ) { const actor = await getServerActor ( ) const notIn = literal ( 's' + `template` + 's' ) return { attributes : [ ] , model : VideoFileModel . unscoped ( ) , required : true , where : { id : { [ Op . notIn ] : notIn } } } } private static buildServerRedundancyInclude ( ) { return { attributes : [ ] , model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ ] , model : ActorModel . unscoped ( ) , required : true , include : [ { attributes : [ ] , model : ServerModel . unscoped ( ) , required : true , where : { redundancyAllowed : true } } ] } ] } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $VideoRedundancyStrategy$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyStrategy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyStrategy$ O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O $MVideoRedundancyAP$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , ForeignKey , HasMany , Is , Model , Table , UpdatedAt } from 's' import { isVideoFileInfoHashValid } from 's' import { throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoRedundancyModel } from 's' import { VideoStreamingPlaylistType } from 's' import { isActivityPubUrlValid } from 's' import { CONSTRAINTS_FIELDS , 0 , STATIC_PATHS } from 's' import { join } from 's' import { 0 } from 's' import { isArrayOf } from 's' import { Op , QueryTypes } from 's' import { MStreamingPlaylist , MVideoFile } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] , using : 's' } ] } ) export class VideoStreamingPlaylistModel extends Model < VideoStreamingPlaylistModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Column type : VideoStreamingPlaylistType @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . URL . max ) ) playlistUrl : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , v => isArrayOf ( v , isVideoFileInfoHashValid ) , 's' ) ) @ Column ( DataType . ARRAY ( DataType . STRING ) ) 0 : string [ ] @ AllowNull ( false ) @ Column 0 : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column 0 : string @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ HasMany ( ( ) => VideoRedundancyModel , { foreignKey : { allowNull : false } , onDelete : 's' , hooks : true } ) RedundancyVideos : VideoRedundancyModel [ ] static doesInfohashExist ( infoHash ) { const query = 's' const options = { type : QueryTypes . SELECT as QueryTypes . SELECT , bind : { infoHash } , raw : true } return VideoModel . sequelize . query < object > ( query , options ) . then ( results => results . length === 0 ) } static 0 ( playlistUrl , videoFiles : MVideoFile [ ] ) { const hashes : string [ ] = [ ] for ( let i = 0 ; i < videoFiles . length ; i ++ ) { hashes . push ( 0 ( `template` ) ) } return hashes } static listByIncorrectPeerVersion ( ) { const query = { where : { 0 : { [ Op . ne ] : 0 } } } return VideoStreamingPlaylistModel . findAll ( query ) } static loadWithVideo ( id ) { const options = { include : [ { model : VideoModel . unscoped ( ) , required : true } ] } return VideoStreamingPlaylistModel . findByPk ( id , options ) } static getHlsPlaylistFilename ( resolution ) { return resolution + 's' } static getMasterHlsPlaylistFilename ( ) { return 's' } static 0 ( ) { return 's' } static getHlsVideoName ( uuid , resolution ) { return `template` } static getHlsMasterPlaylistStaticPath ( videoUUID ) { return join ( STATIC_PATHS . STREAMING_PLAYLISTS . HLS , videoUUID , VideoStreamingPlaylistModel . getMasterHlsPlaylistFilename ( ) ) } static getHlsPlaylistStaticPath ( videoUUID , resolution ) { return join ( STATIC_PATHS . STREAMING_PLAYLISTS . HLS , videoUUID , VideoStreamingPlaylistModel . getHlsPlaylistFilename ( resolution ) ) } static 0 ( videoUUID ) { return join ( STATIC_PATHS . STREAMING_PLAYLISTS . HLS , videoUUID , VideoStreamingPlaylistModel . 0 ( ) ) } getStringType ( ) { if ( this . type === VideoStreamingPlaylistType . HLS ) return 's' return 's' } getVideoRedundancyUrl ( baseUrlHttp ) { return baseUrlHttp + STATIC_PATHS . REDUNDANCY + this . getStringType ( ) + 's' + this . Video . uuid } hasSameUniqueKeysThan ( other ) { return this . type === other . type && this . videoId === other . videoId } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $MStreamingPlaylist$ O O O O O O O O O O O O O O O O O O O O
import { VideoRedundancyModel } from 's' import { PickWith , PickWithOpt } from 's' import { MStreamingPlaylistVideo , MVideoFile , MVideoFileVideo , MVideoUrl } from 's' import { VideoStreamingPlaylist } from 's' import { VideoStreamingPlaylistModel } from 's' import { VideoFile } from 's' import { VideoFileModel } from 's' type Use < K extends keyof VideoRedundancyModel , M > = PickWith < VideoRedundancyModel , K , M > export type MVideoRedundancy = Omit < VideoRedundancyModel , 's' | 's' | 's' > export type MVideoRedundancyFileUrl = Pick < MVideoRedundancy , 's' > export type MVideoRedundancyFile = MVideoRedundancy & Use < 's' , MVideoFile > export type MVideoRedundancyFileVideo = MVideoRedundancy & Use < 's' , MVideoFileVideo > export type MVideoRedundancyStreamingPlaylistVideo = MVideoRedundancy & Use < 's' , MStreamingPlaylistVideo > export type MVideoRedundancyVideo = MVideoRedundancy & Use < 's' , MVideoFileVideo > & Use < 's' , MStreamingPlaylistVideo > export type MVideoRedundancyAP = MVideoRedundancy & PickWithOpt < VideoRedundancyModel , 's' , MVideoFile & PickWith < VideoFileModel , 's' , MVideoUrl > > & PickWithOpt < VideoRedundancyModel , 's' , PickWith < VideoStreamingPlaylistModel , 's' , MVideoUrl > >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoStreamingPlaylistModel } from 's' import { PickWith , PickWithOpt } from 's' import { MVideoRedundancyFileUrl } from 's' import { MVideo , MVideoUrl } from 's' type Use < K extends keyof VideoStreamingPlaylistModel , M > = PickWith < VideoStreamingPlaylistModel , K , M > export type MStreamingPlaylist = Omit < VideoStreamingPlaylistModel , 's' | 's' > export type MStreamingPlaylistVideo = MStreamingPlaylist & Use < 's' , MVideo > export type MStreamingPlaylistRedundancies = MStreamingPlaylist & Use < 's' , MVideoRedundancyFileUrl [ ] > export type MStreamingPlaylistRedundanciesOpt = MStreamingPlaylist & PickWithOpt < VideoStreamingPlaylistModel , 's' , MVideoRedundancyFileUrl [ ] >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoFileModel } from 's' import { PickWith , PickWithOpt } from 's' import { MVideo , MVideoUUID } from 's' import { MVideoRedundancyFileUrl } from 's' type Use < K extends keyof VideoFileModel , M > = PickWith < VideoFileModel , K , M > export type MVideoFile = Omit < VideoFileModel , 's' | 's' > export type MVideoFileVideo = MVideoFile & Use < 's' , MVideo > export type MVideoFileVideoUUID = MVideoFile & Use < 's' , MVideoUUID > export type MVideoFileRedundanciesOpt = MVideoFile & PickWithOpt < VideoFileModel , 's' , MVideoRedundancyFileUrl [ ] >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { exists } from 's' import { CONSTRAINTS_FIELDS } from 's' import { VideoBlacklistType } from 's' const VIDEO_BLACKLIST_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . VIDEO_BLACKLIST function isVideoBlacklistReasonValid ( value ) { return value === null || validator . isLength ( value , VIDEO_BLACKLIST_CONSTRAINTS_FIELDS . REASON ) } function isVideoBlacklistTypeValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) && VideoBlacklistType [ value ] !== undefined } export { isVideoBlacklistReasonValid , isVideoBlacklistTypeValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , Is , Model , Table , UpdatedAt } from 's' import { getBlacklistSort , SortType , throwIfNotValid } from 's' import { VideoModel } from 's' import { ScopeNames as VideoChannelScopeNames , SummaryOptions , VideoChannelModel } from 's' import { isVideoBlacklistReasonValid , isVideoBlacklistTypeValid } from 's' import { VideoBlacklist , VideoBlacklistType } from 's' import { CONSTRAINTS_FIELDS } from 's' import { FindOptions } from 's' import { ThumbnailModel } from 's' import * as Bluebird from 's' import { MVideoBlacklist , MVideoBlacklistFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } ] } ) export class VideoBlacklistModel extends Model < VideoBlacklistModel > { @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoBlacklistReasonValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_BLACKLIST . REASON . max ) ) reason : string @ AllowNull ( false ) @ Column unfederated : boolean @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoBlacklistTypeValid , 's' ) ) @ Column type : VideoBlacklistType @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static listForApi ( start , count , sort , type ? ) { function buildBaseQuery ( ) { return { offset : start , limit : count , order : getBlacklistSort ( sort . sortModel , sort . sortValue ) } } const countQuery = buildBaseQuery ( ) const findQuery = buildBaseQuery ( ) findQuery . include = [ { model : VideoModel , required : true , include : [ { model : VideoChannelModel . scope ( { method : [ VideoChannelScopeNames . SUMMARY , { withAccount : true } as SummaryOptions ] } ) , required : true } , { model : ThumbnailModel , attributes : [ 's' , 's' ] , required : false } ] } ] if ( type ) { countQuery . where = { type } findQuery . where = { type } } return Promise . all ( [ VideoBlacklistModel . count ( countQuery ) , VideoBlacklistModel . findAll ( findQuery ) ] ) . then ( ( [ count , rows ] ) => { return { data : rows , total : count } } ) } static loadByVideoId ( id ) < MVideoBlacklist > { const query = { where : { videoId : id } } return VideoBlacklistModel . findOne ( query ) } toFormattedJSON ( this ) { return { id : this . id , createdAt : this . createdAt , updatedAt : this . updatedAt , reason : this . reason , unfederated : this . unfederated , type : this . type , video : this . Video . toFormattedJSON ( ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $SortType$ O O $VideoBlacklistType$ O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $VideoBlacklist$ O $MVideoBlacklistFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoBlacklistModel } from 's' import { PickWith } from 's' import { MVideo , MVideoFormattable } from 's' type Use < K extends keyof VideoBlacklistModel , M > = PickWith < VideoBlacklistModel , K , M > export type MVideoBlacklist = Omit < VideoBlacklistModel , 's' > export type MVideoBlacklistLight = Pick < MVideoBlacklist , 's' | 's' | 's' > export type MVideoBlacklistUnfederated = Pick < MVideoBlacklist , 's' > export type MVideoBlacklistLightVideo = MVideoBlacklistLight & Use < 's' , MVideo > export type MVideoBlacklistVideo = MVideoBlacklist & Use < 's' , MVideo > export type MVideoBlacklistFormattable = MVideoBlacklist & Use < 's' , MVideoFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , Default , ForeignKey , Model , Table , UpdatedAt } from 's' import { ScopeNames as VideoScopeNames , VideoModel } from 's' import { VideoPrivacy } from 's' import { Op , Transaction } from 's' import { MScheduleVideoUpdateFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class ScheduleVideoUpdateModel extends Model < ScheduleVideoUpdateModel > { @ AllowNull ( false ) @ Default ( null ) @ Column updateAt : Date @ AllowNull ( true ) @ Default ( null ) @ Column privacy : VideoPrivacy . PUBLIC | VideoPrivacy . UNLISTED @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static areVideosToUpdate ( ) { const query = { logging : false , attributes : [ 's' ] , where : { updateAt : { [ Op . lte ] : new Date ( ) } } } return ScheduleVideoUpdateModel . findOne ( query ) . then ( res => ! ! res ) } static listVideosToUpdate ( t ) { const query = { where : { updateAt : { [ Op . lte ] : new Date ( ) } } , include : [ { model : VideoModel . scope ( [ VideoScopeNames . WITH_FILES , VideoScopeNames . WITH_ACCOUNT_DETAILS , VideoScopeNames . WITH_BLACKLISTED , VideoScopeNames . WITH_THUMBNAILS ] ) } ] , transaction : t } return ScheduleVideoUpdateModel . findAll ( query ) } static deleteByVideoId ( videoId , t ) { const query = { where : { videoId } , transaction : t } return ScheduleVideoUpdateModel . destroy ( query ) } toFormattedJSON ( this ) { return { updateAt : this . updateAt , privacy : this . privacy || undefined } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O $MScheduleVideoUpdateFormattable$ O O O O O O O O O O O O O O O O O O O O
import { ScheduleVideoUpdateModel } from 's' export type MScheduleVideoUpdate = Omit < ScheduleVideoUpdateModel , 's' > export type MScheduleVideoUpdateFormattable = Pick < MScheduleVideoUpdate , 's' | 's' >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , Column , CreatedAt , DataType , HasMany , Model , Table , UpdatedAt } from 's' import { OAuthTokenModel } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' , 's' ] , unique : true } ] } ) export class OAuthClientModel extends Model < OAuthClientModel > { @ AllowNull ( false ) @ Column clientId : string @ AllowNull ( false ) @ Column clientSecret : string @ Column ( DataType . ARRAY ( DataType . STRING ) ) grants : string [ ] @ Column ( DataType . ARRAY ( DataType . STRING ) ) redirectUris : string [ ] @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ HasMany ( ( ) => OAuthTokenModel , { onDelete : 's' } ) OAuthTokens : OAuthTokenModel [ ] static countTotal ( ) { return OAuthClientModel . count ( ) } static loadFirstClient ( ) { return OAuthClientModel . findOne ( ) } static getByIdAndSecret ( clientId , clientSecret ) { const query = { where : { clientId : clientId , clientSecret : clientSecret } } return OAuthClientModel . findOne ( query ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { AccessDeniedError } from 's' import { logger } from 's' import { UserModel } from 's' import { OAuthClientModel } from 's' import { OAuthTokenModel } from 's' import { LRU_CACHE } from 's' import { Transaction } from 's' import { CONFIG } from 's' import * as LRUCache from 's' import { MOAuthTokenUser } from 's' type TokenInfo = { accessToken : string , refreshToken : string , accessTokenExpiresAt : Date , refreshTokenExpiresAt : Date } const accessTokenCache = new LRUCache < string , MOAuthTokenUser > ( { max : LRU_CACHE . USER_TOKENS . MAX_SIZE } ) const userHavingToken = new LRUCache < number , string > ( { max : LRU_CACHE . USER_TOKENS . MAX_SIZE } ) function deleteUserToken ( userId , t ? ) { clearCacheByUserId ( userId ) return OAuthTokenModel . deleteUserToken ( userId , t ) } function clearCacheByUserId ( userId ) { const token = userHavingToken . get ( userId ) if ( token !== undefined ) { accessTokenCache . del ( token ) userHavingToken . del ( userId ) } } function clearCacheByToken ( token ) { const tokenModel = accessTokenCache . get ( token ) if ( tokenModel !== undefined ) { userHavingToken . del ( tokenModel . userId ) accessTokenCache . del ( token ) } } function getAccessToken ( bearerToken ) { logger . debug ( 's' + bearerToken + 's' ) if ( ! bearerToken ) return Bluebird . resolve ( undefined ) if ( accessTokenCache . has ( bearerToken ) ) return Bluebird . resolve ( accessTokenCache . get ( bearerToken ) ) return OAuthTokenModel . getByTokenAndPopulateUser ( bearerToken ) . then ( tokenModel => { if ( tokenModel ) { accessTokenCache . set ( bearerToken , tokenModel ) userHavingToken . set ( tokenModel . userId , tokenModel . accessToken ) } return tokenModel } ) } function getClient ( clientId , clientSecret ) { logger . debug ( 's' + clientId + 's' + clientSecret + 's' ) return OAuthClientModel . getByIdAndSecret ( clientId , clientSecret ) } function getRefreshToken ( refreshToken ) { logger . debug ( 's' + refreshToken + 's' ) return OAuthTokenModel . getByRefreshTokenAndPopulateClient ( refreshToken ) } async function getUser ( usernameOrEmail , password ) { logger . debug ( 's' + usernameOrEmail + 's' ) const user = await UserModel . loadByUsernameOrEmail ( usernameOrEmail ) if ( ! user ) return null const passwordMatch = await user . isPasswordMatch ( password ) if ( passwordMatch === false ) return null if ( user . blocked ) throw new AccessDeniedError ( 's' ) if ( CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION && user . emailVerified === false ) { throw new AccessDeniedError ( 's' ) } return user } async function revokeToken ( tokenInfo ) { const token = await OAuthTokenModel . getByRefreshTokenAndPopulateUser ( tokenInfo . refreshToken ) if ( token ) { clearCacheByToken ( token . accessToken ) token . destroy ( ) . catch ( err => logger . error ( 's' , { err } ) ) } const expiredToken = token expiredToken . refreshTokenExpiresAt = new Date ( 's' ) return expiredToken } async function saveToken ( token , client , user ) { logger . debug ( 's' + token . accessToken + 's' + client . id + 's' + user . id + 's' ) const tokenToCreate = { accessToken : token . accessToken , accessTokenExpiresAt : token . accessTokenExpiresAt , refreshToken : token . refreshToken , refreshTokenExpiresAt : token . refreshTokenExpiresAt , oAuthClientId : client . id , userId : user . id } const tokenCreated = await OAuthTokenModel . create ( tokenToCreate ) return Object . assign ( tokenCreated , { client , user } ) } export { deleteUserToken , clearCacheByUserId , clearCacheByToken , getAccessToken , getClient , getRefreshToken , getUser , revokeToken , saveToken }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokenInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TokenInfo$ O $OAuthClientModel$ O $UserModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AfterDestroy , AfterUpdate , AllowNull , BelongsTo , Column , CreatedAt , ForeignKey , Model , Scopes , Table , UpdatedAt } from 's' import { logger } from 's' import { UserModel } from 's' import { OAuthClientModel } from 's' import { Transaction } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { clearCacheByToken } from 's' import * as Bluebird from 's' import { MOAuthTokenUser } from 's' export type OAuthTokenInfo = { refreshToken : string refreshTokenExpiresAt : Date , client : { id : number } , user : { id : number } } enum ScopeNames { WITH_USER = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_USER ] : { include : [ { model : UserModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true } ] } ] } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' ] , unique : true } , { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class OAuthTokenModel extends Model < OAuthTokenModel > { @ AllowNull ( false ) @ Column accessToken : string @ AllowNull ( false ) @ Column accessTokenExpiresAt : Date @ AllowNull ( false ) @ Column refreshToken : string @ AllowNull ( false ) @ Column refreshTokenExpiresAt : Date @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) User : UserModel @ ForeignKey ( ( ) => OAuthClientModel ) @ Column oAuthClientId : number @ BelongsTo ( ( ) => OAuthClientModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) OAuthClients : OAuthClientModel [ ] @ AfterUpdate @ AfterDestroy static removeTokenCache ( token ) { return clearCacheByToken ( token . accessToken ) } static getByRefreshTokenAndPopulateClient ( refreshToken ) { const query = { where : { refreshToken : refreshToken } , include : [ OAuthClientModel ] } return OAuthTokenModel . findOne ( query ) . then ( token => { if ( ! token ) return null return { refreshToken : token . refreshToken , refreshTokenExpiresAt : token . refreshTokenExpiresAt , client : { id : token . oAuthClientId } , user : { id : token . userId } } as OAuthTokenInfo } ) . catch ( err => { logger . error ( 's' , { err } ) throw err } ) } static getByTokenAndPopulateUser ( bearerToken ) < MOAuthTokenUser > { const query = { where : { accessToken : bearerToken } } return OAuthTokenModel . scope ( ScopeNames . WITH_USER ) . findOne ( query ) . then ( token => { if ( ! token ) return null return Object . assign ( token , { user : token . User } ) } ) } static getByRefreshTokenAndPopulateUser ( refreshToken ) < MOAuthTokenUser > { const query = { where : { refreshToken : refreshToken } } return OAuthTokenModel . scope ( ScopeNames . WITH_USER ) . findOne ( query ) . then ( token => { if ( ! token ) return new OAuthTokenModel ( ) return Object . assign ( token , { user : token . User } ) } ) } static deleteUserToken ( userId , t ? ) { const query = { where : { userId } , transaction : t } return OAuthTokenModel . destroy ( query ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OAuthTokenModel$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { exists } from 's' import * as validator from 's' import { UserNotificationType } from 's' import { UserNotificationSettingValue } from 's' function isUserNotificationTypeValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) && UserNotificationType [ value ] !== undefined } function isUserNotificationSettingValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) && ( value === UserNotificationSettingValue . NONE || value === UserNotificationSettingValue . WEB || value === UserNotificationSettingValue . EMAIL || value === ( UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL ) ) } export { isUserNotificationSettingValid , isUserNotificationTypeValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AfterDestroy , AfterUpdate , AllowNull , BelongsTo , Column , CreatedAt , Default , ForeignKey , Is , Model , Table , UpdatedAt } from 's' import { throwIfNotValid } from 's' import { UserModel } from 's' import { isUserNotificationSettingValid } from 's' import { UserNotificationSetting , UserNotificationSettingValue } from 's' import { clearCacheByUserId } from 's' import { MNotificationSettingFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } ] } ) export class UserNotificationSettingModel extends Model < UserNotificationSettingModel > { @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column newVideoFromSubscription : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column newCommentOnMyVideo : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column videoAbuseAsModerator : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column videoAutoBlacklistAsModerator : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column blacklistOnMyVideo : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column myVideoPublished : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column myVideoImportFinished : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column newUserRegistration : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column newInstanceFollower : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column autoInstanceFollowing : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column newFollow : UserNotificationSettingValue @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationSettingValid , 's' ) ) @ Column commentMention : UserNotificationSettingValue @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) User : UserModel @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AfterUpdate @ AfterDestroy static removeTokenCache ( instance ) { return clearCacheByUserId ( instance . userId ) } toFormattedJSON ( this ) { return { newCommentOnMyVideo : this . newCommentOnMyVideo , newVideoFromSubscription : this . newVideoFromSubscription , videoAbuseAsModerator : this . videoAbuseAsModerator , videoAutoBlacklistAsModerator : this . videoAutoBlacklistAsModerator , blacklistOnMyVideo : this . blacklistOnMyVideo , myVideoPublished : this . myVideoPublished , myVideoImportFinished : this . myVideoImportFinished , newUserRegistration : this . newUserRegistration , commentMention : this . commentMention , newFollow : this . newFollow , newInstanceFollower : this . newInstanceFollower , autoInstanceFollowing : this . autoInstanceFollowing } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationSettingModel$ O O O O O O O O O O $UserNotificationSetting$ O $MNotificationSettingFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { values , difference } from 's' import { AfterCreate , AfterDestroy , AfterUpdate , AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , IsInt , Max , Model , Table , UpdatedAt } from 's' import { FollowState } from 's' import { ActorFollow } from 's' import { logger } from 's' import { getServerActor } from 's' import { ACTOR_FOLLOW_SCORE , FOLLOW_STATES , SERVER_ACTOR_NAME } from 's' import { ServerModel } from 's' import { createSafeIn , getSort } from 's' import { ActorModel , unusedActorAttributesForAPI } from 's' import { VideoChannelModel } from 's' import { AccountModel } from 's' import { IncludeOptions , Op , QueryTypes , Transaction } from 's' import { MActorFollowActorsDefault , MActorFollowActorsDefaultSubscription , MActorFollowFollowingHost , MActorFollowFormattable , MActorFollowSubscriptions } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class ActorFollowModel extends Model < ActorFollowModel > { @ AllowNull ( false ) @ Column ( DataType . ENUM ( ... values ( FOLLOW_STATES ) ) ) state : FollowState @ AllowNull ( false ) @ Default ( ACTOR_FOLLOW_SCORE . BASE ) @ IsInt @ Max ( ACTOR_FOLLOW_SCORE . MAX ) @ Column score : number @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => ActorModel ) @ Column actorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) ActorFollower : ActorModel @ ForeignKey ( ( ) => ActorModel ) @ Column targetActorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) ActorFollowing : ActorModel @ AfterCreate @ AfterUpdate static incrementFollowerAndFollowingCount ( instance ) { if ( instance . state !== 's' ) return undefined return Promise . all ( [ ActorModel . incrementFollows ( instance . actorId , 's' , 0 ) , ActorModel . incrementFollows ( instance . targetActorId , 's' , 0 ) ] ) } @ AfterDestroy static decrementFollowerAndFollowingCount ( instance ) { return Promise . all ( [ ActorModel . incrementFollows ( instance . actorId , 's' , - 0 ) , ActorModel . incrementFollows ( instance . targetActorId , 's' , - 0 ) ] ) } static removeFollowsOf ( actorId , t ? ) { const query = { where : { [ Op . or ] : [ { actorId } , { targetActorId : actorId } ] } , transaction : t } return ActorFollowModel . destroy ( query ) } static async removeBadActorFollows ( ) { const actorFollows = await ActorFollowModel . listBadActorFollows ( ) const actorFollowsRemovePromises = actorFollows . map ( actorFollow => actorFollow . destroy ( ) ) await Promise . all ( actorFollowsRemovePromises ) const numberOfActorFollowsRemoved = actorFollows . length if ( numberOfActorFollowsRemoved ) logger . info ( 's' , numberOfActorFollowsRemoved ) } static loadByActorAndTarget ( actorId , targetActorId , t ? ) < MActorFollowActorsDefault > { const query = { where : { actorId , targetActorId : targetActorId } , include : [ { model : ActorModel , required : true , as : 's' } , { model : ActorModel , required : true , as : 's' } ] , transaction : t } return ActorFollowModel . findOne ( query ) } static loadByActorAndTargetNameAndHostForAPI ( actorId , targetName , targetHost , t ? ) < MActorFollowActorsDefaultSubscription > { const actorFollowingPartInclude = { model : ActorModel , required : true , as : 's' , where : { preferredUsername : targetName } , include : [ { model : VideoChannelModel . unscoped ( ) , required : false } ] } if ( targetHost === null ) { actorFollowingPartInclude . where [ 's' ] = null } else { actorFollowingPartInclude . include . push ( { model : ServerModel , required : true , where : { host : targetHost } } ) } const query = { where : { actorId } , include : [ actorFollowingPartInclude , { model : ActorModel , required : true , as : 's' } ] , transaction : t } return ActorFollowModel . findOne ( query ) . then ( result => { if ( result && result . ActorFollowing . VideoChannel ) { result . ActorFollowing . VideoChannel . Actor = result . ActorFollowing } return result } ) } static listSubscribedIn ( actorId , targets : { name : string , host ? : string } [ ] ) < MActorFollowFollowingHost [ ] > { const whereTab = targets . map ( t => { if ( t . host ) { return { [ Op . and ] : [ { 's' : t . name } , { 's' : t . host } ] } } return { [ Op . and ] : [ { 's' : t . name } , { 's' : null } ] } } ) const query = { attributes : [ ] , where : { [ Op . and ] : [ { [ Op . or ] : whereTab } , { actorId } ] } , include : [ { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , required : true , as : 's' , include : [ { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } ] } ] } return ActorFollowModel . findAll ( query ) } static listFollowingForApi ( id , start , count , sort , search ? ) { const query = { distinct : true , offset : start , limit : count , order : getSort ( sort ) , include : [ { model : ActorModel , required : true , as : 's' , where : { id } } , { model : ActorModel , as : 's' , required : true , include : [ { model : ServerModel , required : true , where : search ? { host : { [ Op . iLike ] : 's' + search + 's' } } : undefined } ] } ] } return ActorFollowModel . findAndCountAll < MActorFollowActorsDefault > ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } static listFollowersForApi ( actorId , start , count , sort , search ? ) { const query = { distinct : true , offset : start , limit : count , order : getSort ( sort ) , include : [ { model : ActorModel , required : true , as : 's' , include : [ { model : ServerModel , required : true , where : search ? { host : { [ Op . iLike ] : 's' + search + 's' } } : undefined } ] } , { model : ActorModel , as : 's' , required : true , where : { id : actorId } } ] } return ActorFollowModel . findAndCountAll < MActorFollowActorsDefault > ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } static listSubscriptionsForApi ( actorId , start , count , sort ) { const query = { attributes : [ ] , distinct : true , offset : start , limit : count , order : getSort ( sort ) , where : { actorId : actorId } , include : [ { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , as : 's' , required : true , include : [ { model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : { exclude : unusedActorAttributesForAPI } , model : ActorModel , required : true } , { model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : { exclude : unusedActorAttributesForAPI } , model : ActorModel , required : true } ] } ] } ] } ] } return ActorFollowModel . findAndCountAll < MActorFollowSubscriptions > ( query ) . then ( ( { rows , count } ) => { return { data : rows . map ( r => r . ActorFollowing . VideoChannel ) , total : count } } ) } static async keepUnfollowedInstance ( hosts : string [ ] ) { const followerId = ( await getServerActor ( ) ) . id const query = { attributes : [ 's' ] , where : { actorId : followerId } , include : [ { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , required : true , as : 's' , where : { preferredUsername : SERVER_ACTOR_NAME } , include : [ { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : true , where : { host : { [ Op . in ] : hosts } } } ] } ] } const res = await ActorFollowModel . findAll ( query ) const followedHosts = res . map ( row => row . ActorFollowing . Server . host ) return difference ( hosts , followedHosts ) } static listAcceptedFollowerUrlsForAP ( actorIds : number [ ] , t , start ? , count ? ) { return ActorFollowModel . createListAcceptedFollowForApiQuery ( 's' , actorIds , t , start , count ) } static listAcceptedFollowerSharedInboxUrls ( actorIds : number [ ] , t ) { return ActorFollowModel . createListAcceptedFollowForApiQuery ( 's' , actorIds , t , undefined , undefined , 's' , true ) } static listAcceptedFollowingUrlsForApi ( actorIds : number [ ] , t , start ? , count ? ) { return ActorFollowModel . createListAcceptedFollowForApiQuery ( 's' , actorIds , t , start , count ) } static async getStats ( ) { const serverActor = await getServerActor ( ) const totalInstanceFollowing = await ActorFollowModel . count ( { where : { actorId : serverActor . id } } ) const totalInstanceFollowers = await ActorFollowModel . count ( { where : { targetActorId : serverActor . id } } ) return { totalInstanceFollowing , totalInstanceFollowers } } static updateScore ( inboxUrl , value , t ? ) { const query = `template` + 's' + 's' + 's' + `template` + 's' const options = { type : QueryTypes . BULKUPDATE , transaction : t } return ActorFollowModel . sequelize . query ( query , options ) } static async updateScoreByFollowingServers ( serverIds : number [ ] , value , t ? ) { if ( serverIds . length === 0 ) return const me = await getServerActor ( ) const serverIdsString = createSafeIn ( ActorFollowModel , serverIds ) const query = `template` + 's' + 's' + 's' + `template` + `template` + 's' const options = { type : QueryTypes . BULKUPDATE , transaction : t } return ActorFollowModel . sequelize . query ( query , options ) } private static async createListAcceptedFollowForApiQuery ( type : 's' | 's' , actorIds : number [ ] , t , start ? , count ? , columnUrl = 's' , distinct = false ) { let firstJoin let secondJoin if ( type === 's' ) { firstJoin = 's' secondJoin = 's' } else { firstJoin = 's' secondJoin = 's' } const selections : string [ ] = [ ] if ( distinct === true ) selections . push ( 's' + columnUrl + 's' ) else selections . push ( 's' + columnUrl + 's' ) selections . push ( 's' ) const tasks : Bluebird < any > [ ] = [ ] for ( let selection of selections ) { let query = 's' + selection + 's' + 's' + firstJoin + 's' + 's' + secondJoin + 's' + 's' if ( count !== undefined ) query += 's' + count if ( start !== undefined ) query += 's' + start const options = { bind : { actorIds } , type : QueryTypes . SELECT , transaction : t } tasks . push ( ActorFollowModel . sequelize . query ( query , options ) ) } const [ followers , [ dataTotal ] ] = await Promise . all ( tasks ) const urls : string [ ] = followers . map ( f => f . url ) return { data : urls , total : dataTotal ? parseInt ( dataTotal . total , 0 ) : 0 } } private static listBadActorFollows ( ) { const query = { where : { score : { [ Op . lte ] : 0 } } , logging : false } return ActorFollowModel . findAll ( query ) } toFormattedJSON ( this ) { const follower = this . ActorFollower . toFormattedJSON ( ) const following = this . ActorFollowing . toFormattedJSON ( ) return { id : this . id , follower , following , score : this . score , state : this . state , createdAt : this . createdAt , updatedAt : this . updatedAt } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollowModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollowModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $string$ O $string$ O O $Transaction$ O O O O O O $IncludeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O $number$ O O $number$ O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorFollow$ O $MActorFollowFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as validator from 's' import { CONSTRAINTS_FIELDS , MIMETYPES , VIDEO_IMPORT_STATES } from 's' import { exists , isFileValid } from 's' import * as express from 's' import { VideoImportModel } from 's' function isVideoImportTargetUrlValid ( url ) { const isURLOptions = { require_host : true , require_tld : true , require_protocol : true , require_valid_protocol : true , protocols : [ 's' , 's' ] } return exists ( url ) && validator . isURL ( 's' + url , isURLOptions ) && validator . isLength ( 's' + url , CONSTRAINTS_FIELDS . VIDEO_IMPORTS . URL ) } function isVideoImportStateValid ( value ) { return exists ( value ) && VIDEO_IMPORT_STATES [ value ] !== undefined } const videoTorrentImportTypes = Object . keys ( MIMETYPES . TORRENT . MIMETYPE_EXT ) . map ( m => `template` ) const videoTorrentImportRegex = videoTorrentImportTypes . join ( 's' ) function isVideoImportTorrentFile ( files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] ) { return isFileValid ( files , videoTorrentImportRegex , 's' , CONSTRAINTS_FIELDS . VIDEO_IMPORTS . TORRENT_FILE . FILE_SIZE . max , true ) } async function doesVideoImportExist ( id , res : express . Response ) { const videoImport = await VideoImportModel . loadAndPopulateVideo ( id ) if ( ! videoImport ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoImport = videoImport return true } export { isVideoImportStateValid , isVideoImportTargetUrlValid , doesVideoImportExist , isVideoImportTorrentFile }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AfterUpdate , AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , DefaultScope , ForeignKey , Is , Model , Table , UpdatedAt } from 's' import { CONSTRAINTS_FIELDS , VIDEO_IMPORT_STATES } from 's' import { getSort , throwIfNotValid } from 's' import { ScopeNames as VideoModelScopeNames , VideoModel } from 's' import { isVideoImportStateValid , isVideoImportTargetUrlValid } from 's' import { VideoImport , VideoImportState } from 's' import { isVideoMagnetUriValid } from 's' import { UserModel } from 's' import * as Bluebird from 's' import { MVideoImportDefault , MVideoImportFormattable } from 's' @ DefaultScope ( ( ) => ( { include : [ { model : UserModel . unscoped ( ) , required : true } , { model : VideoModel . scope ( [ VideoModelScopeNames . WITH_ACCOUNT_DETAILS , VideoModelScopeNames . WITH_TAGS , VideoModelScopeNames . WITH_THUMBNAILS ] ) , required : false } ] } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class VideoImportModel extends Model < VideoImportModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoImportTargetUrlValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_IMPORTS . URL . max ) ) targetUrl : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoMagnetUriValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_IMPORTS . URL . max ) ) magnetUri : string @ AllowNull ( true ) @ Default ( null ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_IMPORTS . TORRENT_NAME . max ) ) torrentName : string @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoImportStateValid , 's' ) ) @ Column state : VideoImportState @ AllowNull ( true ) @ Default ( null ) @ Column ( DataType . TEXT ) error : string @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) User : UserModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Video : VideoModel @ AfterUpdate static deleteVideoIfFailed ( instance , options ) { if ( instance . state === VideoImportState . FAILED ) { return instance . Video . destroy ( { transaction : options . transaction } ) } return undefined } static loadAndPopulateVideo ( id ) < MVideoImportDefault > { return VideoImportModel . findByPk ( id ) } static listUserVideoImportsForApi ( userId , start , count , sort ) { const query = { distinct : true , include : [ { model : UserModel . unscoped ( ) , required : true } ] , offset : start , limit : count , order : getSort ( sort ) , where : { userId } } return VideoImportModel . findAndCountAll < MVideoImportDefault > ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } getTargetIdentifier ( ) { return this . targetUrl || this . magnetUri || this . torrentName } toFormattedJSON ( this ) { const videoFormatOptions = { completeDescription : true , additionalAttributes : { state : true , waitTranscoding : true , scheduledUpdate : true } } const video = this . Video ? Object . assign ( this . Video . toFormattedJSON ( videoFormatOptions ) , { tags : this . Video . Tags . map ( t => t . name ) } ) : undefined return { id : this . id , targetUrl : this . targetUrl , magnetUri : this . magnetUri , torrentName : this . torrentName , state : { id : this . state , label : VideoImportModel . getStateLabel ( this . state ) } , error : this . error , updatedAt : this . updatedAt . toISOString ( ) , createdAt : this . createdAt . toISOString ( ) , video } } private static getStateLabel ( id ) { return VIDEO_IMPORT_STATES [ id ] || 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImport$ O $MVideoImportFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O
export enum PluginType { PLUGIN = 0 , THEME = 0 }	O O O O O O O O O O O O
import { exists , isArray , isSafePath } from 's' import * as validator from 's' import { PluginType } from 's' import { CONSTRAINTS_FIELDS } from 's' import { PluginPackageJson } from 's' import { isUrlValid } from 's' const PLUGINS_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . PLUGINS function isPluginTypeValid ( value ) { return exists ( value ) && validator . isInt ( 's' + value ) && PluginType [ value ] !== undefined } function isPluginNameValid ( value ) { return exists ( value ) && validator . isLength ( value , PLUGINS_CONSTRAINTS_FIELDS . NAME ) && validator . matches ( value , "s" ) } function isNpmPluginNameValid ( value ) { return exists ( value ) && validator . isLength ( value , PLUGINS_CONSTRAINTS_FIELDS . NAME ) && validator . matches ( value , "s" ) && ( value . startsWith ( 's' ) || value . startsWith ( 's' ) ) } function isPluginDescriptionValid ( value ) { return exists ( value ) && validator . isLength ( value , PLUGINS_CONSTRAINTS_FIELDS . DESCRIPTION ) } function isPluginVersionValid ( value ) { if ( ! exists ( value ) ) return false const parts = ( value + 's' ) . split ( 's' ) return parts . length === 0 && parts . every ( p => validator . isInt ( p ) ) } function isPluginEngineValid ( engine ) { return exists ( engine ) && exists ( engine . peertube ) } function isPluginHomepage ( value ) { return exists ( value ) && ( ! value || isUrlValid ( value ) ) } function isPluginBugs ( value ) { return exists ( value ) && ( ! value || isUrlValid ( value ) ) } function areStaticDirectoriesValid ( staticDirs ) { if ( ! exists ( staticDirs ) || typeof staticDirs !== 's' ) return false for ( const key of Object . keys ( staticDirs ) ) { if ( ! isSafePath ( staticDirs [ key ] ) ) return false } return true } function areClientScriptsValid ( clientScripts : any [ ] ) { return isArray ( clientScripts ) && clientScripts . every ( c => { return isSafePath ( c . script ) && isArray ( c . scopes ) } ) } function areTranslationPathsValid ( translations ) { if ( ! exists ( translations ) || typeof translations !== 's' ) return false for ( const key of Object . keys ( translations ) ) { if ( ! isSafePath ( translations [ key ] ) ) return false } return true } function areCSSPathsValid ( css : any [ ] ) { return isArray ( css ) && css . every ( c => isSafePath ( c ) ) } function isThemeNameValid ( name ) { return isPluginNameValid ( name ) } function isPackageJSONValid ( packageJSON , pluginType ) { let result = true const badFields : string [ ] = [ ] if ( ! isNpmPluginNameValid ( packageJSON . name ) ) { result = false badFields . push ( 's' ) } if ( ! isPluginDescriptionValid ( packageJSON . description ) ) { result = false badFields . push ( 's' ) } if ( ! isPluginEngineValid ( packageJSON . engine ) ) { result = false badFields . push ( 's' ) } if ( ! isPluginHomepage ( packageJSON . homepage ) ) { result = false badFields . push ( 's' ) } if ( ! exists ( packageJSON . author ) ) { result = false badFields . push ( 's' ) } if ( ! isPluginBugs ( packageJSON . bugs ) ) { result = false badFields . push ( 's' ) } if ( pluginType === PluginType . PLUGIN && ! isSafePath ( packageJSON . library ) ) { result = false badFields . push ( 's' ) } if ( ! areStaticDirectoriesValid ( packageJSON . staticDirs ) ) { result = false badFields . push ( 's' ) } if ( ! areCSSPathsValid ( packageJSON . css ) ) { result = false badFields . push ( 's' ) } if ( ! areClientScriptsValid ( packageJSON . clientScripts ) ) { result = false badFields . push ( 's' ) } if ( ! areTranslationPathsValid ( packageJSON . translations ) ) { result = false badFields . push ( 's' ) } return { result , badFields } } function isLibraryCodeValid ( library ) { return typeof library . register === 's' && typeof library . unregister === 's' } export { isPluginTypeValid , isPackageJSONValid , isThemeNameValid , isPluginHomepage , isPluginVersionValid , isPluginNameValid , isPluginDescriptionValid , isLibraryCodeValid , isNpmPluginNameValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $PluginPackageJson$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PluginType } from 's' export interface PeerTubePlugin { name : string type : PluginType latestVersion : string version : string enabled : boolean uninstalled : boolean peertubeEngine : string description : string homepage : string settings : { [ name ] : string } createdAt : Date updatedAt : Date }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O
export interface RegisterServerSettingOptions { name : string label : string type : 's' private : boolean default ? : string } export interface RegisteredServerSettings { registeredSettings : RegisterServerSettingOptions [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , Column , CreatedAt , DataType , DefaultScope , Is , Model , Table , UpdatedAt } from 's' import { getSort , throwIfNotValid } from 's' import { isPluginDescriptionValid , isPluginHomepage , isPluginNameValid , isPluginTypeValid , isPluginVersionValid } from 's' import { PluginType } from 's' import { PeerTubePlugin } from 's' import { FindAndCountOptions , json } from 's' import { RegisterServerSettingOptions } from 's' import * as Bluebird from 's' import { MPlugin , MPluginFormattable } from 's' @ DefaultScope ( ( ) => ( { attributes : { exclude : [ 's' ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' , 's' ] , unique : true } ] } ) export class PluginModel extends Model < PluginModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginNameValid , 's' ) ) @ Column name : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginTypeValid , 's' ) ) @ Column type : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginVersionValid , 's' ) ) @ Column version : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginVersionValid , 's' ) ) @ Column latestVersion : string @ AllowNull ( false ) @ Column enabled : boolean @ AllowNull ( false ) @ Column uninstalled : boolean @ AllowNull ( false ) @ Column peertubeEngine : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginDescriptionValid , 's' ) ) @ Column description : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isPluginHomepage , 's' ) ) @ Column homepage : string @ AllowNull ( true ) @ Column ( DataType . JSONB ) settings : any @ AllowNull ( true ) @ Column ( DataType . JSONB ) storage : any @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date static listEnabledPluginsAndThemes ( ) < MPlugin [ ] > { const query = { where : { enabled : true , uninstalled : false } } return PluginModel . findAll ( query ) } static loadByNpmName ( npmName ) < MPlugin > { const name = this . normalizePluginName ( npmName ) const type = this . getTypeFromNpmName ( npmName ) const query = { where : { name , type } } return PluginModel . findOne ( query ) } static getSetting ( pluginName , pluginType , settingName ) { const query = { attributes : [ 's' ] , where : { name : pluginName , type : pluginType } } return PluginModel . findOne ( query ) . then ( p => { if ( ! p || ! p . settings ) return undefined return p . settings [ settingName ] } ) } static setSetting ( pluginName , pluginType , settingName , settingValue ) { const query = { where : { name : pluginName , type : pluginType } } const toSave = { [ `template` ] : settingValue } return PluginModel . update ( toSave , query ) . then ( ( ) => undefined ) } static getData ( pluginName , pluginType , key ) { const query = { raw : true , attributes : [ [ json ( 's' + key ) , 's' ] as any ] , where : { name : pluginName , type : pluginType } } return PluginModel . findOne ( query ) . then ( ( c ) => { if ( ! c ) return undefined const value = c . value if ( typeof value === 's' && value . startsWith ( 's' ) ) { try { return JSON . parse ( value ) } catch { return value } } return c . value } ) } static storeData ( pluginName , pluginType , key , data ) { const query = { where : { name : pluginName , type : pluginType } } const toSave = { [ `template` ] : data } return PluginModel . update ( toSave , query ) . then ( ( ) => undefined ) } static listForApi ( options : { pluginType ? : PluginType , uninstalled ? : boolean , start : number , count : number , sort : string } ) { const { uninstalled = false } = options const query = { offset : options . start , limit : options . count , order : getSort ( options . sort ) , where : { uninstalled } } if ( options . pluginType ) query . where [ 's' ] = options . pluginType return PluginModel . findAndCountAll < MPlugin > ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static listInstalled ( ) < MPlugin [ ] > { const query = { where : { uninstalled : false } } return PluginModel . findAll ( query ) } static normalizePluginName ( npmName ) { return npmName . replace ( "s" , 's' ) } static getTypeFromNpmName ( npmName ) { return npmName . startsWith ( 's' ) ? PluginType . PLUGIN : PluginType . THEME } static buildNpmName ( name , type ) { if ( type === PluginType . THEME ) return 's' + name return 's' + name } getPublicSettings ( registeredSettings : RegisterServerSettingOptions [ ] ) { const result : { [ name ] : string } = { } const settings = this . settings || { } for ( const r of registeredSettings ) { if ( r . private !== false ) continue result [ r . name ] = settings [ r . name ] || r . default || null } return result } toFormattedJSON ( this ) { return { name : this . name , type : this . type , version : this . version , latestVersion : this . latestVersion , enabled : this . enabled , uninstalled : this . uninstalled , peertubeEngine : this . peertubeEngine , description : this . description , homepage : this . homepage , settings : this . settings , createdAt : this . createdAt , updatedAt : this . updatedAt } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindAndCountOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O $MPluginFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { execShell } from 's' import { logger } from 's' import { isNpmPluginNameValid , isPluginVersionValid } from 's' import { CONFIG } from 's' import { outputJSON , pathExists } from 's' import { join } from 's' async function installNpmPlugin ( npmName , version ? ) { checkNpmPluginNameOrThrow ( npmName ) if ( version ) checkPluginVersionOrThrow ( version ) let toInstall = npmName if ( version ) toInstall += `template` const { stdout } = await execYarn ( 's' + toInstall ) logger . debug ( 's' , { yarnStdout : stdout } ) } async function installNpmPluginFromDisk ( path ) { await execYarn ( 's' + path ) } async function removeNpmPlugin ( name ) { checkNpmPluginNameOrThrow ( name ) await execYarn ( 's' + name ) } export { installNpmPlugin , installNpmPluginFromDisk , removeNpmPlugin } async function execYarn ( command ) { try { const pluginDirectory = CONFIG . STORAGE . PLUGINS_DIR const pluginPackageJSON = join ( pluginDirectory , 's' ) if ( ! await pathExists ( pluginPackageJSON ) ) { await outputJSON ( pluginPackageJSON , { } ) } return execShell ( `template` , { cwd : pluginDirectory } ) } catch ( result ) { logger . error ( 's' , { command , err : result . err , stderr : result . stderr } ) throw result . err } } function checkNpmPluginNameOrThrow ( name ) { if ( ! isNpmPluginNameValid ( name ) ) throw new Error ( 's' ) } function checkPluginVersionOrThrow ( name ) { if ( ! isPluginVersionValid ( name ) ) throw new Error ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' export interface PluginSettingsManager { getSetting : ( name ) => Bluebird < string > setSetting : ( name , value ) => Bluebird < any > }	O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O $string$ O O O O O O O
import * as Bluebird from 's' export interface PluginStorageManager { getData : ( key ) => Bluebird < string > storeData : ( key , data ) => Bluebird < any > }	O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O $any$ O O O O O O O
export const serverFilterHookObject = { 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true } export type ServerFilterHookName = keyof typeof serverFilterHookObject export const serverActionHookObject = { 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true } export type ServerActionHookName = keyof typeof serverActionHookObject export const serverHookObject = Object . assign ( { } , serverFilterHookObject , serverActionHookObject ) export type ServerHookName = keyof typeof serverHookObject export interface ServerHook { runHook < T > ( hookName , result ? : T , params ? ) : Promise < T > }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerHookName$ O O O O O O O $any$ O O O O O O O
export enum HookType { STATIC = 0 , ACTION = 0 , FILTER = 0 }	O O O O O O O O O O O O O O O O
function randomInt ( low , high ) { return Math . floor ( Math . random ( ) * ( high - low ) + low ) } function compareSemVer ( a , b ) { const 0 = "s" const segmentsA = a . replace ( 0 , 's' ) . split ( 's' ) const segmentsB = b . replace ( 0 , 's' ) . split ( 's' ) const l = Math . min ( segmentsA . length , segmentsB . length ) for ( let i = 0 ; i < l ; i ++ ) { const diff = parseInt ( segmentsA [ i ] , 0 ) - parseInt ( segmentsB [ i ] , 0 ) if ( diff ) return diff } return segmentsA . length - segmentsB . length } function isPromise ( value ) { return value && typeof value . then === 's' } function isCatchable ( value ) { return value && typeof value . catch === 's' } export { randomInt , compareSemVer , isPromise , isCatchable }	O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O
import { HookType } from 's' import { isCatchable , isPromise } from 's' function getHookType ( hookName ) { if ( hookName . startsWith ( 's' ) ) return HookType . FILTER if ( hookName . startsWith ( 's' ) ) return HookType . ACTION return HookType . STATIC } async function internalRunHook < T > ( handler , hookType , result : T , params , onError : ( err ) => void ) { try { if ( hookType === HookType . FILTER ) { const p = handler ( result , params ) if ( isPromise ( p ) ) result = await p else result = p return result } const p = handler ( params ) if ( hookType === HookType . STATIC ) { if ( isPromise ( p ) ) await p return undefined } if ( hookType === HookType . ACTION ) { if ( isCatchable ( p ) ) p . catch ( ( err ) => onError ( err ) ) return undefined } } catch ( err ) { onError ( err ) } return result } export { getHookType , internalRunHook }	O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O $HookType$ O O O O O $any$ O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ServerHookName } from 's' export interface RegisterServerHookOptions { target : ServerHookName handler : Function priority ? : number }	O O O O O O O O O O O O O O O O O O O O O
export interface PluginVideoCategoryManager { addCategory : ( categoryKey , categoryLabel ) => boolean deleteCategory : ( categoryKey ) => boolean }	O O O O O O O $number$ O $string$ O O O O O O $number$ O O O O
export interface PluginVideoLanguageManager { addLanguage : ( languageKey , languageLabel ) => boolean deleteLanguage : ( languageKey ) => boolean }	O O O O O O O $string$ O $string$ O O O O O O $string$ O O O O
export interface PluginVideoLicenceManager { addLicence : ( licenceKey , licenceLabel ) => boolean deleteLicence : ( licenceKey ) => boolean }	O O O O O O O $number$ O $string$ O O O O O O $number$ O O O O
import { logger } from 's' import { PluginSettingsManager } from 's' import { PluginStorageManager } from 's' import { RegisterServerHookOptions } from 's' import { RegisterServerSettingOptions } from 's' import { PluginVideoCategoryManager } from 's' import { PluginVideoLanguageManager } from 's' import { PluginVideoLicenceManager } from 's' export type RegisterServerOptions = { registerHook : ( options ) => void registerSetting : ( options ) => void settingsManager : PluginSettingsManager storageManager : PluginStorageManager videoCategoryManager : PluginVideoCategoryManager videoLanguageManager : PluginVideoLanguageManager videoLicenceManager : PluginVideoLicenceManager peertubeHelpers : { logger : typeof logger } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisterServerHookOptions$ O O O O O O $RegisterServerSettingOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisterServerOptions } from 's' export interface PluginLibrary { register : ( options ) => Promise < any > unregister : ( ) => Promise < any > }	O O O O O O O O O O O O O $RegisterServerOptions$ O O O O O O O O O O O O O O O O
import * as retry from 's' import * as Bluebird from 's' import { Model } from 's' import { logger } from 's' import { Transaction } from 's' function retryTransactionWrapper < T , A , B , C > ( functionToRetry : ( 0 : A , 0 : B , 0 : C ) => Promise < T > | Bluebird < T > , 0 : A , 0 : B , 0 : C ) < T > function retryTransactionWrapper < T , A , B > ( functionToRetry : ( 0 : A , 0 : B ) => Promise < T > | Bluebird < T > , 0 : A , 0 : B ) < T > function retryTransactionWrapper < T , A > ( functionToRetry : ( 0 : A ) => Promise < T > | Bluebird < T > , 0 : A ) < T > function retryTransactionWrapper < T > ( functionToRetry : ( ) => Promise < T > | Bluebird < T > ) < T > function retryTransactionWrapper < T > ( functionToRetry : ( ... args : any [ ] ) => Promise < T > | Bluebird < T > , ... args : any [ ] ) < T > { return transactionRetryer < T > ( callback => { functionToRetry . apply ( null , args ) . then ( ( result : T ) => callback ( null , result ) ) . catch ( err => callback ( err ) ) } ) . catch ( err => { logger . error ( `template` , { err } ) throw err } ) } function transactionRetryer < T > ( func : ( err , data : T ) => any ) { return new Promise < T > ( ( res , rej ) => { retry ( { times : 0 , errorFilter => { const willRetry = ( err . name === 's' ) logger . debug ( 's' , { willRetry , err } ) return willRetry } } , func , ( err , data ) => err ? rej ( err ) : res ( data ) ) } ) } function updateInstanceWithAnother < T extends Model < T > > ( instanceToUpdate < T > , baseInstance < T > ) { const obj = baseInstance . toJSON ( ) for ( const key of Object . keys ( obj ) ) { instanceToUpdate [ key ] = obj [ key ] } } function resetSequelizeInstance ( instance < any > , savedFields ) { Object . keys ( savedFields ) . forEach ( key => { instance [ key ] = savedFields [ key ] } ) } function afterCommitIfTransaction ( t , fn ) { if ( t ) return t . afterCommit ( ( ) => fn ( ) ) return fn ( ) } export { resetSequelizeInstance , retryTransactionWrapper , transactionRetryer , updateInstanceWithAnother , afterCommitIfTransaction }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $err$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Model$ O O O O $Model$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Model$ O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { createWriteStream , remove } from 's' import * as request from 's' import { ACTIVITY_PUB , PEERTUBE_VERSION , WEBSERVER } from 's' import { processImage } from 's' import { join } from 's' import { logger } from 's' import { CONFIG } from 's' function doRequest < T > ( requestOptions : request . CoreOptions & request . UriOptions & { activityPub ? : boolean } , bodyKBLimit = 0 ) < { response : request . RequestResponse , body : T } > { if ( ! ( requestOptions . headers ) ) requestOptions . headers = { } requestOptions . headers [ 's' ] = getUserAgent ( ) if ( requestOptions . activityPub === true ) { requestOptions . headers [ 's' ] = ACTIVITY_PUB . ACCEPT_HEADER } return new Bluebird < { response : request . RequestResponse , body : T } > ( ( res , rej ) => { request ( requestOptions , ( err , response , body ) => err ? rej ( err ) : res ( { response , body } ) ) . on ( 's' , onRequestDataLengthCheck ( bodyKBLimit ) ) } ) } function doRequestAndSaveToFile ( requestOptions : request . CoreOptions & request . UriOptions , destPath , bodyKBLimit = 0 ) { if ( ! requestOptions . headers ) requestOptions . headers = { } requestOptions . headers [ 's' ] = getUserAgent ( ) return new Bluebird < void > ( ( res , rej ) => { const file = createWriteStream ( destPath ) file . on ( 's' , ( ) => res ( ) ) request ( requestOptions ) . on ( 's' , onRequestDataLengthCheck ( bodyKBLimit ) ) . on ( 's' , err => { file . close ( ) remove ( destPath ) . catch ( err => logger . error ( 's' , destPath , { err } ) ) return rej ( err ) } ) . pipe ( file ) } ) } async function downloadImage ( url , destDir , destName , size : { width : number , height : number } ) { const tmpPath = join ( CONFIG . STORAGE . TMP_DIR , 's' + destName ) await doRequestAndSaveToFile ( { method : 's' , uri : url } , tmpPath ) const destPath = join ( destDir , destName ) try { await processImage ( tmpPath , destPath , size ) } catch ( err ) { await remove ( tmpPath ) throw err } } function getUserAgent ( ) { return `template` } export { doRequest , doRequestAndSaveToFile , downloadImage } function onRequestDataLengthCheck ( bodyKBLimit ) { let bufferLength = 0 const bytesLimit = bodyKBLimit * 0 return function ( chunk ) { bufferLength += chunk . length if ( bufferLength > bytesLimit ) { this . abort ( ) const error = new Error ( `template` ) this . emit ( 's' , error ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as WebFinger from 's' import { WebFingerData } from 's' import { ActorModel } from 's' import { isTestInstance } from 's' import { isActivityPubUrlValid } from 's' import { WEBSERVER } from 's' import { MActorFull } from 's' const webfinger = new WebFinger ( { webfist_fallback : false , tls_only : isTestInstance ( ) , uri_fallback : false , request_timeout : 0 } ) async function loadActorUrlOrGetFromWebfinger ( uriArg ) { const uri = uriArg . startsWith ( 's' ) ? uriArg . slice ( 0 ) : uriArg const [ name , host ] = uri . split ( 's' ) let actor if ( ! host || host === WEBSERVER . HOST ) { actor = await ActorModel . loadLocalByName ( name ) } else { actor = await ActorModel . loadByNameAndHost ( name , host ) } if ( actor ) return actor . url return getUrlFromWebfinger ( uri ) } async function getUrlFromWebfinger ( uri ) { const webfingerData = await webfingerLookup ( uri ) return getLinkOrThrow ( webfingerData ) } export { getUrlFromWebfinger , loadActorUrlOrGetFromWebfinger } function getLinkOrThrow ( webfingerData ) { if ( Array . isArray ( webfingerData . links ) === false ) throw new Error ( 's' ) const selfLink = webfingerData . links . find ( l => l . rel === 's' ) if ( selfLink === undefined || isActivityPubUrlValid ( selfLink . href ) === false ) { throw new Error ( 's' ) } return selfLink . href } function webfingerLookup ( nameWithHost ) { return new Promise < WebFingerData > ( ( res , rej ) => { webfinger . lookup ( nameWithHost , ( err , p ) => { if ( err ) return rej ( err ) return res ( p . object ) } ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $WebFingerData$ O O O O O O O O O O O O O O O O O O O O O $WebFingerData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { createClient , RedisClient } from 's' import { logger } from 's' import { generateRandomString } from 's' import { CONTACT_FORM_LIFETIME , USER_EMAIL_VERIFY_LIFETIME , USER_PASSWORD_RESET_LIFETIME , VIDEO_VIEW_LIFETIME , WEBSERVER } from 's' import { CONFIG } from 's' type CachedRoute = { body : string , contentType ? : string statusCode ? : string } class Redis { private static instance : Redis private initialized = false private client : RedisClient private prefix : string private constructor ( ) { } init ( ) { if ( this . initialized === true ) return this . initialized = true this . client = createClient ( Redis . getRedisClientOptions ( ) ) this . client . on ( 's' , err => { logger . error ( 's' , { err } ) process . exit ( - 0 ) } ) if ( CONFIG . REDIS . AUTH ) { this . client . auth ( CONFIG . REDIS . AUTH ) } this . prefix = 's' + WEBSERVER . HOST + 's' } static getRedisClientOptions ( ) { return Object . assign ( { } , ( CONFIG . REDIS . AUTH && CONFIG . REDIS . AUTH != null ) ? { password : CONFIG . REDIS . AUTH } : { } , ( CONFIG . REDIS . DB ) ? { db : CONFIG . REDIS . DB } : { } , ( CONFIG . REDIS . HOSTNAME && CONFIG . REDIS . PORT ) ? { host : CONFIG . REDIS . HOSTNAME , port : CONFIG . REDIS . PORT } : { path : CONFIG . REDIS . SOCKET } ) } getClient ( ) { return this . client } getPrefix ( ) { return this . prefix } async setResetPasswordVerificationString ( userId ) { const generatedString = await generateRandomString ( 0 ) await this . setValue ( this . generateResetPasswordKey ( userId ) , generatedString , USER_PASSWORD_RESET_LIFETIME ) return generatedString } async getResetPasswordLink ( userId ) { return this . getValue ( this . generateResetPasswordKey ( userId ) ) } async setVerifyEmailVerificationString ( userId ) { const generatedString = await generateRandomString ( 0 ) await this . setValue ( this . generateVerifyEmailKey ( userId ) , generatedString , USER_EMAIL_VERIFY_LIFETIME ) return generatedString } async getVerifyEmailLink ( userId ) { return this . getValue ( this . generateVerifyEmailKey ( userId ) ) } async setContactFormIp ( ip ) { return this . setValue ( this . generateContactFormKey ( ip ) , 's' , CONTACT_FORM_LIFETIME ) } async doesContactFormIpExist ( ip ) { return this . exists ( this . generateContactFormKey ( ip ) ) } setIPVideoView ( ip , videoUUID ) { return this . setValue ( this . generateViewKey ( ip , videoUUID ) , 's' , VIDEO_VIEW_LIFETIME ) } async doesVideoIPViewExist ( ip , videoUUID ) { return this . exists ( this . generateViewKey ( ip , videoUUID ) ) } async getCachedRoute ( req : express . Request ) { const cached = await this . getObject ( this . generateCachedRouteKey ( req ) ) return cached as CachedRoute } setCachedRoute ( req : express . Request , body , lifetime , contentType ? , statusCode ? ) { const cached = Object . assign ( { } , { body : body . toString ( ) } , ( contentType ) ? { contentType } : null , ( statusCode ) ? { statusCode : statusCode . toString ( ) } : null ) return this . setObject ( this . generateCachedRouteKey ( req ) , cached , lifetime ) } addVideoView ( videoId ) { const keyIncr = this . generateVideoViewKey ( videoId ) const keySet = this . generateVideosViewKey ( ) return Promise . all ( [ this . addToSet ( keySet , videoId . toString ( ) ) , this . increment ( keyIncr ) ] ) } async getVideoViews ( videoId , hour ) { const key = this . generateVideoViewKey ( videoId , hour ) const valueString = await this . getValue ( key ) const valueInt = parseInt ( valueString , 0 ) if ( isNaN ( valueInt ) ) { logger . error ( 's' , videoId , hour , valueString ) return undefined } return valueInt } async getVideosIdViewed ( hour ) { const key = this . generateVideosViewKey ( hour ) const stringIds = await this . getSet ( key ) return stringIds . map ( s => parseInt ( s , 0 ) ) } deleteVideoViews ( videoId , hour ) { const keySet = this . generateVideosViewKey ( hour ) const keyIncr = this . generateVideoViewKey ( videoId , hour ) return Promise . all ( [ this . deleteFromSet ( keySet , videoId . toString ( ) ) , this . deleteKey ( keyIncr ) ] ) } generateCachedRouteKey ( req : express . Request ) { return req . method + 's' + req . originalUrl } private generateVideosViewKey ( hour ? ) { if ( ! hour ) hour = new Date ( ) . getHours ( ) return `template` } private generateVideoViewKey ( videoId , hour ? ) { if ( ! hour ) hour = new Date ( ) . getHours ( ) return `template` } private generateResetPasswordKey ( userId ) { return 's' + userId } private generateVerifyEmailKey ( userId ) { return 's' + userId } private generateViewKey ( ip , videoUUID ) { return `template` } private generateContactFormKey ( ip ) { return 's' + ip } private getValue ( key ) { return new Promise < string > ( ( res , rej ) => { this . client . get ( this . prefix + key , ( err , value ) => { if ( err ) return rej ( err ) return res ( value ) } ) } ) } private getSet ( key ) { return new Promise < string [ ] > ( ( res , rej ) => { this . client . smembers ( this . prefix + key , ( err , value ) => { if ( err ) return rej ( err ) return res ( value ) } ) } ) } private addToSet ( key , value ) { return new Promise < string [ ] > ( ( res , rej ) => { this . client . sadd ( this . prefix + key , value , err => err ? rej ( err ) : res ( ) ) } ) } private deleteFromSet ( key , value ) { return new Promise < void > ( ( res , rej ) => { this . client . srem ( this . prefix + key , value , err => err ? rej ( err ) : res ( ) ) } ) } private deleteKey ( key ) { return new Promise < void > ( ( res , rej ) => { this . client . del ( this . prefix + key , err => err ? rej ( err ) : res ( ) ) } ) } private deleteFieldInHash ( key , field ) { return new Promise < void > ( ( res , rej ) => { this . client . hdel ( this . prefix + key , field , err => err ? rej ( err ) : res ( ) ) } ) } private setValue ( key , value , expirationMilliseconds ) { return new Promise < void > ( ( res , rej ) => { this . client . set ( this . prefix + key , value , 's' , expirationMilliseconds , ( err , ok ) => { if ( err ) return rej ( err ) if ( ok !== 's' ) return rej ( new Error ( 's' ) ) return res ( ) } ) } ) } private setObject ( key , obj : { [ id ] : string } , expirationMilliseconds ) { return new Promise < void > ( ( res , rej ) => { this . client . hmset ( this . prefix + key , obj , ( err , ok ) => { if ( err ) return rej ( err ) if ( ! ok ) return rej ( new Error ( 's' ) ) this . client . pexpire ( this . prefix + key , expirationMilliseconds , ( err , ok ) => { if ( err ) return rej ( err ) if ( ! ok ) return rej ( new Error ( 's' ) ) return res ( ) } ) } ) } ) } private getObject ( key ) { return new Promise < { [ id ] : string } > ( ( res , rej ) => { this . client . hgetall ( this . prefix + key , ( err , value ) => { if ( err ) return rej ( err ) return res ( value ) } ) } ) } private setValueInHash ( key , field , value ) { return new Promise < void > ( ( res , rej ) => { this . client . hset ( this . prefix + key , field , value , ( err ) => { if ( err ) return rej ( err ) return res ( ) } ) } ) } private increment ( key ) { return new Promise < number > ( ( res , rej ) => { this . client . incr ( this . prefix + key , ( err , value ) => { if ( err ) return rej ( err ) return res ( value ) } ) } ) } private exists ( key ) { return new Promise < boolean > ( ( res , rej ) => { this . client . exists ( this . prefix + key , ( err , existsNumber ) => { if ( err ) return rej ( err ) return res ( existsNumber === 0 ) } ) } ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { Redis }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $number$ O O $string$ O O $number$ O O O $CachedRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $number$ O O O O O O O O O O $string$ O $string$ O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $string$ O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ACTOR_FOLLOW_SCORE } from 's' import { logger } from 's' class ActorFollowScoreCache { private static instance : ActorFollowScoreCache private pendingFollowsScore : { [ url ] : number } = { } private pendingBadServer = new Set < number > ( ) private pendingGoodServer = new Set < number > ( ) private constructor ( ) { } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } updateActorFollowsScore ( goodInboxes : string [ ] , badInboxes : string [ ] ) { if ( goodInboxes . length === 0 && badInboxes . length === 0 ) return logger . info ( 's' , goodInboxes . length , badInboxes . length ) for ( const goodInbox of goodInboxes ) { if ( this . pendingFollowsScore [ goodInbox ] === undefined ) this . pendingFollowsScore [ goodInbox ] = 0 this . pendingFollowsScore [ goodInbox ] += ACTOR_FOLLOW_SCORE . BONUS } for ( const badInbox of badInboxes ) { if ( this . pendingFollowsScore [ badInbox ] === undefined ) this . pendingFollowsScore [ badInbox ] = 0 this . pendingFollowsScore [ badInbox ] += ACTOR_FOLLOW_SCORE . PENALTY } } addBadServerId ( serverId ) { this . pendingBadServer . add ( serverId ) } getBadFollowingServerIds ( ) { return Array . from ( this . pendingBadServer ) } clearBadFollowingServerIds ( ) { this . pendingBadServer = new Set < number > ( ) } addGoodServerId ( serverId ) { this . pendingGoodServer . add ( serverId ) } getGoodFollowingServerIds ( ) { return Array . from ( this . pendingGoodServer ) } clearGoodFollowingServerIds ( ) { this . pendingGoodServer = new Set < number > ( ) } getPendingFollowsScore ( ) { return this . pendingFollowsScore } clearPendingFollowsScore ( ) { this . pendingFollowsScore = { } } } export { ActorFollowScoreCache }	O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { remove } from 's' import { logger } from 's' import * as memoizee from 's' type GetFilePathResult = { isOwned : boolean , path : string } | undefined export abstract class AbstractVideoStaticFileCache < T > { getFilePath : ( params : T ) => Promise < GetFilePathResult > abstract getFilePathImpl ( params : T ) < GetFilePathResult > protected abstract loadRemoteFile ( key ) < GetFilePathResult > init ( max , maxAge ) { this . getFilePath = memoizee ( this . getFilePathImpl , { maxAge , max , promise : true , dispose : ( result ? ) => { if ( result && result . isOwned !== true ) { remove ( result . path ) . then ( ( ) => logger . debug ( 's' , result . path , this . constructor . name ) ) . catch ( err => logger . error ( 's' , result . path , this . constructor . name , { err } ) ) } } } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O $Promise$ O $string$ O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $GetFilePathResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { join } from 's' import { FILES_CACHE , STATIC_PATHS } from 's' import { VideoModel } from 's' import { AbstractVideoStaticFileCache } from 's' import { CONFIG } from 's' import { fetchRemoteVideoStaticFile } from 's' class VideosPreviewCache extends AbstractVideoStaticFileCache < string > { private static instance : VideosPreviewCache private constructor ( ) { super ( ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } async getFilePathImpl ( videoUUID ) { const video = await VideoModel . loadByUUID ( videoUUID ) if ( ! video ) return undefined if ( video . isOwned ( ) ) return { isOwned : true , path : video . getPreview ( ) . getPath ( ) } return this . loadRemoteFile ( videoUUID ) } protected async loadRemoteFile ( key ) { const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( key ) if ( ! video ) return undefined if ( video . isOwned ( ) ) throw new Error ( 's' ) const remoteStaticPath = join ( STATIC_PATHS . PREVIEWS , video . getPreview ( ) . filename ) const destPath = join ( FILES_CACHE . PREVIEWS . DIRECTORY , video . getPreview ( ) . filename ) await fetchRemoteVideoStaticFile ( video , remoteStaticPath , destPath ) return { isOwned : false , path : destPath } } } export { VideosPreviewCache }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { join } from 's' import { FILES_CACHE } from 's' import { VideoModel } from 's' import { VideoCaptionModel } from 's' import { AbstractVideoStaticFileCache } from 's' import { CONFIG } from 's' import { logger } from 's' import { fetchRemoteVideoStaticFile } from 's' type GetPathParam = { videoId : string , language : string } class VideosCaptionCache extends AbstractVideoStaticFileCache < GetPathParam > { private static readonly KEY_DELIMITER = 's' private static instance : VideosCaptionCache private constructor ( ) { super ( ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } async getFilePathImpl ( params ) { const videoCaption = await VideoCaptionModel . loadByVideoIdAndLanguage ( params . videoId , params . language ) if ( ! videoCaption ) return undefined if ( videoCaption . isOwned ( ) ) return { isOwned : true , path : join ( CONFIG . STORAGE . CAPTIONS_DIR , videoCaption . getCaptionName ( ) ) } const key = params . videoId + VideosCaptionCache . KEY_DELIMITER + params . language return this . loadRemoteFile ( key ) } protected async loadRemoteFile ( key ) { logger . debug ( 's' , key ) const [ videoId , language ] = key . split ( VideosCaptionCache . KEY_DELIMITER ) const videoCaption = await VideoCaptionModel . loadByVideoIdAndLanguage ( videoId , language ) if ( ! videoCaption ) return undefined if ( videoCaption . isOwned ( ) ) throw new Error ( 's' ) const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoId ) if ( ! video ) return undefined const remoteStaticPath = videoCaption . getCaptionStaticPath ( ) const destPath = join ( FILES_CACHE . VIDEO_CAPTIONS . DIRECTORY , videoCaption . getCaptionName ( ) ) await fetchRemoteVideoStaticFile ( video , remoteStaticPath , destPath ) return { isOwned : false , path : destPath } } } export { VideosCaptionCache }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GetPathParam$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import * as Bull from 's' import * as Bluebird from 's' import { logger } from 's' import { doRequest } from 's' import { buildGlobalHeaders , buildSignedRequestOptions , computeBody } from 's' import { BROADCAST_CONCURRENCY , JOB_REQUEST_TIMEOUT } from 's' import { ActorFollowScoreCache } from 's' export type ActivitypubHttpBroadcastPayload = { uris : string [ ] signatureActorId ? : number body : any } async function processActivityPubHttpBroadcast ( job : Bull . Job ) { logger . info ( 's' , job . id ) const payload = job . data as ActivitypubHttpBroadcastPayload const body = await computeBody ( payload ) const httpSignatureOptions = await buildSignedRequestOptions ( payload ) const options = { method : 's' , uri : 's' , json : body , httpSignature : httpSignatureOptions , timeout : JOB_REQUEST_TIMEOUT , headers : buildGlobalHeaders ( body ) } const badUrls : string [ ] = [ ] const goodUrls : string [ ] = [ ] await Bluebird . map ( payload . uris , uri => { return doRequest ( Object . assign ( { } , options , { uri } ) ) . then ( ( ) => goodUrls . push ( uri ) ) . catch ( ( ) => badUrls . push ( uri ) ) } , { concurrency : BROADCAST_CONCURRENCY } ) return ActorFollowScoreCache . Instance . updateActorFollowsScore ( goodUrls , badUrls ) } export { processActivityPubHttpBroadcast }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { ACTIVITY_PUB } from 's' import { exists , isArray , isDateValid } from 's' import { isActivityPubUrlValid } from 's' function sanitizeAndCheckVideoCommentObject ( comment ) { if ( ! comment || comment . type !== 's' ) return false normalizeComment ( comment ) return isActivityPubUrlValid ( comment . id ) && isCommentContentValid ( comment . content ) && isActivityPubUrlValid ( comment . inReplyTo ) && isDateValid ( comment . published ) && isActivityPubUrlValid ( comment . url ) && isArray ( comment . to ) && ( comment . to . indexOf ( ACTIVITY_PUB . PUBLIC ) !== - 0 || comment . cc . indexOf ( ACTIVITY_PUB . PUBLIC ) !== - 0 ) } export { sanitizeAndCheckVideoCommentObject } function isCommentContentValid ( content ) { return exists ( content ) && validator . isLength ( 's' + content , { min : 0 } ) } function normalizeComment ( comment ) { if ( ! comment ) return if ( typeof comment . url !== 's' ) { if ( typeof comment . url === 's' ) comment . url = comment . url . href || comment . url . url else comment . url = comment . id } return }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
function regexpCapture ( str , regex , maxIterations = 0 ) { let m let i = 0 let result : RegExpExecArray [ ] = [ ] while ( ( m = regex . exec ( str ) ) !== null && i < maxIterations ) { if ( m . index === regex . lastIndex ) { regex . lastIndex ++ } result . push ( m ) i ++ } return result } export { regexpCapture }	O O O $string$ O $RegExp$ O O O O O O O $RegExpExecArray$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import * as validator from 's' import { CONSTRAINTS_FIELDS , VIDEO_ABUSE_STATES } from 's' import { exists } from 's' import { VideoAbuseModel } from 's' const VIDEO_ABUSES_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . VIDEO_ABUSES function isVideoAbuseReasonValid ( value ) { return exists ( value ) && validator . isLength ( value , VIDEO_ABUSES_CONSTRAINTS_FIELDS . REASON ) } function isVideoAbuseModerationCommentValid ( value ) { return exists ( value ) && validator . isLength ( value , VIDEO_ABUSES_CONSTRAINTS_FIELDS . MODERATION_COMMENT ) } function isVideoAbuseStateValid ( value ) { return exists ( value ) && VIDEO_ABUSE_STATES [ value ] !== undefined } export { isVideoAbuseStateValid , isVideoAbuseReasonValid , isVideoAbuseModerationCommentValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , Is , Model , Table , UpdatedAt } from 's' import { VideoAbuseObject } from 's' import { VideoAbuse } from 's' import { isVideoAbuseModerationCommentValid , isVideoAbuseReasonValid , isVideoAbuseStateValid } from 's' import { AccountModel } from 's' import { buildBlockedAccountSQL , getSort , throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoAbuseState } from 's' import { CONSTRAINTS_FIELDS , VIDEO_ABUSE_STATES } from 's' import { MUserAccountId , MVideoAbuse , MVideoAbuseFormattable , MVideoAbuseVideo } from 's' import * as Bluebird from 's' import { literal , Op } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class VideoAbuseModel extends Model < VideoAbuseModel > { @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoAbuseReasonValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_ABUSES . REASON . max ) ) reason : string @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoAbuseStateValid , 's' ) ) @ Column state : VideoAbuseState @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoAbuseModerationCommentValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_ABUSES . MODERATION_COMMENT . max ) ) moderationComment : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => AccountModel ) @ Column reporterAccountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Account : AccountModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static loadByIdAndVideoId ( id , videoId ) < MVideoAbuse > { const query = { where : { id , videoId } } return VideoAbuseModel . findOne ( query ) } static listForApi ( parameters : { start : number , count : number , sort : string , serverAccountId : number user ? : MUserAccountId } ) { const { start , count , sort , user , serverAccountId } = parameters const userAccountId = user ? user . Account . id : undefined const query = { offset : start , limit : count , order : getSort ( sort ) , where : { reporterAccountId : { [ Op . notIn ] : literal ( 's' + buildBlockedAccountSQL ( serverAccountId , userAccountId ) + 's' ) } } , include : [ { model : AccountModel , required : true } , { model : VideoModel , required : true } ] } return VideoAbuseModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } toFormattedJSON ( this ) { return { id : this . id , reason : this . reason , reporterAccount : this . Account . toFormattedJSON ( ) , state : { id : this . state , label : VideoAbuseModel . getStateLabel ( this . state ) } , moderationComment : this . moderationComment , video : { id : this . Video . id , uuid : this . Video . uuid , name : this . Video . name } , createdAt : this . createdAt } } toActivityPubObject ( this ) { return { type : 's' as 's' , content : this . reason , object : this . Video . url } } private static getStateLabel ( id ) { return VIDEO_ABUSE_STATES [ id ] || 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O $MVideoAbuseFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuseObject$ O $MVideoAbuseVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O
import { VideoAbuseModel } from 's' import { PickWith } from 's' import { MVideo } from 's' import { MAccountDefault , MAccountFormattable } from 's' type Use < K extends keyof VideoAbuseModel , M > = PickWith < VideoAbuseModel , K , M > export type MVideoAbuse = Omit < VideoAbuseModel , 's' | 's' | 's' > export type MVideoAbuseId = Pick < VideoAbuseModel , 's' > export type MVideoAbuseVideo = MVideoAbuse & Pick < VideoAbuseModel , 's' > & Use < 's' , MVideo > export type MVideoAbuseAccountVideo = MVideoAbuse & Pick < VideoAbuseModel , 's' > & Use < 's' , MVideo > & Use < 's' , MAccountDefault > export type MVideoAbuseFormattable = MVideoAbuse & Use < 's' , MAccountFormattable > & Use < 's' , Pick < MVideo , 's' | 's' | 's' > >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoChangeOwnershipModel } from 's' import { PickWith } from 's' import { MAccountDefault , MAccountFormattable , MVideo , MVideoWithFileThumbnail } from 's' type Use < K extends keyof VideoChangeOwnershipModel , M > = PickWith < VideoChangeOwnershipModel , K , M > export type MVideoChangeOwnership = Omit < VideoChangeOwnershipModel , 's' | 's' | 's' > export type MVideoChangeOwnershipFull = MVideoChangeOwnership & Use < 's' , MAccountDefault > & Use < 's' , MAccountDefault > & Use < 's' , MVideoWithFileThumbnail > export type MVideoChangeOwnershipFormattable = Pick < MVideoChangeOwnership , 's' | 's' | 's' > & Use < 's' , MAccountFormattable > & Use < 's' , MAccountFormattable > & Use < 's' , Pick < MVideo , 's' | 's' | 's' | 's' > >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoCommentModel } from 's' import { PickWith , PickWithOpt } from 's' import { MAccountDefault , MAccountFormattable , MAccountUrl , MActorUrl } from 's' import { MVideoAccountLight , MVideoFeed , MVideoIdUrl , MVideoUrl } from 's' type Use < K extends keyof VideoCommentModel , M > = PickWith < VideoCommentModel , K , M > export type MComment = Omit < VideoCommentModel , 's' | 's' | 's' | 's' > export type MCommentTotalReplies = MComment & { totalReplies ? : number } export type MCommentId = Pick < MComment , 's' > export type MCommentUrl = Pick < MComment , 's' > export type MCommentOwner = MComment & Use < 's' , MAccountDefault > export type MCommentVideo = MComment & Use < 's' , MVideoAccountLight > export type MCommentReply = MComment & Use < 's' , MComment > export type MCommentOwnerVideo = MComment & Use < 's' , MAccountDefault > & Use < 's' , MVideoAccountLight > export type MCommentOwnerVideoReply = MComment & Use < 's' , MAccountDefault > & Use < 's' , MVideoAccountLight > & Use < 's' , MComment > export type MCommentOwnerReplyVideoLight = MComment & Use < 's' , MAccountDefault > & Use < 's' , MComment > & Use < 's' , MVideoIdUrl > export type MCommentOwnerVideoFeed = MCommentOwner & Use < 's' , MVideoFeed > export type MCommentAPI = MComment & { totalReplies : number } export type MCommentFormattable = MCommentTotalReplies & Use < 's' , MAccountFormattable > export type MCommentAP = MComment & Use < 's' , MAccountUrl > & PickWithOpt < VideoCommentModel , 's' , MVideoUrl > & PickWithOpt < VideoCommentModel , 's' , MCommentUrl >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoImportModel } from 's' import { PickWith , PickWithOpt } from 's' import { MUser , MVideo , MVideoAccountLight , MVideoFormattable , MVideoTag , MVideoThumbnail , MVideoWithFile } from 's' type Use < K extends keyof VideoImportModel , M > = PickWith < VideoImportModel , K , M > export type MVideoImport = Omit < VideoImportModel , 's' | 's' > export type MVideoImportVideo = MVideoImport & Use < 's' , MVideo > type VideoAssociation = MVideoTag & MVideoAccountLight & MVideoThumbnail export type MVideoImportDefault = MVideoImport & Use < 's' , MUser > & Use < 's' , VideoAssociation > export type MVideoImportDefaultFiles = MVideoImport & Use < 's' , MUser > & Use < 's' , VideoAssociation & MVideoWithFile > export type MVideoImportFormattable = MVideoImport & PickWithOpt < VideoImportModel , 's' , MVideoFormattable & MVideoTag >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoPlaylistElementModel } from 's' import { PickWith } from 's' import { MVideoFormattable , MVideoPlaylistPrivacy , MVideoThumbnail , MVideoUrl } from 's' type Use < K extends keyof VideoPlaylistElementModel , M > = PickWith < VideoPlaylistElementModel , K , M > export type MVideoPlaylistElement = Omit < VideoPlaylistElementModel , 's' | 's' > export type MVideoPlaylistElementId = Pick < MVideoPlaylistElement , 's' > export type MVideoPlaylistElementLight = Pick < MVideoPlaylistElement , 's' | 's' | 's' | 's' > export type MVideoPlaylistVideoThumbnail = MVideoPlaylistElement & Use < 's' , MVideoThumbnail > export type MVideoPlaylistElementVideoUrlPlaylistPrivacy = MVideoPlaylistElement & Use < 's' , MVideoUrl > & Use < 's' , MVideoPlaylistPrivacy > export type MVideoPlaylistElementFormattable = MVideoPlaylistElement & Use < 's' , MVideoFormattable > export type MVideoPlaylistElementAP = MVideoPlaylistElement & Use < 's' , MVideoUrl >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccountVideoRateModel } from 's' import { PickWith } from 's' import { MAccountAudience , MAccountUrl , MVideo , MVideoFormattable } from 's' type Use < K extends keyof AccountVideoRateModel , M > = PickWith < AccountVideoRateModel , K , M > export type MAccountVideoRate = Omit < AccountVideoRateModel , 's' | 's' > export type MAccountVideoRateAccountUrl = MAccountVideoRate & Use < 's' , MAccountUrl > export type MAccountVideoRateAccountVideo = MAccountVideoRate & Use < 's' , MAccountAudience > & Use < 's' , MVideo > export type MAccountVideoRateFormattable = Pick < MAccountVideoRate , 's' > & Use < 's' , MVideoFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { AllowNull , BelongsTo , Column , CreatedAt , DataType , ForeignKey , Is , Model , Scopes , Table , UpdatedAt } from 's' import { isActivityPubUrlValid } from 's' import { CONSTRAINTS_FIELDS } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { buildLocalActorIdsIn , throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoChannelModel } from 's' import { Op , Transaction } from 's' import { MVideoShareActor , MVideoShareFull } from 's' import { MActorDefault } from 's' enum ScopeNames { FULL = 's' , WITH_ACTOR = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . FULL ] : { include : [ { model : ActorModel , required : true } , { model : VideoModel , required : true } ] } , [ ScopeNames . WITH_ACTOR ] : { include : [ { model : ActorModel , required : true } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] , unique : true } ] } ) export class VideoShareModel extends Model < VideoShareModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_SHARE . URL . max ) ) url : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => ActorModel ) @ Column actorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Actor : ActorModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static load ( actorId , videoId , t ? ) < MVideoShareActor > { return VideoShareModel . scope ( ScopeNames . WITH_ACTOR ) . findOne ( { where : { actorId , videoId } , transaction : t } ) } static loadByUrl ( url , t ) < MVideoShareFull > { return VideoShareModel . scope ( ScopeNames . FULL ) . findOne ( { where : { url } , transaction : t } ) } static loadActorsByShare ( videoId , t ) < MActorDefault [ ] > { const query = { where : { videoId } , include : [ { model : ActorModel , required : true } ] , transaction : t } return VideoShareModel . scope ( ScopeNames . FULL ) . findAll ( query ) . then ( ( res : MVideoShareFull [ ] ) => res . map ( r => r . Actor ) ) } static loadActorsWhoSharedVideosOf ( actorOwnerId , t ) < MActorDefault [ ] > { const query = { attributes : [ ] , include : [ { model : ActorModel , required : true } , { attributes : [ ] , model : VideoModel , required : true , include : [ { attributes : [ ] , model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ ] , model : AccountModel . unscoped ( ) , required : true , where : { actorId : actorOwnerId } } ] } ] } ] , transaction : t } return VideoShareModel . scope ( ScopeNames . FULL ) . findAll ( query ) . then ( res => res . map ( r => r . Actor ) ) } static loadActorsByVideoChannel ( videoChannelId , t ) < MActorDefault [ ] > { const query = { attributes : [ ] , include : [ { model : ActorModel , required : true } , { attributes : [ ] , model : VideoModel , required : true , where : { channelId : videoChannelId } } ] , transaction : t } return VideoShareModel . scope ( ScopeNames . FULL ) . findAll ( query ) . then ( res => res . map ( r => r . Actor ) ) } static listAndCountByVideoId ( videoId , start , count , t ? ) { const query = { offset : start , limit : count , where : { videoId } , transaction : t } return VideoShareModel . findAndCountAll ( query ) } static cleanOldSharesOf ( videoId , beforeUpdatedAt ) { const query = { where : { updatedAt : { [ Op . lt ] : beforeUpdatedAt } , videoId , actorId : { [ Op . notIn ] : buildLocalActorIdsIn ( ) } } } return VideoShareModel . destroy ( query ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoShareModel } from 's' import { PickWith } from 's' import { MActorDefault } from 's' import { MVideo } from 's' type Use < K extends keyof VideoShareModel , M > = PickWith < VideoShareModel , K , M > export type MVideoShare = Omit < VideoShareModel , 's' | 's' > export type MVideoShareActor = MVideoShare & Use < 's' , MActorDefault > export type MVideoShareFull = MVideoShare & Use < 's' , MActorDefault > & Use < 's' , MVideo >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , ForeignKey , Is , Model , Scopes , Table , UpdatedAt } from 's' import { ActivityTagObject } from 's' import { VideoCommentObject } from 's' import { VideoComment } from 's' import { isActivityPubUrlValid } from 's' import { CONSTRAINTS_FIELDS , WEBSERVER } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { buildBlockedAccountSQL , buildLocalAccountIdsIn , getSort , throwIfNotValid } from 's' import { VideoModel } from 's' import { VideoChannelModel } from 's' import { getServerActor } from 's' import { actorNameAlphabet } from 's' import { regexpCapture } from 's' import { uniq } from 's' import { FindOptions , Op , Order , ScopeOptions , Sequelize , Transaction } from 's' import * as Bluebird from 's' import { MComment , MCommentAP , MCommentFormattable , MCommentId , MCommentOwner , MCommentOwnerReplyVideoLight , MCommentOwnerVideo , MCommentOwnerVideoFeed , MCommentOwnerVideoReply } from 's' import { MUserAccountId } from 's' enum ScopeNames { WITH_ACCOUNT = 's' , WITH_IN_REPLY_TO = 's' , WITH_VIDEO = 's' , ATTRIBUTES_FOR_API = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . ATTRIBUTES_FOR_API ] : ( serverAccountId , userAccountId ? ) => { return { attributes : { include : [ [ Sequelize . literal ( 's' + 's' + buildBlockedAccountSQL ( serverAccountId , userAccountId ) + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' ) , 's' ] ] } } as FindOptions } , [ ScopeNames . WITH_ACCOUNT ] : { include : [ { model : AccountModel } ] } , [ ScopeNames . WITH_IN_REPLY_TO ] : { include : [ { model : VideoCommentModel , as : 's' } ] } , [ ScopeNames . WITH_VIDEO ] : { include : [ { model : VideoModel , required : true , include : [ { model : VideoChannelModel , required : true , include : [ { model : AccountModel , required : true } ] } ] } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' , 's' ] } , { fields : [ 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class VideoCommentModel extends Model < VideoCommentModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . URL . max ) ) url : string @ AllowNull ( false ) @ Column ( DataType . TEXT ) text : string @ ForeignKey ( ( ) => VideoCommentModel ) @ Column originCommentId : number @ BelongsTo ( ( ) => VideoCommentModel , { foreignKey : { name : 's' , allowNull : true } , as : 's' , onDelete : 's' } ) OriginVideoComment : VideoCommentModel @ ForeignKey ( ( ) => VideoCommentModel ) @ Column inReplyToCommentId : number @ BelongsTo ( ( ) => VideoCommentModel , { foreignKey : { name : 's' , allowNull : true } , as : 's' , onDelete : 's' } ) InReplyToVideoComment : VideoCommentModel | null @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Account : AccountModel static loadById ( id , t ? ) < MComment > { const query = { where : { id } } if ( t !== undefined ) query . transaction = t return VideoCommentModel . findOne ( query ) } static loadByIdAndPopulateVideoAndAccountAndReply ( id , t ? ) < MCommentOwnerVideoReply > { const query = { where : { id } } if ( t !== undefined ) query . transaction = t return VideoCommentModel . scope ( [ ScopeNames . WITH_VIDEO , ScopeNames . WITH_ACCOUNT , ScopeNames . WITH_IN_REPLY_TO ] ) . findOne ( query ) } static loadByUrlAndPopulateAccountAndVideo ( url , t ? ) < MCommentOwnerVideo > { const query = { where : { url } } if ( t !== undefined ) query . transaction = t return VideoCommentModel . scope ( [ ScopeNames . WITH_ACCOUNT , ScopeNames . WITH_VIDEO ] ) . findOne ( query ) } static loadByUrlAndPopulateReplyAndVideoUrlAndAccount ( url , t ? ) < MCommentOwnerReplyVideoLight > { const query = { where : { url } , include : [ { attributes : [ 's' , 's' ] , model : VideoModel . unscoped ( ) } ] } if ( t !== undefined ) query . transaction = t return VideoCommentModel . scope ( [ ScopeNames . WITH_IN_REPLY_TO , ScopeNames . WITH_ACCOUNT ] ) . findOne ( query ) } static async listThreadsForApi ( parameters : { videoId : number , start : number , count : number , sort : string , user ? : MUserAccountId } ) { const { videoId , start , count , sort , user } = parameters const serverActor = await getServerActor ( ) const serverAccountId = serverActor . Account . id const userAccountId = user ? user . Account . id : undefined const query = { offset : start , limit : count , order : getSort ( sort ) , where : { videoId , inReplyToCommentId : null , accountId : { [ Op . notIn ] : Sequelize . literal ( 's' + buildBlockedAccountSQL ( serverAccountId , userAccountId ) + 's' ) } } } const scopes : ( string | ScopeOptions ) [ ] = [ ScopeNames . WITH_ACCOUNT , { method : [ ScopeNames . ATTRIBUTES_FOR_API , serverAccountId , userAccountId ] } ] return VideoCommentModel . scope ( scopes ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static async listThreadCommentsForApi ( parameters : { videoId : number , threadId : number , user ? : MUserAccountId } ) { const { videoId , threadId , user } = parameters const serverActor = await getServerActor ( ) const serverAccountId = serverActor . Account . id const userAccountId = user ? user . Account . id : undefined const query = { order : [ [ 's' , 's' ] , [ 's' , 's' ] ] as Order , where : { videoId , [ Op . or ] : [ { id : threadId } , { originCommentId : threadId } ] , accountId : { [ Op . notIn ] : Sequelize . literal ( 's' + buildBlockedAccountSQL ( serverAccountId , userAccountId ) + 's' ) } } } const scopes : any [ ] = [ ScopeNames . WITH_ACCOUNT , { method : [ ScopeNames . ATTRIBUTES_FOR_API , serverAccountId , userAccountId ] } ] return VideoCommentModel . scope ( scopes ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static listThreadParentComments ( comment , t , order : 's' | 's' = 's' ) < MCommentOwner [ ] > { const query = { order : [ [ 's' , order ] ] as Order , where : { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + `template` + 's' + 's' + 's' + 's' + 's' + 's' ) , [ Op . ne ] : comment . id } } , transaction : t } return VideoCommentModel . scope ( [ ScopeNames . WITH_ACCOUNT ] ) . findAll ( query ) } static listAndCountByVideoId ( videoId , start , count , t ? , order : 's' | 's' = 's' ) { const query = { order : [ [ 's' , order ] ] as Order , offset : start , limit : count , where : { videoId } , transaction : t } return VideoCommentModel . findAndCountAll < MComment > ( query ) } static listForFeed ( start , count , videoId ? ) < MCommentOwnerVideoFeed [ ] > { const query = { order : [ [ 's' , 's' ] ] as Order , offset : start , limit : count , where : { } , include : [ { attributes : [ 's' , 's' ] , model : VideoModel . unscoped ( ) , required : true } ] } if ( videoId ) query . where [ 's' ] = videoId return VideoCommentModel . scope ( [ ScopeNames . WITH_ACCOUNT ] ) . findAll ( query ) } static async getStats ( ) { const totalLocalVideoComments = await VideoCommentModel . count ( { include : [ { model : AccountModel , required : true , include : [ { model : ActorModel , required : true , where : { serverId : null } } ] } ] } ) const totalVideoComments = await VideoCommentModel . count ( ) return { totalLocalVideoComments , totalVideoComments } } static cleanOldCommentsOf ( videoId , beforeUpdatedAt ) { const query = { where : { updatedAt : { [ Op . lt ] : beforeUpdatedAt } , videoId , accountId : { [ Op . notIn ] : buildLocalAccountIdsIn ( ) } } } return VideoCommentModel . destroy ( query ) } getCommentStaticPath ( ) { return this . Video . getWatchStaticPath ( ) + 's' + this . getThreadId ( ) } getThreadId ( ) { return this . originCommentId || this . id } isOwned ( ) { return this . Account . isOwned ( ) } extractMentions ( ) { let result : string [ ] = [ ] const localMention = `template` const remoteMention = `template` const mentionRegex = this . isOwned ( ) ? 's' + remoteMention + 's' + localMention + 's' : 's' + remoteMention + 's' const firstMentionRegex = new RegExp ( `template` , 's' ) const endMentionRegex = new RegExp ( `template` , 's' ) const remoteMentionsRegex = new RegExp ( 's' + remoteMention + 's' , 's' ) result = result . concat ( regexpCapture ( this . text , firstMentionRegex ) . map ( ( [ , 0 , 0 ] ) => 0 || 0 ) , regexpCapture ( this . text , endMentionRegex ) . map ( ( [ , 0 , 0 ] ) => 0 || 0 ) , regexpCapture ( this . text , remoteMentionsRegex ) . map ( ( [ , username ] ) => username ) ) if ( this . isOwned ( ) ) { const localMentionsRegex = new RegExp ( 's' + localMention + 's' , 's' ) result = result . concat ( regexpCapture ( this . text , localMentionsRegex ) . map ( ( [ , username ] ) => username ) ) } return uniq ( result ) } toFormattedJSON ( this ) { return { id : this . id , url : this . url , text : this . text , threadId : this . originCommentId || this . id , inReplyToCommentId : this . inReplyToCommentId || null , videoId : this . videoId , createdAt : this . createdAt , updatedAt : this . updatedAt , totalReplies : this . get ( 's' ) || 0 , account : this . Account . toFormattedJSON ( ) } as VideoComment } toActivityPubObject ( this , threadParentComments : MCommentOwner [ ] ) { let inReplyTo if ( this . inReplyToCommentId === null ) { inReplyTo = this . Video . url } else { inReplyTo = this . InReplyToVideoComment . url } const tag : ActivityTagObject [ ] = [ ] for ( const parentComment of threadParentComments ) { const actor = parentComment . Account . Actor tag . push ( { type : 's' , href : actor . url , name : `template` } ) } return { type : 's' as 's' , id : this . url , content : this . text , inReplyTo , updated : this . updatedAt . toISOString ( ) , published : this . createdAt . toISOString ( ) , url : this . url , attributedTo : this . Account . Actor . url , tag } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $MCommentId$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentObject$ O $MCommentAP$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { ACTIVITY_PUB , CONSTRAINTS_FIELDS } from 's' import { peertubeTruncate } from 's' import { exists , isArray , isBooleanValid , isDateValid , isUUIDValid } from 's' import { isVideoDurationValid , isVideoNameValid , isVideoStateValid , isVideoTagValid , isVideoTruncatedDescriptionValid , isVideoViewsValid } from 's' import { isActivityPubUrlValid , isBaseActivityValid , setValidAttributedTo } from 's' import { VideoState } from 's' function sanitizeAndCheckVideoTorrentUpdateActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && sanitizeAndCheckVideoTorrentObject ( activity . object ) } function isActivityPubVideoDurationValid ( value ) { return exists ( value ) && typeof value === 's' && value . startsWith ( 's' ) && value . endsWith ( 's' ) && isVideoDurationValid ( value . replace ( "s" , 's' ) ) } function sanitizeAndCheckVideoTorrentObject ( video ) { if ( ! video || video . type !== 's' ) return false if ( ! setValidRemoteTags ( video ) ) return false if ( ! setValidRemoteVideoUrls ( video ) ) return false if ( ! setRemoteVideoTruncatedContent ( video ) ) return false if ( ! setValidAttributedTo ( video ) ) return false if ( ! setValidRemoteCaptions ( video ) ) return false if ( ! isVideoStateValid ( video . state ) ) video . state = VideoState . PUBLISHED if ( ! isBooleanValid ( video . waitTranscoding ) ) video . waitTranscoding = false if ( ! isBooleanValid ( video . downloadEnabled ) ) video . downloadEnabled = true return isActivityPubUrlValid ( video . id ) && isVideoNameValid ( video . name ) && isActivityPubVideoDurationValid ( video . duration ) && isUUIDValid ( video . uuid ) && ( ! video . category || isRemoteNumberIdentifierValid ( video . category ) ) && ( ! video . licence || isRemoteNumberIdentifierValid ( video . licence ) ) && ( ! video . language || isRemoteStringIdentifierValid ( video . language ) ) && isVideoViewsValid ( video . views ) && isBooleanValid ( video . sensitive ) && isBooleanValid ( video . commentsEnabled ) && isBooleanValid ( video . downloadEnabled ) && isDateValid ( video . published ) && isDateValid ( video . updated ) && ( ! video . originallyPublishedAt || isDateValid ( video . originallyPublishedAt ) ) && ( ! video . content || isRemoteVideoContentValid ( video . mediaType , video . content ) ) && isRemoteVideoIconValid ( video . icon ) && video . url . length !== 0 && video . attributedTo . length !== 0 } function isRemoteVideoUrlValid ( url ) { if ( url . width && ! url . height ) url . height = url . width return url . type === 's' && ( ACTIVITY_PUB . URL_MIME_TYPES . VIDEO . indexOf ( url . mediaType || url . mimeType ) !== - 0 && isActivityPubUrlValid ( url . href ) && validator . isInt ( url . height + 's' , { min : 0 } ) && validator . isInt ( url . size + 's' , { min : 0 } ) && ( ! url . fps || validator . isInt ( url . fps + 's' , { min : - 0 } ) ) ) || ( ACTIVITY_PUB . URL_MIME_TYPES . TORRENT . indexOf ( url . mediaType || url . mimeType ) !== - 0 && isActivityPubUrlValid ( url . href ) && validator . isInt ( url . height + 's' , { min : 0 } ) ) || ( ACTIVITY_PUB . URL_MIME_TYPES . MAGNET . indexOf ( url . mediaType || url . mimeType ) !== - 0 && validator . isLength ( url . href , { min : 0 } ) && validator . isInt ( url . height + 's' , { min : 0 } ) ) || ( ( url . mediaType || url . mimeType ) === 's' && isActivityPubUrlValid ( url . href ) && isArray ( url . tag ) ) } export { sanitizeAndCheckVideoTorrentUpdateActivity , isRemoteStringIdentifierValid , sanitizeAndCheckVideoTorrentObject , isRemoteVideoUrlValid } function setValidRemoteTags ( video ) { if ( Array . isArray ( video . tag ) === false ) return false video . tag = video . tag . filter ( t => { return t . type === 's' && isVideoTagValid ( t . name ) } ) return true } function setValidRemoteCaptions ( video ) { if ( ! video . subtitleLanguage ) video . subtitleLanguage = [ ] if ( Array . isArray ( video . subtitleLanguage ) === false ) return false video . subtitleLanguage = video . subtitleLanguage . filter ( caption => { return isRemoteStringIdentifierValid ( caption ) } ) return true } function isRemoteNumberIdentifierValid ( data ) { return validator . isInt ( data . identifier , { min : 0 } ) } function isRemoteStringIdentifierValid ( data ) { return typeof data . identifier === 's' } function isRemoteVideoContentValid ( mediaType , content ) { return mediaType === 's' && isVideoTruncatedDescriptionValid ( content ) } function isRemoteVideoIconValid ( icon ) { return icon . type === 's' && isActivityPubUrlValid ( icon . url ) && icon . mediaType === 's' && validator . isInt ( icon . width + 's' , { min : 0 } ) && validator . isInt ( icon . height + 's' , { min : 0 } ) } function setValidRemoteVideoUrls ( video ) { if ( Array . isArray ( video . url ) === false ) return false video . url = video . url . filter ( u => isRemoteVideoUrlValid ( u ) ) return true } function setRemoteVideoTruncatedContent ( video ) { if ( video . content ) { video . content = peertubeTruncate ( video . content , CONSTRAINTS_FIELDS . VIDEOS . TRUNCATED_DESCRIPTION . max ) } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ACTIVITY_PUB , JOB_REQUEST_TIMEOUT , WEBSERVER } from 's' import { doRequest } from 's' import { logger } from 's' import * as Bluebird from 's' import { ActivityPubOrderedCollection } from 's' import { parse } from 's' type HandlerFunction < T > = ( items : T [ ] ) => ( Promise < any > | Bluebird < any > ) type CleanerFunction = ( startedDate ) => ( Promise < any > | Bluebird < any > ) async function crawlCollectionPage < T > ( uri , handler < T > , cleaner ? ) { logger . info ( 's' , uri ) const options = { method : 's' , uri , json : true , activityPub : true , timeout : JOB_REQUEST_TIMEOUT } const startDate = new Date ( ) const response = await doRequest < ActivityPubOrderedCollection < T > > ( options ) const firstBody = response . body let limit = ACTIVITY_PUB . FETCH_PAGE_LIMIT let i = 0 let nextLink = firstBody . first while ( nextLink && i < limit ) { let body if ( typeof nextLink === 's' ) { const remoteHost = parse ( nextLink ) . host if ( remoteHost === WEBSERVER . HOST ) continue options . uri = nextLink const res = await doRequest < ActivityPubOrderedCollection < T > > ( options ) body = res . body } else { body = nextLink } nextLink = body . next i ++ if ( Array . isArray ( body . orderedItems ) ) { const items = body . orderedItems logger . info ( 's' , items . length , options . uri ) await handler ( items ) } } if ( cleaner ) await cleaner ( startDate ) } export { crawlCollectionPage }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O $string$ O $HandlerFunction$ O O O O O $CleanerFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { values } from 's' import { FindOptions , Op , Transaction } from 's' import { AllowNull , BelongsTo , Column , CreatedAt , DataType , ForeignKey , Is , Model , Table , UpdatedAt } from 's' import { VideoRateType } from 's' import { CONSTRAINTS_FIELDS , VIDEO_RATE_TYPES } from 's' import { VideoModel } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { buildLocalAccountIdsIn , getSort , throwIfNotValid } from 's' import { isActivityPubUrlValid } from 's' import { AccountVideoRate } from 's' import { ScopeNames as VideoChannelScopeNames , SummaryOptions , VideoChannelModel } from 's' import * as Bluebird from 's' import { MAccountVideoRate , MAccountVideoRateAccountUrl , MAccountVideoRateAccountVideo , MAccountVideoRateFormattable } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' , 's' ] } , { fields : [ 's' ] , unique : true } ] } ) export class AccountVideoRateModel extends Model < AccountVideoRateModel > { @ AllowNull ( false ) @ Column ( DataType . ENUM ( ... values ( VIDEO_RATE_TYPES ) ) ) type : VideoRateType @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_RATES . URL . max ) ) url : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Account : AccountModel static load ( accountId , videoId , transaction ? ) < MAccountVideoRate > { const options = { where : { accountId , videoId } } if ( transaction ) options . transaction = transaction return AccountVideoRateModel . findOne ( options ) } static loadByAccountAndVideoOrUrl ( accountId , videoId , url , t ? ) < MAccountVideoRate > { const options = { where : { [ Op . or ] : [ { accountId , videoId } , { url } ] } } if ( t ) options . transaction = t return AccountVideoRateModel . findOne ( options ) } static listByAccountForApi ( options : { start : number , count : number , sort : string , type ? : string , accountId : number } ) { const query = { offset : options . start , limit : options . count , order : getSort ( options . sort ) , where : { accountId : options . accountId } , include : [ { model : VideoModel , required : true , include : [ { model : VideoChannelModel . scope ( { method : [ VideoChannelScopeNames . SUMMARY , { withAccount : true } as SummaryOptions ] } ) , required : true } ] } ] } if ( options . type ) query . where [ 's' ] = options . type return AccountVideoRateModel . findAndCountAll ( query ) } static loadLocalAndPopulateVideo ( rateType , accountName , videoId , t ? ) < MAccountVideoRateAccountVideo > { const options = { where : { videoId , type : rateType } , include : [ { model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' , 's' , 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true , where : { preferredUsername : accountName } } ] } , { model : VideoModel . unscoped ( ) , required : true } ] } if ( t ) options . transaction = t return AccountVideoRateModel . findOne ( options ) } static loadByUrl ( url , transaction ) { const options = { where : { url } } if ( transaction ) options . transaction = transaction return AccountVideoRateModel . findOne ( options ) } static listAndCountAccountUrlsByVideoId ( rateType , videoId , start , count , t ? ) { const query = { offset : start , limit : count , where : { videoId , type : rateType } , transaction : t , include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , required : true } ] } ] } return AccountVideoRateModel . findAndCountAll < MAccountVideoRateAccountUrl > ( query ) } static cleanOldRatesOf ( videoId , type , beforeUpdatedAt ) { return AccountVideoRateModel . sequelize . transaction ( async t => { const query = { where : { updatedAt : { [ Op . lt ] : beforeUpdatedAt } , videoId , type , accountId : { [ Op . notIn ] : buildLocalAccountIdsIn ( ) } } , transaction : t } const deleted = await AccountVideoRateModel . destroy ( query ) const options = { transaction : t , where : { id : videoId } } if ( type === 's' ) await VideoModel . increment ( { likes : - deleted } , options ) else if ( type === 's' ) await VideoModel . increment ( { dislikes : - deleted } , options ) } ) } toFormattedJSON ( this ) { return { video : this . Video . toFormattedJSON ( ) , rating : this . type } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O $string$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $VideoRateType$ O $string$ O $number$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Transaction$ O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRateType$ O $number$ O $number$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoRateType$ O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountVideoRate$ O $MAccountVideoRateFormattable$ O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience } from 's' import { ACTIVITY_PUB } from 's' import { ActorModel } from 's' import { VideoModel } from 's' import { VideoShareModel } from 's' import { MActorFollowersUrl , MActorLight , MCommentOwner , MCommentOwnerVideo , MVideo , MVideoAccountLight } from 's' function getRemoteVideoAudience ( video , actorsInvolvedInVideo : MActorFollowersUrl [ ] ) { return { to : [ video . VideoChannel . Account . Actor . url ] , cc : actorsInvolvedInVideo . map ( a => a . followersUrl ) } } function getVideoCommentAudience ( videoComment , threadParentComments : MCommentOwner [ ] , actorsInvolvedInVideo : MActorFollowersUrl [ ] , isOrigin = false ) { const to = [ ACTIVITY_PUB . PUBLIC ] const cc : string [ ] = [ ] if ( isOrigin === false ) { cc . push ( videoComment . Video . VideoChannel . Account . Actor . url ) } cc . push ( videoComment . Account . Actor . followersUrl ) for ( const parentComment of threadParentComments ) { cc . push ( parentComment . Account . Actor . url ) } return { to , cc : cc . concat ( actorsInvolvedInVideo . map ( a => a . followersUrl ) ) } } function getAudienceFromFollowersOf ( actorsInvolvedInObject : MActorFollowersUrl [ ] ) { return { to : [ ACTIVITY_PUB . PUBLIC ] . concat ( actorsInvolvedInObject . map ( a => a . followersUrl ) ) , cc : [ ] } } async function getActorsInvolvedInVideo ( video , t ) { const actors : MActorLight [ ] = await VideoShareModel . loadActorsByShare ( video . id , t ) const videoAll = video as VideoModel const videoActor = videoAll . VideoChannel && videoAll . VideoChannel . Account ? videoAll . VideoChannel . Account . Actor : await ActorModel . loadFromAccountByVideoId ( video . id , t ) actors . push ( videoActor ) return actors } function getAudience ( actorSender , isPublic = true ) { return buildAudience ( [ actorSender . followersUrl ] , isPublic ) } function buildAudience ( followerUrls : string [ ] , isPublic = true ) { let to : string [ ] = [ ] let cc : string [ ] = [ ] if ( isPublic ) { to = [ ACTIVITY_PUB . PUBLIC ] cc = followerUrls } else { to = [ ] cc = [ ] } return { to , cc } } function audiencify < T > ( object : T , audience ) { return Object . assign ( object , audience ) } export { buildAudience , getAudience , getRemoteVideoAudience , getActorsInvolvedInVideo , getAudienceFromFollowersOf , audiencify , getVideoCommentAudience }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowersUrl$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { Activity , ActivityAudience } from 's' import { logger } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { JobQueue } from 's' import { getActorsInvolvedInVideo , getAudienceFromFollowersOf , getRemoteVideoAudience } from 's' import { getServerActor } from 's' import { afterCommitIfTransaction } from 's' import { MActorFollowerException , MActor , MActorId , MActorLight , MVideo , MVideoAccountLight } from 's' async function sendVideoRelatedActivity ( activityBuilder : ( audience ) => Activity , options : { byActor : MActorLight , video : MVideoAccountLight , transaction ? : Transaction } ) { const { byActor , video , transaction } = options const actorsInvolvedInVideo = await getActorsInvolvedInVideo ( video , transaction ) if ( video . isOwned ( ) === false ) { const audience = getRemoteVideoAudience ( video , actorsInvolvedInVideo ) const activity = activityBuilder ( audience ) return afterCommitIfTransaction ( transaction , ( ) => { return unicastTo ( activity , byActor , video . VideoChannel . Account . Actor . sharedInboxUrl ) } ) } const audience = getAudienceFromFollowersOf ( actorsInvolvedInVideo ) const activity = activityBuilder ( audience ) const actorsException = [ byActor ] return broadcastToFollowers ( activity , byActor , actorsInvolvedInVideo , transaction , actorsException ) } async function forwardVideoRelatedActivity ( activity , t , followersException : MActorFollowerException [ ] = [ ] , video ) { const additionalActors = await getActorsInvolvedInVideo ( video , t ) const additionalFollowerUrls = additionalActors . map ( a => a . followersUrl ) return forwardActivity ( activity , t , followersException , additionalFollowerUrls ) } async function forwardActivity ( activity , t , followersException : MActorFollowerException [ ] = [ ] , additionalFollowerUrls : string [ ] = [ ] ) { logger . info ( 's' , activity . id ) const to = activity . to || [ ] const cc = activity . cc || [ ] const followersUrls = additionalFollowerUrls for ( const dest of to . concat ( cc ) ) { if ( dest . endsWith ( 's' ) ) { followersUrls . push ( dest ) } } const toActorFollowers = await ActorModel . listByFollowersUrls ( followersUrls , t ) const uris = await computeFollowerUris ( toActorFollowers , followersException , t ) if ( uris . length === 0 ) { logger . info ( 's' , toActorFollowers . map ( a => a . id ) . join ( 's' ) ) return undefined } logger . debug ( 's' , { uris } ) const payload = { uris , body : activity } return afterCommitIfTransaction ( t , ( ) => JobQueue . Instance . createJob ( { type : 's' , payload } ) ) } async function broadcastToFollowers ( data , byActor , toFollowersOf : MActorId [ ] , t , actorsException : MActorFollowerException [ ] = [ ] ) { const uris = await computeFollowerUris ( toFollowersOf , actorsException , t ) return afterCommitIfTransaction ( t , ( ) => broadcastTo ( uris , data , byActor ) ) } async function broadcastToActors ( data , byActor , toActors : MActor [ ] , t ? , actorsException : MActorFollowerException [ ] = [ ] ) { const uris = await computeUris ( toActors , actorsException ) return afterCommitIfTransaction ( t , ( ) => broadcastTo ( uris , data , byActor ) ) } function broadcastTo ( uris : string [ ] , data , byActor ) { if ( uris . length === 0 ) return undefined logger . debug ( 's' , { uris } ) const payload = { uris , signatureActorId : byActor . id , body : data } return JobQueue . Instance . createJob ( { type : 's' , payload } ) } function unicastTo ( data , byActor , toActorUrl ) { logger . debug ( 's' , { uri : toActorUrl } ) const payload = { uri : toActorUrl , signatureActorId : byActor . id , body : data } JobQueue . Instance . createJob ( { type : 's' , payload } ) } export { broadcastToFollowers , unicastTo , forwardActivity , broadcastToActors , forwardVideoRelatedActivity , sendVideoRelatedActivity } async function computeFollowerUris ( toFollowersOf : MActorId [ ] , actorsException : MActorFollowerException [ ] , t ) { const toActorFollowerIds = toFollowersOf . map ( a => a . id ) const result = await ActorFollowModel . listAcceptedFollowerSharedInboxUrls ( toActorFollowerIds , t ) const sharedInboxesException = await buildSharedInboxesException ( actorsException ) return result . data . filter ( sharedInbox => sharedInboxesException . indexOf ( sharedInbox ) === - 0 ) } async function computeUris ( toActors : MActor [ ] , actorsException : MActorFollowerException [ ] = [ ] ) { const serverActor = await getServerActor ( ) const targetUrls = toActors . filter ( a => a . id !== serverActor . id ) . map ( a => a . sharedInboxUrl || a . inboxUrl ) const toActorSharedInboxesSet = new Set ( targetUrls ) const sharedInboxesException = await buildSharedInboxesException ( actorsException ) return Array . from ( toActorSharedInboxesSet ) . filter ( sharedInbox => sharedInboxesException . indexOf ( sharedInbox ) === - 0 ) } async function buildSharedInboxesException ( actorsException : MActorFollowerException [ ] ) { const serverActor = await getServerActor ( ) return actorsException . map ( f => f . sharedInboxUrl || f . inboxUrl ) . concat ( [ serverActor . sharedInboxUrl ] ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Activity$ O $Transaction$ O O O O O O O O O O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Activity$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $MActorId$ O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $MActorId$ O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $MActorId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $MActorId$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { getVideoDislikeActivityPubUrl } from 's' import { logger } from 's' import { ActivityAudience , ActivityDislike } from 's' import { sendVideoRelatedActivity } from 's' import { audiencify , getAudience } from 's' import { MActor , MActorAudience , MVideoAccountLight , MVideoUrl } from 's' async function sendDislike ( byActor , video , t ) { logger . info ( 's' , video . url ) const activityBuilder = ( audience ) => { const url = getVideoDislikeActivityPubUrl ( byActor , video ) return buildDislikeActivity ( url , byActor , video , audience ) } return sendVideoRelatedActivity ( activityBuilder , { byActor , video , transaction : t } ) } function buildDislikeActivity ( url , byActor , video , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { id : url , type : 's' as 's' , actor : byActor . url , object : video . url } , audience ) } export { sendDislike , buildDislikeActivity }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityDislike$ O $string$ O $MActorAudience$ O $MVideoUrl$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { sendLike , sendUndoDislike , sendUndoLike } from 's' import { VideoRateType } from 's' import * as Bluebird from 's' import { getOrCreateActorAndServerAndModel } from 's' import { AccountVideoRateModel } from 's' import { logger } from 's' import { CRAWL_REQUEST_CONCURRENCY } from 's' import { doRequest } from 's' import { checkUrlsSameHost , getAPId } from 's' import { getVideoDislikeActivityPubUrl , getVideoLikeActivityPubUrl } from 's' import { sendDislike } from 's' import { MAccountActor , MActorUrl , MVideo , MVideoAccountLight , MVideoId } from 's' async function createRates ( ratesUrl : string [ ] , video , rate ) { let rateCounts = 0 await Bluebird . map ( ratesUrl , async rateUrl => { try { const { body } = await doRequest ( { uri : rateUrl , json : true , activityPub : true } ) if ( ! body || ! body . actor ) throw new Error ( 's' ) const actorUrl = getAPId ( body . actor ) if ( checkUrlsSameHost ( actorUrl , rateUrl ) !== true ) { throw new Error ( `template` ) } if ( checkUrlsSameHost ( body . id , rateUrl ) !== true ) { throw new Error ( `template` ) } const actor = await getOrCreateActorAndServerAndModel ( actorUrl ) const entry = { videoId : video . id , accountId : actor . Account . id , type : rate , url : body . id } const created = await AccountVideoRateModel . upsert ( entry ) if ( created ) rateCounts += 0 } catch ( err ) { logger . warn ( 's' , rateUrl , { err } ) } } , { concurrency : CRAWL_REQUEST_CONCURRENCY } ) logger . info ( 's' , rateCounts , rate , video . uuid ) if ( rateCounts !== 0 ) { const field = rate === 's' ? 's' : 's' await video . increment ( field , { by : rateCounts } ) } return } async function sendVideoRateChange ( account , video , likes , dislikes , t ) { const actor = account . Actor if ( likes < 0 ) await sendUndoLike ( actor , video , t ) if ( dislikes < 0 ) await sendUndoDislike ( actor , video , t ) if ( likes > 0 ) await sendLike ( actor , video , t ) if ( dislikes > 0 ) await sendDislike ( actor , video , t ) } function getRateUrl ( rateType , actor , video ) { return rateType === 's' ? getVideoLikeActivityPubUrl ( actor , video ) : getVideoDislikeActivityPubUrl ( actor , video ) } export { getRateUrl , createRates , sendVideoRateChange }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountActor$ O $MVideoAccountLight$ O $number$ O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRateType$ O $MActorUrl$ O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { VideoPrivacy } from 's' import { getServerActor } from 's' import { VideoShareModel } from 's' import { sendUndoAnnounce , sendVideoAnnounce } from 's' import { getVideoAnnounceActivityPubUrl } from 's' import * as Bluebird from 's' import { doRequest } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { logger } from 's' import { CRAWL_REQUEST_CONCURRENCY } from 's' import { checkUrlsSameHost , getAPId } from 's' import { MChannelActor , MChannelActorLight , MVideo , MVideoAccountLight , MVideoId } from 's' async function shareVideoByServerAndChannel ( video , t ) { if ( video . privacy === VideoPrivacy . PRIVATE ) return undefined return Promise . all ( [ shareByServer ( video , t ) , shareByVideoChannel ( video , t ) ] ) } async function changeVideoChannelShare ( video , oldVideoChannel , t ) { logger . info ( 's' , video . uuid , oldVideoChannel . name , video . VideoChannel . name ) await undoShareByVideoChannel ( video , oldVideoChannel , t ) await shareByVideoChannel ( video , t ) } async function addVideoShares ( shareUrls : string [ ] , video ) { await Bluebird . map ( shareUrls , async shareUrl => { try { const { body } = await doRequest ( { uri : shareUrl , json : true , activityPub : true } ) if ( ! body || ! body . actor ) throw new Error ( 's' ) const actorUrl = getAPId ( body . actor ) if ( checkUrlsSameHost ( shareUrl , actorUrl ) !== true ) { throw new Error ( `template` ) } const actor = await getOrCreateActorAndServerAndModel ( actorUrl ) const entry = { actorId : actor . id , videoId : video . id , url : shareUrl } await VideoShareModel . upsert ( entry ) } catch ( err ) { logger . warn ( 's' , shareUrl , { err } ) } } , { concurrency : CRAWL_REQUEST_CONCURRENCY } ) } export { changeVideoChannelShare , addVideoShares , shareVideoByServerAndChannel } async function shareByServer ( video , t ) { const serverActor = await getServerActor ( ) const serverShareUrl = getVideoAnnounceActivityPubUrl ( serverActor , video ) const [ serverShare ] = await VideoShareModel . findOrCreate ( { defaults : { actorId : serverActor . id , videoId : video . id , url : serverShareUrl } , where : { url : serverShareUrl } , transaction : t } ) return sendVideoAnnounce ( serverActor , serverShare , video , t ) } async function shareByVideoChannel ( video , t ) { const videoChannelShareUrl = getVideoAnnounceActivityPubUrl ( video . VideoChannel . Actor , video ) const [ videoChannelShare ] = await VideoShareModel . findOrCreate ( { defaults : { actorId : video . VideoChannel . actorId , videoId : video . id , url : videoChannelShareUrl } , where : { url : videoChannelShareUrl } , transaction : t } ) return sendVideoAnnounce ( video . VideoChannel . Actor , videoChannelShare , video , t ) } async function undoShareByVideoChannel ( video , oldVideoChannel , t ) { const oldShare = await VideoShareModel . load ( oldVideoChannel . actorId , video . id , t ) if ( ! oldShare ) return new Error ( 's' + oldVideoChannel . actorId + 's' + video . id ) await sendUndoAnnounce ( oldVideoChannel . Actor , oldShare , video , t ) await oldShare . destroy ( { transaction : t } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $MChannelActorLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $MChannelActorLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoModel } from 's' import * as Bluebird from 's' import { MVideoAccountLightBlacklistAllFiles , MVideoFullLight , MVideoIdThumbnail , MVideoThumbnail , MVideoWithRights } from 's' import { Response } from 's' type VideoFetchType = 's' | 's' | 's' | 's' | 's' function fetchVideo ( id : number | string , fetchType : 's' , userId ? ) < MVideoFullLight > function fetchVideo ( id : number | string , fetchType : 's' , userId ? ) < MVideoThumbnail > function fetchVideo ( id : number | string , fetchType : 's' , userId ? ) < MVideoWithRights > function fetchVideo ( id : number | string , fetchType : 's' | 's' , userId ? ) < MVideoIdThumbnail > function fetchVideo ( id : number | string , fetchType , userId ? ) < MVideoFullLight | MVideoThumbnail | MVideoWithRights | MVideoIdThumbnail > function fetchVideo ( id : number | string , fetchType , userId ? ) < MVideoFullLight | MVideoThumbnail | MVideoWithRights | MVideoIdThumbnail > { if ( fetchType === 's' ) return VideoModel . loadAndPopulateAccountAndServerAndTags ( id , undefined , userId ) if ( fetchType === 's' ) return VideoModel . loadWithRights ( id ) if ( fetchType === 's' ) return VideoModel . load ( id ) if ( fetchType === 's' || fetchType === 's' ) return VideoModel . loadOnlyId ( id ) } type VideoFetchByUrlType = 's' | 's' function fetchVideoByUrl ( url , fetchType : 's' ) < MVideoAccountLightBlacklistAllFiles > function fetchVideoByUrl ( url , fetchType : 's' ) < MVideoThumbnail > function fetchVideoByUrl ( url , fetchType ) < MVideoAccountLightBlacklistAllFiles | MVideoThumbnail > function fetchVideoByUrl ( url , fetchType ) < MVideoAccountLightBlacklistAllFiles | MVideoThumbnail > { if ( fetchType === 's' ) return VideoModel . loadByUrlAndPopulateAccount ( url ) if ( fetchType === 's' ) return VideoModel . loadByUrl ( url ) } function getVideo ( res ) { return res . locals . videoAll || res . locals . onlyVideo || res . locals . onlyVideoWithRights || res . locals . videoId } function getVideoWithAttributes ( res ) { return res . locals . videoAll || res . locals . onlyVideo || res . locals . onlyVideoWithRights } export { VideoFetchType , VideoFetchByUrlType , fetchVideo , getVideo , getVideoWithAttributes , fetchVideoByUrl }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O $number$ O O O O O $Bluebird$ O O O O O O O O O O O O $number$ O O O O O $Bluebird$ O O O O O O O O O O O O $number$ O O O O O $Bluebird$ O O O O O O O O O O O O O O $number$ O O O O O $Bluebird$ O O O O O O O $VideoFetchType$ O O $number$ O O O O O O O O O O O $Bluebird$ O O O O O O O $VideoFetchType$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O $Bluebird$ O $string$ O $VideoFetchByUrlType$ O O O O O O O $Bluebird$ O $string$ O $VideoFetchByUrlType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { Emailer , SendEmailOptions } from 's' export type EmailPayload = SendEmailOptions async function processEmail ( job : Bull . Job ) { const payload = job . data as EmailPayload logger . info ( 's' , job . id ) return Emailer . Instance . sendMail ( payload ) } export { processEmail }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { createTransport , Transporter } from 's' import { isTestInstance } from 's' import { bunyanLogger , logger } from 's' import { CONFIG } from 's' import { JobQueue } from 's' import { EmailPayload } from 's' import { readFileSync } from 's' import { WEBSERVER } from 's' import { MCommentOwnerVideo , MVideo , MVideoAbuseVideo , MVideoAccountLight , MVideoBlacklistLightVideo , MVideoBlacklistVideo } from 's' import { MActorFollowActors , MActorFollowFull , MUser } from 's' import { MVideoImport , MVideoImportVideo } from 's' type SendEmailOptions = { to : string [ ] subject : string text : string fromDisplayName ? : string replyTo ? : string } class Emailer { private static instance : Emailer private initialized = false private transporter : Transporter private constructor ( ) { } init ( ) { if ( this . initialized === true ) return this . initialized = true if ( Emailer . isEnabled ( ) ) { logger . info ( 's' , CONFIG . SMTP . HOSTNAME , CONFIG . SMTP . PORT ) let tls if ( CONFIG . SMTP . CA_FILE ) { tls = { ca : [ readFileSync ( CONFIG . SMTP . CA_FILE ) ] } } let auth if ( CONFIG . SMTP . USERNAME && CONFIG . SMTP . PASSWORD ) { auth = { user : CONFIG . SMTP . USERNAME , pass : CONFIG . SMTP . PASSWORD } } this . transporter = createTransport ( { host : CONFIG . SMTP . HOSTNAME , port : CONFIG . SMTP . PORT , secure : CONFIG . SMTP . TLS , debug : CONFIG . LOG . LEVEL === 's' , logger : bunyanLogger as any , ignoreTLS : CONFIG . SMTP . DISABLE_STARTTLS , tls , auth } ) } else { if ( ! isTestInstance ( ) ) { logger . error ( 's' ) } } } static isEnabled ( ) { return ! ! CONFIG . SMTP . HOSTNAME && ! ! CONFIG . SMTP . PORT } async checkConnectionOrDie ( ) { if ( ! this . transporter ) return logger . info ( 's' ) try { const success = await this . transporter . verify ( ) if ( success !== true ) this . dieOnConnectionFailure ( ) logger . info ( 's' ) } catch ( err ) { this . dieOnConnectionFailure ( err ) } } addNewVideoFromSubscriberNotification ( to : string [ ] , video ) { const channelName = video . VideoChannel . getDisplayName ( ) const videoUrl = WEBSERVER . URL + video . getWatchStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + channelName + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addNewFollowNotification ( to : string [ ] , actorFollow , followType : 's' | 's' ) { const followerName = actorFollow . ActorFollower . Account . getDisplayName ( ) const followingName = ( actorFollow . ActorFollowing . VideoChannel || actorFollow . ActorFollowing . Account ) . getDisplayName ( ) const text = `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' + followingName , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addNewInstanceFollowerNotification ( to : string [ ] , actorFollow ) { const awaitingApproval = actorFollow . state === 's' ? 's' : 's' const text = `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addAutoInstanceFollowingNotification ( to : string [ ] , actorFollow ) { const text = `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } myVideoPublishedNotification ( to : string [ ] , video ) { const videoUrl = WEBSERVER . URL + video . getWatchStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + `template` , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } myVideoImportSuccessNotification ( to : string [ ] , videoImport ) { const videoUrl = WEBSERVER . URL + videoImport . Video . getWatchStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + `template` , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } myVideoImportErrorNotification ( to : string [ ] , videoImport ) { const importUrl = WEBSERVER . URL + 's' const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + `template` , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addNewCommentOnMyVideoNotification ( to : string [ ] , comment ) { const accountName = comment . Account . getDisplayName ( ) const video = comment . Video const commentUrl = WEBSERVER . URL + comment . getCommentStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' + video . name , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addNewCommentMentionNotification ( to : string [ ] , comment ) { const accountName = comment . Account . getDisplayName ( ) const video = comment . Video const commentUrl = WEBSERVER . URL + comment . getCommentStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' + video . name , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addVideoAbuseModeratorsNotification ( to : string [ ] , videoAbuse ) { const videoUrl = WEBSERVER . URL + videoAbuse . Video . getWatchStaticPath ( ) const text = `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addVideoAutoBlacklistModeratorsNotification ( to : string [ ] , videoBlacklist ) { const VIDEO_AUTO_BLACKLIST_URL = WEBSERVER . URL + 's' const videoUrl = WEBSERVER . URL + videoBlacklist . Video . getWatchStaticPath ( ) const text = `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addNewUserRegistrationNotification ( to : string [ ] , user ) { const text = `template` + `template` + `template` + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' + WEBSERVER . HOST , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addVideoBlacklistNotification ( to : string [ ] , videoBlacklist ) { const videoName = videoBlacklist . Video . name const videoUrl = WEBSERVER . URL + videoBlacklist . Video . getWatchStaticPath ( ) const reasonString = videoBlacklist . reason ? `template` : 's' const blockedString = `template` const text = 's' + blockedString + 's' + 's' + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + `template` , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addVideoUnblacklistNotification ( to : string [ ] , video ) { const videoUrl = WEBSERVER . URL + video . getWatchStaticPath ( ) const text = 's' + `template` + 's' + 's' + `template` const emailPayload = { to , subject : CONFIG . EMAIL . SUBJECT . PREFIX + `template` , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addPasswordResetEmailJob ( to , resetPasswordUrl ) { const text = `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to : [ to ] , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addVerifyEmailJob ( to , verifyEmailUrl ) { const text = `template` + `template` + `template` + `template` + `template` + `template` const emailPayload = { to : [ to ] , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addUserBlockJob ( user , blocked , reason ? ) { const reasonString = reason ? `template` : 's' const blockedWord = blocked ? 's' : 's' const blockedString = `template` const text = 's' + blockedString + 's' + 's' + `template` const to = user . email const emailPayload = { to : [ to ] , subject : CONFIG . EMAIL . SUBJECT . PREFIX + 's' + blockedWord , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } addContactFormJob ( fromEmail , fromName , subject , body ) { const text = 's' + fromName + 's' + 's' + body + 's' + 's' + 's' const emailPayload = { fromDisplayName : fromEmail , replyTo : fromEmail , to : [ CONFIG . ADMIN . EMAIL ] , subject : CONFIG . EMAIL . SUBJECT . PREFIX + subject , text } return JobQueue . Instance . createJob ( { type : 's' , payload : emailPayload } ) } sendMail ( options ) { if ( ! Emailer . isEnabled ( ) ) { throw new Error ( 's' ) } const fromDisplayName = options . fromDisplayName ? options . fromDisplayName : WEBSERVER . HOST return this . transporter . sendMail ( { from : `template` , replyTo : options . replyTo , to : options . to . join ( 's' ) , subject : options . subject , text : options . text } ) } private dieOnConnectionFailure ( err ? ) { logger . error ( 's' , CONFIG . SMTP . HOSTNAME , CONFIG . SMTP . PORT , { err } ) process . exit ( - 0 ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { Emailer , SendEmailOptions }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoImportVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoImport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAbuseVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoBlacklistLightVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoBlacklistVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O $boolean$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EmailPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , Default , ForeignKey , Is , Model , Scopes , Table , UpdatedAt } from 's' import { UserNotification , UserNotificationType } from 's' import { getSort , throwIfNotValid } from 's' import { isBooleanValid } from 's' import { isUserNotificationTypeValid } from 's' import { UserModel } from 's' import { VideoModel } from 's' import { VideoCommentModel } from 's' import { FindOptions , ModelIndexesOptions , Op , WhereOptions } from 's' import { VideoChannelModel } from 's' import { AccountModel } from 's' import { VideoAbuseModel } from 's' import { VideoBlacklistModel } from 's' import { VideoImportModel } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { AvatarModel } from 's' import { ServerModel } from 's' import { UserNotificationIncludes , UserNotificationModelForApi } from 's' enum ScopeNames { WITH_ALL = 's' } function buildActorWithAvatarInclude ( ) { return { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : AvatarModel . unscoped ( ) , required : false } , { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } ] } } function buildVideoInclude ( required ) { return { attributes : [ 's' , 's' , 's' ] , model : VideoModel . unscoped ( ) , required } } function buildChannelInclude ( required , withActor = false ) { return { required , attributes : [ 's' , 's' ] , model : VideoChannelModel . unscoped ( ) , include : withActor === true ? [ buildActorWithAvatarInclude ( ) ] : [ ] } } function buildAccountInclude ( required , withActor = false ) { return { required , attributes : [ 's' , 's' ] , model : AccountModel . unscoped ( ) , include : withActor === true ? [ buildActorWithAvatarInclude ( ) ] : [ ] } } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_ALL ] : { include : [ Object . assign ( buildVideoInclude ( false ) , { include : [ buildChannelInclude ( true , true ) ] } ) , { attributes : [ 's' , 's' ] , model : VideoCommentModel . unscoped ( ) , required : false , include : [ buildAccountInclude ( true , true ) , buildVideoInclude ( true ) ] } , { attributes : [ 's' ] , model : VideoAbuseModel . unscoped ( ) , required : false , include : [ buildVideoInclude ( true ) ] } , { attributes : [ 's' ] , model : VideoBlacklistModel . unscoped ( ) , required : false , include : [ buildVideoInclude ( true ) ] } , { attributes : [ 's' , 's' , 's' , 's' ] , model : VideoImportModel . unscoped ( ) , required : false , include : [ buildVideoInclude ( false ) ] } , { attributes : [ 's' , 's' ] , model : ActorFollowModel . unscoped ( ) , required : false , include : [ { attributes : [ 's' ] , model : ActorModel . unscoped ( ) , required : true , as : 's' , include : [ { attributes : [ 's' , 's' ] , model : AccountModel . unscoped ( ) , required : true } , { attributes : [ 's' ] , model : AvatarModel . unscoped ( ) , required : false } , { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } ] } , { attributes : [ 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true , as : 's' , include : [ buildChannelInclude ( false ) , buildAccountInclude ( false ) , { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } ] } ] } , buildAccountInclude ( false , true ) ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] , where : { videoId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { commentId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { videoAbuseId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { videoBlacklistId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { videoImportId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { accountId : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { actorFollowId : { [ Op . ne ] : null } } } ] as ( ModelIndexesOptions & { where ? : WhereOptions } ) [ ] } ) export class UserNotificationModel extends Model < UserNotificationModel > { @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNotificationTypeValid , 's' ) ) @ Column type : UserNotificationType @ AllowNull ( false ) @ Default ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isBooleanValid , 's' ) ) @ Column read : boolean @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) User : UserModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Video : VideoModel @ ForeignKey ( ( ) => VideoCommentModel ) @ Column commentId : number @ BelongsTo ( ( ) => VideoCommentModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Comment : VideoCommentModel @ ForeignKey ( ( ) => VideoAbuseModel ) @ Column videoAbuseId : number @ BelongsTo ( ( ) => VideoAbuseModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoAbuse : VideoAbuseModel @ ForeignKey ( ( ) => VideoBlacklistModel ) @ Column videoBlacklistId : number @ BelongsTo ( ( ) => VideoBlacklistModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoBlacklist : VideoBlacklistModel @ ForeignKey ( ( ) => VideoImportModel ) @ Column videoImportId : number @ BelongsTo ( ( ) => VideoImportModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoImport : VideoImportModel @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Account : AccountModel @ ForeignKey ( ( ) => ActorFollowModel ) @ Column actorFollowId : number @ BelongsTo ( ( ) => ActorFollowModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) ActorFollow : ActorFollowModel static listForApi ( userId , start , count , sort , unread ? ) { const query = { offset : start , limit : count , order : getSort ( sort ) , where : { userId } } if ( unread !== undefined ) query . where [ 's' ] = ! unread return UserNotificationModel . scope ( ScopeNames . WITH_ALL ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } static markAsRead ( userId , notificationIds : number [ ] ) { const query = { where : { userId , id : { [ Op . in ] : notificationIds } } } return UserNotificationModel . update ( { read : true } , query ) } static markAllAsRead ( userId ) { const query = { where : { userId } } return UserNotificationModel . update ( { read : true } , query ) } toFormattedJSON ( this ) { const video = this . Video ? Object . assign ( this . formatVideo ( this . Video ) , { channel : this . formatActor ( this . Video . VideoChannel ) } ) : undefined const videoImport = this . VideoImport ? { id : this . VideoImport . id , video : this . VideoImport . Video ? this . formatVideo ( this . VideoImport . Video ) : undefined , torrentName : this . VideoImport . torrentName , magnetUri : this . VideoImport . magnetUri , targetUrl : this . VideoImport . targetUrl } : undefined const comment = this . Comment ? { id : this . Comment . id , threadId : this . Comment . getThreadId ( ) , account : this . formatActor ( this . Comment . Account ) , video : this . formatVideo ( this . Comment . Video ) } : undefined const videoAbuse = this . VideoAbuse ? { id : this . VideoAbuse . id , video : this . formatVideo ( this . VideoAbuse . Video ) } : undefined const videoBlacklist = this . VideoBlacklist ? { id : this . VideoBlacklist . id , video : this . formatVideo ( this . VideoBlacklist . Video ) } : undefined const account = this . Account ? this . formatActor ( this . Account ) : undefined const actorFollowingType = { Application : 's' as 's' , Group : 's' as 's' , Person : 's' as 's' } const actorFollow = this . ActorFollow ? { id : this . ActorFollow . id , state : this . ActorFollow . state , follower : { id : this . ActorFollow . ActorFollower . Account . id , displayName : this . ActorFollow . ActorFollower . Account . getDisplayName ( ) , name : this . ActorFollow . ActorFollower . preferredUsername , avatar : this . ActorFollow . ActorFollower . Avatar ? { path : this . ActorFollow . ActorFollower . Avatar . getStaticPath ( ) } : undefined , host : this . ActorFollow . ActorFollower . getHost ( ) } , following : { type : actorFollowingType [ this . ActorFollow . ActorFollowing . type ] , displayName : ( this . ActorFollow . ActorFollowing . VideoChannel || this . ActorFollow . ActorFollowing . Account ) . getDisplayName ( ) , name : this . ActorFollow . ActorFollowing . preferredUsername , host : this . ActorFollow . ActorFollowing . getHost ( ) } } : undefined return { id : this . id , type : this . type , read : this . read , video , videoImport , comment , videoAbuse , videoBlacklist , account , actorFollow , createdAt : this . createdAt . toISOString ( ) , updatedAt : this . updatedAt . toISOString ( ) } } formatVideo ( this , video : UserNotificationIncludes . VideoInclude ) { return { id : video . id , uuid : video . uuid , name : video . name } } formatActor ( this , accountOrChannel : UserNotificationIncludes . AccountIncludeActor | UserNotificationIncludes . VideoChannelIncludeActor ) { const avatar = accountOrChannel . Actor . Avatar ? { path : accountOrChannel . Actor . Avatar . getStaticPath ( ) } : undefined return { id : accountOrChannel . id , displayName : accountOrChannel . getDisplayName ( ) , name : accountOrChannel . Actor . preferredUsername , host : accountOrChannel . Actor . getHost ( ) , avatar } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O $boolean$ O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O $UserNotificationModelForApi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationModelForApi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationModelForApi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { query , validationResult } from 's' import { logger } from 's' function areValidationErrors ( req : express . Request , res : express . Response ) { const errors = validationResult ( req ) if ( ! errors . isEmpty ( ) ) { logger . warn ( 's' , { path : req . originalUrl , err : errors . mapped ( ) } ) res . status ( 0 ) . json ( { errors : errors . mapped ( ) } ) return true } return false } function checkSort ( sortableColumns : string [ ] ) { return [ query ( 's' ) . optional ( ) . isIn ( sortableColumns ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] } function createSortableColumns ( sortableColumns : string [ ] ) { const sortableColumnDesc = sortableColumns . map ( sortableColumn => 's' + sortableColumn ) return sortableColumns . concat ( sortableColumnDesc ) } export { areValidationErrors , checkSort , createSortableColumns }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { AccountModel } from 's' import * as Bluebird from 's' import { MAccountDefault } from 's' function doesAccountIdExist ( id , res , sendNotFound = true ) { const promise = AccountModel . load ( id ) return doesAccountExist ( promise , res , sendNotFound ) } function doesLocalAccountNameExist ( name , res , sendNotFound = true ) { const promise = AccountModel . loadLocalByName ( name ) return doesAccountExist ( promise , res , sendNotFound ) } function doesAccountNameWithHostExist ( nameWithDomain , res , sendNotFound = true ) { const promise = AccountModel . loadByNameWithHost ( nameWithDomain ) return doesAccountExist ( promise , res , sendNotFound ) } async function doesAccountExist ( p < MAccountDefault > , res , sendNotFound ) { const account = await p if ( ! account ) { if ( sendNotFound === true ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } return false } res . locals . account = account return true } export { doesAccountIdExist , doesLocalAccountNameExist , doesAccountNameWithHostExist , doesAccountExist }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O $Response$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { VideoAbuseModel } from 's' async function doesVideoAbuseExist ( abuseId , videoId , res ) { const videoAbuse = await VideoAbuseModel . loadByIdAndVideoId ( abuseId , videoId ) if ( videoAbuse === null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoAbuse = videoAbuse return true } export { doesVideoAbuseExist }	O O O O O O O O O O O O O O O O $number$ O $number$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { VideoBlacklistModel } from 's' async function doesVideoBlacklistExist ( videoId , res ) { const videoBlacklist = await VideoBlacklistModel . loadByVideoId ( videoId ) if ( videoBlacklist === null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoBlacklist = videoBlacklist return true } export { doesVideoBlacklistExist }	O O O O O O O O O O O O O O O O $number$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { VideoCaptionModel } from 's' import { MVideoId } from 's' async function doesVideoCaptionExist ( video , language , res ) { const videoCaption = await VideoCaptionModel . loadByVideoIdAndLanguage ( video . id , language ) if ( ! videoCaption ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoCaption = videoCaption return true } export { doesVideoCaptionExist }	O O O O O O O O O O O O O O O O O O O O O O $MVideoId$ O $string$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { VideoChannelModel } from 's' import { MChannelAccountDefault } from 's' async function doesLocalVideoChannelNameExist ( name , res : express . Response ) { const videoChannel = await VideoChannelModel . loadLocalByNameAndPopulateAccount ( name ) return processVideoChannelExist ( videoChannel , res ) } async function doesVideoChannelIdExist ( id , res : express . Response ) { const videoChannel = await VideoChannelModel . loadAndPopulateAccount ( + id ) return processVideoChannelExist ( videoChannel , res ) } async function doesVideoChannelNameWithHostExist ( nameWithDomain , res : express . Response ) { const videoChannel = await VideoChannelModel . loadByNameWithHostAndPopulateAccount ( nameWithDomain ) return processVideoChannelExist ( videoChannel , res ) } export { doesLocalVideoChannelNameExist , doesVideoChannelIdExist , doesVideoChannelNameWithHostExist } function processVideoChannelExist ( videoChannel , res : express . Response ) { if ( ! videoChannel ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoChannel = videoChannel return true }	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MChannelAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { VideoPlaylistModel } from 's' import { MVideoPlaylist } from 's' export type VideoPlaylistFetchType = 's' | 's' async function doesVideoPlaylistExist ( id : number | string , res : express . Response , fetchType = 's' ) { if ( fetchType === 's' ) { const videoPlaylist = await VideoPlaylistModel . loadWithAccountAndChannelSummary ( id , undefined ) res . locals . videoPlaylistSummary = videoPlaylist return handleVideoPlaylist ( videoPlaylist , res ) } const videoPlaylist = await VideoPlaylistModel . loadWithAccountAndChannel ( id , undefined ) res . locals . videoPlaylistFull = videoPlaylist return handleVideoPlaylist ( videoPlaylist , res ) } export { doesVideoPlaylistExist } function handleVideoPlaylist ( videoPlaylist , res : express . Response ) { if ( ! videoPlaylist ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistFetchType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { fetchVideo , VideoFetchType } from 's' import { UserRight } from 's' import { VideoChannelModel } from 's' import { MUser , MUserAccountId , MVideoAccountLight , MVideoFullLight , MVideoThumbnail , MVideoWithRights } from 's' async function doesVideoExist ( id : number | string , res , fetchType = 's' ) { const userId = res . locals . oauth ? res . locals . oauth . token . User . id : undefined const video = await fetchVideo ( id , fetchType , userId ) if ( video === null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } switch ( fetchType ) { case 's' : res . locals . videoAll = video as MVideoFullLight break case 's' : res . locals . videoId = video break case 's' : res . locals . onlyVideo = video as MVideoThumbnail break case 's' : res . locals . onlyVideoWithRights = video as MVideoWithRights break } return true } async function doesVideoChannelOfAccountExist ( channelId , user , res ) { if ( user . hasRight ( UserRight . UPDATE_ANY_VIDEO ) === true ) { const videoChannel = await VideoChannelModel . loadAndPopulateAccount ( channelId ) if ( videoChannel === null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoChannel = videoChannel return true } const videoChannel = await VideoChannelModel . loadByIdAndAccount ( channelId , user . Account . id ) if ( videoChannel === null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoChannel = videoChannel return true } function checkUserCanManageVideo ( user , video , right , res ) { if ( video . isOwned ( ) === false ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } const account = video . VideoChannel . Account if ( user . hasRight ( right ) === false && account . userId !== user . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true } export { doesVideoChannelOfAccountExist , doesVideoExist , checkUserCanManageVideo }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Response$ O $VideoFetchType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $MUserAccountId$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O $MVideoAccountLight$ O $UserRight$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { param } from 's' import { isAccountNameValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { doesAccountNameWithHostExist , doesLocalAccountNameExist } from 's' const localAccountValidator = [ param ( 's' ) . custom ( isAccountNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesLocalAccountNameExist ( req . params . name , res ) ) return return next ( ) } ] const accountNameWithHostGetValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesAccountNameWithHostExist ( req . params . accountName , res ) ) return return next ( ) } ] export { localAccountValidator , accountNameWithHostGetValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BelongsTo , Column , CreatedAt , ForeignKey , Model , Scopes , Table , UpdatedAt } from 's' import { AccountModel } from 's' import { getSort } from 's' import { AccountBlock } from 's' import { Op } from 's' import * as Bluebird from 's' import { MAccountBlocklist , MAccountBlocklistAccounts , MAccountBlocklistFormattable } from 's' enum ScopeNames { WITH_ACCOUNTS = 's' } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_ACCOUNTS ] : { include : [ { model : AccountModel , required : true , as : 's' } , { model : AccountModel , required : true , as : 's' } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] } ] } ) export class AccountBlocklistModel extends Model < AccountBlocklistModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) ByAccount : AccountModel @ ForeignKey ( ( ) => AccountModel ) @ Column targetAccountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) BlockedAccount : AccountModel static isAccountMutedBy ( accountId , targetAccountId ) { return AccountBlocklistModel . isAccountMutedByMulti ( [ accountId ] , targetAccountId ) . then ( result => result [ accountId ] ) } static isAccountMutedByMulti ( accountIds : number [ ] , targetAccountId ) { const query = { attributes : [ 's' , 's' ] , where : { accountId : { [ Op . in ] : accountIds } , targetAccountId } , raw : true } return AccountBlocklistModel . unscoped ( ) . findAll ( query ) . then ( rows => { const result : { [ accountId ] : boolean } = { } for ( const accountId of accountIds ) { result [ accountId ] = ! ! rows . find ( r => r . accountId === accountId ) } return result } ) } static loadByAccountAndTarget ( accountId , targetAccountId ) < MAccountBlocklist > { const query = { where : { accountId , targetAccountId } } return AccountBlocklistModel . findOne ( query ) } static listForApi ( accountId , start , count , sort ) { const query = { offset : start , limit : count , order : getSort ( sort ) , where : { accountId } } return AccountBlocklistModel . scope ( [ ScopeNames . WITH_ACCOUNTS ] ) . findAndCountAll < MAccountBlocklistAccounts > ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } toFormattedJSON ( this ) { return { byAccount : this . ByAccount . toFormattedJSON ( ) , blockedAccount : this . BlockedAccount . toFormattedJSON ( ) , createdAt : this . createdAt } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountBlock$ O $MAccountBlocklistFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { body , param } from 's' import * as express from 's' import { logger } from 's' import { areValidationErrors } from 's' import { AccountBlocklistModel } from 's' import { isHostValid } from 's' import { ServerBlocklistModel } from 's' import { ServerModel } from 's' import { getServerActor } from 's' import { WEBSERVER } from 's' import { doesAccountNameWithHostExist } from 's' const blockAccountValidator = [ body ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesAccountNameWithHostExist ( req . body . accountName , res ) ) return const user = res . locals . oauth . token . User const accountToBlock = res . locals . account if ( user . Account . id === accountToBlock . id ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) return } return next ( ) } ] const unblockAccountByAccountValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesAccountNameWithHostExist ( req . params . accountName , res ) ) return const user = res . locals . oauth . token . User const targetAccount = res . locals . account if ( ! await doesUnblockAccountExist ( user . Account . id , targetAccount . id , res ) ) return return next ( ) } ] const unblockAccountByServerValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesAccountNameWithHostExist ( req . params . accountName , res ) ) return const serverActor = await getServerActor ( ) const targetAccount = res . locals . account if ( ! await doesUnblockAccountExist ( serverActor . Account . id , targetAccount . id , res ) ) return return next ( ) } ] const blockServerValidator = [ body ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const host = req . body . host if ( host === WEBSERVER . HOST ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } const server = await ServerModel . loadByHost ( host ) if ( ! server ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } res . locals . server = server return next ( ) } ] const unblockServerByAccountValidator = [ param ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const user = res . locals . oauth . token . User if ( ! await doesUnblockServerExist ( user . Account . id , req . params . host , res ) ) return return next ( ) } ] const unblockServerByServerValidator = [ param ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const serverActor = await getServerActor ( ) if ( ! await doesUnblockServerExist ( serverActor . Account . id , req . params . host , res ) ) return return next ( ) } ] export { blockServerValidator , blockAccountValidator , unblockAccountByAccountValidator , unblockServerByAccountValidator , unblockAccountByServerValidator , unblockServerByServerValidator } async function doesUnblockAccountExist ( accountId , targetAccountId , res : express . Response ) { const accountBlock = await AccountBlocklistModel . loadByAccountAndTarget ( accountId , targetAccountId ) if ( ! accountBlock ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) return false } res . locals . accountBlock = accountBlock return true } async function doesUnblockServerExist ( accountId , host , res : express . Response ) { const serverBlock = await ServerBlocklistModel . loadByAccountAndHost ( accountId , host ) if ( ! serverBlock ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) return false } res . locals . serverBlock = serverBlock return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { query } from 's' import { join } from 's' import { isTestInstance } from 's' import { isIdOrUUIDValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { WEBSERVER } from 's' import { doesVideoExist } from 's' const urlShouldStartWith = WEBSERVER . SCHEME + 's' + join ( WEBSERVER . HOST , 's' , 's' ) + 's' const videoWatchRegex = new RegExp ( 's' ) const isURLOptions = { require_host : true , require_tld : true } if ( isTestInstance ( ) ) { isURLOptions . require_tld = false } const oembedValidator = [ query ( 's' ) . isURL ( isURLOptions ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isInt ( ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isInt ( ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isIn ( [ 's' , 's' ] ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return if ( req . query . format !== undefined && req . query . format !== 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } const startIsOk = req . query . url . startsWith ( urlShouldStartWith ) const matches = videoWatchRegex . exec ( req . query . url ) if ( startIsOk === false || matches === null ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } const videoId = matches [ 0 ] if ( isIdOrUUIDValid ( videoId ) === false ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } if ( ! await doesVideoExist ( videoId , res ) ) return return next ( ) } ] export { oembedValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isActivityPubUrlValid , isObjectValid } from 's' function isDislikeActivityValid ( activity ) { return activity . type === 's' && isActivityPubUrlValid ( activity . actor ) && isObjectValid ( activity . object ) } export { isDislikeActivityValid }	O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isActivityPubUrlValid } from 's' function isViewActivityValid ( activity ) { return activity . type === 's' && isActivityPubUrlValid ( activity . actor ) && isActivityPubUrlValid ( activity . object ) } export { isViewActivityValid }	O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isActivityPubUrlValid } from 's' import { isRemoteVideoUrlValid } from 's' import { exists , isDateValid } from 's' import { CacheFileObject } from 's' function isCacheFileObjectValid ( object ) { return exists ( object ) && object . type === 's' && isDateValid ( object . expires ) && isActivityPubUrlValid ( object . object ) && ( isRemoteVideoUrlValid ( object . url ) || isPlaylistRedundancyUrlValid ( object . url ) ) } export { isCacheFileObjectValid } function isPlaylistRedundancyUrlValid ( url ) { return url . type === 's' && ( url . mediaType || url . mimeType ) === 's' && isActivityPubUrlValid ( url . href ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isActivityPubUrlValid } from 's' import { isVideoAbuseReasonValid } from 's' function isFlagActivityValid ( activity ) { return activity . type === 's' && isVideoAbuseReasonValid ( activity . content ) && isActivityPubUrlValid ( activity . object ) } export { isFlagActivityValid }	O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exists , isDateValid } from 's' import { PlaylistObject } from 's' import * as validator from 's' import { PlaylistElementObject } from 's' import { isActivityPubUrlValid } from 's' function isPlaylistObjectValid ( object ) { return exists ( object ) && object . type === 's' && validator . isInt ( object . totalItems + 's' ) && isDateValid ( object . published ) && isDateValid ( object . updated ) } function isPlaylistElementObjectValid ( object ) { return exists ( object ) && object . type === 's' && validator . isInt ( object . position + 's' ) && isActivityPubUrlValid ( object . url ) } export { isPlaylistObjectValid , isPlaylistElementObjectValid }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistElementObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { Activity , ActivityType } from 's' import { sanitizeAndCheckActorObject } from 's' import { isActivityPubUrlValid , isBaseActivityValid , isObjectValid } from 's' import { isDislikeActivityValid } from 's' import { sanitizeAndCheckVideoCommentObject } from 's' import { sanitizeAndCheckVideoTorrentObject } from 's' import { isViewActivityValid } from 's' import { exists } from 's' import { isCacheFileObjectValid } from 's' import { isFlagActivityValid } from 's' import { isPlaylistObjectValid } from 's' function isRootActivityValid ( activity ) { return isCollection ( activity ) || isActivity ( activity ) } function isCollection ( activity ) { return ( activity . type === 's' || activity . type === 's' ) && validator . isInt ( activity . totalItems , { min : 0 } ) && Array . isArray ( activity . items ) } function isActivity ( activity ) { return isActivityPubUrlValid ( activity . id ) && exists ( activity . actor ) && ( isActivityPubUrlValid ( activity . actor ) || isActivityPubUrlValid ( activity . actor . id ) ) } const activityCheckers : { [ P in ActivityType ] : ( activity ) => boolean } = { Create : checkCreateActivity , Update : checkUpdateActivity , Delete : checkDeleteActivity , Follow : checkFollowActivity , Accept : checkAcceptActivity , Reject : checkRejectActivity , Announce : checkAnnounceActivity , Undo : checkUndoActivity , Like : checkLikeActivity , View : checkViewActivity , Flag : checkFlagActivity , Dislike : checkDislikeActivity } function isActivityValid ( activity ) { const checker = activityCheckers [ activity . type ] if ( ! checker ) return false return checker ( activity ) } export { isRootActivityValid , isActivityValid } function checkViewActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isViewActivityValid ( activity ) } function checkFlagActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isFlagActivityValid ( activity ) } function checkDislikeActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isDislikeActivityValid ( activity ) } function checkCreateActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && ( isViewActivityValid ( activity . object ) || isDislikeActivityValid ( activity . object ) || isFlagActivityValid ( activity . object ) || isPlaylistObjectValid ( activity . object ) || isCacheFileObjectValid ( activity . object ) || sanitizeAndCheckVideoCommentObject ( activity . object ) || sanitizeAndCheckVideoTorrentObject ( activity . object ) ) } function checkUpdateActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && ( isCacheFileObjectValid ( activity . object ) || isPlaylistObjectValid ( activity . object ) || sanitizeAndCheckVideoTorrentObject ( activity . object ) || sanitizeAndCheckActorObject ( activity . object ) ) } function checkDeleteActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isObjectValid ( activity . object ) } function checkFollowActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isObjectValid ( activity . object ) } function checkAcceptActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) } function checkRejectActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) } function checkAnnounceActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isObjectValid ( activity . object ) } function checkUndoActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && ( checkFollowActivity ( activity . object ) || checkLikeActivity ( activity . object ) || checkDislikeActivity ( activity . object ) || checkAnnounceActivity ( activity . object ) || checkCreateActivity ( activity . object ) ) } function checkLikeActivity ( activity ) { return isBaseActivityValid ( activity , 's' ) && isObjectValid ( activity . object ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Activity$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O
import * as express from 's' import { isRootActivityValid } from 's' import { logger } from 's' import { getServerActor } from 's' async function activityPubValidator ( req : express . Request , res : express . Response , next : express . NextFunction ) { logger . debug ( 's' ) if ( ! isRootActivityValid ( req . body ) ) { logger . warn ( 's' , { activity : req . body } ) return res . status ( 0 ) . json ( { error : 's' } ) } const serverActor = await getServerActor ( ) const remoteActor = res . locals . signature . actor if ( serverActor . id === remoteActor . id ) { logger . error ( 's' , req . body ) return res . status ( 0 ) . end ( ) } return next ( ) } export { activityPubValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exists } from 's' import { isActivityPubUrlValid } from 's' function isSignatureTypeValid ( signatureType ) { return exists ( signatureType ) && signatureType === 's' } function isSignatureCreatorValid ( signatureCreator ) { return exists ( signatureCreator ) && isActivityPubUrlValid ( signatureCreator ) } function isSignatureValueValid ( signatureValue ) { return exists ( signatureValue ) && signatureValue . length > 0 } export { isSignatureTypeValid , isSignatureCreatorValid , isSignatureValueValid }	O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body } from 's' import { isSignatureCreatorValid , isSignatureTypeValid , isSignatureValueValid } from 's' import { isDateValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' const signatureValidator = [ body ( 's' ) . optional ( ) . custom ( isSignatureTypeValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isSignatureCreatorValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isSignatureValueValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : { signature : req . body . signature } } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { signatureValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's'	O O O O O O O O
import * as express from 's' import { query } from 's' import { logger } from 's' import { areValidationErrors } from 's' const paginationValidator = [ query ( 's' ) . optional ( ) . isInt ( { min : 0 } ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isInt ( { min : 0 } ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { paginationValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param } from 's' import { isTestInstance } from 's' import { isEachUniqueHostValid , isHostValid } from 's' import { logger } from 's' import { getServerActor } from 's' import { SERVER_ACTOR_NAME , WEBSERVER } from 's' import { ActorFollowModel } from 's' import { areValidationErrors } from 's' import { ActorModel } from 's' import { loadActorUrlOrGetFromWebfinger } from 's' import { isValidActorHandle } from 's' import { MActorFollowActorsDefault } from 's' const followValidator = [ body ( 's' ) . custom ( isEachUniqueHostValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { if ( isTestInstance ( ) === false && WEBSERVER . SCHEME === 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const removeFollowingValidator = [ param ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const serverActor = await getServerActor ( ) const follow = await ActorFollowModel . loadByActorAndTargetNameAndHostForAPI ( serverActor . id , SERVER_ACTOR_NAME , req . params . host ) if ( ! follow ) { return res . status ( 0 ) . json ( { error : `template` } ) . end ( ) } res . locals . follow = follow return next ( ) } ] const getFollowerValidator = [ param ( 's' ) . custom ( isValidActorHandle ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return let follow try { const actorUrl = await loadActorUrlOrGetFromWebfinger ( req . params . nameWithHost ) const actor = await ActorModel . loadByUrl ( actorUrl ) const serverActor = await getServerActor ( ) follow = await ActorFollowModel . loadByActorAndTarget ( actor . id , serverActor . id ) } catch ( err ) { logger . warn ( 's' , { handle : req . params . nameWithHost , err } ) } if ( ! follow ) { return res . status ( 0 ) . json ( { error : `template` } ) . end ( ) } res . locals . follow = follow return next ( ) } ] const acceptOrRejectFollowerValidator = [ ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) const follow = res . locals . follow if ( follow . state !== 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] export { followValidator , removeFollowingValidator , getFollowerValidator , acceptOrRejectFollowerValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActorsDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exists } from 's' function isValidRSSFeed ( value ) { if ( ! exists ( value ) ) return false const feedExtensions = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] return feedExtensions . indexOf ( value ) !== - 0 } export { isValidRSSFeed }	O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { param , query } from 's' import { isIdOrUUIDValid , isIdValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isValidRSSFeed } from 's' import { doesVideoExist } from 's' import { doesAccountIdExist , doesAccountNameWithHostExist , doesVideoChannelIdExist , doesVideoChannelNameWithHostExist } from 's' const videoFeedsValidator = [ param ( 's' ) . optional ( ) . custom ( isValidRSSFeed ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isValidRSSFeed ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isIdValid ) , query ( 's' ) . optional ( ) , query ( 's' ) . optional ( ) . custom ( isIdValid ) , query ( 's' ) . optional ( ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return if ( req . query . accountId && ! await doesAccountIdExist ( req . query . accountId , res ) ) return if ( req . query . videoChannelId && ! await doesVideoChannelIdExist ( req . query . videoChannelId , res ) ) return if ( req . query . accountName && ! await doesAccountNameWithHostExist ( req . query . accountName , res ) ) return if ( req . query . videoChannelName && ! await doesVideoChannelNameWithHostExist ( req . query . videoChannelName , res ) ) return return next ( ) } ] const videoCommentsFeedsValidator = [ param ( 's' ) . optional ( ) . custom ( isValidRSSFeed ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isValidRSSFeed ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isIdOrUUIDValid ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return if ( req . query . videoId && ! await doesVideoExist ( req . query . videoId , res ) ) return return next ( ) } ] export { videoFeedsValidator , videoCommentsFeedsValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { SORTABLE_COLUMNS } from 's' import { checkSort , createSortableColumns } from 's' const SORTABLE_USERS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . USERS ) const SORTABLE_ACCOUNTS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . ACCOUNTS ) const SORTABLE_JOBS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . JOBS ) const SORTABLE_VIDEO_ABUSES_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_ABUSES ) const SORTABLE_VIDEOS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEOS ) const SORTABLE_VIDEOS_SEARCH_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEOS_SEARCH ) const SORTABLE_VIDEO_CHANNELS_SEARCH_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_CHANNELS_SEARCH ) const SORTABLE_VIDEO_IMPORTS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_IMPORTS ) const SORTABLE_VIDEO_COMMENT_THREADS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_COMMENT_THREADS ) const SORTABLE_VIDEO_RATES_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_RATES ) const SORTABLE_BLACKLISTS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . BLACKLISTS ) const SORTABLE_VIDEO_CHANNELS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_CHANNELS ) const SORTABLE_FOLLOWERS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . FOLLOWERS ) const SORTABLE_FOLLOWING_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . FOLLOWING ) const SORTABLE_USER_SUBSCRIPTIONS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . USER_SUBSCRIPTIONS ) const SORTABLE_ACCOUNTS_BLOCKLIST_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . ACCOUNTS_BLOCKLIST ) const SORTABLE_SERVERS_BLOCKLIST_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . SERVERS_BLOCKLIST ) const SORTABLE_USER_NOTIFICATIONS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . USER_NOTIFICATIONS ) const SORTABLE_VIDEO_PLAYLISTS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . VIDEO_PLAYLISTS ) const SORTABLE_PLUGINS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . PLUGINS ) const SORTABLE_AVAILABLE_PLUGINS_COLUMNS = createSortableColumns ( SORTABLE_COLUMNS . AVAILABLE_PLUGINS ) const usersSortValidator = checkSort ( SORTABLE_USERS_COLUMNS ) const accountsSortValidator = checkSort ( SORTABLE_ACCOUNTS_COLUMNS ) const jobsSortValidator = checkSort ( SORTABLE_JOBS_COLUMNS ) const videoAbusesSortValidator = checkSort ( SORTABLE_VIDEO_ABUSES_COLUMNS ) const videosSortValidator = checkSort ( SORTABLE_VIDEOS_COLUMNS ) const videoImportsSortValidator = checkSort ( SORTABLE_VIDEO_IMPORTS_COLUMNS ) const videosSearchSortValidator = checkSort ( SORTABLE_VIDEOS_SEARCH_COLUMNS ) const videoChannelsSearchSortValidator = checkSort ( SORTABLE_VIDEO_CHANNELS_SEARCH_COLUMNS ) const videoCommentThreadsSortValidator = checkSort ( SORTABLE_VIDEO_COMMENT_THREADS_COLUMNS ) const videoRatesSortValidator = checkSort ( SORTABLE_VIDEO_RATES_COLUMNS ) const blacklistSortValidator = checkSort ( SORTABLE_BLACKLISTS_COLUMNS ) const videoChannelsSortValidator = checkSort ( SORTABLE_VIDEO_CHANNELS_COLUMNS ) const followersSortValidator = checkSort ( SORTABLE_FOLLOWERS_COLUMNS ) const followingSortValidator = checkSort ( SORTABLE_FOLLOWING_COLUMNS ) const userSubscriptionsSortValidator = checkSort ( SORTABLE_USER_SUBSCRIPTIONS_COLUMNS ) const accountsBlocklistSortValidator = checkSort ( SORTABLE_ACCOUNTS_BLOCKLIST_COLUMNS ) const serversBlocklistSortValidator = checkSort ( SORTABLE_SERVERS_BLOCKLIST_COLUMNS ) const userNotificationsSortValidator = checkSort ( SORTABLE_USER_NOTIFICATIONS_COLUMNS ) const videoPlaylistsSortValidator = checkSort ( SORTABLE_VIDEO_PLAYLISTS_COLUMNS ) const pluginsSortValidator = checkSort ( SORTABLE_PLUGINS_COLUMNS ) const availablePluginsSortValidator = checkSort ( SORTABLE_AVAILABLE_PLUGINS_COLUMNS ) export { usersSortValidator , videoAbusesSortValidator , videoChannelsSortValidator , videoImportsSortValidator , videosSearchSortValidator , videosSortValidator , blacklistSortValidator , accountsSortValidator , followersSortValidator , followingSortValidator , jobsSortValidator , videoCommentThreadsSortValidator , videoRatesSortValidator , userSubscriptionsSortValidator , availablePluginsSortValidator , videoChannelsSearchSortValidator , accountsBlocklistSortValidator , serversBlocklistSortValidator , userNotificationsSortValidator , videoPlaylistsSortValidator , pluginsSortValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserModel } from 's' import * as ipaddr from 's' import { CONFIG } from 's' const isCidr = require ( 's' ) async function isSignupAllowed ( ) { if ( CONFIG . SIGNUP . ENABLED === false ) { return false } if ( CONFIG . SIGNUP . LIMIT === - 0 ) { return true } const totalUsers = await UserModel . countTotal ( ) return totalUsers < CONFIG . SIGNUP . LIMIT } function isSignupAllowedForCurrentIP ( ip ) { const addr = ipaddr . parse ( ip ) let excludeList = [ 's' ] let matched = 's' if ( CONFIG . SIGNUP . FILTERS . CIDR . WHITELIST . filter ( cidr => isCidr ( cidr ) ) . length > 0 ) { excludeList . push ( 's' ) } if ( addr . kind ( ) === 's' ) { const 0 = ipaddr . 0 . parse ( ip ) const rangeList = { whitelist : CONFIG . SIGNUP . FILTERS . CIDR . WHITELIST . filter ( cidr => isCidr . 0 ( cidr ) ) . map ( cidr => ipaddr . 0 . parseCIDR ( cidr ) ) , blacklist : CONFIG . SIGNUP . FILTERS . CIDR . BLACKLIST . filter ( cidr => isCidr . 0 ( cidr ) ) . map ( cidr => ipaddr . 0 . parseCIDR ( cidr ) ) } matched = ipaddr . subnetMatch ( 0 , rangeList , 's' ) } else if ( addr . kind ( ) === 's' ) { const 0 = ipaddr . 0 . parse ( ip ) const rangeList = { whitelist : CONFIG . SIGNUP . FILTERS . CIDR . WHITELIST . filter ( cidr => isCidr . 0 ( cidr ) ) . map ( cidr => ipaddr . 0 . parseCIDR ( cidr ) ) , blacklist : CONFIG . SIGNUP . FILTERS . CIDR . BLACKLIST . filter ( cidr => isCidr . 0 ( cidr ) ) . map ( cidr => ipaddr . 0 . parseCIDR ( cidr ) ) } matched = ipaddr . subnetMatch ( 0 , rangeList , 's' ) } return ! excludeList . includes ( matched ) } export { isSignupAllowed , isSignupAllowedForCurrentIP }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface UserRegister { username : string password : string email : string displayName ? : string channel ? : { name : string displayName : string } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import * as express from 's' import { body , param } from 's' import { omit } from 's' import { isIdOrUUIDValid , toBooleanOrNull , toIntOrNull } from 's' import { isNoInstanceConfigWarningModal , isNoWelcomeModal , isUserAdminFlagsValid , isUserAutoPlayNextVideoValid , isUserAutoPlayVideoValid , isUserBlockedReasonValid , isUserDescriptionValid , isUserDisplayNameValid , isUserNSFWPolicyValid , isUserPasswordValid , isUserRoleValid , isUserUsernameValid , isUserVideoLanguages , isUserVideoQuotaDailyValid , isUserVideoQuotaValid , isUserVideosHistoryEnabledValid } from 's' import { logger } from 's' import { isSignupAllowed , isSignupAllowedForCurrentIP } from 's' import { Redis } from 's' import { UserModel } from 's' import { areValidationErrors } from 's' import { ActorModel } from 's' import { isActorPreferredUsernameValid } from 's' import { isVideoChannelNameValid } from 's' import { UserRegister } from 's' import { isThemeNameValid } from 's' import { isThemeRegistered } from 's' import { doesVideoExist } from 's' import { UserRole } from 's' import { MUserDefault } from 's' const usersAddValidator = [ body ( 's' ) . custom ( isUserUsernameValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , body ( 's' ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserVideoQuotaValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserVideoQuotaDailyValid ) . withMessage ( 's' ) , body ( 's' ) . customSanitizer ( toIntOrNull ) . custom ( isUserRoleValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserAdminFlagsValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : omit ( req . body , 's' ) } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserNameOrEmailDoesNotAlreadyExist ( req . body . username , req . body . email , res ) ) return const authUser = res . locals . oauth . token . User if ( authUser . role !== UserRole . ADMINISTRATOR && req . body . role !== UserRole . USER ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const usersRegisterValidator = [ body ( 's' ) . custom ( isUserUsernameValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , body ( 's' ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserDisplayNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isActorPreferredUsernameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : omit ( req . body , 's' ) } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserNameOrEmailDoesNotAlreadyExist ( req . body . username , req . body . email , res ) ) return const body = req . body if ( body . channel ) { if ( ! body . channel . name || ! body . channel . displayName ) { return res . status ( 0 ) . json ( { error : 's' } ) } if ( body . channel . name === body . username ) { return res . status ( 0 ) . json ( { error : 's' } ) } const existing = await ActorModel . loadLocalByName ( body . channel . name ) if ( existing ) { return res . status ( 0 ) . json ( { error : `template` } ) } } return next ( ) } ] const usersRemoveValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return const user = res . locals . user if ( user . username === 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const usersBlockingValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserBlockedReasonValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return const user = res . locals . user if ( user . username === 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const deleteMeValidator = [ async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const user = res . locals . oauth . token . User if ( user . username === 's' ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] const usersUpdateValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserVideoQuotaValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserVideoQuotaDailyValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isUserRoleValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserAdminFlagsValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return const user = res . locals . user if ( user . username === 's' && req . body . role !== undefined && user . role !== req . body . role ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const usersUpdateMeValidator = [ body ( 's' ) . optional ( ) . custom ( isUserDisplayNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserDescriptionValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserNSFWPolicyValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserAutoPlayVideoValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserVideoLanguages ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isUserVideosHistoryEnabledValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( v => isThemeNameValid ( v ) && isThemeRegistered ( v ) ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( v => isNoInstanceConfigWarningModal ( v ) ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( v => isNoWelcomeModal ( v ) ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( v => isUserAutoPlayNextVideoValid ( v ) ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : omit ( req . body , 's' ) } ) if ( req . body . password || req . body . email ) { if ( ! req . body . currentPassword ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } const user = res . locals . oauth . token . User if ( await user . isPasswordMatch ( req . body . currentPassword ) !== true ) { return res . status ( 0 ) . json ( { error : 's' } ) } } if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const usersGetValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return return next ( ) } ] const usersVideoRatingValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return return next ( ) } ] const ensureUserRegistrationAllowed = [ async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const allowed = await isSignupAllowed ( ) if ( allowed === false ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const ensureUserRegistrationAllowedForIP = [ async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const allowed = isSignupAllowedForCurrentIP ( req . ip ) if ( allowed === false ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const usersAskResetPasswordValidator = [ body ( 's' ) . isEmail ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const exists = await checkUserEmailExist ( req . body . email , res , false ) if ( ! exists ) { logger . debug ( 's' , req . body . email ) return res . status ( 0 ) . end ( ) } return next ( ) } ] const usersResetPasswordValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserPasswordValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return const user = res . locals . user const redisVerificationString = await Redis . Instance . getResetPasswordLink ( user . id ) if ( redisVerificationString !== req . body . verificationString ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const usersAskSendVerifyEmailValidator = [ body ( 's' ) . isEmail ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const exists = await checkUserEmailExist ( req . body . email , res , false ) if ( ! exists ) { logger . debug ( 's' , req . body . email ) return res . status ( 0 ) . end ( ) } return next ( ) } ] const usersVerifyEmailValidator = [ param ( 's' ) . isInt ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await checkUserIdExist ( req . params . id , res ) ) return const user = res . locals . user const redisVerificationString = await Redis . Instance . getVerifyEmailLink ( user . id ) if ( redisVerificationString !== req . body . verificationString ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const userAutocompleteValidator = [ param ( 's' ) . isString ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) ] const ensureAuthUserOwnsAccountValidator = [ async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const user = res . locals . oauth . token . User if ( res . locals . account . id !== user . Account . id ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] const ensureCanManageUser = [ ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const authUser = res . locals . oauth . token . User const onUser = res . locals . user if ( authUser . role === UserRole . ADMINISTRATOR ) return next ( ) if ( authUser . role === UserRole . MODERATOR && onUser . role === UserRole . USER ) return next ( ) return res . status ( 0 ) . json ( { error : 's' } ) } ] export { usersAddValidator , deleteMeValidator , usersRegisterValidator , usersBlockingValidator , usersRemoveValidator , usersUpdateValidator , usersUpdateMeValidator , usersVideoRatingValidator , ensureUserRegistrationAllowed , ensureUserRegistrationAllowedForIP , usersGetValidator , usersAskResetPasswordValidator , usersResetPasswordValidator , usersAskSendVerifyEmailValidator , usersVerifyEmailValidator , userAutocompleteValidator , ensureAuthUserOwnsAccountValidator , ensureCanManageUser } function checkUserIdExist ( id , res : express . Response ) { return checkUserExist ( ( ) => UserModel . loadById ( id ) , res ) } function checkUserEmailExist ( email , res : express . Response , abortResponse = true ) { return checkUserExist ( ( ) => UserModel . loadByEmail ( email ) , res , abortResponse ) } async function checkUserNameOrEmailDoesNotAlreadyExist ( username , email , res : express . Response ) { const user = await UserModel . loadByUsernameOrEmail ( username , email ) if ( user ) { res . status ( 0 ) . json ( { error : 's' } ) return false } const actor = await ActorModel . loadLocalByName ( username ) if ( actor ) { res . status ( 0 ) . json ( { error : 's' } ) return false } return true } async function checkUserExist ( finder : ( ) => Bluebird < MUserDefault > , res : express . Response , abortResponse = true ) { const user = await finder ( ) if ( ! user ) { if ( abortResponse === true ) { res . status ( 0 ) . json ( { error : 's' } ) } return false } res . locals . user = user return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRegister$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param , query } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { ActorFollowModel } from 's' import { areValidActorHandles , isValidActorHandle } from 's' import { toArray } from 's' import { WEBSERVER } from 's' const userSubscriptionAddValidator = [ body ( 's' ) . custom ( isValidActorHandle ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const areSubscriptionsExistValidator = [ query ( 's' ) . customSanitizer ( toArray ) . custom ( areValidActorHandles ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const userSubscriptionGetValidator = [ param ( 's' ) . custom ( isValidActorHandle ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return let [ name , host ] = req . params . uri . split ( 's' ) if ( host === WEBSERVER . HOST ) host = null const user = res . locals . oauth . token . User const subscription = await ActorFollowModel . loadByActorAndTargetNameAndHostForAPI ( user . Account . Actor . id , name , host ) if ( ! subscription || ! subscription . ActorFollowing . VideoChannel ) { return res . status ( 0 ) . json ( { error : `template` } ) . end ( ) } res . locals . subscription = subscription return next ( ) } ] export { areSubscriptionsExistValidator , userSubscriptionAddValidator , userSubscriptionGetValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param } from 's' import { isIdOrUUIDValid , isIdValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isVideoAbuseModerationCommentValid , isVideoAbuseReasonValid , isVideoAbuseStateValid } from 's' import { doesVideoAbuseExist , doesVideoExist } from 's' const videoAbuseReportValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isVideoAbuseReasonValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return return next ( ) } ] const videoAbuseGetValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoAbuseExist ( req . params . id , res . locals . videoAll . id , res ) ) return return next ( ) } ] const videoAbuseUpdateValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoAbuseStateValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoAbuseModerationCommentValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoAbuseExist ( req . params . id , res . locals . videoAll . id , res ) ) return return next ( ) } ] export { videoAbuseReportValidator , videoAbuseGetValidator , videoAbuseUpdateValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param , query } from 's' import { isBooleanValid , isIdOrUUIDValid , toBooleanOrNull } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isVideoBlacklistReasonValid , isVideoBlacklistTypeValid } from 's' import { doesVideoBlacklistExist , doesVideoExist } from 's' const videosBlacklistRemoveValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoBlacklistExist ( res . locals . videoAll . id , res ) ) return return next ( ) } ] const videosBlacklistAddValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoBlacklistReasonValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return const video = res . locals . videoAll if ( req . body . unfederate === true && video . remote === true ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } return next ( ) } ] const videosBlacklistUpdateValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoBlacklistReasonValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoBlacklistExist ( res . locals . videoAll . id , res ) ) return return next ( ) } ] const videosBlacklistFiltersValidator = [ query ( 's' ) . optional ( ) . custom ( isVideoBlacklistTypeValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { videosBlacklistAddValidator , videosBlacklistRemoveValidator , videosBlacklistUpdateValidator , videosBlacklistFiltersValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import * as multer from 's' import { REMOTE_SCHEME } from 's' import { logger } from 's' import { deleteFileAsync , generateRandomString } from 's' import { extname } from 's' import { isArray } from 's' import { CONFIG } from 's' function buildNSFWFilter ( res ? : express . Response , paramNSFW ? ) { if ( paramNSFW === 's' ) return true if ( paramNSFW === 's' ) return false if ( paramNSFW === 's' ) return undefined if ( res && res . locals . oauth ) { const user = res . locals . oauth . token . User if ( user . nsfwPolicy === 's' ) return false return undefined } if ( CONFIG . INSTANCE . DEFAULT_NSFW_POLICY === 's' ) return false return null } function cleanUpReqFiles ( req : { files : { [ fieldname ] : Express . Multer . File [ ] } | Express . Multer . File [ ] } ) { const files = req . files if ( ! files ) return if ( isArray ( files ) ) { ( files as Express . Multer . File [ ] ) . forEach ( f => deleteFileAsync ( f . path ) ) return } for ( const key of Object . keys ( files ) ) { const file = files [ key ] if ( isArray ( file ) ) file . forEach ( f => deleteFileAsync ( f . path ) ) else deleteFileAsync ( file . path ) } } function getHostWithPort ( host ) { const splitted = host . split ( 's' ) if ( splitted . length === 0 ) { if ( REMOTE_SCHEME . HTTP === 's' ) return host + 's' return host + 's' } return host } function badRequest ( req : express . Request , res : express . Response ) { return res . type ( 's' ) . status ( 0 ) . end ( ) } function createReqFiles ( fieldNames : string [ ] , mimeTypes : { [ id ] : string } , destinations : { [ fieldName ] : string } ) { const storage = multer . diskStorage ( { destination : ( req , file , cb ) => { cb ( null , destinations [ file . fieldname ] ) } , filename : async ( req , file , cb ) => { let extension const fileExtension = extname ( file . originalname ) const extensionFromMimetype = mimeTypes [ file . mimetype ] if ( fileExtension === 's' || fileExtension === 's' || ! extensionFromMimetype ) { extension = fileExtension } else { extension = extensionFromMimetype } let randomString = 's' try { randomString = await generateRandomString ( 0 ) } catch ( err ) { logger . error ( 's' , { err } ) randomString = 's' } cb ( null , randomString + extension ) } } ) let fields : { name : string , maxCount : number } [ ] = [ ] for ( const fieldName of fieldNames ) { fields . push ( { name : fieldName , maxCount : 0 } ) } return multer ( { storage } ) . fields ( fields ) } function isUserAbleToSearchRemoteURI ( res : express . Response ) { const user = res . locals . oauth ? res . locals . oauth . token . User : undefined return CONFIG . SEARCH . REMOTE_URI . ANONYMOUS === true || ( CONFIG . SEARCH . REMOTE_URI . USERS === true && user !== undefined ) } export { buildNSFWFilter , getHostWithPort , isUserAbleToSearchRemoteURI , badRequest , createReqFiles , cleanUpReqFiles }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { areValidationErrors } from 's' import { isIdOrUUIDValid } from 's' import { body , param } from 's' import { CONSTRAINTS_FIELDS } from 's' import { UserRight } from 's' import { logger } from 's' import { isVideoCaptionFile , isVideoCaptionLanguageValid } from 's' import { cleanUpReqFiles } from 's' import { checkUserCanManageVideo , doesVideoCaptionExist , doesVideoExist } from 's' const addVideoCaptionValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isVideoCaptionLanguageValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( ( value , { req } ) => isVideoCaptionFile ( req . files , 's' ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEO_CAPTIONS . CAPTION_FILE . EXTNAME . join ( 's' ) ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) if ( ! await doesVideoExist ( req . params . videoId , res ) ) return cleanUpReqFiles ( req ) const user = res . locals . oauth . token . User if ( ! checkUserCanManageVideo ( user , res . locals . videoAll , UserRight . UPDATE_ANY_VIDEO , res ) ) return cleanUpReqFiles ( req ) return next ( ) } ] const deleteVideoCaptionValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isVideoCaptionLanguageValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoCaptionExist ( res . locals . videoAll , req . params . captionLanguage , res ) ) return const user = res . locals . oauth . token . User if ( ! checkUserCanManageVideo ( user , res . locals . videoAll , UserRight . UPDATE_ANY_VIDEO , res ) ) return return next ( ) } ] const listVideoCaptionsValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return return next ( ) } ] export { addVideoCaptionValidator , listVideoCaptionsValidator , deleteVideoCaptionValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param } from 's' import { UserRight } from 's' import { isVideoChannelDescriptionValid , isVideoChannelNameValid , isVideoChannelSupportValid } from 's' import { logger } from 's' import { VideoChannelModel } from 's' import { areValidationErrors } from 's' import { isActorPreferredUsernameValid } from 's' import { ActorModel } from 's' import { isBooleanValid } from 's' import { doesLocalVideoChannelNameExist , doesVideoChannelNameWithHostExist } from 's' import { MChannelAccountDefault , MUser } from 's' const videoChannelsAddValidator = [ body ( 's' ) . custom ( isActorPreferredUsernameValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isVideoChannelNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelDescriptionValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelSupportValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const actor = await ActorModel . loadLocalByName ( req . body . name ) if ( actor ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) return false } return next ( ) } ] const videoChannelsUpdateValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelDescriptionValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoChannelSupportValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isBooleanValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoChannelNameWithHostExist ( req . params . nameWithHost , res ) ) return if ( res . locals . videoChannel . Actor . isOwned ( ) === false ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } if ( res . locals . videoChannel . Account . userId !== res . locals . oauth . token . User . id ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] const videoChannelsRemoveValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoChannelNameWithHostExist ( req . params . nameWithHost , res ) ) return if ( ! checkUserCanDeleteVideoChannel ( res . locals . oauth . token . User , res . locals . videoChannel , res ) ) return if ( ! await checkVideoChannelIsNotTheLastOne ( res ) ) return return next ( ) } ] const videoChannelsNameWithHostValidator = [ param ( 's' ) . exists ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoChannelNameWithHostExist ( req . params . nameWithHost , res ) ) return return next ( ) } ] const localVideoChannelValidator = [ param ( 's' ) . custom ( isVideoChannelNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesLocalVideoChannelNameExist ( req . params . name , res ) ) return return next ( ) } ] export { videoChannelsAddValidator , videoChannelsUpdateValidator , videoChannelsRemoveValidator , videoChannelsNameWithHostValidator , localVideoChannelValidator } function checkUserCanDeleteVideoChannel ( user , videoChannel , res : express . Response ) { if ( videoChannel . Actor . isOwned ( ) === false ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } if ( user . hasRight ( UserRight . REMOVE_ANY_VIDEO_CHANNEL ) === false && videoChannel . Account . userId !== user . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true } async function checkVideoChannelIsNotTheLastOne ( res : express . Response ) { const count = await VideoChannelModel . countByAccount ( res . locals . oauth . token . User . Account . id ) if ( count <= 0 ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O $MChannelAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as validator from 's' import { CONSTRAINTS_FIELDS } from 's' const VIDEO_COMMENTS_CONSTRAINTS_FIELDS = CONSTRAINTS_FIELDS . VIDEO_COMMENTS function isValidVideoCommentText ( value ) { return value === null || validator . isLength ( value , VIDEO_COMMENTS_CONSTRAINTS_FIELDS . TEXT ) } export { isValidVideoCommentText }	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O
import { ServerActionHookName , ServerFilterHookName } from 's' import { PluginManager } from 's' import { logger } from 's' import * as Bluebird from 's' type PromiseFunction < U , T > = ( params : U ) => Promise < T > | Bluebird < T > type RawFunction < U , T > = ( params : U ) => T const Hooks = { wrapObject : < T , U extends ServerFilterHookName > ( result : T , hookName : U ) => { return PluginManager . Instance . runHook ( hookName , result ) } , wrapPromiseFun : async < U , T , V extends ServerFilterHookName > ( fun < U , T > , params : U , hookName : V ) => { const result = await fun ( params ) return PluginManager . Instance . runHook ( hookName , result , params ) } , wrapFun : async < U , T , V extends ServerFilterHookName > ( fun < U , T > , params : U , hookName : V ) => { const result = fun ( params ) return PluginManager . Instance . runHook ( hookName , result , params ) } , runAction : < T , U extends ServerActionHookName > ( hookName : U , params ? : T ) => { PluginManager . Instance . runHook ( hookName , params ) . catch ( err => logger . error ( 's' , { err } ) ) } } export { Hooks }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PromiseFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RawFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoModel } from 's' import { VideoCommentModel } from 's' import { VideoCommentCreate } from 's' import { VideoCreate } from 's' import { UserModel } from 's' import { VideoTorrentObject } from 's' import { ActivityCreate } from 's' import { ActorModel } from 's' import { VideoCommentObject } from 's' export type AcceptResult = { accepted : boolean errorMessage ? : string } function isLocalVideoAccepted ( object : { videoBody : VideoCreate , videoFile : Express . Multer . File & { duration ? : number } , user : UserModel } ) { return { accepted : true } } function isLocalVideoThreadAccepted ( _object : { commentBody : VideoCommentCreate , video : VideoModel , user : UserModel } ) { return { accepted : true } } function isLocalVideoCommentReplyAccepted ( _object : { commentBody : VideoCommentCreate , parentComment : VideoCommentModel , video : VideoModel , user : UserModel } ) { return { accepted : true } } function isRemoteVideoAccepted ( _object : { activity : ActivityCreate , videoAP : VideoTorrentObject , byActor : ActorModel } ) { return { accepted : true } } function isRemoteVideoCommentAccepted ( _object : { activity : ActivityCreate , commentAP : VideoCommentObject , byActor : ActorModel } ) { return { accepted : true } } export { isLocalVideoAccepted , isLocalVideoThreadAccepted , isRemoteVideoAccepted , isRemoteVideoCommentAccepted , isLocalVideoCommentReplyAccepted }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param } from 's' import { UserRight } from 's' import { isIdOrUUIDValid , isIdValid } from 's' import { isValidVideoCommentText } from 's' import { logger } from 's' import { VideoCommentModel } from 's' import { areValidationErrors } from 's' import { Hooks } from 's' import { AcceptResult , isLocalVideoCommentReplyAccepted , isLocalVideoThreadAccepted } from 's' import { doesVideoExist } from 's' import { MCommentOwner , MVideo , MVideoFullLight , MVideoId } from 's' import { MUser } from 's' const listVideoCommentThreadsValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return return next ( ) } ] const listVideoThreadCommentsValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return if ( ! await doesVideoCommentThreadExist ( req . params . threadId , res . locals . onlyVideo , res ) ) return return next ( ) } ] const addVideoCommentThreadValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isValidVideoCommentText ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params , body : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! isVideoCommentsEnabled ( res . locals . videoAll , res ) ) return if ( ! await isVideoCommentAccepted ( req , res , res . locals . videoAll , false ) ) return return next ( ) } ] const addVideoCommentReplyValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isValidVideoCommentText ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params , body : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! isVideoCommentsEnabled ( res . locals . videoAll , res ) ) return if ( ! await doesVideoCommentExist ( req . params . commentId , res . locals . videoAll , res ) ) return if ( ! await isVideoCommentAccepted ( req , res , res . locals . videoAll , true ) ) return return next ( ) } ] const videoCommentGetValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return if ( ! await doesVideoCommentExist ( req . params . commentId , res . locals . videoId , res ) ) return return next ( ) } ] const removeVideoCommentValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! await doesVideoCommentExist ( req . params . commentId , res . locals . videoAll , res ) ) return if ( ! checkUserCanDeleteVideoComment ( res . locals . oauth . token . User , res . locals . videoCommentFull , res ) ) return return next ( ) } ] export { listVideoCommentThreadsValidator , listVideoThreadCommentsValidator , addVideoCommentThreadValidator , addVideoCommentReplyValidator , videoCommentGetValidator , removeVideoCommentValidator } async function doesVideoCommentThreadExist ( id , video , res : express . Response ) { const videoComment = await VideoCommentModel . loadById ( id ) if ( ! videoComment ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } if ( videoComment . videoId !== video . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } if ( videoComment . inReplyToCommentId !== null ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoCommentThread = videoComment return true } async function doesVideoCommentExist ( id , video , res : express . Response ) { const videoComment = await VideoCommentModel . loadByIdAndPopulateVideoAndAccountAndReply ( id ) if ( ! videoComment ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } if ( videoComment . videoId !== video . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoCommentFull = videoComment return true } function isVideoCommentsEnabled ( video , res : express . Response ) { if ( video . commentsEnabled !== true ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true } function checkUserCanDeleteVideoComment ( user , videoComment , res : express . Response ) { const account = videoComment . Account if ( user . hasRight ( UserRight . REMOVE_ANY_VIDEO_COMMENT ) === false && account . userId !== user . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true } async function isVideoCommentAccepted ( req : express . Request , res : express . Response , video , isReply ) { const acceptParameters = { video , commentBody : req . body , user : res . locals . oauth . token . User } let acceptedResult if ( isReply ) { const acceptReplyParameters = Object . assign ( acceptParameters , { parentComment : res . locals . videoCommentFull } ) acceptedResult = await Hooks . wrapFun ( isLocalVideoCommentReplyAccepted , acceptReplyParameters , 's' ) } else { acceptedResult = await Hooks . wrapFun ( isLocalVideoThreadAccepted , acceptParameters , 's' ) } if ( ! acceptedResult || acceptedResult . accepted !== true ) { logger . info ( 's' , { acceptedResult , acceptParameters } ) res . status ( 0 ) . json ( { error : acceptedResult . errorMessage || 's' } ) return false } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O $MCommentOwner$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFullLight$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $AcceptResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import * as OAuthServer from 's' import { OAUTH_LIFETIME } from 's' import { logger } from 's' import { Socket } from 's' import { getAccessToken } from 's' const oAuthServer = new OAuthServer ( { useErrorHandler : true , accessTokenLifetime : OAUTH_LIFETIME . ACCESS_TOKEN , refreshTokenLifetime : OAUTH_LIFETIME . REFRESH_TOKEN , model : require ( 's' ) } ) function authenticate ( req : express . Request , res : express . Response , next : express . NextFunction ) { oAuthServer . authenticate ( ) ( req , res , err => { if ( err ) { logger . warn ( 's' , { err } ) return res . status ( err . status ) . json ( { error : 's' , code : err . name } ) . end ( ) } return next ( ) } ) } function authenticateSocket ( socket , next : ( err ? ) => void ) { const accessToken = socket . handshake . query . accessToken logger . debug ( 's' , accessToken ) if ( ! accessToken ) return next ( new Error ( 's' ) ) getAccessToken ( accessToken ) . then ( tokenDB => { const now = new Date ( ) if ( ! tokenDB || tokenDB . accessTokenExpiresAt < now || tokenDB . refreshTokenExpiresAt < now ) { return next ( new Error ( 's' ) ) } socket . handshake . query . user = tokenDB . User return next ( ) } ) } function authenticatePromiseIfNeeded ( req : express . Request , res : express . Response ) { return new Promise ( resolve => { if ( res . locals . oauth && res . locals . oauth . token . User ) return resolve ( ) if ( res . locals . authenticated === false ) return res . sendStatus ( 0 ) authenticate ( req , res , ( ) => { return resolve ( ) } ) } ) } function optionalAuthenticate ( req : express . Request , res : express . Response , next : express . NextFunction ) { if ( req . header ( 's' ) ) return authenticate ( req , res , next ) res . locals . authenticated = false return next ( ) } function token ( req : express . Request , res : express . Response , next : express . NextFunction ) { return oAuthServer . token ( ) ( req , res , err => { if ( err ) { return res . status ( err . status ) . json ( { error : err . message , code : err . name } ) . end ( ) } return next ( ) } ) } export { authenticate , authenticateSocket , authenticatePromiseIfNeeded , optionalAuthenticate , token }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Socket$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , ForeignKey , Model , Scopes , Table , UpdatedAt } from 's' import { AccountModel } from 's' import { ScopeNames as VideoScopeNames , VideoModel } from 's' import { VideoChangeOwnership , VideoChangeOwnershipStatus } from 's' import { getSort } from 's' import { MVideoChangeOwnershipFormattable , MVideoChangeOwnershipFull } from 's' import * as Bluebird from 's' enum ScopeNames { WITH_ACCOUNTS = 's' , WITH_VIDEO = 's' } @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) @ Scopes ( ( ) => ( { [ ScopeNames . WITH_ACCOUNTS ] : { include : [ { model : AccountModel , as : 's' , required : true } , { model : AccountModel , as : 's' , required : true } ] } , [ ScopeNames . WITH_VIDEO ] : { include : [ { model : VideoModel . scope ( [ VideoScopeNames . WITH_THUMBNAILS , VideoScopeNames . WITH_FILES ] ) , required : true } ] } } ) ) export class VideoChangeOwnershipModel extends Model < VideoChangeOwnershipModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Column status : VideoChangeOwnershipStatus @ ForeignKey ( ( ) => AccountModel ) @ Column initiatorAccountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) Initiator : AccountModel @ ForeignKey ( ( ) => AccountModel ) @ Column nextOwnerAccountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) NextOwner : AccountModel @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static listForApi ( nextOwnerId , start , count , sort ) { const query = { offset : start , limit : count , order : getSort ( sort ) , where : { nextOwnerAccountId : nextOwnerId } } return Promise . all ( [ VideoChangeOwnershipModel . scope ( ScopeNames . WITH_ACCOUNTS ) . count ( query ) , VideoChangeOwnershipModel . scope ( [ ScopeNames . WITH_ACCOUNTS , ScopeNames . WITH_VIDEO ] ) . findAll < MVideoChangeOwnershipFull > ( query ) ] ) . then ( ( [ count , rows ] ) => ( { total : count , data : rows } ) ) } static load ( id ) < MVideoChangeOwnershipFull > { return VideoChangeOwnershipModel . scope ( [ ScopeNames . WITH_ACCOUNTS , ScopeNames . WITH_VIDEO ] ) . findByPk ( id ) } toFormattedJSON ( this ) { return { id : this . id , status : this . status , initiatorAccount : this . Initiator . toFormattedJSON ( ) , nextOwnerAccount : this . NextOwner . toFormattedJSON ( ) , video : { id : this . Video . id , uuid : this . Video . uuid , url : this . Video . url , name : this . Video . name } , createdAt : this . createdAt } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChangeOwnership$ O $MVideoChangeOwnershipFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Response } from 's' import { VideoChangeOwnershipModel } from 's' import { MVideoChangeOwnershipFull } from 's' import { MUserId } from 's' export async function doesChangeVideoOwnershipExist ( id , res ) { const videoChangeOwnership = await VideoChangeOwnershipModel . load ( id ) if ( ! videoChangeOwnership ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } res . locals . videoChangeOwnership = videoChangeOwnership return true } export function checkUserCanTerminateOwnershipChange ( user , videoChangeOwnership , res ) { if ( videoChangeOwnership . NextOwner . userId === user . id ) { return true } res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserId$ O $MVideoChangeOwnershipFull$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as validator from 's' import { isArray } from 's' function isNumberArray ( value ) { return isArray ( value ) && value . every ( v => validator . isInt ( 's' + v ) ) } function isStringArray ( value ) { return isArray ( value ) && value . every ( v => typeof v === 's' ) } function isNSFWQueryValid ( value ) { return value === 's' || value === 's' || value === 's' } export { isNumberArray , isStringArray , isNSFWQueryValid }	O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param , query , ValidationChain } from 's' import { UserRight , VideoChangeOwnershipStatus , VideoPrivacy } from 's' import { isBooleanValid , isDateValid , isIdOrUUIDValid , isIdValid , isUUIDValid , toArray , toBooleanOrNull , toIntOrNull , toValueOrNull } from 's' import { isScheduleVideoUpdatePrivacyValid , isVideoCategoryValid , isVideoDescriptionValid , isVideoFile , isVideoFilterValid , isVideoImage , isVideoLanguageValid , isVideoLicenceValid , isVideoNameValid , isVideoOriginallyPublishedAtValid , isVideoPrivacyValid , isVideoSupportValid , isVideoTagsValid } from 's' import { getDurationFromVideoFile } from 's' import { logger } from 's' import { CONSTRAINTS_FIELDS } from 's' import { authenticatePromiseIfNeeded } from 's' import { areValidationErrors } from 's' import { cleanUpReqFiles } from 's' import { VideoModel } from 's' import { checkUserCanTerminateOwnershipChange , doesChangeVideoOwnershipExist } from 's' import { VideoChangeOwnershipAccept } from 's' import { AccountModel } from 's' import { isNSFWQueryValid , isNumberArray , isStringArray } from 's' import { getServerActor } from 's' import { CONFIG } from 's' import { isLocalVideoAccepted } from 's' import { Hooks } from 's' import { checkUserCanManageVideo , doesVideoChannelOfAccountExist , doesVideoExist } from 's' import { MVideoFullLight } from 's' import { getVideoWithAttributes } from 's' const videosAddValidator = getCommonVideoEditAttributes ( ) . concat ( [ body ( 's' ) . custom ( ( value , { req } ) => isVideoFile ( req . files ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEOS . EXTNAME . join ( 's' ) ) , body ( 's' ) . custom ( isVideoNameValid ) . withMessage ( 's' ) , body ( 's' ) . customSanitizer ( toIntOrNull ) . custom ( isIdValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body , files : req . files } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) if ( areErrorsInScheduleUpdate ( req , res ) ) return cleanUpReqFiles ( req ) const videoFile : Express . Multer . File & { duration ? : number } = req . files [ 's' ] [ 0 ] const user = res . locals . oauth . token . User if ( ! await doesVideoChannelOfAccountExist ( req . body . channelId , user , res ) ) return cleanUpReqFiles ( req ) if ( await user . isAbleToUploadVideo ( videoFile ) === false ) { res . status ( 0 ) . json ( { error : 's' } ) return cleanUpReqFiles ( req ) } let duration try { duration = await getDurationFromVideoFile ( videoFile . path ) } catch ( err ) { logger . error ( 's' , { err } ) res . status ( 0 ) . json ( { error : 's' } ) return cleanUpReqFiles ( req ) } videoFile . duration = duration if ( ! await isVideoAccepted ( req , res , videoFile ) ) return cleanUpReqFiles ( req ) return next ( ) } ] ) const videosUpdateValidator = getCommonVideoEditAttributes ( ) . concat ( [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isIdValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) if ( areErrorsInScheduleUpdate ( req , res ) ) return cleanUpReqFiles ( req ) if ( ! await doesVideoExist ( req . params . id , res ) ) return cleanUpReqFiles ( req ) const user = res . locals . oauth . token . User if ( ! checkUserCanManageVideo ( user , res . locals . videoAll , UserRight . UPDATE_ANY_VIDEO , res ) ) return cleanUpReqFiles ( req ) if ( req . body . channelId && ! await doesVideoChannelOfAccountExist ( req . body . channelId , user , res ) ) return cleanUpReqFiles ( req ) return next ( ) } ] ) async function checkVideoFollowConstraints ( req : express . Request , res : express . Response , next : express . NextFunction ) { const video = getVideoWithAttributes ( res ) if ( video . isOwned ( ) === true ) return next ( ) if ( res . locals . oauth ) { if ( CONFIG . SEARCH . REMOTE_URI . USERS === true ) return next ( ) } if ( CONFIG . SEARCH . REMOTE_URI . ANONYMOUS === true ) return next ( ) const serverActor = await getServerActor ( ) if ( await VideoModel . checkVideoHasInstanceFollow ( video . id , serverActor . id ) === true ) return next ( ) return res . status ( 0 ) . json ( { error : 's' } ) } const videosCustomGetValidator = ( fetchType : 's' | 's' | 's' ) => { return [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . id , res , fetchType ) ) return const video = getVideoWithAttributes ( res ) const videoAll = video as MVideoFullLight if ( video . privacy === VideoPrivacy . PRIVATE || videoAll . VideoBlacklist ) { await authenticatePromiseIfNeeded ( req , res ) const user = res . locals . oauth ? res . locals . oauth . token . User : null if ( ! user || ( videoAll . VideoChannel && videoAll . VideoChannel . Account . userId !== user . id && ! user . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) ) ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } if ( video . privacy === VideoPrivacy . PUBLIC ) return next ( ) if ( video . privacy === VideoPrivacy . UNLISTED ) { if ( isUUIDValid ( req . params . id ) ) return next ( ) return res . status ( 0 ) . end ( ) } } ] } const videosGetValidator = videosCustomGetValidator ( 's' ) const videosRemoveValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . id , res ) ) return if ( ! checkUserCanManageVideo ( res . locals . oauth . token . User , res . locals . videoAll , UserRight . REMOVE_ANY_VIDEO , res ) ) return return next ( ) } ] const videosChangeOwnershipValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return if ( ! checkUserCanManageVideo ( res . locals . oauth . token . User , res . locals . videoAll , UserRight . CHANGE_VIDEO_OWNERSHIP , res ) ) return const nextOwner = await AccountModel . loadLocalByName ( req . body . username ) if ( ! nextOwner ) { res . status ( 0 ) . json ( { error : 's' } ) return } res . locals . nextOwner = nextOwner return next ( ) } ] const videosTerminateChangeOwnershipValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesChangeVideoOwnershipExist ( req . params . id , res ) ) return if ( ! checkUserCanTerminateOwnershipChange ( res . locals . oauth . token . User , res . locals . videoChangeOwnership , res ) ) return return next ( ) } , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const videoChangeOwnership = res . locals . videoChangeOwnership if ( videoChangeOwnership . status === VideoChangeOwnershipStatus . WAITING ) { return next ( ) } else { res . status ( 0 ) . json ( { error : 's' } ) return } } ] const videosAcceptChangeOwnershipValidator = [ async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { const body = req . body as VideoChangeOwnershipAccept if ( ! await doesVideoChannelOfAccountExist ( body . channelId , res . locals . oauth . token . User , res ) ) return const user = res . locals . oauth . token . User const videoChangeOwnership = res . locals . videoChangeOwnership const isAble = await user . isAbleToUploadVideo ( videoChangeOwnership . Video . getOriginalFile ( ) ) if ( isAble === false ) { res . status ( 0 ) . json ( { error : 's' } ) return } return next ( ) } ] function getCommonVideoEditAttributes ( ) { return [ body ( 's' ) . custom ( ( value , { req } ) => isVideoImage ( req . files , 's' ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEOS . IMAGE . EXTNAME . join ( 's' ) ) , body ( 's' ) . custom ( ( value , { req } ) => isVideoImage ( req . files , 's' ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEOS . IMAGE . EXTNAME . join ( 's' ) ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isVideoCategoryValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isVideoLicenceValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoLanguageValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoPrivacyValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoDescriptionValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoSupportValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoTagsValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoOriginallyPublishedAtValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) , body ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isScheduleVideoUpdatePrivacyValid ) . withMessage ( 's' ) ] as ( ValidationChain | express . Handler ) [ ] } const commonVideosFiltersValidator = [ query ( 's' ) . optional ( ) . customSanitizer ( toArray ) . custom ( isNumberArray ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . customSanitizer ( toArray ) . custom ( isNumberArray ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . customSanitizer ( toArray ) . custom ( isStringArray ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . customSanitizer ( toArray ) . custom ( isStringArray ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . customSanitizer ( toArray ) . custom ( isStringArray ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isNSFWQueryValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isVideoFilterValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return const user = res . locals . oauth ? res . locals . oauth . token . User : undefined if ( req . query . filter === 's' && ( ! user || user . hasRight ( UserRight . SEE_ALL_VIDEOS ) === false ) ) { res . status ( 0 ) . json ( { error : 's' } ) return } return next ( ) } ] export { videosAddValidator , videosUpdateValidator , videosGetValidator , checkVideoFollowConstraints , videosCustomGetValidator , videosRemoveValidator , videosChangeOwnershipValidator , videosTerminateChangeOwnershipValidator , videosAcceptChangeOwnershipValidator , getCommonVideoEditAttributes , commonVideosFiltersValidator } function areErrorsInScheduleUpdate ( req : express . Request , res : express . Response ) { if ( req . body . scheduleUpdate ) { if ( ! req . body . scheduleUpdate . updateAt ) { logger . warn ( 's' ) res . status ( 0 ) . json ( { error : 's' } ) return true } } return false } async function isVideoAccepted ( req : express . Request , res : express . Response , videoFile : Express . Multer . File & { duration ? : number } ) { const acceptParameters = { videoBody : req . body , videoFile , user : res . locals . oauth . token . User } const acceptedResult = await Hooks . wrapFun ( isLocalVideoAccepted , acceptParameters , 's' ) if ( ! acceptedResult || acceptedResult . accepted !== true ) { logger . info ( 's' , { acceptedResult , acceptParameters } ) res . status ( 0 ) . json ( { error : acceptedResult . errorMessage || 's' } ) return false } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body } from 's' import { isIdValid , toIntOrNull } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { getCommonVideoEditAttributes } from 's' import { isVideoImportTargetUrlValid , isVideoImportTorrentFile } from 's' import { cleanUpReqFiles } from 's' import { isVideoMagnetUriValid , isVideoNameValid } from 's' import { CONFIG } from 's' import { CONSTRAINTS_FIELDS } from 's' import { doesVideoChannelOfAccountExist } from 's' const videoImportAddValidator = getCommonVideoEditAttributes ( ) . concat ( [ body ( 's' ) . customSanitizer ( toIntOrNull ) . custom ( isIdValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoImportTargetUrlValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoMagnetUriValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( ( value , { req } ) => isVideoImportTorrentFile ( req . files ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEO_IMPORTS . TORRENT_FILE . EXTNAME . join ( 's' ) ) , body ( 's' ) . optional ( ) . custom ( isVideoNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) const user = res . locals . oauth . token . User const torrentFile = req . files && req . files [ 's' ] ? req . files [ 's' ] [ 0 ] : undefined if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) if ( req . body . targetUrl && CONFIG . IMPORT . VIDEOS . HTTP . ENABLED !== true ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } if ( CONFIG . IMPORT . VIDEOS . TORRENT . ENABLED !== true && ( req . body . magnetUri || torrentFile ) ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } if ( ! await doesVideoChannelOfAccountExist ( req . body . channelId , user , res ) ) return cleanUpReqFiles ( req ) if ( ! req . body . targetUrl && ! req . body . magnetUri && ! torrentFile ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] ) export { videoImportAddValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { body , param } from 's' import * as express from 's' import { isIdOrUUIDValid , toIntOrNull } from 's' import { areValidationErrors } from 's' import { logger } from 's' import { doesVideoExist } from 's' const videoWatchingValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . customSanitizer ( toIntOrNull ) . isInt ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res , 's' ) ) return const user = res . locals . oauth . token . User if ( user . videosHistoryEnabled === false ) { logger . warn ( 's' , user . id ) return res . status ( 0 ) . end ( ) } return next ( ) } ] export { videoWatchingValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
function isRatingValid ( value ) { return value === 's' || value === 's' } export { isRatingValid }	O O O $any$ O O O O O O O O O O O O O O O
import * as express from 's' import { body , param , query } from 's' import { isIdOrUUIDValid } from 's' import { isRatingValid } from 's' import { isVideoRatingTypeValid } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { AccountVideoRateModel } from 's' import { VideoRateType } from 's' import { isAccountNameValid } from 's' import { doesVideoExist } from 's' const videoUpdateRateValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isVideoRatingTypeValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . id , res ) ) return return next ( ) } ] const getAccountVideoRateValidator = function ( rateType ) { return [ param ( 's' ) . custom ( isAccountNameValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const rate = await AccountVideoRateModel . loadLocalAndPopulateVideo ( rateType , req . params . name , req . params . videoId ) if ( ! rate ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } res . locals . accountVideoRate = rate return next ( ) } ] } const videoRatingValidator = [ query ( 's' ) . optional ( ) . custom ( isRatingValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { videoUpdateRateValidator , getAccountVideoRateValidator , videoRatingValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { param } from 's' import { isIdOrUUIDValid , isIdValid } from 's' import { logger } from 's' import { VideoShareModel } from 's' import { areValidationErrors } from 's' import { doesVideoExist } from 's' const videosShareValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . id , res ) ) return const video = res . locals . videoAll const share = await VideoShareModel . load ( req . params . actorId , video . id ) if ( ! share ) { return res . status ( 0 ) . end ( ) } res . locals . videoShare = share return next ( ) } ] export { videosShareValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { REMOTE_SCHEME , WEBSERVER } from 's' import { sanitizeHost } from 's' import { exists } from 's' function isWebfingerLocalResourceValid ( value ) { if ( ! exists ( value ) ) return false if ( value . startsWith ( 's' ) === false ) return false const actorWithHost = value . substr ( 0 ) const actorParts = actorWithHost . split ( 's' ) if ( actorParts . length !== 0 ) return false const host = actorParts [ 0 ] return sanitizeHost ( host , REMOTE_SCHEME . HTTP ) === WEBSERVER . HOST } export { isWebfingerLocalResourceValid }	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { query } from 's' import { isWebfingerLocalResourceValid } from 's' import { logger } from 's' import { ActorModel } from 's' import { areValidationErrors } from 's' import { getHostWithPort } from 's' const webfingerValidator = [ query ( 's' ) . custom ( isWebfingerLocalResourceValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return const nameWithHost = getHostWithPort ( req . query . resource . substr ( 0 ) ) const [ name ] = nameWithHost . split ( 's' ) const actor = await ActorModel . loadLocalByName ( name ) if ( ! actor ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } res . locals . actorFull = actor return next ( ) } ] export { webfingerValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { areValidationErrors } from 's' import { logger } from 's' import { query } from 's' import { isDateValid } from 's' const videosSearchValidator = [ query ( 's' ) . optional ( ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isInt ( ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . isInt ( ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const videoChannelsSearchValidator = [ query ( 's' ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { videoChannelsSearchValidator , videosSearchValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isHostValid , isValidContactBody } from 's' import { ServerModel } from 's' import { body } from 's' import { isUserDisplayNameValid } from 's' import { Emailer } from 's' import { Redis } from 's' import { CONFIG } from 's' const serverGetValidator = [ body ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const server = await ServerModel . loadByHost ( req . body . host ) if ( ! server ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } res . locals . server = server return next ( ) } ] const contactAdministratorValidator = [ body ( 's' ) . custom ( isUserDisplayNameValid ) . withMessage ( 's' ) , body ( 's' ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isValidContactBody ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( CONFIG . CONTACT_FORM . ENABLED === false ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } if ( Emailer . isEnabled ( ) === false ) { return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } if ( await Redis . Instance . doesContactFormIpExist ( req . ip ) ) { logger . info ( 's' , req . ip ) return res . status ( 0 ) . send ( { error : 's' } ) . end ( ) } return next ( ) } ] export { serverGetValidator , contactAdministratorValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isDateValid } from 's' const userHistoryRemoveValidator = [ body ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { userHistoryRemoveValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NextFunction , Request , Response } from 's' import { ActivityPubSignature } from 's' import { logger } from 's' import { isHTTPSignatureVerified , isJsonLDSignatureVerified , parseHTTPSignature } from 's' import { ACCEPT_HEADERS , ACTIVITY_PUB , HTTP_SIGNATURE } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { loadActorUrlOrGetFromWebfinger } from 's' async function checkSignature ( req , res , next ) { try { const httpSignatureChecked = await checkHttpSignature ( req , res ) if ( httpSignatureChecked !== true ) return const actor = res . locals . signature . actor const bodyActor = req . body . actor const bodyActorId = bodyActor && bodyActor . id ? bodyActor . id : bodyActor if ( bodyActorId && bodyActorId !== actor . url ) { const jsonLDSignatureChecked = await checkJsonLDSignature ( req , res ) if ( jsonLDSignatureChecked !== true ) return } return next ( ) } catch ( err ) { logger . error ( 's' , err ) return res . sendStatus ( 0 ) } } function executeIfActivityPub ( req , res , next ) { const accepted = req . accepts ( ACCEPT_HEADERS ) if ( accepted === false || ACTIVITY_PUB . POTENTIAL_ACCEPT_HEADERS . indexOf ( accepted ) === - 0 ) { return next ( 's' ) } logger . debug ( 's' , req . url ) return next ( ) } export { checkSignature , executeIfActivityPub , checkHttpSignature } async function checkHttpSignature ( req , res ) { const sig = req . headers [ HTTP_SIGNATURE . HEADER_NAME ] as string if ( sig && sig . startsWith ( 's' ) === false ) req . headers [ HTTP_SIGNATURE . HEADER_NAME ] = 's' + sig const parsed = parseHTTPSignature ( req ) const keyId = parsed . keyId if ( ! keyId ) { res . sendStatus ( 0 ) return false } logger . debug ( 's' , keyId ) let [ actorUrl ] = keyId . split ( 's' ) if ( actorUrl . startsWith ( 's' ) ) { actorUrl = await loadActorUrlOrGetFromWebfinger ( actorUrl . replace ( "s" , 's' ) ) } const actor = await getOrCreateActorAndServerAndModel ( actorUrl ) const verified = isHTTPSignatureVerified ( parsed , actor ) if ( verified !== true ) { logger . warn ( 's' , actorUrl , { parsed } ) res . sendStatus ( 0 ) return false } res . locals . signature = { actor } return true } async function checkJsonLDSignature ( req , res ) { const signatureObject = req . body . signature if ( ! signatureObject || ! signatureObject . creator ) { res . sendStatus ( 0 ) return false } const [ creator ] = signatureObject . creator . split ( 's' ) logger . debug ( 's' , creator ) const actor = await getOrCreateActorAndServerAndModel ( creator ) const verified = await isJsonLDSignatureVerified ( actor , req . body ) if ( verified !== true ) { logger . warn ( 's' , req . body ) res . sendStatus ( 0 ) return false } res . locals . signature = { actor } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O $ActivityPubSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { eachSeries } from 's' import { NextFunction , Request , RequestHandler , Response } from 's' import { retryTransactionWrapper } from 's' import { ValidationChain } from 's' export type RequestPromiseHandler = ValidationChain | ( ( req , res , next ) => Promise < any > ) function asyncMiddleware ( fun : RequestPromiseHandler | RequestPromiseHandler [ ] ) { return ( req , res , next ) => { if ( Array . isArray ( fun ) === true ) { return eachSeries ( fun as RequestHandler [ ] , ( f , cb ) => { Promise . resolve ( f ( req , res , cb ) ) . catch ( err => next ( err ) ) } , next ) } return Promise . resolve ( ( fun as RequestHandler ) ( req , res , next ) ) . catch ( err => next ( err ) ) } } function asyncRetryTransactionMiddleware ( fun : ( req , res , next ) => Promise < any > ) { return ( req , res , next ) => { return Promise . resolve ( retryTransactionWrapper ( fun , req , res , next ) ) . catch ( err => next ( err ) ) } } export { asyncMiddleware , asyncRetryTransactionMiddleware }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O $Request$ O $Response$ O $NextFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { PAGINATION } from 's' function setDefaultPagination ( req : express . Request , res : express . Response , next : express . NextFunction ) { if ( ! req . query . start ) req . query . start = 0 else req . query . start = parseInt ( req . query . start , 0 ) if ( ! req . query . count ) req . query . count = PAGINATION . COUNT . DEFAULT else req . query . count = parseInt ( req . query . count , 0 ) if ( req . query . count > PAGINATION . COUNT . MAX ) req . query . count = PAGINATION . COUNT . MAX return next ( ) } export { setDefaultPagination }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { getHostWithPort } from 's' function setBodyHostsPort ( req : express . Request , res : express . Response , next : express . NextFunction ) { if ( ! req . body . hosts ) return next ( ) for ( let i = 0 ; i < req . body . hosts . length ; i ++ ) { const hostWithPort = getHostWithPort ( req . body . hosts [ i ] ) if ( hostWithPort === null ) { return res . sendStatus ( 0 ) } req . body . hosts [ i ] = hostWithPort } return next ( ) } export { setBodyHostsPort }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { SortType } from 's' function setDefaultSort ( req : express . Request , res : express . Response , next : express . NextFunction ) { if ( ! req . query . sort ) req . query . sort = 's' return next ( ) } function setDefaultSearchSort ( req : express . Request , res : express . Response , next : express . NextFunction ) { if ( ! req . query . sort ) req . query . sort = 's' return next ( ) } function setBlacklistSort ( req : express . Request , res : express . Response , next : express . NextFunction ) { let newSort = { sortModel : undefined , sortValue : 's' } if ( ! req . query . sort ) req . query . sort = 's' if ( req . query . sort === 's' || req . query . sort === 's' || req . query . sort === 's' || req . query . sort === 's' ) { newSort . sortModel = undefined } else { newSort . sortModel = 's' } newSort . sortValue = req . query . sort req . query . sort = newSort return next ( ) } export { setDefaultSort , setDefaultSearchSort , setBlacklistSort }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SortType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight } from 's' import { logger } from 's' function ensureUserHasRight ( userRight ) { return function ( req : express . Request , res : express . Response , next : express . NextFunction ) { const user = res . locals . oauth . token . user if ( user . hasRight ( userRight ) === false ) { const message = `template` logger . info ( message ) return res . status ( 0 ) . json ( { error : message } ) . end ( ) } return next ( ) } } export { ensureUserHasRight }	O O O O O O O O O O O O O O O O O O O O O $UserRight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as ipaddr from 's' import { format } from 's' const advertiseDoNotTrack = ( _ , res , next ) => { res . setHeader ( 's' , 's' ) return next ( ) } export { advertiseDoNotTrack }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as helmet from 's' import { CONFIG } from 's' const baseDirectives = Object . assign ( { } , { defaultSrc : [ "s" ] , connectSrc : [ 's' , 's' ] , mediaSrc : [ "s" , 's' , 's' ] , fontSrc : [ "s" , 's' ] , imgSrc : [ "s" , 's' , 's' ] , scriptSrc : [ "s" , 's' ] , styleSrc : [ "s" ] , objectSrc : [ "s" ] , formAction : [ "s" ] , frameAncestors : [ "s" ] , baseUri : [ "s" ] , manifestSrc : [ "s" ] , frameSrc : [ "s" ] , workerSrc : [ "s" , 's' ] } , CONFIG . CSP . REPORT_URI ? { reportUri : CONFIG . CSP . REPORT_URI } : { } , CONFIG . WEBSERVER . SCHEME === 's' ? { upgradeInsecureRequests : true } : { } ) const baseCSP = helmet . contentSecurityPolicy ( { directives : baseDirectives , browserSniff : false , reportOnly : CONFIG . CSP . REPORT_ONLY } ) const embedCSP = helmet . contentSecurityPolicy ( { directives : Object . assign ( { } , baseDirectives , { frameAncestors : [ 's' ] } ) , browserSniff : false , reportOnly : CONFIG . CSP . REPORT_ONLY } ) export { baseCSP , embedCSP }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as SocketIO from 's' import { authenticateSocket } from 's' import { logger } from 's' import { Server } from 's' import { UserNotificationModelForApi } from 's' class PeerTubeSocket { private static instance : PeerTubeSocket private userNotificationSockets : { [ userId ] : SocketIO . Socket [ ] } = { } private constructor ( ) { } init ( server ) { const io = SocketIO ( server ) io . of ( 's' ) . use ( authenticateSocket ) . on ( 's' , socket => { const userId = socket . handshake . query . user . id logger . debug ( 's' , userId ) if ( ! this . userNotificationSockets [ userId ] ) this . userNotificationSockets [ userId ] = [ ] this . userNotificationSockets [ userId ] . push ( socket ) socket . on ( 's' , ( ) => { logger . debug ( 's' , userId ) this . userNotificationSockets [ userId ] = this . userNotificationSockets [ userId ] . filter ( s => s !== socket ) } ) } ) } sendNotification ( userId , notification ) { const sockets = this . userNotificationSockets [ userId ] if ( ! sockets ) return const notificationMessage = notification . toFormattedJSON ( ) for ( const socket of sockets ) { socket . emit ( 's' , notificationMessage ) } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { PeerTubeSocket }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O $Server$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $UserNotificationModelForApi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserNotificationSettingValue , UserNotificationType , UserRight } from 's' import { logger } from 's' import { Emailer } from 's' import { UserNotificationModel } from 's' import { UserModel } from 's' import { PeerTubeSocket } from 's' import { CONFIG } from 's' import { VideoPrivacy , VideoState } from 's' import * as Bluebird from 's' import { AccountBlocklistModel } from 's' import { MCommentOwnerVideo , MVideoAbuseVideo , MVideoAccountLight , MVideoBlacklistLightVideo , MVideoBlacklistVideo , MVideoFullLight } from 's' import { MUser , MUserDefault , MUserNotifSettingAccount , MUserWithNotificationSetting , UserNotificationModelForApi } from 's' import { MActorFollowFull } from 's' import { MVideoImportVideo } from 's' class Notifier { private static instance : Notifier private constructor ( ) { } notifyOnNewVideoIfNeeded ( video ) { if ( video . privacy !== VideoPrivacy . PUBLIC || video . state !== VideoState . PUBLISHED || video . isBlacklisted ( ) ) return this . notifySubscribersOfNewVideo ( video ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } notifyOnVideoPublishedAfterTranscoding ( video ) { if ( ! video . waitTranscoding || video . VideoBlacklist || video . ScheduleVideoUpdate ) return this . notifyOwnedVideoHasBeenPublished ( video ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } notifyOnVideoPublishedAfterScheduledUpdate ( video ) { if ( video . VideoBlacklist || ( video . waitTranscoding && video . state !== VideoState . PUBLISHED ) ) return this . notifyOwnedVideoHasBeenPublished ( video ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } notifyOnVideoPublishedAfterRemovedFromAutoBlacklist ( video ) { if ( video . ScheduleVideoUpdate || ( video . waitTranscoding && video . state !== VideoState . PUBLISHED ) ) return this . notifyOwnedVideoHasBeenPublished ( video ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } notifyOnNewComment ( comment ) { this . notifyVideoOwnerOfNewComment ( comment ) . catch ( err => logger . error ( 's' , comment . url , { err } ) ) this . notifyOfCommentMention ( comment ) . catch ( err => logger . error ( 's' , comment . url , { err } ) ) } notifyOnNewVideoAbuse ( videoAbuse ) { this . notifyModeratorsOfNewVideoAbuse ( videoAbuse ) . catch ( err => logger . error ( 's' , videoAbuse . Video . url , { err } ) ) } notifyOnVideoAutoBlacklist ( videoBlacklist ) { this . notifyModeratorsOfVideoAutoBlacklist ( videoBlacklist ) . catch ( err => logger . error ( 's' , videoBlacklist . Video . url , { err } ) ) } notifyOnVideoBlacklist ( videoBlacklist ) { this . notifyVideoOwnerOfBlacklist ( videoBlacklist ) . catch ( err => logger . error ( 's' , videoBlacklist . Video . url , { err } ) ) } notifyOnVideoUnblacklist ( video ) { this . notifyVideoOwnerOfUnblacklist ( video ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } notifyOnFinishedVideoImport ( videoImport , success ) { this . notifyOwnerVideoImportIsFinished ( videoImport , success ) . catch ( err => logger . error ( 's' , videoImport . getTargetIdentifier ( ) , { err } ) ) } notifyOnNewUserRegistration ( user ) { this . notifyModeratorsOfNewUserRegistration ( user ) . catch ( err => logger . error ( 's' , user . username , { err } ) ) } notifyOfNewUserFollow ( actorFollow ) { this . notifyUserOfNewActorFollow ( actorFollow ) . catch ( err => { logger . error ( 's' , actorFollow . ActorFollowing . VideoChannel . getDisplayName ( ) , actorFollow . ActorFollower . Account . getDisplayName ( ) , { err } ) } ) } notifyOfNewInstanceFollow ( actorFollow ) { this . notifyAdminsOfNewInstanceFollow ( actorFollow ) . catch ( err => { logger . error ( 's' , actorFollow . ActorFollower . url , { err } ) } ) } notifyOfAutoInstanceFollowing ( actorFollow ) { this . notifyAdminsOfAutoInstanceFollowing ( actorFollow ) . catch ( err => { logger . error ( 's' , actorFollow . ActorFollowing . url , { err } ) } ) } private async notifySubscribersOfNewVideo ( video ) { const users = await UserModel . listUserSubscribersOf ( video . VideoChannel . actorId ) logger . info ( 's' , users . length , video . url ) function settingGetter ( user ) { return user . NotificationSetting . newVideoFromSubscription } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_VIDEO_FROM_SUBSCRIPTION , userId : user . id , videoId : video . id } ) notification . Video = video return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewVideoFromSubscriberNotification ( emails , video ) } return this . notify ( { users , settingGetter , notificationCreator , emailSender } ) } private async notifyVideoOwnerOfNewComment ( comment ) { if ( comment . Video . isOwned ( ) === false ) return const user = await UserModel . loadByVideoId ( comment . videoId ) if ( ! user || comment . Account . userId === user . id ) return const accountMuted = await AccountBlocklistModel . isAccountMutedBy ( user . Account . id , comment . accountId ) if ( accountMuted ) return logger . info ( 's' , user . username , comment . url ) function settingGetter ( user ) { return user . NotificationSetting . newCommentOnMyVideo } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_COMMENT_ON_MY_VIDEO , userId : user . id , commentId : comment . id } ) notification . Comment = comment return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewCommentOnMyVideoNotification ( emails , comment ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyOfCommentMention ( comment ) { const extractedUsernames = comment . extractMentions ( ) logger . debug ( 's' , extractedUsernames . length , comment . url , { usernames : extractedUsernames , text : comment . text } ) let users = await UserModel . listByUsernames ( extractedUsernames ) if ( comment . Video . isOwned ( ) ) { const userException = await UserModel . loadByVideoId ( comment . videoId ) users = users . filter ( u => u . id !== userException . id ) } users = users . filter ( u => u . Account . id !== comment . accountId ) if ( users . length === 0 ) return const accountMutedHash = await AccountBlocklistModel . isAccountMutedByMulti ( users . map ( u => u . Account . id ) , comment . accountId ) logger . info ( 's' , users . length , comment . url ) function settingGetter ( user ) { if ( accountMutedHash [ user . Account . id ] === true ) return UserNotificationSettingValue . NONE return user . NotificationSetting . commentMention } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . COMMENT_MENTION , userId : user . id , commentId : comment . id } ) notification . Comment = comment return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewCommentMentionNotification ( emails , comment ) } return this . notify ( { users , settingGetter , notificationCreator , emailSender } ) } private async notifyUserOfNewActorFollow ( actorFollow ) { if ( actorFollow . ActorFollowing . isOwned ( ) === false ) return let followType : 's' | 's' = 's' let user = await UserModel . loadByChannelActorId ( actorFollow . ActorFollowing . id ) if ( ! user ) { user = await UserModel . loadByAccountActorId ( actorFollow . ActorFollowing . id ) followType = 's' } if ( ! user ) return const followerAccount = actorFollow . ActorFollower . Account const accountMuted = await AccountBlocklistModel . isAccountMutedBy ( user . Account . id , followerAccount . id ) if ( accountMuted ) return logger . info ( 's' , user . username , followerAccount . getDisplayName ( ) ) function settingGetter ( user ) { return user . NotificationSetting . newFollow } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_FOLLOW , userId : user . id , actorFollowId : actorFollow . id } ) notification . ActorFollow = actorFollow return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewFollowNotification ( emails , actorFollow , followType ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyAdminsOfNewInstanceFollow ( actorFollow ) { const admins = await UserModel . listWithRight ( UserRight . MANAGE_SERVER_FOLLOW ) logger . info ( 's' , admins . length , actorFollow . ActorFollower . url ) function settingGetter ( user ) { return user . NotificationSetting . newInstanceFollower } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_INSTANCE_FOLLOWER , userId : user . id , actorFollowId : actorFollow . id } ) notification . ActorFollow = actorFollow return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewInstanceFollowerNotification ( emails , actorFollow ) } return this . notify ( { users : admins , settingGetter , notificationCreator , emailSender } ) } private async notifyAdminsOfAutoInstanceFollowing ( actorFollow ) { const admins = await UserModel . listWithRight ( UserRight . MANAGE_SERVER_FOLLOW ) logger . info ( 's' , admins . length , actorFollow . ActorFollowing . url ) function settingGetter ( user ) { return user . NotificationSetting . autoInstanceFollowing } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . AUTO_INSTANCE_FOLLOWING , userId : user . id , actorFollowId : actorFollow . id } ) notification . ActorFollow = actorFollow return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addAutoInstanceFollowingNotification ( emails , actorFollow ) } return this . notify ( { users : admins , settingGetter , notificationCreator , emailSender } ) } private async notifyModeratorsOfNewVideoAbuse ( videoAbuse ) { const moderators = await UserModel . listWithRight ( UserRight . MANAGE_VIDEO_ABUSES ) if ( moderators . length === 0 ) return logger . info ( 's' , moderators . length , videoAbuse . Video . url ) function settingGetter ( user ) { return user . NotificationSetting . videoAbuseAsModerator } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_VIDEO_ABUSE_FOR_MODERATORS , userId : user . id , videoAbuseId : videoAbuse . id } ) notification . VideoAbuse = videoAbuse return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addVideoAbuseModeratorsNotification ( emails , videoAbuse ) } return this . notify ( { users : moderators , settingGetter , notificationCreator , emailSender } ) } private async notifyModeratorsOfVideoAutoBlacklist ( videoBlacklist ) { const moderators = await UserModel . listWithRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) if ( moderators . length === 0 ) return logger . info ( 's' , moderators . length , videoBlacklist . Video . url ) function settingGetter ( user ) { return user . NotificationSetting . videoAutoBlacklistAsModerator } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . VIDEO_AUTO_BLACKLIST_FOR_MODERATORS , userId : user . id , videoBlacklistId : videoBlacklist . id } ) notification . VideoBlacklist = videoBlacklist return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addVideoAutoBlacklistModeratorsNotification ( emails , videoBlacklist ) } return this . notify ( { users : moderators , settingGetter , notificationCreator , emailSender } ) } private async notifyVideoOwnerOfBlacklist ( videoBlacklist ) { const user = await UserModel . loadByVideoId ( videoBlacklist . videoId ) if ( ! user ) return logger . info ( 's' , user . username , videoBlacklist . Video . url ) function settingGetter ( user ) { return user . NotificationSetting . blacklistOnMyVideo } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . BLACKLIST_ON_MY_VIDEO , userId : user . id , videoBlacklistId : videoBlacklist . id } ) notification . VideoBlacklist = videoBlacklist return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addVideoBlacklistNotification ( emails , videoBlacklist ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyVideoOwnerOfUnblacklist ( video ) { const user = await UserModel . loadByVideoId ( video . id ) if ( ! user ) return logger . info ( 's' , user . username , video . url ) function settingGetter ( user ) { return user . NotificationSetting . blacklistOnMyVideo } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . UNBLACKLIST_ON_MY_VIDEO , userId : user . id , videoId : video . id } ) notification . Video = video return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addVideoUnblacklistNotification ( emails , video ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyOwnedVideoHasBeenPublished ( video ) { const user = await UserModel . loadByVideoId ( video . id ) if ( ! user ) return logger . info ( 's' , user . username , video . url ) function settingGetter ( user ) { return user . NotificationSetting . myVideoPublished } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . MY_VIDEO_PUBLISHED , userId : user . id , videoId : video . id } ) notification . Video = video return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . myVideoPublishedNotification ( emails , video ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyOwnerVideoImportIsFinished ( videoImport , success ) { const user = await UserModel . loadByVideoImportId ( videoImport . id ) if ( ! user ) return logger . info ( 's' , user . username , videoImport . getTargetIdentifier ( ) ) function settingGetter ( user ) { return user . NotificationSetting . myVideoImportFinished } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : success ? UserNotificationType . MY_VIDEO_IMPORT_SUCCESS : UserNotificationType . MY_VIDEO_IMPORT_ERROR , userId : user . id , videoImportId : videoImport . id } ) notification . VideoImport = videoImport return notification } function emailSender ( emails : string [ ] ) { return success ? Emailer . Instance . myVideoImportSuccessNotification ( emails , videoImport ) : Emailer . Instance . myVideoImportErrorNotification ( emails , videoImport ) } return this . notify ( { users : [ user ] , settingGetter , notificationCreator , emailSender } ) } private async notifyModeratorsOfNewUserRegistration ( registeredUser ) { const moderators = await UserModel . listWithRight ( UserRight . MANAGE_USERS ) if ( moderators . length === 0 ) return logger . info ( 's' , moderators . length , registeredUser . username ) function settingGetter ( user ) { return user . NotificationSetting . newUserRegistration } async function notificationCreator ( user ) { const notification = await UserNotificationModel . create < UserNotificationModelForApi > ( { type : UserNotificationType . NEW_USER_REGISTRATION , userId : user . id , accountId : registeredUser . Account . id } ) notification . Account = registeredUser . Account return notification } function emailSender ( emails : string [ ] ) { return Emailer . Instance . addNewUserRegistrationNotification ( emails , registeredUser ) } return this . notify ( { users : moderators , settingGetter , notificationCreator , emailSender } ) } private async notify < T extends MUserWithNotificationSetting > ( options : { users : T [ ] , notificationCreator : ( user : T ) => Promise < UserNotificationModelForApi > , emailSender : ( emails : string [ ] ) => Promise < any > | Bluebird < any > , settingGetter : ( user : T ) => UserNotificationSettingValue } ) { const emails : string [ ] = [ ] for ( const user of options . users ) { if ( this . isWebNotificationEnabled ( options . settingGetter ( user ) ) ) { const notification = await options . notificationCreator ( user ) PeerTubeSocket . Instance . sendNotification ( user . id , notification ) } if ( this . isEmailEnabled ( user , options . settingGetter ( user ) ) ) { emails . push ( user . email ) } } if ( emails . length !== 0 ) { await options . emailSender ( emails ) } } private isEmailEnabled ( user , value ) { if ( CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION === true && user . emailVerified === false ) return false return value & UserNotificationSettingValue . EMAIL } private isWebNotificationEnabled ( value ) { return value & UserNotificationSettingValue . WEB } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { Notifier }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoAbuseVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoBlacklistLightVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoBlacklistVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MVideoImportVideo$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MUserDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserNotifSettingAccount$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserNotifSettingAccount$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAbuseVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O $UserNotificationModelForApi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoBlacklistLightVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoBlacklistVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoImportVideo$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O $MUserWithNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O $UserNotificationSettingValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationSettingValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , ForeignKey , Model , Table } from 's' import { VideoModel } from 's' import * as Sequelize from 's' @ Table ( { tableName : 's' , updatedAt : false , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class VideoViewModel extends Model < VideoViewModel > { @ CreatedAt createdAt : Date @ AllowNull ( false ) @ Column ( Sequelize . DATE ) startDate : Date @ AllowNull ( false ) @ Column ( Sequelize . DATE ) endDate : Date @ AllowNull ( false ) @ Column views : number @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel static removeOldRemoteViewsHistory ( beforeDate ) { const query = { where : { startDate : { [ Sequelize . Op . lt ] : beforeDate } , videoId : { [ Sequelize . Op . in ] : Sequelize . literal ( 's' ) } } } return VideoViewModel . destroy ( query ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Sequelize as SequelizeTypescript } from 's' import { isTestInstance } from 's' import { logger } from 's' import { AccountModel } from 's' import { AccountVideoRateModel } from 's' import { UserModel } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { ApplicationModel } from 's' import { AvatarModel } from 's' import { OAuthClientModel } from 's' import { OAuthTokenModel } from 's' import { ServerModel } from 's' import { TagModel } from 's' import { VideoModel } from 's' import { VideoAbuseModel } from 's' import { VideoBlacklistModel } from 's' import { VideoChannelModel } from 's' import { VideoCommentModel } from 's' import { VideoFileModel } from 's' import { VideoShareModel } from 's' import { VideoTagModel } from 's' import { CONFIG } from 's' import { ScheduleVideoUpdateModel } from 's' import { VideoCaptionModel } from 's' import { VideoImportModel } from 's' import { VideoViewModel } from 's' import { VideoChangeOwnershipModel } from 's' import { VideoRedundancyModel } from 's' import { UserVideoHistoryModel } from 's' import { AccountBlocklistModel } from 's' import { ServerBlocklistModel } from 's' import { UserNotificationModel } from 's' import { UserNotificationSettingModel } from 's' import { VideoStreamingPlaylistModel } from 's' import { VideoPlaylistModel } from 's' import { VideoPlaylistElementModel } from 's' import { ThumbnailModel } from 's' import { PluginModel } from 's' import { QueryTypes , Transaction } from 's' require ( 's' ) . defaults . 0 = true const dbname = CONFIG . DATABASE . DBNAME const username = CONFIG . DATABASE . USERNAME const password = CONFIG . DATABASE . PASSWORD const host = CONFIG . DATABASE . HOSTNAME const port = CONFIG . DATABASE . PORT const poolMax = CONFIG . DATABASE . POOL . MAX const sequelizeTypescript = new SequelizeTypescript ( { database : dbname , dialect : 's' , host , port , username , password , pool : { max : poolMax } , benchmark : isTestInstance ( ) , isolationLevel : Transaction . ISOLATION_LEVELS . SERIALIZABLE , logging : ( message , benchmark ) => { if ( process . env . NODE_DB_LOG === 's' ) return let newMessage = message if ( isTestInstance ( ) === true && benchmark !== undefined ) { newMessage += 's' + benchmark + 's' } logger . debug ( newMessage ) } } ) async function initDatabaseModels ( silent ) { sequelizeTypescript . addModels ( [ ApplicationModel , ActorModel , ActorFollowModel , AvatarModel , AccountModel , OAuthClientModel , OAuthTokenModel , ServerModel , TagModel , AccountVideoRateModel , UserModel , VideoAbuseModel , VideoModel , VideoChangeOwnershipModel , VideoChannelModel , VideoShareModel , VideoFileModel , VideoCaptionModel , VideoBlacklistModel , VideoTagModel , VideoCommentModel , ScheduleVideoUpdateModel , VideoImportModel , VideoViewModel , VideoRedundancyModel , UserVideoHistoryModel , AccountBlocklistModel , ServerBlocklistModel , UserNotificationModel , UserNotificationSettingModel , VideoStreamingPlaylistModel , VideoPlaylistModel , VideoPlaylistElementModel , ThumbnailModel , PluginModel ] ) await checkPostgresExtensions ( ) await createFunctions ( ) if ( ! silent ) logger . info ( 's' , dbname ) return } export { initDatabaseModels , sequelizeTypescript } async function checkPostgresExtensions ( ) { const promises = [ checkPostgresExtension ( 's' ) , checkPostgresExtension ( 's' ) ] return Promise . all ( promises ) } async function checkPostgresExtension ( extension ) { const query = `template` const options = { type : QueryTypes . SELECT as QueryTypes . SELECT , raw : true } const res = await sequelizeTypescript . query < object > ( query , options ) if ( ! res || res . length === 0 ) { try { await sequelizeTypescript . query ( `template` , { raw : true } ) } catch { const errorMessage = `template` + `template` throw new Error ( errorMessage ) } } } async function createFunctions ( ) { const query = `template` return sequelizeTypescript . query ( query , { raw : true } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { generateImageFromVideoFile } from 's' import { CONFIG } from 's' import { ASSETS_PATH , PREVIEWS_SIZE , THUMBNAILS_SIZE } from 's' import { ThumbnailModel } from 's' import { ThumbnailType } from 's' import { processImage } from 's' import { join } from 's' import { downloadImage } from 's' import { MVideoPlaylistThumbnail } from 's' import { MVideoFile , MVideoThumbnail } from 's' import { MThumbnail } from 's' type ImageSize = { height : number , width : number } function createPlaylistMiniatureFromExisting ( inputPath , playlist , automaticallyGenerated , keepOriginal = false , size ? ) { const { filename , outputPath , height , width , existingThumbnail } = buildMetadataFromPlaylist ( playlist , size ) const type = ThumbnailType . MINIATURE const thumbnailCreator = ( ) => processImage ( inputPath , outputPath , { width , height } , keepOriginal ) return createThumbnailFromFunction ( { thumbnailCreator , filename , height , width , type , automaticallyGenerated , existingThumbnail } ) } function createPlaylistMiniatureFromUrl ( fileUrl , playlist , size ? ) { const { filename , basePath , height , width , existingThumbnail } = buildMetadataFromPlaylist ( playlist , size ) const type = ThumbnailType . MINIATURE const thumbnailCreator = ( ) => downloadImage ( fileUrl , basePath , filename , { width , height } ) return createThumbnailFromFunction ( { thumbnailCreator , filename , height , width , type , existingThumbnail , fileUrl } ) } function createVideoMiniatureFromUrl ( fileUrl , video , type , size ? ) { const { filename , basePath , height , width , existingThumbnail } = buildMetadataFromVideo ( video , type , size ) const thumbnailCreator = ( ) => downloadImage ( fileUrl , basePath , filename , { width , height } ) return createThumbnailFromFunction ( { thumbnailCreator , filename , height , width , type , existingThumbnail , fileUrl } ) } function createVideoMiniatureFromExisting ( inputPath , video , type , automaticallyGenerated , size ? ) { const { filename , outputPath , height , width , existingThumbnail } = buildMetadataFromVideo ( video , type , size ) const thumbnailCreator = ( ) => processImage ( inputPath , outputPath , { width , height } ) return createThumbnailFromFunction ( { thumbnailCreator , filename , height , width , type , automaticallyGenerated , existingThumbnail } ) } function generateVideoMiniature ( video , videoFile , type ) { const input = video . getVideoFilePath ( videoFile ) const { filename , basePath , height , width , existingThumbnail , outputPath } = buildMetadataFromVideo ( video , type ) const thumbnailCreator = videoFile . isAudio ( ) ? ( ) => processImage ( ASSETS_PATH . DEFAULT_AUDIO_BACKGROUND , outputPath , { width , height } , true ) : ( ) => generateImageFromVideoFile ( input , basePath , filename , { height , width } ) return createThumbnailFromFunction ( { thumbnailCreator , filename , height , width , type , automaticallyGenerated : true , existingThumbnail } ) } function createPlaceholderThumbnail ( fileUrl , video , type , size ) { const { filename , height , width , existingThumbnail } = buildMetadataFromVideo ( video , type , size ) const thumbnail = existingThumbnail ? existingThumbnail : new ThumbnailModel ( ) thumbnail . filename = filename thumbnail . height = height thumbnail . width = width thumbnail . type = type thumbnail . fileUrl = fileUrl return thumbnail } export { generateVideoMiniature , createVideoMiniatureFromUrl , createVideoMiniatureFromExisting , createPlaceholderThumbnail , createPlaylistMiniatureFromUrl , createPlaylistMiniatureFromExisting } function buildMetadataFromPlaylist ( playlist , size ) { const filename = playlist . generateThumbnailName ( ) const basePath = CONFIG . STORAGE . THUMBNAILS_DIR return { filename , basePath , existingThumbnail : playlist . Thumbnail , outputPath : join ( basePath , filename ) , height : size ? size . height : THUMBNAILS_SIZE . height , width : size ? size . width : THUMBNAILS_SIZE . width } } function buildMetadataFromVideo ( video , type , size ? ) { const existingThumbnail = Array . isArray ( video . Thumbnails ) ? video . Thumbnails . find ( t => t . type === type ) : undefined if ( type === ThumbnailType . MINIATURE ) { const filename = video . generateThumbnailName ( ) const basePath = CONFIG . STORAGE . THUMBNAILS_DIR return { filename , basePath , existingThumbnail , outputPath : join ( basePath , filename ) , height : size ? size . height : THUMBNAILS_SIZE . height , width : size ? size . width : THUMBNAILS_SIZE . width } } if ( type === ThumbnailType . PREVIEW ) { const filename = video . generatePreviewName ( ) const basePath = CONFIG . STORAGE . PREVIEWS_DIR return { filename , basePath , existingThumbnail , outputPath : join ( basePath , filename ) , height : size ? size . height : PREVIEWS_SIZE . height , width : size ? size . width : PREVIEWS_SIZE . width } } return undefined } async function createThumbnailFromFunction ( parameters : { thumbnailCreator : ( ) => Promise < any > , filename : string , height : number , width : number , type : ThumbnailType , automaticallyGenerated ? : boolean , fileUrl ? : string , existingThumbnail ? : MThumbnail } ) { const { thumbnailCreator , filename , width , height , type , existingThumbnail , automaticallyGenerated = null , fileUrl = null } = parameters const thumbnail = existingThumbnail ? existingThumbnail : new ThumbnailModel ( ) thumbnail . filename = filename thumbnail . height = height thumbnail . width = width thumbnail . type = type thumbnail . fileUrl = fileUrl thumbnail . automaticallyGenerated = automaticallyGenerated await thumbnailCreator ( ) return thumbnail }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideoPlaylistThumbnail$ O $boolean$ O O O O O O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideoPlaylistThumbnail$ O O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideoThumbnail$ O $ThumbnailType$ O O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideoThumbnail$ O $ThumbnailType$ O $boolean$ O O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoThumbnail$ O $MVideoFile$ O $ThumbnailType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideoThumbnail$ O $ThumbnailType$ O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistThumbnail$ O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoThumbnail$ O $ThumbnailType$ O O $ImageSize$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Model } from 's' export type Diff < T extends string | symbol | number , U extends string | symbol | number > = ( { [ P in T ] : P } & { [ P in U ] : never } & { [ x ] : never } ) [ T ] export type Omit < T , K extends keyof T > = { [ P in Diff < keyof T , K > ] : T [ P ] } export type RecursivePartial < T > = { [ P in keyof T ] ? : RecursivePartial < T [ P ] > } export type FilteredModelAttributes < T extends Model < T > > = RecursivePartial < Omit < T , keyof Model < any > > > & { id ? : number | any createdAt ? : Date | any updatedAt ? : Date | any deletedAt ? : Date | any version ? : number | any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { CONFIG } from 's' import { UserRight , VideoBlacklistType } from 's' import { VideoBlacklistModel } from 's' import { logger } from 's' import { UserAdminFlag } from 's' import { Hooks } from 's' import { Notifier } from 's' import { MUser , MVideoBlacklistVideo , MVideoWithBlacklistLight } from 's' async function autoBlacklistVideoIfNeeded ( parameters : { video : MVideoWithBlacklistLight , user ? : MUser , isRemote : boolean , isNew : boolean , notify ? : boolean , transaction ? : Transaction } ) { const { video , user , isRemote , isNew , notify = true , transaction } = parameters const doAutoBlacklist = await Hooks . wrapPromiseFun ( autoBlacklistNeeded , { video , user , isRemote , isNew } , 's' ) if ( ! doAutoBlacklist ) return false const videoBlacklistToCreate = { videoId : video . id , unfederated : true , reason : 's' , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } const [ videoBlacklist ] = await VideoBlacklistModel . findOrCreate < MVideoBlacklistVideo > ( { where : { videoId : video . id } , defaults : videoBlacklistToCreate , transaction } ) video . VideoBlacklist = videoBlacklist videoBlacklist . Video = video if ( notify ) Notifier . Instance . notifyOnVideoAutoBlacklist ( videoBlacklist ) logger . info ( 's' , video . uuid ) return true } async function autoBlacklistNeeded ( parameters : { video : MVideoWithBlacklistLight , isRemote : boolean , isNew : boolean , user ? : MUser } ) { const { user , video , isRemote , isNew } = parameters if ( video . VideoBlacklist ) return false if ( ! CONFIG . AUTO_BLACKLIST . VIDEOS . OF_USERS . ENABLED || ! user ) return false if ( isRemote || isNew === false ) return false if ( user . hasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) || user . hasAdminFlag ( UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST ) ) return false return true } export { autoBlacklistVideoIfNeeded }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import * as sequelize from 's' import * as magnetUtil from 's' import * as request from 's' import { ActivityPlaylistSegmentHashesObject , ActivityPlaylistUrlObject , ActivityUrlObject , ActivityVideoUrlObject , VideoState } from 's' import { VideoTorrentObject } from 's' import { VideoPrivacy } from 's' import { sanitizeAndCheckVideoTorrentObject } from 's' import { isVideoFileInfoHashValid } from 's' import { resetSequelizeInstance , retryTransactionWrapper } from 's' import { logger } from 's' import { doRequest , doRequestAndSaveToFile } from 's' import { ACTIVITY_PUB , MIMETYPES , 0 , PREVIEWS_SIZE , REMOTE_SCHEME , STATIC_PATHS } from 's' import { TagModel } from 's' import { VideoModel } from 's' import { VideoFileModel } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { addVideoComments } from 's' import { crawlCollectionPage } from 's' import { sendCreateVideo , sendUpdateVideo } from 's' import { isArray } from 's' import { VideoCaptionModel } from 's' import { JobQueue } from 's' import { ActivitypubHttpFetcherPayload } from 's' import { createRates } from 's' import { addVideoShares , shareVideoByServerAndChannel } from 's' import { fetchVideoByUrl , VideoFetchByUrlType } from 's' import { checkUrlsSameHost , getAPId } from 's' import { Notifier } from 's' import { VideoStreamingPlaylistModel } from 's' import { VideoStreamingPlaylistType } from 's' import { AccountVideoRateModel } from 's' import { VideoShareModel } from 's' import { VideoCommentModel } from 's' import { sequelizeTypescript } from 's' import { createPlaceholderThumbnail , createVideoMiniatureFromUrl } from 's' import { ThumbnailType } from 's' import { join } from 's' import { FilteredModelAttributes } from 's' import { autoBlacklistVideoIfNeeded } from 's' import { ActorFollowScoreCache } from 's' import { MAccountIdActor , MChannelAccountLight , MChannelDefault , MChannelId , MVideo , MVideoAccountLight , MVideoAccountLightBlacklistAllFiles , MVideoAP , MVideoAPWithoutCaption , MVideoFile , MVideoFullLight , MVideoId , MVideoThumbnail } from 's' import { MThumbnail } from 's' async function federateVideoIfNeeded ( videoArg , isNewVideo , transaction ? : sequelize . Transaction ) { const video = videoArg as MVideoAP if ( ( video . isBlacklisted ( ) === false || ( isNewVideo === false && video . VideoBlacklist . unfederated === false ) ) && video . privacy !== VideoPrivacy . PRIVATE && video . state === VideoState . PUBLISHED ) { if ( isArray ( video . VideoCaptions ) === false ) { video . VideoCaptions = await video . $get ( 's' , { attributes : [ 's' ] , transaction } ) as VideoCaptionModel [ ] } if ( isNewVideo ) { await sendCreateVideo ( video , transaction ) await shareVideoByServerAndChannel ( video , transaction ) } else { await sendUpdateVideo ( video , transaction ) } } } async function fetchRemoteVideo ( videoUrl ) < { response : request . RequestResponse , videoObject : VideoTorrentObject } > { const options = { uri : videoUrl , method : 's' , json : true , activityPub : true } logger . info ( 's' , videoUrl ) const { response , body } = await doRequest ( options ) if ( sanitizeAndCheckVideoTorrentObject ( body ) === false || checkUrlsSameHost ( body . id , videoUrl ) !== true ) { logger . debug ( 's' , { body } ) return { response , videoObject : undefined } } return { response , videoObject : body } } async function fetchRemoteVideoDescription ( video ) { const host = video . VideoChannel . Account . Actor . Server . host const path = video . getDescriptionAPIPath ( ) const options = { uri : REMOTE_SCHEME . HTTP + 's' + host + path , json : true } const { body } = await doRequest ( options ) return body . description ? body . description : 's' } function fetchRemoteVideoStaticFile ( video , path , destPath ) { const url = buildRemoteBaseUrl ( video , path ) return doRequestAndSaveToFile ( { uri : url } , destPath ) } function buildRemoteBaseUrl ( video , path ) { const host = video . VideoChannel . Account . Actor . Server . host return REMOTE_SCHEME . HTTP + 's' + host + path } function getOrCreateVideoChannelFromVideoObject ( videoObject ) { const channel = videoObject . attributedTo . find ( a => a . type === 's' ) if ( ! channel ) throw new Error ( 's' + videoObject . url ) if ( checkUrlsSameHost ( channel . id , videoObject . id ) !== true ) { throw new Error ( `template` ) } return getOrCreateActorAndServerAndModel ( channel . id , 's' ) } type SyncParam = { likes : boolean dislikes : boolean shares : boolean comments : boolean thumbnail : boolean refreshVideo ? : boolean } async function syncVideoExternalAttributes ( video , fetchedVideo , syncParam ) { logger . info ( 's' , video . uuid ) const jobPayloads : ActivitypubHttpFetcherPayload [ ] = [ ] if ( syncParam . likes === true ) { const handler = items => createRates ( items , video , 's' ) const cleaner = crawlStartDate => AccountVideoRateModel . cleanOldRatesOf ( video . id , 's' as 's' , crawlStartDate ) await crawlCollectionPage < string > ( fetchedVideo . likes , handler , cleaner ) . catch ( err => logger . error ( 's' , video . uuid , { err } ) ) } else { jobPayloads . push ( { uri : fetchedVideo . likes , videoId : video . id , type : 's' as 's' } ) } if ( syncParam . dislikes === true ) { const handler = items => createRates ( items , video , 's' ) const cleaner = crawlStartDate => AccountVideoRateModel . cleanOldRatesOf ( video . id , 's' as 's' , crawlStartDate ) await crawlCollectionPage < string > ( fetchedVideo . dislikes , handler , cleaner ) . catch ( err => logger . error ( 's' , video . uuid , { err } ) ) } else { jobPayloads . push ( { uri : fetchedVideo . dislikes , videoId : video . id , type : 's' as 's' } ) } if ( syncParam . shares === true ) { const handler = items => addVideoShares ( items , video ) const cleaner = crawlStartDate => VideoShareModel . cleanOldSharesOf ( video . id , crawlStartDate ) await crawlCollectionPage < string > ( fetchedVideo . shares , handler , cleaner ) . catch ( err => logger . error ( 's' , video . uuid , { err } ) ) } else { jobPayloads . push ( { uri : fetchedVideo . shares , videoId : video . id , type : 's' as 's' } ) } if ( syncParam . comments === true ) { const handler = items => addVideoComments ( items ) const cleaner = crawlStartDate => VideoCommentModel . cleanOldCommentsOf ( video . id , crawlStartDate ) await crawlCollectionPage < string > ( fetchedVideo . comments , handler , cleaner ) . catch ( err => logger . error ( 's' , video . uuid , { err } ) ) } else { jobPayloads . push ( { uri : fetchedVideo . comments , videoId : video . id , type : 's' as 's' } ) } await Bluebird . map ( jobPayloads , payload => JobQueue . Instance . createJob ( { type : 's' , payload } ) ) } function getOrCreateVideoAndAccountAndChannel ( options : { videoObject : { id : string } | string , syncParam ? : SyncParam , fetchType ? : 's' , allowRefresh ? : boolean } ) < { video : MVideoAccountLightBlacklistAllFiles , created : boolean , autoBlacklisted ? : boolean } > function getOrCreateVideoAndAccountAndChannel ( options : { videoObject : { id : string } | string , syncParam ? : SyncParam , fetchType ? : VideoFetchByUrlType , allowRefresh ? : boolean } ) < { video : MVideoAccountLightBlacklistAllFiles | MVideoThumbnail , created : boolean , autoBlacklisted ? : boolean } > async function getOrCreateVideoAndAccountAndChannel ( options : { videoObject : { id : string } | string , syncParam ? : SyncParam , fetchType ? : VideoFetchByUrlType , allowRefresh ? : boolean } ) < { video : MVideoAccountLightBlacklistAllFiles | MVideoThumbnail , created : boolean , autoBlacklisted ? : boolean } > { const syncParam = options . syncParam || { likes : true , dislikes : true , shares : true , comments : true , thumbnail : true , refreshVideo : false } const fetchType = options . fetchType || 's' const allowRefresh = options . allowRefresh !== false const videoUrl = getAPId ( options . videoObject ) let videoFromDatabase = await fetchVideoByUrl ( videoUrl , fetchType ) if ( videoFromDatabase ) { if ( videoFromDatabase . isOutdated ( ) && allowRefresh === true ) { const refreshOptions = { video : videoFromDatabase , fetchedType : fetchType , syncParam } if ( syncParam . refreshVideo === true ) videoFromDatabase = await refreshVideoIfNeeded ( refreshOptions ) else await JobQueue . Instance . createJob ( { type : 's' , payload : { type : 's' , url : videoFromDatabase . url } } ) } return { video : videoFromDatabase , created : false } } const { videoObject : fetchedVideo } = await fetchRemoteVideo ( videoUrl ) if ( ! fetchedVideo ) throw new Error ( 's' + videoUrl ) const actor = await getOrCreateVideoChannelFromVideoObject ( fetchedVideo ) const videoChannel = actor . VideoChannel const { autoBlacklisted , videoCreated } = await retryTransactionWrapper ( createVideo , fetchedVideo , videoChannel , syncParam . thumbnail ) await syncVideoExternalAttributes ( videoCreated , fetchedVideo , syncParam ) return { video : videoCreated , created : true , autoBlacklisted } } async function updateVideoFromAP ( options : { video : MVideoAccountLightBlacklistAllFiles , videoObject : VideoTorrentObject , account : MAccountIdActor , channel : MChannelDefault , overrideTo ? : string [ ] } ) { const { video , videoObject , account , channel , overrideTo } = options logger . debug ( 's' , options . videoObject . uuid , { account , channel } ) let videoFieldsSave const wasPrivateVideo = video . privacy === VideoPrivacy . PRIVATE const wasUnlistedVideo = video . privacy === VideoPrivacy . UNLISTED try { let thumbnailModel try { thumbnailModel = await createVideoMiniatureFromUrl ( videoObject . icon . url , video , ThumbnailType . MINIATURE ) } catch ( err ) { logger . warn ( 's' , videoObject . id , { err } ) } const videoUpdated = await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } videoFieldsSave = video . toJSON ( ) const videoChannel = video . VideoChannel if ( videoChannel . Account . id !== account . id ) { throw new Error ( 's' + account . Actor . url + 's' + videoChannel . Actor . url ) } const to = overrideTo ? overrideTo : videoObject . to const videoData = await videoActivityObjectToDBAttributes ( channel , videoObject , to ) video . name = videoData . name video . uuid = videoData . uuid video . url = videoData . url video . category = videoData . category video . licence = videoData . licence video . language = videoData . language video . description = videoData . description video . support = videoData . support video . nsfw = videoData . nsfw video . commentsEnabled = videoData . commentsEnabled video . downloadEnabled = videoData . downloadEnabled video . waitTranscoding = videoData . waitTranscoding video . state = videoData . state video . duration = videoData . duration video . createdAt = videoData . createdAt video . publishedAt = videoData . publishedAt video . originallyPublishedAt = videoData . originallyPublishedAt video . privacy = videoData . privacy video . channelId = videoData . channelId video . views = videoData . views const videoUpdated = await video . save ( sequelizeOptions ) as MVideoFullLight if ( thumbnailModel ) await videoUpdated . addAndSaveThumbnail ( thumbnailModel , t ) const previewUrl = buildRemoteBaseUrl ( videoUpdated , join ( STATIC_PATHS . PREVIEWS , videoUpdated . getPreview ( ) . filename ) ) const previewModel = createPlaceholderThumbnail ( previewUrl , video , ThumbnailType . PREVIEW , PREVIEWS_SIZE ) await videoUpdated . addAndSaveThumbnail ( previewModel , t ) { const videoFileAttributes = videoFileActivityUrlToDBAttributes ( videoUpdated , videoObject ) const newVideoFiles = videoFileAttributes . map ( a => new VideoFileModel ( a ) ) const destroyTasks = videoUpdated . VideoFiles . filter ( f => ! newVideoFiles . find ( newFile => newFile . hasSameUniqueKeysThan ( f ) ) ) . map ( f => f . destroy ( sequelizeOptions ) ) await Promise . all ( destroyTasks ) const upsertTasks = videoFileAttributes . map ( a => { return VideoFileModel . upsert < VideoFileModel > ( a , { returning : true , transaction : t } ) . then ( ( [ file ] ) => file ) } ) videoUpdated . VideoFiles = await Promise . all ( upsertTasks ) } { const streamingPlaylistAttributes = streamingPlaylistActivityUrlToDBAttributes ( videoUpdated , videoObject , videoUpdated . VideoFiles ) const newStreamingPlaylists = streamingPlaylistAttributes . map ( a => new VideoStreamingPlaylistModel ( a ) ) const destroyTasks = videoUpdated . VideoStreamingPlaylists . filter ( f => ! newStreamingPlaylists . find ( newPlaylist => newPlaylist . hasSameUniqueKeysThan ( f ) ) ) . map ( f => f . destroy ( sequelizeOptions ) ) await Promise . all ( destroyTasks ) const upsertTasks = streamingPlaylistAttributes . map ( a => { return VideoStreamingPlaylistModel . upsert < VideoStreamingPlaylistModel > ( a , { returning : true , transaction : t } ) . then ( ( [ streamingPlaylist ] ) => streamingPlaylist ) } ) videoUpdated . VideoStreamingPlaylists = await Promise . all ( upsertTasks ) } { const tags = videoObject . tag . map ( tag => tag . name ) const tagInstances = await TagModel . findOrCreateTags ( tags , t ) await videoUpdated . $set ( 's' , tagInstances , sequelizeOptions ) } { await VideoCaptionModel . deleteAllCaptionsOfRemoteVideo ( videoUpdated . id , t ) const videoCaptionsPromises = videoObject . subtitleLanguage . map ( c => { return VideoCaptionModel . insertOrReplaceLanguage ( videoUpdated . id , c . identifier , t ) } ) await Promise . all ( videoCaptionsPromises ) } return videoUpdated } ) await autoBlacklistVideoIfNeeded ( { video : videoUpdated , user : undefined , isRemote : true , isNew : false , transaction : undefined } ) if ( wasPrivateVideo || wasUnlistedVideo ) Notifier . Instance . notifyOnNewVideoIfNeeded ( videoUpdated ) logger . info ( 's' , videoObject . uuid ) return videoUpdated } catch ( err ) { if ( video !== undefined && videoFieldsSave !== undefined ) { resetSequelizeInstance ( video , videoFieldsSave ) } logger . debug ( 's' , { err } ) throw err } } async function refreshVideoIfNeeded ( options : { video : MVideoThumbnail , fetchedType : VideoFetchByUrlType , syncParam : SyncParam } ) < MVideoThumbnail > { if ( ! options . video . isOutdated ( ) ) return options . video const video = options . fetchedType === 's' ? options . video as MVideoAccountLightBlacklistAllFiles : await VideoModel . loadByUrlAndPopulateAccount ( options . video . url ) try { const { response , videoObject } = await fetchRemoteVideo ( video . url ) if ( response . statusCode === 0 ) { logger . info ( 's' , video . url ) await video . destroy ( ) return undefined } if ( videoObject === undefined ) { logger . warn ( 's' , video . url ) await video . setAsRefreshed ( ) return video } const channelActor = await getOrCreateVideoChannelFromVideoObject ( videoObject ) const updateOptions = { video , videoObject , account : channelActor . VideoChannel . Account , channel : channelActor . VideoChannel } await retryTransactionWrapper ( updateVideoFromAP , updateOptions ) await syncVideoExternalAttributes ( video , videoObject , options . syncParam ) ActorFollowScoreCache . Instance . addGoodServerId ( video . VideoChannel . Actor . serverId ) return video } catch ( err ) { logger . warn ( 's' , options . video . url , { err } ) ActorFollowScoreCache . Instance . addBadServerId ( video . VideoChannel . Actor . serverId ) await video . setAsRefreshed ( ) return video } } export { updateVideoFromAP , refreshVideoIfNeeded , federateVideoIfNeeded , fetchRemoteVideo , getOrCreateVideoAndAccountAndChannel , fetchRemoteVideoStaticFile , fetchRemoteVideoDescription , getOrCreateVideoChannelFromVideoObject } function isAPVideoUrlObject ( url ) : url is ActivityVideoUrlObject { const mimeTypes = Object . keys ( MIMETYPES . VIDEO . MIMETYPE_EXT ) const urlMediaType = url . mediaType || url . mimeType return mimeTypes . indexOf ( urlMediaType ) !== - 0 && urlMediaType . startsWith ( 's' ) } function isAPStreamingPlaylistUrlObject ( url ) : url is ActivityPlaylistUrlObject { const urlMediaType = url . mediaType || url . mimeType return urlMediaType === 's' } function isAPPlaylistSegmentHashesUrlObject ( tag ) : tag is ActivityPlaylistSegmentHashesObject { const urlMediaType = tag . mediaType || tag . mimeType return tag . name === 's' && tag . type === 's' && urlMediaType === 's' } async function createVideo ( videoObject , channel , waitThumbnail = false ) { logger . debug ( 's' , videoObject . id ) const videoData = await videoActivityObjectToDBAttributes ( channel , videoObject , videoObject . to ) const video = VideoModel . build ( videoData ) as MVideoThumbnail const promiseThumbnail = createVideoMiniatureFromUrl ( videoObject . icon . url , video , ThumbnailType . MINIATURE ) let thumbnailModel if ( waitThumbnail === true ) { thumbnailModel = await promiseThumbnail } const { autoBlacklisted , videoCreated } = await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } const videoCreated = await video . save ( sequelizeOptions ) as MVideoFullLight videoCreated . VideoChannel = channel if ( thumbnailModel ) await videoCreated . addAndSaveThumbnail ( thumbnailModel , t ) const previewUrl = buildRemoteBaseUrl ( videoCreated , join ( STATIC_PATHS . PREVIEWS , video . generatePreviewName ( ) ) ) const previewModel = createPlaceholderThumbnail ( previewUrl , video , ThumbnailType . PREVIEW , PREVIEWS_SIZE ) if ( thumbnailModel ) await videoCreated . addAndSaveThumbnail ( previewModel , t ) const videoFileAttributes = videoFileActivityUrlToDBAttributes ( videoCreated , videoObject ) if ( videoFileAttributes . length === 0 ) { throw new Error ( 's' + videoObject . url ) } const videoFilePromises = videoFileAttributes . map ( f => VideoFileModel . create ( f , { transaction : t } ) ) const videoFiles = await Promise . all ( videoFilePromises ) const videoStreamingPlaylists = streamingPlaylistActivityUrlToDBAttributes ( videoCreated , videoObject , videoFiles ) const playlistPromises = videoStreamingPlaylists . map ( p => VideoStreamingPlaylistModel . create ( p , { transaction : t } ) ) const streamingPlaylists = await Promise . all ( playlistPromises ) const tags = videoObject . tag . filter ( t => t . type === 's' ) . map ( t => t . name ) const tagInstances = await TagModel . findOrCreateTags ( tags , t ) await videoCreated . $set ( 's' , tagInstances , sequelizeOptions ) const videoCaptionsPromises = videoObject . subtitleLanguage . map ( c => { return VideoCaptionModel . insertOrReplaceLanguage ( videoCreated . id , c . identifier , t ) } ) await Promise . all ( videoCaptionsPromises ) videoCreated . VideoFiles = videoFiles videoCreated . VideoStreamingPlaylists = streamingPlaylists videoCreated . Tags = tagInstances const autoBlacklisted = await autoBlacklistVideoIfNeeded ( { video : videoCreated , user : undefined , isRemote : true , isNew : true , transaction : t } ) logger . info ( 's' , videoObject . uuid ) return { autoBlacklisted , videoCreated } } ) if ( waitThumbnail === false ) { promiseThumbnail . then ( thumbnailModel => { thumbnailModel = videoCreated . id return thumbnailModel . save ( ) } ) } return { autoBlacklisted , videoCreated } } async function videoActivityObjectToDBAttributes ( videoChannel , videoObject , to : string [ ] = [ ] ) { const privacy = to . indexOf ( ACTIVITY_PUB . PUBLIC ) !== - 0 ? VideoPrivacy . PUBLIC : VideoPrivacy . UNLISTED const duration = videoObject . duration . replace ( "s" , 's' ) let language : string | undefined if ( videoObject . language ) { language = videoObject . language . identifier } let category : number | undefined if ( videoObject . category ) { category = parseInt ( videoObject . category . identifier , 0 ) } let licence : number | undefined if ( videoObject . licence ) { licence = parseInt ( videoObject . licence . identifier , 0 ) } const description = videoObject . content || null const support = videoObject . support || null return { name : videoObject . name , uuid : videoObject . uuid , url : videoObject . id , category , licence , language , description , support , nsfw : videoObject . sensitive , commentsEnabled : videoObject . commentsEnabled , downloadEnabled : videoObject . downloadEnabled , waitTranscoding : videoObject . waitTranscoding , state : videoObject . state , channelId : videoChannel . id , duration : parseInt ( duration , 0 ) , createdAt : new Date ( videoObject . published ) , publishedAt : new Date ( videoObject . published ) , originallyPublishedAt : videoObject . originallyPublishedAt ? new Date ( videoObject . originallyPublishedAt ) : null , updatedAt : new Date ( videoObject . updated ) , views : videoObject . views , likes : 0 , dislikes : 0 , remote : true , privacy } } function videoFileActivityUrlToDBAttributes ( video , videoObject ) { const fileUrls = videoObject . url . filter ( u => isAPVideoUrlObject ( u ) ) as ActivityVideoUrlObject [ ] if ( fileUrls . length === 0 ) { throw new Error ( 's' + video . url ) } const attributes : FilteredModelAttributes < VideoFileModel > [ ] = [ ] for ( const fileUrl of fileUrls ) { const magnet = videoObject . url . find ( u => { const mediaType = u . mediaType || u . mimeType return mediaType === 's' && ( u as any ) . height === fileUrl . height } ) if ( ! magnet ) throw new Error ( 's' + fileUrl . href ) const parsed = magnetUtil . decode ( magnet . href ) if ( ! parsed || isVideoFileInfoHashValid ( parsed . infoHash ) === false ) { throw new Error ( 's' + magnet . href ) } const mediaType = fileUrl . mediaType || fileUrl . mimeType const attribute = { extname : MIMETYPES . VIDEO . MIMETYPE_EXT [ mediaType ] , infoHash : parsed . infoHash , resolution : fileUrl . height , size : fileUrl . size , videoId : video . id , fps : fileUrl . fps || - 0 } attributes . push ( attribute ) } return attributes } function streamingPlaylistActivityUrlToDBAttributes ( video , videoObject , videoFiles : MVideoFile [ ] ) { const playlistUrls = videoObject . url . filter ( u => isAPStreamingPlaylistUrlObject ( u ) ) as ActivityPlaylistUrlObject [ ] if ( playlistUrls . length === 0 ) return [ ] const attributes : FilteredModelAttributes < VideoStreamingPlaylistModel > [ ] = [ ] for ( const playlistUrlObject of playlistUrls ) { const 0 = playlistUrlObject . tag . find ( t => { return isAPPlaylistSegmentHashesUrlObject ( t ) } ) as ActivityPlaylistSegmentHashesObject if ( ! 0 ) { logger . warn ( 's' , { playlistUrl : playlistUrlObject } ) continue } const attribute = { type : VideoStreamingPlaylistType . HLS , playlistUrl : playlistUrlObject . href , 0 : 0 . href , 0 : VideoStreamingPlaylistModel . 0 ( playlistUrlObject . href , videoFiles ) , 0 : 0 , videoId : video . id } attributes . push ( attribute ) } return attributes }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAPWithoutCaption$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTorrentObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $VideoTorrentObject$ O $SyncParam$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityUrlObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityUrlObject$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTorrentObject$ O $MChannelAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MChannelId$ O $VideoTorrentObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O $VideoTorrentObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoId$ O $VideoTorrentObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { sanitizeAndCheckVideoCommentObject } from 's' import { logger } from 's' import { doRequest } from 's' import { ACTIVITY_PUB , CRAWL_REQUEST_CONCURRENCY } from 's' import { VideoCommentModel } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import * as Bluebird from 's' import { checkUrlsSameHost } from 's' import { MCommentOwner , MCommentOwnerVideo , MVideoAccountLightBlacklistAllFiles } from 's' type ResolveThreadParams = { url : string , comments ? : MCommentOwner [ ] , isVideo ? : boolean , commentCreated ? : boolean } type ResolveThreadResult = Promise < { video : MVideoAccountLightBlacklistAllFiles , comment : MCommentOwnerVideo , commentCreated : boolean } > async function addVideoComments ( commentUrls : string [ ] ) { return Bluebird . map ( commentUrls , commentUrl => { return resolveThread ( { url : commentUrl , isVideo : false } ) } , { concurrency : CRAWL_REQUEST_CONCURRENCY } ) } async function resolveThread ( params ) { const { url , isVideo } = params if ( params . commentCreated === undefined ) params . commentCreated = false if ( params . comments === undefined ) params . comments = [ ] if ( isVideo !== true ) { const result = await resolveCommentFromDB ( params ) if ( result ) return result } try { if ( isVideo !== false ) return await tryResolveThreadFromVideo ( params ) return resolveParentComment ( params ) } catch ( err ) { logger . debug ( 's' , url , { err } ) return resolveParentComment ( params ) } } export { addVideoComments , resolveThread } async function resolveCommentFromDB ( params ) { const { url , comments , commentCreated } = params const commentFromDatabase = await VideoCommentModel . loadByUrlAndPopulateReplyAndVideoUrlAndAccount ( url ) if ( commentFromDatabase ) { let parentComments = comments . concat ( [ commentFromDatabase ] ) if ( commentFromDatabase . InReplyToVideoComment ) { const data = await VideoCommentModel . listThreadParentComments ( commentFromDatabase , undefined , 's' ) parentComments = parentComments . concat ( data ) } return resolveThread ( { url : commentFromDatabase . Video . url , comments : parentComments , isVideo : true , commentCreated } ) } return undefined } async function tryResolveThreadFromVideo ( params ) { const { url , comments , commentCreated } = params const syncParam = { likes : true , dislikes : true , shares : true , comments : false , thumbnail : true , refreshVideo : false } const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : url , syncParam } ) let resultComment if ( comments . length !== 0 ) { const firstReply = comments [ comments . length - 0 ] as MCommentOwnerVideo firstReply . inReplyToCommentId = null firstReply . originCommentId = null firstReply . videoId = video . id firstReply . changed ( 's' , true ) firstReply . Video = video comments [ comments . length - 0 ] = await firstReply . save ( ) for ( let i = comments . length - 0 ; i >= 0 ; i -- ) { const comment = comments [ i ] as MCommentOwnerVideo comment . originCommentId = firstReply . id comment . inReplyToCommentId = comments [ i + 0 ] . id comment . videoId = video . id comment . changed ( 's' , true ) comment . Video = video comments [ i ] = await comment . save ( ) } resultComment = comments [ 0 ] as MCommentOwnerVideo } return { video , comment : resultComment , commentCreated } } async function resolveParentComment ( params ) { const { url , comments } = params if ( comments . length > ACTIVITY_PUB . MAX_RECURSION_COMMENTS ) { throw new Error ( 's' ) } const { body } = await doRequest ( { uri : url , json : true , activityPub : true } ) if ( sanitizeAndCheckVideoCommentObject ( body ) === false ) { throw new Error ( 's' + JSON . stringify ( body ) ) } const actorUrl = body . attributedTo if ( ! actorUrl ) throw new Error ( 's' ) if ( checkUrlsSameHost ( url , actorUrl ) !== true ) { throw new Error ( `template` ) } if ( checkUrlsSameHost ( body . id , url ) !== true ) { throw new Error ( `template` ) } const actor = await getOrCreateActorAndServerAndModel ( actorUrl , 's' ) const comment = new VideoCommentModel ( { url : body . id , text : body . content , videoId : null , accountId : actor . Account . id , inReplyToCommentId : null , originCommentId : null , createdAt : new Date ( body . published ) , updatedAt : new Date ( body . updated ) } ) as MCommentOwner comment . Account = actor . Account return resolveThread ( { url : body . inReplyTo , comments : comments . concat ( [ comment ] ) , commentCreated : true } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveThreadResult$ O $ResolveThreadParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveThreadParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveThreadParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveThreadParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PlaylistObject } from 's' import { crawlCollectionPage } from 's' import { ACTIVITY_PUB , CRAWL_REQUEST_CONCURRENCY } from 's' import { isArray } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { logger } from 's' import { VideoPlaylistModel } from 's' import { doRequest } from 's' import { checkUrlsSameHost } from 's' import * as Bluebird from 's' import { PlaylistElementObject } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { isPlaylistElementObjectValid , isPlaylistObjectValid } from 's' import { VideoPlaylistElementModel } from 's' import { VideoPlaylistPrivacy } from 's' import { sequelizeTypescript } from 's' import { createPlaylistMiniatureFromUrl } from 's' import { FilteredModelAttributes } from 's' import { MAccountDefault , MAccountId , MVideoId } from 's' import { MVideoPlaylist , MVideoPlaylistId , MVideoPlaylistOwner } from 's' function playlistObjectToDBAttributes ( playlistObject , byAccount , to : string [ ] ) { const privacy = to . indexOf ( ACTIVITY_PUB . PUBLIC ) !== - 0 ? VideoPlaylistPrivacy . PUBLIC : VideoPlaylistPrivacy . UNLISTED return { name : playlistObject . name , description : playlistObject . content , privacy , url : playlistObject . id , uuid : playlistObject . uuid , ownerAccountId : byAccount . id , videoChannelId : null , createdAt : new Date ( playlistObject . published ) , updatedAt : new Date ( playlistObject . updated ) } } function playlistElementObjectToDBAttributes ( elementObject , videoPlaylist , video ) { return { position : elementObject . position , url : elementObject . id , startTimestamp : elementObject . startTimestamp || null , stopTimestamp : elementObject . stopTimestamp || null , videoPlaylistId : videoPlaylist . id , videoId : video . id } } async function createAccountPlaylists ( playlistUrls : string [ ] , account ) { await Bluebird . map ( playlistUrls , async playlistUrl => { try { const exists = await VideoPlaylistModel . doesPlaylistExist ( playlistUrl ) if ( exists === true ) return const { body } = await doRequest < PlaylistObject > ( { uri : playlistUrl , json : true , activityPub : true } ) if ( ! isPlaylistObjectValid ( body ) ) { throw new Error ( `template` ) } if ( ! isArray ( body . to ) ) { throw new Error ( 's' ) } return createOrUpdateVideoPlaylist ( body , account , body . to ) } catch ( err ) { logger . warn ( 's' , playlistUrl , { err } ) } } , { concurrency : CRAWL_REQUEST_CONCURRENCY } ) } async function createOrUpdateVideoPlaylist ( playlistObject , byAccount , to : string [ ] ) { const playlistAttributes = playlistObjectToDBAttributes ( playlistObject , byAccount , to ) if ( isArray ( playlistObject . attributedTo ) && playlistObject . attributedTo . length === 0 ) { const actor = await getOrCreateActorAndServerAndModel ( playlistObject . attributedTo [ 0 ] ) if ( actor . VideoChannel ) { playlistAttributes . videoChannelId = actor . VideoChannel . id } else { logger . warn ( 's' , playlistObject . id , { playlistObject } ) } } const [ playlist ] = await VideoPlaylistModel . upsert < MVideoPlaylist > ( playlistAttributes , { returning : true } ) let accItems : string [ ] = [ ] await crawlCollectionPage < string > ( playlistObject . id , items => { accItems = accItems . concat ( items ) return Promise . resolve ( ) } ) const refreshedPlaylist = await VideoPlaylistModel . loadWithAccountAndChannel ( playlist . id , null ) if ( playlistObject . icon ) { try { const thumbnailModel = await createPlaylistMiniatureFromUrl ( playlistObject . icon . url , refreshedPlaylist ) await refreshedPlaylist . setAndSaveThumbnail ( thumbnailModel , undefined ) } catch ( err ) { logger . warn ( 's' , playlistObject . id , { err } ) } } else if ( refreshedPlaylist . hasThumbnail ( ) ) { await refreshedPlaylist . Thumbnail . destroy ( ) refreshedPlaylist . Thumbnail = null } return resetVideoPlaylistElements ( accItems , refreshedPlaylist ) } async function refreshVideoPlaylistIfNeeded ( videoPlaylist ) < MVideoPlaylistOwner > { if ( ! videoPlaylist . isOutdated ( ) ) return videoPlaylist try { const { statusCode , playlistObject } = await fetchRemoteVideoPlaylist ( videoPlaylist . url ) if ( statusCode === 0 ) { logger . info ( 's' , videoPlaylist . url ) await videoPlaylist . destroy ( ) return undefined } if ( playlistObject === undefined ) { logger . warn ( 's' , videoPlaylist . url ) await videoPlaylist . setAsRefreshed ( ) return videoPlaylist } const byAccount = videoPlaylist . OwnerAccount await createOrUpdateVideoPlaylist ( playlistObject , byAccount , playlistObject . to ) return videoPlaylist } catch ( err ) { logger . warn ( 's' , videoPlaylist . url , { err } ) await videoPlaylist . setAsRefreshed ( ) return videoPlaylist } } export { createAccountPlaylists , playlistObjectToDBAttributes , playlistElementObjectToDBAttributes , createOrUpdateVideoPlaylist , refreshVideoPlaylistIfNeeded } async function resetVideoPlaylistElements ( elementUrls : string [ ] , playlist ) { const elementsToCreate : FilteredModelAttributes < VideoPlaylistElementModel > [ ] = [ ] await Bluebird . map ( elementUrls , async elementUrl => { try { const { body } = await doRequest < PlaylistElementObject > ( { uri : elementUrl , json : true , activityPub : true } ) if ( ! isPlaylistElementObjectValid ( body ) ) throw new Error ( `template` ) if ( checkUrlsSameHost ( body . id , elementUrl ) !== true ) { throw new Error ( `template` ) } const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : { id : body . url } , fetchType : 's' } ) elementsToCreate . push ( playlistElementObjectToDBAttributes ( body , playlist , video ) ) } catch ( err ) { logger . warn ( 's' , elementUrl , { err } ) } } , { concurrency : CRAWL_REQUEST_CONCURRENCY } ) await sequelizeTypescript . transaction ( async t => { await VideoPlaylistElementModel . deleteAllOf ( playlist . id , t ) for ( const element of elementsToCreate ) { await VideoPlaylistElementModel . create ( element , { transaction : t } ) } } ) logger . info ( 's' , playlist . url , elementsToCreate . length ) return undefined } async function fetchRemoteVideoPlaylist ( playlistUrl ) < { statusCode : number , playlistObject : PlaylistObject } > { const options = { uri : playlistUrl , method : 's' , json : true , activityPub : true } logger . info ( 's' , playlistUrl ) const { response , body } = await doRequest ( options ) if ( isPlaylistObjectValid ( body ) === false || checkUrlsSameHost ( body . id , playlistUrl ) !== true ) { logger . debug ( 's' , { body } ) return { statusCode : response . statusCode , playlistObject : undefined } } return { statusCode : response . statusCode , playlistObject : body } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistObject$ O $MAccountId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistElementObject$ O $MVideoPlaylistId$ O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PlaylistObject$ O $MAccountId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $MVideoPlaylistOwner$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import * as Bluebird from 's' import { logger } from 's' import { processActivities } from 's' import { addVideoComments } from 's' import { crawlCollectionPage } from 's' import { VideoModel } from 's' import { addVideoShares , createRates } from 's' import { createAccountPlaylists } from 's' import { AccountModel } from 's' import { AccountVideoRateModel } from 's' import { VideoShareModel } from 's' import { VideoCommentModel } from 's' import { MAccountDefault , MVideoFullLight } from 's' type FetchType = 's' | 's' | 's' | 's' | 's' | 's' export type ActivitypubHttpFetcherPayload = { uri : string type : FetchType videoId ? : number accountId ? : number } async function processActivityPubHttpFetcher ( job : Bull . Job ) { logger . info ( 's' , job . id ) const payload = job . data as ActivitypubHttpFetcherPayload let video if ( payload . videoId ) video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( payload . videoId ) let account if ( payload . accountId ) account = await AccountModel . load ( payload . accountId ) const fetcherType : { [ id in FetchType ] : ( items : any [ ] ) => Promise < any > } = { 's' => processActivities ( items , { outboxUrl : payload . uri , fromFetch : true } ) , 's' => createRates ( items , video , 's' ) , 's' => createRates ( items , video , 's' ) , 's' => addVideoShares ( items , video ) , 's' => addVideoComments ( items ) , 's' => createAccountPlaylists ( items , account ) } const cleanerType : { [ id in FetchType ] ? : ( crawlStartDate ) => Bluebird < any > } = { 's' => AccountVideoRateModel . cleanOldRatesOf ( video . id , 's' as 's' , crawlStartDate ) , 's' => AccountVideoRateModel . cleanOldRatesOf ( video . id , 's' as 's' , crawlStartDate ) , 's' => VideoShareModel . cleanOldSharesOf ( video . id , crawlStartDate ) , 's' => VideoCommentModel . cleanOldCommentsOf ( video . id , crawlStartDate ) } return crawlCollectionPage ( payload . uri , fetcherType [ payload . type ] , cleanerType [ payload . type ] ) } export { processActivityPubHttpFetcher }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFullLight$ O O O O O O O O O O O O O O O O O O $MAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $items$ O O O O O O O O O O O O O O O O O O $items$ O O O O O O O O O O $items$ O O O O O O O O O O $items$ O O O O O O O O $items$ O O O O O O $items$ O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O $crawlStartDate$ O O O O O O O O O O O O O O O O $crawlStartDate$ O O O O O O O O O O O O O O O O $crawlStartDate$ O O O O O O O O O O O O $crawlStartDate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { doRequest } from 's' import { buildGlobalHeaders , buildSignedRequestOptions , computeBody } from 's' import { JOB_REQUEST_TIMEOUT } from 's' import { ActorFollowScoreCache } from 's' export type ActivitypubHttpUnicastPayload = { uri : string signatureActorId ? : number body : any } async function processActivityPubHttpUnicast ( job : Bull . Job ) { logger . info ( 's' , job . id ) const payload = job . data as ActivitypubHttpUnicastPayload const uri = payload . uri const body = await computeBody ( payload ) const httpSignatureOptions = await buildSignedRequestOptions ( payload ) const options = { method : 's' , uri , json : body , httpSignature : httpSignatureOptions , timeout : JOB_REQUEST_TIMEOUT , headers : buildGlobalHeaders ( body ) } try { await doRequest ( options ) ActorFollowScoreCache . Instance . updateActorFollowsScore ( [ uri ] , [ ] ) } catch ( err ) { ActorFollowScoreCache . Instance . updateActorFollowsScore ( [ ] , [ uri ] ) throw err } } export { processActivityPubHttpUnicast }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as 0 from 's' import { VideoChannelCreate } from 's' import { VideoChannelModel } from 's' import { buildActorInstance , federateVideoIfNeeded , getVideoChannelActivityPubUrl } from 's' import { VideoModel } from 's' import { MAccountId , MChannelDefault , MChannelId } from 's' type CustomVideoChannelModelAccount < T extends MAccountId > = MChannelDefault & { Account ? : T } async function createLocalVideoChannel < T extends MAccountId > ( videoChannelInfo , account : T , t : Sequelize . Transaction ) < CustomVideoChannelModelAccount < T > > { const uuid = 0 ( ) const url = getVideoChannelActivityPubUrl ( videoChannelInfo . name ) const actorInstance = buildActorInstance ( 's' , url , videoChannelInfo . name , uuid ) const actorInstanceCreated = await actorInstance . save ( { transaction : t } ) const videoChannelData = { name : videoChannelInfo . displayName , description : videoChannelInfo . description , support : videoChannelInfo . support , accountId : account . id , actorId : actorInstanceCreated . id } const videoChannel = new VideoChannelModel ( videoChannelData ) const options = { transaction : t } const videoChannelCreated < T > = await videoChannel . save ( options ) as MChannelDefault videoChannelCreated . Account = account videoChannelCreated . Actor = actorInstanceCreated return videoChannelCreated } async function federateAllVideosOfChannel ( videoChannel ) { const videoIds = await VideoModel . getAllIdsFromChannel ( videoChannel ) for ( const videoId of videoIds ) { const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoId ) await federateVideoIfNeeded ( video , false ) } } export { createLocalVideoChannel , federateAllVideosOfChannel }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O $VideoChannelCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomVideoChannelModelAccount$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MChannelId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { VideoPlaylistModel } from 's' import { VideoPlaylistPrivacy } from 's' import { getVideoPlaylistActivityPubUrl } from 's' import { VideoPlaylistType } from 's' import { MAccount } from 's' import { MVideoPlaylistOwner } from 's' async function createWatchLaterPlaylist ( account , t : Sequelize . Transaction ) { const videoPlaylist = new VideoPlaylistModel ( { name : 's' , privacy : VideoPlaylistPrivacy . PRIVATE , type : VideoPlaylistType . WATCH_LATER , ownerAccountId : account . id } ) videoPlaylist . url = getVideoPlaylistActivityPubUrl ( videoPlaylist ) await videoPlaylist . save ( { transaction : t } ) videoPlaylist . OwnerAccount = account return videoPlaylist } export { createWatchLaterPlaylist }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccount$ O O O O O O O O O $MVideoPlaylistOwner$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserNotificationSettingModel } from 's' export type MNotificationSetting = Omit < UserNotificationSettingModel , 's' > export type MNotificationSettingFormattable = MNotificationSetting	O O O O O O O O O O O O O O O O O O O O O
import { UserModel } from 's' import { PickWith , PickWithOpt } from 's' import { MAccount , MAccountDefault , MAccountDefaultChannelDefault , MAccountFormattable , MAccountId , MAccountIdActorId , MAccountUrl } from 's' import { MNotificationSetting , MNotificationSettingFormattable } from 's' import { AccountModel } from 's' import { MChannelFormattable } from 's' type Use < K extends keyof UserModel , M > = PickWith < UserModel , K , M > export type MUser = Omit < UserModel , 's' | 's' | 's' | 's' > export type MUserQuotaUsed = MUser & { videoQuotaUsed ? : number , videoQuotaUsedDaily ? : number } export type MUserId = Pick < UserModel , 's' > export type MUserAccountId = MUser & Use < 's' , MAccountId > export type MUserAccountUrl = MUser & Use < 's' , MAccountUrl & MAccountIdActorId > export type MUserAccount = MUser & Use < 's' , MAccount > export type MUserAccountDefault = MUser & Use < 's' , MAccountDefault > export type MUserNotifSettingChannelDefault = MUser & Use < 's' , MNotificationSetting > & Use < 's' , MAccountDefaultChannelDefault > export type MUserWithNotificationSetting = MUser & Use < 's' , MNotificationSetting > export type MUserNotifSettingAccount = MUser & Use < 's' , MNotificationSetting > & Use < 's' , MAccount > export type MUserDefault = MUser & Use < 's' , MNotificationSetting > & Use < 's' , MAccountDefault > export type MUserFormattable = MUserQuotaUsed & Use < 's' , MAccountFormattable & PickWithOpt < AccountModel , 's' , MChannelFormattable [ ] > > & PickWithOpt < UserModel , 's' , MNotificationSettingFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserNotificationModel } from 's' import { PickWith , PickWithOpt } from 's' import { VideoModel } from 's' import { ActorModel } from 's' import { ServerModel } from 's' import { AvatarModel } from 's' import { VideoChannelModel } from 's' import { AccountModel } from 's' import { VideoCommentModel } from 's' import { VideoAbuseModel } from 's' import { VideoBlacklistModel } from 's' import { VideoImportModel } from 's' import { ActorFollowModel } from 's' type Use < K extends keyof UserNotificationModel , M > = PickWith < UserNotificationModel , K , M > export namespace UserNotificationIncludes { export type VideoInclude = Pick < VideoModel , 's' | 's' | 's' > export type VideoIncludeChannel = VideoInclude & PickWith < VideoModel , 's' , VideoChannelIncludeActor > export type ActorInclude = Pick < ActorModel , 's' | 's' > & PickWith < ActorModel , 's' , Pick < AvatarModel , 's' | 's' > > & PickWith < ActorModel , 's' , Pick < ServerModel , 's' > > export type VideoChannelInclude = Pick < VideoChannelModel , 's' | 's' | 's' > export type VideoChannelIncludeActor = VideoChannelInclude & PickWith < VideoChannelModel , 's' , ActorInclude > export type AccountInclude = Pick < AccountModel , 's' | 's' | 's' > export type AccountIncludeActor = AccountInclude & PickWith < AccountModel , 's' , ActorInclude > export type VideoCommentInclude = Pick < VideoCommentModel , 's' | 's' | 's' > & PickWith < VideoCommentModel , 's' , AccountIncludeActor > & PickWith < VideoCommentModel , 's' , VideoInclude > export type VideoAbuseInclude = Pick < VideoAbuseModel , 's' > & PickWith < VideoAbuseModel , 's' , VideoInclude > export type VideoBlacklistInclude = Pick < VideoBlacklistModel , 's' > & PickWith < VideoAbuseModel , 's' , VideoInclude > export type VideoImportInclude = Pick < VideoImportModel , 's' | 's' | 's' | 's' > & PickWith < VideoImportModel , 's' , VideoInclude > export type ActorFollower = Pick < ActorModel , 's' | 's' > & PickWith < ActorModel , 's' , AccountInclude > & PickWith < ActorModel , 's' , Pick < ServerModel , 's' > > & PickWithOpt < ActorModel , 's' , Pick < AvatarModel , 's' | 's' > > export type ActorFollowing = Pick < ActorModel , 's' | 's' | 's' > & PickWith < ActorModel , 's' , VideoChannelInclude > & PickWith < ActorModel , 's' , AccountInclude > & PickWith < ActorModel , 's' , Pick < ServerModel , 's' > > export type ActorFollowInclude = Pick < ActorFollowModel , 's' | 's' > & PickWith < ActorFollowModel , 's' , ActorFollower > & PickWith < ActorFollowModel , 's' , ActorFollowing > } export type MUserNotification = Omit < UserNotificationModel , 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' > export type UserNotificationModelForApi = MUserNotification & Use < 's' , UserNotificationIncludes . VideoIncludeChannel > & Use < 's' , UserNotificationIncludes . VideoCommentInclude > & Use < 's' , UserNotificationIncludes . VideoAbuseInclude > & Use < 's' , UserNotificationIncludes . VideoBlacklistInclude > & Use < 's' , UserNotificationIncludes . VideoImportInclude > & Use < 's' , UserNotificationIncludes . ActorFollowInclude > & Use < 's' , UserNotificationIncludes . AccountIncludeActor >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as 0 from 's' import { ActivityPubActorType } from 's' import { SERVER_ACTOR_NAME , WEBSERVER } from 's' import { AccountModel } from 's' import { buildActorInstance , getAccountActivityPubUrl , setAsyncActorKeys } from 's' import { createLocalVideoChannel } from 's' import { ActorModel } from 's' import { UserNotificationSettingModel } from 's' import { UserNotificationSetting , UserNotificationSettingValue } from 's' import { createWatchLaterPlaylist } from 's' import { sequelizeTypescript } from 's' import { Transaction } from 's' import { Redis } from 's' import { Emailer } from 's' import { MAccountDefault , MActorDefault , MChannelActor } from 's' import { MUser , MUserDefault , MUserId } from 's' type ChannelNames = { name : string , displayName : string } async function createUserAccountAndChannelAndPlaylist ( parameters : { userToCreate : MUser , userDisplayName ? : string , channelNames ? : ChannelNames , validateUser ? : boolean } ) < { user : MUserDefault , account : MAccountDefault , videoChannel : MChannelActor } > { const { userToCreate , userDisplayName , channelNames , validateUser = true } = parameters const { user , account , videoChannel } = await sequelizeTypescript . transaction ( async t => { const userOptions = { transaction : t , validate : validateUser } const userCreated = await userToCreate . save ( userOptions ) userCreated . NotificationSetting = await createDefaultUserNotificationSettings ( userCreated , t ) const accountCreated = await createLocalAccountWithoutKeys ( { name : userCreated . username , displayName : userDisplayName , userId : userCreated . id , applicationId : null , t : t } ) userCreated . Account = accountCreated const channelAttributes = await buildChannelAttributes ( userCreated , channelNames ) const videoChannel = await createLocalVideoChannel ( channelAttributes , accountCreated , t ) const videoPlaylist = await createWatchLaterPlaylist ( accountCreated , t ) return { user : userCreated , account : accountCreated , videoChannel , videoPlaylist } } ) const [ accountActorWithKeys , channelActorWithKeys ] = await Promise . all ( [ setAsyncActorKeys ( account . Actor ) , setAsyncActorKeys ( videoChannel . Actor ) ] ) account . Actor = accountActorWithKeys videoChannel . Actor = channelActorWithKeys return { user , account , videoChannel } } async function createLocalAccountWithoutKeys ( parameters : { name : string , displayName ? : string , userId : number | null , applicationId : number | null , t : Transaction | undefined , type ? : ActivityPubActorType } ) { const { name , displayName , userId , applicationId , t , type = 's' } = parameters const url = getAccountActivityPubUrl ( name ) const actorInstance = buildActorInstance ( type , url , name ) const actorInstanceCreated = await actorInstance . save ( { transaction : t } ) const accountInstance = new AccountModel ( { name : displayName || name , userId , applicationId , actorId : actorInstanceCreated . id } ) const accountInstanceCreated = await accountInstance . save ( { transaction : t } ) accountInstanceCreated . Actor = actorInstanceCreated return accountInstanceCreated } async function createApplicationActor ( applicationId ) { const accountCreated = await createLocalAccountWithoutKeys ( { name : SERVER_ACTOR_NAME , userId : null , applicationId : applicationId , t : undefined , type : 's' } ) accountCreated . Actor = await setAsyncActorKeys ( accountCreated . Actor ) return accountCreated } async function sendVerifyUserEmail ( user , isPendingEmail = false ) { const verificationString = await Redis . Instance . setVerifyEmailVerificationString ( user . id ) let url = WEBSERVER . URL + 's' + user . id + 's' + verificationString if ( isPendingEmail ) url += 's' const email = isPendingEmail ? user . pendingEmail : user . email await Emailer . Instance . addVerifyEmailJob ( email , url ) } export { createApplicationActor , createUserAccountAndChannelAndPlaylist , createLocalAccountWithoutKeys , sendVerifyUserEmail } function createDefaultUserNotificationSettings ( user , t : Transaction | undefined ) { const values : UserNotificationSetting & { userId : number } = { userId : user . id , newVideoFromSubscription : UserNotificationSettingValue . WEB , newCommentOnMyVideo : UserNotificationSettingValue . WEB , myVideoImportFinished : UserNotificationSettingValue . WEB , myVideoPublished : UserNotificationSettingValue . WEB , videoAbuseAsModerator : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , videoAutoBlacklistAsModerator : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , blacklistOnMyVideo : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , newUserRegistration : UserNotificationSettingValue . WEB , commentMention : UserNotificationSettingValue . WEB , newFollow : UserNotificationSettingValue . WEB , newInstanceFollower : UserNotificationSettingValue . WEB , autoInstanceFollowing : UserNotificationSettingValue . WEB } return UserNotificationSettingModel . create ( values , { transaction : t } ) } async function buildChannelAttributes ( user , channelNames ? ) { if ( channelNames ) return channelNames let channelName = user . username + 's' const actor = await ActorModel . loadLocalByName ( channelName ) if ( actor ) channelName = 0 ( ) const videoChannelDisplayName = `template` return { name : channelName , displayName : videoChannelDisplayName } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUser$ O O $ChannelNames$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as config from 's' import { isProdInstance , isTestInstance } from 's' import { UserModel } from 's' import { ApplicationModel } from 's' import { OAuthClientModel } from 's' import { parse } from 's' import { CONFIG } from 's' import { logger } from 's' import { getServerActor } from 's' import { RecentlyAddedStrategy } from 's' import { isArray } from 's' import { uniq } from 's' import { Emailer } from 's' import { WEBSERVER } from 's' async function checkActivityPubUrls ( ) { const actor = await getServerActor ( ) const parsed = parse ( actor . url ) if ( WEBSERVER . HOST !== parsed . host ) { const NODE_ENV = config . util . getEnv ( 's' ) const NODE_CONFIG_DIR = config . util . getEnv ( 's' ) logger . warn ( 's' + 's' + 's' , NODE_CONFIG_DIR ? `template` : 's' , NODE_ENV ? `template` : 's' ) } } function checkConfig ( ) { if ( config . has ( 's' ) ) { logger . warn ( 's' ) } if ( ! Emailer . isEnabled ( ) ) { if ( CONFIG . SIGNUP . ENABLED && CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION ) { return 's' } if ( CONFIG . CONTACT_FORM . ENABLED ) { logger . warn ( 's' ) } } const defaultNSFWPolicy = CONFIG . INSTANCE . DEFAULT_NSFW_POLICY { const available = [ 's' , 's' , 's' ] if ( available . indexOf ( defaultNSFWPolicy ) === - 0 ) { return 's' + available . join ( 's' ) + 's' + defaultNSFWPolicy } } const redundancyVideos = CONFIG . REDUNDANCY . VIDEOS . STRATEGIES if ( isArray ( redundancyVideos ) ) { const available = [ 's' , 's' , 's' ] for ( const r of redundancyVideos ) { if ( available . indexOf ( r . strategy ) === - 0 ) { return 's' + available . join ( 's' ) + 's' + r . strategy } if ( ! isTestInstance ( ) && r . minLifetime < 0 * 0 * 0 ) { return 's' + r . strategy } } const filtered = uniq ( redundancyVideos . map ( r => r . strategy ) ) if ( filtered . length !== redundancyVideos . length ) { return 's' } const recentlyAddedStrategy = redundancyVideos . find ( r => r . strategy === 's' ) as RecentlyAddedStrategy if ( recentlyAddedStrategy && isNaN ( recentlyAddedStrategy . minViews ) ) { return 's' } } else { return 's' } if ( isProdInstance ( ) ) { const configStorage = config . get ( 's' ) for ( const key of Object . keys ( configStorage ) ) { if ( configStorage [ key ] . startsWith ( 's' ) ) { logger . warn ( 's' , key ) } } } return null } async function clientsExist ( ) { const totalClients = await OAuthClientModel . countTotal ( ) return totalClients !== 0 } async function usersExist ( ) { const totalUsers = await UserModel . countTotal ( ) return totalUsers !== 0 } async function applicationExist ( ) { const totalApplication = await ApplicationModel . countTotal ( ) return totalApplication !== 0 } export { checkConfig , clientsExist , usersExist , applicationExist , checkActivityPubUrls }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as passwordGenerator from 's' import { UserRole } from 's' import { logger } from 's' import { createApplicationActor , createUserAccountAndChannelAndPlaylist } from 's' import { UserModel } from 's' import { ApplicationModel } from 's' import { OAuthClientModel } from 's' import { applicationExist , clientsExist , usersExist } from 's' import { FILES_CACHE , HLS_STREAMING_PLAYLIST_DIRECTORY , LAST_MIGRATION_VERSION } from 's' import { sequelizeTypescript } from 's' import { ensureDir , remove } from 's' import { CONFIG } from 's' async function installApplication ( ) { try { await Promise . all ( [ sequelizeTypescript . sync ( ) . then ( ( ) => { return Promise . all ( [ createApplicationIfNotExist ( ) , createOAuthClientIfNotExist ( ) , createOAuthAdminIfNotExist ( ) ] ) } ) , removeCacheAndTmpDirectories ( ) . then ( ( ) => createDirectoriesIfNotExist ( ) ) ] ) } catch ( err ) { logger . error ( 's' , { err } ) process . exit ( - 0 ) } } export { installApplication } function removeCacheAndTmpDirectories ( ) { const cacheDirectories = Object . keys ( FILES_CACHE ) . map ( k => FILES_CACHE [ k ] . DIRECTORY ) const tasks : Promise < any > [ ] = [ ] for ( const key of Object . keys ( cacheDirectories ) ) { const dir = cacheDirectories [ key ] tasks . push ( remove ( dir ) ) } tasks . push ( remove ( CONFIG . STORAGE . TMP_DIR ) ) return Promise . all ( tasks ) } function createDirectoriesIfNotExist ( ) { const storage = CONFIG . STORAGE const cacheDirectories = Object . keys ( FILES_CACHE ) . map ( k => FILES_CACHE [ k ] . DIRECTORY ) const tasks : Promise < void > [ ] = [ ] for ( const key of Object . keys ( storage ) ) { const dir = storage [ key ] tasks . push ( ensureDir ( dir ) ) } for ( const key of Object . keys ( cacheDirectories ) ) { const dir = cacheDirectories [ key ] tasks . push ( ensureDir ( dir ) ) } tasks . push ( ensureDir ( HLS_STREAMING_PLAYLIST_DIRECTORY ) ) return Promise . all ( tasks ) } async function createOAuthClientIfNotExist ( ) { const exist = await clientsExist ( ) if ( exist === true ) return undefined logger . info ( 's' ) const id = passwordGenerator ( 0 , false , "s" ) const secret = passwordGenerator ( 0 , false , "s" ) const client = new OAuthClientModel ( { clientId : id , clientSecret : secret , grants : [ 's' , 's' ] , redirectUris : null } ) const createdClient = await client . save ( ) logger . info ( 's' + createdClient . clientId ) logger . info ( 's' + createdClient . clientSecret ) return undefined } async function createOAuthAdminIfNotExist ( ) { const exist = await usersExist ( ) if ( exist === true ) return undefined logger . info ( 's' ) const username = 's' const role = UserRole . ADMINISTRATOR const email = CONFIG . ADMIN . EMAIL let validatePassword = true let password = 's' if ( process . env . NODE_ENV === 's' ) { password = 's' if ( process . env . NODE_APP_INSTANCE ) { password += process . env . NODE_APP_INSTANCE } validatePassword = false } else if ( process . env . PT_INITIAL_ROOT_PASSWORD ) { password = process . env . PT_INITIAL_ROOT_PASSWORD } else { password = passwordGenerator ( 0 , true ) } const userData = { username , email , password , role , verified : true , nsfwPolicy : CONFIG . INSTANCE . DEFAULT_NSFW_POLICY , videoQuota : - 0 , videoQuotaDaily : - 0 } const user = new UserModel ( userData ) await createUserAccountAndChannelAndPlaylist ( { userToCreate : user , channelNames : undefined , validateUser : validatePassword } ) logger . info ( 's' + username ) logger . info ( 's' + password ) } async function createApplicationIfNotExist ( ) { const exist = await applicationExist ( ) if ( exist === true ) return undefined logger . info ( 's' ) const application = await ApplicationModel . create ( { migrationVersion : LAST_MIGRATION_VERSION } ) return createApplicationActor ( application . id ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { logger } from 's' import { LAST_MIGRATION_VERSION } from 's' import { sequelizeTypescript } from 's' import { readdir } from 's' import { QueryTypes } from 's' async function migrate ( ) { const tables = await sequelizeTypescript . getQueryInterface ( ) . showAllTables ( ) if ( tables . length === 0 ) return let actualVersion : number | null = null const query = 's' const options = { type : QueryTypes . SELECT as QueryTypes . SELECT } const rows = await sequelizeTypescript . query < { migrationVersion : number } > ( query , options ) if ( rows && rows [ 0 ] && rows [ 0 ] . migrationVersion ) { actualVersion = rows [ 0 ] . migrationVersion } if ( actualVersion === null ) { await sequelizeTypescript . query ( 's' ) actualVersion = 0 } if ( actualVersion >= LAST_MIGRATION_VERSION ) return logger . info ( 's' ) const migrationScripts = await getMigrationScripts ( ) for ( const migrationScript of migrationScripts ) { try { await executeMigration ( actualVersion , migrationScript ) } catch ( err ) { logger . error ( 's' , migrationScript . version , { err } ) process . exit ( - 0 ) } } logger . info ( 's' , LAST_MIGRATION_VERSION ) } export { migrate } async function getMigrationScripts ( ) { const files = await readdir ( path . join ( __dirname , 's' ) ) const filesToMigrate : { version : string , script : string } [ ] = [ ] files . filter ( file => file . endsWith ( 's' ) === false ) . forEach ( file => { const version = file . split ( 's' ) [ 0 ] filesToMigrate . push ( { version , script : file } ) } ) return filesToMigrate } async function executeMigration ( actualVersion , entity : { version : string , script : string } ) { const versionScript = parseInt ( entity . version , 0 ) if ( versionScript <= actualVersion ) return undefined const migrationScriptName = entity . script logger . info ( 's' , migrationScriptName ) const migrationScript = require ( path . join ( __dirname , 's' , migrationScriptName ) ) return sequelizeTypescript . transaction ( async t => { const options = { transaction : t , queryInterface : sequelizeTypescript . getQueryInterface ( ) , sequelize : sequelizeTypescript } await migrationScript . up ( options ) await sequelizeTypescript . query ( 's' + versionScript , { transaction : t } ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O
import { basename , dirname , join } from 's' import { HLS_STREAMING_PLAYLIST_DIRECTORY , 0 } from 's' import { close , ensureDir , move , open , outputJSON , pathExists , read , readFile , remove , writeFile } from 's' import { getVideoFileSize } from 's' import { 0 } from 's' import { VideoStreamingPlaylistModel } from 's' import { logger } from 's' import { doRequest , doRequestAndSaveToFile } from 's' import { generateRandomString } from 's' import { flatten , uniq } from 's' import { VideoFileModel } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { MVideoWithFile } from 's' async function updateStreamingPlaylistsInfohashesIfNeeded ( ) { const playlistsToUpdate = await VideoStreamingPlaylistModel . listByIncorrectPeerVersion ( ) for ( const playlist of playlistsToUpdate ) { await sequelizeTypescript . transaction ( async t => { const videoFiles = await VideoFileModel . listByStreamingPlaylist ( playlist . id , t ) playlist . 0 = VideoStreamingPlaylistModel . 0 ( playlist . playlistUrl , videoFiles ) playlist . 0 = 0 await playlist . save ( { transaction : t } ) } ) } } async function updateMasterHLSPlaylist ( video ) { const directory = join ( HLS_STREAMING_PLAYLIST_DIRECTORY , video . uuid ) const masterPlaylists : string [ ] = [ 's' , 's' ] const masterPlaylistPath = join ( directory , VideoStreamingPlaylistModel . getMasterHlsPlaylistFilename ( ) ) for ( const file of video . VideoFiles ) { const filePlaylistPath = join ( directory , VideoStreamingPlaylistModel . getHlsPlaylistFilename ( file . resolution ) ) if ( await pathExists ( filePlaylistPath ) === false ) continue const videoFilePath = video . getVideoFilePath ( file ) const size = await getVideoFileSize ( videoFilePath ) const bandwidth = 's' + video . getBandwidthBits ( file ) const resolution = `template` let line = `template` if ( file . fps ) line += 's' + file . fps masterPlaylists . push ( line ) masterPlaylists . push ( VideoStreamingPlaylistModel . getHlsPlaylistFilename ( file . resolution ) ) } await writeFile ( masterPlaylistPath , masterPlaylists . join ( 's' ) + 's' ) } async function 0 ( video ) { const json : { [ filename ] : { [ range ] : string } } = { } const playlistDirectory = join ( HLS_STREAMING_PLAYLIST_DIRECTORY , video . uuid ) for ( const file of video . VideoFiles ) { const rangeHashes : { [ range ] : string } = { } const videoPath = join ( playlistDirectory , VideoStreamingPlaylistModel . getHlsVideoName ( video . uuid , file . resolution ) ) const playlistPath = join ( playlistDirectory , VideoStreamingPlaylistModel . getHlsPlaylistFilename ( file . resolution ) ) if ( ! await pathExists ( playlistPath ) ) continue const playlistContent = await readFile ( playlistPath ) const ranges = getRangesFromPlaylist ( playlistContent . toString ( ) ) const fd = await open ( videoPath , 's' ) for ( const range of ranges ) { const buf = Buffer . alloc ( range . length ) await read ( fd , buf , 0 , range . length , range . offset ) rangeHashes [ `template` ] = 0 ( buf ) } await close ( fd ) const videoFilename = VideoStreamingPlaylistModel . getHlsVideoName ( video . uuid , file . resolution ) json [ videoFilename ] = rangeHashes } const outputPath = join ( playlistDirectory , VideoStreamingPlaylistModel . 0 ( ) ) await outputJSON ( outputPath , json ) } function getRangesFromPlaylist ( playlistContent ) { const ranges : { offset : number , length : number } [ ] = [ ] const lines = playlistContent . split ( 's' ) const regex = "s" for ( const line of lines ) { const captured = regex . exec ( line ) if ( captured ) { ranges . push ( { length : parseInt ( captured [ 0 ] , 0 ) , offset : parseInt ( captured [ 0 ] , 0 ) } ) } } return ranges } function downloadPlaylistSegments ( playlistUrl , destinationDir , timeout ) { let timer logger . info ( 's' , playlistUrl ) return new Promise < string > ( async ( res , rej ) => { const tmpDirectory = join ( CONFIG . STORAGE . TMP_DIR , await generateRandomString ( 0 ) ) await ensureDir ( tmpDirectory ) timer = setTimeout ( ( ) => { deleteTmpDirectory ( tmpDirectory ) return rej ( new Error ( 's' ) ) } , timeout ) try { const subPlaylistUrls = await fetchUniqUrls ( playlistUrl ) const subRequests = subPlaylistUrls . map ( u => fetchUniqUrls ( u ) ) const fileUrls = uniq ( flatten ( await Promise . all ( subRequests ) ) ) logger . debug ( 's' , fileUrls . length , { fileUrls } ) for ( const fileUrl of fileUrls ) { const destPath = join ( tmpDirectory , basename ( fileUrl ) ) const bodyKBLimit = 0 * 0 * 0 await doRequestAndSaveToFile ( { uri : fileUrl } , destPath , bodyKBLimit ) } clearTimeout ( timer ) await move ( tmpDirectory , destinationDir , { overwrite : true } ) return res ( ) } catch ( err ) { deleteTmpDirectory ( tmpDirectory ) return rej ( err ) } } ) function deleteTmpDirectory ( directory ) { remove ( directory ) . catch ( err => logger . error ( 's' , { err } ) ) } async function fetchUniqUrls ( playlistUrl ) { const { body } = await doRequest < string > ( { uri : playlistUrl } ) if ( ! body ) return [ ] const urls = body . split ( 's' ) . filter ( line => line . endsWith ( 's' ) || line . endsWith ( 's' ) ) . map ( url => { if ( url . startsWith ( 's' ) || url . startsWith ( 's' ) ) return url return `template` } ) return uniq ( urls ) } } export { updateMasterHLSPlaylist , 0 , downloadPlaylistSegments , updateStreamingPlaylistsInfohashesIfNeeded }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { HLS_STREAMING_PLAYLIST_DIRECTORY , 0 , WEBSERVER } from 's' import { join } from 's' import { canDoQuickTranscode , getVideoFileFPS , transcode , TranscodeOptions , TranscodeOptionsType } from 's' import { ensureDir , move , remove , stat } from 's' import { logger } from 's' import { VideoResolution } from 's' import { VideoFileModel } from 's' import { updateMasterHLSPlaylist , 0 } from 's' import { VideoStreamingPlaylistModel } from 's' import { VideoStreamingPlaylistType } from 's' import { CONFIG } from 's' import { MVideoFile , MVideoWithFile , MVideoWithFileThumbnail } from 's' async function optimizeVideofile ( video , inputVideoFileArg ? ) { const videosDirectory = CONFIG . STORAGE . VIDEOS_DIR const transcodeDirectory = CONFIG . STORAGE . TMP_DIR const newExtname = 's' const inputVideoFile = inputVideoFileArg ? inputVideoFileArg : video . getOriginalFile ( ) const videoInputPath = join ( videosDirectory , video . getVideoFilename ( inputVideoFile ) ) const videoTranscodedPath = join ( transcodeDirectory , video . id + 's' + newExtname ) const transcodeType = await canDoQuickTranscode ( videoInputPath ) ? 's' : 's' const transcodeOptions = { type : transcodeType as any , inputPath : videoInputPath , outputPath : videoTranscodedPath , resolution : inputVideoFile . resolution } await transcode ( transcodeOptions ) try { await remove ( videoInputPath ) inputVideoFile . extname = newExtname const videoOutputPath = video . getVideoFilePath ( inputVideoFile ) await onVideoFileTranscoding ( video , inputVideoFile , videoTranscodedPath , videoOutputPath ) } catch ( err ) { video . destroy ( ) . catch ( err => logger . error ( 's' , { err } ) ) throw err } } async function transcodeOriginalVideofile ( video , resolution , isPortrait ) { const videosDirectory = CONFIG . STORAGE . VIDEOS_DIR const transcodeDirectory = CONFIG . STORAGE . TMP_DIR const extname = 's' const videoInputPath = join ( videosDirectory , video . getVideoFilename ( video . getOriginalFile ( ) ) ) const newVideoFile = new VideoFileModel ( { resolution , extname , size : 0 , videoId : video . id } ) const videoOutputPath = join ( CONFIG . STORAGE . VIDEOS_DIR , video . getVideoFilename ( newVideoFile ) ) const videoTranscodedPath = join ( transcodeDirectory , video . getVideoFilename ( newVideoFile ) ) const transcodeOptions = { type : 's' as 's' , inputPath : videoInputPath , outputPath : videoTranscodedPath , resolution , isPortraitMode : isPortrait } await transcode ( transcodeOptions ) return onVideoFileTranscoding ( video , newVideoFile , videoTranscodedPath , videoOutputPath ) } async function mergeAudioVideofile ( video , resolution ) { const videosDirectory = CONFIG . STORAGE . VIDEOS_DIR const transcodeDirectory = CONFIG . STORAGE . TMP_DIR const newExtname = 's' const inputVideoFile = video . getOriginalFile ( ) const audioInputPath = join ( videosDirectory , video . getVideoFilename ( video . getOriginalFile ( ) ) ) const videoTranscodedPath = join ( transcodeDirectory , video . id + 's' + newExtname ) const transcodeOptions = { type : 's' as 's' , inputPath : video . getPreview ( ) . getPath ( ) , outputPath : videoTranscodedPath , audioPath : audioInputPath , resolution } await transcode ( transcodeOptions ) await remove ( audioInputPath ) inputVideoFile . extname = newExtname const videoOutputPath = video . getVideoFilePath ( inputVideoFile ) return onVideoFileTranscoding ( video , inputVideoFile , videoTranscodedPath , videoOutputPath ) } async function generateHlsPlaylist ( video , resolution , isPortraitMode ) { const baseHlsDirectory = join ( HLS_STREAMING_PLAYLIST_DIRECTORY , video . uuid ) await ensureDir ( join ( HLS_STREAMING_PLAYLIST_DIRECTORY , video . uuid ) ) const videoInputPath = join ( CONFIG . STORAGE . VIDEOS_DIR , video . getVideoFilename ( video . getFile ( resolution ) ) ) const outputPath = join ( baseHlsDirectory , VideoStreamingPlaylistModel . getHlsPlaylistFilename ( resolution ) ) const transcodeOptions = { type : 's' as 's' , inputPath : videoInputPath , outputPath , resolution , isPortraitMode , hlsPlaylist : { videoFilename : VideoStreamingPlaylistModel . getHlsVideoName ( video . uuid , resolution ) } } await transcode ( transcodeOptions ) await updateMasterHLSPlaylist ( video ) await 0 ( video ) const playlistUrl = WEBSERVER . URL + VideoStreamingPlaylistModel . getHlsMasterPlaylistStaticPath ( video . uuid ) await VideoStreamingPlaylistModel . upsert ( { videoId : video . id , playlistUrl , 0 : WEBSERVER . URL + VideoStreamingPlaylistModel . 0 ( video . uuid ) , 0 : VideoStreamingPlaylistModel . 0 ( playlistUrl , video . VideoFiles ) , 0 : 0 , type : VideoStreamingPlaylistType . HLS } ) } export { generateHlsPlaylist , optimizeVideofile , transcodeOriginalVideofile , mergeAudioVideofile } async function onVideoFileTranscoding ( video , videoFile , transcodingPath , outputPath ) { const stats = await stat ( transcodingPath ) const fps = await getVideoFileFPS ( transcodingPath ) await move ( transcodingPath , outputPath ) videoFile . size = stats . size videoFile . fps = fps await video . createTorrentAndSetInfoHash ( videoFile ) const updatedVideoFile = await videoFile . save ( ) if ( video . VideoFiles . some ( f => f . id === videoFile . id ) === false ) { video . VideoFiles . push ( updatedVideoFile ) } return video }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TranscodeOptionsType$ O O O O O O O O O O O $TranscodeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O $VideoResolution$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFileThumbnail$ O $VideoResolution$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O $VideoResolution$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O $MVideoFile$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { VideoResolution , VideoState } from 's' import { logger } from 's' import { VideoModel } from 's' import { JobQueue } from 's' import { federateVideoIfNeeded } from 's' import { retryTransactionWrapper } from 's' import { sequelizeTypescript } from 's' import * as Bluebird from 's' import { computeResolutionsToTranscode } from 's' import { generateHlsPlaylist , optimizeVideofile , transcodeOriginalVideofile , mergeAudioVideofile } from 's' import { Notifier } from 's' import { CONFIG } from 's' import { MVideoUUID , MVideoWithFile } from 's' interface BaseTranscodingPayload { videoUUID : string isNewVideo ? : boolean } interface HLSTranscodingPayload extends BaseTranscodingPayload { type : 's' isPortraitMode ? : boolean resolution : VideoResolution } interface NewResolutionTranscodingPayload extends BaseTranscodingPayload { type : 's' isPortraitMode ? : boolean resolution : VideoResolution } interface MergeAudioTranscodingPayload extends BaseTranscodingPayload { type : 's' resolution : VideoResolution } interface OptimizeTranscodingPayload extends BaseTranscodingPayload { type : 's' } export type VideoTranscodingPayload = HLSTranscodingPayload | NewResolutionTranscodingPayload | OptimizeTranscodingPayload | MergeAudioTranscodingPayload async function processVideoTranscoding ( job : Bull . Job ) { const payload = job . data as VideoTranscodingPayload logger . info ( 's' , job . id ) const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( payload . videoUUID ) if ( ! video ) { logger . info ( 's' , job . id ) return undefined } if ( payload . type === 's' ) { await generateHlsPlaylist ( video , payload . resolution , payload . isPortraitMode || false ) await retryTransactionWrapper ( onHlsPlaylistGenerationSuccess , video ) } else if ( payload . type === 's' ) { await transcodeOriginalVideofile ( video , payload . resolution , payload . isPortraitMode || false ) await retryTransactionWrapper ( publishNewResolutionIfNeeded , video , payload ) } else if ( payload . type === 's' ) { await mergeAudioVideofile ( video , payload . resolution ) await retryTransactionWrapper ( publishNewResolutionIfNeeded , video , payload ) } else { await optimizeVideofile ( video ) await retryTransactionWrapper ( onVideoFileOptimizerSuccess , video , payload ) } return video } async function onHlsPlaylistGenerationSuccess ( video ) { if ( video === undefined ) return undefined await sequelizeTypescript . transaction ( async t => { let videoDatabase = await VideoModel . loadAndPopulateAccountAndServerAndTags ( video . uuid , t ) if ( ! videoDatabase ) return undefined await federateVideoIfNeeded ( videoDatabase , false , t ) } ) } async function publishNewResolutionIfNeeded ( video , payload ? : NewResolutionTranscodingPayload | MergeAudioTranscodingPayload ) { const { videoDatabase , videoPublished } = await sequelizeTypescript . transaction ( async t => { let videoDatabase = await VideoModel . loadAndPopulateAccountAndServerAndTags ( video . uuid , t ) if ( ! videoDatabase ) return undefined let videoPublished = false if ( videoDatabase . state !== VideoState . PUBLISHED ) { videoPublished = true videoDatabase . state = VideoState . PUBLISHED videoDatabase . publishedAt = new Date ( ) videoDatabase = await videoDatabase . save ( { transaction : t } ) } await federateVideoIfNeeded ( videoDatabase , videoPublished , t ) return { videoDatabase , videoPublished } } ) if ( videoPublished ) { Notifier . Instance . notifyOnNewVideoIfNeeded ( videoDatabase ) Notifier . Instance . notifyOnVideoPublishedAfterTranscoding ( videoDatabase ) } await createHlsJobIfEnabled ( payload ) } async function onVideoFileOptimizerSuccess ( videoArg , payload ) { if ( videoArg === undefined ) return undefined const { videoFileResolution } = await videoArg . getOriginalFileResolution ( ) const { videoDatabase , videoPublished } = await sequelizeTypescript . transaction ( async t => { let videoDatabase = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoArg . uuid , t ) if ( ! videoDatabase ) return undefined const resolutionsEnabled = computeResolutionsToTranscode ( videoFileResolution ) logger . info ( 's' , videoDatabase . uuid , videoFileResolution , { resolutions : resolutionsEnabled } ) let videoPublished = false if ( resolutionsEnabled . length !== 0 ) { const tasks : ( Bluebird < Bull . Job < any > > | Promise < Bull . Job < any > > ) [ ] = [ ] for ( const resolution of resolutionsEnabled ) { const dataInput = { type : 's' as 's' , videoUUID : videoDatabase . uuid , resolution } const p = JobQueue . Instance . createJob ( { type : 's' , payload : dataInput } ) tasks . push ( p ) } await Promise . all ( tasks ) logger . info ( 's' , videoDatabase . uuid , { resolutionsEnabled } ) } else { videoPublished = true videoDatabase . state = VideoState . PUBLISHED videoDatabase = await videoDatabase . save ( { transaction : t } ) logger . info ( 's' , videoDatabase . uuid , { privacy : videoDatabase . privacy } ) } await federateVideoIfNeeded ( videoDatabase , payload . isNewVideo , t ) return { videoDatabase , videoPublished } } ) if ( payload . isNewVideo ) Notifier . Instance . notifyOnNewVideoIfNeeded ( videoDatabase ) if ( videoPublished ) Notifier . Instance . notifyOnVideoPublishedAfterTranscoding ( videoDatabase ) const hlsPayload = Object . assign ( { } , payload , { resolution : videoDatabase . getOriginalFile ( ) . resolution } ) await createHlsJobIfEnabled ( hlsPayload ) } export { processVideoTranscoding , publishNewResolutionIfNeeded } function createHlsJobIfEnabled ( payload ? : { videoUUID : string , resolution : number , isPortraitMode ? : boolean } ) { if ( payload && CONFIG . TRANSCODING . HLS . ENABLED ) { const hlsTranscodingPayload = { type : 's' as 's' , videoUUID : payload . videoUUID , resolution : payload . resolution , isPortraitMode : payload . isPortraitMode } return JobQueue . Instance . createJob ( { type : 's' , payload : hlsTranscodingPayload } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoUUID$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoUUID$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O $OptimizeTranscodingPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { REMOTE_SCHEME , WEBSERVER } from 's' import { sendFollow } from 's' import { sanitizeHost } from 's' import { loadActorUrlOrGetFromWebfinger } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { retryTransactionWrapper } from 's' import { ActorFollowModel } from 's' import { ActorModel } from 's' import { Notifier } from 's' import { sequelizeTypescript } from 's' import { MActor , MActorFollowActors , MActorFull } from 's' export type ActivitypubFollowPayload = { followerActorId : number name : string host : string isAutoFollow ? : boolean } async function processActivityPubFollow ( job : Bull . Job ) { const payload = job . data as ActivitypubFollowPayload const host = payload . host logger . info ( 's' , job . id ) let targetActor if ( ! host || host === WEBSERVER . HOST ) { targetActor = await ActorModel . loadLocalByName ( payload . name ) } else { const sanitizedHost = sanitizeHost ( host , REMOTE_SCHEME . HTTP ) const actorUrl = await loadActorUrlOrGetFromWebfinger ( payload . name + 's' + sanitizedHost ) targetActor = await getOrCreateActorAndServerAndModel ( actorUrl , 's' ) } const fromActor = await ActorModel . load ( payload . followerActorId ) return retryTransactionWrapper ( follow , fromActor , targetActor , payload . isAutoFollow ) } export { processActivityPubFollow } async function follow ( fromActor , targetActor , isAutoFollow = false ) { if ( fromActor . id === targetActor . id ) { throw new Error ( 's' ) } const state = ! fromActor . serverId && ! targetActor . serverId ? 's' : 's' const actorFollow = await sequelizeTypescript . transaction ( async t => { const [ actorFollow ] = await ActorFollowModel . findOrCreate < MActorFollowActors > ( { where : { actorId : fromActor . id , targetActorId : targetActor . id } , defaults : { state , actorId : fromActor . id , targetActorId : targetActor . id } , transaction : t } ) actorFollow . ActorFollowing = targetActor actorFollow . ActorFollower = fromActor if ( actorFollow . state !== 's' ) sendFollow ( actorFollow , t ) return actorFollow } ) const followerFull = await ActorModel . loadFull ( fromActor . id ) const actorFollowFull = Object . assign ( actorFollow , { ActorFollowing : targetActor , ActorFollower : followerFull } ) if ( actorFollow . state === 's' ) Notifier . Instance . notifyOfNewUserFollow ( actorFollowFull ) if ( isAutoFollow === true ) Notifier . Instance . notifyOfAutoInstanceFollowing ( actorFollowFull ) return actorFollow }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MActorFull$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { truncate } from 's' import { CONSTRAINTS_FIELDS , VIDEO_CATEGORIES } from 's' import { logger } from 's' import { generateVideoImportTmpPath } from 's' import { join } from 's' import { root } from 's' import { ensureDir , writeFile , remove } from 's' import * as request from 's' import { createWriteStream } from 's' export type YoutubeDLInfo = { name ? : string description ? : string category ? : number licence ? : number nsfw ? : boolean tags ? : string [ ] thumbnailUrl ? : string originallyPublishedAt ? : Date } const processOptions = { maxBuffer : 0 * 0 * 0 } function getYoutubeDLInfo ( url , opts ? : string [ ] ) < YoutubeDLInfo > { return new Promise < YoutubeDLInfo > ( async ( res , rej ) => { const args = opts || [ 's' , 's' ] const youtubeDL = await safeGetYoutubeDL ( ) youtubeDL . getInfo ( url , args , processOptions , ( err , info ) => { if ( err ) return rej ( err ) if ( info . is_live === true ) return rej ( new Error ( 's' ) ) const obj = buildVideoInfo ( normalizeObject ( info ) ) if ( obj . name && obj . name . length < CONSTRAINTS_FIELDS . VIDEOS . NAME . min ) obj . name += 's' return res ( obj ) } ) } ) } function downloadYoutubeDLVideo ( url , timeout ) { const path = generateVideoImportTmpPath ( url ) let timer logger . info ( 's' , url ) const options = [ 's' , 's' , 's' , path ] if ( process . env . FFMPEG_PATH ) { options . push ( 's' ) options . push ( process . env . FFMPEG_PATH ) } return new Promise < string > ( async ( res , rej ) => { const youtubeDL = await safeGetYoutubeDL ( ) youtubeDL . exec ( url , options , processOptions , err => { clearTimeout ( timer ) if ( err ) { remove ( path ) . catch ( err => logger . error ( 's' , { err } ) ) return rej ( err ) } return res ( path ) } ) timer = setTimeout ( async ( ) => { await remove ( path ) return rej ( new Error ( 's' ) ) } , timeout ) } ) } async function updateYoutubeDLBinary ( ) { logger . info ( 's' ) const binDirectory = join ( root ( ) , 's' , 's' , 's' ) const bin = join ( binDirectory , 's' ) const detailsPath = join ( binDirectory , 's' ) const url = 's' await ensureDir ( binDirectory ) return new Promise ( res => { request . get ( url , { followRedirect : false } , ( err , result ) => { if ( err ) { logger . error ( 's' , { err } ) return res ( ) } if ( result . statusCode !== 0 ) { logger . error ( 's' , result . statusCode ) return res ( ) } const url = result . headers . location const downloadFile = request . get ( url ) const newVersion = "s" . exec ( url ) [ 0 ] downloadFile . on ( 's' , result => { if ( result . statusCode !== 0 ) { logger . error ( 's' , result . statusCode ) return res ( ) } downloadFile . pipe ( createWriteStream ( bin , { mode : 0 } ) ) } ) downloadFile . on ( 's' , err => { logger . error ( 's' , { err } ) return res ( ) } ) downloadFile . on ( 's' , ( ) => { const details = JSON . stringify ( { version : newVersion , path : bin , exec : 's' } ) writeFile ( detailsPath , details , { encoding : 's' } , err => { if ( err ) { logger . error ( 's' , { err } ) return res ( ) } logger . info ( 's' , newVersion ) return res ( ) } ) } ) } ) } ) } async function safeGetYoutubeDL ( ) { let youtubeDL try { youtubeDL = require ( 's' ) } catch ( e ) { await updateYoutubeDLBinary ( ) youtubeDL = require ( 's' ) } return youtubeDL } function buildOriginallyPublishedAt ( obj ) { let originallyPublishedAt = null const uploadDateMatcher = "s" . exec ( obj . upload_date ) if ( uploadDateMatcher ) { originallyPublishedAt = new Date ( ) originallyPublishedAt . setHours ( 0 , 0 , 0 , 0 ) const year = parseInt ( uploadDateMatcher [ 0 ] , 0 ) const month = parseInt ( uploadDateMatcher [ 0 ] , 0 ) - 0 const day = parseInt ( uploadDateMatcher [ 0 ] , 0 ) originallyPublishedAt . setFullYear ( year , month , day ) } return originallyPublishedAt } export { updateYoutubeDLBinary , downloadYoutubeDLVideo , getYoutubeDLInfo , safeGetYoutubeDL , buildOriginallyPublishedAt } function normalizeObject ( obj ) { const newObj = { } for ( const key of Object . keys ( obj ) ) { if ( key === 's' ) continue const value = obj [ key ] if ( typeof value === 's' ) { newObj [ key ] = value . normalize ( ) } else { newObj [ key ] = value } } return newObj } function buildVideoInfo ( obj ) { return { name : titleTruncation ( obj . title ) , description : descriptionTruncation ( obj . description ) , category : getCategory ( obj . categories ) , licence : getLicence ( obj . license ) , nsfw : isNSFW ( obj ) , tags : getTags ( obj . tags ) , thumbnailUrl : obj . thumbnail || undefined , originallyPublishedAt : buildOriginallyPublishedAt ( obj ) } } function titleTruncation ( title ) { return truncate ( title , { 's' : CONSTRAINTS_FIELDS . VIDEOS . NAME . max , 's' : "s" , 's' : 's' } ) } function descriptionTruncation ( description ) { if ( ! description || description . length < CONSTRAINTS_FIELDS . VIDEOS . DESCRIPTION . min ) return undefined return truncate ( description , { 's' : CONSTRAINTS_FIELDS . VIDEOS . DESCRIPTION . max , 's' : "s" , 's' : 's' } ) } function isNSFW ( info ) { return info . age_limit && info . age_limit >= 0 } function getTags ( tags ) { if ( Array . isArray ( tags ) === false ) return [ ] return tags . filter ( t => t . length < CONSTRAINTS_FIELDS . VIDEOS . TAG . max && t . length > CONSTRAINTS_FIELDS . VIDEOS . TAG . min ) . map ( t => t . normalize ( ) ) . slice ( 0 , 0 ) } function getLicence ( licence ) { if ( ! licence ) return undefined if ( licence . indexOf ( 's' ) !== - 0 ) return 0 return undefined } function getCategory ( categories : string [ ] ) { if ( ! categories ) return undefined const categoryString = categories [ 0 ] if ( ! categoryString || typeof categoryString !== 's' ) return undefined if ( categoryString === 's' ) return 0 for ( const key of Object . keys ( VIDEO_CATEGORIES ) ) { const category = VIDEO_CATEGORIES [ key ] if ( categoryString . toLowerCase ( ) === category . toLowerCase ( ) ) return parseInt ( key , 0 ) } return undefined }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { generateVideoImportTmpPath } from 's' import * as WebTorrent from 's' import { createWriteStream , ensureDir , remove } from 's' import { CONFIG } from 's' import { dirname , join } from 's' import * as createTorrent from 's' import { 0 } from 's' async function downloadWebTorrentVideo ( target : { magnetUri : string , torrentName ? : string } , timeout ) { const id = target . magnetUri || target . torrentName let timer const path = generateVideoImportTmpPath ( id ) logger . info ( 's' , id ) const directoryPath = join ( CONFIG . STORAGE . TMP_DIR , 's' ) await ensureDir ( directoryPath ) return new Promise < string > ( ( res , rej ) => { const webtorrent = new WebTorrent ( ) let file : WebTorrent . TorrentFile const torrentId = target . magnetUri || join ( CONFIG . STORAGE . TORRENTS_DIR , target . torrentName ) const options = { path : directoryPath } const torrent = webtorrent . add ( torrentId , options , torrent => { if ( torrent . files . length !== 0 ) { if ( timer ) clearTimeout ( timer ) for ( let file of torrent . files ) { deleteDownloadedFile ( { directoryPath , filepath : file . path } ) } return safeWebtorrentDestroy ( webtorrent , torrentId , undefined , target . torrentName ) . then ( ( ) => rej ( new Error ( 's' + torrentId + 's' ) ) ) } file = torrent . files [ 0 ] const writeStream = createWriteStream ( path ) writeStream . on ( 's' , ( ) => { if ( timer ) clearTimeout ( timer ) return safeWebtorrentDestroy ( webtorrent , torrentId , { directoryPath , filepath : file . path } , target . torrentName ) . then ( ( ) => res ( path ) ) } ) file . createReadStream ( ) . pipe ( writeStream ) } ) torrent . on ( 's' , err => rej ( err ) ) timer = setTimeout ( async ( ) => { return safeWebtorrentDestroy ( webtorrent , torrentId , file ? { directoryPath , filepath : file . path } : undefined , target . torrentName ) . then ( ( ) => rej ( new Error ( 's' ) ) ) } , timeout ) } ) } const createTorrentPromise = 0 < string , any , any > ( createTorrent ) export { createTorrentPromise , downloadWebTorrentVideo } function safeWebtorrentDestroy ( webtorrent : WebTorrent . Instance , torrentId , downloadedFile ? : { directoryPath : string , filepath : string } , torrentName ? ) { return new Promise ( res => { webtorrent . destroy ( err => { if ( torrentName ) { logger . debug ( 's' , torrentId ) remove ( torrentId ) . catch ( err => logger . error ( 's' , torrentId , { err } ) ) } if ( downloadedFile ) deleteDownloadedFile ( downloadedFile ) if ( err ) logger . warn ( 's' , { err } ) return res ( ) } ) } ) } function deleteDownloadedFile ( downloadedFile : { directoryPath : string , filepath : string } ) { let pathToDelete = dirname ( downloadedFile . filepath ) if ( pathToDelete === 's' ) pathToDelete = downloadedFile . filepath const toRemovePath = join ( downloadedFile . directoryPath , pathToDelete ) logger . debug ( 's' , toRemovePath ) remove ( toRemovePath ) . catch ( err => logger . error ( 's' , toRemovePath , { err } ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { downloadYoutubeDLVideo } from 's' import { VideoImportModel } from 's' import { VideoImportState } from 's' import { getDurationFromVideoFile , getVideoFileFPS , getVideoFileResolution } from 's' import { extname , join } from 's' import { VideoFileModel } from 's' import { VIDEO_IMPORT_TIMEOUT } from 's' import { VideoState } from 's' import { JobQueue } from 's' import { federateVideoIfNeeded } from 's' import { VideoModel } from 's' import { downloadWebTorrentVideo } from 's' import { getSecureTorrentName } from 's' import { move , remove , stat } from 's' import { Notifier } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { createVideoMiniatureFromUrl , generateVideoMiniature } from 's' import { ThumbnailType } from 's' import { MThumbnail } from 's' import { MVideoImportDefault , MVideoImportDefaultFiles , MVideoImportVideo } from 's' import { MVideoBlacklistVideo , MVideoBlacklist } from 's' type VideoImportYoutubeDLPayload = { type : 's' videoImportId : number thumbnailUrl : string downloadThumbnail : boolean downloadPreview : boolean } type VideoImportTorrentPayload = { type : 's' | 's' videoImportId : number } export type VideoImportPayload = VideoImportYoutubeDLPayload | VideoImportTorrentPayload async function processVideoImport ( job : Bull . Job ) { const payload = job . data as VideoImportPayload if ( payload . type === 's' ) return processYoutubeDLImport ( job , payload ) if ( payload . type === 's' || payload . type === 's' ) return processTorrentImport ( job , payload ) } export { processVideoImport } async function processTorrentImport ( job : Bull . Job , payload ) { logger . info ( 's' , job . id ) const videoImport = await getVideoImportOrDie ( payload . videoImportId ) const options = { videoImportId : payload . videoImportId , downloadThumbnail : false , downloadPreview : false , generateThumbnail : true , generatePreview : true } const target = { torrentName : videoImport . torrentName ? getSecureTorrentName ( videoImport . torrentName ) : undefined , magnetUri : videoImport . magnetUri } return processFile ( ( ) => downloadWebTorrentVideo ( target , VIDEO_IMPORT_TIMEOUT ) , videoImport , options ) } async function processYoutubeDLImport ( job : Bull . Job , payload ) { logger . info ( 's' , job . id ) const videoImport = await getVideoImportOrDie ( payload . videoImportId ) const options = { videoImportId : videoImport . id , downloadThumbnail : payload . downloadThumbnail , downloadPreview : payload . downloadPreview , thumbnailUrl : payload . thumbnailUrl , generateThumbnail : false , generatePreview : false } return processFile ( ( ) => downloadYoutubeDLVideo ( videoImport . targetUrl , VIDEO_IMPORT_TIMEOUT ) , videoImport , options ) } async function getVideoImportOrDie ( videoImportId ) { const videoImport = await VideoImportModel . loadAndPopulateVideo ( videoImportId ) if ( ! videoImport || ! videoImport . Video ) { throw new Error ( 's' ) } return videoImport } type ProcessFileOptions = { videoImportId : number downloadThumbnail : boolean downloadPreview : boolean thumbnailUrl ? : string generateThumbnail : boolean generatePreview : boolean } async function processFile ( downloader : ( ) => Promise < string > , videoImport , options ) { let tempVideoPath let videoDestFile let videoFile try { tempVideoPath = await downloader ( ) const stats = await stat ( tempVideoPath ) const isAble = await videoImport . User . isAbleToUploadVideo ( { size : stats . size } ) if ( isAble === false ) { throw new Error ( 's' ) } const { videoFileResolution } = await getVideoFileResolution ( tempVideoPath ) const fps = await getVideoFileFPS ( tempVideoPath ) const duration = await getDurationFromVideoFile ( tempVideoPath ) const videoFileData = { extname : extname ( tempVideoPath ) , resolution : videoFileResolution , size : stats . size , fps , videoId : videoImport . videoId } videoFile = new VideoFileModel ( videoFileData ) const videoWithFiles = Object . assign ( videoImport . Video , { VideoFiles : [ videoFile ] } ) const videoImportWithFiles = Object . assign ( videoImport , { Video : videoWithFiles } ) videoDestFile = join ( CONFIG . STORAGE . VIDEOS_DIR , videoImportWithFiles . Video . getVideoFilename ( videoFile ) ) await move ( tempVideoPath , videoDestFile ) tempVideoPath = null let thumbnailModel if ( options . downloadThumbnail && options . thumbnailUrl ) { thumbnailModel = await createVideoMiniatureFromUrl ( options . thumbnailUrl , videoImportWithFiles . Video , ThumbnailType . MINIATURE ) } else if ( options . generateThumbnail || options . downloadThumbnail ) { thumbnailModel = await generateVideoMiniature ( videoImportWithFiles . Video , videoFile , ThumbnailType . MINIATURE ) } let previewModel if ( options . downloadPreview && options . thumbnailUrl ) { previewModel = await createVideoMiniatureFromUrl ( options . thumbnailUrl , videoImportWithFiles . Video , ThumbnailType . PREVIEW ) } else if ( options . generatePreview || options . downloadPreview ) { previewModel = await generateVideoMiniature ( videoImportWithFiles . Video , videoFile , ThumbnailType . PREVIEW ) } await videoImportWithFiles . Video . createTorrentAndSetInfoHash ( videoFile ) const { videoImportUpdated , video } = await sequelizeTypescript . transaction ( async t => { const videoImportToUpdate = videoImportWithFiles as MVideoImportVideo const video = await VideoModel . load ( videoImportToUpdate . videoId , t ) if ( ! video ) throw new Error ( 's' + videoImportToUpdate . videoId + 's' ) const videoFileCreated = await videoFile . save ( { transaction : t } ) videoImportToUpdate . Video = Object . assign ( video , { VideoFiles : [ videoFileCreated ] } ) video . duration = duration video . state = CONFIG . TRANSCODING . ENABLED ? VideoState . TO_TRANSCODE : VideoState . PUBLISHED await video . save ( { transaction : t } ) if ( thumbnailModel ) await video . addAndSaveThumbnail ( thumbnailModel , t ) if ( previewModel ) await video . addAndSaveThumbnail ( previewModel , t ) const videoForFederation = await VideoModel . loadAndPopulateAccountAndServerAndTags ( video . uuid , t ) await federateVideoIfNeeded ( videoForFederation , true , t ) videoImportToUpdate . state = VideoImportState . SUCCESS const videoImportUpdated = await videoImportToUpdate . save ( { transaction : t } ) as MVideoImportVideo videoImportUpdated . Video = video logger . info ( 's' , video . uuid ) return { videoImportUpdated , video : videoForFederation } } ) Notifier . Instance . notifyOnFinishedVideoImport ( videoImportUpdated , true ) if ( video . isBlacklisted ( ) ) { const videoBlacklist = Object . assign ( video . VideoBlacklist , { Video : video } ) Notifier . Instance . notifyOnVideoAutoBlacklist ( videoBlacklist ) } else { Notifier . Instance . notifyOnNewVideoIfNeeded ( video ) } if ( video . state === VideoState . TO_TRANSCODE ) { const dataInput = { type : 's' as 's' , videoUUID : videoImportUpdated . Video . uuid , isNewVideo : true } await JobQueue . Instance . createJob ( { type : 's' , payload : dataInput } ) } } catch ( err ) { try { if ( tempVideoPath ) await remove ( tempVideoPath ) } catch ( errUnlink ) { logger . warn ( 's' , { err : errUnlink } ) } videoImport . error = err . message videoImport . state = VideoImportState . FAILED await videoImport . save ( ) Notifier . Instance . notifyOnFinishedVideoImport ( videoImport , false ) throw err } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportTorrentPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportYoutubeDLPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoImportDefault$ O $ProcessFileOptions$ O O O $string$ O $string$ O $VideoFileModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoImportDefaultFiles$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Redis } from 's' import { logger } from 's' import { VideoModel } from 's' import { VideoViewModel } from 's' import { isTestInstance } from 's' import { federateVideoIfNeeded } from 's' async function processVideosViews ( ) { const lastHour = new Date ( ) if ( ! isTestInstance ( ) ) lastHour . setHours ( lastHour . getHours ( ) - 0 ) const hour = lastHour . getHours ( ) const startDate = lastHour . setMinutes ( 0 , 0 , 0 ) const endDate = lastHour . setMinutes ( 0 , 0 , 0 ) const videoIds = await Redis . Instance . getVideosIdViewed ( hour ) if ( videoIds . length === 0 ) return logger . info ( 's' , hour ) for ( const videoId of videoIds ) { try { const views = await Redis . Instance . getVideoViews ( videoId , hour ) if ( views ) { logger . debug ( 's' , views , videoId , hour ) try { const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoId ) if ( ! video ) { logger . debug ( 's' , videoId ) continue } await VideoViewModel . create ( { startDate , endDate , views , videoId } ) if ( video . isOwned ( ) ) { await VideoModel . incrementViews ( videoId , views ) video . views += views await federateVideoIfNeeded ( video , false ) } } catch ( err ) { logger . error ( 's' , videoId , hour , { err } ) } } await Redis . Instance . deleteVideoViews ( videoId , hour ) } catch ( err ) { logger . error ( 's' , videoId , hour , { err } ) } } } export { processVideosViews }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { fetchVideoByUrl } from 's' import { refreshActorIfNeeded , refreshVideoIfNeeded , refreshVideoPlaylistIfNeeded } from 's' import { ActorModel } from 's' import { VideoPlaylistModel } from 's' export type RefreshPayload = { type : 's' | 's' | 's' url : string } async function refreshAPObject ( job : Bull . Job ) { const payload = job . data as RefreshPayload logger . info ( 's' , job . id , payload . url ) if ( payload . type === 's' ) return refreshVideo ( payload . url ) if ( payload . type === 's' ) return refreshVideoPlaylist ( payload . url ) if ( payload . type === 's' ) return refreshActor ( payload . url ) } export { refreshAPObject } async function refreshVideo ( videoUrl ) { const fetchType = 's' as 's' const syncParam = { likes : true , dislikes : true , shares : true , comments : true , thumbnail : true } const videoFromDatabase = await fetchVideoByUrl ( videoUrl , fetchType ) if ( videoFromDatabase ) { const refreshOptions = { video : videoFromDatabase , fetchedType : fetchType , syncParam } await refreshVideoIfNeeded ( refreshOptions ) } } async function refreshActor ( actorUrl ) { const fetchType = 's' as 's' const actor = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( actorUrl ) if ( actor ) { await refreshActorIfNeeded ( actor , fetchType ) } } async function refreshVideoPlaylist ( playlistUrl ) { const playlist = await VideoPlaylistModel . loadByUrlAndPopulateAccount ( playlistUrl ) if ( playlist ) { await refreshVideoPlaylistIfNeeded ( playlist ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { logger } from 's' import { VideoModel } from 's' import { publishNewResolutionIfNeeded } from 's' import { getVideoFileFPS , getVideoFileResolution } from 's' import { copy , stat } from 's' import { VideoFileModel } from 's' import { extname } from 's' import { MVideoFile , MVideoWithFile } from 's' export type VideoFileImportPayload = { videoUUID : string , filePath : string } async function processVideoFileImport ( job : Bull . Job ) { const payload = job . data as VideoFileImportPayload logger . info ( 's' , job . id ) const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( payload . videoUUID ) if ( ! video ) { logger . info ( 's' , job . id ) return undefined } await updateVideoFile ( video , payload . filePath ) await publishNewResolutionIfNeeded ( video ) return video } export { processVideoFileImport } async function updateVideoFile ( video , inputFilePath ) { const { videoFileResolution } = await getVideoFileResolution ( inputFilePath ) const { size } = await stat ( inputFilePath ) const fps = await getVideoFileFPS ( inputFilePath ) let updatedVideoFile = new VideoFileModel ( { resolution : videoFileResolution , extname : extname ( inputFilePath ) , size , fps , videoId : video . id } ) as MVideoFile const currentVideoFile = video . VideoFiles . find ( videoFile => videoFile . resolution === updatedVideoFile . resolution ) if ( currentVideoFile ) { await video . removeFile ( currentVideoFile ) await video . removeTorrent ( currentVideoFile ) video . VideoFiles = video . VideoFiles . filter ( f => f !== currentVideoFile ) currentVideoFile . extname = updatedVideoFile . extname currentVideoFile . size = updatedVideoFile . size currentVideoFile . fps = updatedVideoFile . fps updatedVideoFile = currentVideoFile } const outputPath = video . getVideoFilePath ( updatedVideoFile ) await copy ( inputFilePath , outputPath ) await video . createTorrentAndSetInfoHash ( updatedVideoFile ) await updatedVideoFile . save ( ) video . VideoFiles . push ( updatedVideoFile ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoWithFile$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bull from 's' import { JobState , JobType } from 's' import { logger } from 's' import { Redis } from 's' import { JOB_ATTEMPTS , JOB_COMPLETED_LIFETIME , JOB_CONCURRENCY , JOB_TTL , REPEAT_JOBS , WEBSERVER } from 's' import { ActivitypubHttpBroadcastPayload , processActivityPubHttpBroadcast } from 's' import { ActivitypubHttpFetcherPayload , processActivityPubHttpFetcher } from 's' import { ActivitypubHttpUnicastPayload , processActivityPubHttpUnicast } from 's' import { EmailPayload , processEmail } from 's' import { processVideoTranscoding , VideoTranscodingPayload } from 's' import { ActivitypubFollowPayload , processActivityPubFollow } from 's' import { processVideoImport , VideoImportPayload } from 's' import { processVideosViews } from 's' import { refreshAPObject , RefreshPayload } from 's' import { processVideoFileImport , VideoFileImportPayload } from 's' type CreateJobArgument = { type : 's' , payload : ActivitypubHttpBroadcastPayload } | { type : 's' , payload : ActivitypubHttpUnicastPayload } | { type : 's' , payload : ActivitypubHttpFetcherPayload } | { type : 's' , payload : ActivitypubFollowPayload } | { type : 's' , payload : VideoFileImportPayload } | { type : 's' , payload : VideoTranscodingPayload } | { type : 's' , payload : EmailPayload } | { type : 's' , payload : VideoImportPayload } | { type : 's' , payload : RefreshPayload } | { type : 's' , payload : { } } const handlers : { [ id in ( JobType | 's' ) ] : ( job : Bull . Job ) => Promise < any > } = { 's' : processActivityPubHttpBroadcast , 's' : processActivityPubHttpUnicast , 's' : processActivityPubHttpFetcher , 's' : processActivityPubFollow , 's' : processVideoFileImport , 's' : processVideoTranscoding , 's' : processVideoTranscoding , 's' : processEmail , 's' : processVideoImport , 's' : processVideosViews , 's' : refreshAPObject } const jobTypes : JobType [ ] = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class JobQueue { private static instance : JobQueue private queues : { [ id in JobType ] ? : Bull . Queue } = { } private initialized = false private jobRedisPrefix : string private constructor ( ) { } async init ( ) { if ( this . initialized === true ) return this . initialized = true this . jobRedisPrefix = 's' + WEBSERVER . HOST const queueOptions = { prefix : this . jobRedisPrefix , redis : Redis . getRedisClientOptions ( ) , settings : { maxStalledCount : 0 } } for ( const handlerName of Object . keys ( handlers ) ) { const queue = new Bull ( handlerName , queueOptions ) const handler = handlers [ handlerName ] queue . process ( JOB_CONCURRENCY [ handlerName ] , handler ) . catch ( err => logger . error ( 's' , handlerName , { err } ) ) queue . on ( 's' , ( job , err ) => { logger . error ( 's' , job . id , handlerName , { payload : job . data , err } ) } ) queue . on ( 's' , err => { logger . error ( 's' , handlerName , { err } ) } ) this . queues [ handlerName ] = queue } this . addRepeatableJobs ( ) } terminate ( ) { for ( const queueName of Object . keys ( this . queues ) ) { const queue = this . queues [ queueName ] queue . close ( ) } } createJob ( obj ) { const queue = this . queues [ obj . type ] if ( queue === undefined ) { logger . error ( 's' , obj . type ) throw Error ( 's' ) } const jobArgs : Bull . JobOptions = { backoff : { delay : 0 * 0 , type : 's' } , attempts : JOB_ATTEMPTS [ obj . type ] , timeout : JOB_TTL [ obj . type ] } return queue . add ( obj . payload , jobArgs ) } async listForApi ( state , start , count , asc ? ) < Bull . Job [ ] > { let results : Bull . Job [ ] = [ ] for ( const jobType of jobTypes ) { const queue = this . queues [ jobType ] if ( queue === undefined ) { logger . error ( 's' , jobType ) continue } const jobs = await ( queue as any ) . getJobs ( state , 0 , start + count , asc ) results = results . concat ( jobs ) } results . sort ( ( 0 , 0 ) => { if ( 0 . timestamp < 0 . timestamp ) return - 0 else if ( 0 . timestamp === 0 . timestamp ) return 0 return 0 } ) if ( asc === false ) results . reverse ( ) return results . slice ( start , start + count ) } async count ( state ) < number > { let total = 0 for ( const type of jobTypes ) { const queue = this . queues [ type ] if ( queue === undefined ) { logger . error ( 's' , type ) continue } const counts = await queue . getJobCounts ( ) total += counts [ state ] } return total } async removeOldJobs ( ) { for ( const key of Object . keys ( this . queues ) ) { const queue = this . queues [ key ] await queue . clean ( JOB_COMPLETED_LIFETIME , 's' ) } } private addRepeatableJobs ( ) { this . queues [ 's' ] . add ( { } , { repeat : REPEAT_JOBS [ 's' ] } ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { JobQueue }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateJobArgument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $JobState$ O $number$ O $number$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $JobState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
import { ActorModel } from 's' import * as Bluebird from 's' import { MActorFull , MActorAccountChannelId } from 's' type ActorFetchByUrlType = 's' | 's' function fetchActorByUrl ( url , fetchType ) < MActorFull | MActorAccountChannelId > { if ( fetchType === 's' ) return ActorModel . loadByUrlAndPopulateAccountAndChannel ( url ) if ( fetchType === 's' ) return ActorModel . loadByUrl ( url ) } export { ActorFetchByUrlType , fetchActorByUrl }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O $ActorFetchByUrlType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { Transaction } from 's' import * as url from 's' import * as 0 from 's' import { ActivityPubActor , ActivityPubActorType } from 's' import { ActivityPubAttributedTo } from 's' import { checkUrlsSameHost , getAPId } from 's' import { sanitizeAndCheckActorObject } from 's' import { isActivityPubUrlValid } from 's' import { retryTransactionWrapper , updateInstanceWithAnother } from 's' import { logger } from 's' import { createPrivateAndPublicKeys } from 's' import { doRequest } from 's' import { getUrlFromWebfinger } from 's' import { MIMETYPES , WEBSERVER } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { AvatarModel } from 's' import { ServerModel } from 's' import { VideoChannelModel } from 's' import { JobQueue } from 's' import { getServerActor } from 's' import { ActorFetchByUrlType , fetchActorByUrl } from 's' import { sequelizeTypescript } from 's' import { MAccount , MAccountDefault , MActor , MActorAccountChannelId , MActorAccountChannelIdActor , MActorAccountId , MActorDefault , MActorFull , MActorFullActor , MActorId , MChannel , MChannelAccountDefault } from 's' function setAsyncActorKeys < T extends MActor > ( actor : T ) { return createPrivateAndPublicKeys ( ) . then ( ( { publicKey , privateKey } ) => { actor . publicKey = publicKey actor . privateKey = privateKey return actor . save ( ) } ) . catch ( err => { logger . error ( 's' , actor . url , { err } ) return actor } ) } function getOrCreateActorAndServerAndModel ( activityActor : string | ActivityPubActor , fetchType : 's' , recurseIfNeeded ? , updateCollections ? ) < MActorFullActor > function getOrCreateActorAndServerAndModel ( activityActor : string | ActivityPubActor , fetchType ? : 's' , recurseIfNeeded ? , updateCollections ? ) < MActorAccountChannelId > async function getOrCreateActorAndServerAndModel ( activityActor : string | ActivityPubActor , fetchType = 's' , recurseIfNeeded = true , updateCollections = false ) < MActorFullActor | MActorAccountChannelId > { const actorUrl = getAPId ( activityActor ) let created = false let accountPlaylistsUrl let actor = await fetchActorByUrl ( actorUrl , fetchType ) if ( actor && ( ! actor . Account && ! actor . VideoChannel ) ) { await actor . destroy ( ) actor = null } if ( ! actor ) { const { result } = await fetchRemoteActor ( actorUrl ) if ( result === undefined ) throw new Error ( 's' + actorUrl ) let ownerActor if ( recurseIfNeeded === true && result . actor . type === 's' ) { const accountAttributedTo = result . attributedTo . find ( a => a . type === 's' ) if ( ! accountAttributedTo ) throw new Error ( 's' + actor . url ) if ( checkUrlsSameHost ( accountAttributedTo . id , actorUrl ) !== true ) { throw new Error ( `template` ) } try { const recurseIfNeeded = false ownerActor = await getOrCreateActorAndServerAndModel ( accountAttributedTo . id , 's' , recurseIfNeeded ) } catch ( err ) { logger . error ( 's' + actor . url ) throw new Error ( err ) } } actor = await retryTransactionWrapper ( saveActorAndServerAndModelIfNotExist , result , ownerActor ) created = true accountPlaylistsUrl = result . playlists } if ( actor . Account ) ( actor as MActorAccountChannelIdActor ) . Account . Actor = actor if ( actor . VideoChannel ) ( actor as MActorAccountChannelIdActor ) . VideoChannel . Actor = actor const { actor : actorRefreshed , refreshed } = await retryTransactionWrapper ( refreshActorIfNeeded , actor , fetchType ) if ( ! actorRefreshed ) throw new Error ( 's' + actorRefreshed . url + 's' ) if ( ( created === true || refreshed === true ) && updateCollections === true ) { const payload = { uri : actor . outboxUrl , type : 's' as 's' } await JobQueue . Instance . createJob ( { type : 's' , payload } ) } if ( created === true && actor . Account && accountPlaylistsUrl ) { const payload = { uri : accountPlaylistsUrl , accountId : actor . Account . id , type : 's' as 's' } await JobQueue . Instance . createJob ( { type : 's' , payload } ) } return actorRefreshed } function buildActorInstance ( type , url , preferredUsername , uuid ? ) { return new ActorModel ( { type , url , preferredUsername , uuid , publicKey : null , privateKey : null , followersCount : 0 , followingCount : 0 , inboxUrl : url + 's' , outboxUrl : url + 's' , sharedInboxUrl : WEBSERVER . URL + 's' , followersUrl : url + 's' , followingUrl : url + 's' } ) as MActor } async function updateActorInstance ( actorInstance , attributes ) { const followersCount = await fetchActorTotalItems ( attributes . followers ) const followingCount = await fetchActorTotalItems ( attributes . following ) actorInstance . type = attributes . type actorInstance . preferredUsername = attributes . preferredUsername actorInstance . url = attributes . id actorInstance . publicKey = attributes . publicKey . publicKeyPem actorInstance . followersCount = followersCount actorInstance . followingCount = followingCount actorInstance . inboxUrl = attributes . inbox actorInstance . outboxUrl = attributes . outbox actorInstance . sharedInboxUrl = attributes . endpoints . sharedInbox actorInstance . followersUrl = attributes . followers actorInstance . followingUrl = attributes . following } type AvatarInfo = { name : string , onDisk : boolean , fileUrl : string } async function updateActorAvatarInstance ( actor , info , t ) { if ( info . name !== undefined ) { if ( actor . avatarId ) { try { await actor . Avatar . destroy ( { transaction : t } ) } catch ( err ) { logger . error ( 's' , actor . url , { err } ) } } const avatar = await AvatarModel . create ( { filename : info . name , onDisk : info . onDisk , fileUrl : info . fileUrl } , { transaction : t } ) actor . avatarId = avatar . id actor . Avatar = avatar } return actor } async function fetchActorTotalItems ( url ) { const options = { uri : url , method : 's' , json : true , activityPub : true } try { const { body } = await doRequest ( options ) return body . totalItems ? body . totalItems : 0 } catch ( err ) { logger . warn ( 's' , url , { err } ) return 0 } } async function getAvatarInfoIfExists ( actorJSON ) { if ( actorJSON . icon && actorJSON . icon . type === 's' && MIMETYPES . IMAGE . MIMETYPE_EXT [ actorJSON . icon . mediaType ] !== undefined && isActivityPubUrlValid ( actorJSON . icon . url ) ) { const extension = MIMETYPES . IMAGE . MIMETYPE_EXT [ actorJSON . icon . mediaType ] return { name : 0 ( ) + extension , fileUrl : actorJSON . icon . url } } return undefined } async function addFetchOutboxJob ( actor < ActorModel , 's' | 's' > ) { const serverActor = await getServerActor ( ) if ( serverActor . id === actor . id ) { logger . error ( 's' ) return undefined } const payload = { uri : actor . outboxUrl , type : 's' as 's' } return JobQueue . Instance . createJob ( { type : 's' , payload } ) } async function refreshActorIfNeeded < T extends MActorFull | MActorAccountChannelId > ( actorArg : T , fetchedType ) < { actor : T | MActorFull , refreshed : boolean } > { if ( ! actorArg . isOutdated ( ) ) return { actor : actorArg , refreshed : false } const actor = fetchedType === 's' ? actorArg as MActorFull : await ActorModel . loadByUrlAndPopulateAccountAndChannel ( actorArg . url ) try { let actorUrl try { actorUrl = await getUrlFromWebfinger ( actor . preferredUsername + 's' + actor . getHost ( ) ) } catch ( err ) { logger . warn ( 's' , err ) actorUrl = actor . url } const { result , statusCode } = await fetchRemoteActor ( actorUrl ) if ( statusCode === 0 ) { logger . info ( 's' , actor . url ) actor . Account ? actor . Account . destroy ( ) : actor . VideoChannel . destroy ( ) return { actor : undefined , refreshed : false } } if ( result === undefined ) { logger . warn ( 's' ) return { actor , refreshed : false } } return sequelizeTypescript . transaction ( async t => { updateInstanceWithAnother ( actor , result . actor ) if ( result . avatar !== undefined ) { const avatarInfo = { name : result . avatar . name , fileUrl : result . avatar . fileUrl , onDisk : false } await updateActorAvatarInstance ( actor , avatarInfo , t ) } actor . setDataValue ( 's' , new Date ( ) ) await actor . save ( { transaction : t } ) if ( actor . Account ) { actor . Account . name = result . name actor . Account . description = result . summary await actor . Account . save ( { transaction : t } ) } else if ( actor . VideoChannel ) { actor . VideoChannel . name = result . name actor . VideoChannel . description = result . summary actor . VideoChannel . support = result . support await actor . VideoChannel . save ( { transaction : t } ) } return { refreshed : true , actor } } ) } catch ( err ) { logger . warn ( 's' , actor . url , { err } ) return { actor , refreshed : false } } } export { getOrCreateActorAndServerAndModel , buildActorInstance , setAsyncActorKeys , fetchActorTotalItems , getAvatarInfoIfExists , updateActorInstance , refreshActorIfNeeded , updateActorAvatarInstance , addFetchOutboxJob } function saveActorAndServerAndModelIfNotExist ( result , ownerActor ? , t ? ) : Bluebird < MActorFullActor > | Promise < MActorFullActor > { let actor = result . actor if ( t !== undefined ) return save ( t ) return sequelizeTypescript . transaction ( t => save ( t ) ) async function save ( t ) { const actorHost = url . parse ( actor . url ) . host const serverOptions = { where : { host : actorHost } , defaults : { host : actorHost } , transaction : t } const [ server ] = await ServerModel . findOrCreate ( serverOptions ) actor . serverId = server . id if ( result . avatar ) { const avatar = await AvatarModel . create ( { filename : result . avatar . name , fileUrl : result . avatar . fileUrl , onDisk : false } , { transaction : t } ) actor . avatarId = avatar . id } const [ actorCreated ] = await ActorModel . findOrCreate < MActorFullActor > ( { defaults : actor . toJSON ( ) , where : { url : actor . url } , transaction : t } ) if ( actorCreated . type === 's' || actorCreated . type === 's' ) { actorCreated . Account = await saveAccount ( actorCreated , result , t ) as MAccountDefault actorCreated . Account . Actor = actorCreated } else if ( actorCreated . type === 's' ) { const channel = await saveVideoChannel ( actorCreated , result , ownerActor , t ) actorCreated . VideoChannel = Object . assign ( channel , { Actor : actorCreated , Account : ownerActor . Account } ) } actorCreated . Server = server return actorCreated } } type FetchRemoteActorResult = { actor : MActor name : string summary : string support ? : string playlists ? : string avatar ? : { name : string , fileUrl : string } attributedTo : ActivityPubAttributedTo [ ] } async function fetchRemoteActor ( actorUrl ) < { statusCode ? : number , result : FetchRemoteActorResult } > { const options = { uri : actorUrl , method : 's' , json : true , activityPub : true } logger . info ( 's' , actorUrl ) const requestResult = await doRequest < ActivityPubActor > ( options ) const actorJSON = requestResult . body if ( sanitizeAndCheckActorObject ( actorJSON ) === false ) { logger . debug ( 's' , { actorJSON } ) return { result : undefined , statusCode : requestResult . response . statusCode } } if ( checkUrlsSameHost ( actorJSON . id , actorUrl ) !== true ) { logger . warn ( 's' , actorUrl , actorJSON . id ) return { result : undefined , statusCode : requestResult . response . statusCode } } const followersCount = await fetchActorTotalItems ( actorJSON . followers ) const followingCount = await fetchActorTotalItems ( actorJSON . following ) const actor = new ActorModel ( { type : actorJSON . type , preferredUsername : actorJSON . preferredUsername , url : actorJSON . id , publicKey : actorJSON . publicKey . publicKeyPem , privateKey : null , followersCount : followersCount , followingCount : followingCount , inboxUrl : actorJSON . inbox , outboxUrl : actorJSON . outbox , sharedInboxUrl : actorJSON . endpoints . sharedInbox , followersUrl : actorJSON . followers , followingUrl : actorJSON . following } ) const avatarInfo = await getAvatarInfoIfExists ( actorJSON ) const name = actorJSON . name || actorJSON . preferredUsername return { statusCode : requestResult . response . statusCode , result : { actor , name , avatar : avatarInfo , summary : actorJSON . summary , support : actorJSON . support , playlists : actorJSON . playlists , attributedTo : actorJSON . attributedTo } } } async function saveAccount ( actor , result , t ) { const [ accountCreated ] = await AccountModel . findOrCreate ( { defaults : { name : result . name , description : result . summary , actorId : actor . id } , where : { actorId : actor . id } , transaction : t } ) return accountCreated as MAccount } async function saveVideoChannel ( actor , result , ownerActor , t ) { const [ videoChannelCreated ] = await VideoChannelModel . findOrCreate ( { defaults : { name : result . name , description : result . summary , support : result . support , actorId : actor . id , accountId : ownerActor . Account . id } , where : { actorId : actor . id } , transaction : t } ) return videoChannelCreated as MChannel }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O $boolean$ O O $boolean$ O O O O O $Promise$ O O O O O O O O O O O O O $boolean$ O O $boolean$ O O O O O O $Promise$ O O O O O O O $ActorFetchByUrlType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFullActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityPubActorType$ O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorModel$ O $ActivityPubActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorDefault$ O $AvatarInfo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityPubActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Pick$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O $ActorFetchByUrlType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FetchRemoteActorResult$ O O $MActorFullActor$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorId$ O $FetchRemoteActorResult$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorId$ O $FetchRemoteActorResult$ O $MActorAccountId$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Activity } from 's' import { MActorDefault , MActorSignature } from 's' export type APProcessorOptions < T extends Activity > = { activity : T byActor : MActorSignature inboxActor ? : MActorDefault fromFetch ? : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityAccept } from 's' import { ActorFollowModel } from 's' import { addFetchOutboxJob } from 's' import { APProcessorOptions } from 's' import { MActorDefault , MActorSignature } from 's' async function processAcceptActivity ( options < ActivityAccept > ) { const { byActor : targetActor , inboxActor } = options if ( inboxActor === undefined ) throw new Error ( 's' ) return processAccept ( inboxActor , targetActor ) } export { processAcceptActivity } async function processAccept ( actor , targetActor ) { const follow = await ActorFollowModel . loadByActorAndTarget ( actor . id , targetActor . id ) if ( ! follow ) throw new Error ( 's' ) if ( follow . state !== 's' ) { follow . state = 's' await follow . save ( ) await addFetchOutboxJob ( targetActor ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorDefault$ O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityAnnounce } from 's' import { retryTransactionWrapper } from 's' import { sequelizeTypescript } from 's' import { VideoShareModel } from 's' import { forwardVideoRelatedActivity } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { Notifier } from 's' import { logger } from 's' import { APProcessorOptions } from 's' import { MActorSignature , MVideoAccountLightBlacklistAllFiles } from 's' async function processAnnounceActivity ( options < ActivityAnnounce > ) { const { activity , byActor : actorAnnouncer } = options const notify = options . fromFetch !== true return retryTransactionWrapper ( processVideoShare , actorAnnouncer , activity , notify ) } export { processAnnounceActivity } async function processVideoShare ( actorAnnouncer , activity , notify ) { const objectUri = typeof activity . object === 's' ? activity . object : activity . object . id let video let videoCreated try { const result = await getOrCreateVideoAndAccountAndChannel ( { videoObject : objectUri } ) video = result . video videoCreated = result . created } catch ( err ) { logger . debug ( 's' , objectUri , { err } ) return } await sequelizeTypescript . transaction ( async t => { const share = { actorId : actorAnnouncer . id , videoId : video . id , url : activity . id } const [ , created ] = await VideoShareModel . findOrCreate ( { where : { url : activity . id } , defaults : share , transaction : t } ) if ( video . isOwned ( ) && created === true ) { const exceptions = [ actorAnnouncer ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } return undefined } ) if ( videoCreated && notify ) Notifier . Instance . notifyOnNewVideoIfNeeded ( video ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityAnnounce$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLightBlacklistAllFiles$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CacheFileObject } from 's' import { VideoRedundancyModel } from 's' import { Transaction } from 's' import { VideoStreamingPlaylistType } from 's' import { MActorId , MVideoRedundancy , MVideoWithAllFiles } from 's' function cacheFileActivityObjectToDBAttributes ( cacheFileObject , video , byActor ) { if ( cacheFileObject . url . mediaType === 's' ) { const url = cacheFileObject . url const playlist = video . VideoStreamingPlaylists . find ( t => t . type === VideoStreamingPlaylistType . HLS ) if ( ! playlist ) throw new Error ( 's' + video . url ) return { expiresOn : new Date ( cacheFileObject . expires ) , url : cacheFileObject . id , fileUrl : url . href , strategy : null , videoStreamingPlaylistId : playlist . id , actorId : byActor . id } } const url = cacheFileObject . url const videoFile = video . VideoFiles . find ( f => { return f . resolution === url . height && f . fps === url . fps } ) if ( ! videoFile ) throw new Error ( `template` ) return { expiresOn : new Date ( cacheFileObject . expires ) , url : cacheFileObject . id , fileUrl : url . href , strategy : null , videoFileId : videoFile . id , actorId : byActor . id } } async function createOrUpdateCacheFile ( cacheFileObject , video , byActor , t ) { const redundancyModel = await VideoRedundancyModel . loadByUrl ( cacheFileObject . id , t ) if ( ! redundancyModel ) { await createCacheFile ( cacheFileObject , video , byActor , t ) } else { await updateCacheFile ( cacheFileObject , redundancyModel , video , byActor , t ) } } function createCacheFile ( cacheFileObject , video , byActor , t ) { const attributes = cacheFileActivityObjectToDBAttributes ( cacheFileObject , video , byActor ) return VideoRedundancyModel . create ( attributes , { transaction : t } ) } function updateCacheFile ( cacheFileObject , redundancyModel , video , byActor , t ) { if ( redundancyModel . actorId !== byActor . id ) { throw new Error ( 's' + redundancyModel . url + 's' ) } const attributes = cacheFileActivityObjectToDBAttributes ( cacheFileObject , video , byActor ) redundancyModel . expiresOn = attributes . expiresOn redundancyModel . fileUrl = attributes . fileUrl return redundancyModel . save ( { transaction : t } ) } export { createOrUpdateCacheFile , createCacheFile , updateCacheFile , cacheFileActivityObjectToDBAttributes }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O $MVideoWithAllFiles$ O $MActorId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O $MVideoWithAllFiles$ O $MActorId$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O $MVideoWithAllFiles$ O $MActorId$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CacheFileObject$ O $MVideoRedundancy$ O $MVideoWithAllFiles$ O $MActorId$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityCreate , CacheFileObject , VideoTorrentObject } from 's' import { VideoCommentObject } from 's' import { retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { resolveThread } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { forwardVideoRelatedActivity } from 's' import { createOrUpdateCacheFile } from 's' import { Notifier } from 's' import { PlaylistObject } from 's' import { createOrUpdateVideoPlaylist } from 's' import { APProcessorOptions } from 's' import { MActorSignature , MCommentOwnerVideo , MVideoAccountLightBlacklistAllFiles } from 's' async function processCreateActivity ( options < ActivityCreate > ) { const { activity , byActor } = options const notify = options . fromFetch !== true const activityObject = activity . object const activityType = activityObject . type if ( activityType === 's' ) { return processCreateVideo ( activity , notify ) } if ( activityType === 's' ) { return retryTransactionWrapper ( processCreateVideoComment , activity , byActor , notify ) } if ( activityType === 's' ) { return retryTransactionWrapper ( processCreateCacheFile , activity , byActor ) } if ( activityType === 's' ) { return retryTransactionWrapper ( processCreatePlaylist , activity , byActor ) } logger . warn ( 's' , activityType , { activity : activity . id } ) return Promise . resolve ( undefined ) } export { processCreateActivity } async function processCreateVideo ( activity , notify ) { const videoToCreateData = activity . object as VideoTorrentObject const { video , created } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : videoToCreateData } ) if ( created && notify ) Notifier . Instance . notifyOnNewVideoIfNeeded ( video ) return video } async function processCreateCacheFile ( activity , byActor ) { const cacheFile = activity . object as CacheFileObject const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : cacheFile . object } ) await sequelizeTypescript . transaction ( async t => { return createOrUpdateCacheFile ( cacheFile , video , byActor , t ) } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , undefined , exceptions , video ) } } async function processCreateVideoComment ( activity , byActor , notify ) { const commentObject = activity . object as VideoCommentObject const byAccount = byActor . Account if ( ! byAccount ) throw new Error ( 's' + byActor . url ) let video let created let comment try { const resolveThreadResult = await resolveThread ( { url : commentObject . id , isVideo : false } ) video = resolveThreadResult . video created = resolveThreadResult . commentCreated comment = resolveThreadResult . comment } catch ( err ) { logger . debug ( 's' , commentObject . inReplyTo , { err } ) return } if ( video . isOwned ( ) && created === true ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , undefined , exceptions , video ) } if ( created && notify ) Notifier . Instance . notifyOnNewComment ( comment ) } async function processCreatePlaylist ( activity , byActor ) { const playlistObject = activity . object as PlaylistObject const byAccount = byActor . Account if ( ! byAccount ) throw new Error ( 's' + byActor . url ) await createOrUpdateVideoPlaylist ( playlistObject , byAccount , activity . to ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityCreate$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityCreate$ O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityCreate$ O $MActorSignature$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLightBlacklistAllFiles$ O $boolean$ O $MCommentOwnerVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityCreate$ O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityDelete } from 's' import { retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { ActorModel } from 's' import { VideoModel } from 's' import { VideoCommentModel } from 's' import { forwardVideoRelatedActivity } from 's' import { VideoPlaylistModel } from 's' import { APProcessorOptions } from 's' import { MAccountActor , MActor , MActorSignature , MChannelActor , MChannelActorAccountActor } from 's' async function processDeleteActivity ( options < ActivityDelete > ) { const { activity , byActor } = options const objectUrl = typeof activity . object === 's' ? activity . object : activity . object . id if ( activity . actor === objectUrl ) { const byActorFull = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( byActor . url ) if ( byActorFull . type === 's' ) { if ( ! byActorFull . Account ) throw new Error ( 's' + byActorFull . url + 's' ) const accountToDelete = byActorFull . Account as MAccountActor accountToDelete . Actor = byActorFull return retryTransactionWrapper ( processDeleteAccount , accountToDelete ) } else if ( byActorFull . type === 's' ) { if ( ! byActorFull . VideoChannel ) throw new Error ( 's' + byActorFull . url + 's' ) const channelToDelete = byActorFull . VideoChannel as MChannelActorAccountActor channelToDelete . Actor = byActorFull return retryTransactionWrapper ( processDeleteVideoChannel , channelToDelete ) } } { const videoCommentInstance = await VideoCommentModel . loadByUrlAndPopulateAccountAndVideo ( objectUrl ) if ( videoCommentInstance ) { return retryTransactionWrapper ( processDeleteVideoComment , byActor , videoCommentInstance , activity ) } } { const videoInstance = await VideoModel . loadByUrlAndPopulateAccount ( objectUrl ) if ( videoInstance ) { if ( videoInstance . isOwned ( ) ) throw new Error ( `template` ) return retryTransactionWrapper ( processDeleteVideo , byActor , videoInstance ) } } { const videoPlaylist = await VideoPlaylistModel . loadByUrlAndPopulateAccount ( objectUrl ) if ( videoPlaylist ) { if ( videoPlaylist . isOwned ( ) ) throw new Error ( `template` ) return retryTransactionWrapper ( processDeleteVideoPlaylist , byActor , videoPlaylist ) } } return undefined } export { processDeleteActivity } async function processDeleteVideo ( actor , videoToDelete ) { logger . debug ( 's' , videoToDelete . uuid ) await sequelizeTypescript . transaction ( async t => { if ( videoToDelete . VideoChannel . Account . Actor . id !== actor . id ) { throw new Error ( 's' + actor . url + 's' + videoToDelete . VideoChannel . Actor . url ) } await videoToDelete . destroy ( { transaction : t } ) } ) logger . info ( 's' , videoToDelete . uuid ) } async function processDeleteVideoPlaylist ( actor , playlistToDelete ) { logger . debug ( 's' , playlistToDelete . uuid ) await sequelizeTypescript . transaction ( async t => { if ( playlistToDelete . OwnerAccount . Actor . id !== actor . id ) { throw new Error ( 's' + actor . url + 's' + playlistToDelete . url ) } await playlistToDelete . destroy ( { transaction : t } ) } ) logger . info ( 's' , playlistToDelete . uuid ) } async function processDeleteAccount ( accountToRemove ) { logger . debug ( 's' , accountToRemove . Actor . url ) await sequelizeTypescript . transaction ( async t => { await accountToRemove . destroy ( { transaction : t } ) } ) logger . info ( 's' , accountToRemove . Actor . url ) } async function processDeleteVideoChannel ( videoChannelToRemove ) { logger . debug ( 's' , videoChannelToRemove . Actor . url ) await sequelizeTypescript . transaction ( async t => { await videoChannelToRemove . destroy ( { transaction : t } ) } ) logger . info ( 's' , videoChannelToRemove . Actor . url ) } function processDeleteVideoComment ( byActor , videoComment , activity ) { logger . debug ( 's' , videoComment . url ) return sequelizeTypescript . transaction ( async t => { if ( byActor . Account . id !== videoComment . Account . id && byActor . Account . id !== videoComment . Video . VideoChannel . accountId ) { throw new Error ( `template` ) } await videoComment . destroy ( { transaction : t } ) if ( videoComment . Video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , videoComment . Video ) } logger . info ( 's' , videoComment . url ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $VideoModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $VideoPlaylistModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MChannelActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $VideoCommentModel$ O $ActivityDelete$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { MActorFollowActors } from 's' import { CONFIG } from 's' import { SERVER_ACTOR_NAME } from 's' import { JobQueue } from 's' import { logger } from 's' import { getServerActor } from 's' import { ServerModel } from 's' async function autoFollowBackIfNeeded ( actorFollow ) { if ( ! CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_BACK . ENABLED ) return const follower = actorFollow . ActorFollower if ( follower . type === 's' && follower . preferredUsername === SERVER_ACTOR_NAME ) { logger . info ( 's' , follower . url ) const me = await getServerActor ( ) const server = await ServerModel . load ( follower . serverId ) const host = server . host const payload = { host , name : SERVER_ACTOR_NAME , followerActorId : me . id , isAutoFollow : true } JobQueue . Instance . createJob ( { type : 's' , payload } ) . catch ( err => logger . error ( 's' , host , err ) ) } } export { autoFollowBackIfNeeded }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityFollow } from 's' import { retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { sendAccept , sendReject } from 's' import { Notifier } from 's' import { getAPId } from 's' import { getServerActor } from 's' import { CONFIG } from 's' import { APProcessorOptions } from 's' import { MActorFollowActors , MActorSignature } from 's' import { autoFollowBackIfNeeded } from 's' async function processFollowActivity ( options < ActivityFollow > ) { const { activity , byActor } = options const activityObject = getAPId ( activity . object ) return retryTransactionWrapper ( processFollow , byActor , activityObject ) } export { processFollowActivity } async function processFollow ( byActor , targetActorURL ) { const { actorFollow , created , isFollowingInstance , targetActor } = await sequelizeTypescript . transaction ( async t => { const targetActor = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( targetActorURL , t ) if ( ! targetActor ) throw new Error ( 's' ) if ( targetActor . isOwned ( ) === false ) throw new Error ( 's' ) const serverActor = await getServerActor ( ) const isFollowingInstance = targetActor . id === serverActor . id if ( isFollowingInstance && CONFIG . FOLLOWERS . INSTANCE . ENABLED === false ) { logger . info ( 's' , targetActor . url ) await sendReject ( byActor , targetActor ) return { actorFollow : undefined as MActorFollowActors } } const [ actorFollow , created ] = await ActorFollowModel . findOrCreate < MActorFollowActors > ( { where : { actorId : byActor . id , targetActorId : targetActor . id } , defaults : { actorId : byActor . id , targetActorId : targetActor . id , state : CONFIG . FOLLOWERS . INSTANCE . MANUAL_APPROVAL ? 's' : 's' } , transaction : t } ) if ( actorFollow . state !== 's' && CONFIG . FOLLOWERS . INSTANCE . MANUAL_APPROVAL === false ) { actorFollow . state = 's' await actorFollow . save ( { transaction : t } ) } actorFollow . ActorFollower = byActor actorFollow . ActorFollowing = targetActor if ( actorFollow . state === 's' ) { await sendAccept ( actorFollow ) await autoFollowBackIfNeeded ( actorFollow ) } return { actorFollow , created , isFollowingInstance , targetActor } } ) if ( ! actorFollow ) return if ( created ) { const follower = await ActorModel . loadFull ( byActor . id ) const actorFollowFull = Object . assign ( actorFollow , { ActorFollowing : targetActor , ActorFollower : follower } ) if ( isFollowingInstance ) { Notifier . Instance . notifyOfNewInstanceFollow ( actorFollowFull ) } else { Notifier . Instance . notifyOfNewUserFollow ( actorFollowFull ) } } logger . info ( 's' , targetActorURL , byActor . url ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityLike } from 's' import { retryTransactionWrapper } from 's' import { sequelizeTypescript } from 's' import { AccountVideoRateModel } from 's' import { forwardVideoRelatedActivity } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { getVideoLikeActivityPubUrl } from 's' import { getAPId } from 's' import { APProcessorOptions } from 's' import { MActorSignature } from 's' async function processLikeActivity ( options < ActivityLike > ) { const { activity , byActor } = options return retryTransactionWrapper ( processLikeVideo , byActor , activity ) } export { processLikeActivity } async function processLikeVideo ( byActor , activity ) { const videoUrl = getAPId ( activity . object ) const byAccount = byActor . Account if ( ! byAccount ) throw new Error ( 's' + byActor . url ) const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : videoUrl } ) return sequelizeTypescript . transaction ( async t => { const url = getVideoLikeActivityPubUrl ( byActor , video ) const existingRate = await AccountVideoRateModel . loadByAccountAndVideoOrUrl ( byAccount . id , video . id , url ) if ( existingRate && existingRate . type === 's' ) return if ( existingRate && existingRate . type === 's' ) { await video . decrement ( 's' , { transaction : t } ) } await video . increment ( 's' , { transaction : t } ) const rate = existingRate || new AccountVideoRateModel ( ) rate . type = 's' rate . videoId = video . id rate . accountId = byAccount . id rate . url = url await rate . save ( { transaction : t } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityLike$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityReject } from 's' import { sequelizeTypescript } from 's' import { ActorFollowModel } from 's' import { APProcessorOptions } from 's' import { MActor } from 's' async function processRejectActivity ( options < ActivityReject > ) { const { byActor : targetActor , inboxActor } = options if ( inboxActor === undefined ) throw new Error ( 's' ) return processReject ( inboxActor , targetActor ) } export { processRejectActivity } async function processReject ( follower , targetActor ) { return sequelizeTypescript . transaction ( async t => { const actorFollow = await ActorFollowModel . loadByActorAndTarget ( follower . id , targetActor . id , t ) if ( ! actorFollow ) throw new Error ( `template` ) await actorFollow . destroy ( { transaction : t } ) return undefined } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityAnnounce , ActivityFollow , ActivityLike , ActivityUndo , CacheFileObject } from 's' import { DislikeObject } from 's' import { retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { AccountVideoRateModel } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { forwardVideoRelatedActivity } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { VideoShareModel } from 's' import { VideoRedundancyModel } from 's' import { APProcessorOptions } from 's' import { MActorSignature } from 's' async function processUndoActivity ( options < ActivityUndo > ) { const { activity , byActor } = options const activityToUndo = activity . object if ( activityToUndo . type === 's' ) { return retryTransactionWrapper ( processUndoLike , byActor , activity ) } if ( activityToUndo . type === 's' ) { if ( activityToUndo . object . type === 's' ) { return retryTransactionWrapper ( processUndoDislike , byActor , activity ) } else if ( activityToUndo . object . type === 's' ) { return retryTransactionWrapper ( processUndoCacheFile , byActor , activity ) } } if ( activityToUndo . type === 's' ) { return retryTransactionWrapper ( processUndoDislike , byActor , activity ) } if ( activityToUndo . type === 's' ) { return retryTransactionWrapper ( processUndoFollow , byActor , activityToUndo ) } if ( activityToUndo . type === 's' ) { return retryTransactionWrapper ( processUndoAnnounce , byActor , activityToUndo ) } logger . warn ( 's' , activityToUndo . type , { activity : activity . id } ) return undefined } export { processUndoActivity } async function processUndoLike ( byActor , activity ) { const likeActivity = activity . object as ActivityLike const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : likeActivity . object } ) return sequelizeTypescript . transaction ( async t => { if ( ! byActor . Account ) throw new Error ( 's' + byActor . url ) const rate = await AccountVideoRateModel . loadByAccountAndVideoOrUrl ( byActor . Account . id , video . id , likeActivity . id , t ) if ( ! rate || rate . type !== 's' ) throw new Error ( `template` ) await rate . destroy ( { transaction : t } ) await video . decrement ( 's' , { transaction : t } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } } ) } async function processUndoDislike ( byActor , activity ) { const dislike = activity . object . type === 's' ? activity . object : activity . object . object as DislikeObject const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : dislike . object } ) return sequelizeTypescript . transaction ( async t => { if ( ! byActor . Account ) throw new Error ( 's' + byActor . url ) const rate = await AccountVideoRateModel . loadByAccountAndVideoOrUrl ( byActor . Account . id , video . id , dislike . id , t ) if ( ! rate || rate . type !== 's' ) throw new Error ( `template` ) await rate . destroy ( { transaction : t } ) await video . decrement ( 's' , { transaction : t } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } } ) } async function processUndoCacheFile ( byActor , activity ) { const cacheFileObject = activity . object . object as CacheFileObject const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : cacheFileObject . object } ) return sequelizeTypescript . transaction ( async t => { const cacheFile = await VideoRedundancyModel . loadByUrl ( cacheFileObject . id ) if ( ! cacheFile ) { logger . debug ( 's' , cacheFileObject . id ) return } if ( cacheFile . actorId !== byActor . id ) throw new Error ( 's' + cacheFile . url + 's' ) await cacheFile . destroy ( ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } } ) } function processUndoFollow ( follower , followActivity ) { return sequelizeTypescript . transaction ( async t => { const following = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( followActivity . object , t ) const actorFollow = await ActorFollowModel . loadByActorAndTarget ( follower . id , following . id , t ) if ( ! actorFollow ) throw new Error ( `template` ) await actorFollow . destroy ( { transaction : t } ) return undefined } ) } function processUndoAnnounce ( byActor , announceActivity ) { return sequelizeTypescript . transaction ( async t => { const share = await VideoShareModel . loadByUrl ( announceActivity . id , t ) if ( ! share ) throw new Error ( `template` ) if ( share . actorId !== byActor . id ) throw new Error ( `template` ) await share . destroy ( { transaction : t } ) if ( share . Video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( announceActivity , t , exceptions , share . Video ) } } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUndo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUndo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUndo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityFollow$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityAnnounce$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityUpdate , CacheFileObject , VideoTorrentObject } from 's' import { ActivityPubActor } from 's' import { resetSequelizeInstance , retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { AccountModel } from 's' import { ActorModel } from 's' import { VideoChannelModel } from 's' import { getAvatarInfoIfExists , updateActorAvatarInstance , updateActorInstance } from 's' import { getOrCreateVideoAndAccountAndChannel , getOrCreateVideoChannelFromVideoObject , updateVideoFromAP } from 's' import { sanitizeAndCheckVideoTorrentObject } from 's' import { isCacheFileObjectValid } from 's' import { createOrUpdateCacheFile } from 's' import { forwardVideoRelatedActivity } from 's' import { PlaylistObject } from 's' import { createOrUpdateVideoPlaylist } from 's' import { APProcessorOptions } from 's' import { MActorSignature , MAccountIdActor } from 's' async function processUpdateActivity ( options < ActivityUpdate > ) { const { activity , byActor } = options const objectType = activity . object . type if ( objectType === 's' ) { return retryTransactionWrapper ( processUpdateVideo , byActor , activity ) } if ( objectType === 's' || objectType === 's' || objectType === 's' ) { const byActorFull = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( byActor . url ) return retryTransactionWrapper ( processUpdateActor , byActorFull , activity ) } if ( objectType === 's' ) { const byActorFull = await ActorModel . loadByUrlAndPopulateAccountAndChannel ( byActor . url ) return retryTransactionWrapper ( processUpdateCacheFile , byActorFull , activity ) } if ( objectType === 's' ) { return retryTransactionWrapper ( processUpdatePlaylist , byActor , activity ) } return undefined } export { processUpdateActivity } async function processUpdateVideo ( actor , activity ) { const videoObject = activity . object as VideoTorrentObject if ( sanitizeAndCheckVideoTorrentObject ( videoObject ) === false ) { logger . debug ( 's' , { videoObject } ) return undefined } const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : videoObject . id , allowRefresh : false , fetchType : 's' } ) const channelActor = await getOrCreateVideoChannelFromVideoObject ( videoObject ) const account = actor . Account as MAccountIdActor account . Actor = actor const updateOptions = { video , videoObject , account , channel : channelActor . VideoChannel , overrideTo : activity . to } return updateVideoFromAP ( updateOptions ) } async function processUpdateCacheFile ( byActor , activity ) { const cacheFileObject = activity . object as CacheFileObject if ( ! isCacheFileObjectValid ( cacheFileObject ) ) { logger . debug ( 's' , { cacheFileObject } ) return undefined } const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : cacheFileObject . object } ) await sequelizeTypescript . transaction ( async t => { await createOrUpdateCacheFile ( cacheFileObject , video , byActor , t ) } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , undefined , exceptions , video ) } } async function processUpdateActor ( actor , activity ) { const actorAttributesToUpdate = activity . object as ActivityPubActor logger . debug ( 's' , actorAttributesToUpdate . url ) let accountOrChannelInstance : AccountModel | VideoChannelModel let actorFieldsSave let accountOrChannelFieldsSave const avatarInfo = await getAvatarInfoIfExists ( actorAttributesToUpdate ) try { await sequelizeTypescript . transaction ( async t => { actorFieldsSave = actor . toJSON ( ) if ( actorAttributesToUpdate . type === 's' ) accountOrChannelInstance = actor . VideoChannel else accountOrChannelInstance = actor . Account accountOrChannelFieldsSave = accountOrChannelInstance . toJSON ( ) await updateActorInstance ( actor , actorAttributesToUpdate ) if ( avatarInfo !== undefined ) { const avatarOptions = Object . assign ( { } , avatarInfo , { onDisk : false } ) await updateActorAvatarInstance ( actor , avatarOptions , t ) } await actor . save ( { transaction : t } ) accountOrChannelInstance . name = actorAttributesToUpdate . name || actorAttributesToUpdate . preferredUsername accountOrChannelInstance . description = actorAttributesToUpdate . summary if ( accountOrChannelInstance instanceof VideoChannelModel ) accountOrChannelInstance . support = actorAttributesToUpdate . support await accountOrChannelInstance . save ( { transaction : t } ) } ) logger . info ( 's' , actorAttributesToUpdate . url ) } catch ( err ) { if ( actor !== undefined && actorFieldsSave !== undefined ) { resetSequelizeInstance ( actor , actorFieldsSave ) } if ( accountOrChannelInstance !== undefined && accountOrChannelFieldsSave !== undefined ) { resetSequelizeInstance ( accountOrChannelInstance , accountOrChannelFieldsSave ) } logger . debug ( 's' , { err } ) throw err } } async function processUpdatePlaylist ( byActor , activity ) { const playlistObject = activity . object as PlaylistObject const byAccount = byActor . Account if ( ! byAccount ) throw new Error ( 's' + byActor . url ) await createOrUpdateVideoPlaylist ( playlistObject , byAccount , activity . to ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorModel$ O $ActivityUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O $ActivityUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityCreate , ActivityDislike } from 's' import { DislikeObject } from 's' import { retryTransactionWrapper } from 's' import { sequelizeTypescript } from 's' import { AccountVideoRateModel } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { forwardVideoRelatedActivity } from 's' import { getVideoDislikeActivityPubUrl } from 's' import { APProcessorOptions } from 's' import { MActorSignature } from 's' async function processDislikeActivity ( options < ActivityCreate | ActivityDislike > ) { const { activity , byActor } = options return retryTransactionWrapper ( processDislike , activity , byActor ) } export { processDislikeActivity } async function processDislike ( activity : ActivityCreate | ActivityDislike , byActor ) { const dislikeObject = activity . type === 's' ? activity . object : ( activity . object as DislikeObject ) . object const byAccount = byActor . Account if ( ! byAccount ) throw new Error ( 's' + byActor . url ) const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : dislikeObject } ) return sequelizeTypescript . transaction ( async t => { const url = getVideoDislikeActivityPubUrl ( byActor , video ) const existingRate = await AccountVideoRateModel . loadByAccountAndVideoOrUrl ( byAccount . id , video . id , url ) if ( existingRate && existingRate . type === 's' ) return await video . increment ( 's' , { transaction : t } ) if ( existingRate && existingRate . type === 's' ) { await video . decrement ( 's' , { transaction : t } ) } const rate = existingRate || new AccountVideoRateModel ( ) rate . type = 's' rate . videoId = video . id rate . accountId = byAccount . id rate . url = url await rate . save ( { transaction : t } ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , t , exceptions , video ) } } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityCreate , ActivityFlag , VideoAbuseState } from 's' import { VideoAbuseObject } from 's' import { retryTransactionWrapper } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { VideoAbuseModel } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { Notifier } from 's' import { getAPId } from 's' import { APProcessorOptions } from 's' import { MActorSignature , MVideoAbuseVideo } from 's' async function processFlagActivity ( options < ActivityCreate | ActivityFlag > ) { const { activity , byActor } = options return retryTransactionWrapper ( processCreateVideoAbuse , activity , byActor ) } export { processFlagActivity } async function processCreateVideoAbuse ( activity : ActivityCreate | ActivityFlag , byActor ) { const flag = activity . type === 's' ? activity : ( activity . object as VideoAbuseObject ) const account = byActor . Account if ( ! account ) throw new Error ( 's' + byActor . url ) const objects = Array . isArray ( flag . object ) ? flag . object : [ flag . object ] for ( const object of objects ) { try { logger . debug ( 's' , getAPId ( object ) ) const { video } = await getOrCreateVideoAndAccountAndChannel ( { videoObject : object } ) const videoAbuse = await sequelizeTypescript . transaction ( async t => { const videoAbuseData = { reporterAccountId : account . id , reason : flag . content , videoId : video . id , state : VideoAbuseState . PENDING } const videoAbuseInstance = await VideoAbuseModel . create ( videoAbuseData , { transaction : t } ) as MVideoAbuseVideo videoAbuseInstance . Video = video logger . info ( 's' , flag . object ) return videoAbuseInstance } ) Notifier . Instance . notifyOnNewVideoAbuse ( videoAbuse ) } catch ( err ) { logger . debug ( 's' , getAPId ( object ) , { err } ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { getOrCreateVideoAndAccountAndChannel } from 's' import { forwardVideoRelatedActivity } from 's' import { Redis } from 's' import { ActivityCreate , ActivityView , ViewObject } from 's' import { APProcessorOptions } from 's' import { MActorSignature } from 's' async function processViewActivity ( options < ActivityCreate | ActivityView > ) { const { activity , byActor } = options return processCreateView ( activity , byActor ) } export { processViewActivity } async function processCreateView ( activity : ActivityView | ActivityCreate , byActor ) { const videoObject = activity . type === 's' ? activity . object : ( activity . object as ViewObject ) . object const options = { videoObject , fetchType : 's' as 's' } const { video } = await getOrCreateVideoAndAccountAndChannel ( options ) await Redis . Instance . addVideoView ( video . id ) if ( video . isOwned ( ) ) { const exceptions = [ byActor ] await forwardVideoRelatedActivity ( activity , undefined , exceptions , video ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorSignature$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Activity , ActivityType } from 's' import { checkUrlsSameHost , getAPId } from 's' import { logger } from 's' import { processAcceptActivity } from 's' import { processAnnounceActivity } from 's' import { processCreateActivity } from 's' import { processDeleteActivity } from 's' import { processFollowActivity } from 's' import { processLikeActivity } from 's' import { processRejectActivity } from 's' import { processUndoActivity } from 's' import { processUpdateActivity } from 's' import { getOrCreateActorAndServerAndModel } from 's' import { processDislikeActivity } from 's' import { processFlagActivity } from 's' import { processViewActivity } from 's' import { APProcessorOptions } from 's' import { MActorDefault , MActorSignature } from 's' const processActivity : { [ P in ActivityType ] : ( options < Activity > ) => Promise < any > } = { Create : processCreateActivity , Update : processUpdateActivity , Delete : processDeleteActivity , Follow : processFollowActivity , Accept : processAcceptActivity , Reject : processRejectActivity , Announce : processAnnounceActivity , Undo : processUndoActivity , Like : processLikeActivity , Dislike : processDislikeActivity , Flag : processFlagActivity , View : processViewActivity } async function processActivities ( activities : Activity [ ] , options : { signatureActor ? : MActorSignature inboxActor ? : MActorDefault outboxUrl ? : string fromFetch ? : boolean } = { } ) { const { outboxUrl , signatureActor , inboxActor , fromFetch = false } = options const actorsCache : { [ url ] : MActorSignature } = { } for ( const activity of activities ) { if ( ! signatureActor && [ 's' , 's' , 's' ] . includes ( activity . type ) === false ) { logger . error ( 's' , activity . id , activity . type ) continue } const actorUrl = getAPId ( activity . actor ) if ( signatureActor && actorUrl !== signatureActor . url ) { logger . warn ( 's' , actorUrl , signatureActor . url ) continue } if ( outboxUrl && checkUrlsSameHost ( outboxUrl , actorUrl ) !== true ) { logger . warn ( 's' , outboxUrl , actorUrl ) continue } const byActor = signatureActor || actorsCache [ actorUrl ] || await getOrCreateActorAndServerAndModel ( actorUrl ) actorsCache [ actorUrl ] = byActor const activityProcessor = processActivity [ activity . type ] if ( activityProcessor === undefined ) { logger . warn ( 's' , activity . type , { activityId : activity . id } ) continue } try { await activityProcessor ( { activity , byActor , inboxActor , fromFetch } ) } catch ( err ) { logger . warn ( 's' , activity . type , { err } ) } } } export { processActivities }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $APProcessorOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's'	O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Video , VideoDetails , VideoFile } from 's' import { VideoModel } from 's' import { ActivityPlaylistInfohashesObject , ActivityPlaylistSegmentHashesObject , ActivityUrlObject , VideoTorrentObject } from 's' import { MIMETYPES , WEBSERVER } from 's' import { VideoCaptionModel } from 's' import { getVideoCommentsActivityPubUrl , getVideoDislikesActivityPubUrl , getVideoLikesActivityPubUrl , getVideoSharesActivityPubUrl } from 's' import { isArray } from 's' import { VideoStreamingPlaylist } from 's' import { MStreamingPlaylistRedundanciesOpt , MVideo , MVideoAP , MVideoFormattable , MVideoFormattableDetails } from 's' import { MStreamingPlaylistRedundancies } from 's' import { MVideoFileRedundanciesOpt } from 's' export type VideoFormattingJSONOptions = { completeDescription ? : boolean additionalAttributes : { state ? : boolean , waitTranscoding ? : boolean , scheduledUpdate ? : boolean , blacklistInfo ? : boolean } } function videoModelToFormattedJSON ( video , options ? ) { const userHistory = isArray ( video . UserVideoHistories ) ? video . UserVideoHistories [ 0 ] : undefined const videoObject = { id : video . id , uuid : video . uuid , name : video . name , category : { id : video . category , label : VideoModel . getCategoryLabel ( video . category ) } , licence : { id : video . licence , label : VideoModel . getLicenceLabel ( video . licence ) } , language : { id : video . language , label : VideoModel . getLanguageLabel ( video . language ) } , privacy : { id : video . privacy , label : VideoModel . getPrivacyLabel ( video . privacy ) } , nsfw : video . nsfw , description : options && options . completeDescription === true ? video . description : video . getTruncatedDescription ( ) , isLocal : video . isOwned ( ) , duration : video . duration , views : video . views , likes : video . likes , dislikes : video . dislikes , thumbnailPath : video . getMiniatureStaticPath ( ) , previewPath : video . getPreviewStaticPath ( ) , embedPath : video . getEmbedStaticPath ( ) , createdAt : video . createdAt , updatedAt : video . updatedAt , publishedAt : video . publishedAt , originallyPublishedAt : video . originallyPublishedAt , account : video . VideoChannel . Account . toFormattedSummaryJSON ( ) , channel : video . VideoChannel . toFormattedSummaryJSON ( ) , userHistory : userHistory ? { currentTime : userHistory . currentTime } : undefined } if ( options ) { if ( options . additionalAttributes . state === true ) { videoObject . state = { id : video . state , label : VideoModel . getStateLabel ( video . state ) } } if ( options . additionalAttributes . waitTranscoding === true ) { videoObject . waitTranscoding = video . waitTranscoding } if ( options . additionalAttributes . scheduledUpdate === true && video . ScheduleVideoUpdate ) { videoObject . scheduledUpdate = { updateAt : video . ScheduleVideoUpdate . updateAt , privacy : video . ScheduleVideoUpdate . privacy || undefined } } if ( options . additionalAttributes . blacklistInfo === true ) { videoObject . blacklisted = ! ! video . VideoBlacklist videoObject . blacklistedReason = video . VideoBlacklist ? video . VideoBlacklist . reason : null } } return videoObject } function videoModelToFormattedDetailsJSON ( video ) { const formattedJson = video . toFormattedJSON ( { additionalAttributes : { scheduledUpdate : true , blacklistInfo : true } } ) const { baseUrlHttp , baseUrlWs } = video . getBaseUrls ( ) const tags = video . Tags ? video . Tags . map ( t => t . name ) : [ ] const streamingPlaylists = streamingPlaylistsModelToFormattedJSON ( video . VideoStreamingPlaylists ) const detailsJson = { support : video . support , descriptionPath : video . getDescriptionAPIPath ( ) , channel : video . VideoChannel . toFormattedJSON ( ) , account : video . VideoChannel . Account . toFormattedJSON ( ) , tags , commentsEnabled : video . commentsEnabled , downloadEnabled : video . downloadEnabled , waitTranscoding : video . waitTranscoding , state : { id : video . state , label : VideoModel . getStateLabel ( video . state ) } , trackerUrls : video . getTrackerUrls ( baseUrlHttp , baseUrlWs ) , files : [ ] , streamingPlaylists } detailsJson . files = videoFilesModelToFormattedJSON ( video , video . VideoFiles ) return Object . assign ( formattedJson , detailsJson ) } function streamingPlaylistsModelToFormattedJSON ( playlists : MStreamingPlaylistRedundanciesOpt [ ] ) : VideoStreamingPlaylist [ ] { if ( isArray ( playlists ) === false ) return [ ] return playlists . map ( playlist => { const redundancies = isArray ( playlist . RedundancyVideos ) ? playlist . RedundancyVideos . map ( r => ( { baseUrl : r . fileUrl } ) ) : [ ] return { id : playlist . id , type : playlist . type , playlistUrl : playlist . playlistUrl , 0 : playlist . 0 , redundancies } as VideoStreamingPlaylist } ) } function videoFilesModelToFormattedJSON ( video , videoFiles : MVideoFileRedundanciesOpt [ ] ) : VideoFile [ ] { const { baseUrlHttp , baseUrlWs } = video . getBaseUrls ( ) return videoFiles . map ( videoFile => { let resolutionLabel = videoFile . resolution + 's' return { resolution : { id : videoFile . resolution , label : resolutionLabel } , magnetUri : video . generateMagnetUri ( videoFile , baseUrlHttp , baseUrlWs ) , size : videoFile . size , fps : videoFile . fps , torrentUrl : video . getTorrentUrl ( videoFile , baseUrlHttp ) , torrentDownloadUrl : video . getTorrentDownloadUrl ( videoFile , baseUrlHttp ) , fileUrl : video . getVideoFileUrl ( videoFile , baseUrlHttp ) , fileDownloadUrl : video . getVideoFileDownloadUrl ( videoFile , baseUrlHttp ) } as VideoFile } ) . sort ( ( a , b ) => { if ( a . resolution . id < b . resolution . id ) return 0 if ( a . resolution . id === b . resolution . id ) return 0 return - 0 } ) } function videoModelToActivityPubObject ( video ) { const { baseUrlHttp , baseUrlWs } = video . getBaseUrls ( ) if ( ! video . Tags ) video . Tags = [ ] const tag = video . Tags . map ( t => ( { type : 's' as 's' , name : t . name } ) ) let language if ( video . language ) { language = { identifier : video . language , name : VideoModel . getLanguageLabel ( video . language ) } } let category if ( video . category ) { category = { identifier : video . category + 's' , name : VideoModel . getCategoryLabel ( video . category ) } } let licence if ( video . licence ) { licence = { identifier : video . licence + 's' , name : VideoModel . getLicenceLabel ( video . licence ) } } const url : ActivityUrlObject [ ] = [ ] for ( const file of video . VideoFiles ) { url . push ( { type : 's' , mimeType : MIMETYPES . VIDEO . EXT_MIMETYPE [ file . extname ] as any , mediaType : MIMETYPES . VIDEO . EXT_MIMETYPE [ file . extname ] as any , href : video . getVideoFileUrl ( file , baseUrlHttp ) , height : file . resolution , size : file . size , fps : file . fps } ) url . push ( { type : 's' , mimeType : 's' as 's' , mediaType : 's' as 's' , href : video . getTorrentUrl ( file , baseUrlHttp ) , height : file . resolution } ) url . push ( { type : 's' , mimeType : 's' as 's' , mediaType : 's' as 's' , href : video . generateMagnetUri ( file , baseUrlHttp , baseUrlWs ) , height : file . resolution } ) } for ( const playlist of ( video . VideoStreamingPlaylists || [ ] ) ) { let tag : ( ActivityPlaylistSegmentHashesObject | ActivityPlaylistInfohashesObject ) [ ] tag = playlist . 0 . map ( i => ( { type : 's' as 's' , name : i } ) ) tag . push ( { type : 's' , name : 's' , mimeType : 's' as 's' , mediaType : 's' as 's' , href : playlist . 0 } ) url . push ( { type : 's' , mimeType : 's' as 's' , mediaType : 's' as 's' , href : playlist . playlistUrl , tag } ) } url . push ( { type : 's' , mimeType : 's' , mediaType : 's' , href : WEBSERVER . URL + 's' + video . uuid } ) const subtitleLanguage = [ ] for ( const caption of video . VideoCaptions ) { subtitleLanguage . push ( { identifier : caption . language , name : VideoCaptionModel . getLanguageLabel ( caption . language ) } ) } const miniature = video . getMiniature ( ) return { type : 's' as 's' , id : video . url , name : video . name , duration : getActivityStreamDuration ( video . duration ) , uuid : video . uuid , tag , category , licence , language , views : video . views , sensitive : video . nsfw , waitTranscoding : video . waitTranscoding , state : video . state , commentsEnabled : video . commentsEnabled , downloadEnabled : video . downloadEnabled , published : video . publishedAt . toISOString ( ) , originallyPublishedAt : video . originallyPublishedAt ? video . originallyPublishedAt . toISOString ( ) : null , updated : video . updatedAt . toISOString ( ) , mediaType : 's' , content : video . getTruncatedDescription ( ) , support : video . support , subtitleLanguage , icon : { type : 's' , url : miniature . getFileUrl ( ) , mediaType : 's' , width : miniature . width , height : miniature . height } , url , likes : getVideoLikesActivityPubUrl ( video ) , dislikes : getVideoDislikesActivityPubUrl ( video ) , shares : getVideoSharesActivityPubUrl ( video ) , comments : getVideoCommentsActivityPubUrl ( video ) , attributedTo : [ { type : 's' , id : video . VideoChannel . Account . Actor . url } , { type : 's' , id : video . VideoChannel . Actor . url } ] } } function getActivityStreamDuration ( duration ) { return 's' + duration + 's' } export { videoModelToFormattedJSON , videoModelToFormattedDetailsJSON , videoFilesModelToFormattedJSON , videoModelToActivityPubObject , getActivityStreamDuration }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O $MVideoFormattable$ O O $VideoFormattingJSONOptions$ O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O $MVideoFormattableDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTorrentObject$ O $MVideoAP$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { buildFileLocale , getDefaultLocale , 0 , POSSIBLE_LOCALES } from 's' import { CUSTOM_HTML_TAG_COMMENTS , EMBED_SIZE , PLUGIN_GLOBAL_CSS_PATH , WEBSERVER } from 's' import { join } from 's' import { escapeHTML , 0 } from 's' import { VideoModel } from 's' import * as validator from 's' import { VideoPrivacy } from 's' import { readFile } from 's' import { getActivityStreamDuration } from 's' import { AccountModel } from 's' import { VideoChannelModel } from 's' import * as Bluebird from 's' import { CONFIG } from 's' import { logger } from 's' import { MAccountActor , MChannelActor , MVideo } from 's' export class ClientHtml { private static htmlCache : { [ path ] : string } = { } static invalidCache ( ) { logger . info ( 's' ) ClientHtml . htmlCache = { } } static async getDefaultHTMLPage ( req : express . Request , res : express . Response , paramLang ? ) { const html = await ClientHtml . getIndexHTML ( req , res , paramLang ) let customHtml = ClientHtml . addTitleTag ( html ) customHtml = ClientHtml . addDescriptionTag ( customHtml ) return customHtml } static async getWatchHTMLPage ( videoId , req : express . Request , res : express . Response ) { if ( ! validator . isInt ( videoId ) && ! validator . isUUID ( videoId , 0 ) ) { return ClientHtml . getIndexHTML ( req , res ) } const [ html , video ] = await Promise . all ( [ ClientHtml . getIndexHTML ( req , res ) , VideoModel . loadWithBlacklist ( videoId ) ] ) if ( ! video || video . privacy === VideoPrivacy . PRIVATE || video . VideoBlacklist ) { return ClientHtml . getIndexHTML ( req , res ) } let customHtml = ClientHtml . addTitleTag ( html , escapeHTML ( video . name ) ) customHtml = ClientHtml . addDescriptionTag ( customHtml , escapeHTML ( video . description ) ) customHtml = ClientHtml . addVideoOpenGraphAndOEmbedTags ( customHtml , video ) return customHtml } static async getAccountHTMLPage ( nameWithHost , req : express . Request , res : express . Response ) { return this . getAccountOrChannelHTMLPage ( ( ) => AccountModel . loadByNameWithHost ( nameWithHost ) , req , res ) } static async getVideoChannelHTMLPage ( nameWithHost , req : express . Request , res : express . Response ) { return this . getAccountOrChannelHTMLPage ( ( ) => VideoChannelModel . loadByNameWithHostAndPopulateAccount ( nameWithHost ) , req , res ) } private static async getAccountOrChannelHTMLPage ( loader : ( ) => Bluebird < MAccountActor | MChannelActor > , req : express . Request , res : express . Response ) { const [ html , entity ] = await Promise . all ( [ ClientHtml . getIndexHTML ( req , res ) , loader ( ) ] ) if ( ! entity ) { return ClientHtml . getIndexHTML ( req , res ) } let customHtml = ClientHtml . addTitleTag ( html , escapeHTML ( entity . getDisplayName ( ) ) ) customHtml = ClientHtml . addDescriptionTag ( customHtml , escapeHTML ( entity . description ) ) customHtml = ClientHtml . addAccountOrChannelMetaTags ( customHtml , entity ) return customHtml } private static async getIndexHTML ( req : express . Request , res : express . Response , paramLang ? ) { const path = ClientHtml . getIndexPath ( req , res , paramLang ) if ( ClientHtml . htmlCache [ path ] ) return ClientHtml . htmlCache [ path ] const buffer = await readFile ( path ) let html = buffer . toString ( ) html = ClientHtml . addCustomCSS ( html ) html = await ClientHtml . addAsyncPluginCSS ( html ) ClientHtml . htmlCache [ path ] = html return html } private static getIndexPath ( req : express . Request , res : express . Response , paramLang ? ) { let lang if ( paramLang && 0 ( paramLang ) ) { lang = paramLang res . cookie ( 's' , lang , { secure : WEBSERVER . SCHEME === 's' , sameSite : true , maxAge : 0 * 0 * 0 * 0 } ) } else if ( req . cookies . clientLanguage && 0 ( req . cookies . clientLanguage ) ) { lang = req . cookies . clientLanguage } else { lang = req . acceptsLanguages ( POSSIBLE_LOCALES ) || getDefaultLocale ( ) } return join ( __dirname , 's' + buildFileLocale ( lang ) + 's' ) } private static addTitleTag ( htmlStringPage , title ? ) { let text = title || CONFIG . INSTANCE . NAME if ( title ) text += `template` const titleTag = `template` return htmlStringPage . replace ( CUSTOM_HTML_TAG_COMMENTS . TITLE , titleTag ) } private static addDescriptionTag ( htmlStringPage , description ? ) { const content = description || CONFIG . INSTANCE . SHORT_DESCRIPTION const descriptionTag = `template` return htmlStringPage . replace ( CUSTOM_HTML_TAG_COMMENTS . DESCRIPTION , descriptionTag ) } private static addCustomCSS ( htmlStringPage ) { const styleTag = `template` return htmlStringPage . replace ( CUSTOM_HTML_TAG_COMMENTS . CUSTOM_CSS , styleTag ) } private static async addAsyncPluginCSS ( htmlStringPage ) { const globalCSSContent = await readFile ( PLUGIN_GLOBAL_CSS_PATH ) if ( globalCSSContent . byteLength === 0 ) return htmlStringPage const fileHash = 0 ( globalCSSContent ) const linkTag = `template` return htmlStringPage . replace ( 's' , linkTag + 's' ) } private static addVideoOpenGraphAndOEmbedTags ( htmlStringPage , video ) { const previewUrl = WEBSERVER . URL + video . getPreviewStaticPath ( ) const videoUrl = WEBSERVER . URL + video . getWatchStaticPath ( ) const videoNameEscaped = escapeHTML ( video . name ) const videoDescriptionEscaped = escapeHTML ( video . description ) const embedUrl = WEBSERVER . URL + video . getEmbedStaticPath ( ) const openGraphMetaTags = { 's' : 's' , 's' : videoNameEscaped , 's' : previewUrl , 's' : videoUrl , 's' : videoDescriptionEscaped , 's' : embedUrl , 's' : embedUrl , 's' : 's' , 's' : EMBED_SIZE . width , 's' : EMBED_SIZE . height , 's' : videoNameEscaped , 's' : videoDescriptionEscaped , 's' : previewUrl , 's' : CONFIG . SERVICES . TWITTER . WHITELISTED ? 's' : 's' , 's' : CONFIG . SERVICES . TWITTER . USERNAME , 's' : videoNameEscaped , 's' : videoDescriptionEscaped , 's' : previewUrl , 's' : embedUrl , 's' : EMBED_SIZE . width , 's' : EMBED_SIZE . height } const oembedLinkTags = [ { type : 's' , href : WEBSERVER . URL + 's' + encodeURIComponent ( videoUrl ) , title : videoNameEscaped } ] const schemaTags = { 's' : 's' , 's' : 's' , name : videoNameEscaped , description : videoDescriptionEscaped , thumbnailUrl : previewUrl , uploadDate : video . createdAt . toISOString ( ) , duration : getActivityStreamDuration ( video . duration ) , contentUrl : videoUrl , embedUrl : embedUrl , interactionCount : video . views } let tagsString = 's' Object . keys ( openGraphMetaTags ) . forEach ( tagName => { const tagValue = openGraphMetaTags [ tagName ] tagsString += `template` } ) for ( const oembedLinkTag of oembedLinkTags ) { tagsString += `template` } tagsString += `template` tagsString += `template` return this . addOpenGraphAndOEmbedTags ( htmlStringPage , tagsString ) } private static addAccountOrChannelMetaTags ( htmlStringPage , entity : MAccountActor | MChannelActor ) { const metaTags = `template` return this . addOpenGraphAndOEmbedTags ( htmlStringPage , metaTags ) } private static addOpenGraphAndOEmbedTags ( htmlStringPage , metaTags ) { return htmlStringPage . replace ( CUSTOM_HTML_TAG_COMMENTS . META_TAGS , metaTags ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $MVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O
export type PluginTranslation = { [ npmName ] : { [ key ] : string } }	O O O O O O $string$ O O O O $string$ O O O O O
import { PluginModel } from 's' import { logger } from 's' import { basename , join } from 's' import { CONFIG } from 's' import { isLibraryCodeValid , isPackageJSONValid } from 's' import { ClientScript , PluginPackageJson , PluginTranslationPaths as PackagePluginTranslations } from 's' import { createReadStream , createWriteStream } from 's' import { PLUGIN_GLOBAL_CSS_PATH , VIDEO_CATEGORIES , VIDEO_LANGUAGES , VIDEO_LICENCES } from 's' import { PluginType } from 's' import { installNpmPlugin , installNpmPluginFromDisk , removeNpmPlugin } from 's' import { outputFile , readJSON } from 's' import { PluginSettingsManager } from 's' import { PluginStorageManager } from 's' import { ServerHook , ServerHookName , serverHookObject } from 's' import { getHookType , internalRunHook } from 's' import { RegisterServerOptions } from 's' import { PluginLibrary } from 's' import { ClientHtml } from 's' import { RegisterServerHookOptions } from 's' import { RegisterServerSettingOptions } from 's' import { PluginVideoLanguageManager } from 's' import { PluginVideoCategoryManager } from 's' import { PluginVideoLicenceManager } from 's' import { PluginTranslation } from 's' export interface RegisteredPlugin { npmName : string name : string version : string description : string peertubeEngine : string type : PluginType path : string staticDirs : { [ name ] : string } clientScripts : { [ name ] : ClientScript } css : string [ ] unregister ? : Function } export interface HookInformationValue { npmName : string pluginName : string handler : Function priority : number } type AlterableVideoConstant = 's' | 's' | 's' type VideoConstant = { [ key in number | string ] : string } type UpdatedVideoConstant = { [ name in AlterableVideoConstant ] : { [ npmName ] : { added : { key : number | string , label : string } [ ] , deleted : { key : number | string , label : string } [ ] } } } type PluginLocalesTranslations = { [ locale ] : PluginTranslation } export class PluginManager implements ServerHook { private static instance : PluginManager private registeredPlugins : { [ name ] : RegisteredPlugin } = { } private settings : { [ name ] : RegisterServerSettingOptions [ ] } = { } private hooks : { [ name ] : HookInformationValue [ ] } = { } private translations : PluginLocalesTranslations = { } private updatedVideoConstants : UpdatedVideoConstant = { language : { } , licence : { } , category : { } } private constructor ( ) { } isRegistered ( npmName ) { return ! ! this . getRegisteredPluginOrTheme ( npmName ) } getRegisteredPluginOrTheme ( npmName ) { return this . registeredPlugins [ npmName ] } getRegisteredPlugin ( name ) { const npmName = PluginModel . buildNpmName ( name , PluginType . PLUGIN ) const registered = this . getRegisteredPluginOrTheme ( npmName ) if ( ! registered || registered . type !== PluginType . PLUGIN ) return undefined return registered } getRegisteredTheme ( name ) { const npmName = PluginModel . buildNpmName ( name , PluginType . THEME ) const registered = this . getRegisteredPluginOrTheme ( npmName ) if ( ! registered || registered . type !== PluginType . THEME ) return undefined return registered } getRegisteredPlugins ( ) { return this . getRegisteredPluginsOrThemes ( PluginType . PLUGIN ) } getRegisteredThemes ( ) { return this . getRegisteredPluginsOrThemes ( PluginType . THEME ) } getRegisteredSettings ( npmName ) { return this . settings [ npmName ] || [ ] } getTranslations ( locale ) { return this . translations [ locale ] || { } } async runHook < T > ( hookName , result ? : T , params ? ) < T > { if ( ! this . hooks [ hookName ] ) return Promise . resolve ( result ) const hookType = getHookType ( hookName ) for ( const hook of this . hooks [ hookName ] ) { logger . debug ( 's' , hookName , hook . npmName ) result = await internalRunHook ( hook . handler , hookType , result , params , err => { logger . error ( 's' , hookName , hook . pluginName , { err } ) } ) } return result } async registerPluginsAndThemes ( ) { await this . resetCSSGlobalFile ( ) const plugins = await PluginModel . listEnabledPluginsAndThemes ( ) for ( const plugin of plugins ) { try { await this . registerPluginOrTheme ( plugin ) } catch ( err ) { try { await this . unregister ( PluginModel . buildNpmName ( plugin . name , plugin . type ) ) } catch { } logger . error ( 's' , plugin . name , { err } ) } } this . sortHooksByPriority ( ) } async unregister ( npmName ) { logger . info ( 's' , npmName ) const plugin = this . getRegisteredPluginOrTheme ( npmName ) if ( ! plugin ) { throw new Error ( `template` ) } delete this . registeredPlugins [ plugin . npmName ] delete this . settings [ plugin . npmName ] this . deleteTranslations ( plugin . npmName ) if ( plugin . type === PluginType . PLUGIN ) { await plugin . unregister ( ) for ( const key of Object . keys ( this . hooks ) ) { this . hooks [ key ] = this . hooks [ key ] . filter ( h => h . pluginName !== npmName ) } this . reinitVideoConstants ( plugin . npmName ) logger . info ( 's' ) await this . regeneratePluginGlobalCSS ( ) } } async install ( toInstall , version ? , fromDisk = false ) { let plugin let npmName logger . info ( 's' , toInstall ) try { fromDisk ? await installNpmPluginFromDisk ( toInstall ) : await installNpmPlugin ( toInstall , version ) npmName = fromDisk ? basename ( toInstall ) : toInstall const pluginType = PluginModel . getTypeFromNpmName ( npmName ) const pluginName = PluginModel . normalizePluginName ( npmName ) const packageJSON = await this . getPackageJSON ( pluginName , pluginType ) this . sanitizeAndCheckPackageJSONOrThrow ( packageJSON , pluginType ) ; [ plugin ] = await PluginModel . upsert ( { name : pluginName , description : packageJSON . description , homepage : packageJSON . homepage , type : pluginType , version : packageJSON . version , enabled : true , uninstalled : false , peertubeEngine : packageJSON . engine . peertube } , { returning : true } ) } catch ( err ) { logger . error ( 's' , toInstall , { err } ) try { await removeNpmPlugin ( npmName ) } catch ( err ) { logger . error ( 's' , toInstall , { err } ) } throw err } logger . info ( 's' , toInstall ) await this . registerPluginOrTheme ( plugin ) return plugin } async update ( toUpdate , version ? , fromDisk = false ) { const npmName = fromDisk ? basename ( toUpdate ) : toUpdate logger . info ( 's' , npmName ) await this . unregister ( npmName ) return this . install ( toUpdate , version , fromDisk ) } async uninstall ( npmName ) { logger . info ( 's' , npmName ) try { await this . unregister ( npmName ) } catch ( err ) { logger . warn ( 's' , npmName , { err } ) } const plugin = await PluginModel . loadByNpmName ( npmName ) if ( ! plugin || plugin . uninstalled === true ) { logger . error ( 's' , npmName ) return } plugin . enabled = false plugin . uninstalled = true await plugin . save ( ) await removeNpmPlugin ( npmName ) logger . info ( 's' , npmName ) } private async registerPluginOrTheme ( plugin ) { const npmName = PluginModel . buildNpmName ( plugin . name , plugin . type ) logger . info ( 's' , npmName ) const packageJSON = await this . getPackageJSON ( plugin . name , plugin . type ) const pluginPath = this . getPluginPath ( plugin . name , plugin . type ) this . sanitizeAndCheckPackageJSONOrThrow ( packageJSON , plugin . type ) let library if ( plugin . type === PluginType . PLUGIN ) { library = await this . registerPlugin ( plugin , pluginPath , packageJSON ) } const clientScripts : { [ id ] : ClientScript } = { } for ( const c of packageJSON . clientScripts ) { clientScripts [ c . script ] = c } this . registeredPlugins [ npmName ] = { npmName , name : plugin . name , type : plugin . type , version : plugin . version , description : plugin . description , peertubeEngine : plugin . peertubeEngine , path : pluginPath , staticDirs : packageJSON . staticDirs , clientScripts , css : packageJSON . css , unregister : library ? library . unregister : undefined } await this . addTranslations ( plugin , npmName , packageJSON . translations ) } private async registerPlugin ( plugin , pluginPath , packageJSON ) { const npmName = PluginModel . buildNpmName ( plugin . name , plugin . type ) const modulePath = join ( pluginPath , packageJSON . library ) delete require . cache [ modulePath ] const library = require ( modulePath ) if ( ! isLibraryCodeValid ( library ) ) { throw new Error ( 's' ) } const registerHelpers = this . getRegisterHelpers ( npmName , plugin ) library . register ( registerHelpers ) . catch ( err => logger . error ( 's' , npmName , { err } ) ) logger . info ( 's' , npmName ) await this . addCSSToGlobalFile ( pluginPath , packageJSON . css ) return library } private async addTranslations ( plugin , npmName , translationPaths ) { for ( const locale of Object . keys ( translationPaths ) ) { const path = translationPaths [ locale ] const json = await readJSON ( join ( this . getPluginPath ( plugin . name , plugin . type ) , path ) ) if ( ! this . translations [ locale ] ) this . translations [ locale ] = { } this . translations [ locale ] [ npmName ] = json logger . info ( 's' , locale , npmName ) } } private deleteTranslations ( npmName ) { for ( const locale of Object . keys ( this . translations ) ) { delete this . translations [ locale ] [ npmName ] logger . info ( 's' , locale , npmName ) } } private resetCSSGlobalFile ( ) { ClientHtml . invalidCache ( ) return outputFile ( PLUGIN_GLOBAL_CSS_PATH , 's' ) } private async addCSSToGlobalFile ( pluginPath , cssRelativePaths : string [ ] ) { for ( const cssPath of cssRelativePaths ) { await this . concatFiles ( join ( pluginPath , cssPath ) , PLUGIN_GLOBAL_CSS_PATH ) } ClientHtml . invalidCache ( ) } private concatFiles ( input , output ) { return new Promise < void > ( ( res , rej ) => { const inputStream = createReadStream ( input ) const outputStream = createWriteStream ( output , { flags : 's' } ) inputStream . pipe ( outputStream ) inputStream . on ( 's' , ( ) => res ( ) ) inputStream . on ( 's' , err => rej ( err ) ) } ) } private async regeneratePluginGlobalCSS ( ) { await this . resetCSSGlobalFile ( ) for ( const plugin of this . getRegisteredPlugins ( ) ) { await this . addCSSToGlobalFile ( plugin . path , plugin . css ) } } private sortHooksByPriority ( ) { for ( const hookName of Object . keys ( this . hooks ) ) { this . hooks [ hookName ] . sort ( ( a , b ) => { return b . priority - a . priority } ) } } private getPackageJSON ( pluginName , pluginType ) { const pluginPath = join ( this . getPluginPath ( pluginName , pluginType ) , 's' ) return readJSON ( pluginPath ) as Promise < PluginPackageJson > } private getPluginPath ( pluginName , pluginType ) { const npmName = PluginModel . buildNpmName ( pluginName , pluginType ) return join ( CONFIG . STORAGE . PLUGINS_DIR , 's' , npmName ) } private getRegisteredPluginsOrThemes ( type ) { const plugins : RegisteredPlugin [ ] = [ ] for ( const npmName of Object . keys ( this . registeredPlugins ) ) { const plugin = this . registeredPlugins [ npmName ] if ( plugin . type !== type ) continue plugins . push ( plugin ) } return plugins } private getRegisterHelpers ( npmName , plugin ) { const registerHook = ( options ) => { if ( serverHookObject [ options . target ] !== true ) { logger . warn ( 's' , options . target , npmName ) return } if ( ! this . hooks [ options . target ] ) this . hooks [ options . target ] = [ ] this . hooks [ options . target ] . push ( { npmName , pluginName : plugin . name , handler : options . handler , priority : options . priority || 0 } ) } const registerSetting = ( options ) => { if ( ! this . settings [ npmName ] ) this . settings [ npmName ] = [ ] this . settings [ npmName ] . push ( options ) } const settingsManager = { getSetting : ( name ) => PluginModel . getSetting ( plugin . name , plugin . type , name ) , setSetting : ( name , value ) => PluginModel . setSetting ( plugin . name , plugin . type , name , value ) } const storageManager = { getData : ( key ) => PluginModel . getData ( plugin . name , plugin . type , key ) , storeData : ( key , data ) => PluginModel . storeData ( plugin . name , plugin . type , key , data ) } const videoLanguageManager = { addLanguage : ( key , label ) => this . addConstant ( { npmName , type : 's' , obj : VIDEO_LANGUAGES , key , label } ) , deleteLanguage : ( key ) => this . deleteConstant ( { npmName , type : 's' , obj : VIDEO_LANGUAGES , key } ) } const videoCategoryManager = { addCategory : ( key , label ) => this . addConstant ( { npmName , type : 's' , obj : VIDEO_CATEGORIES , key , label } ) , deleteCategory : ( key ) => this . deleteConstant ( { npmName , type : 's' , obj : VIDEO_CATEGORIES , key } ) } const videoLicenceManager = { addLicence : ( key , label ) => this . addConstant ( { npmName , type : 's' , obj : VIDEO_LICENCES , key , label } ) , deleteLicence : ( key ) => this . deleteConstant ( { npmName , type : 's' , obj : VIDEO_LICENCES , key } ) } const peertubeHelpers = { logger } return { registerHook , registerSetting , settingsManager , storageManager , videoLanguageManager , videoCategoryManager , videoLicenceManager , peertubeHelpers } } private addConstant < T extends string | number > ( parameters : { npmName : string , type : AlterableVideoConstant , obj : VideoConstant , key : T , label : string } ) { const { npmName , type , obj , key , label } = parameters if ( obj [ key ] ) { logger . warn ( 's' , type , npmName , key ) return false } if ( ! this . updatedVideoConstants [ type ] [ npmName ] ) { this . updatedVideoConstants [ type ] [ npmName ] = { added : [ ] , deleted : [ ] } } this . updatedVideoConstants [ type ] [ npmName ] . added . push ( { key , label } ) obj [ key ] = label return true } private deleteConstant < T extends string | number > ( parameters : { npmName : string , type : AlterableVideoConstant , obj : VideoConstant , key : T } ) { const { npmName , type , obj , key } = parameters if ( ! obj [ key ] ) { logger . warn ( 's' , type , npmName , key ) return false } if ( ! this . updatedVideoConstants [ type ] [ npmName ] ) { this . updatedVideoConstants [ type ] [ npmName ] = { added : [ ] , deleted : [ ] } } this . updatedVideoConstants [ type ] [ npmName ] . deleted . push ( { key , label : obj [ key ] } ) delete obj [ key ] return true } private reinitVideoConstants ( npmName ) { const hash = { language : VIDEO_LANGUAGES , licence : VIDEO_LICENCES , category : VIDEO_CATEGORIES } const types : AlterableVideoConstant [ ] = [ 's' , 's' , 's' ] for ( const type of types ) { const updatedConstants = this . updatedVideoConstants [ type ] [ npmName ] if ( ! updatedConstants ) continue for ( const added of updatedConstants . added ) { delete hash [ type ] [ added . key ] } for ( const deleted of updatedConstants . deleted ) { hash [ type ] [ deleted . key ] = deleted . label } delete this . updatedVideoConstants [ type ] [ npmName ] } } private sanitizeAndCheckPackageJSONOrThrow ( packageJSON , pluginType ) { if ( ! packageJSON . staticDirs ) packageJSON . staticDirs = { } if ( ! packageJSON . css ) packageJSON . css = [ ] if ( ! packageJSON . clientScripts ) packageJSON . clientScripts = [ ] if ( ! packageJSON . translations ) packageJSON . translations = { } const { result : packageJSONValid , badFields } = isPackageJSONValid ( packageJSON , pluginType ) if ( ! packageJSONValid ) { const formattedFields = badFields . map ( f => `template` ) . join ( 's' ) throw new Error ( `template` ) } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $Promise$ O O O O $ServerHookName$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O $PluginModel$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLibrary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginModel$ O $string$ O $PluginPackageJson$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLibrary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginModel$ O $string$ O $PackagePluginTranslations$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisterServerOptions$ O $string$ O $PluginModel$ O O O O O O $RegisterServerHookOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisterServerSettingOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginSettingsManager$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O $PluginStorageManager$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O $PluginVideoLanguageManager$ O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $PluginVideoCategoryManager$ O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O $PluginVideoLicenceManager$ O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginPackageJson$ O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DEFAULT_THEME_NAME , DEFAULT_USER_THEME_NAME } from 's' import { PluginManager } from 's' import { CONFIG } from 's' function getThemeOrDefault ( name , defaultTheme ) { if ( isThemeRegistered ( name ) ) return name if ( name !== CONFIG . THEME . DEFAULT ) return getThemeOrDefault ( CONFIG . THEME . DEFAULT , DEFAULT_THEME_NAME ) return defaultTheme } function isThemeRegistered ( name ) { if ( name === DEFAULT_THEME_NAME || name === DEFAULT_USER_THEME_NAME ) return true return ! ! PluginManager . Instance . getRegisteredThemes ( ) . find ( r => r . name === name ) } export { getThemeOrDefault , isThemeRegistered }	O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FindOptions , literal , Op , QueryTypes } from 's' import { AfterDestroy , AfterUpdate , AllowNull , BeforeCreate , BeforeUpdate , Column , CreatedAt , DataType , Default , DefaultScope , HasMany , HasOne , Is , IsEmail , Model , Scopes , Table , UpdatedAt } from 's' import { hasUserRight , USER_ROLE_LABELS , UserRight } from 's' import { User , UserRole } from 's' import { isNoInstanceConfigWarningModal , isUserAdminFlagsValid , isUserAutoPlayVideoValid , isUserAutoPlayNextVideoValid , isUserBlockedReasonValid , isUserBlockedValid , isUserEmailVerifiedValid , isUserNSFWPolicyValid , isUserPasswordValid , isUserRoleValid , isUserUsernameValid , isUserVideoLanguages , isUserVideoQuotaDailyValid , isUserVideoQuotaValid , isUserVideosHistoryEnabledValid , isUserWebTorrentEnabledValid , isNoWelcomeModal } from 's' import { comparePassword , cryptPassword } from 's' import { OAuthTokenModel } from 's' import { getSort , throwIfNotValid } from 's' import { VideoChannelModel } from 's' import { AccountModel } from 's' import { NSFWPolicyType } from 's' import { values } from 's' import { DEFAULT_THEME_NAME , DEFAULT_USER_THEME_NAME , NSFW_POLICY_TYPES } from 's' import { clearCacheByUserId } from 's' import { UserNotificationSettingModel } from 's' import { VideoModel } from 's' import { ActorModel } from 's' import { ActorFollowModel } from 's' import { VideoImportModel } from 's' import { UserAdminFlag } from 's' import { isThemeNameValid } from 's' import { getThemeOrDefault } from 's' import * as Bluebird from 's' import { MUserDefault , MUserFormattable , MUserId , MUserNotifSettingChannelDefault , MUserWithNotificationSetting } from 's' enum ScopeNames { WITH_VIDEO_CHANNEL = 's' } @ DefaultScope ( ( ) => ( { include : [ { model : AccountModel , required : true } , { model : UserNotificationSettingModel , required : true } ] } ) ) @ Scopes ( ( ) => ( { [ ScopeNames . WITH_VIDEO_CHANNEL ] : { include : [ { model : AccountModel , required : true , include : [ VideoChannelModel ] } , { model : UserNotificationSettingModel , required : true } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' ] , unique : true } ] } ) export class UserModel extends Model < UserModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserPasswordValid , 's' ) ) @ Column password : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserUsernameValid , 's' ) ) @ Column username : string @ AllowNull ( false ) @ IsEmail @ Column ( DataType . STRING ( 0 ) ) email : string @ AllowNull ( true ) @ IsEmail @ Column ( DataType . STRING ( 0 ) ) pendingEmail : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserEmailVerifiedValid , 's' , true ) ) @ Column emailVerified : boolean @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserNSFWPolicyValid , 's' ) ) @ Column ( DataType . ENUM ( ... values ( NSFW_POLICY_TYPES ) ) ) nsfwPolicy : NSFWPolicyType @ AllowNull ( false ) @ Default ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isUserWebTorrentEnabledValid , 's' ) ) @ Column webTorrentEnabled : boolean @ AllowNull ( false ) @ Default ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isUserVideosHistoryEnabledValid , 's' ) ) @ Column videosHistoryEnabled : boolean @ AllowNull ( false ) @ Default ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isUserAutoPlayVideoValid , 's' ) ) @ Column autoPlayVideo : boolean @ AllowNull ( false ) @ Default ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserAutoPlayNextVideoValid , 's' ) ) @ Column autoPlayNextVideo : boolean @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserVideoLanguages , 's' ) ) @ Column ( DataType . ARRAY ( DataType . STRING ) ) videoLanguages : string [ ] @ AllowNull ( false ) @ Default ( UserAdminFlag . NONE ) @ Is ( 's' , value => throwIfNotValid ( value , isUserAdminFlagsValid , 's' ) ) @ Column adminFlags ? : UserAdminFlag @ AllowNull ( false ) @ Default ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserBlockedValid , 's' ) ) @ Column blocked : boolean @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isUserBlockedReasonValid , 's' , true ) ) @ Column blockedReason : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserRoleValid , 's' ) ) @ Column role : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserVideoQuotaValid , 's' ) ) @ Column ( DataType . BIGINT ) videoQuota : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isUserVideoQuotaDailyValid , 's' ) ) @ Column ( DataType . BIGINT ) videoQuotaDaily : number @ AllowNull ( false ) @ Default ( DEFAULT_THEME_NAME ) @ Is ( 's' , value => throwIfNotValid ( value , isThemeNameValid , 's' ) ) @ Column theme : string @ AllowNull ( false ) @ Default ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isNoInstanceConfigWarningModal , 's' ) ) @ Column noInstanceConfigWarningModal : boolean @ AllowNull ( false ) @ Default ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isNoWelcomeModal , 's' ) ) @ Column noWelcomeModal : boolean @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ HasOne ( ( ) => AccountModel , { foreignKey : 's' , onDelete : 's' , hooks : true } ) Account : AccountModel @ HasOne ( ( ) => UserNotificationSettingModel , { foreignKey : 's' , onDelete : 's' , hooks : true } ) NotificationSetting : UserNotificationSettingModel @ HasMany ( ( ) => VideoImportModel , { foreignKey : 's' , onDelete : 's' } ) VideoImports : VideoImportModel [ ] @ HasMany ( ( ) => OAuthTokenModel , { foreignKey : 's' , onDelete : 's' } ) OAuthTokens : OAuthTokenModel [ ] @ BeforeCreate @ BeforeUpdate static cryptPasswordIfNeeded ( instance ) { if ( instance . changed ( 's' ) ) { return cryptPassword ( instance . password ) . then ( hash => { instance . password = hash return undefined } ) } } @ AfterUpdate @ AfterDestroy static removeTokenCache ( instance ) { return clearCacheByUserId ( instance . id ) } static countTotal ( ) { return this . count ( ) } static listForApi ( start , count , sort , search ? ) { let where = undefined if ( search ) { where = { [ Op . or ] : [ { email : { [ Op . iLike ] : 's' + search + 's' } } , { username : { [ Op . iLike ] : 's' + search + 's' } } ] } } const query = { attributes : { include : [ [ literal ( 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' ) , 's' ] ] } , offset : start , limit : count , order : getSort ( sort ) , where } return UserModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } static listWithRight ( right ) < MUserDefault [ ] > { const roles = Object . keys ( USER_ROLE_LABELS ) . map ( k => parseInt ( k , 0 ) as UserRole ) . filter ( role => hasUserRight ( role , right ) ) const query = { where : { role : { [ Op . in ] : roles } } } return UserModel . findAll ( query ) } static listUserSubscribersOf ( actorId ) < MUserWithNotificationSetting [ ] > { const query = { include : [ { model : UserNotificationSettingModel . unscoped ( ) , required : true } , { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ ] , model : ActorModel . unscoped ( ) , required : true , where : { serverId : null } , include : [ { attributes : [ ] , as : 's' , model : ActorFollowModel . unscoped ( ) , required : true , where : { targetActorId : actorId } } ] } ] } ] } return UserModel . unscoped ( ) . findAll ( query ) } static listByUsernames ( usernames : string [ ] ) < MUserDefault [ ] > { const query = { where : { username : usernames } } return UserModel . findAll ( query ) } static loadById ( id ) < MUserDefault > { return UserModel . findByPk ( id ) } static loadByUsername ( username ) < MUserDefault > { const query = { where : { username : { [ Op . iLike ] : username } } } return UserModel . findOne ( query ) } static loadByUsernameAndPopulateChannels ( username ) < MUserNotifSettingChannelDefault > { const query = { where : { username : { [ Op . iLike ] : username } } } return UserModel . scope ( ScopeNames . WITH_VIDEO_CHANNEL ) . findOne ( query ) } static loadByEmail ( email ) < MUserDefault > { const query = { where : { email } } return UserModel . findOne ( query ) } static loadByUsernameOrEmail ( username , email ? ) < MUserDefault > { if ( ! email ) email = username const query = { where : { [ Op . or ] : [ { username : { [ Op . iLike ] : username } } , { email } ] } } return UserModel . findOne ( query ) } static loadByVideoId ( videoId ) < MUserDefault > { const query = { include : [ { required : true , attributes : [ 's' ] , model : AccountModel . unscoped ( ) , include : [ { required : true , attributes : [ 's' ] , model : VideoChannelModel . unscoped ( ) , include : [ { required : true , attributes : [ 's' ] , model : VideoModel . unscoped ( ) , where : { id : videoId } } ] } ] } ] } return UserModel . findOne ( query ) } static loadByVideoImportId ( videoImportId ) < MUserDefault > { const query = { include : [ { required : true , attributes : [ 's' ] , model : VideoImportModel . unscoped ( ) , where : { id : videoImportId } } ] } return UserModel . findOne ( query ) } static loadByChannelActorId ( videoChannelActorId ) < MUserDefault > { const query = { include : [ { required : true , attributes : [ 's' ] , model : AccountModel . unscoped ( ) , include : [ { required : true , attributes : [ 's' ] , model : VideoChannelModel . unscoped ( ) , where : { actorId : videoChannelActorId } } ] } ] } return UserModel . findOne ( query ) } static loadByAccountActorId ( accountActorId ) < MUserDefault > { const query = { include : [ { required : true , attributes : [ 's' ] , model : AccountModel . unscoped ( ) , where : { actorId : accountActorId } } ] } return UserModel . findOne ( query ) } static getOriginalVideoFileTotalFromUser ( user ) { const query = UserModel . generateUserQuotaBaseSQL ( ) return UserModel . getTotalRawQuery ( query , user . id ) } static getOriginalVideoFileTotalDailyFromUser ( user ) { const query = UserModel . generateUserQuotaBaseSQL ( 's' ) return UserModel . getTotalRawQuery ( query , user . id ) } static async getStats ( ) { const totalUsers = await UserModel . count ( ) return { totalUsers } } static autoComplete ( search ) { const query = { where : { username : { [ Op . like ] : `template` } } , limit : 0 } return UserModel . findAll ( query ) . then ( u => u . map ( u => u . username ) ) } hasRight ( right ) { return hasUserRight ( this . role , right ) } hasAdminFlag ( flag ) { return this . adminFlags & flag } isPasswordMatch ( password ) { return comparePassword ( password , this . password ) } toFormattedJSON ( this , parameters : { withAdminFlags ? : boolean } = { } ) { const videoQuotaUsed = this . get ( 's' ) const videoQuotaUsedDaily = this . get ( 's' ) const json = { id : this . id , username : this . username , email : this . email , theme : getThemeOrDefault ( this . theme , DEFAULT_USER_THEME_NAME ) , pendingEmail : this . pendingEmail , emailVerified : this . emailVerified , nsfwPolicy : this . nsfwPolicy , webTorrentEnabled : this . webTorrentEnabled , videosHistoryEnabled : this . videosHistoryEnabled , autoPlayVideo : this . autoPlayVideo , autoPlayNextVideo : this . autoPlayNextVideo , videoLanguages : this . videoLanguages , role : this . role , roleLabel : USER_ROLE_LABELS [ this . role ] , videoQuota : this . videoQuota , videoQuotaDaily : this . videoQuotaDaily , videoQuotaUsed : videoQuotaUsed !== undefined ? parseInt ( videoQuotaUsed + 's' , 0 ) : undefined , videoQuotaUsedDaily : videoQuotaUsedDaily !== undefined ? parseInt ( videoQuotaUsedDaily + 's' , 0 ) : undefined , noInstanceConfigWarningModal : this . noInstanceConfigWarningModal , noWelcomeModal : this . noWelcomeModal , blocked : this . blocked , blockedReason : this . blockedReason , account : this . Account . toFormattedJSON ( ) , notificationSettings : this . NotificationSetting ? this . NotificationSetting . toFormattedJSON ( ) : undefined , videoChannels : [ ] , createdAt : this . createdAt } if ( parameters . withAdminFlags ) { Object . assign ( json , { adminFlags : this . adminFlags } ) } if ( Array . isArray ( this . Account . VideoChannels ) === true ) { json . videoChannels = this . Account . VideoChannels . map ( c => c . toFormattedJSON ( ) ) . sort ( ( 0 , 0 ) => { if ( 0 . createdAt < 0 . createdAt ) return - 0 if ( 0 . createdAt === 0 . createdAt ) return 0 return 0 } ) } return json } async isAbleToUploadVideo ( videoFile : { size : number } ) { if ( this . videoQuota === - 0 && this . videoQuotaDaily === - 0 ) return Promise . resolve ( true ) const [ totalBytes , totalBytesDaily ] = await Promise . all ( [ UserModel . getOriginalVideoFileTotalFromUser ( this ) , UserModel . getOriginalVideoFileTotalDailyFromUser ( this ) ] ) const uploadedTotal = videoFile . size + totalBytes const uploadedDaily = videoFile . size + totalBytesDaily if ( this . videoQuotaDaily === - 0 ) return uploadedTotal < this . videoQuota if ( this . videoQuota === - 0 ) return uploadedDaily < this . videoQuotaDaily return uploadedTotal < this . videoQuota && uploadedDaily < this . videoQuotaDaily } private static generateUserQuotaBaseSQL ( where ? ) { const andWhere = where ? 's' + where : 's' return 's' + 's' + 's' + 's' + 's' + 's' + 's' + andWhere + 's' + 's' } private static getTotalRawQuery ( query , userId ) { const options = { bind : { userId } , type : QueryTypes . SELECT as QueryTypes . SELECT } return UserModel . sequelize . query < { total : string } > ( query , options ) . then ( ( [ { total } ] ) => { if ( total === null ) return 0 return parseInt ( total , 0 ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserModel$ O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $UserRight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserId$ O O O O O O O O O O O O O O O O O O O O O O O O O $MUserId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRight$ O O O O O O O O O O O O O O $UserAdminFlag$ O O O O O O O O O O O $string$ O O O O O O O O O O O O $User$ O $MUserFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , ForeignKey , IsInt , Model , Table , UpdatedAt } from 's' import { VideoModel } from 's' import { UserModel } from 's' import { DestroyOptions , Op , Transaction } from 's' import { MUserAccountId , MUserId } from 's' @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class UserVideoHistoryModel extends Model < UserVideoHistoryModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ IsInt @ Column currentTime : number @ ForeignKey ( ( ) => VideoModel ) @ Column videoId : number @ BelongsTo ( ( ) => VideoModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Video : VideoModel @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) User : UserModel static listForApi ( user , start , count ) { return VideoModel . listForApi ( { start , count , sort : 's' , nsfw : null , includeLocalVideos : true , withFiles : false , user , historyOfUser : user } ) } static removeUserHistoryBefore ( user , beforeDate , t ) { const query = { where : { userId : user . id } , transaction : t } if ( beforeDate ) { query . where [ 's' ] = { [ Op . lt ] : beforeDate } } return UserVideoHistoryModel . destroy ( query ) } static removeOldHistory ( beforeDate ) { const query = { where : { updatedAt : { [ Op . lt ] : beforeDate } } } return UserVideoHistoryModel . destroy ( query ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserAccountId$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserId$ O $string$ O $Transaction$ O O O $DestroyOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $DestroyOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserVideoHistoryModel } from 's' export type MUserVideoHistory = Omit < UserVideoHistoryModel , 's' | 's' > export type MUserVideoHistoryTime = Pick < MUserVideoHistory , 's' >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoModel } from 's' import { PickWith , PickWithOpt } from 's' import { MChannelAccountDefault , MChannelAccountLight , MChannelAccountSummaryFormattable , MChannelActor , MChannelFormattable , MChannelUserId } from 's' import { MTag } from 's' import { MVideoCaptionLanguage } from 's' import { MStreamingPlaylist , MStreamingPlaylistRedundancies , MStreamingPlaylistRedundanciesOpt } from 's' import { MVideoFile , MVideoFileRedundanciesOpt } from 's' import { MThumbnail } from 's' import { MVideoBlacklist , MVideoBlacklistLight , MVideoBlacklistUnfederated } from 's' import { MScheduleVideoUpdate } from 's' import { MUserVideoHistoryTime } from 's' type Use < K extends keyof VideoModel , M > = PickWith < VideoModel , K , M > export type MVideo = Omit < VideoModel , 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' > export type MVideoId = Pick < MVideo , 's' > export type MVideoUrl = Pick < MVideo , 's' > export type MVideoUUID = Pick < MVideo , 's' > export type MVideoIdUrl = MVideoId & MVideoUrl export type MVideoFeed = Pick < MVideo , 's' | 's' > export type MVideoWithFile = MVideo & Use < 's' , MVideoFile [ ] > export type MVideoThumbnail = MVideo & Use < 's' , MThumbnail [ ] > export type MVideoIdThumbnail = MVideoId & Use < 's' , MThumbnail [ ] > export type MVideoWithFileThumbnail = MVideo & Use < 's' , MVideoFile [ ] > & Use < 's' , MThumbnail [ ] > export type MVideoThumbnailBlacklist = MVideo & Use < 's' , MThumbnail [ ] > & Use < 's' , MVideoBlacklistLight > export type MVideoTag = MVideo & Use < 's' , MTag [ ] > export type MVideoWithSchedule = MVideo & PickWithOpt < VideoModel , 's' , MScheduleVideoUpdate > export type MVideoWithCaptions = MVideo & Use < 's' , MVideoCaptionLanguage [ ] > export type MVideoWithStreamingPlaylist = MVideo & Use < 's' , MStreamingPlaylist [ ] > export type MVideoUserHistory = MVideo & Use < 's' , MUserVideoHistoryTime [ ] > export type MVideoWithBlacklistLight = MVideo & Use < 's' , MVideoBlacklistLight > export type MVideoAccountLight = MVideo & Use < 's' , MChannelAccountLight > export type MVideoWithRights = MVideo & Use < 's' , MVideoBlacklistLight > & Use < 's' , MThumbnail [ ] > & Use < 's' , MChannelUserId > export type MVideoWithAllFiles = MVideo & Use < 's' , MVideoFile [ ] > & Use < 's' , MThumbnail [ ] > & Use < 's' , MStreamingPlaylist [ ] > export type MVideoAccountLightBlacklistAllFiles = MVideo & Use < 's' , MVideoFile [ ] > & Use < 's' , MThumbnail [ ] > & Use < 's' , MStreamingPlaylist [ ] > & Use < 's' , MChannelAccountLight > & Use < 's' , MVideoBlacklistLight > export type MVideoAccountDefault = MVideo & Use < 's' , MChannelAccountDefault > export type MVideoThumbnailAccountDefault = MVideo & Use < 's' , MThumbnail [ ] > & Use < 's' , MChannelAccountDefault > export type MVideoWithChannelActor = MVideo & Use < 's' , MChannelActor > export type MVideoFullLight = MVideo & Use < 's' , MThumbnail [ ] > & Use < 's' , MVideoBlacklistLight > & Use < 's' , MTag [ ] > & Use < 's' , MChannelAccountLight > & Use < 's' , MUserVideoHistoryTime [ ] > & Use < 's' , MVideoFile [ ] > & Use < 's' , MScheduleVideoUpdate > & Use < 's' , MStreamingPlaylist [ ] > export type MVideoAP = MVideo & Use < 's' , MTag [ ] > & Use < 's' , MChannelAccountLight > & Use < 's' , MStreamingPlaylist [ ] > & Use < 's' , MVideoCaptionLanguage [ ] > & Use < 's' , MVideoBlacklistUnfederated > & Use < 's' , MVideoFileRedundanciesOpt [ ] > export type MVideoAPWithoutCaption = Omit < MVideoAP , 's' > export type MVideoDetails = MVideo & Use < 's' , MVideoBlacklistLight > & Use < 's' , MTag [ ] > & Use < 's' , MChannelAccountLight > & Use < 's' , MScheduleVideoUpdate > & Use < 's' , MThumbnail [ ] > & Use < 's' , MUserVideoHistoryTime [ ] > & Use < 's' , MStreamingPlaylistRedundancies [ ] > & Use < 's' , MVideoFileRedundanciesOpt [ ] > export type MVideoForUser = MVideo & Use < 's' , MChannelAccountDefault > & Use < 's' , MScheduleVideoUpdate > & Use < 's' , MVideoBlacklistLight > & Use < 's' , MThumbnail [ ] > export type MVideoFormattable = MVideo & PickWithOpt < VideoModel , 's' , MUserVideoHistoryTime [ ] > & Use < 's' , MChannelAccountSummaryFormattable > & PickWithOpt < VideoModel , 's' , Pick < MScheduleVideoUpdate , 's' | 's' > > & PickWithOpt < VideoModel , 's' , Pick < MVideoBlacklist , 's' > > export type MVideoFormattableDetails = MVideoFormattable & Use < 's' , MChannelFormattable > & Use < 's' , MTag [ ] > & Use < 's' , MStreamingPlaylistRedundanciesOpt [ ] > & Use < 's' , MVideoFileRedundanciesOpt [ ] >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FunctionProperties , PickWith , PickWithOpt } from 's' import { VideoChannelModel } from 's' import { MAccountActor , MAccountAPI , MAccountDefault , MAccountFormattable , MAccountLight , MAccountSummaryBlocks , MAccountSummaryFormattable , MAccountUrl , MAccountUserId , MActor , MActorAccountChannelId , MActorAP , MActorAPI , MActorDefault , MActorDefaultLight , MActorFormattable , MActorLight , MActorSummary , MActorSummaryFormattable , MActorUrl } from 's' import { MVideo } from 's' type Use < K extends keyof VideoChannelModel , M > = PickWith < VideoChannelModel , K , M > export type MChannel = Omit < VideoChannelModel , 's' | 's' | 's' | 's' > export type MChannelId = Pick < MChannel , 's' > export type MChannelIdActor = MChannelId & Use < 's' , MActorAccountChannelId > export type MChannelUserId = Pick < MChannel , 's' > & Use < 's' , MAccountUserId > export type MChannelActor = MChannel & Use < 's' , MActor > export type MChannelUrl = Use < 's' , MActorUrl > export type MChannelDefault = MChannel & Use < 's' , MActorDefault > export type MChannelLight = MChannel & Use < 's' , MActorDefaultLight > export type MChannelActorLight = MChannel & Use < 's' , MActorLight > export type MChannelAccountLight = MChannel & Use < 's' , MActorDefaultLight > & Use < 's' , MAccountLight > export type MChannelAccountActor = MChannel & Use < 's' , MAccountActor > export type MChannelAccountDefault = MChannel & Use < 's' , MActorDefault > & Use < 's' , MAccountDefault > export type MChannelActorAccountActor = MChannel & Use < 's' , MAccountActor > & Use < 's' , MActor > export type MChannelVideos = MChannel & Use < 's' , MVideo [ ] > export type MChannelActorAccountDefaultVideos = MChannel & Use < 's' , MActorDefault > & Use < 's' , MAccountDefault > & Use < 's' , MVideo [ ] > export type MChannelSummary = FunctionProperties < MChannel > & Pick < MChannel , 's' | 's' | 's' | 's' > & Use < 's' , MActorSummary > export type MChannelSummaryAccount = MChannelSummary & Use < 's' , MAccountSummaryBlocks > export type MChannelAPI = MChannel & Use < 's' , MActorAPI > & Use < 's' , MAccountAPI > export type MChannelSummaryFormattable = FunctionProperties < MChannel > & Pick < MChannel , 's' | 's' > & Use < 's' , MActorSummaryFormattable > export type MChannelAccountSummaryFormattable = MChannelSummaryFormattable & Use < 's' , MAccountSummaryFormattable > export type MChannelFormattable = FunctionProperties < MChannel > & Pick < MChannel , 's' | 's' | 's' | 's' | 's' | 's' > & Use < 's' , MActorFormattable > & PickWithOpt < VideoChannelModel , 's' , MAccountFormattable > export type MChannelAP = Pick < MChannel , 's' | 's' | 's' > & Use < 's' , MActorAP > & Use < 's' , MAccountUrl >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoPlaylistModel } from 's' import { PickWith } from 's' import { MAccount , MAccountDefault , MAccountSummary , MAccountSummaryFormattable } from 's' import { MThumbnail } from 's' import { MChannelDefault , MChannelSummary , MChannelSummaryFormattable , MChannelUrl } from 's' import { MVideoPlaylistElementLight } from 's' type Use < K extends keyof VideoPlaylistModel , M > = PickWith < VideoPlaylistModel , K , M > export type MVideoPlaylist = Omit < VideoPlaylistModel , 's' | 's' | 's' | 's' > export type MVideoPlaylistId = Pick < MVideoPlaylist , 's' > export type MVideoPlaylistPrivacy = Pick < MVideoPlaylist , 's' > export type MVideoPlaylistUUID = Pick < MVideoPlaylist , 's' > export type MVideoPlaylistVideosLength = MVideoPlaylist & { videosLength ? : number } export type MVideoPlaylistWithElements = MVideoPlaylist & Use < 's' , MVideoPlaylistElementLight [ ] > export type MVideoPlaylistIdWithElements = MVideoPlaylistId & Use < 's' , MVideoPlaylistElementLight [ ] > export type MVideoPlaylistOwner = MVideoPlaylist & Use < 's' , MAccount > export type MVideoPlaylistOwnerDefault = MVideoPlaylist & Use < 's' , MAccountDefault > export type MVideoPlaylistThumbnail = MVideoPlaylist & Use < 's' , MThumbnail > export type MVideoPlaylistAccountThumbnail = MVideoPlaylist & Use < 's' , MAccountDefault > & Use < 's' , MThumbnail > export type MVideoPlaylistAccountChannelDefault = MVideoPlaylist & Use < 's' , MAccountDefault > & Use < 's' , MChannelDefault > export type MVideoPlaylistFull = MVideoPlaylist & Use < 's' , MAccountDefault > & Use < 's' , MChannelDefault > & Use < 's' , MThumbnail > export type MVideoPlaylistAccountChannelSummary = MVideoPlaylist & Use < 's' , MAccountSummary > & Use < 's' , MChannelSummary > export type MVideoPlaylistFullSummary = MVideoPlaylist & Use < 's' , MThumbnail > & Use < 's' , MAccountSummary > & Use < 's' , MChannelSummary > export type MVideoPlaylistFormattable = MVideoPlaylistVideosLength & Use < 's' , MAccountSummaryFormattable > & Use < 's' , MChannelSummaryFormattable > export type MVideoPlaylistAP = MVideoPlaylist & Use < 's' , MThumbnail > & Use < 's' , MChannelUrl >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BelongsTo , Column , CreatedAt , DataType , Default , ForeignKey , HasMany , HasOne , Is , IsUUID , Model , Scopes , Table , UpdatedAt } from 's' import { VideoPlaylistPrivacy } from 's' import { buildServerIdsFollowedBy , buildWhereIdOrUUID , getSort , isOutdated , throwIfNotValid } from 's' import { isVideoPlaylistDescriptionValid , isVideoPlaylistNameValid , isVideoPlaylistPrivacyValid } from 's' import { isActivityPubUrlValid } from 's' import { ACTIVITY_PUB , CONSTRAINTS_FIELDS , STATIC_PATHS , THUMBNAILS_SIZE , VIDEO_PLAYLIST_PRIVACIES , VIDEO_PLAYLIST_TYPES , WEBSERVER } from 's' import { VideoPlaylist } from 's' import { AccountModel , ScopeNames as AccountScopeNames , SummaryOptions } from 's' import { ScopeNames as VideoChannelScopeNames , VideoChannelModel } from 's' import { join } from 's' import { VideoPlaylistElementModel } from 's' import { PlaylistObject } from 's' import { activityPubCollectionPagination } from 's' import { VideoPlaylistType } from 's' import { ThumbnailModel } from 's' import { ActivityIconObject } from 's' import { FindOptions , literal , Op , ScopeOptions , Transaction , WhereOptions } from 's' import * as Bluebird from 's' import { MVideoPlaylistAccountThumbnail , MVideoPlaylistAP , MVideoPlaylistFormattable , MVideoPlaylistFull , MVideoPlaylistFullSummary , MVideoPlaylistIdWithElements } from 's' import { MThumbnail } from 's' enum ScopeNames { AVAILABLE_FOR_LIST = 's' , WITH_VIDEOS_LENGTH = 's' , WITH_ACCOUNT_AND_CHANNEL_SUMMARY = 's' , WITH_ACCOUNT = 's' , WITH_THUMBNAIL = 's' , WITH_ACCOUNT_AND_CHANNEL = 's' } type AvailableForListOptions = { followerActorId : number type ? : VideoPlaylistType accountId ? : number videoChannelId ? : number privateAndUnlisted ? : boolean } @ Scopes ( ( ) => ( { [ ScopeNames . WITH_THUMBNAIL ] : { include : [ { model : ThumbnailModel , required : false } ] } , [ ScopeNames . WITH_VIDEOS_LENGTH ] : { attributes : { include : [ [ literal ( 's' ) , 's' ] ] } } as FindOptions , [ ScopeNames . WITH_ACCOUNT ] : { include : [ { model : AccountModel , required : true } ] } , [ ScopeNames . WITH_ACCOUNT_AND_CHANNEL_SUMMARY ] : { include : [ { model : AccountModel . scope ( AccountScopeNames . SUMMARY ) , required : true } , { model : VideoChannelModel . scope ( VideoChannelScopeNames . SUMMARY ) , required : false } ] } , [ ScopeNames . WITH_ACCOUNT_AND_CHANNEL ] : { include : [ { model : AccountModel , required : true } , { model : VideoChannelModel , required : false } ] } , [ ScopeNames . AVAILABLE_FOR_LIST ] : ( options ) => { const inQueryInstanceFollow = buildServerIdsFollowedBy ( options . followerActorId ) const whereActor = { [ Op . or ] : [ { serverId : null } , { serverId : { [ Op . in ] : literal ( inQueryInstanceFollow ) } } ] } const whereAnd : WhereOptions [ ] = [ ] if ( options . privateAndUnlisted !== true ) { whereAnd . push ( { privacy : VideoPlaylistPrivacy . PUBLIC } ) } if ( options . accountId ) { whereAnd . push ( { ownerAccountId : options . accountId } ) } if ( options . videoChannelId ) { whereAnd . push ( { videoChannelId : options . videoChannelId } ) } if ( options . type ) { whereAnd . push ( { type : options . type } ) } const where = { [ Op . and ] : whereAnd } const accountScope = { method : [ AccountScopeNames . SUMMARY , { whereActor } as SummaryOptions ] } return { where , include : [ { model : AccountModel . scope ( accountScope ) , required : true } , { model : VideoChannelModel . scope ( VideoChannelScopeNames . SUMMARY ) , required : false } ] } as FindOptions } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] , unique : true } ] } ) export class VideoPlaylistModel extends Model < VideoPlaylistModel > { @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoPlaylistNameValid , 's' ) ) @ Column name : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoPlaylistDescriptionValid , 's' , true ) ) @ Column description : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoPlaylistPrivacyValid , 's' ) ) @ Column privacy : VideoPlaylistPrivacy @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_PLAYLISTS . URL . max ) ) url : string @ AllowNull ( false ) @ Default ( DataType . 0 ) @ IsUUID ( 0 ) @ Column ( DataType . UUID ) uuid : string @ AllowNull ( false ) @ Default ( VideoPlaylistType . REGULAR ) @ Column type : VideoPlaylistType @ ForeignKey ( ( ) => AccountModel ) @ Column ownerAccountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) OwnerAccount : AccountModel @ ForeignKey ( ( ) => VideoChannelModel ) @ Column videoChannelId : number @ BelongsTo ( ( ) => VideoChannelModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) VideoChannel : VideoChannelModel @ HasMany ( ( ) => VideoPlaylistElementModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) VideoPlaylistElements : VideoPlaylistElementModel [ ] @ HasOne ( ( ) => ThumbnailModel , { foreignKey : { name : 's' , allowNull : true } , onDelete : 's' , hooks : true } ) Thumbnail : ThumbnailModel static listForApi ( options : { followerActorId : number start : number , count : number , sort : string , type ? : VideoPlaylistType , accountId ? : number , videoChannelId ? : number , privateAndUnlisted ? : boolean } ) { const query = { offset : options . start , limit : options . count , order : getSort ( options . sort ) } const scopes : ( string | ScopeOptions ) [ ] = [ { method : [ ScopeNames . AVAILABLE_FOR_LIST , { type : options . type , followerActorId : options . followerActorId , accountId : options . accountId , videoChannelId : options . videoChannelId , privateAndUnlisted : options . privateAndUnlisted } as AvailableForListOptions ] } , ScopeNames . WITH_VIDEOS_LENGTH , ScopeNames . WITH_THUMBNAIL ] return VideoPlaylistModel . scope ( scopes ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static listPublicUrlsOfForAP ( accountId , start , count ) { const query = { attributes : [ 's' ] , offset : start , limit : count , where : { ownerAccountId : accountId , privacy : VideoPlaylistPrivacy . PUBLIC } } return VideoPlaylistModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows . map ( p => p . url ) } } ) } static listPlaylistIdsOf ( accountId , videoIds : number [ ] ) < MVideoPlaylistIdWithElements [ ] > { const query = { attributes : [ 's' ] , where : { ownerAccountId : accountId } , include : [ { attributes : [ 's' , 's' , 's' , 's' ] , model : VideoPlaylistElementModel . unscoped ( ) , where : { videoId : { [ Op . in ] : videoIds } } , required : true } ] } return VideoPlaylistModel . findAll ( query ) } static doesPlaylistExist ( url ) { const query = { attributes : [ ] , where : { url } } return VideoPlaylistModel . findOne ( query ) . then ( e => ! ! e ) } static loadWithAccountAndChannelSummary ( id : number | string , transaction ) < MVideoPlaylistFullSummary > { const where = buildWhereIdOrUUID ( id ) const query = { where , transaction } return VideoPlaylistModel . scope ( [ ScopeNames . WITH_ACCOUNT_AND_CHANNEL_SUMMARY , ScopeNames . WITH_VIDEOS_LENGTH , ScopeNames . WITH_THUMBNAIL ] ) . findOne ( query ) } static loadWithAccountAndChannel ( id : number | string , transaction ) < MVideoPlaylistFull > { const where = buildWhereIdOrUUID ( id ) const query = { where , transaction } return VideoPlaylistModel . scope ( [ ScopeNames . WITH_ACCOUNT_AND_CHANNEL , ScopeNames . WITH_VIDEOS_LENGTH , ScopeNames . WITH_THUMBNAIL ] ) . findOne ( query ) } static loadByUrlAndPopulateAccount ( url ) < MVideoPlaylistAccountThumbnail > { const query = { where : { url } } return VideoPlaylistModel . scope ( [ ScopeNames . WITH_ACCOUNT , ScopeNames . WITH_THUMBNAIL ] ) . findOne ( query ) } static getPrivacyLabel ( privacy ) { return VIDEO_PLAYLIST_PRIVACIES [ privacy ] || 's' } static getTypeLabel ( type ) { return VIDEO_PLAYLIST_TYPES [ type ] || 's' } static resetPlaylistsOfChannel ( videoChannelId , transaction ) { const query = { where : { videoChannelId } , transaction } return VideoPlaylistModel . update ( { privacy : VideoPlaylistPrivacy . PRIVATE , videoChannelId : null } , query ) } async setAndSaveThumbnail ( thumbnail , t ) { thumbnail . videoPlaylistId = this . id this . Thumbnail = await thumbnail . save ( { transaction : t } ) } hasThumbnail ( ) { return ! ! this . Thumbnail } hasGeneratedThumbnail ( ) { return this . hasThumbnail ( ) && this . Thumbnail . automaticallyGenerated === true } generateThumbnailName ( ) { const extension = 's' return 's' + this . uuid + extension } getThumbnailUrl ( ) { if ( ! this . hasThumbnail ( ) ) return null return WEBSERVER . URL + STATIC_PATHS . THUMBNAILS + this . Thumbnail . filename } getThumbnailStaticPath ( ) { if ( ! this . hasThumbnail ( ) ) return null return join ( STATIC_PATHS . THUMBNAILS , this . Thumbnail . filename ) } setAsRefreshed ( ) { this . changed ( 's' , true ) return this . save ( ) } isOwned ( ) { return this . OwnerAccount . isOwned ( ) } isOutdated ( ) { if ( this . isOwned ( ) ) return false return isOutdated ( this , ACTIVITY_PUB . VIDEO_PLAYLIST_REFRESH_INTERVAL ) } toFormattedJSON ( this ) { return { id : this . id , uuid : this . uuid , isLocal : this . isOwned ( ) , displayName : this . name , description : this . description , privacy : { id : this . privacy , label : VideoPlaylistModel . getPrivacyLabel ( this . privacy ) } , thumbnailPath : this . getThumbnailStaticPath ( ) , type : { id : this . type , label : VideoPlaylistModel . getTypeLabel ( this . type ) } , videosLength : this . get ( 's' ) as number , createdAt : this . createdAt , updatedAt : this . updatedAt , ownerAccount : this . OwnerAccount . toFormattedSummaryJSON ( ) , videoChannel : this . VideoChannel ? this . VideoChannel . toFormattedSummaryJSON ( ) : null } } toActivityPubObject ( this , page , t ) < PlaylistObject > { const handler = ( start , count ) => { return VideoPlaylistElementModel . listUrlsOfForAP ( this . id , start , count , t ) } let icon if ( this . hasThumbnail ( ) ) { icon = { type : 's' as 's' , url : this . getThumbnailUrl ( ) , mediaType : 's' as 's' , width : THUMBNAILS_SIZE . width , height : THUMBNAILS_SIZE . height } } return activityPubCollectionPagination ( this . url , handler , page ) . then ( o => { return Object . assign ( o , { type : 's' as 's' , name : this . name , content : this . description , uuid : this . uuid , published : this . createdAt . toISOString ( ) , updated : this . updatedAt . toISOString ( ) , attributedTo : this . VideoChannel ? [ this . VideoChannel . Actor . url ] : [ ] , icon } ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvailableForListOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistPrivacy$ O O O O O O O O O O O O O $VideoPlaylistType$ O O O O O O O O O O O O O $number$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O $MVideoPlaylistFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $MVideoPlaylistAP$ O $number$ O $Transaction$ O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O $ActivityIconObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BeforeDestroy , BelongsTo , Column , CreatedAt , DataType , Default , DefaultScope , ForeignKey , HasMany , Is , Model , Scopes , Sequelize , Table , UpdatedAt } from 's' import { ActivityPubActor } from 's' import { VideoChannel , VideoChannelSummary } from 's' import { isVideoChannelDescriptionValid , isVideoChannelNameValid , isVideoChannelSupportValid } from 's' import { sendDeleteActor } from 's' import { AccountModel , ScopeNames as AccountModelScopeNames , SummaryOptions as AccountSummaryOptions } from 's' import { ActorModel , unusedActorAttributesForAPI } from 's' import { buildServerIdsFollowedBy , buildTrigramSearchIndex , createSimilarityAttribute , getSort , throwIfNotValid } from 's' import { VideoModel } from 's' import { CONSTRAINTS_FIELDS , WEBSERVER } from 's' import { ServerModel } from 's' import { FindOptions , ModelIndexesOptions , Op } from 's' import { AvatarModel } from 's' import { VideoPlaylistModel } from 's' import * as Bluebird from 's' import { MChannelAccountDefault , MChannelActor , MChannelActorAccountDefaultVideos , MChannelAP , MChannelFormattable , MChannelSummaryFormattable } from 's' const indexes : ModelIndexesOptions [ ] = [ buildTrigramSearchIndex ( 's' , 's' ) , { fields : [ 's' ] } , { fields : [ 's' ] } ] export enum ScopeNames { FOR_API = 's' , WITH_ACCOUNT = 's' , WITH_ACTOR = 's' , WITH_VIDEOS = 's' , SUMMARY = 's' } type AvailableForListOptions = { actorId : number } export type SummaryOptions = { withAccount ? : boolean withAccountBlockerIds ? : number [ ] } @ DefaultScope ( ( ) => ( { include : [ { model : ActorModel , required : true } ] } ) ) @ Scopes ( ( ) => ( { [ ScopeNames . SUMMARY ] : ( options = { } ) => { const base = { attributes : [ 's' , 's' , 's' , 's' ] , include : [ { attributes : [ 's' , 's' , 's' , 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } , { model : AvatarModel . unscoped ( ) , required : false } ] } ] } if ( options . withAccount === true ) { base . include . push ( { model : AccountModel . scope ( { method : [ AccountModelScopeNames . SUMMARY , { withAccountBlockerIds : options . withAccountBlockerIds } as AccountSummaryOptions ] } ) , required : true } ) } return base } , [ ScopeNames . FOR_API ] : ( options ) => { const inQueryInstanceFollow = buildServerIdsFollowedBy ( options . actorId ) return { include : [ { attributes : { exclude : unusedActorAttributesForAPI } , model : ActorModel , where : { [ Op . or ] : [ { serverId : null } , { serverId : { [ Op . in ] : Sequelize . literal ( inQueryInstanceFollow ) } } ] } } , { model : AccountModel , required : true , include : [ { attributes : { exclude : unusedActorAttributesForAPI } , model : ActorModel , required : true } ] } ] } } , [ ScopeNames . WITH_ACCOUNT ] : { include : [ { model : AccountModel , required : true } ] } , [ ScopeNames . WITH_VIDEOS ] : { include : [ VideoModel ] } , [ ScopeNames . WITH_ACTOR ] : { include : [ ActorModel ] } } ) ) @ Table ( { tableName : 's' , indexes } ) export class VideoChannelModel extends Model < VideoChannelModel > { @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoChannelNameValid , 's' ) ) @ Column name : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoChannelDescriptionValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_CHANNELS . DESCRIPTION . max ) ) description : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoChannelSupportValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEO_CHANNELS . SUPPORT . max ) ) support : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => ActorModel ) @ Column actorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Actor : ActorModel @ ForeignKey ( ( ) => AccountModel ) @ Column accountId : number @ BelongsTo ( ( ) => AccountModel , { foreignKey : { allowNull : false } , hooks : true } ) Account : AccountModel @ HasMany ( ( ) => VideoModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' , hooks : true } ) Videos : VideoModel [ ] @ HasMany ( ( ) => VideoPlaylistModel , { foreignKey : { allowNull : true } , onDelete : 's' , hooks : true } ) VideoPlaylists : VideoPlaylistModel [ ] @ BeforeDestroy static async sendDeleteIfOwned ( instance , options ) { if ( ! instance . Actor ) { instance . Actor = await instance . $get ( 's' , { transaction : options . transaction } ) as ActorModel } if ( instance . Actor . isOwned ( ) ) { return sendDeleteActor ( instance . Actor , options . transaction ) } return undefined } static countByAccount ( accountId ) { const query = { where : { accountId } } return VideoChannelModel . count ( query ) } static listForApi ( actorId , start , count , sort ) { const query = { offset : start , limit : count , order : getSort ( sort ) } const scopes = { method : [ ScopeNames . FOR_API , { actorId } as AvailableForListOptions ] } return VideoChannelModel . scope ( scopes ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static listLocalsForSitemap ( sort ) < MChannelActor [ ] > { const query = { attributes : [ ] , offset : 0 , order : getSort ( sort ) , include : [ { attributes : [ 's' , 's' ] , model : ActorModel . unscoped ( ) , where : { serverId : null } } ] } return VideoChannelModel . unscoped ( ) . findAll ( query ) } static searchForApi ( options : { actorId : number search : string start : number count : number sort : string } ) { const attributesInclude = [ ] const escapedSearch = VideoModel . sequelize . escape ( options . search ) const escapedLikeSearch = VideoModel . sequelize . escape ( 's' + options . search + 's' ) attributesInclude . push ( createSimilarityAttribute ( 's' , options . search ) ) const query = { attributes : { include : attributesInclude } , offset : options . start , limit : options . count , order : getSort ( options . sort ) , where : { [ Op . or ] : [ Sequelize . literal ( 's' + escapedSearch + 's' ) , Sequelize . literal ( 's' + escapedLikeSearch + 's' ) ] } } const scopes = { method : [ ScopeNames . FOR_API , { actorId : options . actorId } as AvailableForListOptions ] } return VideoChannelModel . scope ( scopes ) . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static listByAccount ( options : { accountId : number , start : number , count : number , sort : string } ) { const query = { offset : options . start , limit : options . count , order : getSort ( options . sort ) , include : [ { model : AccountModel , where : { id : options . accountId } , required : true } ] } return VideoChannelModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { total : count , data : rows } } ) } static loadByIdAndPopulateAccount ( id ) < MChannelAccountDefault > { return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT ] ) . findByPk ( id ) } static loadByIdAndAccount ( id , accountId ) < MChannelAccountDefault > { const query = { where : { id , accountId } } return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT ] ) . findOne ( query ) } static loadAndPopulateAccount ( id ) < MChannelAccountDefault > { return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT ] ) . findByPk ( id ) } static loadByUrlAndPopulateAccount ( url ) < MChannelAccountDefault > { const query = { include : [ { model : ActorModel , required : true , where : { url } } ] } return VideoChannelModel . scope ( [ ScopeNames . WITH_ACCOUNT ] ) . findOne ( query ) } static loadByNameWithHostAndPopulateAccount ( nameWithHost ) { const [ name , host ] = nameWithHost . split ( 's' ) if ( ! host || host === WEBSERVER . HOST ) return VideoChannelModel . loadLocalByNameAndPopulateAccount ( name ) return VideoChannelModel . loadByNameAndHostAndPopulateAccount ( name , host ) } static loadLocalByNameAndPopulateAccount ( name ) < MChannelAccountDefault > { const query = { include : [ { model : ActorModel , required : true , where : { preferredUsername : name , serverId : null } } ] } return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT ] ) . findOne ( query ) } static loadByNameAndHostAndPopulateAccount ( name , host ) < MChannelAccountDefault > { const query = { include : [ { model : ActorModel , required : true , where : { preferredUsername : name } , include : [ { model : ServerModel , required : true , where : { host } } ] } ] } return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT ] ) . findOne ( query ) } static loadAndPopulateAccountAndVideos ( id ) < MChannelActorAccountDefaultVideos > { const options = { include : [ VideoModel ] } return VideoChannelModel . unscoped ( ) . scope ( [ ScopeNames . WITH_ACTOR , ScopeNames . WITH_ACCOUNT , ScopeNames . WITH_VIDEOS ] ) . findByPk ( id , options ) } toFormattedSummaryJSON ( this ) { const actor = this . Actor . toFormattedSummaryJSON ( ) return { id : this . id , name : actor . name , displayName : this . getDisplayName ( ) , url : actor . url , host : actor . host , avatar : actor . avatar } } toFormattedJSON ( this ) { const actor = this . Actor . toFormattedJSON ( ) const videoChannel = { id : this . id , displayName : this . getDisplayName ( ) , description : this . description , support : this . support , isLocal : this . Actor . isOwned ( ) , createdAt : this . createdAt , updatedAt : this . updatedAt , ownerAccount : undefined } if ( this . Account ) videoChannel . ownerAccount = this . Account . toFormattedJSON ( ) return Object . assign ( actor , videoChannel ) } toActivityPubObject ( this ) { const obj = this . Actor . toActivityPubObject ( this . name ) return Object . assign ( obj , { summary : this . description , support : this . support , attributedTo : [ { type : 's' as 's' , id : this . Account . Actor . url } ] } ) } getDisplayName ( ) { return this . name } isOutdated ( ) { return this . Actor . isOutdated ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SummaryOptions$ O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvailableForListOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelSummary$ O $MChannelSummaryFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O $MChannelFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityPubActor$ O $MChannelAP$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { values } from 's' import { extname } from 's' import * as Sequelize from 's' import { AllowNull , BelongsTo , Column , CreatedAt , DataType , DefaultScope , ForeignKey , HasMany , HasOne , Is , Model , Scopes , Table , UpdatedAt } from 's' import { ActivityPubActorType } from 's' import { Avatar } from 's' import { activityPubContextify } from 's' import { isActorFollowersCountValid , isActorFollowingCountValid , isActorPreferredUsernameValid , isActorPrivateKeyValid , isActorPublicKeyValid } from 's' import { isActivityPubUrlValid } from 's' import { ACTIVITY_PUB , ACTIVITY_PUB_ACTOR_TYPES , CONSTRAINTS_FIELDS , WEBSERVER } from 's' import { AccountModel } from 's' import { AvatarModel } from 's' import { ServerModel } from 's' import { isOutdated , throwIfNotValid } from 's' import { VideoChannelModel } from 's' import { ActorFollowModel } from 's' import { VideoModel } from 's' import { MActor , MActorAccountChannelId , MActorAP , MActorFormattable , MActorFull , MActorHost , MActorServer , MActorSummaryFormattable } from 's' import * as Bluebird from 's' enum ScopeNames { FULL = 's' } export const unusedActorAttributesForAPI = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] @ DefaultScope ( ( ) => ( { include : [ { model : ServerModel , required : false } , { model : AvatarModel , required : false } ] } ) ) @ Scopes ( ( ) => ( { [ ScopeNames . FULL ] : { include : [ { model : AccountModel . unscoped ( ) , required : false } , { model : VideoChannelModel . unscoped ( ) , required : false , include : [ { model : AccountModel , required : true } ] } , { model : ServerModel , required : false } , { model : AvatarModel , required : false } ] } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' , 's' ] , unique : true } , { fields : [ 's' , 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class ActorModel extends Model < ActorModel > { @ AllowNull ( false ) @ Column ( DataType . ENUM ( ... values ( ACTIVITY_PUB_ACTOR_TYPES ) ) ) type : ActivityPubActorType @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActorPreferredUsernameValid , 's' ) ) @ Column preferredUsername : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) url : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActorPublicKeyValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . PUBLIC_KEY . max ) ) publicKey : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActorPrivateKeyValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . PRIVATE_KEY . max ) ) privateKey : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActorFollowersCountValid , 's' ) ) @ Column followersCount : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActorFollowingCountValid , 's' ) ) @ Column followingCount : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) inboxUrl : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) outboxUrl : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) sharedInboxUrl : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) followersUrl : string @ AllowNull ( true ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . ACTORS . URL . max ) ) followingUrl : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => AvatarModel ) @ Column avatarId : number @ BelongsTo ( ( ) => AvatarModel , { foreignKey : { allowNull : true } , onDelete : 's' , hooks : true } ) Avatar : AvatarModel @ HasMany ( ( ) => ActorFollowModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) ActorFollowing : ActorFollowModel [ ] @ HasMany ( ( ) => ActorFollowModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) ActorFollowers : ActorFollowModel [ ] @ ForeignKey ( ( ) => ServerModel ) @ Column serverId : number @ BelongsTo ( ( ) => ServerModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Server : ServerModel @ HasOne ( ( ) => AccountModel , { foreignKey : { allowNull : true } , onDelete : 's' , hooks : true } ) Account : AccountModel @ HasOne ( ( ) => VideoChannelModel , { foreignKey : { allowNull : true } , onDelete : 's' , hooks : true } ) VideoChannel : VideoChannelModel static load ( id ) < MActor > { return ActorModel . unscoped ( ) . findByPk ( id ) } static loadFull ( id ) < MActorFull > { return ActorModel . scope ( ScopeNames . FULL ) . findByPk ( id ) } static loadFromAccountByVideoId ( videoId , transaction : Sequelize . Transaction ) < MActor > { const query = { include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : VideoModel . unscoped ( ) , required : true , where : { id : videoId } } ] } ] } ] , transaction } return ActorModel . unscoped ( ) . findOne ( query ) } static isActorUrlExist ( url ) { const query = { raw : true , where : { url } } return ActorModel . unscoped ( ) . findOne ( query ) . then ( a => ! ! a ) } static listByFollowersUrls ( followersUrls : string [ ] , transaction ? : Sequelize . Transaction ) < MActorFull [ ] > { const query = { where : { followersUrl : { [ Sequelize . Op . in ] : followersUrls } } , transaction } return ActorModel . scope ( ScopeNames . FULL ) . findAll ( query ) } static loadLocalByName ( preferredUsername , transaction ? : Sequelize . Transaction ) < MActorFull > { const query = { where : { preferredUsername , serverId : null } , transaction } return ActorModel . scope ( ScopeNames . FULL ) . findOne ( query ) } static loadByNameAndHost ( preferredUsername , host ) < MActorFull > { const query = { where : { preferredUsername } , include : [ { model : ServerModel , required : true , where : { host } } ] } return ActorModel . scope ( ScopeNames . FULL ) . findOne ( query ) } static loadByUrl ( url , transaction ? : Sequelize . Transaction ) < MActorAccountChannelId > { const query = { where : { url } , transaction , include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : false } , { attributes : [ 's' ] , model : VideoChannelModel . unscoped ( ) , required : false } ] } return ActorModel . unscoped ( ) . findOne ( query ) } static loadByUrlAndPopulateAccountAndChannel ( url , transaction ? : Sequelize . Transaction ) < MActorFull > { const query = { where : { url } , transaction } return ActorModel . scope ( ScopeNames . FULL ) . findOne ( query ) } static incrementFollows ( id , column : 's' | 's' , by ) { return ActorModel . increment ( column , { by , where : { id } } ) } toFormattedSummaryJSON ( this ) { let avatar = null if ( this . Avatar ) { avatar = this . Avatar . toFormattedJSON ( ) } return { url : this . url , name : this . preferredUsername , host : this . getHost ( ) , avatar } } toFormattedJSON ( this ) { const base = this . toFormattedSummaryJSON ( ) return Object . assign ( base , { id : this . id , hostRedundancyAllowed : this . getRedundancyAllowed ( ) , followingCount : this . followingCount , followersCount : this . followersCount , createdAt : this . createdAt , updatedAt : this . updatedAt } ) } toActivityPubObject ( this , name ) { let activityPubType let icon = undefined if ( this . avatarId ) { const extension = extname ( this . Avatar . filename ) icon = { type : 's' , mediaType : extension === 's' ? 's' : 's' , url : this . getAvatarUrl ( ) } } const json = { type : this . type , id : this . url , following : this . getFollowingUrl ( ) , followers : this . getFollowersUrl ( ) , playlists : this . getPlaylistsUrl ( ) , inbox : this . inboxUrl , outbox : this . outboxUrl , preferredUsername : this . preferredUsername , url : this . url , name , endpoints : { sharedInbox : this . sharedInboxUrl } , publicKey : { id : this . getPublicKeyUrl ( ) , owner : this . url , publicKeyPem : this . publicKey } , icon } return activityPubContextify ( json ) } getFollowerSharedInboxUrls ( t : Sequelize . Transaction ) { const query = { attributes : [ 's' ] , include : [ { attribute : [ ] , model : ActorFollowModel . unscoped ( ) , required : true , as : 's' , where : { state : 's' , targetActorId : this . id } } ] , transaction : t } return ActorModel . findAll ( query ) . then ( accounts => accounts . map ( a => a . sharedInboxUrl ) ) } getFollowingUrl ( ) { return this . url + 's' } getFollowersUrl ( ) { return this . url + 's' } getPlaylistsUrl ( ) { return this . url + 's' } getPublicKeyUrl ( ) { return this . url + 's' } isOwned ( ) { return this . serverId === null } getWebfingerUrl ( this ) { return 's' + this . preferredUsername + 's' + this . getHost ( ) } getIdentifier ( ) { return this . Server ? `template` : this . preferredUsername } getHost ( this ) { return this . Server ? this . Server . host : WEBSERVER . HOST } getRedundancyAllowed ( ) { return this . Server ? this . Server . redundancyAllowed : false } getAvatarUrl ( ) { if ( ! this . avatarId ) return undefined return WEBSERVER . URL + this . Avatar . getStaticPath ( ) } isOutdated ( ) { if ( this . isOwned ( ) ) return false return isOutdated ( this , ACTIVITY_PUB . ACTOR_REFRESH_INTERVAL ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O $MActorSummaryFormattable$ O O O $Avatar$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorAP$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorServer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorHost$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PluginModel } from 's' export type MPlugin = PluginModel export type MPluginFormattable = Pick < MPlugin , 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ServerModel } from 's' import { FunctionProperties , PickWith } from 's' import { MAccountBlocklistId } from 's' type Use < K extends keyof ServerModel , M > = PickWith < ServerModel , K , M > export type MServer = Omit < ServerModel , 's' | 's' > export type MServerHost = Pick < MServer , 's' > export type MServerRedundancyAllowed = Pick < MServer , 's' > export type MServerHostBlocks = MServerHost & Use < 's' , MAccountBlocklistId [ ] > export type MServerFormattable = FunctionProperties < MServer > & Pick < MServer , 's' >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ServerBlocklistModel } from 's' import { PickWith } from 's' import { MAccountDefault , MAccountFormattable , MServer , MServerFormattable } from 's' type Use < K extends keyof ServerBlocklistModel , M > = PickWith < ServerBlocklistModel , K , M > export type MServerBlocklist = Omit < ServerBlocklistModel , 's' | 's' > export type MServerBlocklistAccountServer = MServerBlocklist & Use < 's' , MAccountDefault > & Use < 's' , MServer > export type MServerBlocklistFormattable = Pick < MServerBlocklist , 's' > & Use < 's' , MAccountFormattable > & Use < 's' , MServerFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AvatarModel } from 's' import { FunctionProperties } from 's' export type MAvatar = AvatarModel export type MAvatarFormattable = FunctionProperties < MAvatar > & Pick < MAvatar , 's' | 's' | 's' >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActorModel } from 's' import { FunctionProperties , PickWith , PickWithOpt } from 's' import { MAccount , MAccountDefault , MAccountId , MAccountIdActor } from 's' import { MServer , MServerHost , MServerHostBlocks , MServerRedundancyAllowed } from 's' import { MAvatar , MAvatarFormattable } from 's' import { MChannel , MChannelAccountActor , MChannelAccountDefault , MChannelId , MChannelIdActor } from 's' type Use < K extends keyof ActorModel , M > = PickWith < ActorModel , K , M > export type MActor = Omit < ActorModel , 's' | 's' | 's' | 's' | 's' | 's' > export type MActorUrl = Pick < MActor , 's' > export type MActorId = Pick < MActor , 's' > export type MActorUsername = Pick < MActor , 's' > export type MActorFollowersUrl = Pick < MActor , 's' > export type MActorAudience = MActorUrl & MActorFollowersUrl export type MActorFollowerException = Pick < ActorModel , 's' | 's' > export type MActorSignature = MActorAccountChannelId export type MActorLight = Omit < MActor , 's' | 's' > export type MActorHost = Use < 's' , MServerHost > export type MActorRedundancyAllowedOpt = PickWithOpt < ActorModel , 's' , MServerRedundancyAllowed > export type MActorDefaultLight = MActorLight & Use < 's' , MServerHost > & Use < 's' , MAvatar > export type MActorAccountId = MActor & Use < 's' , MAccountId > export type MActorAccountIdActor = MActor & Use < 's' , MAccountIdActor > export type MActorChannelId = MActor & Use < 's' , MChannelId > export type MActorChannelIdActor = MActor & Use < 's' , MChannelIdActor > export type MActorAccountChannelId = MActorAccountId & MActorChannelId export type MActorAccountChannelIdActor = MActorAccountIdActor & MActorChannelIdActor export type MActorAccount = MActor & Use < 's' , MAccount > export type MActorChannel = MActor & Use < 's' , MChannel > export type MActorDefaultAccountChannel = MActorDefault & MActorAccount & MActorChannel export type MActorServer = MActor & Use < 's' , MServer > export type MActorDefault = MActor & Use < 's' , MServer > & Use < 's' , MAvatar > export type MActorChannelAccountActor = MActor & Use < 's' , MChannelAccountActor > export type MActorFull = MActor & Use < 's' , MServer > & Use < 's' , MAvatar > & Use < 's' , MAccount > & Use < 's' , MChannelAccountActor > export type MActorFullActor = MActor & Use < 's' , MServer > & Use < 's' , MAvatar > & Use < 's' , MAccountDefault > & Use < 's' , MChannelAccountDefault > export type MActorSummary = FunctionProperties < MActor > & Pick < MActor , 's' | 's' | 's' | 's' | 's' > & Use < 's' , MServerHost > & Use < 's' , MAvatar > export type MActorSummaryBlocks = MActorSummary & Use < 's' , MServerHostBlocks > export type MActorAPI = Omit < MActorDefault , 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' > export type MActorSummaryFormattable = FunctionProperties < MActor > & Pick < MActor , 's' | 's' > & Use < 's' , MServerHost > & Use < 's' , MAvatarFormattable > export type MActorFormattable = MActorSummaryFormattable & Pick < MActor , 's' | 's' | 's' | 's' | 's' > & Use < 's' , MServerHost & Partial < Pick < MServer , 's' > > > export type MActorAP = MActor & Use < 's' , MAvatar >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccountBlocklistModel } from 's' import { PickWith } from 's' import { MAccountDefault , MAccountFormattable } from 's' type Use < K extends keyof AccountBlocklistModel , M > = PickWith < AccountBlocklistModel , K , M > export type MAccountBlocklist = Omit < AccountBlocklistModel , 's' | 's' > export type MAccountBlocklistId = Pick < AccountBlocklistModel , 's' > export type MAccountBlocklistAccounts = MAccountBlocklist & Use < 's' , MAccountDefault > & Use < 's' , MAccountDefault > export type MAccountBlocklistFormattable = Pick < MAccountBlocklist , 's' > & Use < 's' , MAccountFormattable > & Use < 's' , MAccountFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccountModel } from 's' import { MActor , MActorAP , MActorAPI , MActorAudience , MActorDefault , MActorDefaultLight , MActorFormattable , MActorId , MActorServer , MActorSummary , MActorSummaryFormattable , MActorUrl } from 's' import { FunctionProperties , PickWith } from 's' import { MAccountBlocklistId } from 's' import { MChannelDefault } from 's' type Use < K extends keyof AccountModel , M > = PickWith < AccountModel , K , M > export type MAccount = Omit < AccountModel , 's' | 's' | 's' | 's' | 's' | 's' | 's' > export type MAccountId = Pick < MAccount , 's' > export type MAccountUserId = Pick < MAccount , 's' > export type MAccountUrl = Use < 's' , MActorUrl > export type MAccountAudience = Use < 's' , MActorAudience > export type MAccountIdActor = MAccountId & Use < 's' , MActor > export type MAccountIdActorId = MAccountId & Use < 's' , MActorId > export type MAccountDefault = MAccount & Use < 's' , MActorDefault > export type MAccountDefaultChannelDefault = MAccount & Use < 's' , MActorDefault > & Use < 's' , MChannelDefault [ ] > export type MAccountLight = MAccount & Use < 's' , MActorDefaultLight > export type MAccountActor = MAccount & Use < 's' , MActor > export type MAccountServer = MAccount & Use < 's' , MActorServer > export type MAccountSummary = FunctionProperties < MAccount > & Pick < MAccount , 's' | 's' > & Use < 's' , MActorSummary > export type MAccountSummaryBlocks = MAccountSummary & Use < 's' , MAccountBlocklistId [ ] > export type MAccountAPI = MAccount & Use < 's' , MActorAPI > export type MAccountSummaryFormattable = FunctionProperties < MAccount > & Pick < MAccount , 's' | 's' > & Use < 's' , MActorSummaryFormattable > export type MAccountFormattable = FunctionProperties < MAccount > & Pick < MAccount , 's' | 's' | 's' | 's' | 's' | 's' > & Use < 's' , MActorFormattable > export type MAccountAP = Pick < MAccount , 's' | 's' > & Use < 's' , MActorAP >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActorFollowModel } from 's' import { MActor , MActorAccount , MActorDefaultAccountChannel , MActorChannelAccountActor , MActorDefault , MActorFormattable , MActorHost , MActorUsername } from 's' import { PickWith } from 's' import { ActorModel } from 's' import { MChannelDefault } from 's' type Use < K extends keyof ActorFollowModel , M > = PickWith < ActorFollowModel , K , M > export type MActorFollow = Omit < ActorFollowModel , 's' | 's' > export type MActorFollowFollowingHost = MActorFollow & Use < 's' , MActorUsername & MActorHost > export type MActorFollowActors = MActorFollow & Use < 's' , MActor > & Use < 's' , MActor > export type MActorFollowActorsDefault = MActorFollow & Use < 's' , MActorDefault > & Use < 's' , MActorDefault > export type MActorFollowFull = MActorFollow & Use < 's' , MActorDefaultAccountChannel > & Use < 's' , MActorDefaultAccountChannel > type SubscriptionFollowing = MActorDefault & PickWith < ActorModel , 's' , MChannelDefault > export type MActorFollowActorsDefaultSubscription = MActorFollow & Use < 's' , MActorDefault > & Use < 's' , SubscriptionFollowing > export type MActorFollowSubscriptions = MActorFollow & Use < 's' , MActorChannelAccountActor > export type MActorFollowFormattable = Pick < MActorFollow , 's' | 's' | 's' | 's' | 's' > & Use < 's' , MActorFormattable > & Use < 's' , MActorFormattable >	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { OAuthClientModel } from 's' export type MOAuthClient = Omit < OAuthClientModel , 's' >	O O O O O O O O O O O O O O O O
import { OAuthTokenModel } from 's' import { PickWith } from 's' import { MUserAccountUrl } from 's' type Use < K extends keyof OAuthTokenModel , M > = PickWith < OAuthTokenModel , K , M > export type MOAuthToken = Omit < OAuthTokenModel , 's' | 's' > export type MOAuthTokenUser = MOAuthToken & Use < 's' , MUserAccountUrl > & { user ? : MUserAccountUrl }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { WEBSERVER } from 's' import { MActor , MActorFollowActors , MActorId , MActorUrl , MCommentId , MVideoAbuseId , MVideoId , MVideoUrl , MVideoUUID } from 's' import { MVideoPlaylist , MVideoPlaylistUUID } from 's' import { MVideoFileVideoUUID } from 's' import { MStreamingPlaylist } from 's' function getVideoActivityPubUrl ( video ) { return WEBSERVER . URL + 's' + video . uuid } function getVideoPlaylistActivityPubUrl ( videoPlaylist ) { return WEBSERVER . URL + 's' + videoPlaylist . uuid } function getVideoPlaylistElementActivityPubUrl ( videoPlaylist , video ) { return WEBSERVER . URL + 's' + videoPlaylist . uuid + 's' + video . uuid } function getVideoCacheFileActivityPubUrl ( videoFile ) { const suffixFPS = videoFile . fps && videoFile . fps !== - 0 ? 's' + videoFile . fps : 's' return `template` } function getVideoCacheStreamingPlaylistActivityPubUrl ( video , playlist ) { return `template` } function getVideoCommentActivityPubUrl ( video , videoComment ) { return WEBSERVER . URL + 's' + video . uuid + 's' + videoComment . id } function getVideoChannelActivityPubUrl ( videoChannelName ) { return WEBSERVER . URL + 's' + videoChannelName } function getAccountActivityPubUrl ( accountName ) { return WEBSERVER . URL + 's' + accountName } function getVideoAbuseActivityPubUrl ( videoAbuse ) { return WEBSERVER . URL + 's' + videoAbuse . id } function getVideoViewActivityPubUrl ( byActor , video ) { return byActor . url + 's' + video . id + 's' + new Date ( ) . toISOString ( ) } function getVideoLikeActivityPubUrl ( byActor , video ) { return byActor . url + 's' + video . id } function getVideoDislikeActivityPubUrl ( byActor , video ) { return byActor . url + 's' + video . id } function getVideoSharesActivityPubUrl ( video ) { return video . url + 's' } function getVideoCommentsActivityPubUrl ( video ) { return video . url + 's' } function getVideoLikesActivityPubUrl ( video ) { return video . url + 's' } function getVideoDislikesActivityPubUrl ( video ) { return video . url + 's' } function getActorFollowActivityPubUrl ( follower , following ) { return follower . url + 's' + following . id } function getActorFollowAcceptActivityPubUrl ( actorFollow ) { const follower = actorFollow . ActorFollower const me = actorFollow . ActorFollowing return follower . url + 's' + me . id } function getActorFollowRejectActivityPubUrl ( follower , following ) { return follower . url + 's' + following . id } function getVideoAnnounceActivityPubUrl ( byActor , video ) { return video . url + 's' + byActor . id } function getDeleteActivityPubUrl ( originalUrl ) { return originalUrl + 's' } function getUpdateActivityPubUrl ( originalUrl , updatedAt ) { return originalUrl + 's' + updatedAt } function getUndoActivityPubUrl ( originalUrl ) { return originalUrl + 's' } export { getVideoActivityPubUrl , getVideoPlaylistElementActivityPubUrl , getVideoPlaylistActivityPubUrl , getVideoCacheStreamingPlaylistActivityPubUrl , getVideoChannelActivityPubUrl , getAccountActivityPubUrl , getVideoAbuseActivityPubUrl , getActorFollowActivityPubUrl , getActorFollowAcceptActivityPubUrl , getVideoAnnounceActivityPubUrl , getUpdateActivityPubUrl , getUndoActivityPubUrl , getVideoViewActivityPubUrl , getVideoLikeActivityPubUrl , getVideoDislikeActivityPubUrl , getActorFollowRejectActivityPubUrl , getVideoCommentActivityPubUrl , getDeleteActivityPubUrl , getVideoSharesActivityPubUrl , getVideoCommentsActivityPubUrl , getVideoLikesActivityPubUrl , getVideoDislikesActivityPubUrl , getVideoCacheFileActivityPubUrl }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoUUID$ O O O O O O O O O O O O O O O O $MVideoPlaylist$ O O O O O O O O O O O O O O O O $MVideoPlaylistUUID$ O $MVideoUUID$ O O O O O O O O O O O O O O O O O O O O O O $MVideoFileVideoUUID$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoUUID$ O $MStreamingPlaylist$ O O O O O O O O $MVideoUUID$ O $MCommentId$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $MVideoAbuseId$ O O O O O O O O O O O O O O O O $MActorUrl$ O $MVideoId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorUrl$ O $MVideoId$ O O O O O O O O O O O O O O O O $MActorUrl$ O $MVideoId$ O O O O O O O O O O O O O O O O $MVideoUrl$ O O O O O O O O O O O O $MVideoUrl$ O O O O O O O O O O O O $MVideoUrl$ O O O O O O O O O O O O $MVideoUrl$ O O O O O O O O O O O O $MActor$ O $MActorId$ O O O O O O O O O O O O O O O O $MActorFollowActors$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorUrl$ O $MActorId$ O O O O O O O O O O O O O O O O $MActorId$ O $MVideoUrl$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityFollow } from 's' import { getActorFollowActivityPubUrl } from 's' import { unicastTo } from 's' import { logger } from 's' import { Transaction } from 's' import { MActor , MActorFollowActors } from 's' function sendFollow ( actorFollow , t ) { const me = actorFollow . ActorFollower const following = actorFollow . ActorFollowing if ( ! following . serverId ) return logger . info ( 's' , following . url ) const url = getActorFollowActivityPubUrl ( me , following ) const data = buildFollowActivity ( url , me , following ) t . afterCommit ( ( ) => unicastTo ( data , me , following . inboxUrl ) ) } function buildFollowActivity ( url , byActor , targetActor ) { return { type : 's' , id : url , actor : byActor . url , object : targetActor . url } } export { sendFollow , buildFollowActivity }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityFollow$ O $string$ O $MActor$ O $MActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityAccept , ActivityFollow } from 's' import { getActorFollowAcceptActivityPubUrl , getActorFollowActivityPubUrl } from 's' import { unicastTo } from 's' import { buildFollowActivity } from 's' import { logger } from 's' import { MActor , MActorFollowActors } from 's' async function sendAccept ( actorFollow ) { const follower = actorFollow . ActorFollower const me = actorFollow . ActorFollowing if ( ! follower . serverId ) { logger . warn ( 's' ) return } logger . info ( 's' , follower . url ) const followUrl = getActorFollowActivityPubUrl ( follower , me ) const followData = buildFollowActivity ( followUrl , follower , me ) const url = getActorFollowAcceptActivityPubUrl ( actorFollow ) const data = buildAcceptActivity ( url , me , followData ) return unicastTo ( data , me , follower . inboxUrl ) } export { sendAccept } function buildAcceptActivity ( url , byActor , followActivityData ) { return { type : 's' , id : url , actor : byActor . url , object : followActivityData } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAccept$ O $string$ O $MActor$ O $ActivityFollow$ O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAnnounce , ActivityAudience } from 's' import { broadcastToFollowers } from 's' import { audiencify , getActorsInvolvedInVideo , getAudience , getAudienceFromFollowersOf } from 's' import { logger } from 's' import { MActorLight , MVideo } from 's' import { MVideoShare } from 's' async function buildAnnounceWithVideoAudience ( byActor , videoShare , video , t ) { const announcedObject = video . url const actorsInvolvedInVideo = await getActorsInvolvedInVideo ( video , t ) const audience = getAudienceFromFollowersOf ( actorsInvolvedInVideo ) const activity = buildAnnounceActivity ( videoShare . url , byActor , announcedObject , audience ) return { activity , actorsInvolvedInVideo } } async function sendVideoAnnounce ( byActor , videoShare , video , t ) { const { activity , actorsInvolvedInVideo } = await buildAnnounceWithVideoAudience ( byActor , videoShare , video , t ) logger . info ( 's' , videoShare . url ) const followersException = [ byActor ] return broadcastToFollowers ( activity , byActor , actorsInvolvedInVideo , t , followersException ) } function buildAnnounceActivity ( url , byActor , object , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { type : 's' as 's' , id : url , actor : byActor . url , object } , audience ) } export { sendVideoAnnounce , buildAnnounceActivity , buildAnnounceWithVideoAudience }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $MVideoShare$ O $MVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $MVideoShare$ O $MVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAnnounce$ O $string$ O $MActorLight$ O $string$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience , ActivityCreate } from 's' import { VideoPrivacy } from 's' import { VideoCommentModel } from 's' import { broadcastToActors , broadcastToFollowers , sendVideoRelatedActivity , unicastTo } from 's' import { audiencify , getActorsInvolvedInVideo , getAudience , getAudienceFromFollowersOf , getVideoCommentAudience } from 's' import { logger } from 's' import { VideoPlaylistPrivacy } from 's' import { getServerActor } from 's' import { MActorLight , MCommentOwnerVideo , MVideoAccountLight , MVideoAP , MVideoPlaylistFull , MVideoRedundancyFileVideo , MVideoRedundancyStreamingPlaylistVideo } from 's' async function sendCreateVideo ( video , t ) { if ( video . privacy === VideoPrivacy . PRIVATE ) return undefined logger . info ( 's' , video . url ) const byActor = video . VideoChannel . Account . Actor const videoObject = video . toActivityPubObject ( ) const audience = getAudience ( byActor , video . privacy === VideoPrivacy . PUBLIC ) const createActivity = buildCreateActivity ( video . url , byActor , videoObject , audience ) return broadcastToFollowers ( createActivity , byActor , [ byActor ] , t ) } async function sendCreateCacheFile ( byActor , video , fileRedundancy : MVideoRedundancyStreamingPlaylistVideo | MVideoRedundancyFileVideo ) { logger . info ( 's' , fileRedundancy . url ) return sendVideoRelatedCreateActivity ( { byActor , video , url : fileRedundancy . url , object : fileRedundancy . toActivityPubObject ( ) } ) } async function sendCreateVideoPlaylist ( playlist , t ) { if ( playlist . privacy === VideoPlaylistPrivacy . PRIVATE ) return undefined logger . info ( 's' , playlist . url ) const byActor = playlist . OwnerAccount . Actor const audience = getAudience ( byActor , playlist . privacy === VideoPlaylistPrivacy . PUBLIC ) const object = await playlist . toActivityPubObject ( null , t ) const createActivity = buildCreateActivity ( playlist . url , byActor , object , audience ) const serverActor = await getServerActor ( ) const toFollowersOf = [ byActor , serverActor ] if ( playlist . VideoChannel ) toFollowersOf . push ( playlist . VideoChannel . Actor ) return broadcastToFollowers ( createActivity , byActor , toFollowersOf , t ) } async function sendCreateVideoComment ( comment , t ) { logger . info ( 's' , comment . url ) const isOrigin = comment . Video . isOwned ( ) const byActor = comment . Account . Actor const threadParentComments = await VideoCommentModel . listThreadParentComments ( comment , t ) const commentObject = comment . toActivityPubObject ( threadParentComments ) const actorsInvolvedInComment = await getActorsInvolvedInVideo ( comment . Video , t ) actorsInvolvedInComment . push ( byActor ) const parentsCommentActors = threadParentComments . map ( c => c . Account . Actor ) let audience if ( isOrigin ) { audience = getVideoCommentAudience ( comment , threadParentComments , actorsInvolvedInComment , isOrigin ) } else { audience = getAudienceFromFollowersOf ( actorsInvolvedInComment . concat ( parentsCommentActors ) ) } const createActivity = buildCreateActivity ( comment . url , byActor , commentObject , audience ) const actorsException = [ byActor ] await broadcastToActors ( createActivity , byActor , parentsCommentActors , t , actorsException ) await broadcastToFollowers ( createActivity , byActor , [ byActor ] , t ) if ( isOrigin ) return broadcastToFollowers ( createActivity , byActor , actorsInvolvedInComment , t , actorsException ) t . afterCommit ( ( ) => unicastTo ( createActivity , byActor , comment . Video . VideoChannel . Account . Actor . sharedInboxUrl ) ) } function buildCreateActivity ( url , byActor , object , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { type : 's' as 's' , id : url + 's' , actor : byActor . url , object : audiencify ( object , audience ) } , audience ) } export { sendCreateVideo , buildCreateActivity , sendCreateVideoComment , sendCreateVideoPlaylist , sendCreateCacheFile } async function sendVideoRelatedCreateActivity ( options : { byActor : MActorLight , video : MVideoAccountLight , url : string , object : any , transaction ? : Transaction } ) { const activityBuilder = ( audience ) => { return buildCreateActivity ( options . url , options . byActor , options . object , audience ) } return sendVideoRelatedActivity ( activityBuilder , options ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAP$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistFull$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityCreate$ O $string$ O $MActorLight$ O $any$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience , ActivityDelete } from 's' import { ActorModel } from 's' import { VideoCommentModel } from 's' import { VideoShareModel } from 's' import { getDeleteActivityPubUrl } from 's' import { broadcastToActors , broadcastToFollowers , sendVideoRelatedActivity , unicastTo } from 's' import { audiencify , getActorsInvolvedInVideo , getVideoCommentAudience } from 's' import { logger } from 's' import { getServerActor } from 's' import { MCommentOwnerVideoReply , MVideoAccountLight , MVideoPlaylistFullSummary } from 's' import { MActorUrl } from 's' async function sendDeleteVideo ( video , transaction ) { logger . info ( 's' , video . url ) const byActor = video . VideoChannel . Account . Actor const activityBuilder = ( audience ) => { const url = getDeleteActivityPubUrl ( video . url ) return buildDeleteActivity ( url , video . url , byActor , audience ) } return sendVideoRelatedActivity ( activityBuilder , { byActor , video , transaction } ) } async function sendDeleteActor ( byActor , t ) { logger . info ( 's' , byActor . url ) const url = getDeleteActivityPubUrl ( byActor . url ) const activity = buildDeleteActivity ( url , byActor . url , byActor ) const actorsInvolved = await VideoShareModel . loadActorsWhoSharedVideosOf ( byActor . id , t ) const serverActor = await getServerActor ( ) actorsInvolved . push ( serverActor ) actorsInvolved . push ( byActor ) return broadcastToFollowers ( activity , byActor , actorsInvolved , t ) } async function sendDeleteVideoComment ( videoComment , t ) { logger . info ( 's' , videoComment . url ) const isVideoOrigin = videoComment . Video . isOwned ( ) const url = getDeleteActivityPubUrl ( videoComment . url ) const byActor = videoComment . isOwned ( ) ? videoComment . Account . Actor : videoComment . Video . VideoChannel . Account . Actor const threadParentComments = await VideoCommentModel . listThreadParentComments ( videoComment , t ) const actorsInvolvedInComment = await getActorsInvolvedInVideo ( videoComment . Video , t ) actorsInvolvedInComment . push ( byActor ) const audience = getVideoCommentAudience ( videoComment , threadParentComments , actorsInvolvedInComment , isVideoOrigin ) const activity = buildDeleteActivity ( url , videoComment . url , byActor , audience ) const actorsException = [ byActor ] await broadcastToActors ( activity , byActor , threadParentComments . map ( c => c . Account . Actor ) , t , actorsException ) await broadcastToFollowers ( activity , byActor , [ byActor ] , t ) if ( isVideoOrigin ) return broadcastToFollowers ( activity , byActor , actorsInvolvedInComment , t , actorsException ) t . afterCommit ( ( ) => unicastTo ( activity , byActor , videoComment . Video . VideoChannel . Account . Actor . sharedInboxUrl ) ) } async function sendDeleteVideoPlaylist ( videoPlaylist , t ) { logger . info ( 's' , videoPlaylist . url ) const byActor = videoPlaylist . OwnerAccount . Actor const url = getDeleteActivityPubUrl ( videoPlaylist . url ) const activity = buildDeleteActivity ( url , videoPlaylist . url , byActor ) const serverActor = await getServerActor ( ) const toFollowersOf = [ byActor , serverActor ] if ( videoPlaylist . VideoChannel ) toFollowersOf . push ( videoPlaylist . VideoChannel . Actor ) return broadcastToFollowers ( activity , byActor , toFollowersOf , t ) } export { sendDeleteVideo , sendDeleteActor , sendDeleteVideoComment , sendDeleteVideoPlaylist } function buildDeleteActivity ( url , object , byActor , audience ? ) { const activity = { type : 's' as 's' , id : url , actor : byActor . url , object } if ( audience ) return audiencify ( activity , audience ) return activity }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorModel$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideoReply$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistFullSummary$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityDelete$ O $string$ O $string$ O $MActorUrl$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience , ActivityLike } from 's' import { getVideoLikeActivityPubUrl } from 's' import { sendVideoRelatedActivity } from 's' import { audiencify , getAudience } from 's' import { logger } from 's' import { MActor , MActorAudience , MVideoAccountLight , MVideoUrl } from 's' async function sendLike ( byActor , video , t ) { logger . info ( 's' , video . url ) const activityBuilder = ( audience ) => { const url = getVideoLikeActivityPubUrl ( byActor , video ) return buildLikeActivity ( url , byActor , video , audience ) } return sendVideoRelatedActivity ( activityBuilder , { byActor , video , transaction : t } ) } function buildLikeActivity ( url , byActor , video , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { id : url , type : 's' as 's' , actor : byActor . url , object : video . url } , audience ) } export { sendLike , buildLikeActivity }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityLike$ O $string$ O $MActorAudience$ O $MVideoUrl$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActivityFollow , ActivityReject } from 's' import { getActorFollowActivityPubUrl , getActorFollowRejectActivityPubUrl } from 's' import { unicastTo } from 's' import { buildFollowActivity } from 's' import { logger } from 's' import { MActor } from 's' async function sendReject ( follower , following ) { if ( ! follower . serverId ) { logger . warn ( 's' ) return } logger . info ( 's' , follower . url ) const followUrl = getActorFollowActivityPubUrl ( follower , following ) const followData = buildFollowActivity ( followUrl , follower , following ) const url = getActorFollowRejectActivityPubUrl ( follower , following ) const data = buildRejectActivity ( url , following , followData ) return unicastTo ( data , following , follower . inboxUrl ) } export { sendReject } function buildRejectActivity ( url , byActor , followActivityData ) { return { type : 's' , id : url , actor : byActor . url , object : followActivityData } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityReject$ O $string$ O $MActor$ O $ActivityFollow$ O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAnnounce , ActivityAudience , ActivityCreate , ActivityDislike , ActivityFollow , ActivityLike , ActivityUndo } from 's' import { VideoModel } from 's' import { getActorFollowActivityPubUrl , getUndoActivityPubUrl , getVideoDislikeActivityPubUrl , getVideoLikeActivityPubUrl } from 's' import { broadcastToFollowers , sendVideoRelatedActivity , unicastTo } from 's' import { audiencify , getAudience } from 's' import { buildCreateActivity } from 's' import { buildFollowActivity } from 's' import { buildLikeActivity } from 's' import { buildAnnounceWithVideoAudience } from 's' import { logger } from 's' import { buildDislikeActivity } from 's' import { MActor , MActorAudience , MActorFollowActors , MActorLight , MVideo , MVideoAccountLight , MVideoRedundancyVideo , MVideoShare } from 's' async function sendUndoFollow ( actorFollow , t ) { const me = actorFollow . ActorFollower const following = actorFollow . ActorFollowing if ( ! following . serverId ) return logger . info ( 's' , following . url ) const followUrl = getActorFollowActivityPubUrl ( me , following ) const undoUrl = getUndoActivityPubUrl ( followUrl ) const followActivity = buildFollowActivity ( followUrl , me , following ) const undoActivity = undoActivityData ( undoUrl , me , followActivity ) t . afterCommit ( ( ) => unicastTo ( undoActivity , me , following . inboxUrl ) ) } async function sendUndoAnnounce ( byActor , videoShare , video , t ) { logger . info ( 's' , videoShare . url ) const undoUrl = getUndoActivityPubUrl ( videoShare . url ) const { activity : announceActivity , actorsInvolvedInVideo } = await buildAnnounceWithVideoAudience ( byActor , videoShare , video , t ) const undoActivity = undoActivityData ( undoUrl , byActor , announceActivity ) const followersException = [ byActor ] return broadcastToFollowers ( undoActivity , byActor , actorsInvolvedInVideo , t , followersException ) } async function sendUndoLike ( byActor , video , t ) { logger . info ( 's' , video . url ) const likeUrl = getVideoLikeActivityPubUrl ( byActor , video ) const likeActivity = buildLikeActivity ( likeUrl , byActor , video ) return sendUndoVideoRelatedActivity ( { byActor , video , url : likeUrl , activity : likeActivity , transaction : t } ) } async function sendUndoDislike ( byActor , video , t ) { logger . info ( 's' , video . url ) const dislikeUrl = getVideoDislikeActivityPubUrl ( byActor , video ) const dislikeActivity = buildDislikeActivity ( dislikeUrl , byActor , video ) return sendUndoVideoRelatedActivity ( { byActor , video , url : dislikeUrl , activity : dislikeActivity , transaction : t } ) } async function sendUndoCacheFile ( byActor , redundancyModel , t ) { logger . info ( 's' , redundancyModel . url ) const videoId = redundancyModel . getVideo ( ) . id const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoId ) const createActivity = buildCreateActivity ( redundancyModel . url , byActor , redundancyModel . toActivityPubObject ( ) ) return sendUndoVideoRelatedActivity ( { byActor , video , url : redundancyModel . url , activity : createActivity , transaction : t } ) } export { sendUndoFollow , sendUndoLike , sendUndoDislike , sendUndoAnnounce , sendUndoCacheFile } function undoActivityData ( url , byActor , object : ActivityFollow | ActivityLike | ActivityDislike | ActivityCreate | ActivityAnnounce , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { type : 's' as 's' , id : url , actor : byActor . url , object } , audience ) } async function sendUndoVideoRelatedActivity ( options : { byActor : MActor , video : MVideoAccountLight , url : string , activity : ActivityFollow | ActivityLike | ActivityDislike | ActivityCreate | ActivityAnnounce , transaction : Transaction } ) { const activityBuilder = ( audience ) => { const undoUrl = getUndoActivityPubUrl ( options . url ) return undoActivityData ( undoUrl , options . byActor , options . activity , audience ) } return sendVideoRelatedActivity ( activityBuilder , options ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorFollowActors$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $MVideoShare$ O $MVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoRedundancyVideo$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityUndo$ O $string$ O $MActorAudience$ O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience , ActivityUpdate } from 's' import { VideoPrivacy } from 's' import { AccountModel } from 's' import { VideoModel } from 's' import { VideoShareModel } from 's' import { getUpdateActivityPubUrl } from 's' import { broadcastToFollowers , sendVideoRelatedActivity } from 's' import { audiencify , getActorsInvolvedInVideo , getAudience } from 's' import { logger } from 's' import { VideoCaptionModel } from 's' import { VideoPlaylistPrivacy } from 's' import { getServerActor } from 's' import { MAccountDefault , MActor , MActorLight , MChannelDefault , MVideoAP , MVideoAPWithoutCaption , MVideoPlaylistFull , MVideoRedundancyVideo } from 's' async function sendUpdateVideo ( videoArg , t , overrodeByActor ? ) { const video = videoArg as MVideoAP if ( video . privacy === VideoPrivacy . PRIVATE ) return undefined logger . info ( 's' , video . url ) const byActor = overrodeByActor ? overrodeByActor : video . VideoChannel . Account . Actor const url = getUpdateActivityPubUrl ( video . url , video . updatedAt . toISOString ( ) ) if ( ! video . VideoCaptions ) { video . VideoCaptions = await video . $get ( 's' , { transaction : t } ) as VideoCaptionModel [ ] } const videoObject = video . toActivityPubObject ( ) const audience = getAudience ( byActor , video . privacy === VideoPrivacy . PUBLIC ) const updateActivity = buildUpdateActivity ( url , byActor , videoObject , audience ) const actorsInvolved = await getActorsInvolvedInVideo ( video , t ) if ( overrodeByActor ) actorsInvolved . push ( overrodeByActor ) return broadcastToFollowers ( updateActivity , byActor , actorsInvolved , t ) } async function sendUpdateActor ( accountOrChannel : MChannelDefault | MAccountDefault , t ) { const byActor = accountOrChannel . Actor logger . info ( 's' , byActor . url ) const url = getUpdateActivityPubUrl ( byActor . url , byActor . updatedAt . toISOString ( ) ) const accountOrChannelObject = accountOrChannel . toActivityPubObject ( ) const audience = getAudience ( byActor ) const updateActivity = buildUpdateActivity ( url , byActor , accountOrChannelObject , audience ) let actorsInvolved : MActor [ ] if ( accountOrChannel instanceof AccountModel ) { actorsInvolved = await VideoShareModel . loadActorsWhoSharedVideosOf ( byActor . id , t ) } else { actorsInvolved = await VideoShareModel . loadActorsByVideoChannel ( accountOrChannel . id , t ) } actorsInvolved . push ( byActor ) return broadcastToFollowers ( updateActivity , byActor , actorsInvolved , t ) } async function sendUpdateCacheFile ( byActor , redundancyModel ) { logger . info ( 's' , redundancyModel . url ) const video = await VideoModel . loadAndPopulateAccountAndServerAndTags ( redundancyModel . getVideo ( ) . id ) const activityBuilder = ( audience ) => { const redundancyObject = redundancyModel . toActivityPubObject ( ) const url = getUpdateActivityPubUrl ( redundancyModel . url , redundancyModel . updatedAt . toISOString ( ) ) return buildUpdateActivity ( url , byActor , redundancyObject , audience ) } return sendVideoRelatedActivity ( activityBuilder , { byActor , video } ) } async function sendUpdateVideoPlaylist ( videoPlaylist , t ) { if ( videoPlaylist . privacy === VideoPlaylistPrivacy . PRIVATE ) return undefined const byActor = videoPlaylist . OwnerAccount . Actor logger . info ( 's' , videoPlaylist . url ) const url = getUpdateActivityPubUrl ( videoPlaylist . url , videoPlaylist . updatedAt . toISOString ( ) ) const object = await videoPlaylist . toActivityPubObject ( null , t ) const audience = getAudience ( byActor , videoPlaylist . privacy === VideoPlaylistPrivacy . PUBLIC ) const updateActivity = buildUpdateActivity ( url , byActor , object , audience ) const serverActor = await getServerActor ( ) const toFollowersOf = [ byActor , serverActor ] if ( videoPlaylist . VideoChannel ) toFollowersOf . push ( videoPlaylist . VideoChannel . Actor ) return broadcastToFollowers ( updateActivity , byActor , toFollowersOf , t ) } export { sendUpdateActor , sendUpdateVideo , sendUpdateCacheFile , sendUpdateVideoPlaylist } function buildUpdateActivity ( url , byActor , object , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { type : 's' as 's' , id : url , actor : byActor . url , object : audiencify ( object , audience ) } , audience ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAPWithoutCaption$ O $Transaction$ O O $MActor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $MVideoRedundancyVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistFull$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityUpdate$ O $string$ O $MActorLight$ O $any$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , BeforeDestroy , BelongsTo , Column , CreatedAt , DataType , Default , DefaultScope , ForeignKey , HasMany , Is , Model , Scopes , Table , UpdatedAt } from 's' import { Account , AccountSummary } from 's' import { isAccountDescriptionValid } from 's' import { sendDeleteActor } from 's' import { ActorModel } from 's' import { ApplicationModel } from 's' import { ServerModel } from 's' import { getSort , throwIfNotValid } from 's' import { VideoChannelModel } from 's' import { VideoCommentModel } from 's' import { UserModel } from 's' import { AvatarModel } from 's' import { VideoPlaylistModel } from 's' import { CONSTRAINTS_FIELDS , WEBSERVER } from 's' import { FindOptions , IncludeOptions , Op , Transaction , WhereOptions } from 's' import { AccountBlocklistModel } from 's' import { ServerBlocklistModel } from 's' import { ActorFollowModel } from 's' import { MAccountActor , MAccountDefault , MAccountSummaryFormattable , MAccountFormattable , MAccountAP } from 's' import * as Bluebird from 's' export enum ScopeNames { SUMMARY = 's' } export type SummaryOptions = { whereActor ? : WhereOptions withAccountBlockerIds ? : number [ ] } @ DefaultScope ( ( ) => ( { include : [ { model : ActorModel , required : true } ] } ) ) @ Scopes ( ( ) => ( { [ ScopeNames . SUMMARY ] : ( options = { } ) => { const whereActor = options . whereActor || undefined const serverInclude = { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } const query = { attributes : [ 's' , 's' ] , include : [ { attributes : [ 's' , 's' , 's' , 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true , where : whereActor , include : [ serverInclude , { model : AvatarModel . unscoped ( ) , required : false } ] } ] } if ( options . withAccountBlockerIds ) { query . include . push ( { attributes : [ 's' ] , model : AccountBlocklistModel . unscoped ( ) , as : 's' , required : false , where : { accountId : { [ Op . in ] : options . withAccountBlockerIds } } } ) serverInclude . include = [ { attributes : [ 's' ] , model : ServerBlocklistModel . unscoped ( ) , required : false , where : { accountId : { [ Op . in ] : options . withAccountBlockerIds } } } ] } return query } } ) ) @ Table ( { tableName : 's' , indexes : [ { fields : [ 's' ] , unique : true } , { fields : [ 's' ] } , { fields : [ 's' ] } ] } ) export class AccountModel extends Model < AccountModel > { @ AllowNull ( false ) @ Column name : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isAccountDescriptionValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . USERS . DESCRIPTION . max ) ) description : string @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ ForeignKey ( ( ) => ActorModel ) @ Column actorId : number @ BelongsTo ( ( ) => ActorModel , { foreignKey : { allowNull : false } , onDelete : 's' } ) Actor : ActorModel @ ForeignKey ( ( ) => UserModel ) @ Column userId : number @ BelongsTo ( ( ) => UserModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) User : UserModel @ ForeignKey ( ( ) => ApplicationModel ) @ Column applicationId : number @ BelongsTo ( ( ) => ApplicationModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Application : ApplicationModel @ HasMany ( ( ) => VideoChannelModel , { foreignKey : { allowNull : false } , onDelete : 's' , hooks : true } ) VideoChannels : VideoChannelModel [ ] @ HasMany ( ( ) => VideoPlaylistModel , { foreignKey : { allowNull : false } , onDelete : 's' , hooks : true } ) VideoPlaylists : VideoPlaylistModel [ ] @ HasMany ( ( ) => VideoCommentModel , { foreignKey : { allowNull : false } , onDelete : 's' , hooks : true } ) VideoComments : VideoCommentModel [ ] @ HasMany ( ( ) => AccountBlocklistModel , { foreignKey : { name : 's' , allowNull : false } , as : 's' , onDelete : 's' } ) BlockedAccounts : AccountBlocklistModel [ ] @ BeforeDestroy static async sendDeleteIfOwned ( instance , options ) { if ( ! instance . Actor ) { instance . Actor = await instance . $get ( 's' , { transaction : options . transaction } ) as ActorModel } await ActorFollowModel . removeFollowsOf ( instance . Actor . id , options . transaction ) if ( instance . isOwned ( ) ) { return sendDeleteActor ( instance . Actor , options . transaction ) } return undefined } static load ( id , transaction ? ) < MAccountDefault > { return AccountModel . findByPk ( id , { transaction } ) } static loadByNameWithHost ( nameWithHost ) < MAccountDefault > { const [ accountName , host ] = nameWithHost . split ( 's' ) if ( ! host || host === WEBSERVER . HOST ) return AccountModel . loadLocalByName ( accountName ) return AccountModel . loadByNameAndHost ( accountName , host ) } static loadLocalByName ( name ) < MAccountDefault > { const query = { where : { [ Op . or ] : [ { userId : { [ Op . ne ] : null } } , { applicationId : { [ Op . ne ] : null } } ] } , include : [ { model : ActorModel , required : true , where : { preferredUsername : name } } ] } return AccountModel . findOne ( query ) } static loadByNameAndHost ( name , host ) < MAccountDefault > { const query = { include : [ { model : ActorModel , required : true , where : { preferredUsername : name } , include : [ { model : ServerModel , required : true , where : { host } } ] } ] } return AccountModel . findOne ( query ) } static loadByUrl ( url , transaction ? ) < MAccountDefault > { const query = { include : [ { model : ActorModel , required : true , where : { url } } ] , transaction } return AccountModel . findOne ( query ) } static listForApi ( start , count , sort ) { const query = { offset : start , limit : count , order : getSort ( sort ) } return AccountModel . findAndCountAll ( query ) . then ( ( { rows , count } ) => { return { data : rows , total : count } } ) } static listLocalsForSitemap ( sort ) < MAccountActor [ ] > { const query = { attributes : [ ] , offset : 0 , order : getSort ( sort ) , include : [ { attributes : [ 's' , 's' ] , model : ActorModel . unscoped ( ) , where : { serverId : null } } ] } return AccountModel . unscoped ( ) . findAll ( query ) } toFormattedJSON ( this ) { const actor = this . Actor . toFormattedJSON ( ) const account = { id : this . id , displayName : this . getDisplayName ( ) , description : this . description , createdAt : this . createdAt , updatedAt : this . updatedAt , userId : this . userId ? this . userId : undefined } return Object . assign ( actor , account ) } toFormattedSummaryJSON ( this ) { const actor = this . Actor . toFormattedSummaryJSON ( ) return { id : this . id , name : actor . name , displayName : this . getDisplayName ( ) , url : actor . url , host : actor . host , avatar : actor . avatar } } toActivityPubObject ( this ) { const obj = this . Actor . toActivityPubObject ( this . name ) return Object . assign ( obj , { summary : this . description } ) } isOwned ( ) { return this . Actor . isOwned ( ) } isOutdated ( ) { return this . Actor . isOutdated ( ) } getDisplayName ( ) { return this . name } isBlocked ( ) { return this . BlockedAccounts && this . BlockedAccounts . length !== 0 } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SummaryOptions$ O O O O O O O O O O O O O O O $IncludeOptions$ O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $number$ O O $Transaction$ O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O $MAccountFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccountSummary$ O $MAccountSummaryFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountAP$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AllowNull , Column , Default , DefaultScope , HasOne , IsInt , Model , Table } from 's' import { AccountModel } from 's' @ DefaultScope ( ( ) => ( { include : [ { model : AccountModel , required : true } ] } ) ) @ Table ( { tableName : 's' , timestamps : false } ) export class ApplicationModel extends Model < ApplicationModel > { @ AllowNull ( false ) @ Default ( 0 ) @ IsInt @ Column migrationVersion : number @ HasOne ( ( ) => AccountModel , { foreignKey : { allowNull : true } , onDelete : 's' } ) Account : AccountModel static countTotal ( ) { return ApplicationModel . count ( ) } static load ( ) { return ApplicationModel . findOne ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ResultList } from 's' import { ApplicationModel } from 's' import { execPromise , 0 , pseudoRandomBytesPromise , 0 } from 's' import { logger } from 's' import { join } from 's' import { Instance as ParseTorrent } from 's' import { remove } from 's' import * as memoizee from 's' import { CONFIG } from 's' function deleteFileAsync ( path ) { remove ( path ) . catch ( err => logger . error ( 's' , path , { err } ) ) } async function generateRandomString ( size ) { const raw = await pseudoRandomBytesPromise ( size ) return raw . toString ( 's' ) } interface FormattableToJSON < U , V > { toFormattedJSON ( args ? : U ) : V } function getFormattedObjects < U , V , T extends FormattableToJSON < U , V > > ( objects : T [ ] , objectsTotal , formattedArg ? : U ) { const formattedObjects = objects . map ( o => o . toFormattedJSON ( formattedArg ) ) return { total : objectsTotal , data : formattedObjects } as ResultList < V > } const getServerActor = memoizee ( async function ( ) { const application = await ApplicationModel . load ( ) if ( ! application ) throw Error ( 's' ) const actor = application . Account . Actor actor . Account = application . Account return actor } ) function generateVideoImportTmpPath ( target : string | ParseTorrent ) { const id = typeof target === 's' ? target : target . infoHash const hash = 0 ( id ) return join ( CONFIG . STORAGE . TMP_DIR , hash + 's' ) } function getSecureTorrentName ( originalName ) { return 0 ( originalName ) + 's' } async function getServerCommit ( ) { try { const tag = await 0 ( 's' , { stdio : [ 0 , 0 , 0 ] } ) if ( tag ) return tag . replace ( "s" , 's' ) } catch ( err ) { logger . debug ( 's' , { err } ) } try { const version = await execPromise ( 's' ) if ( version ) return version . toString ( ) . trim ( ) } catch ( err ) { logger . debug ( 's' , { err } ) } return 's' } function getUUIDFromFilename ( filename ) { const regex = "s" const result = filename . match ( regex ) if ( ! result || Array . isArray ( result ) === false ) return null return result [ 0 ] } export { deleteFileAsync , generateRandomString , getFormattedObjects , getSecureTorrentName , getServerActor , getServerCommit , generateVideoImportTmpPath , getUUIDFromFilename }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bluebird from 's' import { maxBy } from 's' import * as magnetUtil from 's' import * as parseTorrent from 's' import { join } from 's' import { CountOptions , FindOptions , IncludeOptions , ModelIndexesOptions , Op , QueryTypes , ScopeOptions , Sequelize , Transaction , WhereOptions } from 's' import { AllowNull , BeforeDestroy , BelongsTo , BelongsToMany , Column , CreatedAt , DataType , Default , ForeignKey , HasMany , HasOne , Is , IsInt , IsUUID , Min , Model , Scopes , Table , UpdatedAt } from 's' import { UserRight , VideoPrivacy , VideoState } from 's' import { VideoTorrentObject } from 's' import { Video , VideoDetails , VideoFile } from 's' import { VideoFilter } from 's' import { peertubeTruncate } from 's' import { isActivityPubUrlValid } from 's' import { isArray , isBooleanValid } from 's' import { isVideoCategoryValid , isVideoDescriptionValid , isVideoDurationValid , isVideoLanguageValid , isVideoLicenceValid , isVideoNameValid , isVideoPrivacyValid , isVideoStateValid , isVideoSupportValid } from 's' import { getVideoFileResolution } from 's' import { logger } from 's' import { getServerActor } from 's' import { ACTIVITY_PUB , API_VERSION , CONSTRAINTS_FIELDS , HLS_REDUNDANCY_DIRECTORY , HLS_STREAMING_PLAYLIST_DIRECTORY , LAZY_STATIC_PATHS , REMOTE_SCHEME , STATIC_DOWNLOAD_PATHS , STATIC_PATHS , VIDEO_CATEGORIES , VIDEO_LANGUAGES , VIDEO_LICENCES , VIDEO_PRIVACIES , VIDEO_STATES , WEBSERVER } from 's' import { sendDeleteVideo } from 's' import { AccountModel } from 's' import { AccountVideoRateModel } from 's' import { ActorModel } from 's' import { AvatarModel } from 's' import { ServerModel } from 's' import { buildBlockedAccountSQL , buildTrigramSearchIndex , buildWhereIdOrUUID , createSafeIn , createSimilarityAttribute , getVideoSort , isOutdated , throwIfNotValid } from 's' import { TagModel } from 's' import { VideoAbuseModel } from 's' import { ScopeNames as VideoChannelScopeNames , SummaryOptions , VideoChannelModel } from 's' import { VideoCommentModel } from 's' import { VideoFileModel } from 's' import { VideoShareModel } from 's' import { VideoTagModel } from 's' import { ScheduleVideoUpdateModel } from 's' import { VideoCaptionModel } from 's' import { VideoBlacklistModel } from 's' import { remove , writeFile } from 's' import { VideoViewModel } from 's' import { VideoRedundancyModel } from 's' import { videoFilesModelToFormattedJSON , VideoFormattingJSONOptions , videoModelToActivityPubObject , videoModelToFormattedDetailsJSON , videoModelToFormattedJSON } from 's' import { UserVideoHistoryModel } from 's' import { VideoImportModel } from 's' import { VideoStreamingPlaylistModel } from 's' import { VideoPlaylistElementModel } from 's' import { CONFIG } from 's' import { ThumbnailModel } from 's' import { ThumbnailType } from 's' import { createTorrentPromise } from 's' import { VideoStreamingPlaylistType } from 's' import { MChannel , MChannelAccountDefault , MChannelId , MUserAccountId , MUserId , MVideoAccountLight , MVideoAccountLightBlacklistAllFiles , MVideoAP , MVideoDetails , MVideoFormattable , MVideoFormattableDetails , MVideoForUser , MVideoFullLight , MVideoIdThumbnail , MVideoThumbnail , MVideoThumbnailBlacklist , MVideoWithAllFiles , MVideoWithFile , MVideoWithRights } from 's' import { MVideoFile , MVideoFileRedundanciesOpt } from 's' import { MThumbnail } from 's' const indexes : ( ModelIndexesOptions & { where ? : WhereOptions } ) [ ] = [ buildTrigramSearchIndex ( 's' , 's' ) , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] } , { fields : [ 's' ] , where : { originallyPublishedAt : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { category : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { licence : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { language : { [ Op . ne ] : null } } } , { fields : [ 's' ] , where : { nsfw : true } } , { fields : [ 's' ] , where : { remote : false } } , { fields : [ 's' ] , unique : true } , { fields : [ 's' ] , unique : true } ] export enum ScopeNames { AVAILABLE_FOR_LIST_IDS = 's' , FOR_API = 's' , WITH_ACCOUNT_DETAILS = 's' , WITH_TAGS = 's' , WITH_FILES = 's' , WITH_SCHEDULED_UPDATE = 's' , WITH_BLACKLISTED = 's' , WITH_BLOCKLIST = 's' , WITH_USER_HISTORY = 's' , WITH_STREAMING_PLAYLISTS = 's' , WITH_USER_ID = 's' , WITH_THUMBNAILS = 's' } export type ForAPIOptions = { ids ? : number [ ] videoPlaylistId ? : number withFiles ? : boolean withAccountBlockerIds ? : number [ ] } export type AvailableForListIDsOptions = { serverAccountId : number followerActorId : number includeLocalVideos : boolean attributesType ? : 's' | 's' | 's' filter ? : VideoFilter categoryOneOf ? : number [ ] nsfw ? : boolean licenceOneOf ? : number [ ] languageOneOf ? : string [ ] tagsOneOf ? : string [ ] tagsAllOf ? : string [ ] withFiles ? : boolean accountId ? : number videoChannelId ? : number videoPlaylistId ? : number trendingDays ? : number user ? : MUserAccountId historyOfUser ? : MUserId baseWhere ? : WhereOptions [ ] } @ Scopes ( ( ) => ( { [ ScopeNames . FOR_API ] : ( options ) => { const query = { include : [ { model : VideoChannelModel . scope ( { method : [ VideoChannelScopeNames . SUMMARY , { withAccount : true , withAccountBlockerIds : options . withAccountBlockerIds } as SummaryOptions ] } ) , required : true } , { attributes : [ 's' , 's' ] , model : ThumbnailModel , required : false } ] } if ( options . ids ) { query . where = { id : { [ Op . in ] : options . ids } } } if ( options . withFiles === true ) { query . include . push ( { model : VideoFileModel . unscoped ( ) , required : true } ) } if ( options . videoPlaylistId ) { query . include . push ( { model : VideoPlaylistElementModel . unscoped ( ) , required : true , where : { videoPlaylistId : options . videoPlaylistId } } ) } return query } , [ ScopeNames . AVAILABLE_FOR_LIST_IDS ] : ( options ) => { const whereAnd = options . baseWhere ? options . baseWhere : [ ] const query = { raw : true , include : [ ] } const attributesType = options . attributesType || 's' if ( attributesType === 's' ) query . attributes = [ 's' ] else if ( attributesType === 's' ) query . attributes = [ ] whereAnd . push ( { id : { [ Op . notIn ] : Sequelize . literal ( 's' ) } } ) if ( options . serverAccountId ) { whereAnd . push ( { channelId : { [ Op . notIn ] : Sequelize . literal ( 's' + 's' + buildBlockedAccountSQL ( options . serverAccountId , options . user ? options . user . Account . id : undefined ) + 's' + 's' ) } } ) } if ( ! options . filter || options . filter !== 's' ) { const privacyWhere = { privacy : VideoPrivacy . PUBLIC , [ Op . or ] : [ { state : VideoState . PUBLISHED } , { [ Op . and ] : { state : VideoState . TO_TRANSCODE , waitTranscoding : false } } ] } whereAnd . push ( privacyWhere ) } if ( options . videoPlaylistId ) { query . include . push ( { attributes : [ ] , model : VideoPlaylistElementModel . unscoped ( ) , required : true , where : { videoPlaylistId : options . videoPlaylistId } } ) query . subQuery = false } if ( options . filter || options . accountId || options . videoChannelId ) { const videoChannelInclude = { attributes : [ ] , model : VideoChannelModel . unscoped ( ) , required : true } if ( options . videoChannelId ) { videoChannelInclude . where = { id : options . videoChannelId } } if ( options . filter || options . accountId ) { const accountInclude = { attributes : [ ] , model : AccountModel . unscoped ( ) , required : true } if ( options . filter ) { accountInclude . include = [ { attributes : [ ] , model : ActorModel . unscoped ( ) , required : true , where : VideoModel . buildActorWhereWithFilter ( options . filter ) } ] } if ( options . accountId ) { accountInclude . where = { id : options . accountId } } videoChannelInclude . include = [ accountInclude ] } query . include . push ( videoChannelInclude ) } if ( options . followerActorId ) { let localVideosReq = 's' if ( options . includeLocalVideos === true ) { localVideosReq = 's' + 's' + 's' + 's' + 's' + 's' } const actorIdNumber = parseInt ( options . followerActorId . toString ( ) , 0 ) whereAnd . push ( { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + 's' + 's' + actorIdNumber + 's' + 's' + 's' + 's' + 's' + 's' + 's' + actorIdNumber + localVideosReq + 's' ) } } ) } if ( options . withFiles === true ) { whereAnd . push ( { id : { [ Op . in ] : Sequelize . literal ( 's' ) } } ) } if ( options . tagsAllOf || options . tagsOneOf ) { if ( options . tagsOneOf ) { const tagsOneOfLower = options . tagsOneOf . map ( t => t . toLowerCase ( ) ) whereAnd . push ( { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + 's' + 's' + createSafeIn ( VideoModel , tagsOneOfLower ) + 's' + 's' ) } } ) } if ( options . tagsAllOf ) { const tagsAllOfLower = options . tagsAllOf . map ( t => t . toLowerCase ( ) ) whereAnd . push ( { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + 's' + 's' + createSafeIn ( VideoModel , tagsAllOfLower ) + 's' + 's' + tagsAllOfLower . length + 's' ) } } ) } } if ( options . nsfw === true || options . nsfw === false ) { whereAnd . push ( { nsfw : options . nsfw } ) } if ( options . categoryOneOf ) { whereAnd . push ( { category : { [ Op . or ] : options . categoryOneOf } } ) } if ( options . licenceOneOf ) { whereAnd . push ( { licence : { [ Op . or ] : options . licenceOneOf } } ) } if ( options . languageOneOf ) { let videoLanguages = options . languageOneOf if ( options . languageOneOf . find ( l => l === 's' ) ) { videoLanguages = videoLanguages . concat ( [ null ] ) } whereAnd . push ( { [ Op . or ] : [ { language : { [ Op . or ] : videoLanguages } } , { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + 's' + createSafeIn ( VideoModel , options . languageOneOf ) + 's' + 's' ) } } ] } ) } if ( options . trendingDays ) { query . include . push ( VideoModel . buildTrendingQuery ( options . trendingDays ) ) query . subQuery = false } if ( options . historyOfUser ) { query . include . push ( { model : UserVideoHistoryModel , required : true , where : { userId : options . historyOfUser . id } } ) query . subQuery = false } query . where = { [ Op . and ] : whereAnd } return query } , [ ScopeNames . WITH_BLOCKLIST ] : { } , [ ScopeNames . WITH_THUMBNAILS ] : { include : [ { model : ThumbnailModel , required : false } ] } , [ ScopeNames . WITH_USER_ID ] : { include : [ { attributes : [ 's' ] , model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true } ] } ] } , [ ScopeNames . WITH_ACCOUNT_DETAILS ] : { include : [ { model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : { exclude : [ 's' , 's' ] } , model : ActorModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } , { model : AvatarModel . unscoped ( ) , required : false } ] } , { model : AccountModel . unscoped ( ) , required : true , include : [ { model : ActorModel . unscoped ( ) , attributes : { exclude : [ 's' , 's' ] } , required : true , include : [ { attributes : [ 's' ] , model : ServerModel . unscoped ( ) , required : false } , { model : AvatarModel . unscoped ( ) , required : false } ] } ] } ] } ] } , [ ScopeNames . WITH_TAGS ] : { include : [ TagModel ] } , [ ScopeNames . WITH_BLACKLISTED ] : { include : [ { attributes : [ 's' , 's' , 's' ] , model : VideoBlacklistModel , required : false } ] } , [ ScopeNames . WITH_FILES ] : ( withRedundancies = false ) => { let subInclude : any [ ] = [ ] if ( withRedundancies === true ) { subInclude = [ { attributes : [ 's' ] , model : VideoRedundancyModel . unscoped ( ) , required : false } ] } return { include : [ { model : VideoFileModel . unscoped ( ) , separate : true , required : false , include : subInclude } ] } } , [ ScopeNames . WITH_STREAMING_PLAYLISTS ] : ( withRedundancies = false ) => { let subInclude : any [ ] = [ ] if ( withRedundancies === true ) { subInclude = [ { attributes : [ 's' ] , model : VideoRedundancyModel . unscoped ( ) , required : false } ] } return { include : [ { model : VideoStreamingPlaylistModel . unscoped ( ) , separate : true , required : false , include : subInclude } ] } } , [ ScopeNames . WITH_SCHEDULED_UPDATE ] : { include : [ { model : ScheduleVideoUpdateModel . unscoped ( ) , required : false } ] } , [ ScopeNames . WITH_USER_HISTORY ] : ( userId ) => { return { include : [ { attributes : [ 's' ] , model : UserVideoHistoryModel . unscoped ( ) , required : false , where : { userId } } ] } } } ) ) @ Table ( { tableName : 's' , indexes } ) export class VideoModel extends Model < VideoModel > { @ AllowNull ( false ) @ Default ( DataType . 0 ) @ IsUUID ( 0 ) @ Column ( DataType . UUID ) uuid : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoNameValid , 's' ) ) @ Column name : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoCategoryValid , 's' , true ) ) @ Column category : number @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoLicenceValid , 's' , true ) ) @ Column licence : number @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoLanguageValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . LANGUAGE . max ) ) language : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoPrivacyValid , 's' ) ) @ Column privacy : number @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isBooleanValid , 's' ) ) @ Column nsfw : boolean @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoDescriptionValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . DESCRIPTION . max ) ) description : string @ AllowNull ( true ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoSupportValid , 's' , true ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . SUPPORT . max ) ) support : string @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoDurationValid , 's' ) ) @ Column duration : number @ AllowNull ( false ) @ Default ( 0 ) @ IsInt @ Min ( 0 ) @ Column views : number @ AllowNull ( false ) @ Default ( 0 ) @ IsInt @ Min ( 0 ) @ Column likes : number @ AllowNull ( false ) @ Default ( 0 ) @ IsInt @ Min ( 0 ) @ Column dislikes : number @ AllowNull ( false ) @ Column remote : boolean @ AllowNull ( false ) @ Is ( 's' , value => throwIfNotValid ( value , isActivityPubUrlValid , 's' ) ) @ Column ( DataType . STRING ( CONSTRAINTS_FIELDS . VIDEOS . URL . max ) ) url : string @ AllowNull ( false ) @ Column commentsEnabled : boolean @ AllowNull ( false ) @ Column downloadEnabled : boolean @ AllowNull ( false ) @ Column waitTranscoding : boolean @ AllowNull ( false ) @ Default ( null ) @ Is ( 's' , value => throwIfNotValid ( value , isVideoStateValid , 's' ) ) @ Column state : VideoState @ CreatedAt createdAt : Date @ UpdatedAt updatedAt : Date @ AllowNull ( false ) @ Default ( DataType . NOW ) @ Column publishedAt : Date @ AllowNull ( true ) @ Default ( null ) @ Column originallyPublishedAt : Date @ ForeignKey ( ( ) => VideoChannelModel ) @ Column channelId : number @ BelongsTo ( ( ) => VideoChannelModel , { foreignKey : { allowNull : true } , hooks : true } ) VideoChannel : VideoChannelModel @ BelongsToMany ( ( ) => TagModel , { foreignKey : 's' , through : ( ) => VideoTagModel , onDelete : 's' } ) Tags : TagModel [ ] @ HasMany ( ( ) => ThumbnailModel , { foreignKey : { name : 's' , allowNull : true } , hooks : true , onDelete : 's' } ) Thumbnails : ThumbnailModel [ ] @ HasMany ( ( ) => VideoPlaylistElementModel , { foreignKey : { name : 's' , allowNull : true } , onDelete : 's' } ) VideoPlaylistElements : VideoPlaylistElementModel [ ] @ HasMany ( ( ) => VideoAbuseModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) VideoAbuses : VideoAbuseModel [ ] @ HasMany ( ( ) => VideoFileModel , { foreignKey : { name : 's' , allowNull : false } , hooks : true , onDelete : 's' } ) VideoFiles : VideoFileModel [ ] @ HasMany ( ( ) => VideoStreamingPlaylistModel , { foreignKey : { name : 's' , allowNull : false } , hooks : true , onDelete : 's' } ) VideoStreamingPlaylists : VideoStreamingPlaylistModel [ ] @ HasMany ( ( ) => VideoShareModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) VideoShares : VideoShareModel [ ] @ HasMany ( ( ) => AccountVideoRateModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) AccountVideoRates : AccountVideoRateModel [ ] @ HasMany ( ( ) => VideoCommentModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' , hooks : true } ) VideoComments : VideoCommentModel [ ] @ HasMany ( ( ) => VideoViewModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) VideoViews : VideoViewModel [ ] @ HasMany ( ( ) => UserVideoHistoryModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) UserVideoHistories : UserVideoHistoryModel [ ] @ HasOne ( ( ) => ScheduleVideoUpdateModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) ScheduleVideoUpdate : ScheduleVideoUpdateModel @ HasOne ( ( ) => VideoBlacklistModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' } ) VideoBlacklist : VideoBlacklistModel @ HasOne ( ( ) => VideoImportModel , { foreignKey : { name : 's' , allowNull : true } , onDelete : 's' } ) VideoImport : VideoImportModel @ HasMany ( ( ) => VideoCaptionModel , { foreignKey : { name : 's' , allowNull : false } , onDelete : 's' , hooks : true , [ 's' as any ] : true } ) VideoCaptions : VideoCaptionModel [ ] @ BeforeDestroy static async sendDelete ( instance , options ) { if ( instance . isOwned ( ) ) { if ( ! instance . VideoChannel ) { instance . VideoChannel = await instance . $get ( 's' , { include : [ ActorModel , AccountModel ] , transaction : options . transaction } ) as MChannelAccountDefault } return sendDeleteVideo ( instance , options . transaction ) } return undefined } @ BeforeDestroy static async removeFiles ( instance ) { const tasks : Promise < any > [ ] = [ ] logger . info ( 's' , instance . url ) if ( instance . isOwned ( ) ) { if ( ! Array . isArray ( instance . VideoFiles ) ) { instance . VideoFiles = await instance . $get ( 's' ) as VideoFileModel [ ] } instance . VideoFiles . forEach ( file => { tasks . push ( instance . removeFile ( file ) ) tasks . push ( instance . removeTorrent ( file ) ) } ) tasks . push ( instance . removeStreamingPlaylist ( ) ) } Promise . all ( tasks ) . catch ( err => { logger . error ( 's' , instance . uuid , { err } ) } ) return undefined } static listLocal ( ) < MVideoWithAllFiles [ ] > { const query = { where : { remote : false } } return VideoModel . scope ( [ ScopeNames . WITH_FILES , ScopeNames . WITH_STREAMING_PLAYLISTS , ScopeNames . WITH_THUMBNAILS ] ) . findAll ( query ) } static listAllAndSharedByActorForOutbox ( actorId , start , count ) { function getRawQuery ( select ) { const queryVideo = 's' + select + 's' + 's' + 's' + 's' + actorId const queryVideoShare = 's' + select + 's' + 's' + 's' + actorId return `template` } const rawQuery = getRawQuery ( 's' ) const rawCountQuery = getRawQuery ( 's' ) const query = { distinct : true , offset : start , limit : count , order : getVideoSort ( 's' , [ 's' , 's' , 's' ] as any ) , where : { id : { [ Op . in ] : Sequelize . literal ( 's' + rawQuery + 's' ) } , [ Op . or ] : [ { privacy : VideoPrivacy . PUBLIC } , { privacy : VideoPrivacy . UNLISTED } ] } , include : [ { attributes : [ 's' ] , model : VideoCaptionModel . unscoped ( ) , required : false } , { attributes : [ 's' , 's' ] , model : VideoShareModel . unscoped ( ) , required : false , where : { [ Op . and ] : [ { id : { [ Op . not ] : null } } , { actorId } ] } , include : [ { attributes : [ 's' , 's' ] , model : ActorModel . unscoped ( ) } ] } , { model : VideoChannelModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' ] , model : AccountModel . unscoped ( ) , required : true , include : [ { attributes : [ 's' , 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true } ] } , { attributes : [ 's' , 's' , 's' ] , model : ActorModel . unscoped ( ) , required : true } ] } , VideoFileModel , TagModel ] } return Bluebird . all ( [ VideoModel . scope ( ScopeNames . WITH_THUMBNAILS ) . findAll ( query ) , VideoModel . sequelize . query < { total : string } > ( rawCountQuery , { type : QueryTypes . SELECT } ) ] ) . then ( ( [ rows , totals ] ) => { let totalVideos = 0 let totalVideoShares = 0 if ( totals [ 0 ] ) totalVideos = parseInt ( totals [ 0 ] . total , 0 ) if ( totals [ 0 ] ) totalVideoShares = parseInt ( totals [ 0 ] . total , 0 ) const total = totalVideos + totalVideoShares return { data : rows , total : total } } ) } static listUserVideosForApi ( accountId , start , count , sort ) { function buildBaseQuery ( ) { return { offset : start , limit : count , order : getVideoSort ( sort ) , include : [ { model : VideoChannelModel , required : true , include : [ { model : AccountModel , where : { id : accountId } , required : true } ] } ] } } const countQuery = buildBaseQuery ( ) const findQuery = buildBaseQuery ( ) const findScopes = [ ScopeNames . WITH_SCHEDULED_UPDATE , ScopeNames . WITH_BLACKLISTED , ScopeNames . WITH_THUMBNAILS ] return Promise . all ( [ VideoModel . count ( countQuery ) , VideoModel . scope ( findScopes ) . findAll < MVideoForUser > ( findQuery ) ] ) . then ( ( [ count , rows ] ) => { return { data : rows , total : count } } ) } static async listForApi ( options : { start : number , count : number , sort : string , nsfw : boolean , includeLocalVideos : boolean , withFiles : boolean , categoryOneOf ? : number [ ] , licenceOneOf ? : number [ ] , languageOneOf ? : string [ ] , tagsOneOf ? : string [ ] , tagsAllOf ? : string [ ] , filter ? : VideoFilter , accountId ? : number , videoChannelId ? : number , followerActorId ? : number videoPlaylistId ? : number , trendingDays ? : number , user ? : MUserAccountId , historyOfUser ? : MUserId } , countVideos = true ) { if ( options . filter && options . filter === 's' && ! options . user . hasRight ( UserRight . SEE_ALL_VIDEOS ) ) { throw new Error ( 's' ) } const query : FindOptions & { where ? : null } = { offset : options . start , limit : options . count , order : getVideoSort ( options . sort ) } let trendingDays if ( options . sort . endsWith ( 's' ) ) { trendingDays = CONFIG . TRENDING . VIDEOS . INTERVAL_DAYS query . group = 's' } const serverActor = await getServerActor ( ) const followerActorId = options . followerActorId !== undefined ? options . followerActorId : serverActor . id const queryOptions = { followerActorId , serverAccountId : serverActor . Account . id , nsfw : options . nsfw , categoryOneOf : options . categoryOneOf , licenceOneOf : options . licenceOneOf , languageOneOf : options . languageOneOf , tagsOneOf : options . tagsOneOf , tagsAllOf : options . tagsAllOf , filter : options . filter , withFiles : options . withFiles , accountId : options . accountId , videoChannelId : options . videoChannelId , videoPlaylistId : options . videoPlaylistId , includeLocalVideos : options . includeLocalVideos , user : options . user , historyOfUser : options . historyOfUser , trendingDays } return VideoModel . getAvailableForApi ( query , queryOptions , countVideos ) } static async searchAndPopulateAccountAndServer ( options : { includeLocalVideos : boolean search ? : string start ? : number count ? : number sort ? : string startDate ? : string endDate ? : string originallyPublishedStartDate ? : string originallyPublishedEndDate ? : string nsfw ? : boolean categoryOneOf ? : number [ ] licenceOneOf ? : number [ ] languageOneOf ? : string [ ] tagsOneOf ? : string [ ] tagsAllOf ? : string [ ] durationMin ? : number durationMax ? : number user ? : MUserAccountId , filter ? : VideoFilter } ) { const whereAnd = [ ] if ( options . startDate || options . endDate ) { const publishedAtRange = { } if ( options . startDate ) publishedAtRange [ Op . gte ] = options . startDate if ( options . endDate ) publishedAtRange [ Op . lte ] = options . endDate whereAnd . push ( { publishedAt : publishedAtRange } ) } if ( options . originallyPublishedStartDate || options . originallyPublishedEndDate ) { const originallyPublishedAtRange = { } if ( options . originallyPublishedStartDate ) originallyPublishedAtRange [ Op . gte ] = options . originallyPublishedStartDate if ( options . originallyPublishedEndDate ) originallyPublishedAtRange [ Op . lte ] = options . originallyPublishedEndDate whereAnd . push ( { originallyPublishedAt : originallyPublishedAtRange } ) } if ( options . durationMin || options . durationMax ) { const durationRange = { } if ( options . durationMin ) durationRange [ Op . gte ] = options . durationMin if ( options . durationMax ) durationRange [ Op . lte ] = options . durationMax whereAnd . push ( { duration : durationRange } ) } const attributesInclude = [ ] const escapedSearch = VideoModel . sequelize . escape ( options . search ) const escapedLikeSearch = VideoModel . sequelize . escape ( 's' + options . search + 's' ) if ( options . search ) { whereAnd . push ( { id : { [ Op . in ] : Sequelize . literal ( 's' + 's' + 's' + 's' + escapedSearch + 's' + 's' + escapedLikeSearch + 's' + 's' + 's' + 's' + 's' + escapedSearch + 's' ) } } ) attributesInclude . push ( createSimilarityAttribute ( 's' , options . search ) ) } if ( ! options . search ) { attributesInclude . push ( Sequelize . literal ( 's' ) ) } const query = { attributes : { include : attributesInclude } , offset : options . start , limit : options . count , order : getVideoSort ( options . sort ) } const serverActor = await getServerActor ( ) const queryOptions = { followerActorId : serverActor . id , serverAccountId : serverActor . Account . id , includeLocalVideos : options . includeLocalVideos , nsfw : options . nsfw , categoryOneOf : options . categoryOneOf , licenceOneOf : options . licenceOneOf , languageOneOf : options . languageOneOf , tagsOneOf : options . tagsOneOf , tagsAllOf : options . tagsAllOf , user : options . user , filter : options . filter , baseWhere : whereAnd } return VideoModel . getAvailableForApi ( query , queryOptions ) } static load ( id : number | string , t ? ) < MVideoThumbnail > { const where = buildWhereIdOrUUID ( id ) const options = { where , transaction : t } return VideoModel . scope ( ScopeNames . WITH_THUMBNAILS ) . findOne ( options ) } static loadWithBlacklist ( id : number | string , t ? ) < MVideoThumbnailBlacklist > { const where = buildWhereIdOrUUID ( id ) const options = { where , transaction : t } return VideoModel . scope ( [ ScopeNames . WITH_THUMBNAILS , ScopeNames . WITH_BLACKLISTED ] ) . findOne ( options ) } static loadWithRights ( id : number | string , t ? ) < MVideoWithRights > { const where = buildWhereIdOrUUID ( id ) const options = { where , transaction : t } return VideoModel . scope ( [ ScopeNames . WITH_BLACKLISTED , ScopeNames . WITH_USER_ID , ScopeNames . WITH_THUMBNAILS ] ) . findOne ( options ) } static loadOnlyId ( id : number | string , t ? ) < MVideoIdThumbnail > { const where = buildWhereIdOrUUID ( id ) const options = { attributes : [ 's' ] , where , transaction : t } return VideoModel . scope ( ScopeNames . WITH_THUMBNAILS ) . findOne ( options ) } static loadWithFiles ( id : number | string , t ? , logging ? ) < MVideoWithAllFiles > { const where = buildWhereIdOrUUID ( id ) const query = { where , transaction : t , logging } return VideoModel . scope ( [ ScopeNames . WITH_FILES , ScopeNames . WITH_STREAMING_PLAYLISTS , ScopeNames . WITH_THUMBNAILS ] ) . findOne ( query ) } static loadByUUID ( uuid ) < MVideoThumbnail > { const options = { where : { uuid } } return VideoModel . scope ( ScopeNames . WITH_THUMBNAILS ) . findOne ( options ) } static loadByUrl ( url , transaction ? ) < MVideoThumbnail > { const query = { where : { url } , transaction } return VideoModel . scope ( ScopeNames . WITH_THUMBNAILS ) . findOne ( query ) } static loadByUrlAndPopulateAccount ( url , transaction ? ) < MVideoAccountLightBlacklistAllFiles > { const query = { where : { url } , transaction } return VideoModel . scope ( [ ScopeNames . WITH_ACCOUNT_DETAILS , ScopeNames . WITH_FILES , ScopeNames . WITH_STREAMING_PLAYLISTS , ScopeNames . WITH_THUMBNAILS , ScopeNames . WITH_BLACKLISTED ] ) . findOne ( query ) } static loadAndPopulateAccountAndServerAndTags ( id : number | string , t ? , userId ? ) < MVideoFullLight > { const where = buildWhereIdOrUUID ( id ) const options = { order : [ [ 's' , 's' , 's' ] ] as any , where , transaction : t } const scopes : ( string | ScopeOptions ) [ ] = [ ScopeNames . WITH_TAGS , ScopeNames . WITH_BLACKLISTED , ScopeNames . WITH_ACCOUNT_DETAILS , ScopeNames . WITH_SCHEDULED_UPDATE , ScopeNames . WITH_FILES , ScopeNames . WITH_STREAMING_PLAYLISTS , ScopeNames . WITH_THUMBNAILS ] if ( userId ) { scopes . push ( { method : [ ScopeNames . WITH_USER_HISTORY , userId ] } ) } return VideoModel . scope ( scopes ) . findOne ( options ) } static loadForGetAPI ( parameters : { id : number | string , t ? : Transaction , userId ? : number } ) < MVideoDetails > { const { id , t , userId } = parameters const where = buildWhereIdOrUUID ( id ) const options = { order : [ [ 's' , 's' , 's' ] ] as any , where , transaction : t } const scopes : ( string | ScopeOptions ) [ ] = [ ScopeNames . WITH_TAGS , ScopeNames . WITH_BLACKLISTED , ScopeNames . WITH_ACCOUNT_DETAILS , ScopeNames . WITH_SCHEDULED_UPDATE , ScopeNames . WITH_THUMBNAILS , { method : [ ScopeNames . WITH_FILES , true ] } , { method : [ ScopeNames . WITH_STREAMING_PLAYLISTS , true ] } ] if ( userId ) { scopes . push ( { method : [ ScopeNames . WITH_USER_HISTORY , userId ] } ) } return VideoModel . scope ( scopes ) . findOne ( options ) } static async getStats ( ) { const totalLocalVideos = await VideoModel . count ( { where : { remote : false } } ) const totalVideos = await VideoModel . count ( ) let totalLocalVideoViews = await VideoModel . sum ( 's' , { where : { remote : false } } ) if ( ! totalLocalVideoViews ) totalLocalVideoViews = 0 return { totalLocalVideos , totalLocalVideoViews , totalVideos } } static incrementViews ( id , views ) { return VideoModel . increment ( 's' , { by : views , where : { id } } ) } static checkVideoHasInstanceFollow ( videoId , followerActorId ) { const query = 's' + 's' + 's' + 's' const options = { type : QueryTypes . SELECT , bind : { followerActorId , videoId } , raw : true } return VideoModel . sequelize . query ( query , options ) . then ( results => results . length === 0 ) } static bulkUpdateSupportField ( videoChannel , t ) { const options = { where : { channelId : videoChannel . id } , transaction : t } return VideoModel . update ( { support : videoChannel . support } , options ) } static getAllIdsFromChannel ( videoChannel ) < number [ ] > { const query = { attributes : [ 's' ] , where : { channelId : videoChannel . id } } return VideoModel . findAll ( query ) . then ( videos => videos . map ( v => v . id ) ) } static async getRandomFieldSamples ( field : 's' | 's' , threshold , count ) { const serverActor = await getServerActor ( ) const followerActorId = serverActor . id const scopeOptions = { serverAccountId : serverActor . Account . id , followerActorId , includeLocalVideos : true , attributesType : 's' } const query = { attributes : [ field ] , limit : count , group : field , having : Sequelize . where ( Sequelize . fn ( 's' , Sequelize . col ( field ) ) , { [ Op . gte ] : threshold } ) , order : [ ( this . sequelize as any ) . random ( ) ] } return VideoModel . scope ( { method : [ ScopeNames . AVAILABLE_FOR_LIST_IDS , scopeOptions ] } ) . findAll ( query ) . then ( rows => rows . map ( r => r [ field ] ) ) } static buildTrendingQuery ( trendingDays ) { return { attributes : [ ] , subQuery : false , model : VideoViewModel , required : false , where : { startDate : { [ Op . gte ] : new Date ( new Date ( ) . getTime ( ) - ( 0 * 0 * 0 ) * trendingDays ) } } } } private static buildActorWhereWithFilter ( filter ? ) { if ( filter && ( filter === 's' || filter === 's' ) ) { return { serverId : null } } return { } } private static async getAvailableForApi ( query : FindOptions & { where ? : null } , options , countVideos = true ) { const idsScope = { method : [ ScopeNames . AVAILABLE_FOR_LIST_IDS , options ] } const countOptions = Object . assign ( { } , options , { trendingDays : undefined } ) const countQuery = Object . assign ( { } , query , { attributes : undefined , group : undefined } ) const countScope = { method : [ ScopeNames . AVAILABLE_FOR_LIST_IDS , countOptions ] } const [ count , ids ] = await Promise . all ( [ countVideos ? VideoModel . scope ( countScope ) . count ( countQuery ) : Promise . resolve < number > ( undefined ) , VideoModel . scope ( idsScope ) . findAll ( query ) . then ( rows => rows . map ( r => r . id ) ) ] ) if ( ids . length === 0 ) return { data : [ ] , total : count } const secondQuery = { offset : 0 , limit : query . limit , attributes : query . attributes , order : [ Sequelize . literal ( ids . map ( id => `template` ) . join ( 's' ) ) ] } const apiScope : ( string | ScopeOptions ) [ ] = [ ] if ( options . user ) { apiScope . push ( { method : [ ScopeNames . WITH_USER_HISTORY , options . user . id ] } ) } apiScope . push ( { method : [ ScopeNames . FOR_API , { ids , withFiles : options . withFiles , videoPlaylistId : options . videoPlaylistId } as ForAPIOptions ] } ) const rows = await VideoModel . scope ( apiScope ) . findAll ( secondQuery ) return { data : rows , total : count } } static getCategoryLabel ( id ) { return VIDEO_CATEGORIES [ id ] || 's' } static getLicenceLabel ( id ) { return VIDEO_LICENCES [ id ] || 's' } static getLanguageLabel ( id ) { return VIDEO_LANGUAGES [ id ] || 's' } static getPrivacyLabel ( id ) { return VIDEO_PRIVACIES [ id ] || 's' } static getStateLabel ( id ) { return VIDEO_STATES [ id ] || 's' } isBlacklisted ( ) { return ! ! this . VideoBlacklist } isBlocked ( ) { return ( this . VideoChannel . Account . Actor . Server && this . VideoChannel . Account . Actor . Server . isBlocked ( ) ) || this . VideoChannel . Account . isBlocked ( ) } getOriginalFile < T extends MVideoWithFile > ( this : T ) { if ( Array . isArray ( this . VideoFiles ) === false ) return undefined return maxBy ( this . VideoFiles , file => file . resolution ) } getFile < T extends MVideoWithFile > ( this : T , resolution ) { if ( Array . isArray ( this . VideoFiles ) === false ) return undefined return this . VideoFiles . find ( f => f . resolution === resolution ) } async addAndSaveThumbnail ( thumbnail , transaction ) { thumbnail . videoId = this . id const savedThumbnail = await thumbnail . save ( { transaction } ) if ( Array . isArray ( this . Thumbnails ) === false ) this . Thumbnails = [ ] if ( this . Thumbnails . find ( t => t . id === savedThumbnail . id ) ) return this . Thumbnails . push ( savedThumbnail ) } getVideoFilename ( videoFile ) { return this . uuid + 's' + videoFile . resolution + videoFile . extname } generateThumbnailName ( ) { return this . uuid + 's' } getMiniature ( ) { if ( Array . isArray ( this . Thumbnails ) === false ) return undefined return this . Thumbnails . find ( t => t . type === ThumbnailType . MINIATURE ) } generatePreviewName ( ) { return this . uuid + 's' } getPreview ( ) { if ( Array . isArray ( this . Thumbnails ) === false ) return undefined return this . Thumbnails . find ( t => t . type === ThumbnailType . PREVIEW ) } getTorrentFileName ( videoFile ) { const extension = 's' return this . uuid + 's' + videoFile . resolution + extension } isOwned ( ) { return this . remote === false } getTorrentFilePath ( videoFile ) { return join ( CONFIG . STORAGE . TORRENTS_DIR , this . getTorrentFileName ( videoFile ) ) } getVideoFilePath ( videoFile ) { return join ( CONFIG . STORAGE . VIDEOS_DIR , this . getVideoFilename ( videoFile ) ) } async createTorrentAndSetInfoHash ( videoFile ) { const options = { name : `template` , createdBy : 's' , announceList : [ [ WEBSERVER . WS + 's' + WEBSERVER . HOSTNAME + 's' + WEBSERVER . PORT + 's' ] , [ WEBSERVER . URL + 's' ] ] , urlList : [ WEBSERVER . URL + STATIC_PATHS . WEBSEED + this . getVideoFilename ( videoFile ) ] } const torrent = await createTorrentPromise ( this . getVideoFilePath ( videoFile ) , options ) const filePath = join ( CONFIG . STORAGE . TORRENTS_DIR , this . getTorrentFileName ( videoFile ) ) logger . info ( 's' , filePath ) await writeFile ( filePath , torrent ) const parsedTorrent = parseTorrent ( torrent ) videoFile . infoHash = parsedTorrent . infoHash } getWatchStaticPath ( ) { return 's' + this . uuid } getEmbedStaticPath ( ) { return 's' + this . uuid } getMiniatureStaticPath ( ) { const thumbnail = this . getMiniature ( ) if ( ! thumbnail ) return null return join ( STATIC_PATHS . THUMBNAILS , thumbnail . filename ) } getPreviewStaticPath ( ) { const preview = this . getPreview ( ) if ( ! preview ) return null return join ( LAZY_STATIC_PATHS . PREVIEWS , preview . filename ) } toFormattedJSON ( this , options ? ) { return videoModelToFormattedJSON ( this , options ) } toFormattedDetailsJSON ( this ) { return videoModelToFormattedDetailsJSON ( this ) } getFormattedVideoFilesJSON ( ) : VideoFile [ ] { return videoFilesModelToFormattedJSON ( this , this . VideoFiles ) } toActivityPubObject ( this ) { return videoModelToActivityPubObject ( this ) } getTruncatedDescription ( ) { if ( ! this . description ) return null const maxLength = CONSTRAINTS_FIELDS . VIDEOS . TRUNCATED_DESCRIPTION . max return peertubeTruncate ( this . description , maxLength ) } getOriginalFileResolution ( ) { const originalFilePath = this . getVideoFilePath ( this . getOriginalFile ( ) ) return getVideoFileResolution ( originalFilePath ) } getDescriptionAPIPath ( ) { return `template` } getHLSPlaylist ( ) { if ( ! this . VideoStreamingPlaylists ) return undefined return this . VideoStreamingPlaylists . find ( p => p . type === VideoStreamingPlaylistType . HLS ) } removeFile ( videoFile , isRedundancy = false ) { const baseDir = isRedundancy ? CONFIG . STORAGE . REDUNDANCY_DIR : CONFIG . STORAGE . VIDEOS_DIR const filePath = join ( baseDir , this . getVideoFilename ( videoFile ) ) return remove ( filePath ) . catch ( err => logger . warn ( 's' , filePath , { err } ) ) } removeTorrent ( videoFile ) { const torrentPath = join ( CONFIG . STORAGE . TORRENTS_DIR , this . getTorrentFileName ( videoFile ) ) return remove ( torrentPath ) . catch ( err => logger . warn ( 's' , torrentPath , { err } ) ) } removeStreamingPlaylist ( isRedundancy = false ) { const baseDir = isRedundancy ? HLS_REDUNDANCY_DIRECTORY : HLS_STREAMING_PLAYLIST_DIRECTORY const filePath = join ( baseDir , this . uuid ) return remove ( filePath ) . catch ( err => logger . warn ( 's' , filePath , { err } ) ) } isOutdated ( ) { if ( this . isOwned ( ) ) return false return isOutdated ( this , ACTIVITY_PUB . VIDEO_REFRESH_INTERVAL ) } setAsRefreshed ( ) { this . changed ( 's' , true ) return this . save ( ) } getBaseUrls ( ) { let baseUrlHttp let baseUrlWs if ( this . isOwned ( ) ) { baseUrlHttp = WEBSERVER . URL baseUrlWs = WEBSERVER . WS + 's' + WEBSERVER . HOSTNAME + 's' + WEBSERVER . PORT } else { baseUrlHttp = REMOTE_SCHEME . HTTP + 's' + this . VideoChannel . Account . Actor . Server . host baseUrlWs = REMOTE_SCHEME . WS + 's' + this . VideoChannel . Account . Actor . Server . host } return { baseUrlHttp , baseUrlWs } } generateMagnetUri ( videoFile , baseUrlHttp , baseUrlWs ) { const xs = this . getTorrentUrl ( videoFile , baseUrlHttp ) const announce = this . getTrackerUrls ( baseUrlHttp , baseUrlWs ) let urlList = [ this . getVideoFileUrl ( videoFile , baseUrlHttp ) ] const redundancies = videoFile . RedundancyVideos if ( isArray ( redundancies ) ) urlList = urlList . concat ( redundancies . map ( r => r . fileUrl ) ) const magnetHash = { xs , announce , urlList , infoHash : videoFile . infoHash , name : this . name } return magnetUtil . encode ( magnetHash ) } getTrackerUrls ( baseUrlHttp , baseUrlWs ) { return [ baseUrlWs + 's' , baseUrlHttp + 's' ] } getTorrentUrl ( videoFile , baseUrlHttp ) { return baseUrlHttp + STATIC_PATHS . TORRENTS + this . getTorrentFileName ( videoFile ) } getTorrentDownloadUrl ( videoFile , baseUrlHttp ) { return baseUrlHttp + STATIC_DOWNLOAD_PATHS . TORRENTS + this . getTorrentFileName ( videoFile ) } getVideoFileUrl ( videoFile , baseUrlHttp ) { return baseUrlHttp + STATIC_PATHS . WEBSEED + this . getVideoFilename ( videoFile ) } getVideoRedundancyUrl ( videoFile , baseUrlHttp ) { return baseUrlHttp + STATIC_PATHS . REDUNDANCY + this . getVideoFilename ( videoFile ) } getVideoFileDownloadUrl ( videoFile , baseUrlHttp ) { return baseUrlHttp + STATIC_DOWNLOAD_PATHS . VIDEOS + this . getVideoFilename ( videoFile ) } getBandwidthBits ( videoFile ) { return Math . ceil ( ( videoFile . size * 0 ) / this . duration ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ForAPIOptions$ O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvailableForListIDsOptions$ O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IncludeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IncludeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAccountLight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $string$ O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $string$ O O $Transaction$ O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O $Transaction$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MChannel$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O $MChannelId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O $AvailableForListIDsOptions$ O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFilter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvailableForListIDsOptions$ O O O O O O O $ScopeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CountOptions$ O O O O O O O O O O O O O O O O O O O O O $ScopeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FindOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MThumbnail$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O $MVideoFormattable$ O O $VideoFormattingJSONOptions$ O O O O O O O O O O $VideoDetails$ O $MVideoFormattableDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTorrentObject$ O $MVideoAP$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoFileRedundanciesOpt$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O $MVideoFile$ O $string$ O O O O O O O O O O O O O O O O O O $MVideoFile$ O $string$ O O O O O O O O O O O O O O O O O O $MVideoFile$ O $string$ O O O O O O O O O O O O O O O O O O $MVideoFile$ O $string$ O O O O O O O O O O O O O O O O O O $MVideoFile$ O $string$ O O O O O O O O O O O O O O O O O O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { resolve } from 's' import { VideoModel } from 's' import { initDatabaseModels } from 's' import { JobQueue } from 's' program . option ( 's' , 's' ) . option ( 's' , 's' ) . description ( 's' ) . parse ( process . argv ) if ( program [ 's' ] === undefined || program [ 's' ] === undefined ) { console . error ( 's' ) process . exit ( - 0 ) } run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const video = await VideoModel . loadByUUID ( program [ 's' ] ) if ( ! video ) throw new Error ( 's' ) if ( video . isOwned ( ) === false ) throw new Error ( 's' ) const dataInput = { videoUUID : video . uuid , filePath : resolve ( program [ 's' ] ) } await JobQueue . Instance . init ( ) await JobQueue . Instance . createJob ( { type : 's' , payload : dataInput } ) console . log ( 's' , video . uuid ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { VideoModel } from 's' import { initDatabaseModels } from 's' import { JobQueue } from 's' import { VideoTranscodingPayload } from 's' program . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) if ( program [ 's' ] === undefined ) { console . error ( 's' ) process . exit ( - 0 ) } if ( program . resolution !== undefined && Number . isNaN ( + program . resolution ) ) { console . error ( 's' ) process . exit ( - 0 ) } run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const video = await VideoModel . loadByUUID ( program [ 's' ] ) if ( ! video ) throw new Error ( 's' ) const dataInput = program . resolution !== undefined ? { type : 's' as 's' , videoUUID : video . uuid , isNewVideo : false , resolution : program . resolution } : { type : 's' as 's' , videoUUID : video . uuid , isNewVideo : false } await JobQueue . Instance . init ( ) await JobQueue . Instance . createJob ( { type : 's' , payload : dataInput } ) console . log ( 's' , video . uuid ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTranscodingPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Promise from 's' import * as rimraf from 's' import { initDatabaseModels , sequelizeTypescript } from 's' import { CONFIG } from 's' initDatabaseModels ( true ) . then ( ( ) => { return sequelizeTypescript . drop ( ) } ) . then ( ( ) => { console . info ( 's' , CONFIG . DATABASE . DBNAME ) const STORAGE = CONFIG . STORAGE Promise . mapSeries ( Object . keys ( STORAGE ) , storage => { const storageDir = STORAGE [ storage ] return new Promise ( ( res , rej ) => { rimraf ( storageDir , err => { if ( err ) return rej ( err ) console . info ( 's' , storageDir ) return res ( ) } ) } ) } ) . then ( ( ) => process . exit ( 0 ) ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { doRequest } from 's' import { readFileSync } from 's' run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { { const contributors = await fetchGithub ( 's' ) console . log ( 's' ) for ( const contributor of contributors ) { const contributorUrl = contributor . url . replace ( 's' , 's' ) console . log ( `template` ) } } { const zanataConfig = readFileSync ( require ( 's' ) . homedir ( ) + 's' ) . toString ( ) const zanataUsername = zanataConfig . match ( 's' ) [ 0 ] const zanataToken = zanataConfig . match ( 's' ) [ 0 ] const translators = await fetchZanata ( zanataUsername , zanataToken ) console . log ( 's' ) for ( const translator of translators ) { console . log ( `template` ) } } { console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) } } function get ( url , headers = { } ) { return doRequest < any > ( { uri : url , json : true , headers : Object . assign ( headers , { 's' : 's' } ) } ) . then ( res => res . body ) } async function fetchGithub ( url ) { let next = url let allResult = [ ] let i = 0 while ( i < 0 ) { const result = await get ( next + 's' + i ) if ( result . length === 0 ) break allResult = allResult . concat ( result ) i ++ } return allResult } async function fetchZanata ( zanataUsername , zanataPassword ) { const today = new Date ( ) . toISOString ( ) . split ( 's' ) [ 0 ] const 0 = `template` const 0 = `template` const headers = { 's' : zanataUsername , 's' : zanataPassword } const [ 0 , 0 ] = await Promise . all ( [ get ( 0 , headers ) , get ( 0 , headers ) ] ) return 0 . concat ( 0 ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as 0 from 's' import { writeFile } from 's' import { join } from 's' import { buildLanguages , VIDEO_CATEGORIES , VIDEO_IMPORT_STATES , VIDEO_LICENCES , VIDEO_PLAYLIST_PRIVACIES , VIDEO_PLAYLIST_TYPES , VIDEO_PRIVACIES , VIDEO_STATES } from 's' import { values } from 's' type TranslationType = { target : string data : { [ id ] : string } } const videojs = require ( join ( __dirname , 's' ) ) const playerKeys = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } const playerTranslations = { target : join ( __dirname , 's' ) , data : Object . assign ( { } , videojs , playerKeys ) } const serverKeys = { } values ( VIDEO_CATEGORIES ) . concat ( values ( VIDEO_LICENCES ) ) . concat ( values ( VIDEO_PRIVACIES ) ) . concat ( values ( VIDEO_STATES ) ) . concat ( values ( VIDEO_IMPORT_STATES ) ) . concat ( values ( VIDEO_PLAYLIST_PRIVACIES ) ) . concat ( values ( VIDEO_PLAYLIST_TYPES ) ) . concat ( [ 's' , 's' , 's' , 's' ] ) . forEach ( v => serverKeys [ v ] = v ) Object . assign ( serverKeys , { 's' : 's' , 's' : 's' } ) const serverTranslations = { target : join ( __dirname , 's' ) , data : serverKeys } const languageKeys = { } const languages = buildLanguages ( ) Object . keys ( languages ) . forEach ( k => languageKeys [ languages [ k ] ] = languages [ k ] ) const 0 = { target : join ( __dirname , 's' ) , data : languageKeys } saveToXliffFile ( playerTranslations , err => { if ( err ) return handleError ( err ) saveToXliffFile ( serverTranslations , err => { if ( err ) return handleError ( err ) saveToXliffFile ( 0 , err => { if ( err ) return handleError ( err ) process . exit ( 0 ) } ) } ) } ) function saveToXliffFile ( jsonTranslations , cb ) { const obj = { resources : { 0 : { } } } Object . keys ( jsonTranslations . data ) . forEach ( k => obj . resources . 0 [ k ] = { source : jsonTranslations . data [ k ] } ) 0 ( obj , ( err , res ) => { if ( err ) return cb ( err ) writeFile ( jsonTranslations . target , res , err => { if ( err ) return cb ( err ) return cb ( null ) } ) } ) } function handleError ( err ) { console . error ( err ) process . exit ( - 0 ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TranslationType$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O
import * as 0 from 's' import { readFileSync , unlink , writeFile } from 's' import { join } from 's' import { buildFileLocale , 0 , isDefaultLocale } from 's' import { eachSeries } from 's' const sources : string [ ] = [ ] const availableLocales = Object . keys ( 0 ) . filter ( l => isDefaultLocale ( l ) === false ) . map ( l => buildFileLocale ( l ) ) for ( const file of [ 's' , 's' , 's' ] ) { for ( const locale of availableLocales ) { sources . push ( join ( __dirname , 's' , `template` ) ) } } eachSeries ( sources , ( source , cb ) => { 0 ( source , cb ) } , err => { if ( err ) return handleError ( err ) 0 ( err => { if ( err ) return handleError ( err ) process . exit ( 0 ) } ) } ) function handleError ( err ) { console . error ( err ) process . exit ( - 0 ) } function 0 ( filePath , cb ) { const fileTarget = filePath . replace ( 's' , 's' ) let fileContent = readFileSync ( filePath ) . toString ( ) fileContent = removeFirstLine ( fileContent ) fileContent = removeFirstLine ( fileContent ) 0 ( fileContent , ( err , res ) => { if ( err ) return cb ( err ) const json = createJSONString ( res ) writeFile ( fileTarget , json , err => { if ( err ) return cb ( err ) return unlink ( filePath , cb ) } ) } ) } function 0 ( cb ) { eachSeries ( availableLocales , ( locale , eachCallback ) => { const serverPath = join ( __dirname , 's' , `template` ) const 0 = join ( __dirname , 's' , `template` ) const resServer = readFileSync ( serverPath ) . toString ( ) const 0 = readFileSync ( 0 ) . toString ( ) const jsonServer = JSON . parse ( resServer ) const 0 = JSON . parse ( 0 ) Object . assign ( jsonServer , 0 ) const serverString = JSON . stringify ( jsonServer ) writeFile ( serverPath , serverString , err => { if ( err ) return eachCallback ( err ) return unlink ( 0 , eachCallback ) } ) } , cb ) } function removeFirstLine ( str ) { return str . substring ( str . indexOf ( 's' ) + 0 ) } function createJSONString ( obj ) { const res = { } const strings = obj . resources [ 's' ] Object . keys ( strings ) . forEach ( k => res [ k ] = strings [ k ] . target ) return JSON . stringify ( res ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VIDEO_TRANSCODING_FPS } from 's' import { getDurationFromVideoFile , getVideoFileBitrate , getVideoFileFPS , getVideoFileResolution } from 's' import { getMaxBitrate } from 's' import { VideoModel } from 's' import { optimizeVideofile } from 's' import { initDatabaseModels } from 's' import { basename , dirname , join } from 's' import { copy , move , remove } from 's' import { CONFIG } from 's' run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) let currentVideoId = null let currentFile = null process . on ( 's' , async function ( ) { console . log ( 's' ) await remove ( `template` ) await remove ( `template` ) process . exit ( 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const localVideos = await VideoModel . listLocal ( ) for ( const video of localVideos ) { currentVideoId = video . id for ( const file of video . VideoFiles ) { currentFile = join ( CONFIG . STORAGE . VIDEOS_DIR , video . getVideoFilename ( file ) ) const [ videoBitrate , fps , resolution ] = await Promise . all ( [ getVideoFileBitrate ( currentFile ) , getVideoFileFPS ( currentFile ) , getVideoFileResolution ( currentFile ) ] ) const maxBitrate = getMaxBitrate ( resolution . videoFileResolution , fps , VIDEO_TRANSCODING_FPS ) const isMaxBitrateExceeded = videoBitrate > maxBitrate if ( isMaxBitrateExceeded ) { console . log ( 's' , basename ( currentFile ) , videoBitrate / 0 , maxBitrate / 0 ) const backupFile = `template` await copy ( currentFile , backupFile ) await optimizeVideofile ( video , file ) const originalDuration = await getDurationFromVideoFile ( backupFile ) const newDuration = await getDurationFromVideoFile ( currentFile ) if ( originalDuration === newDuration ) { console . log ( 's' , basename ( currentFile ) ) await remove ( backupFile ) continue } console . log ( 's' , basename ( currentFile ) ) await move ( backupFile , currentFile , { overwrite : true } ) await video . createTorrentAndSetInfoHash ( file ) await file . save ( ) } } } console . log ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { stat } from 's' async function mtimeSortFilesDesc ( files : string [ ] , basePath ) { const promises = [ ] const out : { file : string , mtime : number } [ ] = [ ] for ( const file of files ) { const p = stat ( basePath + 's' + file ) . then ( stats => { if ( stats . isFile ( ) ) out . push ( { file , mtime : stats . mtime . getTime ( ) } ) } ) promises . push ( p ) } await Promise . all ( promises ) out . sort ( ( a , b ) => b . mtime - a . mtime ) return out } export { mtimeSortFilesDesc }	O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { createReadStream , readdir } from 's' import { join } from 's' import { createInterface } from 's' import * as winston from 's' import { labelFormatter } from 's' import { CONFIG } from 's' import { mtimeSortFilesDesc } from 's' program . option ( 's' , 's' ) . parse ( process . argv ) const excludedKeys = { level : true , message : true , splat : true , timestamp : true , label : true } function keysExcluder ( key , value ) { return excludedKeys [ key ] === true ? undefined : value } const loggerFormat = winston . format . printf ( ( info ) => { let additionalInfos = JSON . stringify ( info , keysExcluder , 0 ) if ( additionalInfos === 's' ) additionalInfos = 's' else additionalInfos = 's' + additionalInfos return `template` } ) const logger = winston . createLogger ( { transports : [ new winston . transports . Console ( { level : program [ 's' ] || 's' , stderrLevels : [ ] , format : winston . format . combine ( winston . format . splat ( ) , labelFormatter , winston . format . colorize ( ) , loggerFormat ) } ) ] , exitOnError : true } ) const logLevels = { error : logger . error . bind ( logger ) , warn : logger . warn . bind ( logger ) , info : logger . info . bind ( logger ) , debug : logger . debug . bind ( logger ) } run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => console . error ( err ) ) function run ( ) { return new Promise ( async res => { const logFiles = await readdir ( CONFIG . STORAGE . LOG_DIR ) const lastLogFile = await getNewestFile ( logFiles , CONFIG . STORAGE . LOG_DIR ) const path = join ( CONFIG . STORAGE . LOG_DIR , lastLogFile ) console . log ( 's' , path ) const stream = createReadStream ( path ) const rl = createInterface ( { input : stream } ) rl . on ( 's' , line => { const log = JSON . parse ( line ) Object . assign ( log , { splat : undefined } ) logLevels [ log . level ] ( log ) } ) stream . once ( 's' , ( ) => res ( ) ) } ) } async function getNewestFile ( files : string [ ] , basePath ) { const sorted = await mtimeSortFilesDesc ( files , basePath ) return ( sorted . length > 0 ) ? sorted [ 0 ] . file : 's' } function toTimeFormat ( time ) { const timestamp = Date . parse ( time ) if ( isNaN ( timestamp ) === true ) return 's' return new Date ( timestamp ) . toISOString ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { initDatabaseModels } from 's' import * as program from 's' import { PluginManager } from 's' import { isAbsolute } from 's' program . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) if ( ! program [ 's' ] && ! program [ 's' ] ) { console . error ( 's' ) process . exit ( - 0 ) } if ( program [ 's' ] && ! isAbsolute ( program [ 's' ] ) ) { console . error ( 's' ) process . exit ( - 0 ) } run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const toInstall = program [ 's' ] || program [ 's' ] await PluginManager . Instance . install ( toInstall , program [ 's' ] , ! ! program [ 's' ] ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { initDatabaseModels } from 's' import * as program from 's' import { PluginManager } from 's' program . option ( 's' , 's' ) . parse ( process . argv ) if ( ! program [ 's' ] ) { console . error ( 's' ) process . exit ( - 0 ) } run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const toUninstall = program [ 's' ] await PluginManager . Instance . uninstall ( toUninstall ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as prompt from 's' import { join } from 's' import { CONFIG } from 's' import { VideoModel } from 's' import { initDatabaseModels } from 's' import { readdir , remove } from 's' import { VideoRedundancyModel } from 's' import * as Bluebird from 's' import { getUUIDFromFilename } from 's' import { ThumbnailModel } from 's' import { AvatarModel } from 's' import { uniq , values } from 's' run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { const dirs = values ( CONFIG . STORAGE ) if ( uniq ( dirs ) . length !== dirs . length ) { console . error ( 's' ) process . exit ( 0 ) } await initDatabaseModels ( true ) let toDelete : string [ ] = [ ] toDelete = toDelete . concat ( await pruneDirectory ( CONFIG . STORAGE . VIDEOS_DIR , doesVideoExist ( true ) ) , await pruneDirectory ( CONFIG . STORAGE . TORRENTS_DIR , doesVideoExist ( true ) ) , await pruneDirectory ( CONFIG . STORAGE . REDUNDANCY_DIR , doesRedundancyExist ) , await pruneDirectory ( CONFIG . STORAGE . PREVIEWS_DIR , doesThumbnailExist ( true ) ) , await pruneDirectory ( CONFIG . STORAGE . THUMBNAILS_DIR , doesThumbnailExist ( false ) ) , await pruneDirectory ( CONFIG . STORAGE . AVATARS_DIR , doesAvatarExist ) ) const tmpFiles = await readdir ( CONFIG . STORAGE . TMP_DIR ) toDelete = toDelete . concat ( tmpFiles . map ( t => join ( CONFIG . STORAGE . TMP_DIR , t ) ) ) if ( toDelete . length === 0 ) { console . log ( 's' ) return } console . log ( 's' , toDelete . length , toDelete . join ( 's' ) ) const res = await askConfirmation ( ) if ( res === true ) { console . log ( 's' ) for ( const path of toDelete ) { await remove ( path ) } console . log ( 's' ) } else { console . log ( 's' ) } } type ExistFun = ( file ) => Promise < boolean > async function pruneDirectory ( directory , existFun ) { const files = await readdir ( directory ) const toDelete : string [ ] = [ ] await Bluebird . map ( files , async file => { if ( await existFun ( file ) !== true ) { toDelete . push ( join ( directory , file ) ) } } , { concurrency : 0 } ) return toDelete } function doesVideoExist ( keepOnlyOwned ) { return async ( file ) => { const uuid = getUUIDFromFilename ( file ) const video = await VideoModel . loadByUUID ( uuid ) return video && ( keepOnlyOwned === false || video . isOwned ( ) ) } } function doesThumbnailExist ( keepOnlyOwned ) { return async ( file ) => { const thumbnail = await ThumbnailModel . loadByName ( file ) if ( ! thumbnail ) return false if ( keepOnlyOwned ) { const video = await VideoModel . load ( thumbnail . videoId ) if ( video . isOwned ( ) === false ) return false } return true } } async function doesAvatarExist ( file ) { const avatar = await AvatarModel . loadByName ( file ) return ! ! avatar } async function doesRedundancyExist ( file ) { const uuid = getUUIDFromFilename ( file ) const video = await VideoModel . loadWithFiles ( uuid ) if ( ! video ) return false const isPlaylist = file . includes ( 's' ) === false if ( isPlaylist ) { const p = video . getHLSPlaylist ( ) if ( ! p ) return false const redundancy = await VideoRedundancyModel . loadLocalByStreamingPlaylistId ( p . id ) return ! ! redundancy } const resolution = parseInt ( file . split ( 's' ) [ 0 ] , 0 ) if ( isNaN ( resolution ) ) { console . error ( 's' , file ) return true } const videoFile = video . getFile ( resolution ) if ( ! videoFile ) { console . error ( 's' , video . url , resolution ) return true } const redundancy = await VideoRedundancyModel . loadLocalByFileId ( videoFile . id ) return ! ! redundancy } async function askConfirmation ( ) { return new Promise ( ( res , rej ) => { prompt . start ( ) const schema = { properties : { confirm : { type : 's' , description : 's' + 's' + 's' , default : 's' , required : true } } } prompt . get ( schema , function ( err , result ) { if ( err ) return rej ( err ) return res ( result . confirm && result . confirm . match ( "s" ) !== null ) } ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O $ExistFun$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { initDatabaseModels } from 's' import { UserModel } from 's' import { isUserPasswordValid } from 's' program . option ( 's' , 's' ) . parse ( process . argv ) if ( program [ 's' ] === undefined ) { console . error ( 's' ) process . exit ( - 0 ) } initDatabaseModels ( true ) . then ( ( ) => { return UserModel . loadByUsername ( program [ 's' ] ) } ) . then ( user => { if ( ! user ) { console . error ( 's' ) process . exit ( - 0 ) } const readline = require ( 's' ) const Writable = require ( 's' ) . Writable const mutableStdout = new Writable ( { write : function ( chunk , encoding , callback ) { callback ( ) } } ) const rl = readline . createInterface ( { input : process . stdin , output : mutableStdout , terminal : true } ) console . log ( 's' ) rl . on ( 's' , function ( password ) { if ( ! isUserPasswordValid ( password ) ) { console . error ( 's' ) process . exit ( - 0 ) } user . password = password user . save ( ) . then ( ( ) => console . log ( 's' ) ) . catch ( err => console . error ( err ) ) . finally ( ( ) => process . exit ( 0 ) ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { WEBSERVER } from 's' import { ActorFollowModel } from 's' import { VideoModel } from 's' import { ActorModel } from 's' import { getAccountActivityPubUrl , getVideoActivityPubUrl , getVideoAnnounceActivityPubUrl , getVideoChannelActivityPubUrl , getVideoCommentActivityPubUrl } from 's' import { VideoShareModel } from 's' import { VideoCommentModel } from 's' import { getServerActor } from 's' import { AccountModel } from 's' import { VideoChannelModel } from 's' import { VideoStreamingPlaylistModel } from 's' import { initDatabaseModels } from 's' run ( ) . then ( ( ) => process . exit ( 0 ) ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) async function run ( ) { await initDatabaseModels ( true ) const serverAccount = await getServerActor ( ) { const res = await ActorFollowModel . listAcceptedFollowingUrlsForApi ( [ serverAccount . id ] , undefined ) const hasFollowing = res . total > 0 if ( hasFollowing === true ) { throw new Error ( 's' ) } } console . log ( 's' ) const actors : ActorModel [ ] = await ActorModel . unscoped ( ) . findAll ( { include : [ { model : VideoChannelModel . unscoped ( ) , required : false } , { model : AccountModel . unscoped ( ) , required : false } ] } ) for ( const actor of actors ) { if ( actor . isOwned ( ) === false ) continue console . log ( 's' + actor . url ) const newUrl = actor . Account ? getAccountActivityPubUrl ( actor . preferredUsername ) : getVideoChannelActivityPubUrl ( actor . preferredUsername ) actor . url = newUrl actor . inboxUrl = newUrl + 's' actor . outboxUrl = newUrl + 's' actor . sharedInboxUrl = WEBSERVER . URL + 's' actor . followersUrl = newUrl + 's' actor . followingUrl = newUrl + 's' await actor . save ( ) } console . log ( 's' ) const videoShares : VideoShareModel [ ] = await VideoShareModel . findAll ( { include : [ VideoModel . unscoped ( ) , ActorModel . unscoped ( ) ] } ) for ( const videoShare of videoShares ) { if ( videoShare . Video . isOwned ( ) === false ) continue console . log ( 's' + videoShare . url ) videoShare . url = getVideoAnnounceActivityPubUrl ( videoShare . Actor , videoShare . Video ) await videoShare . save ( ) } console . log ( 's' ) const videoComments : VideoCommentModel [ ] = await VideoCommentModel . findAll ( { include : [ { model : VideoModel . unscoped ( ) } , { model : AccountModel . unscoped ( ) , include : [ { model : ActorModel . unscoped ( ) } ] } ] } ) for ( const comment of videoComments ) { if ( comment . isOwned ( ) === false ) continue console . log ( 's' + comment . url ) comment . url = getVideoCommentActivityPubUrl ( comment . Video , comment ) await comment . save ( ) } console . log ( 's' ) const videos = await VideoModel . listLocal ( ) for ( const video of videos ) { console . log ( 's' + video . uuid ) video . url = getVideoActivityPubUrl ( video ) await video . save ( ) for ( const file of video . VideoFiles ) { console . log ( 's' , file . resolution , video . uuid ) await video . createTorrentAndSetInfoHash ( file ) } for ( const playlist of video . VideoStreamingPlaylists ) { playlist . playlistUrl = WEBSERVER . URL + VideoStreamingPlaylistModel . getHlsMasterPlaylistStaticPath ( video . uuid ) playlist . 0 = WEBSERVER . URL + VideoStreamingPlaylistModel . 0 ( video . uuid ) await playlist . save ( ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Redis } from 's' import * as apicache from 's' Redis . Instance . init ( ) const options = { redisClient : Redis . Instance . getClient ( ) , appendKey : ( ) => Redis . Instance . getPrefix ( ) } const cacheRoute = apicache . options ( options ) . middleware export { cacheRoute }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' function activityPubResponse ( data , res : express . Response ) { return res . type ( 's' ) . json ( data ) . end ( ) } export { activityPubResponse }	O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param } from 's' import { exists , isBooleanValid , isIdOrUUIDValid , toBooleanOrNull , toIntOrNull } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { VideoRedundancyModel } from 's' import { isHostValid } from 's' import { ServerModel } from 's' import { doesVideoExist } from 's' const videoFileRedundancyGetValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . customSanitizer ( toIntOrNull ) . custom ( exists ) . withMessage ( 's' ) , param ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( exists ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return const video = res . locals . videoAll const videoFile = video . VideoFiles . find ( f => { return f . resolution === req . params . resolution && ( ! req . params . fps || f . fps === req . params . fps ) } ) if ( ! videoFile ) return res . status ( 0 ) . json ( { error : 's' } ) res . locals . videoFile = videoFile const videoRedundancy = await VideoRedundancyModel . loadLocalByFileId ( videoFile . id ) if ( ! videoRedundancy ) return res . status ( 0 ) . json ( { error : 's' } ) res . locals . videoRedundancy = videoRedundancy return next ( ) } ] const videoPlaylistRedundancyGetValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , param ( 's' ) . custom ( exists ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoExist ( req . params . videoId , res ) ) return const video = res . locals . videoAll const videoStreamingPlaylist = video . VideoStreamingPlaylists . find ( p => p === req . params . streamingPlaylistType ) if ( ! videoStreamingPlaylist ) return res . status ( 0 ) . json ( { error : 's' } ) res . locals . videoStreamingPlaylist = videoStreamingPlaylist const videoRedundancy = await VideoRedundancyModel . loadLocalByStreamingPlaylistId ( videoStreamingPlaylist . id ) if ( ! videoRedundancy ) return res . status ( 0 ) . json ( { error : 's' } ) res . locals . videoRedundancy = videoRedundancy return next ( ) } ] const updateServerRedundancyValidator = [ param ( 's' ) . custom ( isHostValid ) . withMessage ( 's' ) , body ( 's' ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const server = await ServerModel . loadByHost ( req . params . host ) if ( ! server ) { return res . status ( 0 ) . json ( { error : `template` } ) . end ( ) } res . locals . server = server return next ( ) } ] export { videoFileRedundancyGetValidator , videoPlaylistRedundancyGetValidator , updateServerRedundancyValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , param , query , ValidationChain } from 's' import { UserRight , VideoPlaylistCreate , VideoPlaylistUpdate } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isVideoImage } from 's' import { CONSTRAINTS_FIELDS } from 's' import { isArrayOf , isIdOrUUIDValid , isIdValid , isUUIDValid , toIntArray , toIntOrNull , toValueOrNull } from 's' import { isVideoPlaylistDescriptionValid , isVideoPlaylistNameValid , isVideoPlaylistPrivacyValid , isVideoPlaylistTimestampValid , isVideoPlaylistTypeValid } from 's' import { cleanUpReqFiles } from 's' import { VideoPlaylistElementModel } from 's' import { authenticatePromiseIfNeeded } from 's' import { VideoPlaylistPrivacy } from 's' import { VideoPlaylistType } from 's' import { doesVideoChannelIdExist , doesVideoExist , doesVideoPlaylistExist , VideoPlaylistFetchType } from 's' import { MVideoPlaylist } from 's' import { MUserAccountId } from 's' const videoPlaylistsAddValidator = getCommonPlaylistEditAttributes ( ) . concat ( [ body ( 's' ) . custom ( isVideoPlaylistNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) const body = req . body if ( body . videoChannelId && ! await doesVideoChannelIdExist ( body . videoChannelId , res ) ) return cleanUpReqFiles ( req ) if ( body . privacy === VideoPlaylistPrivacy . PUBLIC && ! body . videoChannelId ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } ] ) const videoPlaylistsUpdateValidator = getCommonPlaylistEditAttributes ( ) . concat ( [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoPlaylistNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res , 's' ) ) return cleanUpReqFiles ( req ) const videoPlaylist = getPlaylist ( res ) if ( ! checkUserCanManageVideoPlaylist ( res . locals . oauth . token . User , videoPlaylist , UserRight . REMOVE_ANY_VIDEO_PLAYLIST , res ) ) { return cleanUpReqFiles ( req ) } const body = req . body const newPrivacy = body . privacy || videoPlaylist . privacy if ( newPrivacy === VideoPlaylistPrivacy . PUBLIC && ( ( ! videoPlaylist . videoChannelId && ! body . videoChannelId ) || body . videoChannelId === null ) ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) } if ( videoPlaylist . type === VideoPlaylistType . WATCH_LATER ) { cleanUpReqFiles ( req ) return res . status ( 0 ) . json ( { error : 's' } ) } if ( body . videoChannelId && ! await doesVideoChannelIdExist ( body . videoChannelId , res ) ) return cleanUpReqFiles ( req ) return next ( ) } ] ) const videoPlaylistsDeleteValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res ) ) return const videoPlaylist = getPlaylist ( res ) if ( videoPlaylist . type === VideoPlaylistType . WATCH_LATER ) { return res . status ( 0 ) . json ( { error : 's' } ) } if ( ! checkUserCanManageVideoPlaylist ( res . locals . oauth . token . User , videoPlaylist , UserRight . REMOVE_ANY_VIDEO_PLAYLIST , res ) ) { return } return next ( ) } ] const videoPlaylistsGetValidator = ( fetchType ) => { return [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res , fetchType ) ) return const videoPlaylist = res . locals . videoPlaylistFull || res . locals . videoPlaylistSummary if ( videoPlaylist . privacy === VideoPlaylistPrivacy . UNLISTED ) { if ( isUUIDValid ( req . params . playlistId ) ) return next ( ) return res . status ( 0 ) . end ( ) } if ( videoPlaylist . privacy === VideoPlaylistPrivacy . PRIVATE ) { await authenticatePromiseIfNeeded ( req , res ) const user = res . locals . oauth ? res . locals . oauth . token . User : null if ( ! user || ( videoPlaylist . OwnerAccount . id !== user . Account . id && ! user . hasRight ( UserRight . UPDATE_ANY_VIDEO_PLAYLIST ) ) ) { return res . status ( 0 ) . json ( { error : 's' } ) } return next ( ) } return next ( ) } ] } const videoPlaylistsAddVideoValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoPlaylistTimestampValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoPlaylistTimestampValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res , 's' ) ) return if ( ! await doesVideoExist ( req . body . videoId , res , 's' ) ) return const videoPlaylist = getPlaylist ( res ) const video = res . locals . onlyVideo const videoPlaylistElement = await VideoPlaylistElementModel . loadByPlaylistAndVideo ( videoPlaylist . id , video . id ) if ( videoPlaylistElement ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return } if ( ! checkUserCanManageVideoPlaylist ( res . locals . oauth . token . User , videoPlaylist , UserRight . UPDATE_ANY_VIDEO_PLAYLIST , res ) ) { return } return next ( ) } ] const videoPlaylistsUpdateOrRemoveVideoValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoPlaylistTimestampValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isVideoPlaylistTimestampValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res , 's' ) ) return const videoPlaylist = getPlaylist ( res ) const videoPlaylistElement = await VideoPlaylistElementModel . loadById ( req . params . playlistElementId ) if ( ! videoPlaylistElement ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return } res . locals . videoPlaylistElement = videoPlaylistElement if ( ! checkUserCanManageVideoPlaylist ( res . locals . oauth . token . User , videoPlaylist , UserRight . UPDATE_ANY_VIDEO_PLAYLIST , res ) ) return return next ( ) } ] const videoPlaylistElementAPGetValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const videoPlaylistElement = await VideoPlaylistElementModel . loadByPlaylistAndVideoForAP ( req . params . playlistId , req . params . videoId ) if ( ! videoPlaylistElement ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return } if ( videoPlaylistElement . VideoPlaylist . privacy === VideoPlaylistPrivacy . PRIVATE ) { return res . status ( 0 ) . end ( ) } res . locals . videoPlaylistElementAP = videoPlaylistElement return next ( ) } ] const videoPlaylistsReorderVideosValidator = [ param ( 's' ) . custom ( isIdOrUUIDValid ) . withMessage ( 's' ) , body ( 's' ) . isInt ( { min : 0 } ) . withMessage ( 's' ) , body ( 's' ) . isInt ( { min : 0 } ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . isInt ( { min : 0 } ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return if ( ! await doesVideoPlaylistExist ( req . params . playlistId , res , 's' ) ) return const videoPlaylist = getPlaylist ( res ) if ( ! checkUserCanManageVideoPlaylist ( res . locals . oauth . token . User , videoPlaylist , UserRight . UPDATE_ANY_VIDEO_PLAYLIST , res ) ) return const nextPosition = await VideoPlaylistElementModel . getNextPositionOf ( videoPlaylist . id ) const startPosition = req . body . startPosition const insertAfterPosition = req . body . insertAfterPosition const reorderLength = req . body . reorderLength if ( startPosition >= nextPosition || insertAfterPosition >= nextPosition ) { res . status ( 0 ) . json ( { error : `template` } ) . end ( ) return } if ( reorderLength && reorderLength + startPosition > nextPosition ) { res . status ( 0 ) . json ( { error : `template` } ) . end ( ) return } return next ( ) } ] const commonVideoPlaylistFiltersValidator = [ query ( 's' ) . optional ( ) . custom ( isVideoPlaylistTypeValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const doVideosInPlaylistExistValidator = [ query ( 's' ) . customSanitizer ( toIntArray ) . custom ( v => isArrayOf ( v , isIdValid ) ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { videoPlaylistsAddValidator , videoPlaylistsUpdateValidator , videoPlaylistsDeleteValidator , videoPlaylistsGetValidator , videoPlaylistsAddVideoValidator , videoPlaylistsUpdateOrRemoveVideoValidator , videoPlaylistsReorderVideosValidator , videoPlaylistElementAPGetValidator , commonVideoPlaylistFiltersValidator , doVideosInPlaylistExistValidator } function getCommonPlaylistEditAttributes ( ) { return [ body ( 's' ) . custom ( ( value , { req } ) => isVideoImage ( req . files , 's' ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . VIDEO_PLAYLISTS . IMAGE . EXTNAME . join ( 's' ) ) , body ( 's' ) . optional ( ) . customSanitizer ( toValueOrNull ) . custom ( isVideoPlaylistDescriptionValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) . custom ( isVideoPlaylistPrivacyValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . customSanitizer ( toIntOrNull ) ] as ( ValidationChain | express . Handler ) [ ] } function checkUserCanManageVideoPlaylist ( user , videoPlaylist , right , res : express . Response ) { if ( videoPlaylist . isOwned ( ) === false ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } if ( user . hasRight ( right ) === false && videoPlaylist . ownerAccountId !== user . Account . id ) { res . status ( 0 ) . json ( { error : 's' } ) . end ( ) return false } return true } function getPlaylist ( res : express . Response ) { return res . locals . videoPlaylistFull || res . locals . videoPlaylistSummary }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistFetchType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O $number$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserAccountId$ O $MVideoPlaylist$ O $UserRight$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { VideoPrivacy , VideoRateType } from 's' import { activityPubCollectionPagination , activityPubContextify } from 's' import { ROUTE_CACHE_LIFETIME , WEBSERVER } from 's' import { buildAnnounceWithVideoAudience , buildLikeActivity } from 's' import { audiencify , getAudience } from 's' import { buildCreateActivity } from 's' import { asyncMiddleware , executeIfActivityPub , localAccountValidator , localVideoChannelValidator , videosCustomGetValidator , videosShareValidator } from 's' import { getAccountVideoRateValidator , videoCommentGetValidator } from 's' import { AccountModel } from 's' import { ActorFollowModel } from 's' import { VideoModel } from 's' import { VideoCommentModel } from 's' import { VideoShareModel } from 's' import { cacheRoute } from 's' import { activityPubResponse } from 's' import { AccountVideoRateModel } from 's' import { getRateUrl , getVideoCommentsActivityPubUrl , getVideoDislikesActivityPubUrl , getVideoLikesActivityPubUrl , getVideoSharesActivityPubUrl } from 's' import { VideoCaptionModel } from 's' import { videoFileRedundancyGetValidator , videoPlaylistRedundancyGetValidator } from 's' import { getServerActor } from 's' import { buildDislikeActivity } from 's' import { videoPlaylistElementAPGetValidator , videoPlaylistsGetValidator } from 's' import { VideoPlaylistModel } from 's' import { VideoPlaylistPrivacy } from 's' import { MAccountId , MActorId , MVideo , MVideoAPWithoutCaption } from 's' const activityPubClientRouter = express . Router ( ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localAccountValidator ) , accountController ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localAccountValidator ) , asyncMiddleware ( accountFollowersController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localAccountValidator ) , asyncMiddleware ( accountFollowingController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localAccountValidator ) , asyncMiddleware ( accountPlaylistsController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( getAccountVideoRateValidator ( 's' ) ) , getAccountVideoRate ( 's' ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( getAccountVideoRateValidator ( 's' ) ) , getAccountVideoRate ( 's' ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . ACTIVITY_PUB . VIDEOS ) ) , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoAnnouncesController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosShareValidator ) , asyncMiddleware ( videoAnnounceController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoLikesController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoDislikesController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( videoCommentsController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoCommentGetValidator ) , asyncMiddleware ( videoCommentController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoCommentGetValidator ) , asyncMiddleware ( videoCommentController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localVideoChannelValidator ) , asyncMiddleware ( videoChannelController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localVideoChannelValidator ) , asyncMiddleware ( videoChannelFollowersController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( localVideoChannelValidator ) , asyncMiddleware ( videoChannelFollowingController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoFileRedundancyGetValidator ) , asyncMiddleware ( videoRedundancyController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoPlaylistRedundancyGetValidator ) , asyncMiddleware ( videoRedundancyController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoPlaylistsGetValidator ( 's' ) ) , asyncMiddleware ( videoPlaylistController ) ) activityPubClientRouter . get ( 's' , executeIfActivityPub , asyncMiddleware ( videoPlaylistElementAPGetValidator ) , asyncMiddleware ( videoPlaylistElementController ) ) export { activityPubClientRouter } function accountController ( req : express . Request , res : express . Response ) { const account = res . locals . account return activityPubResponse ( activityPubContextify ( account . toActivityPubObject ( ) ) , res ) } async function accountFollowersController ( req : express . Request , res : express . Response ) { const account = res . locals . account const activityPubResult = await actorFollowers ( req , account . Actor ) return activityPubResponse ( activityPubContextify ( activityPubResult ) , res ) } async function accountFollowingController ( req : express . Request , res : express . Response ) { const account = res . locals . account const activityPubResult = await actorFollowing ( req , account . Actor ) return activityPubResponse ( activityPubContextify ( activityPubResult ) , res ) } async function accountPlaylistsController ( req : express . Request , res : express . Response ) { const account = res . locals . account const activityPubResult = await actorPlaylists ( req , account ) return activityPubResponse ( activityPubContextify ( activityPubResult ) , res ) } function getAccountVideoRate ( rateType ) { return ( req : express . Request , res : express . Response ) => { const accountVideoRate = res . locals . accountVideoRate const byActor = accountVideoRate . Account . Actor const url = getRateUrl ( rateType , byActor , accountVideoRate . Video ) const APObject = rateType === 's' ? buildLikeActivity ( url , byActor , accountVideoRate . Video ) : buildDislikeActivity ( url , byActor , accountVideoRate . Video ) return activityPubResponse ( activityPubContextify ( APObject ) , res ) } } async function videoController ( req : express . Request , res : express . Response ) { const video = await VideoModel . loadForGetAPI ( { id : res . locals . onlyVideoWithRights . id } ) as MVideoAPWithoutCaption if ( video . url . startsWith ( WEBSERVER . URL ) === false ) return res . redirect ( video . url ) const captions = await VideoCaptionModel . listVideoCaptions ( video . id ) const videoWithCaptions = Object . assign ( video , { VideoCaptions : captions } ) const audience = getAudience ( videoWithCaptions . VideoChannel . Account . Actor , videoWithCaptions . privacy === VideoPrivacy . PUBLIC ) const videoObject = audiencify ( videoWithCaptions . toActivityPubObject ( ) , audience ) if ( req . path . endsWith ( 's' ) ) { const data = buildCreateActivity ( videoWithCaptions . url , video . VideoChannel . Account . Actor , videoObject , audience ) return activityPubResponse ( activityPubContextify ( data ) , res ) } return activityPubResponse ( activityPubContextify ( videoObject ) , res ) } async function videoAnnounceController ( req : express . Request , res : express . Response ) { const share = res . locals . videoShare if ( share . url . startsWith ( WEBSERVER . URL ) === false ) return res . redirect ( share . url ) const { activity } = await buildAnnounceWithVideoAudience ( share . Actor , share , res . locals . videoAll , undefined ) return activityPubResponse ( activityPubContextify ( activity ) , res ) } async function videoAnnouncesController ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const handler = async ( start , count ) => { const result = await VideoShareModel . listAndCountByVideoId ( video . id , start , count ) return { total : result . count , data : result . rows . map ( r => r . url ) } } const json = await activityPubCollectionPagination ( getVideoSharesActivityPubUrl ( video ) , handler , req . query . page ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function videoLikesController ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const json = await videoRates ( req , 's' , video , getVideoLikesActivityPubUrl ( video ) ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function videoDislikesController ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const json = await videoRates ( req , 's' , video , getVideoDislikesActivityPubUrl ( video ) ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function videoCommentsController ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const handler = async ( start , count ) => { const result = await VideoCommentModel . listAndCountByVideoId ( video . id , start , count ) return { total : result . count , data : result . rows . map ( r => r . url ) } } const json = await activityPubCollectionPagination ( getVideoCommentsActivityPubUrl ( video ) , handler , req . query . page ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function videoChannelController ( req : express . Request , res : express . Response ) { const videoChannel = res . locals . videoChannel return activityPubResponse ( activityPubContextify ( videoChannel . toActivityPubObject ( ) ) , res ) } async function videoChannelFollowersController ( req : express . Request , res : express . Response ) { const videoChannel = res . locals . videoChannel const activityPubResult = await actorFollowers ( req , videoChannel . Actor ) return activityPubResponse ( activityPubContextify ( activityPubResult ) , res ) } async function videoChannelFollowingController ( req : express . Request , res : express . Response ) { const videoChannel = res . locals . videoChannel const activityPubResult = await actorFollowing ( req , videoChannel . Actor ) return activityPubResponse ( activityPubContextify ( activityPubResult ) , res ) } async function videoCommentController ( req : express . Request , res : express . Response ) { const videoComment = res . locals . videoCommentFull if ( videoComment . url . startsWith ( WEBSERVER . URL ) === false ) return res . redirect ( videoComment . url ) const threadParentComments = await VideoCommentModel . listThreadParentComments ( videoComment , undefined ) const isPublic = true const audience = getAudience ( videoComment . Account . Actor , isPublic ) const videoCommentObject = audiencify ( videoComment . toActivityPubObject ( threadParentComments ) , audience ) if ( req . path . endsWith ( 's' ) ) { const data = buildCreateActivity ( videoComment . url , videoComment . Account . Actor , videoCommentObject , audience ) return activityPubResponse ( activityPubContextify ( data ) , res ) } return activityPubResponse ( activityPubContextify ( videoCommentObject ) , res ) } async function videoRedundancyController ( req : express . Request , res : express . Response ) { const videoRedundancy = res . locals . videoRedundancy if ( videoRedundancy . url . startsWith ( WEBSERVER . URL ) === false ) return res . redirect ( videoRedundancy . url ) const serverActor = await getServerActor ( ) const audience = getAudience ( serverActor ) const object = audiencify ( videoRedundancy . toActivityPubObject ( ) , audience ) if ( req . path . endsWith ( 's' ) ) { const data = buildCreateActivity ( videoRedundancy . url , serverActor , object , audience ) return activityPubResponse ( activityPubContextify ( data ) , res ) } return activityPubResponse ( activityPubContextify ( object ) , res ) } async function videoPlaylistController ( req : express . Request , res : express . Response ) { const playlist = res . locals . videoPlaylistFull playlist . OwnerAccount = await AccountModel . load ( playlist . ownerAccountId ) const json = await playlist . toActivityPubObject ( req . query . page , null ) const audience = getAudience ( playlist . OwnerAccount . Actor , playlist . privacy === VideoPlaylistPrivacy . PUBLIC ) const object = audiencify ( json , audience ) return activityPubResponse ( activityPubContextify ( object ) , res ) } async function videoPlaylistElementController ( req : express . Request , res : express . Response ) { const videoPlaylistElement = res . locals . videoPlaylistElementAP const json = videoPlaylistElement . toActivityPubObject ( ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function actorFollowing ( req : express . Request , actor ) { const handler = ( start , count ) => { return ActorFollowModel . listAcceptedFollowingUrlsForApi ( [ actor . id ] , undefined , start , count ) } return activityPubCollectionPagination ( WEBSERVER . URL + req . path , handler , req . query . page ) } async function actorFollowers ( req : express . Request , actor ) { const handler = ( start , count ) => { return ActorFollowModel . listAcceptedFollowerUrlsForAP ( [ actor . id ] , undefined , start , count ) } return activityPubCollectionPagination ( WEBSERVER . URL + req . path , handler , req . query . page ) } async function actorPlaylists ( req : express . Request , account ) { const handler = ( start , count ) => { return VideoPlaylistModel . listPublicUrlsOfForAP ( account . id , start , count ) } return activityPubCollectionPagination ( WEBSERVER . URL + req . path , handler , req . query . page ) } function videoRates ( req : express . Request , rateType , video , url ) { const handler = async ( start , count ) => { const result = await AccountVideoRateModel . listAndCountAccountUrlsByVideoId ( rateType , video . id , start , count ) return { total : result . count , data : result . rows . map ( r => r . url ) } } return activityPubCollectionPagination ( url , handler , req . query . page ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorId$ O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorId$ O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountId$ O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRateType$ O $MVideo$ O $string$ O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { Activity , ActivityPubCollection , ActivityPubOrderedCollection , RootActivity } from 's' import { isActivityValid } from 's' import { logger } from 's' import { processActivities } from 's' import { asyncMiddleware , checkSignature , localAccountValidator , localVideoChannelValidator , signatureValidator } from 's' import { activityPubValidator } from 's' import { queue } from 's' import { ActorModel } from 's' import { MActorDefault , MActorSignature } from 's' const inboxRouter = express . Router ( ) inboxRouter . post ( 's' , signatureValidator , asyncMiddleware ( checkSignature ) , asyncMiddleware ( activityPubValidator ) , inboxController ) inboxRouter . post ( 's' , signatureValidator , asyncMiddleware ( checkSignature ) , asyncMiddleware ( localAccountValidator ) , asyncMiddleware ( activityPubValidator ) , inboxController ) inboxRouter . post ( 's' , signatureValidator , asyncMiddleware ( checkSignature ) , asyncMiddleware ( localVideoChannelValidator ) , asyncMiddleware ( activityPubValidator ) , inboxController ) export { inboxRouter } type QueueParam = { activities : Activity [ ] , signatureActor ? : MActorSignature , inboxActor ? : MActorDefault } const inboxQueue = queue < QueueParam , Error > ( ( task , cb ) => { const options = { signatureActor : task . signatureActor , inboxActor : task . inboxActor } processActivities ( task . activities , options ) . then ( ( ) => cb ( ) ) } ) function inboxController ( req : express . Request , res : express . Response ) { const rootActivity = req . body let activities : Activity [ ] = [ ] if ( [ 's' , 's' ] . indexOf ( rootActivity . type ) !== - 0 ) { activities = ( rootActivity as ActivityPubCollection ) . items } else if ( [ 's' , 's' ] . indexOf ( rootActivity . type ) !== - 0 ) { activities = ( rootActivity as ActivityPubOrderedCollection < Activity > ) . orderedItems } else { activities = [ rootActivity as Activity ] } logger . debug ( 's' , activities . length ) activities = activities . filter ( a => isActivityValid ( a ) ) logger . debug ( 's' , activities . length , { activities } ) const accountOrChannel = res . locals . account || res . locals . videoChannel logger . info ( 's' , activities . length , res . locals . signature . actor . url ) inboxQueue . push ( { activities , signatureActor : res . locals . signature . actor , inboxActor : accountOrChannel ? accountOrChannel . Actor : undefined } ) return res . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootActivity$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { Activity } from 's' import { VideoPrivacy } from 's' import { activityPubCollectionPagination , activityPubContextify } from 's' import { logger } from 's' import { buildAnnounceActivity , buildCreateActivity } from 's' import { buildAudience } from 's' import { asyncMiddleware , localAccountValidator , localVideoChannelValidator } from 's' import { VideoModel } from 's' import { activityPubResponse } from 's' import { MActorLight } from 's' const outboxRouter = express . Router ( ) outboxRouter . get ( 's' , localAccountValidator , asyncMiddleware ( outboxController ) ) outboxRouter . get ( 's' , localVideoChannelValidator , asyncMiddleware ( outboxController ) ) export { outboxRouter } async function outboxController ( req : express . Request , res : express . Response ) { const accountOrVideoChannel = res . locals . account || res . locals . videoChannel const actor = accountOrVideoChannel . Actor const actorOutboxUrl = actor . url + 's' logger . info ( 's' , actorOutboxUrl ) const handler = ( start , count ) => buildActivities ( actor , start , count ) const json = await activityPubCollectionPagination ( actorOutboxUrl , handler , req . query . page ) return activityPubResponse ( activityPubContextify ( json ) , res ) } async function buildActivities ( actor , start , count ) { const data = await VideoModel . listAllAndSharedByActorForOutbox ( actor . id , start , count ) const activities : Activity [ ] = [ ] for ( const video of data . data ) { const byActor = video . VideoChannel . Account . Actor const createActivityAudience = buildAudience ( [ byActor . followersUrl ] , video . privacy === VideoPrivacy . PUBLIC ) if ( video . VideoShares !== undefined && video . VideoShares . length !== 0 ) { const videoShare = video . VideoShares [ 0 ] const announceActivity = buildAnnounceActivity ( videoShare . url , actor , video . url , createActivityAudience ) activities . push ( announceActivity ) } else { const videoObject = video . toActivityPubObject ( ) const createActivity = buildCreateActivity ( video . url , byActor , videoObject , createActivityAudience ) activities . push ( createActivity ) } } return { data : activities , total : data . total } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActorLight$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { activityPubClientRouter } from 's' import { inboxRouter } from 's' import { outboxRouter } from 's' const activityPubRouter = express . Router ( ) activityPubRouter . use ( 's' , inboxRouter ) activityPubRouter . use ( 's' , outboxRouter ) activityPubRouter . use ( 's' , activityPubClientRouter ) export { activityPubRouter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { getFormattedObjects , getServerActor } from 's' import { asyncMiddleware , authenticate , commonVideosFiltersValidator , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSort , videoPlaylistsSortValidator , videoRatesSortValidator , videoRatingValidator } from 's' import { accountNameWithHostGetValidator , accountsSortValidator , ensureAuthUserOwnsAccountValidator , videosSortValidator , videoChannelsSortValidator } from 's' import { AccountModel } from 's' import { AccountVideoRateModel } from 's' import { VideoModel } from 's' import { buildNSFWFilter , isUserAbleToSearchRemoteURI } from 's' import { VideoChannelModel } from 's' import { JobQueue } from 's' import { logger } from 's' import { VideoPlaylistModel } from 's' import { commonVideoPlaylistFiltersValidator } from 's' const accountsRouter = express . Router ( ) accountsRouter . get ( 's' , paginationValidator , accountsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listAccounts ) ) accountsRouter . get ( 's' , asyncMiddleware ( accountNameWithHostGetValidator ) , getAccount ) accountsRouter . get ( 's' , asyncMiddleware ( accountNameWithHostGetValidator ) , paginationValidator , videosSortValidator , setDefaultSort , setDefaultPagination , optionalAuthenticate , commonVideosFiltersValidator , asyncMiddleware ( listAccountVideos ) ) accountsRouter . get ( 's' , asyncMiddleware ( accountNameWithHostGetValidator ) , paginationValidator , videoChannelsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listAccountChannels ) ) accountsRouter . get ( 's' , optionalAuthenticate , asyncMiddleware ( accountNameWithHostGetValidator ) , paginationValidator , videoPlaylistsSortValidator , setDefaultSort , setDefaultPagination , commonVideoPlaylistFiltersValidator , asyncMiddleware ( listAccountPlaylists ) ) accountsRouter . get ( 's' , authenticate , asyncMiddleware ( accountNameWithHostGetValidator ) , ensureAuthUserOwnsAccountValidator , paginationValidator , videoRatesSortValidator , setDefaultSort , setDefaultPagination , videoRatingValidator , asyncMiddleware ( listAccountRatings ) ) export { accountsRouter } function getAccount ( req : express . Request , res : express . Response ) { const account = res . locals . account if ( account . isOutdated ( ) ) { JobQueue . Instance . createJob ( { type : 's' , payload : { type : 's' , url : account . Actor . url } } ) . catch ( err => logger . error ( 's' , account . Actor . url , { err } ) ) } return res . json ( account . toFormattedJSON ( ) ) } async function listAccounts ( req : express . Request , res : express . Response ) { const resultList = await AccountModel . listForApi ( req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listAccountChannels ( req : express . Request , res : express . Response ) { const options = { accountId : res . locals . account . id , start : req . query . start , count : req . query . count , sort : req . query . sort } const resultList = await VideoChannelModel . listByAccount ( options ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listAccountPlaylists ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) let privateAndUnlisted = false if ( res . locals . oauth && res . locals . oauth . token . User . Account . id === res . locals . account . id ) { privateAndUnlisted = true } const resultList = await VideoPlaylistModel . listForApi ( { followerActorId : serverActor . id , start : req . query . start , count : req . query . count , sort : req . query . sort , accountId : res . locals . account . id , privateAndUnlisted , type : req . query . playlistType } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listAccountVideos ( req : express . Request , res : express . Response ) { const account = res . locals . account const followerActorId = isUserAbleToSearchRemoteURI ( res ) ? null : undefined const resultList = await VideoModel . listForApi ( { followerActorId , start : req . query . start , count : req . query . count , sort : req . query . sort , includeLocalVideos : true , categoryOneOf : req . query . categoryOneOf , licenceOneOf : req . query . licenceOneOf , languageOneOf : req . query . languageOneOf , tagsOneOf : req . query . tagsOneOf , tagsAllOf : req . query . tagsAllOf , filter : req . query . filter , nsfw : buildNSFWFilter ( res , req . query . nsfw ) , withFiles : false , accountId : account . id , user : res . locals . oauth ? res . locals . oauth . token . User : undefined } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listAccountRatings ( req : express . Request , res : express . Response ) { const account = res . locals . account const resultList = await AccountVideoRateModel . listByAccountForApi ( { accountId : account . id , start : req . query . start , count : req . query . count , sort : req . query . sort , type : req . query . rating } ) return res . json ( getFormattedObjects ( resultList . rows , resultList . count ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body } from 's' import { isUserNSFWPolicyValid , isUserVideoQuotaDailyValid , isUserVideoQuotaValid } from 's' import { logger } from 's' import { CustomConfig } from 's' import { Emailer } from 's' import { areValidationErrors } from 's' import { isThemeNameValid } from 's' import { isThemeRegistered } from 's' const customConfigUpdateValidator = [ body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNSFWPolicyValid ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . exists ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isInt ( ) . withMessage ( 's' ) , body ( 's' ) . isInt ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isInt ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isEmail ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserVideoQuotaValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserVideoQuotaDailyValid ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isInt ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . isBoolean ( ) . withMessage ( 's' ) , body ( 's' ) . custom ( v => isThemeNameValid ( v ) && isThemeRegistered ( v ) ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return if ( ! checkInvalidConfigIfEmailDisabled ( req . body as CustomConfig , res ) ) return return next ( ) } ] export { customConfigUpdateValidator } function checkInvalidConfigIfEmailDisabled ( customConfig , res : express . Response ) { if ( Emailer . isEnabled ( ) ) return true if ( customConfig . signup . requiresEmailVerification === true ) { res . status ( 0 ) . send ( { error : 's' } ) . end ( ) return false } return true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import * as express from 's' import { diff } from 's' import { chain } from 's' import * as flatten from 's' import * as winston from 's' import { jsonLoggerFormat , labelFormatter } from 's' import { User , VideoAbuse , VideoChannel , VideoDetails , VideoImport } from 's' import { VideoComment } from 's' import { CustomConfig } from 's' import { CONFIG } from 's' function getAuditIdFromRes ( res : express . Response ) { return res . locals . oauth . token . User . username } enum AUDIT_TYPE { CREATE = 's' , UPDATE = 's' , DELETE = 's' } const colors = winston . config . npm . colors colors . audit = winston . config . npm . colors . info winston . addColors ( colors ) const auditLogger = winston . createLogger ( { levels : { audit : 0 } , transports : [ new winston . transports . File ( { filename : path . join ( CONFIG . STORAGE . LOG_DIR , 's' ) , level : 's' , maxsize : 0 , maxFiles : 0 , format : winston . format . combine ( winston . format . timestamp ( ) , labelFormatter , winston . format . splat ( ) , jsonLoggerFormat ) } ) ] , exitOnError : true } ) function auditLoggerWrapper ( domain , user , action , entity , oldEntity = null ) { let entityInfos if ( action === AUDIT_TYPE . UPDATE && oldEntity ) { const oldEntityKeys = oldEntity . toLogKeys ( ) const diffObject = diff ( oldEntityKeys , entity . toLogKeys ( ) ) const diffKeys = Object . entries ( diffObject ) . reduce ( ( newKeys , entry ) => { newKeys [ `template` ] = entry [ 0 ] return newKeys } , { } ) entityInfos = { ... oldEntityKeys , ... diffKeys } } else { entityInfos = { ... entity . toLogKeys ( ) } } auditLogger . log ( 's' , JSON . stringify ( { user , domain , action , ... entityInfos } ) ) } function auditLoggerFactory ( domain ) { return { create ( user , entity ) { auditLoggerWrapper ( domain , user , AUDIT_TYPE . CREATE , entity ) } , update ( user , entity , oldEntity ) { auditLoggerWrapper ( domain , user , AUDIT_TYPE . UPDATE , entity , oldEntity ) } , delete ( user , entity ) { auditLoggerWrapper ( domain , user , AUDIT_TYPE . DELETE , entity ) } } } abstract class EntityAuditView { constructor ( private keysToKeep < string > , private prefix , private entityInfos ) { } toLogKeys ( ) { return chain ( flatten ( this . entityInfos , { delimiter : 's' , safe : true } ) ) . pick ( this . keysToKeep ) . mapKeys ( ( value , key ) => `template` ) . value ( ) } } const videoKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class VideoAuditView extends EntityAuditView { constructor ( private video ) { super ( videoKeysToKeep , 's' , video ) } } const videoImportKeysToKeep = [ 's' , 's' , 's' ] class VideoImportAuditView extends EntityAuditView { constructor ( private videoImport ) { super ( videoImportKeysToKeep , 's' , videoImport ) } } const commentKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class CommentAuditView extends EntityAuditView { constructor ( private comment ) { super ( commentKeysToKeep , 's' , comment ) } } const userKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class UserAuditView extends EntityAuditView { constructor ( private user ) { super ( userKeysToKeep , 's' , user ) } } const channelKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class VideoChannelAuditView extends EntityAuditView { constructor ( private channel ) { super ( channelKeysToKeep , 's' , channel ) } } const videoAbuseKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class VideoAbuseAuditView extends EntityAuditView { constructor ( private videoAbuse ) { super ( videoAbuseKeysToKeep , 's' , videoAbuse ) } } const customConfigKeysToKeep = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] class CustomConfigAuditView extends EntityAuditView { constructor ( customConfig ) { const infos = customConfig const resolutionsDict = infos . transcoding . resolutions const resolutionsArray = [ ] Object . entries ( resolutionsDict ) . forEach ( ( [ resolution , isEnabled ] ) => { if ( isEnabled ) resolutionsArray . push ( resolution ) } ) Object . assign ( { } , infos , { transcoding : { resolutions : resolutionsArray } } ) super ( customConfigKeysToKeep , 's' , infos ) } } export { getAuditIdFromRes , auditLoggerFactory , VideoImportAuditView , VideoChannelAuditView , CommentAuditView , UserAuditView , VideoAuditView , VideoAbuseAuditView , CustomConfigAuditView }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $AUDIT_TYPE$ O $EntityAuditView$ O $EntityAuditView$ O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O $EntityAuditView$ O O O O O O O O O O O O O O O O O O $string$ O $EntityAuditView$ O $EntityAuditView$ O O O O O O O O O O O O O O O O O O O O $string$ O $EntityAuditView$ O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O $string$ O O $object$ O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { snakeCase } from 's' import { ServerConfig , UserRight } from 's' import { About } from 's' import { CustomConfig } from 's' import { isSignupAllowed , isSignupAllowedForCurrentIP } from 's' import { CONSTRAINTS_FIELDS , DEFAULT_THEME_NAME , PEERTUBE_VERSION } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight } from 's' import { customConfigUpdateValidator } from 's' import { ClientHtml } from 's' import { auditLoggerFactory , CustomConfigAuditView , getAuditIdFromRes } from 's' import { remove , writeJSON } from 's' import { getServerCommit } from 's' import { Emailer } from 's' import { isNumeric } from 's' import { objectConverter } from 's' import { CONFIG , reloadConfig } from 's' import { PluginManager } from 's' import { getThemeOrDefault } from 's' const configRouter = express . Router ( ) const auditLogger = auditLoggerFactory ( 's' ) configRouter . get ( 's' , getAbout ) configRouter . get ( 's' , asyncMiddleware ( getConfig ) ) configRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_CONFIGURATION ) , asyncMiddleware ( getCustomConfig ) ) configRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_CONFIGURATION ) , asyncMiddleware ( customConfigUpdateValidator ) , asyncMiddleware ( updateCustomConfig ) ) configRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_CONFIGURATION ) , asyncMiddleware ( deleteCustomConfig ) ) let serverCommit async function getConfig ( req : express . Request , res : express . Response ) { const allowed = await isSignupAllowed ( ) const allowedForCurrentIP = isSignupAllowedForCurrentIP ( req . ip ) const defaultTheme = getThemeOrDefault ( CONFIG . THEME . DEFAULT , DEFAULT_THEME_NAME ) if ( serverCommit === undefined ) serverCommit = await getServerCommit ( ) const json = { instance : { name : CONFIG . INSTANCE . NAME , shortDescription : CONFIG . INSTANCE . SHORT_DESCRIPTION , defaultClientRoute : CONFIG . INSTANCE . DEFAULT_CLIENT_ROUTE , isNSFW : CONFIG . INSTANCE . IS_NSFW , defaultNSFWPolicy : CONFIG . INSTANCE . DEFAULT_NSFW_POLICY , customizations : { javascript : CONFIG . INSTANCE . CUSTOMIZATIONS . JAVASCRIPT , css : CONFIG . INSTANCE . CUSTOMIZATIONS . CSS } } , plugin : { registered : getRegisteredPlugins ( ) } , theme : { registered : getRegisteredThemes ( ) , default : defaultTheme } , email : { enabled : Emailer . isEnabled ( ) } , contactForm : { enabled : CONFIG . CONTACT_FORM . ENABLED } , serverVersion : PEERTUBE_VERSION , serverCommit , signup : { allowed , allowedForCurrentIP , requiresEmailVerification : CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION } , transcoding : { hls : { enabled : CONFIG . TRANSCODING . HLS . ENABLED } , enabledResolutions : getEnabledResolutions ( ) } , import : { videos : { http : { enabled : CONFIG . IMPORT . VIDEOS . HTTP . ENABLED } , torrent : { enabled : CONFIG . IMPORT . VIDEOS . TORRENT . ENABLED } } } , autoBlacklist : { videos : { ofUsers : { enabled : CONFIG . AUTO_BLACKLIST . VIDEOS . OF_USERS . ENABLED } } } , avatar : { file : { size : { max : CONSTRAINTS_FIELDS . ACTORS . AVATAR . FILE_SIZE . max } , extensions : CONSTRAINTS_FIELDS . ACTORS . AVATAR . EXTNAME } } , video : { image : { extensions : CONSTRAINTS_FIELDS . VIDEOS . IMAGE . EXTNAME , size : { max : CONSTRAINTS_FIELDS . VIDEOS . IMAGE . FILE_SIZE . max } } , file : { extensions : CONSTRAINTS_FIELDS . VIDEOS . EXTNAME } } , videoCaption : { file : { size : { max : CONSTRAINTS_FIELDS . VIDEO_CAPTIONS . CAPTION_FILE . FILE_SIZE . max } , extensions : CONSTRAINTS_FIELDS . VIDEO_CAPTIONS . CAPTION_FILE . EXTNAME } } , user : { videoQuota : CONFIG . USER . VIDEO_QUOTA , videoQuotaDaily : CONFIG . USER . VIDEO_QUOTA_DAILY } , trending : { videos : { intervalDays : CONFIG . TRENDING . VIDEOS . INTERVAL_DAYS } } , tracker : { enabled : CONFIG . TRACKER . ENABLED } } return res . json ( json ) } function getAbout ( req : express . Request , res : express . Response ) { const about = { instance : { name : CONFIG . INSTANCE . NAME , shortDescription : CONFIG . INSTANCE . SHORT_DESCRIPTION , description : CONFIG . INSTANCE . DESCRIPTION , terms : CONFIG . INSTANCE . TERMS , codeOfConduct : CONFIG . INSTANCE . CODE_OF_CONDUCT , hardwareInformation : CONFIG . INSTANCE . HARDWARE_INFORMATION , creationReason : CONFIG . INSTANCE . CREATION_REASON , moderationInformation : CONFIG . INSTANCE . MODERATION_INFORMATION , administrator : CONFIG . INSTANCE . ADMINISTRATOR , maintenanceLifetime : CONFIG . INSTANCE . MAINTENANCE_LIFETIME , businessModel : CONFIG . INSTANCE . BUSINESS_MODEL , languages : CONFIG . INSTANCE . LANGUAGES , categories : CONFIG . INSTANCE . CATEGORIES } } return res . json ( about ) . end ( ) } async function getCustomConfig ( req : express . Request , res : express . Response ) { const data = customConfig ( ) return res . json ( data ) . end ( ) } async function deleteCustomConfig ( req : express . Request , res : express . Response ) { await remove ( CONFIG . CUSTOM_FILE ) auditLogger . delete ( getAuditIdFromRes ( res ) , new CustomConfigAuditView ( customConfig ( ) ) ) reloadConfig ( ) ClientHtml . invalidCache ( ) const data = customConfig ( ) return res . json ( data ) . end ( ) } async function updateCustomConfig ( req : express . Request , res : express . Response ) { const oldCustomConfigAuditKeys = new CustomConfigAuditView ( customConfig ( ) ) const toUpdateJSON = convertCustomConfigBody ( req . body ) await writeJSON ( CONFIG . CUSTOM_FILE , toUpdateJSON , { spaces : 0 } ) reloadConfig ( ) ClientHtml . invalidCache ( ) const data = customConfig ( ) auditLogger . update ( getAuditIdFromRes ( res ) , new CustomConfigAuditView ( data ) , oldCustomConfigAuditKeys ) return res . json ( data ) . end ( ) } export { configRouter } function customConfig ( ) { return { instance : { name : CONFIG . INSTANCE . NAME , shortDescription : CONFIG . INSTANCE . SHORT_DESCRIPTION , description : CONFIG . INSTANCE . DESCRIPTION , terms : CONFIG . INSTANCE . TERMS , codeOfConduct : CONFIG . INSTANCE . CODE_OF_CONDUCT , creationReason : CONFIG . INSTANCE . CREATION_REASON , moderationInformation : CONFIG . INSTANCE . MODERATION_INFORMATION , administrator : CONFIG . INSTANCE . ADMINISTRATOR , maintenanceLifetime : CONFIG . INSTANCE . MAINTENANCE_LIFETIME , businessModel : CONFIG . INSTANCE . BUSINESS_MODEL , hardwareInformation : CONFIG . INSTANCE . HARDWARE_INFORMATION , languages : CONFIG . INSTANCE . LANGUAGES , categories : CONFIG . INSTANCE . CATEGORIES , isNSFW : CONFIG . INSTANCE . IS_NSFW , defaultClientRoute : CONFIG . INSTANCE . DEFAULT_CLIENT_ROUTE , defaultNSFWPolicy : CONFIG . INSTANCE . DEFAULT_NSFW_POLICY , customizations : { css : CONFIG . INSTANCE . CUSTOMIZATIONS . CSS , javascript : CONFIG . INSTANCE . CUSTOMIZATIONS . JAVASCRIPT } } , theme : { default : CONFIG . THEME . DEFAULT } , services : { twitter : { username : CONFIG . SERVICES . TWITTER . USERNAME , whitelisted : CONFIG . SERVICES . TWITTER . WHITELISTED } } , cache : { previews : { size : CONFIG . CACHE . PREVIEWS . SIZE } , captions : { size : CONFIG . CACHE . VIDEO_CAPTIONS . SIZE } } , signup : { enabled : CONFIG . SIGNUP . ENABLED , limit : CONFIG . SIGNUP . LIMIT , requiresEmailVerification : CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION } , admin : { email : CONFIG . ADMIN . EMAIL } , contactForm : { enabled : CONFIG . CONTACT_FORM . ENABLED } , user : { videoQuota : CONFIG . USER . VIDEO_QUOTA , videoQuotaDaily : CONFIG . USER . VIDEO_QUOTA_DAILY } , transcoding : { enabled : CONFIG . TRANSCODING . ENABLED , allowAdditionalExtensions : CONFIG . TRANSCODING . ALLOW_ADDITIONAL_EXTENSIONS , allowAudioFiles : CONFIG . TRANSCODING . ALLOW_AUDIO_FILES , threads : CONFIG . TRANSCODING . THREADS , resolutions : { 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] , 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] , 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] , 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] , 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] , 's' : CONFIG . TRANSCODING . RESOLUTIONS [ 's' ] } , hls : { enabled : CONFIG . TRANSCODING . HLS . ENABLED } } , import : { videos : { http : { enabled : CONFIG . IMPORT . VIDEOS . HTTP . ENABLED } , torrent : { enabled : CONFIG . IMPORT . VIDEOS . TORRENT . ENABLED } } } , autoBlacklist : { videos : { ofUsers : { enabled : CONFIG . AUTO_BLACKLIST . VIDEOS . OF_USERS . ENABLED } } } , followers : { instance : { enabled : CONFIG . FOLLOWERS . INSTANCE . ENABLED , manualApproval : CONFIG . FOLLOWERS . INSTANCE . MANUAL_APPROVAL } } , followings : { instance : { autoFollowBack : { enabled : CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_BACK . ENABLED } , autoFollowIndex : { enabled : CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_INDEX . ENABLED , indexUrl : CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_INDEX . INDEX_URL } } } } } function convertCustomConfigBody ( body ) { function keyConverter ( k ) { if ( "s" . exec ( k ) ) return k return snakeCase ( k ) } function valueConverter ( v ) { if ( isNumeric ( v + 's' ) ) return parseInt ( 's' + v , 0 ) return v } return objectConverter ( body , keyConverter , valueConverter ) } function getRegisteredThemes ( ) { return PluginManager . Instance . getRegisteredThemes ( ) . map ( t => ( { name : t . name , version : t . version , description : t . description , css : t . css , clientScripts : t . clientScripts } ) ) } function getEnabledResolutions ( ) { return Object . keys ( CONFIG . TRANSCODING . RESOLUTIONS ) . filter ( key => CONFIG . TRANSCODING . ENABLED && CONFIG . TRANSCODING . RESOLUTIONS [ key ] === true ) . map ( r => parseInt ( r , 0 ) ) } function getRegisteredPlugins ( ) { return PluginManager . Instance . getRegisteredPlugins ( ) . map ( p => ( { name : p . name , version : p . version , description : p . description , clientScripts : p . clientScripts } ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $About$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { JobState } from 's' import { exists } from 's' const jobStates : JobState [ ] = [ 's' , 's' , 's' , 's' , 's' ] function isValidJobState ( value ) { return exists ( value ) && jobStates . indexOf ( value ) !== - 0 } export { isValidJobState }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobState$ O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { param } from 's' import { isValidJobState } from 's' import { logger } from 's' import { areValidationErrors } from 's' const listJobsValidator = [ param ( 's' ) . custom ( isValidJobState ) . not ( ) . isEmpty ( ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { listJobsValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { ResultList } from 's' import { Job , JobType , JobState } from 's' import { UserRight } from 's' import { JobQueue } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight , jobsSortValidator , setDefaultPagination , setDefaultSort } from 's' import { paginationValidator } from 's' import { listJobsValidator } from 's' import { isArray } from 's' const jobsRouter = express . Router ( ) jobsRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_JOBS ) , paginationValidator , jobsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listJobsValidator ) , asyncMiddleware ( listJobs ) ) export { jobsRouter } async function listJobs ( req : express . Request , res : express . Response , next : express . NextFunction ) { const state = req . params . state const asc = req . query . sort === 's' const jobs = await JobQueue . Instance . listForApi ( state , req . query . start , req . query . count , asc ) const total = await JobQueue . Instance . count ( state ) const result < any > = { total , data : jobs . map ( j => formatJob ( j , state ) ) } return res . json ( result ) } function formatJob ( job , state ) { const error = isArray ( job . stacktrace ) && job . stacktrace . length !== 0 ? job . stacktrace [ 0 ] : null return { id : job . id , state : state , type : job . queue . name as JobType , data : job . data , error , createdAt : new Date ( job . timestamp ) , finishedOn : new Date ( job . finishedOn ) , processedOn : new Date ( job . processedOn ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $JobState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Job$ O $any$ O $JobState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { OAuthClientLocal } from 's' import { logger } from 's' import { CONFIG } from 's' import { asyncMiddleware } from 's' import { OAuthClientModel } from 's' const oauthClientsRouter = express . Router ( ) oauthClientsRouter . get ( 's' , asyncMiddleware ( getLocalClient ) ) async function getLocalClient ( req : express . Request , res : express . Response , next : express . NextFunction ) { const serverHostname = CONFIG . WEBSERVER . HOSTNAME const serverPort = CONFIG . WEBSERVER . PORT let headerHostShouldBe = serverHostname if ( serverPort !== 0 && serverPort !== 0 ) { headerHostShouldBe += 's' + serverPort } if ( process . env . NODE_ENV !== 's' && req . get ( 's' ) !== headerHostShouldBe ) { logger . info ( 's' , req . get ( 's' ) , headerHostShouldBe ) return res . type ( 's' ) . status ( 0 ) . end ( ) } const client = await OAuthClientModel . loadFirstClient ( ) if ( ! client ) throw new Error ( 's' ) const json = { client_id : client . clientId , client_secret : client . clientSecret } return res . json ( json ) } export { oauthClientsRouter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OAuthClientLocal$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoRedundancyModel } from 's' import { sendUndoCacheFile } from 's' import { Transaction } from 's' import { getServerActor } from 's' import { MVideoRedundancyVideo } from 's' async function removeVideoRedundancy ( videoRedundancy , t ? ) { const serverActor = await getServerActor ( ) if ( videoRedundancy . actorId === serverActor . id ) await sendUndoCacheFile ( serverActor , videoRedundancy , t ) await videoRedundancy . destroy ( { transaction : t } ) } async function removeRedundancyOf ( serverId ) { const videosRedundancy = await VideoRedundancyModel . listLocalOfServer ( serverId ) for ( const redundancy of videosRedundancy ) { await removeVideoRedundancy ( redundancy ) } } export { removeRedundancyOf , removeVideoRedundancy }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoRedundancyVideo$ O O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight } from 's' import { logger } from 's' import { getFormattedObjects , getServerActor } from 's' import { SERVER_ACTOR_NAME } from 's' import { sendAccept , sendReject , sendUndoFollow } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight , paginationValidator , setBodyHostsPort , setDefaultPagination , setDefaultSort } from 's' import { acceptOrRejectFollowerValidator , followersSortValidator , followingSortValidator , followValidator , getFollowerValidator , removeFollowingValidator } from 's' import { ActorFollowModel } from 's' import { JobQueue } from 's' import { removeRedundancyOf } from 's' import { sequelizeTypescript } from 's' import { autoFollowBackIfNeeded } from 's' const serverFollowsRouter = express . Router ( ) serverFollowsRouter . get ( 's' , paginationValidator , followingSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listFollowing ) ) serverFollowsRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , followValidator , setBodyHostsPort , asyncMiddleware ( followInstance ) ) serverFollowsRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , asyncMiddleware ( removeFollowingValidator ) , asyncMiddleware ( removeFollowing ) ) serverFollowsRouter . get ( 's' , paginationValidator , followersSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listFollowers ) ) serverFollowsRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , asyncMiddleware ( getFollowerValidator ) , asyncMiddleware ( removeOrRejectFollower ) ) serverFollowsRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , asyncMiddleware ( getFollowerValidator ) , acceptOrRejectFollowerValidator , asyncMiddleware ( removeOrRejectFollower ) ) serverFollowsRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , asyncMiddleware ( getFollowerValidator ) , acceptOrRejectFollowerValidator , asyncMiddleware ( acceptFollower ) ) export { serverFollowsRouter } async function listFollowing ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await ActorFollowModel . listFollowingForApi ( serverActor . id , req . query . start , req . query . count , req . query . sort , req . query . search ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listFollowers ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await ActorFollowModel . listFollowersForApi ( serverActor . id , req . query . start , req . query . count , req . query . sort , req . query . search ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function followInstance ( req : express . Request , res : express . Response ) { const hosts = req . body . hosts as string [ ] const follower = await getServerActor ( ) for ( const host of hosts ) { const payload = { host , name : SERVER_ACTOR_NAME , followerActorId : follower . id } JobQueue . Instance . createJob ( { type : 's' , payload } ) . catch ( err => logger . error ( 's' , host , err ) ) } return res . status ( 0 ) . end ( ) } async function removeFollowing ( req : express . Request , res : express . Response ) { const follow = res . locals . follow await sequelizeTypescript . transaction ( async t => { if ( follow . state === 's' ) await sendUndoFollow ( follow , t ) const server = follow . ActorFollowing . Server server . redundancyAllowed = false await server . save ( { transaction : t } ) removeRedundancyOf ( server . id ) . catch ( err => logger . error ( 's' , server . host , err ) ) await follow . destroy ( { transaction : t } ) } ) return res . status ( 0 ) . end ( ) } async function removeOrRejectFollower ( req : express . Request , res : express . Response ) { const follow = res . locals . follow await sendReject ( follow . ActorFollower , follow . ActorFollowing ) await follow . destroy ( ) return res . status ( 0 ) . end ( ) } async function acceptFollower ( req : express . Request , res : express . Response ) { const follow = res . locals . follow await sendAccept ( follow ) follow . state = 's' await follow . save ( ) await autoFollowBackIfNeeded ( follow ) return res . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { ServerStats } from 's' import { asyncMiddleware } from 's' import { UserModel } from 's' import { ActorFollowModel } from 's' import { VideoModel } from 's' import { VideoCommentModel } from 's' import { VideoRedundancyModel } from 's' import { ROUTE_CACHE_LIFETIME } from 's' import { cacheRoute } from 's' import { VideoFileModel } from 's' import { CONFIG } from 's' const statsRouter = express . Router ( ) statsRouter . get ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . STATS ) ) , asyncMiddleware ( getStats ) ) async function getStats ( req : express . Request , res : express . Response ) { const { totalLocalVideos , totalLocalVideoViews , totalVideos } = await VideoModel . getStats ( ) const { totalLocalVideoComments , totalVideoComments } = await VideoCommentModel . getStats ( ) const { totalUsers } = await UserModel . getStats ( ) const { totalInstanceFollowers , totalInstanceFollowing } = await ActorFollowModel . getStats ( ) const { totalLocalVideoFilesSize } = await VideoFileModel . getStats ( ) const videosRedundancyStats = await Promise . all ( CONFIG . REDUNDANCY . VIDEOS . STRATEGIES . map ( r => { return VideoRedundancyModel . getStats ( r . strategy ) . then ( stats => Object . assign ( stats , { strategy : r . strategy , totalSize : r . size } ) ) } ) ) const data = { totalLocalVideos , totalLocalVideoViews , totalLocalVideoFilesSize , totalLocalVideoComments , totalVideos , totalVideoComments , totalUsers , totalInstanceFollowers , totalInstanceFollowing , videosRedundancy : videosRedundancyStats } return res . json ( data ) . end ( ) } export { statsRouter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight } from 's' import { updateServerRedundancyValidator } from 's' import { removeRedundancyOf } from 's' import { logger } from 's' const serverRedundancyRouter = express . Router ( ) serverRedundancyRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVER_FOLLOW ) , asyncMiddleware ( updateServerRedundancyValidator ) , asyncMiddleware ( updateRedundancy ) ) export { serverRedundancyRouter } async function updateRedundancy ( req : express . Request , res : express . Response ) { const server = res . locals . server server . redundancyAllowed = req . body . redundancyAllowed await server . save ( ) removeRedundancyOf ( server . id ) . catch ( err => logger . error ( 's' , server . host , err ) ) return res . sendStatus ( 0 ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { sequelizeTypescript } from 's' import { AccountBlocklistModel } from 's' import { ServerBlocklistModel } from 's' import { MAccountBlocklist , MServerBlocklist } from 's' function addAccountInBlocklist ( byAccountId , targetAccountId ) { return sequelizeTypescript . transaction ( async t => { return AccountBlocklistModel . upsert ( { accountId : byAccountId , targetAccountId : targetAccountId } , { transaction : t } ) } ) } function addServerInBlocklist ( byAccountId , targetServerId ) { return sequelizeTypescript . transaction ( async t => { return ServerBlocklistModel . upsert ( { accountId : byAccountId , targetServerId } , { transaction : t } ) } ) } function removeAccountFromBlocklist ( accountBlock ) { return sequelizeTypescript . transaction ( async t => { return accountBlock . destroy ( { transaction : t } ) } ) } function removeServerFromBlocklist ( serverBlock ) { return sequelizeTypescript . transaction ( async t => { return serverBlock . destroy ( { transaction : t } ) } ) } export { addAccountInBlocklist , addServerInBlocklist , removeAccountFromBlocklist , removeServerFromBlocklist }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MAccountBlocklist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MServerBlocklist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import 's' import { getFormattedObjects , getServerActor } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , ensureUserHasRight , paginationValidator , setDefaultPagination , setDefaultSort } from 's' import { accountsBlocklistSortValidator , blockAccountValidator , blockServerValidator , serversBlocklistSortValidator , unblockAccountByServerValidator , unblockServerByServerValidator } from 's' import { AccountBlocklistModel } from 's' import { addAccountInBlocklist , addServerInBlocklist , removeAccountFromBlocklist , removeServerFromBlocklist } from 's' import { ServerBlocklistModel } from 's' import { UserRight } from 's' const serverBlocklistRouter = express . Router ( ) serverBlocklistRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_ACCOUNTS_BLOCKLIST ) , paginationValidator , accountsBlocklistSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listBlockedAccounts ) ) serverBlocklistRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_ACCOUNTS_BLOCKLIST ) , asyncMiddleware ( blockAccountValidator ) , asyncRetryTransactionMiddleware ( blockAccount ) ) serverBlocklistRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_ACCOUNTS_BLOCKLIST ) , asyncMiddleware ( unblockAccountByServerValidator ) , asyncRetryTransactionMiddleware ( unblockAccount ) ) serverBlocklistRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVERS_BLOCKLIST ) , paginationValidator , serversBlocklistSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listBlockedServers ) ) serverBlocklistRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVERS_BLOCKLIST ) , asyncMiddleware ( blockServerValidator ) , asyncRetryTransactionMiddleware ( blockServer ) ) serverBlocklistRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_SERVERS_BLOCKLIST ) , asyncMiddleware ( unblockServerByServerValidator ) , asyncRetryTransactionMiddleware ( unblockServer ) ) export { serverBlocklistRouter } async function listBlockedAccounts ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await AccountBlocklistModel . listForApi ( serverActor . Account . id , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function blockAccount ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const accountToBlock = res . locals . account await addAccountInBlocklist ( serverActor . Account . id , accountToBlock . id ) return res . status ( 0 ) . end ( ) } async function unblockAccount ( req : express . Request , res : express . Response ) { const accountBlock = res . locals . accountBlock await removeAccountFromBlocklist ( accountBlock ) return res . status ( 0 ) . end ( ) } async function listBlockedServers ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await ServerBlocklistModel . listForApi ( serverActor . Account . id , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function blockServer ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const serverToBlock = res . locals . server await addServerInBlocklist ( serverActor . Account . id , serverToBlock . id ) return res . status ( 0 ) . end ( ) } async function unblockServer ( req : express . Request , res : express . Response ) { const serverBlock = res . locals . serverBlock await removeServerFromBlocklist ( serverBlock ) return res . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware , contactAdministratorValidator } from 's' import { Redis } from 's' import { Emailer } from 's' import { ContactForm } from 's' const contactRouter = express . Router ( ) contactRouter . post ( 's' , asyncMiddleware ( contactAdministratorValidator ) , asyncMiddleware ( contactAdministrator ) ) async function contactAdministrator ( req : express . Request , res : express . Response ) { const data = req . body as ContactForm await Emailer . Instance . addContactFormJob ( data . fromEmail , data . fromName , data . subject , data . body ) await Redis . Instance . setContactFormIp ( req . ip ) return res . status ( 0 ) . end ( ) } export { contactRouter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type LogLevel = 's' | 's' | 's' | 's'	O O O O O O O O O O O
import { exists } from 's' import { LogLevel } from 's' const logLevels : LogLevel [ ] = [ 's' , 's' , 's' , 's' ] function isValidLogLevel ( value ) { return exists ( value ) && logLevels . indexOf ( value ) !== - 0 } export { isValidLogLevel }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isDateValid } from 's' import { query } from 's' import { isValidLogLevel } from 's' const getLogsValidator = [ query ( 's' ) . custom ( isDateValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isValidLogLevel ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isDateValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { getLogsValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight } from 's' import { mtimeSortFilesDesc } from 's' import { readdir , readFile } from 's' import { MAX_LOGS_OUTPUT_CHARACTERS } from 's' import { join } from 's' import { getLogsValidator } from 's' import { LogLevel } from 's' import { CONFIG } from 's' const logsRouter = express . Router ( ) logsRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_LOGS ) , getLogsValidator , asyncMiddleware ( getLogs ) ) export { logsRouter } async function getLogs ( req : express . Request , res : express . Response ) { const logFiles = await readdir ( CONFIG . STORAGE . LOG_DIR ) const sortedLogFiles = await mtimeSortFilesDesc ( logFiles , CONFIG . STORAGE . LOG_DIR ) let currentSize = 0 const startDate = new Date ( req . query . startDate ) const endDate = req . query . endDate ? new Date ( req . query . endDate ) : new Date ( ) const level = req . query . level || 's' let output : string [ ] = [ ] for ( const meta of sortedLogFiles ) { const path = join ( CONFIG . STORAGE . LOG_DIR , meta . file ) const result = await getOutputFromFile ( path , startDate , endDate , level , currentSize ) if ( ! result . output ) break output = result . output . concat ( output ) currentSize = result . currentSize if ( currentSize > MAX_LOGS_OUTPUT_CHARACTERS || ( result . logTime && result . logTime < startDate . getTime ( ) ) ) break } return res . json ( output ) . end ( ) } async function getOutputFromFile ( path , startDate , endDate , level , currentSize ) { const startTime = startDate . getTime ( ) const endTime = endDate . getTime ( ) let logTime const logsLevel : { [ id in LogLevel ] : number } = { debug : 0 , info : 0 , warn : 0 , error : 0 } const content = await readFile ( path ) const lines = content . toString ( ) . split ( 's' ) const output : any [ ] = [ ] for ( let i = lines . length - 0 ; i >= 0 ; i -- ) { const line = lines [ i ] let log try { log = JSON . parse ( line ) } catch { continue } logTime = new Date ( log . timestamp ) . getTime ( ) if ( logTime >= startTime && logTime <= endTime && logsLevel [ log . level ] >= logsLevel [ level ] ) { output . push ( log ) currentSize += line . length if ( currentSize > MAX_LOGS_OUTPUT_CHARACTERS ) break } else if ( logTime < startTime ) { break } } return { currentSize , output : output . reverse ( ) , logTime } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogLevel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Date$ O $Date$ O $LogLevel$ O $number$ O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight } from 's' const debugRouter = express . Router ( ) debugRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_DEBUG ) , asyncMiddleware ( getDebug ) ) export { debugRouter } async function getDebug ( req : express . Request , res : express . Response ) { return res . json ( { ip : req . ip } ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { serverFollowsRouter } from 's' import { statsRouter } from 's' import { serverRedundancyRouter } from 's' import { serverBlocklistRouter } from 's' import { contactRouter } from 's' import { logsRouter } from 's' import { debugRouter } from 's' const serverRouter = express . Router ( ) serverRouter . use ( 's' , serverFollowsRouter ) serverRouter . use ( 's' , serverRedundancyRouter ) serverRouter . use ( 's' , statsRouter ) serverRouter . use ( 's' , serverBlocklistRouter ) serverRouter . use ( 's' , contactRouter ) serverRouter . use ( 's' , logsRouter ) serverRouter . use ( 's' , debugRouter ) export { serverRouter }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body } from 's' import { isAvatarFile } from 's' import { areValidationErrors } from 's' import { CONSTRAINTS_FIELDS } from 's' import { logger } from 's' import { cleanUpReqFiles } from 's' const updateAvatarValidator = [ body ( 's' ) . custom ( ( value , { req } ) => isAvatarFile ( req . files ) ) . withMessage ( 's' + CONSTRAINTS_FIELDS . ACTORS . AVATAR . EXTNAME . join ( 's' ) ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { files : req . files } ) if ( areValidationErrors ( req , res ) ) return cleanUpReqFiles ( req ) return next ( ) } ] export { updateAvatarValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { sendUpdateActor } from 's' import { AVATARS_SIZE , LRU_CACHE , QUEUE_CONCURRENCY } from 's' import { updateActorAvatarInstance } from 's' import { processImage } from 's' import { extname , join } from 's' import { retryTransactionWrapper } from 's' import * as 0 from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import * as LRUCache from 's' import { queue } from 's' import { downloadImage } from 's' import { MAccountDefault , MChannelDefault } from 's' async function updateActorAvatarFile ( avatarPhysicalFile : Express . Multer . File , accountOrChannel : MAccountDefault | MChannelDefault ) { const extension = extname ( avatarPhysicalFile . filename ) const avatarName = 0 ( ) + extension const destination = join ( CONFIG . STORAGE . AVATARS_DIR , avatarName ) await processImage ( avatarPhysicalFile . path , destination , AVATARS_SIZE ) return retryTransactionWrapper ( ( ) => { return sequelizeTypescript . transaction ( async t => { const avatarInfo = { name : avatarName , fileUrl : null , onDisk : true } const updatedActor = await updateActorAvatarInstance ( accountOrChannel . Actor , avatarInfo , t ) await updatedActor . save ( { transaction : t } ) await sendUpdateActor ( accountOrChannel , t ) return updatedActor . Avatar } ) } ) } type DownloadImageQueueTask = { fileUrl : string , filename : string } const downloadImageQueue = queue < DownloadImageQueueTask , Error > ( ( task , cb ) => { downloadImage ( task . fileUrl , CONFIG . STORAGE . AVATARS_DIR , task . filename , AVATARS_SIZE ) . then ( ( ) => cb ( ) ) . catch ( err => cb ( err ) ) } , QUEUE_CONCURRENCY . AVATAR_PROCESS_IMAGE ) function pushAvatarProcessInQueue ( task ) { return new Promise ( ( res , rej ) => { downloadImageQueue . push ( task , err => { if ( err ) return rej ( err ) return res ( ) } ) } ) } const avatarPathUnsafeCache = new LRUCache < string , string > ( { max : LRU_CACHE . AVATAR_STATIC . MAX_SIZE } ) export { avatarPathUnsafeCache , updateActorAvatarFile , pushAvatarProcessInQueue }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DownloadImageQueueTask$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import 's' import { UserUpdateMe , UserVideoRate as FormattedUserVideoRate } from 's' import { getFormattedObjects } from 's' import { MIMETYPES } from 's' import { sendUpdateActor } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , paginationValidator , setDefaultPagination , setDefaultSort , usersUpdateMeValidator , usersVideoRatingValidator } from 's' import { deleteMeValidator , videoImportsSortValidator , videosSortValidator } from 's' import { AccountVideoRateModel } from 's' import { UserModel } from 's' import { VideoModel } from 's' import { VideoSortField } from 's' import { createReqFiles } from 's' import { UserVideoQuota } from 's' import { updateAvatarValidator } from 's' import { updateActorAvatarFile } from 's' import { VideoImportModel } from 's' import { AccountModel } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { sendVerifyUserEmail } from 's' const reqAvatarFile = createReqFiles ( [ 's' ] , MIMETYPES . IMAGE . MIMETYPE_EXT , { avatarfile : CONFIG . STORAGE . TMP_DIR } ) const meRouter = express . Router ( ) meRouter . get ( 's' , authenticate , asyncMiddleware ( getUserInformation ) ) meRouter . delete ( 's' , authenticate , asyncMiddleware ( deleteMeValidator ) , asyncMiddleware ( deleteMe ) ) meRouter . get ( 's' , authenticate , asyncMiddleware ( getUserVideoQuotaUsed ) ) meRouter . get ( 's' , authenticate , paginationValidator , videoImportsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( getUserVideoImports ) ) meRouter . get ( 's' , authenticate , paginationValidator , videosSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( getUserVideos ) ) meRouter . get ( 's' , authenticate , asyncMiddleware ( usersVideoRatingValidator ) , asyncMiddleware ( getUserVideoRating ) ) meRouter . put ( 's' , authenticate , asyncMiddleware ( usersUpdateMeValidator ) , asyncRetryTransactionMiddleware ( updateMe ) ) meRouter . post ( 's' , authenticate , reqAvatarFile , updateAvatarValidator , asyncRetryTransactionMiddleware ( updateMyAvatar ) ) export { meRouter } async function getUserVideos ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await VideoModel . listUserVideosForApi ( user . Account . id , req . query . start as number , req . query . count as number , req . query . sort as VideoSortField ) const additionalAttributes = { waitTranscoding : true , state : true , scheduledUpdate : true , blacklistInfo : true } return res . json ( getFormattedObjects ( resultList . data , resultList . total , { additionalAttributes } ) ) } async function getUserVideoImports ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await VideoImportModel . listUserVideoImportsForApi ( user . id , req . query . start as number , req . query . count as number , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function getUserInformation ( req : express . Request , res : express . Response ) { const user = await UserModel . loadByUsernameAndPopulateChannels ( res . locals . oauth . token . user . username ) return res . json ( user . toFormattedJSON ( ) ) } async function getUserVideoQuotaUsed ( req : express . Request , res : express . Response ) { const user = await UserModel . loadByUsernameAndPopulateChannels ( res . locals . oauth . token . user . username ) const videoQuotaUsed = await UserModel . getOriginalVideoFileTotalFromUser ( user ) const videoQuotaUsedDaily = await UserModel . getOriginalVideoFileTotalDailyFromUser ( user ) const data = { videoQuotaUsed , videoQuotaUsedDaily } return res . json ( data ) } async function getUserVideoRating ( req : express . Request , res : express . Response ) { const videoId = res . locals . videoId . id const accountId = + res . locals . oauth . token . User . Account . id const ratingObj = await AccountVideoRateModel . load ( accountId , videoId , null ) const rating = ratingObj ? ratingObj . type : 's' const json = { videoId , rating } return res . json ( json ) } async function deleteMe ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User await user . destroy ( ) return res . sendStatus ( 0 ) } async function updateMe ( req : express . Request , res : express . Response ) { const body = req . body let sendVerificationEmail = false const user = res . locals . oauth . token . user if ( body . password !== undefined ) user . password = body . password if ( body . nsfwPolicy !== undefined ) user . nsfwPolicy = body . nsfwPolicy if ( body . webTorrentEnabled !== undefined ) user . webTorrentEnabled = body . webTorrentEnabled if ( body . autoPlayVideo !== undefined ) user . autoPlayVideo = body . autoPlayVideo if ( body . autoPlayNextVideo !== undefined ) user . autoPlayNextVideo = body . autoPlayNextVideo if ( body . videosHistoryEnabled !== undefined ) user . videosHistoryEnabled = body . videosHistoryEnabled if ( body . videoLanguages !== undefined ) user . videoLanguages = body . videoLanguages if ( body . theme !== undefined ) user . theme = body . theme if ( body . noInstanceConfigWarningModal !== undefined ) user . noInstanceConfigWarningModal = body . noInstanceConfigWarningModal if ( body . noWelcomeModal !== undefined ) user . noWelcomeModal = body . noWelcomeModal if ( body . email !== undefined ) { if ( CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION ) { user . pendingEmail = body . email sendVerificationEmail = true } else { user . email = body . email } } await sequelizeTypescript . transaction ( async t => { await user . save ( { transaction : t } ) if ( body . displayName !== undefined || body . description !== undefined ) { const userAccount = await AccountModel . load ( user . Account . id , t ) if ( body . displayName !== undefined ) userAccount . name = body . displayName if ( body . description !== undefined ) userAccount . description = body . description await userAccount . save ( { transaction : t } ) await sendUpdateActor ( userAccount , t ) } } ) if ( sendVerificationEmail === true ) { await sendVerifyUserEmail ( user , true ) } return res . sendStatus ( 0 ) } async function updateMyAvatar ( req : express . Request , res : express . Response ) { const avatarPhysicalFile = req . files [ 's' ] [ 0 ] const user = res . locals . oauth . token . user const userAccount = await AccountModel . load ( user . Account . id ) const avatar = await updateActorAvatarFile ( avatarPhysicalFile , userAccount ) return res . json ( { avatar : avatar . toFormattedJSON ( ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserVideoQuota$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FormattedUserVideoRate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import 's' import { getFormattedObjects } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , paginationValidator , setDefaultPagination , setDefaultSort , unblockAccountByAccountValidator } from 's' import { accountsBlocklistSortValidator , blockAccountValidator , blockServerValidator , serversBlocklistSortValidator , unblockServerByAccountValidator } from 's' import { AccountBlocklistModel } from 's' import { addAccountInBlocklist , addServerInBlocklist , removeAccountFromBlocklist , removeServerFromBlocklist } from 's' import { ServerBlocklistModel } from 's' const myBlocklistRouter = express . Router ( ) myBlocklistRouter . get ( 's' , authenticate , paginationValidator , accountsBlocklistSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listBlockedAccounts ) ) myBlocklistRouter . post ( 's' , authenticate , asyncMiddleware ( blockAccountValidator ) , asyncRetryTransactionMiddleware ( blockAccount ) ) myBlocklistRouter . delete ( 's' , authenticate , asyncMiddleware ( unblockAccountByAccountValidator ) , asyncRetryTransactionMiddleware ( unblockAccount ) ) myBlocklistRouter . get ( 's' , authenticate , paginationValidator , serversBlocklistSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listBlockedServers ) ) myBlocklistRouter . post ( 's' , authenticate , asyncMiddleware ( blockServerValidator ) , asyncRetryTransactionMiddleware ( blockServer ) ) myBlocklistRouter . delete ( 's' , authenticate , asyncMiddleware ( unblockServerByAccountValidator ) , asyncRetryTransactionMiddleware ( unblockServer ) ) export { myBlocklistRouter } async function listBlockedAccounts ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await AccountBlocklistModel . listForApi ( user . Account . id , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function blockAccount ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const accountToBlock = res . locals . account await addAccountInBlocklist ( user . Account . id , accountToBlock . id ) return res . status ( 0 ) . end ( ) } async function unblockAccount ( req : express . Request , res : express . Response ) { const accountBlock = res . locals . accountBlock await removeAccountFromBlocklist ( accountBlock ) return res . status ( 0 ) . end ( ) } async function listBlockedServers ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await ServerBlocklistModel . listForApi ( user . Account . id , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function blockServer ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const serverToBlock = res . locals . server await addServerInBlocklist ( user . Account . id , serverToBlock . id ) return res . status ( 0 ) . end ( ) } async function unblockServer ( req : express . Request , res : express . Response ) { const serverBlock = res . locals . serverBlock await removeServerFromBlocklist ( serverBlock ) return res . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type VideoExistInPlaylist = { [ videoId ] : { playlistElementId : number playlistId : number startTimestamp ? : number stopTimestamp ? : number } [ ] }	O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware , authenticate } from 's' import { doVideosInPlaylistExistValidator } from 's' import { VideoPlaylistModel } from 's' import { VideoExistInPlaylist } from 's' const myVideoPlaylistsRouter = express . Router ( ) myVideoPlaylistsRouter . get ( 's' , authenticate , doVideosInPlaylistExistValidator , asyncMiddleware ( doVideosInPlaylistExist ) ) export { myVideoPlaylistsRouter } async function doVideosInPlaylistExist ( req : express . Request , res : express . Response ) { const videoIds = req . query . videoIds . map ( i => parseInt ( i + 's' , 0 ) ) const user = res . locals . oauth . token . User const results = await VideoPlaylistModel . listPlaylistIdsOf ( user . Account . id , videoIds ) const existObject = { } for ( const videoId of videoIds ) { existObject [ videoId ] = [ ] } for ( const result of results ) { for ( const element of result . VideoPlaylistElements ) { existObject [ element . videoId ] . push ( { playlistElementId : element . id , playlistId : result . id , startTimestamp : element . startTimestamp , stopTimestamp : element . stopTimestamp } ) } } return res . json ( existObject ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoExistInPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , paginationValidator , setDefaultPagination , userHistoryRemoveValidator } from 's' import { getFormattedObjects } from 's' import { UserVideoHistoryModel } from 's' import { sequelizeTypescript } from 's' const myVideosHistoryRouter = express . Router ( ) myVideosHistoryRouter . get ( 's' , authenticate , paginationValidator , setDefaultPagination , asyncMiddleware ( listMyVideosHistory ) ) myVideosHistoryRouter . post ( 's' , authenticate , userHistoryRemoveValidator , asyncRetryTransactionMiddleware ( removeUserHistory ) ) export { myVideosHistoryRouter } async function listMyVideosHistory ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await UserVideoHistoryModel . listForApi ( user , req . query . start , req . query . count ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function removeUserHistory ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const beforeDate = req . body . beforeDate || null await sequelizeTypescript . transaction ( t => { return UserVideoHistoryModel . removeUserHistoryBefore ( user , beforeDate , t ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { body , query } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isUserNotificationSettingValid } from 's' import { isNotEmptyIntArray , toBooleanOrNull } from 's' const listUserNotificationsValidator = [ query ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . isBoolean ( ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const updateNotificationSettingsValidator = [ body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , body ( 's' ) . custom ( isUserNotificationSettingValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const markAsReadUserNotificationsValidator = [ body ( 's' ) . optional ( ) . custom ( isNotEmptyIntArray ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] export { listUserNotificationsValidator , updateNotificationSettingsValidator , markAsReadUserNotificationsValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , paginationValidator , setDefaultPagination , setDefaultSort , userNotificationsSortValidator } from 's' import { getFormattedObjects } from 's' import { UserNotificationModel } from 's' import { meRouter } from 's' import { listUserNotificationsValidator , markAsReadUserNotificationsValidator , updateNotificationSettingsValidator } from 's' import { UserNotificationSetting } from 's' import { UserNotificationSettingModel } from 's' const myNotificationsRouter = express . Router ( ) meRouter . put ( 's' , authenticate , updateNotificationSettingsValidator , asyncRetryTransactionMiddleware ( updateNotificationSettings ) ) myNotificationsRouter . get ( 's' , authenticate , paginationValidator , userNotificationsSortValidator , setDefaultSort , setDefaultPagination , listUserNotificationsValidator , asyncMiddleware ( listUserNotifications ) ) myNotificationsRouter . post ( 's' , authenticate , markAsReadUserNotificationsValidator , asyncMiddleware ( markAsReadUserNotifications ) ) myNotificationsRouter . post ( 's' , authenticate , asyncMiddleware ( markAsReadAllUserNotifications ) ) export { myNotificationsRouter } async function updateNotificationSettings ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const body = req . body as UserNotificationSetting const query = { where : { userId : user . id } } const values = { newVideoFromSubscription : body . newVideoFromSubscription , newCommentOnMyVideo : body . newCommentOnMyVideo , videoAbuseAsModerator : body . videoAbuseAsModerator , videoAutoBlacklistAsModerator : body . videoAutoBlacklistAsModerator , blacklistOnMyVideo : body . blacklistOnMyVideo , myVideoPublished : body . myVideoPublished , myVideoImportFinished : body . myVideoImportFinished , newFollow : body . newFollow , newUserRegistration : body . newUserRegistration , commentMention : body . commentMention , newInstanceFollower : body . newInstanceFollower , autoInstanceFollowing : body . autoInstanceFollowing } await UserNotificationSettingModel . update ( values , query ) return res . status ( 0 ) . end ( ) } async function listUserNotifications ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await UserNotificationModel . listForApi ( user . id , req . query . start , req . query . count , req . query . sort , req . query . unread ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function markAsReadUserNotifications ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User await UserNotificationModel . markAsRead ( user . id , req . body . ids ) return res . status ( 0 ) . end ( ) } async function markAsReadAllUserNotifications ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User await UserNotificationModel . markAllAsRead ( user . id ) return res . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import 's' import { getFormattedObjects } from 's' import { WEBSERVER } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , commonVideosFiltersValidator , paginationValidator , setDefaultPagination , setDefaultSort , userSubscriptionAddValidator , userSubscriptionGetValidator } from 's' import { areSubscriptionsExistValidator , userSubscriptionsSortValidator , videosSortValidator } from 's' import { VideoModel } from 's' import { buildNSFWFilter } from 's' import { VideoFilter } from 's' import { ActorFollowModel } from 's' import { JobQueue } from 's' import { logger } from 's' import { sequelizeTypescript } from 's' const mySubscriptionsRouter = express . Router ( ) mySubscriptionsRouter . get ( 's' , authenticate , paginationValidator , videosSortValidator , setDefaultSort , setDefaultPagination , commonVideosFiltersValidator , asyncMiddleware ( getUserSubscriptionVideos ) ) mySubscriptionsRouter . get ( 's' , authenticate , areSubscriptionsExistValidator , asyncMiddleware ( areSubscriptionsExist ) ) mySubscriptionsRouter . get ( 's' , authenticate , paginationValidator , userSubscriptionsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( getUserSubscriptions ) ) mySubscriptionsRouter . post ( 's' , authenticate , userSubscriptionAddValidator , asyncMiddleware ( addUserSubscription ) ) mySubscriptionsRouter . get ( 's' , authenticate , userSubscriptionGetValidator , getUserSubscription ) mySubscriptionsRouter . delete ( 's' , authenticate , userSubscriptionGetValidator , asyncRetryTransactionMiddleware ( deleteUserSubscription ) ) export { mySubscriptionsRouter } async function areSubscriptionsExist ( req : express . Request , res : express . Response ) { const uris = req . query . uris as string [ ] const user = res . locals . oauth . token . User const handles = uris . map ( u => { let [ name , host ] = u . split ( 's' ) if ( host === WEBSERVER . HOST ) host = null return { name , host , uri : u } } ) const results = await ActorFollowModel . listSubscribedIn ( user . Account . Actor . id , handles ) const existObject : { [ id ] : boolean } = { } for ( const handle of handles ) { const obj = results . find ( r => { const server = r . ActorFollowing . Server return r . ActorFollowing . preferredUsername === handle . name && ( ( ! server && ! handle . host ) || ( server . host === handle . host ) ) } ) existObject [ handle . uri ] = obj !== undefined } return res . json ( existObject ) } async function addUserSubscription ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const [ name , host ] = req . body . uri . split ( 's' ) const payload = { name , host , followerActorId : user . Account . Actor . id } JobQueue . Instance . createJob ( { type : 's' , payload } ) . catch ( err => logger . error ( 's' , req . body . uri , err ) ) return res . status ( 0 ) . end ( ) } function getUserSubscription ( req : express . Request , res : express . Response ) { const subscription = res . locals . subscription return res . json ( subscription . ActorFollowing . VideoChannel . toFormattedJSON ( ) ) } async function deleteUserSubscription ( req : express . Request , res : express . Response ) { const subscription = res . locals . subscription await sequelizeTypescript . transaction ( async t => { return subscription . destroy ( { transaction : t } ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function getUserSubscriptions ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const actorId = user . Account . Actor . id const resultList = await ActorFollowModel . listSubscriptionsForApi ( actorId , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function getUserSubscriptionVideos ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const resultList = await VideoModel . listForApi ( { start : req . query . start , count : req . query . count , sort : req . query . sort , includeLocalVideos : false , categoryOneOf : req . query . categoryOneOf , licenceOneOf : req . query . licenceOneOf , languageOneOf : req . query . languageOneOf , tagsOneOf : req . query . tagsOneOf , tagsAllOf : req . query . tagsAllOf , nsfw : buildNSFWFilter ( res , req . query . nsfw ) , filter : req . query . filter as VideoFilter , withFiles : false , followerActorId : user . Account . Actor . id , user } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import * as RateLimit from 's' import { UserCreate , UserRight , UserRole , UserUpdate } from 's' import { logger } from 's' import { getFormattedObjects } from 's' import { WEBSERVER } from 's' import { Emailer } from 's' import { Redis } from 's' import { createUserAccountAndChannelAndPlaylist , sendVerifyUserEmail } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , ensureUserHasRight , ensureUserRegistrationAllowed , ensureUserRegistrationAllowedForIP , paginationValidator , setDefaultPagination , setDefaultSort , token , userAutocompleteValidator , usersAddValidator , usersGetValidator , usersRegisterValidator , usersRemoveValidator , usersSortValidator , usersUpdateValidator } from 's' import { usersAskResetPasswordValidator , usersAskSendVerifyEmailValidator , usersBlockingValidator , usersResetPasswordValidator , usersVerifyEmailValidator , ensureCanManageUser } from 's' import { UserModel } from 's' import { auditLoggerFactory , getAuditIdFromRes , UserAuditView } from 's' import { meRouter } from 's' import { deleteUserToken } from 's' import { myBlocklistRouter } from 's' import { myVideoPlaylistsRouter } from 's' import { myVideosHistoryRouter } from 's' import { myNotificationsRouter } from 's' import { Notifier } from 's' import { mySubscriptionsRouter } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { UserAdminFlag } from 's' import { UserRegister } from 's' import { MUser , MUserAccountDefault } from 's' const auditLogger = auditLoggerFactory ( 's' ) const loginRateLimiter = RateLimit ( { windowMs : CONFIG . RATES_LIMIT . LOGIN . WINDOW_MS , max : CONFIG . RATES_LIMIT . LOGIN . MAX } ) const signupRateLimiter = RateLimit ( { windowMs : CONFIG . RATES_LIMIT . SIGNUP . WINDOW_MS , max : CONFIG . RATES_LIMIT . SIGNUP . MAX , skipFailedRequests : true } ) const askSendEmailLimiter = new RateLimit ( { windowMs : CONFIG . RATES_LIMIT . ASK_SEND_EMAIL . WINDOW_MS , max : CONFIG . RATES_LIMIT . ASK_SEND_EMAIL . MAX } ) const usersRouter = express . Router ( ) usersRouter . use ( 's' , myNotificationsRouter ) usersRouter . use ( 's' , mySubscriptionsRouter ) usersRouter . use ( 's' , myBlocklistRouter ) usersRouter . use ( 's' , myVideosHistoryRouter ) usersRouter . use ( 's' , myVideoPlaylistsRouter ) usersRouter . use ( 's' , meRouter ) usersRouter . get ( 's' , userAutocompleteValidator , asyncMiddleware ( autocompleteUsers ) ) usersRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , paginationValidator , usersSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listUsers ) ) usersRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersBlockingValidator ) , ensureCanManageUser , asyncMiddleware ( blockUser ) ) usersRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersBlockingValidator ) , ensureCanManageUser , asyncMiddleware ( unblockUser ) ) usersRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersGetValidator ) , getUser ) usersRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersAddValidator ) , asyncRetryTransactionMiddleware ( createUser ) ) usersRouter . post ( 's' , signupRateLimiter , asyncMiddleware ( ensureUserRegistrationAllowed ) , ensureUserRegistrationAllowedForIP , asyncMiddleware ( usersRegisterValidator ) , asyncRetryTransactionMiddleware ( registerUser ) ) usersRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersUpdateValidator ) , ensureCanManageUser , asyncMiddleware ( updateUser ) ) usersRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_USERS ) , asyncMiddleware ( usersRemoveValidator ) , ensureCanManageUser , asyncMiddleware ( removeUser ) ) usersRouter . post ( 's' , asyncMiddleware ( usersAskResetPasswordValidator ) , asyncMiddleware ( askResetUserPassword ) ) usersRouter . post ( 's' , asyncMiddleware ( usersResetPasswordValidator ) , asyncMiddleware ( resetUserPassword ) ) usersRouter . post ( 's' , askSendEmailLimiter , asyncMiddleware ( usersAskSendVerifyEmailValidator ) , asyncMiddleware ( reSendVerifyUserEmail ) ) usersRouter . post ( 's' , asyncMiddleware ( usersVerifyEmailValidator ) , asyncMiddleware ( verifyUserEmail ) ) usersRouter . post ( 's' , loginRateLimiter , token , success ) export { usersRouter } async function createUser ( req : express . Request , res : express . Response ) { const body = req . body const userToCreate = new UserModel ( { username : body . username , password : body . password , email : body . email , nsfwPolicy : CONFIG . INSTANCE . DEFAULT_NSFW_POLICY , autoPlayVideo : true , role : body . role , videoQuota : body . videoQuota , videoQuotaDaily : body . videoQuotaDaily , adminFlags : body . adminFlags || UserAdminFlag . NONE } ) as MUser const { user , account } = await createUserAccountAndChannelAndPlaylist ( { userToCreate : userToCreate } ) auditLogger . create ( getAuditIdFromRes ( res ) , new UserAuditView ( user . toFormattedJSON ( ) ) ) logger . info ( 's' , body . username ) return res . json ( { user : { id : user . id , account : { id : account . id } } } ) . end ( ) } async function registerUser ( req : express . Request , res : express . Response ) { const body = req . body const userToCreate = new UserModel ( { username : body . username , password : body . password , email : body . email , nsfwPolicy : CONFIG . INSTANCE . DEFAULT_NSFW_POLICY , autoPlayVideo : true , role : UserRole . USER , videoQuota : CONFIG . USER . VIDEO_QUOTA , videoQuotaDaily : CONFIG . USER . VIDEO_QUOTA_DAILY , emailVerified : CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION ? false : null } ) const { user } = await createUserAccountAndChannelAndPlaylist ( { userToCreate : userToCreate , userDisplayName : body . displayName || undefined , channelNames : body . channel } ) auditLogger . create ( body . username , new UserAuditView ( user . toFormattedJSON ( ) ) ) logger . info ( 's' , body . username ) if ( CONFIG . SIGNUP . REQUIRES_EMAIL_VERIFICATION ) { await sendVerifyUserEmail ( user ) } Notifier . Instance . notifyOnNewUserRegistration ( user ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function unblockUser ( req : express . Request , res : express . Response ) { const user = res . locals . user await changeUserBlock ( res , user , false ) return res . status ( 0 ) . end ( ) } async function blockUser ( req : express . Request , res : express . Response ) { const user = res . locals . user const reason = req . body . reason await changeUserBlock ( res , user , true , reason ) return res . status ( 0 ) . end ( ) } function getUser ( req : express . Request , res : express . Response ) { return res . json ( res . locals . user . toFormattedJSON ( { withAdminFlags : true } ) ) } async function autocompleteUsers ( req : express . Request , res : express . Response ) { const resultList = await UserModel . autoComplete ( req . query . search as string ) return res . json ( resultList ) } async function listUsers ( req : express . Request , res : express . Response ) { const resultList = await UserModel . listForApi ( req . query . start , req . query . count , req . query . sort , req . query . search ) return res . json ( getFormattedObjects ( resultList . data , resultList . total , { withAdminFlags : true } ) ) } async function removeUser ( req : express . Request , res : express . Response ) { const user = res . locals . user await user . destroy ( ) auditLogger . delete ( getAuditIdFromRes ( res ) , new UserAuditView ( user . toFormattedJSON ( ) ) ) return res . sendStatus ( 0 ) } async function updateUser ( req : express . Request , res : express . Response ) { const body = req . body const userToUpdate = res . locals . user const oldUserAuditView = new UserAuditView ( userToUpdate . toFormattedJSON ( ) ) const roleChanged = body . role !== undefined && body . role !== userToUpdate . role if ( body . password !== undefined ) userToUpdate . password = body . password if ( body . email !== undefined ) userToUpdate . email = body . email if ( body . emailVerified !== undefined ) userToUpdate . emailVerified = body . emailVerified if ( body . videoQuota !== undefined ) userToUpdate . videoQuota = body . videoQuota if ( body . videoQuotaDaily !== undefined ) userToUpdate . videoQuotaDaily = body . videoQuotaDaily if ( body . role !== undefined ) userToUpdate . role = body . role if ( body . adminFlags !== undefined ) userToUpdate . adminFlags = body . adminFlags const user = await userToUpdate . save ( ) if ( roleChanged || body . password !== undefined ) await deleteUserToken ( userToUpdate . id ) auditLogger . update ( getAuditIdFromRes ( res ) , new UserAuditView ( user . toFormattedJSON ( ) ) , oldUserAuditView ) return res . sendStatus ( 0 ) } async function askResetUserPassword ( req : express . Request , res : express . Response ) { const user = res . locals . user const verificationString = await Redis . Instance . setResetPasswordVerificationString ( user . id ) const url = WEBSERVER . URL + 's' + user . id + 's' + verificationString await Emailer . Instance . addPasswordResetEmailJob ( user . email , url ) return res . status ( 0 ) . end ( ) } async function resetUserPassword ( req : express . Request , res : express . Response ) { const user = res . locals . user user . password = req . body . password await user . save ( ) return res . status ( 0 ) . end ( ) } async function reSendVerifyUserEmail ( req : express . Request , res : express . Response ) { const user = res . locals . user await sendVerifyUserEmail ( user ) return res . status ( 0 ) . end ( ) } async function verifyUserEmail ( req : express . Request , res : express . Response ) { const user = res . locals . user user . emailVerified = true if ( req . body . isPendingEmail === true ) { user . email = user . pendingEmail user . pendingEmail = null } await user . save ( ) return res . status ( 0 ) . end ( ) } function success ( req : express . Request , res : express . Response ) { res . end ( ) } async function changeUserBlock ( res : express . Response , user , block , reason ? ) { const oldUserAuditView = new UserAuditView ( user . toFormattedJSON ( ) ) user . blocked = block user . blockedReason = reason || null await sequelizeTypescript . transaction ( async t => { await deleteUserToken ( user . id , t ) await user . save ( { transaction : t } ) } ) await Emailer . Instance . addUserBlockJob ( user , block , reason ) auditLogger . update ( getAuditIdFromRes ( res ) , new UserAuditView ( user . toFormattedJSON ( ) ) , oldUserAuditView ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRegister$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MUserAccountDefault$ O $boolean$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { getVideoAbuseActivityPubUrl } from 's' import { unicastTo } from 's' import { logger } from 's' import { ActivityAudience , ActivityFlag } from 's' import { audiencify , getAudience } from 's' import { Transaction } from 's' import { MActor , MVideoFullLight } from 's' import { MVideoAbuseVideo } from 's' async function sendVideoAbuse ( byActor , videoAbuse , video , t ) { if ( ! video . VideoChannel . Account . Actor . serverId ) return const url = getVideoAbuseActivityPubUrl ( videoAbuse ) logger . info ( 's' , url ) const audience = { to : [ video . VideoChannel . Account . Actor . url ] , cc : [ ] } const flagActivity = buildFlagActivity ( url , byActor , videoAbuse , audience ) t . afterCommit ( ( ) => unicastTo ( flagActivity , byActor , video . VideoChannel . Account . Actor . sharedInboxUrl ) ) } function buildFlagActivity ( url , byActor , videoAbuse , audience ) { if ( ! audience ) audience = getAudience ( byActor ) const activity = Object . assign ( { id : url , actor : byActor . url } , videoAbuse . toActivityPubObject ( ) ) return audiencify ( activity , audience ) } export { sendVideoAbuse }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MActor$ O $MVideoAbuseVideo$ O $MVideoFullLight$ O $Transaction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityFlag$ O $string$ O $MActor$ O $MVideoAbuseVideo$ O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight , VideoAbuseCreate , VideoAbuseState } from 's' import { logger } from 's' import { getFormattedObjects , getServerActor } from 's' import { sequelizeTypescript } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , ensureUserHasRight , paginationValidator , setDefaultPagination , setDefaultSort , videoAbuseGetValidator , videoAbuseReportValidator , videoAbusesSortValidator , videoAbuseUpdateValidator } from 's' import { AccountModel } from 's' import { VideoAbuseModel } from 's' import { auditLoggerFactory , VideoAbuseAuditView } from 's' import { Notifier } from 's' import { sendVideoAbuse } from 's' import { MVideoAbuseAccountVideo } from 's' const auditLogger = auditLoggerFactory ( 's' ) const abuseVideoRouter = express . Router ( ) abuseVideoRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_ABUSES ) , paginationValidator , videoAbusesSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listVideoAbuses ) ) abuseVideoRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_ABUSES ) , asyncMiddleware ( videoAbuseUpdateValidator ) , asyncRetryTransactionMiddleware ( updateVideoAbuse ) ) abuseVideoRouter . post ( 's' , authenticate , asyncMiddleware ( videoAbuseReportValidator ) , asyncRetryTransactionMiddleware ( reportVideoAbuse ) ) abuseVideoRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_ABUSES ) , asyncMiddleware ( videoAbuseGetValidator ) , asyncRetryTransactionMiddleware ( deleteVideoAbuse ) ) export { abuseVideoRouter } async function listVideoAbuses ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . user const serverActor = await getServerActor ( ) const resultList = await VideoAbuseModel . listForApi ( { start : req . query . start , count : req . query . count , sort : req . query . sort , serverAccountId : serverActor . Account . id , user } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function updateVideoAbuse ( req : express . Request , res : express . Response ) { const videoAbuse = res . locals . videoAbuse if ( req . body . moderationComment !== undefined ) videoAbuse . moderationComment = req . body . moderationComment if ( req . body . state !== undefined ) videoAbuse . state = req . body . state await sequelizeTypescript . transaction ( t => { return videoAbuse . save ( { transaction : t } ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function deleteVideoAbuse ( req : express . Request , res : express . Response ) { const videoAbuse = res . locals . videoAbuse await sequelizeTypescript . transaction ( t => { return videoAbuse . destroy ( { transaction : t } ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function reportVideoAbuse ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll const body = req . body const videoAbuse = await sequelizeTypescript . transaction ( async t => { const reporterAccount = await AccountModel . load ( res . locals . oauth . token . User . Account . id , t ) const abuseToCreate = { reporterAccountId : reporterAccount . id , reason : body . reason , videoId : videoInstance . id , state : VideoAbuseState . PENDING } const videoAbuseInstance = await VideoAbuseModel . create ( abuseToCreate , { transaction : t } ) videoAbuseInstance . Video = videoInstance videoAbuseInstance . Account = reporterAccount if ( videoInstance . isOwned ( ) === false ) { await sendVideoAbuse ( reporterAccount . Actor , videoAbuseInstance , videoInstance , t ) } auditLogger . create ( reporterAccount . Actor . getIdentifier ( ) , new VideoAbuseAuditView ( videoAbuseInstance . toFormattedJSON ( ) ) ) return videoAbuseInstance } ) Notifier . Instance . notifyOnNewVideoAbuse ( videoAbuse ) logger . info ( 's' , videoInstance . name ) return res . json ( { videoAbuse : videoAbuse . toFormattedJSON ( ) } ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuseCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoAbuseAccountVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserRight , VideoBlacklistCreate , VideoBlacklistType } from 's' import { logger } from 's' import { getFormattedObjects } from 's' import { asyncMiddleware , authenticate , blacklistSortValidator , ensureUserHasRight , paginationValidator , setBlacklistSort , setDefaultPagination , videosBlacklistAddValidator , videosBlacklistFiltersValidator , videosBlacklistRemoveValidator , videosBlacklistUpdateValidator } from 's' import { VideoBlacklistModel } from 's' import { sequelizeTypescript } from 's' import { Notifier } from 's' import { sendDeleteVideo } from 's' import { federateVideoIfNeeded } from 's' import { MVideoBlacklistVideo } from 's' const blacklistRouter = express . Router ( ) blacklistRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) , asyncMiddleware ( videosBlacklistAddValidator ) , asyncMiddleware ( addVideoToBlacklist ) ) blacklistRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) , paginationValidator , blacklistSortValidator , setBlacklistSort , setDefaultPagination , videosBlacklistFiltersValidator , asyncMiddleware ( listBlacklist ) ) blacklistRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) , asyncMiddleware ( videosBlacklistUpdateValidator ) , asyncMiddleware ( updateVideoBlacklistController ) ) blacklistRouter . delete ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_VIDEO_BLACKLIST ) , asyncMiddleware ( videosBlacklistRemoveValidator ) , asyncMiddleware ( removeVideoFromBlacklistController ) ) export { blacklistRouter } async function addVideoToBlacklist ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll const body = req . body const toCreate = { videoId : videoInstance . id , unfederated : body . unfederate === true , reason : body . reason , type : VideoBlacklistType . MANUAL } const blacklist = await VideoBlacklistModel . create ( toCreate ) blacklist . Video = videoInstance if ( body . unfederate === true ) { await sendDeleteVideo ( videoInstance , undefined ) } Notifier . Instance . notifyOnVideoBlacklist ( blacklist ) logger . info ( 's' , videoInstance . uuid ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function updateVideoBlacklistController ( req : express . Request , res : express . Response ) { const videoBlacklist = res . locals . videoBlacklist if ( req . body . reason !== undefined ) videoBlacklist . reason = req . body . reason await sequelizeTypescript . transaction ( t => { return videoBlacklist . save ( { transaction : t } ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function listBlacklist ( req : express . Request , res : express . Response ) { const resultList = await VideoBlacklistModel . listForApi ( req . query . start , req . query . count , req . query . sort , req . query . type ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function removeVideoFromBlacklistController ( req : express . Request , res : express . Response ) { const videoBlacklist = res . locals . videoBlacklist const video = res . locals . videoAll const videoBlacklistType = await sequelizeTypescript . transaction ( async t => { const unfederated = videoBlacklist . unfederated const videoBlacklistType = videoBlacklist . type await videoBlacklist . destroy ( { transaction : t } ) video . VideoBlacklist = undefined if ( unfederated === true ) { await federateVideoIfNeeded ( video , true , t ) } return videoBlacklistType } ) Notifier . Instance . notifyOnVideoUnblacklist ( video ) if ( videoBlacklistType === VideoBlacklistType . AUTO_BEFORE_PUBLISHED ) { Notifier . Instance . notifyOnVideoPublishedAfterRemovedFromAutoBlacklist ( video ) delete video . VideoBlacklist Notifier . Instance . notifyOnNewVideoIfNeeded ( video ) } logger . info ( 's' , video . uuid ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoBlacklistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoBlacklistVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { ResultList } from 's' import { VideoCommentThreadTree } from 's' import { VideoCommentModel } from 's' import { getVideoCommentActivityPubUrl } from 's' import { sendCreateVideoComment } from 's' import { MAccountDefault , MComment , MCommentOwnerVideoReply , MVideoFullLight } from 's' async function createVideoComment ( obj : { text : string , inReplyToComment : MComment | null , video : MVideoFullLight , account : MAccountDefault } , t : Sequelize . Transaction ) { let originCommentId : number | null = null let inReplyToCommentId : number | null = null if ( obj . inReplyToComment && obj . inReplyToComment !== null ) { originCommentId = obj . inReplyToComment . originCommentId || obj . inReplyToComment . id inReplyToCommentId = obj . inReplyToComment . id } const comment = await VideoCommentModel . create ( { text : obj . text , originCommentId , inReplyToCommentId , videoId : obj . video . id , accountId : obj . account . id , url : new Date ( ) . toISOString ( ) } , { transaction : t , validate : false } ) comment . url = getVideoCommentActivityPubUrl ( obj . video , comment ) const savedComment = await comment . save ( { transaction : t } ) savedComment . InReplyToVideoComment = obj . inReplyToComment savedComment . Video = obj . video savedComment . Account = obj . account await sendCreateVideoComment ( savedComment , t ) return savedComment } function buildFormattedCommentTree ( resultList < VideoCommentModel > ) { const comments = resultList . data const comment = comments . shift ( ) const thread = { comment : comment . toFormattedJSON ( ) , children : [ ] } const idx = { [ comment . id ] : thread } while ( comments . length !== 0 ) { const childComment = comments . shift ( ) const childCommentThread = { comment : childComment . toFormattedJSON ( ) , children : [ ] } const parentCommentThread = idx [ childComment . inReplyToCommentId ] if ( ! parentCommentThread ) continue parentCommentThread . children . push ( childCommentThread ) idx [ childComment . id ] = childCommentThread } return thread } export { createVideoComment , buildFormattedCommentTree }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MCommentOwnerVideoReply$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O $ResultList$ O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { ResultList } from 's' import { VideoCommentCreate } from 's' import { logger } from 's' import { getFormattedObjects } from 's' import { sequelizeTypescript } from 's' import { buildFormattedCommentTree , createVideoComment } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSort } from 's' import { addVideoCommentReplyValidator , addVideoCommentThreadValidator , listVideoCommentThreadsValidator , listVideoThreadCommentsValidator , removeVideoCommentValidator , videoCommentThreadsSortValidator } from 's' import { VideoCommentModel } from 's' import { auditLoggerFactory , CommentAuditView , getAuditIdFromRes } from 's' import { AccountModel } from 's' import { Notifier } from 's' import { Hooks } from 's' import { sendDeleteVideoComment } from 's' const auditLogger = auditLoggerFactory ( 's' ) const videoCommentRouter = express . Router ( ) videoCommentRouter . get ( 's' , paginationValidator , videoCommentThreadsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listVideoCommentThreadsValidator ) , optionalAuthenticate , asyncMiddleware ( listVideoThreads ) ) videoCommentRouter . get ( 's' , asyncMiddleware ( listVideoThreadCommentsValidator ) , optionalAuthenticate , asyncMiddleware ( listVideoThreadComments ) ) videoCommentRouter . post ( 's' , authenticate , asyncMiddleware ( addVideoCommentThreadValidator ) , asyncRetryTransactionMiddleware ( addVideoCommentThread ) ) videoCommentRouter . post ( 's' , authenticate , asyncMiddleware ( addVideoCommentReplyValidator ) , asyncRetryTransactionMiddleware ( addVideoCommentReply ) ) videoCommentRouter . delete ( 's' , authenticate , asyncMiddleware ( removeVideoCommentValidator ) , asyncRetryTransactionMiddleware ( removeVideoComment ) ) export { videoCommentRouter } async function listVideoThreads ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const user = res . locals . oauth ? res . locals . oauth . token . User : undefined let resultList < VideoCommentModel > if ( video . commentsEnabled === true ) { const apiOptions = await Hooks . wrapObject ( { videoId : video . id , start : req . query . start , count : req . query . count , sort : req . query . sort , user } , 's' ) resultList = await Hooks . wrapPromiseFun ( VideoCommentModel . listThreadsForApi , apiOptions , 's' ) } else { resultList = { total : 0 , data : [ ] } } return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listVideoThreadComments ( req : express . Request , res : express . Response ) { const video = res . locals . onlyVideo const user = res . locals . oauth ? res . locals . oauth . token . User : undefined let resultList < VideoCommentModel > if ( video . commentsEnabled === true ) { const apiOptions = await Hooks . wrapObject ( { videoId : video . id , threadId : res . locals . videoCommentThread . id , user } , 's' ) resultList = await Hooks . wrapPromiseFun ( VideoCommentModel . listThreadCommentsForApi , apiOptions , 's' ) } else { resultList = { total : 0 , data : [ ] } } return res . json ( buildFormattedCommentTree ( resultList ) ) } async function addVideoCommentThread ( req : express . Request , res : express . Response ) { const videoCommentInfo = req . body const comment = await sequelizeTypescript . transaction ( async t => { const account = await AccountModel . load ( res . locals . oauth . token . User . Account . id , t ) return createVideoComment ( { text : videoCommentInfo . text , inReplyToComment : null , video : res . locals . videoAll , account } , t ) } ) Notifier . Instance . notifyOnNewComment ( comment ) auditLogger . create ( getAuditIdFromRes ( res ) , new CommentAuditView ( comment . toFormattedJSON ( ) ) ) Hooks . runAction ( 's' , { comment } ) return res . json ( { comment : comment . toFormattedJSON ( ) } ) . end ( ) } async function addVideoCommentReply ( req : express . Request , res : express . Response ) { const videoCommentInfo = req . body const comment = await sequelizeTypescript . transaction ( async t => { const account = await AccountModel . load ( res . locals . oauth . token . User . Account . id , t ) return createVideoComment ( { text : videoCommentInfo . text , inReplyToComment : res . locals . videoCommentFull , video : res . locals . videoAll , account } , t ) } ) Notifier . Instance . notifyOnNewComment ( comment ) auditLogger . create ( getAuditIdFromRes ( res ) , new CommentAuditView ( comment . toFormattedJSON ( ) ) ) Hooks . runAction ( 's' , { comment } ) return res . json ( { comment : comment . toFormattedJSON ( ) } ) . end ( ) } async function removeVideoComment ( req : express . Request , res : express . Response ) { const videoCommentInstance = res . locals . videoCommentFull await sequelizeTypescript . transaction ( async t => { await videoCommentInstance . destroy ( { transaction : t } ) if ( videoCommentInstance . isOwned ( ) || videoCommentInstance . Video . isOwned ( ) ) { await sendDeleteVideoComment ( videoCommentInstance , t ) } } ) auditLogger . delete ( getAuditIdFromRes ( res ) , new CommentAuditView ( videoCommentInstance . toFormattedJSON ( ) ) ) logger . info ( 's' , videoCommentInstance . id ) Hooks . runAction ( 's' , { comment : videoCommentInstance } ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserVideoRateUpdate } from 's' import { logger } from 's' import { VIDEO_RATE_TYPES } from 's' import { getRateUrl , sendVideoRateChange } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , videoUpdateRateValidator } from 's' import { AccountModel } from 's' import { AccountVideoRateModel } from 's' import { sequelizeTypescript } from 's' const rateVideoRouter = express . Router ( ) rateVideoRouter . put ( 's' , authenticate , asyncMiddleware ( videoUpdateRateValidator ) , asyncRetryTransactionMiddleware ( rateVideo ) ) export { rateVideoRouter } async function rateVideo ( req : express . Request , res : express . Response ) { const body = req . body const rateType = body . rating const videoInstance = res . locals . videoAll const userAccount = res . locals . oauth . token . User . Account await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } const accountInstance = await AccountModel . load ( userAccount . id , t ) const previousRate = await AccountVideoRateModel . load ( accountInstance . id , videoInstance . id , t ) let likesToIncrement = 0 let dislikesToIncrement = 0 if ( rateType === VIDEO_RATE_TYPES . LIKE ) likesToIncrement ++ else if ( rateType === VIDEO_RATE_TYPES . DISLIKE ) dislikesToIncrement ++ if ( previousRate ) { if ( previousRate . type === 's' ) likesToIncrement -- else if ( previousRate . type === 's' ) dislikesToIncrement -- if ( rateType === 's' ) { await previousRate . destroy ( sequelizeOptions ) } else { previousRate . type = rateType previousRate . url = getRateUrl ( rateType , userAccount . Actor , videoInstance ) await previousRate . save ( sequelizeOptions ) } } else if ( rateType !== 's' ) { const query = { accountId : accountInstance . id , videoId : videoInstance . id , type : rateType , url : getRateUrl ( rateType , userAccount . Actor , videoInstance ) } await AccountVideoRateModel . create ( query , sequelizeOptions ) } const incrementQuery = { likes : likesToIncrement , dislikes : dislikesToIncrement } await videoInstance . increment ( incrementQuery , sequelizeOptions ) await sendVideoRateChange ( accountInstance , videoInstance , likesToIncrement , dislikesToIncrement , t ) logger . info ( 's' , videoInstance . name , accountInstance . name ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserVideoRateUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { logger } from 's' import { sequelizeTypescript } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , paginationValidator , setDefaultPagination , videosAcceptChangeOwnershipValidator , videosChangeOwnershipValidator , videosTerminateChangeOwnershipValidator } from 's' import { VideoChangeOwnershipModel } from 's' import { VideoChangeOwnershipStatus , VideoPrivacy , VideoState } from 's' import { VideoChannelModel } from 's' import { getFormattedObjects } from 's' import { changeVideoChannelShare } from 's' import { sendUpdateVideo } from 's' import { VideoModel } from 's' import { MVideoFullLight } from 's' const ownershipVideoRouter = express . Router ( ) ownershipVideoRouter . post ( 's' , authenticate , asyncMiddleware ( videosChangeOwnershipValidator ) , asyncRetryTransactionMiddleware ( giveVideoOwnership ) ) ownershipVideoRouter . get ( 's' , authenticate , paginationValidator , setDefaultPagination , asyncRetryTransactionMiddleware ( listVideoOwnership ) ) ownershipVideoRouter . post ( 's' , authenticate , asyncMiddleware ( videosTerminateChangeOwnershipValidator ) , asyncMiddleware ( videosAcceptChangeOwnershipValidator ) , asyncRetryTransactionMiddleware ( acceptOwnership ) ) ownershipVideoRouter . post ( 's' , authenticate , asyncMiddleware ( videosTerminateChangeOwnershipValidator ) , asyncRetryTransactionMiddleware ( refuseOwnership ) ) export { ownershipVideoRouter } async function giveVideoOwnership ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll const initiatorAccountId = res . locals . oauth . token . User . Account . id const nextOwner = res . locals . nextOwner await sequelizeTypescript . transaction ( t => { return VideoChangeOwnershipModel . findOrCreate ( { where : { initiatorAccountId , nextOwnerAccountId : nextOwner . id , videoId : videoInstance . id , status : VideoChangeOwnershipStatus . WAITING } , defaults : { initiatorAccountId , nextOwnerAccountId : nextOwner . id , videoId : videoInstance . id , status : VideoChangeOwnershipStatus . WAITING } , transaction : t } ) } ) logger . info ( 's' , videoInstance . name ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function listVideoOwnership ( req : express . Request , res : express . Response ) { const currentAccountId = res . locals . oauth . token . User . Account . id const resultList = await VideoChangeOwnershipModel . listForApi ( currentAccountId , req . query . start || 0 , req . query . count || 0 , req . query . sort || 's' ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function acceptOwnership ( req : express . Request , res : express . Response ) { return sequelizeTypescript . transaction ( async t => { const videoChangeOwnership = res . locals . videoChangeOwnership const channel = res . locals . videoChannel const targetVideo = await VideoModel . loadAndPopulateAccountAndServerAndTags ( videoChangeOwnership . Video . id ) const oldVideoChannel = await VideoChannelModel . loadByIdAndPopulateAccount ( targetVideo . channelId ) targetVideo . channelId = channel . id const targetVideoUpdated = await targetVideo . save ( { transaction : t } ) as MVideoFullLight targetVideoUpdated . VideoChannel = channel if ( targetVideoUpdated . privacy !== VideoPrivacy . PRIVATE && targetVideoUpdated . state === VideoState . PUBLISHED ) { await changeVideoChannelShare ( targetVideoUpdated , oldVideoChannel , t ) await sendUpdateVideo ( targetVideoUpdated , t , oldVideoChannel . Account . Actor ) } videoChangeOwnership . status = VideoChangeOwnershipStatus . ACCEPTED await videoChangeOwnership . save ( { transaction : t } ) return res . sendStatus ( 0 ) } ) } async function refuseOwnership ( req : express . Request , res : express . Response ) { return sequelizeTypescript . transaction ( async t => { const videoChangeOwnership = res . locals . videoChangeOwnership videoChangeOwnership . status = VideoChangeOwnershipStatus . REFUSED await videoChangeOwnership . save ( { transaction : t } ) return res . sendStatus ( 0 ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { join } from 's' import { CONFIG } from 's' import * as 0 from 's' import { createReadStream , createWriteStream , move , remove } from 's' import { MVideoCaptionFormattable } from 's' async function moveAndProcessCaptionFile ( physicalFile : { filename : string , path : string } , videoCaption ) { const videoCaptionsDir = CONFIG . STORAGE . CAPTIONS_DIR const destination = join ( videoCaptionsDir , videoCaption . getCaptionName ( ) ) if ( physicalFile . path . endsWith ( 's' ) ) { await convertSrtToVtt ( physicalFile . path , destination ) await remove ( physicalFile . path ) } else { await move ( physicalFile . path , destination , { overwrite : true } ) } physicalFile . filename = videoCaption . getCaptionName ( ) physicalFile . path = destination } export { moveAndProcessCaptionFile } function convertSrtToVtt ( source , destination ) { return new Promise ( ( res , rej ) => { const file = createReadStream ( source ) const converter = 0 ( ) const writer = createWriteStream ( destination ) for ( const s of [ file , converter , writer ] ) { s . on ( 's' , err => rej ( err ) ) } return file . pipe ( converter ) . pipe ( writer ) . on ( 's' , ( ) => res ( ) ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoCaptionFormattable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate } from 's' import { addVideoCaptionValidator , deleteVideoCaptionValidator , listVideoCaptionsValidator } from 's' import { createReqFiles } from 's' import { MIMETYPES } from 's' import { getFormattedObjects } from 's' import { VideoCaptionModel } from 's' import { logger } from 's' import { federateVideoIfNeeded } from 's' import { moveAndProcessCaptionFile } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { MVideoCaptionVideo } from 's' const reqVideoCaptionAdd = createReqFiles ( [ 's' ] , MIMETYPES . VIDEO_CAPTIONS . MIMETYPE_EXT , { captionfile : CONFIG . STORAGE . CAPTIONS_DIR } ) const videoCaptionsRouter = express . Router ( ) videoCaptionsRouter . get ( 's' , asyncMiddleware ( listVideoCaptionsValidator ) , asyncMiddleware ( listVideoCaptions ) ) videoCaptionsRouter . put ( 's' , authenticate , reqVideoCaptionAdd , asyncMiddleware ( addVideoCaptionValidator ) , asyncRetryTransactionMiddleware ( addVideoCaption ) ) videoCaptionsRouter . delete ( 's' , authenticate , asyncMiddleware ( deleteVideoCaptionValidator ) , asyncRetryTransactionMiddleware ( deleteVideoCaption ) ) export { videoCaptionsRouter } async function listVideoCaptions ( req : express . Request , res : express . Response ) { const data = await VideoCaptionModel . listVideoCaptions ( res . locals . videoId . id ) return res . json ( getFormattedObjects ( data , data . length ) ) } async function addVideoCaption ( req : express . Request , res : express . Response ) { const videoCaptionPhysicalFile = req . files [ 's' ] [ 0 ] const video = res . locals . videoAll const videoCaption = new VideoCaptionModel ( { videoId : video . id , language : req . params . captionLanguage } ) as MVideoCaptionVideo videoCaption . Video = video await moveAndProcessCaptionFile ( videoCaptionPhysicalFile , videoCaption ) await sequelizeTypescript . transaction ( async t => { await VideoCaptionModel . insertOrReplaceLanguage ( video . id , req . params . captionLanguage , t ) await federateVideoIfNeeded ( video , false , t ) } ) return res . status ( 0 ) . end ( ) } async function deleteVideoCaption ( req : express . Request , res : express . Response ) { const video = res . locals . videoAll const videoCaption = res . locals . videoCaption await sequelizeTypescript . transaction ( async t => { await videoCaption . destroy ( { transaction : t } ) await federateVideoIfNeeded ( video , false , t ) } ) logger . info ( 's' , videoCaption . language , video . uuid ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import * as magnetUtil from 's' import { auditLoggerFactory , getAuditIdFromRes , VideoImportAuditView } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , videoImportAddValidator } from 's' import { MIMETYPES } from 's' import { getYoutubeDLInfo , YoutubeDLInfo } from 's' import { createReqFiles } from 's' import { logger } from 's' import { VideoImportCreate , VideoImportState , VideoPrivacy , VideoState } from 's' import { VideoModel } from 's' import { getVideoActivityPubUrl } from 's' import { TagModel } from 's' import { VideoImportModel } from 's' import { JobQueue } from 's' import { join } from 's' import { isArray } from 's' import * as Bluebird from 's' import * as parseTorrent from 's' import { getSecureTorrentName } from 's' import { move , readFile } from 's' import { autoBlacklistVideoIfNeeded } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { createVideoMiniatureFromExisting } from 's' import { ThumbnailType } from 's' import { MChannelAccountDefault , MThumbnail , MUser , MVideoAccountDefault , MVideoTag , MVideoThumbnailAccountDefault , MVideoWithBlacklistLight } from 's' import { MVideoImport , MVideoImportFormattable } from 's' const auditLogger = auditLoggerFactory ( 's' ) const videoImportsRouter = express . Router ( ) const reqVideoFileImport = createReqFiles ( [ 's' , 's' , 's' ] , Object . assign ( { } , MIMETYPES . TORRENT . MIMETYPE_EXT , MIMETYPES . IMAGE . MIMETYPE_EXT ) , { thumbnailfile : CONFIG . STORAGE . TMP_DIR , previewfile : CONFIG . STORAGE . TMP_DIR , torrentfile : CONFIG . STORAGE . TMP_DIR } ) videoImportsRouter . post ( 's' , authenticate , reqVideoFileImport , asyncMiddleware ( videoImportAddValidator ) , asyncRetryTransactionMiddleware ( addVideoImport ) ) export { videoImportsRouter } function addVideoImport ( req : express . Request , res : express . Response ) { if ( req . body . targetUrl ) return addYoutubeDLImport ( req , res ) const file = req . files && req . files [ 's' ] ? req . files [ 's' ] [ 0 ] : undefined if ( req . body . magnetUri || file ) return addTorrentImport ( req , res , file ) } async function addTorrentImport ( req : express . Request , res : express . Response , torrentfile : Express . Multer . File ) { const body = req . body const user = res . locals . oauth . token . User let videoName let torrentName let magnetUri if ( torrentfile ) { torrentName = torrentfile . originalname const newTorrentPath = join ( CONFIG . STORAGE . TORRENTS_DIR , getSecureTorrentName ( torrentName ) ) await move ( torrentfile . path , newTorrentPath ) torrentfile . path = newTorrentPath const buf = await readFile ( torrentfile . path ) const parsedTorrent = parseTorrent ( buf ) videoName = isArray ( parsedTorrent . name ) ? parsedTorrent . name [ 0 ] : parsedTorrent . name as string } else { magnetUri = body . magnetUri const parsed = magnetUtil . decode ( magnetUri ) videoName = isArray ( parsed . name ) ? parsed . name [ 0 ] : parsed . name as string } const video = buildVideo ( res . locals . videoChannel . id , body , { name : videoName } ) const thumbnailModel = await processThumbnail ( req , video ) const previewModel = await processPreview ( req , video ) const tags = body . tags || undefined const videoImportAttributes = { magnetUri , torrentName , state : VideoImportState . PENDING , userId : user . id } const videoImport = await insertIntoDB ( { video , thumbnailModel , previewModel , videoChannel : res . locals . videoChannel , tags , videoImportAttributes , user } ) const payload = { type : torrentfile ? 's' as 's' : 's' as 's' , videoImportId : videoImport . id , magnetUri } await JobQueue . Instance . createJob ( { type : 's' , payload } ) auditLogger . create ( getAuditIdFromRes ( res ) , new VideoImportAuditView ( videoImport . toFormattedJSON ( ) ) ) return res . json ( videoImport . toFormattedJSON ( ) ) . end ( ) } async function addYoutubeDLImport ( req : express . Request , res : express . Response ) { const body = req . body const targetUrl = body . targetUrl const user = res . locals . oauth . token . User let youtubeDLInfo try { youtubeDLInfo = await getYoutubeDLInfo ( targetUrl ) } catch ( err ) { logger . info ( 's' , targetUrl , { err } ) return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } const video = buildVideo ( res . locals . videoChannel . id , body , youtubeDLInfo ) const thumbnailModel = await processThumbnail ( req , video ) const previewModel = await processPreview ( req , video ) const tags = body . tags || youtubeDLInfo . tags const videoImportAttributes = { targetUrl , state : VideoImportState . PENDING , userId : user . id } const videoImport = await insertIntoDB ( { video , thumbnailModel , previewModel , videoChannel : res . locals . videoChannel , tags , videoImportAttributes , user } ) const payload = { type : 's' as 's' , videoImportId : videoImport . id , thumbnailUrl : youtubeDLInfo . thumbnailUrl , downloadThumbnail : ! thumbnailModel , downloadPreview : ! previewModel } await JobQueue . Instance . createJob ( { type : 's' , payload } ) auditLogger . create ( getAuditIdFromRes ( res ) , new VideoImportAuditView ( videoImport . toFormattedJSON ( ) ) ) return res . json ( videoImport . toFormattedJSON ( ) ) . end ( ) } function buildVideo ( channelId , body , importData ) { const videoData = { name : body . name || importData . name || 's' , remote : false , category : body . category || importData . category , licence : body . licence || importData . licence , language : body . language || undefined , commentsEnabled : body . commentsEnabled !== false , downloadEnabled : body . downloadEnabled !== false , waitTranscoding : body . waitTranscoding || false , state : VideoState . TO_IMPORT , nsfw : body . nsfw || importData . nsfw || false , description : body . description || importData . description , support : body . support || null , privacy : body . privacy || VideoPrivacy . PRIVATE , duration : 0 , channelId : channelId , originallyPublishedAt : importData . originallyPublishedAt } const video = new VideoModel ( videoData ) video . url = getVideoActivityPubUrl ( video ) return video } async function processThumbnail ( req : express . Request , video ) { const thumbnailField = req . files ? req . files [ 's' ] : undefined if ( thumbnailField ) { const thumbnailPhysicalFile = thumbnailField [ 0 ] return createVideoMiniatureFromExisting ( thumbnailPhysicalFile . path , video , ThumbnailType . MINIATURE , false ) } return undefined } async function processPreview ( req : express . Request , video ) { const previewField = req . files ? req . files [ 's' ] : undefined if ( previewField ) { const previewPhysicalFile = previewField [ 0 ] return createVideoMiniatureFromExisting ( previewPhysicalFile . path , video , ThumbnailType . PREVIEW , false ) } return undefined } function insertIntoDB ( parameters : { video : MVideoThumbnailAccountDefault , thumbnailModel : MThumbnail , previewModel : MThumbnail , videoChannel : MChannelAccountDefault , tags : string [ ] , videoImportAttributes : Partial < MVideoImport > , user : MUser } ) < MVideoImportFormattable > { const { video , thumbnailModel , previewModel , videoChannel , tags , videoImportAttributes , user } = parameters return sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } const videoCreated = await video . save ( sequelizeOptions ) as ( MVideoAccountDefault & MVideoWithBlacklistLight & MVideoTag ) videoCreated . VideoChannel = videoChannel if ( thumbnailModel ) await videoCreated . addAndSaveThumbnail ( thumbnailModel , t ) if ( previewModel ) await videoCreated . addAndSaveThumbnail ( previewModel , t ) await autoBlacklistVideoIfNeeded ( { video : videoCreated , user , notify : false , isRemote : false , isNew : true , transaction : t } ) if ( tags ) { const tagInstances = await TagModel . findOrCreateTags ( tags , t ) await videoCreated . $set ( 's' , tagInstances , sequelizeOptions ) videoCreated . Tags = tagInstances } else { videoCreated . Tags = [ ] } const videoImport = await VideoImportModel . create ( Object . assign ( { videoId : videoCreated . id } , videoImportAttributes ) , sequelizeOptions ) as MVideoImportFormattable videoImport . Video = videoCreated return videoImport } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportCreate$ O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoImportCreate$ O O O O O O O O O O O O O O O O O O O O O O O $YoutubeDLInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoImportCreate$ O $YoutubeDLInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bluebird$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { UserWatchingVideo } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , videoWatchingValidator } from 's' import { UserVideoHistoryModel } from 's' const watchingRouter = express . Router ( ) watchingRouter . put ( 's' , authenticate , asyncMiddleware ( videoWatchingValidator ) , asyncRetryTransactionMiddleware ( userWatchVideo ) ) export { watchingRouter } async function userWatchVideo ( req : express . Request , res : express . Response ) { const user = res . locals . oauth . token . User const body = req . body const { id : videoId } = res . locals . videoId await UserVideoHistoryModel . upsert ( { videoId , userId : user . id , currentTime : body . currentTime } ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserWatchingVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Transaction } from 's' import { ActivityAudience , ActivityView } from 's' import { ActorModel } from 's' import { getVideoLikeActivityPubUrl } from 's' import { sendVideoRelatedActivity } from 's' import { audiencify , getAudience } from 's' import { logger } from 's' import { MActorAudience , MVideoAccountLight , MVideoUrl } from 's' async function sendView ( byActor , video , t ) { logger . info ( 's' , video . url ) const activityBuilder = ( audience ) => { const url = getVideoLikeActivityPubUrl ( byActor , video ) return buildViewActivity ( url , byActor , video , audience ) } return sendVideoRelatedActivity ( activityBuilder , { byActor , video , transaction : t } ) } function buildViewActivity ( url , byActor , video , audience ? ) { if ( ! audience ) audience = getAudience ( byActor ) return audiencify ( { id : url , type : 's' as 's' , actor : byActor . url , object : video . url } , audience ) } export { sendView }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActorModel$ O $MVideoAccountLight$ O $Transaction$ O O O O O O O O O O O O O O O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActivityView$ O $string$ O $MActorAudience$ O $MVideoUrl$ O O $ActivityAudience$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { extname , join } from 's' import { VideoCreate , VideoPrivacy , VideoState , VideoUpdate } from 's' import { getVideoFileFPS , getVideoFileResolution } from 's' import { logger } from 's' import { auditLoggerFactory , getAuditIdFromRes , VideoAuditView } from 's' import { getFormattedObjects , getServerActor } from 's' import { autoBlacklistVideoIfNeeded } from 's' import { DEFAULT_AUDIO_RESOLUTION , MIMETYPES , VIDEO_CATEGORIES , VIDEO_LANGUAGES , VIDEO_LICENCES , VIDEO_PRIVACIES } from 's' import { changeVideoChannelShare , federateVideoIfNeeded , fetchRemoteVideoDescription , getVideoActivityPubUrl } from 's' import { JobQueue } from 's' import { Redis } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , checkVideoFollowConstraints , commonVideosFiltersValidator , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSort , videosAddValidator , videosCustomGetValidator , videosGetValidator , videosRemoveValidator , videosSortValidator , videosUpdateValidator } from 's' import { TagModel } from 's' import { VideoModel } from 's' import { VideoFileModel } from 's' import { abuseVideoRouter } from 's' import { blacklistRouter } from 's' import { videoCommentRouter } from 's' import { rateVideoRouter } from 's' import { ownershipVideoRouter } from 's' import { VideoFilter } from 's' import { buildNSFWFilter , createReqFiles } from 's' import { ScheduleVideoUpdateModel } from 's' import { videoCaptionsRouter } from 's' import { videoImportsRouter } from 's' import { resetSequelizeInstance } from 's' import { move } from 's' import { watchingRouter } from 's' import { Notifier } from 's' import { sendView } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { createVideoMiniatureFromExisting , generateVideoMiniature } from 's' import { ThumbnailType } from 's' import { VideoTranscodingPayload } from 's' import { Hooks } from 's' import { MVideoDetails , MVideoFullLight } from 's' const auditLogger = auditLoggerFactory ( 's' ) const videosRouter = express . Router ( ) const reqVideoFileAdd = createReqFiles ( [ 's' , 's' , 's' ] , Object . assign ( { } , MIMETYPES . VIDEO . MIMETYPE_EXT , MIMETYPES . IMAGE . MIMETYPE_EXT ) , { videofile : CONFIG . STORAGE . TMP_DIR , thumbnailfile : CONFIG . STORAGE . TMP_DIR , previewfile : CONFIG . STORAGE . TMP_DIR } ) const reqVideoFileUpdate = createReqFiles ( [ 's' , 's' ] , MIMETYPES . IMAGE . MIMETYPE_EXT , { thumbnailfile : CONFIG . STORAGE . TMP_DIR , previewfile : CONFIG . STORAGE . TMP_DIR } ) videosRouter . use ( 's' , abuseVideoRouter ) videosRouter . use ( 's' , blacklistRouter ) videosRouter . use ( 's' , rateVideoRouter ) videosRouter . use ( 's' , videoCommentRouter ) videosRouter . use ( 's' , videoCaptionsRouter ) videosRouter . use ( 's' , videoImportsRouter ) videosRouter . use ( 's' , ownershipVideoRouter ) videosRouter . use ( 's' , watchingRouter ) videosRouter . get ( 's' , listVideoCategories ) videosRouter . get ( 's' , listVideoLicences ) videosRouter . get ( 's' , listVideoLanguages ) videosRouter . get ( 's' , listVideoPrivacies ) videosRouter . get ( 's' , paginationValidator , videosSortValidator , setDefaultSort , setDefaultPagination , optionalAuthenticate , commonVideosFiltersValidator , asyncMiddleware ( listVideos ) ) videosRouter . put ( 's' , authenticate , reqVideoFileUpdate , asyncMiddleware ( videosUpdateValidator ) , asyncRetryTransactionMiddleware ( updateVideo ) ) videosRouter . post ( 's' , authenticate , reqVideoFileAdd , asyncMiddleware ( videosAddValidator ) , asyncRetryTransactionMiddleware ( addVideo ) ) videosRouter . get ( 's' , asyncMiddleware ( videosGetValidator ) , asyncMiddleware ( getVideoDescription ) ) videosRouter . get ( 's' , optionalAuthenticate , asyncMiddleware ( videosCustomGetValidator ( 's' ) ) , asyncMiddleware ( checkVideoFollowConstraints ) , asyncMiddleware ( getVideo ) ) videosRouter . post ( 's' , asyncMiddleware ( videosGetValidator ) , asyncMiddleware ( viewVideo ) ) videosRouter . delete ( 's' , authenticate , asyncMiddleware ( videosRemoveValidator ) , asyncRetryTransactionMiddleware ( removeVideo ) ) export { videosRouter } function listVideoCategories ( req : express . Request , res : express . Response ) { res . json ( VIDEO_CATEGORIES ) } function listVideoLicences ( req : express . Request , res : express . Response ) { res . json ( VIDEO_LICENCES ) } function listVideoLanguages ( req : express . Request , res : express . Response ) { res . json ( VIDEO_LANGUAGES ) } function listVideoPrivacies ( req : express . Request , res : express . Response ) { res . json ( VIDEO_PRIVACIES ) } async function addVideo ( req : express . Request , res : express . Response ) { req . setTimeout ( 0 * 0 * 0 , ( ) => { logger . error ( 's' ) return res . sendStatus ( 0 ) } ) const videoPhysicalFile = req . files [ 's' ] [ 0 ] const videoInfo = req . body const videoData = { name : videoInfo . name , remote : false , category : videoInfo . category , licence : videoInfo . licence , language : videoInfo . language , commentsEnabled : videoInfo . commentsEnabled !== false , downloadEnabled : videoInfo . downloadEnabled !== false , waitTranscoding : videoInfo . waitTranscoding || false , state : CONFIG . TRANSCODING . ENABLED ? VideoState . TO_TRANSCODE : VideoState . PUBLISHED , nsfw : videoInfo . nsfw || false , description : videoInfo . description , support : videoInfo . support , privacy : videoInfo . privacy || VideoPrivacy . PRIVATE , duration : videoPhysicalFile [ 's' ] , channelId : res . locals . videoChannel . id , originallyPublishedAt : videoInfo . originallyPublishedAt } const video = new VideoModel ( videoData ) as MVideoDetails video . url = getVideoActivityPubUrl ( video ) const videoFile = new VideoFileModel ( { extname : extname ( videoPhysicalFile . filename ) , size : videoPhysicalFile . size } ) if ( videoFile . isAudio ( ) ) { videoFile . resolution = DEFAULT_AUDIO_RESOLUTION } else { videoFile . fps = await getVideoFileFPS ( videoPhysicalFile . path ) videoFile . resolution = ( await getVideoFileResolution ( videoPhysicalFile . path ) ) . videoFileResolution } const videoDir = CONFIG . STORAGE . VIDEOS_DIR const destination = join ( videoDir , video . getVideoFilename ( videoFile ) ) await move ( videoPhysicalFile . path , destination ) videoPhysicalFile . filename = video . getVideoFilename ( videoFile ) videoPhysicalFile . path = destination const thumbnailField = req . files [ 's' ] const thumbnailModel = thumbnailField ? await createVideoMiniatureFromExisting ( thumbnailField [ 0 ] . path , video , ThumbnailType . MINIATURE , false ) : await generateVideoMiniature ( video , videoFile , ThumbnailType . MINIATURE ) const previewField = req . files [ 's' ] const previewModel = previewField ? await createVideoMiniatureFromExisting ( previewField [ 0 ] . path , video , ThumbnailType . PREVIEW , false ) : await generateVideoMiniature ( video , videoFile , ThumbnailType . PREVIEW ) await video . createTorrentAndSetInfoHash ( videoFile ) const { videoCreated } = await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } const videoCreated = await video . save ( sequelizeOptions ) as MVideoFullLight await videoCreated . addAndSaveThumbnail ( thumbnailModel , t ) await videoCreated . addAndSaveThumbnail ( previewModel , t ) videoCreated . VideoChannel = res . locals . videoChannel videoFile . videoId = video . id await videoFile . save ( sequelizeOptions ) video . VideoFiles = [ videoFile ] if ( videoInfo . tags !== undefined ) { const tagInstances = await TagModel . findOrCreateTags ( videoInfo . tags , t ) await video . $set ( 's' , tagInstances , sequelizeOptions ) video . Tags = tagInstances } if ( videoInfo . scheduleUpdate ) { await ScheduleVideoUpdateModel . create ( { videoId : video . id , updateAt : videoInfo . scheduleUpdate . updateAt , privacy : videoInfo . scheduleUpdate . privacy || null } , { transaction : t } ) } await autoBlacklistVideoIfNeeded ( { video , user : res . locals . oauth . token . User , isRemote : false , isNew : true , transaction : t } ) await federateVideoIfNeeded ( video , true , t ) auditLogger . create ( getAuditIdFromRes ( res ) , new VideoAuditView ( videoCreated . toFormattedDetailsJSON ( ) ) ) logger . info ( 's' , videoInfo . name , videoCreated . uuid ) return { videoCreated } } ) Notifier . Instance . notifyOnNewVideoIfNeeded ( videoCreated ) if ( video . state === VideoState . TO_TRANSCODE ) { let dataInput if ( videoFile . isAudio ( ) ) { dataInput = { type : 's' as 's' , resolution : DEFAULT_AUDIO_RESOLUTION , videoUUID : videoCreated . uuid , isNewVideo : true } } else { dataInput = { type : 's' as 's' , videoUUID : videoCreated . uuid , isNewVideo : true } } await JobQueue . Instance . createJob ( { type : 's' , payload : dataInput } ) } Hooks . runAction ( 's' , { video : videoCreated } ) return res . json ( { video : { id : videoCreated . id , uuid : videoCreated . uuid } } ) . end ( ) } async function updateVideo ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll const videoFieldsSave = videoInstance . toJSON ( ) const oldVideoAuditView = new VideoAuditView ( videoInstance . toFormattedDetailsJSON ( ) ) const videoInfoToUpdate = req . body const wasPrivateVideo = videoInstance . privacy === VideoPrivacy . PRIVATE const wasNotPrivateVideo = videoInstance . privacy !== VideoPrivacy . PRIVATE const wasUnlistedVideo = videoInstance . privacy === VideoPrivacy . UNLISTED const thumbnailModel = req . files && req . files [ 's' ] ? await createVideoMiniatureFromExisting ( req . files [ 's' ] [ 0 ] . path , videoInstance , ThumbnailType . MINIATURE , false ) : undefined const previewModel = req . files && req . files [ 's' ] ? await createVideoMiniatureFromExisting ( req . files [ 's' ] [ 0 ] . path , videoInstance , ThumbnailType . PREVIEW , false ) : undefined try { const videoInstanceUpdated = await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } const oldVideoChannel = videoInstance . VideoChannel if ( videoInfoToUpdate . name !== undefined ) videoInstance . name = videoInfoToUpdate . name if ( videoInfoToUpdate . category !== undefined ) videoInstance . category = videoInfoToUpdate . category if ( videoInfoToUpdate . licence !== undefined ) videoInstance . licence = videoInfoToUpdate . licence if ( videoInfoToUpdate . language !== undefined ) videoInstance . language = videoInfoToUpdate . language if ( videoInfoToUpdate . nsfw !== undefined ) videoInstance . nsfw = videoInfoToUpdate . nsfw if ( videoInfoToUpdate . waitTranscoding !== undefined ) videoInstance . waitTranscoding = videoInfoToUpdate . waitTranscoding if ( videoInfoToUpdate . support !== undefined ) videoInstance . support = videoInfoToUpdate . support if ( videoInfoToUpdate . description !== undefined ) videoInstance . description = videoInfoToUpdate . description if ( videoInfoToUpdate . commentsEnabled !== undefined ) videoInstance . commentsEnabled = videoInfoToUpdate . commentsEnabled if ( videoInfoToUpdate . downloadEnabled !== undefined ) videoInstance . downloadEnabled = videoInfoToUpdate . downloadEnabled if ( videoInfoToUpdate . originallyPublishedAt !== undefined && videoInfoToUpdate . originallyPublishedAt !== null ) { videoInstance . originallyPublishedAt = new Date ( videoInfoToUpdate . originallyPublishedAt ) } if ( videoInfoToUpdate . privacy !== undefined ) { const newPrivacy = parseInt ( videoInfoToUpdate . privacy . toString ( ) , 0 ) videoInstance . privacy = newPrivacy if ( wasPrivateVideo === true && newPrivacy !== VideoPrivacy . PRIVATE ) { videoInstance . publishedAt = new Date ( ) } if ( wasNotPrivateVideo === true && newPrivacy === VideoPrivacy . PRIVATE ) { await VideoModel . sendDelete ( videoInstance , { transaction : t } ) } } const videoInstanceUpdated = await videoInstance . save ( sequelizeOptions ) as MVideoFullLight if ( thumbnailModel ) await videoInstanceUpdated . addAndSaveThumbnail ( thumbnailModel , t ) if ( previewModel ) await videoInstanceUpdated . addAndSaveThumbnail ( previewModel , t ) if ( videoInfoToUpdate . tags !== undefined ) { const tagInstances = await TagModel . findOrCreateTags ( videoInfoToUpdate . tags , t ) await videoInstanceUpdated . $set ( 's' , tagInstances , sequelizeOptions ) videoInstanceUpdated . Tags = tagInstances } if ( res . locals . videoChannel && videoInstanceUpdated . channelId !== res . locals . videoChannel . id ) { await videoInstanceUpdated . $set ( 's' , res . locals . videoChannel , { transaction : t } ) videoInstanceUpdated . VideoChannel = res . locals . videoChannel if ( wasPrivateVideo === false ) await changeVideoChannelShare ( videoInstanceUpdated , oldVideoChannel , t ) } if ( videoInfoToUpdate . scheduleUpdate ) { await ScheduleVideoUpdateModel . upsert ( { videoId : videoInstanceUpdated . id , updateAt : videoInfoToUpdate . scheduleUpdate . updateAt , privacy : videoInfoToUpdate . scheduleUpdate . privacy || null } , { transaction : t } ) } else if ( videoInfoToUpdate . scheduleUpdate === null ) { await ScheduleVideoUpdateModel . deleteByVideoId ( videoInstanceUpdated . id , t ) } await autoBlacklistVideoIfNeeded ( { video : videoInstanceUpdated , user : res . locals . oauth . token . User , isRemote : false , isNew : false , transaction : t } ) const isNewVideo = wasPrivateVideo && videoInstanceUpdated . privacy !== VideoPrivacy . PRIVATE await federateVideoIfNeeded ( videoInstanceUpdated , isNewVideo , t ) auditLogger . update ( getAuditIdFromRes ( res ) , new VideoAuditView ( videoInstanceUpdated . toFormattedDetailsJSON ( ) ) , oldVideoAuditView ) logger . info ( 's' , videoInstance . name , videoInstance . uuid ) return videoInstanceUpdated } ) if ( wasUnlistedVideo || wasPrivateVideo ) { Notifier . Instance . notifyOnNewVideoIfNeeded ( videoInstanceUpdated ) } Hooks . runAction ( 's' , { video : videoInstanceUpdated } ) } catch ( err ) { resetSequelizeInstance ( videoInstance , videoFieldsSave ) throw err } return res . type ( 's' ) . status ( 0 ) . end ( ) } async function getVideo ( req : express . Request , res : express . Response ) { const userId = res . locals . oauth ? res . locals . oauth . token . User . id : null const video = await Hooks . wrapPromiseFun ( VideoModel . loadForGetAPI , { id : res . locals . onlyVideoWithRights . id , userId } , 's' ) if ( video . isOutdated ( ) ) { JobQueue . Instance . createJob ( { type : 's' , payload : { type : 's' , url : video . url } } ) . catch ( err => logger . error ( 's' , video . url , { err } ) ) } return res . json ( video . toFormattedDetailsJSON ( ) ) } async function viewVideo ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll const ip = req . ip const exists = await Redis . Instance . doesVideoIPViewExist ( ip , videoInstance . uuid ) if ( exists ) { logger . debug ( 's' , ip , videoInstance . uuid ) return res . status ( 0 ) . end ( ) } await Promise . all ( [ Redis . Instance . addVideoView ( videoInstance . id ) , Redis . Instance . setIPVideoView ( ip , videoInstance . uuid ) ] ) const serverActor = await getServerActor ( ) await sendView ( serverActor , videoInstance , undefined ) Hooks . runAction ( 's' , { video : videoInstance , ip } ) return res . status ( 0 ) . end ( ) } async function getVideoDescription ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll let description = 's' if ( videoInstance . isOwned ( ) ) { description = videoInstance . description } else { description = await fetchRemoteVideoDescription ( videoInstance ) } return res . json ( { description } ) } async function listVideos ( req : express . Request , res : express . Response ) { const apiOptions = await Hooks . wrapObject ( { start : req . query . start , count : req . query . count , sort : req . query . sort , includeLocalVideos : true , categoryOneOf : req . query . categoryOneOf , licenceOneOf : req . query . licenceOneOf , languageOneOf : req . query . languageOneOf , tagsOneOf : req . query . tagsOneOf , tagsAllOf : req . query . tagsAllOf , nsfw : buildNSFWFilter ( res , req . query . nsfw ) , filter : req . query . filter as VideoFilter , withFiles : false , user : res . locals . oauth ? res . locals . oauth . token . User : undefined } , 's' ) const resultList = await Hooks . wrapPromiseFun ( VideoModel . listForApi , apiOptions , 's' ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function removeVideo ( req : express . Request , res : express . Response ) { const videoInstance = res . locals . videoAll await sequelizeTypescript . transaction ( async t => { await videoInstance . destroy ( { transaction : t } ) } ) auditLogger . delete ( getAuditIdFromRes ( res ) , new VideoAuditView ( videoInstance . toFormattedDetailsJSON ( ) ) ) logger . info ( 's' , videoInstance . name , videoInstance . uuid ) Hooks . runAction ( 's' , { video : videoInstance } ) return res . type ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoTranscodingPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { getFormattedObjects , getServerActor } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , commonVideosFiltersValidator , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSort , videoChannelsAddValidator , videoChannelsRemoveValidator , videoChannelsSortValidator , videoChannelsUpdateValidator , videoPlaylistsSortValidator } from 's' import { VideoChannelModel } from 's' import { videoChannelsNameWithHostValidator , videosSortValidator } from 's' import { sendUpdateActor } from 's' import { VideoChannelCreate , VideoChannelUpdate } from 's' import { createLocalVideoChannel , federateAllVideosOfChannel } from 's' import { buildNSFWFilter , createReqFiles , isUserAbleToSearchRemoteURI } from 's' import { setAsyncActorKeys } from 's' import { AccountModel } from 's' import { MIMETYPES } from 's' import { logger } from 's' import { VideoModel } from 's' import { updateAvatarValidator } from 's' import { updateActorAvatarFile } from 's' import { auditLoggerFactory , getAuditIdFromRes , VideoChannelAuditView } from 's' import { resetSequelizeInstance } from 's' import { JobQueue } from 's' import { VideoPlaylistModel } from 's' import { commonVideoPlaylistFiltersValidator } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { MChannelAccountDefault } from 's' const auditLogger = auditLoggerFactory ( 's' ) const reqAvatarFile = createReqFiles ( [ 's' ] , MIMETYPES . IMAGE . MIMETYPE_EXT , { avatarfile : CONFIG . STORAGE . TMP_DIR } ) const videoChannelRouter = express . Router ( ) videoChannelRouter . get ( 's' , paginationValidator , videoChannelsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listVideoChannels ) ) videoChannelRouter . post ( 's' , authenticate , asyncMiddleware ( videoChannelsAddValidator ) , asyncRetryTransactionMiddleware ( addVideoChannel ) ) videoChannelRouter . post ( 's' , authenticate , reqAvatarFile , asyncMiddleware ( videoChannelsUpdateValidator ) , updateAvatarValidator , asyncMiddleware ( updateVideoChannelAvatar ) ) videoChannelRouter . put ( 's' , authenticate , asyncMiddleware ( videoChannelsUpdateValidator ) , asyncRetryTransactionMiddleware ( updateVideoChannel ) ) videoChannelRouter . delete ( 's' , authenticate , asyncMiddleware ( videoChannelsRemoveValidator ) , asyncRetryTransactionMiddleware ( removeVideoChannel ) ) videoChannelRouter . get ( 's' , asyncMiddleware ( videoChannelsNameWithHostValidator ) , asyncMiddleware ( getVideoChannel ) ) videoChannelRouter . get ( 's' , asyncMiddleware ( videoChannelsNameWithHostValidator ) , paginationValidator , videoPlaylistsSortValidator , setDefaultSort , setDefaultPagination , commonVideoPlaylistFiltersValidator , asyncMiddleware ( listVideoChannelPlaylists ) ) videoChannelRouter . get ( 's' , asyncMiddleware ( videoChannelsNameWithHostValidator ) , paginationValidator , videosSortValidator , setDefaultSort , setDefaultPagination , optionalAuthenticate , commonVideosFiltersValidator , asyncMiddleware ( listVideoChannelVideos ) ) export { videoChannelRouter } async function listVideoChannels ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await VideoChannelModel . listForApi ( serverActor . id , req . query . start , req . query . count , req . query . sort ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function updateVideoChannelAvatar ( req : express . Request , res : express . Response ) { const avatarPhysicalFile = req . files [ 's' ] [ 0 ] const videoChannel = res . locals . videoChannel const oldVideoChannelAuditKeys = new VideoChannelAuditView ( videoChannel . toFormattedJSON ( ) ) const avatar = await updateActorAvatarFile ( avatarPhysicalFile , videoChannel ) auditLogger . update ( getAuditIdFromRes ( res ) , new VideoChannelAuditView ( videoChannel . toFormattedJSON ( ) ) , oldVideoChannelAuditKeys ) return res . json ( { avatar : avatar . toFormattedJSON ( ) } ) . end ( ) } async function addVideoChannel ( req : express . Request , res : express . Response ) { const videoChannelInfo = req . body const videoChannelCreated = await sequelizeTypescript . transaction ( async t => { const account = await AccountModel . load ( res . locals . oauth . token . User . Account . id , t ) return createLocalVideoChannel ( videoChannelInfo , account , t ) } ) setAsyncActorKeys ( videoChannelCreated . Actor ) . catch ( err => logger . error ( 's' , videoChannelCreated . Actor . url , { err } ) ) auditLogger . create ( getAuditIdFromRes ( res ) , new VideoChannelAuditView ( videoChannelCreated . toFormattedJSON ( ) ) ) logger . info ( 's' , videoChannelCreated . Actor . url ) return res . json ( { videoChannel : { id : videoChannelCreated . id } } ) . end ( ) } async function updateVideoChannel ( req : express . Request , res : express . Response ) { const videoChannelInstance = res . locals . videoChannel const videoChannelFieldsSave = videoChannelInstance . toJSON ( ) const oldVideoChannelAuditKeys = new VideoChannelAuditView ( videoChannelInstance . toFormattedJSON ( ) ) const videoChannelInfoToUpdate = req . body as VideoChannelUpdate let doBulkVideoUpdate = false try { await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } if ( videoChannelInfoToUpdate . displayName !== undefined ) videoChannelInstance . name = videoChannelInfoToUpdate . displayName if ( videoChannelInfoToUpdate . description !== undefined ) videoChannelInstance . description = videoChannelInfoToUpdate . description if ( videoChannelInfoToUpdate . support !== undefined ) { const oldSupportField = videoChannelInstance . support videoChannelInstance . support = videoChannelInfoToUpdate . support if ( videoChannelInfoToUpdate . bulkVideosSupportUpdate === true && oldSupportField !== videoChannelInfoToUpdate . support ) { doBulkVideoUpdate = true await VideoModel . bulkUpdateSupportField ( videoChannelInstance , t ) } } const videoChannelInstanceUpdated = await videoChannelInstance . save ( sequelizeOptions ) as MChannelAccountDefault await sendUpdateActor ( videoChannelInstanceUpdated , t ) auditLogger . update ( getAuditIdFromRes ( res ) , new VideoChannelAuditView ( videoChannelInstanceUpdated . toFormattedJSON ( ) ) , oldVideoChannelAuditKeys ) logger . info ( 's' , videoChannelInstance . Actor . url ) } ) } catch ( err ) { logger . debug ( 's' , { err } ) resetSequelizeInstance ( videoChannelInstance , videoChannelFieldsSave ) throw err } res . type ( 's' ) . status ( 0 ) . end ( ) if ( doBulkVideoUpdate ) { await federateAllVideosOfChannel ( videoChannelInstance ) } } async function removeVideoChannel ( req : express . Request , res : express . Response ) { const videoChannelInstance = res . locals . videoChannel await sequelizeTypescript . transaction ( async t => { await VideoPlaylistModel . resetPlaylistsOfChannel ( videoChannelInstance . id , t ) await videoChannelInstance . destroy ( { transaction : t } ) auditLogger . delete ( getAuditIdFromRes ( res ) , new VideoChannelAuditView ( videoChannelInstance . toFormattedJSON ( ) ) ) logger . info ( 's' , videoChannelInstance . Actor . url ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function getVideoChannel ( req : express . Request , res : express . Response ) { const videoChannelWithVideos = await VideoChannelModel . loadAndPopulateAccountAndVideos ( res . locals . videoChannel . id ) if ( videoChannelWithVideos . isOutdated ( ) ) { JobQueue . Instance . createJob ( { type : 's' , payload : { type : 's' , url : videoChannelWithVideos . Actor . url } } ) . catch ( err => logger . error ( 's' , videoChannelWithVideos . Actor . url , { err } ) ) } return res . json ( videoChannelWithVideos . toFormattedJSON ( ) ) } async function listVideoChannelPlaylists ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await VideoPlaylistModel . listForApi ( { followerActorId : serverActor . id , start : req . query . start , count : req . query . count , sort : req . query . sort , videoChannelId : res . locals . videoChannel . id , type : req . query . playlistType } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function listVideoChannelVideos ( req : express . Request , res : express . Response ) { const videoChannelInstance = res . locals . videoChannel const followerActorId = isUserAbleToSearchRemoteURI ( res ) ? null : undefined const resultList = await VideoModel . listForApi ( { followerActorId , start : req . query . start , count : req . query . count , sort : req . query . sort , includeLocalVideos : true , categoryOneOf : req . query . categoryOneOf , licenceOneOf : req . query . licenceOneOf , languageOneOf : req . query . languageOneOf , tagsOneOf : req . query . tagsOneOf , tagsAllOf : req . query . tagsAllOf , filter : req . query . filter , nsfw : buildNSFWFilter ( res , req . query . nsfw ) , withFiles : false , videoChannelId : videoChannelInstance . id , user : res . locals . oauth ? res . locals . oauth . token . User : undefined } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { buildNSFWFilter , isUserAbleToSearchRemoteURI } from 's' import { getFormattedObjects , getServerActor } from 's' import { VideoModel } from 's' import { asyncMiddleware , commonVideosFiltersValidator , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSearchSort , videoChannelsSearchSortValidator , videoChannelsSearchValidator , videosSearchSortValidator , videosSearchValidator } from 's' import { VideoChannelsSearchQuery , VideosSearchQuery } from 's' import { getOrCreateActorAndServerAndModel , getOrCreateVideoAndAccountAndChannel } from 's' import { logger } from 's' import { VideoChannelModel } from 's' import { loadActorUrlOrGetFromWebfinger } from 's' import { MChannelAccountDefault , MVideoAccountLightBlacklistAllFiles } from 's' const searchRouter = express . Router ( ) searchRouter . get ( 's' , paginationValidator , setDefaultPagination , videosSearchSortValidator , setDefaultSearchSort , optionalAuthenticate , commonVideosFiltersValidator , videosSearchValidator , asyncMiddleware ( searchVideos ) ) searchRouter . get ( 's' , paginationValidator , setDefaultPagination , videoChannelsSearchSortValidator , setDefaultSearchSort , optionalAuthenticate , videoChannelsSearchValidator , asyncMiddleware ( searchVideoChannels ) ) export { searchRouter } function searchVideoChannels ( req : express . Request , res : express . Response ) { const query = req . query const search = query . search const isURISearch = search . startsWith ( 's' ) || search . startsWith ( 's' ) const parts = search . split ( 's' ) if ( parts . length === 0 && parts [ 0 ] . length === 0 ) parts . shift ( ) const isWebfingerSearch = parts . length === 0 && parts . every ( p => p && p . indexOf ( 's' ) === - 0 ) if ( isURISearch || isWebfingerSearch ) return searchVideoChannelURI ( search , isWebfingerSearch , res ) if ( query . search . startsWith ( 's' ) ) query . search = query . search . replace ( "s" , 's' ) return searchVideoChannelsDB ( query , res ) } async function searchVideoChannelsDB ( query , res : express . Response ) { const serverActor = await getServerActor ( ) const options = { actorId : serverActor . id , search : query . search , start : query . start , count : query . count , sort : query . sort } const resultList = await VideoChannelModel . searchForApi ( options ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function searchVideoChannelURI ( search , isWebfingerSearch , res : express . Response ) { let videoChannel let uri = search if ( isWebfingerSearch ) { try { uri = await loadActorUrlOrGetFromWebfinger ( search ) } catch ( err ) { logger . warn ( 's' , { search , err } ) return res . json ( { total : 0 , data : [ ] } ) } } if ( isUserAbleToSearchRemoteURI ( res ) ) { try { const actor = await getOrCreateActorAndServerAndModel ( uri , 's' , true , true ) videoChannel = actor . VideoChannel } catch ( err ) { logger . info ( 's' , uri , { err } ) } } else { videoChannel = await VideoChannelModel . loadByUrlAndPopulateAccount ( uri ) } return res . json ( { total : videoChannel ? 0 : 0 , data : videoChannel ? [ videoChannel . toFormattedJSON ( ) ] : [ ] } ) } function searchVideos ( req : express . Request , res : express . Response ) { const query = req . query const search = query . search if ( search && ( search . startsWith ( 's' ) || search . startsWith ( 's' ) ) ) { return searchVideoURI ( search , res ) } return searchVideosDB ( query , res ) } async function searchVideosDB ( query , res : express . Response ) { const options = Object . assign ( query , { includeLocalVideos : true , nsfw : buildNSFWFilter ( res , query . nsfw ) , filter : query . filter , user : res . locals . oauth ? res . locals . oauth . token . User : undefined } ) const resultList = await VideoModel . searchAndPopulateAccountAndServer ( options ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } async function searchVideoURI ( url , res : express . Response ) { let video if ( isUserAbleToSearchRemoteURI ( res ) ) { try { const syncParam = { likes : false , dislikes : false , shares : false , comments : false , thumbnail : true , refreshVideo : false } const result = await getOrCreateVideoAndAccountAndChannel ( { videoObject : url , syncParam } ) video = result ? result . video : undefined } catch ( err ) { logger . info ( 's' , url , { err } ) } } else { video = await VideoModel . loadByUrlAndPopulateAccount ( url ) } return res . json ( { total : video ? 0 : 0 , data : video ? [ video . toFormattedJSON ( ) ] : [ ] } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelsSearchQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelsSearchQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O $MChannelAccountDefault$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosSearchQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosSearchQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $MVideoAccountLightBlacklistAllFiles$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { buildNSFWFilter } from 's' import { VideoModel } from 's' import { asyncMiddleware } from 's' import { TagModel } from 's' import { VideosOverview } from 's' import { MEMOIZE_TTL , OVERVIEWS , ROUTE_CACHE_LIFETIME } from 's' import { cacheRoute } from 's' import * as memoizee from 's' const overviewsRouter = express . Router ( ) overviewsRouter . get ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . OVERVIEWS . VIDEOS ) ) , asyncMiddleware ( getVideosOverview ) ) export { overviewsRouter } const buildSamples = memoizee ( async function ( ) { const [ categories , channels , tags ] = await Promise . all ( [ VideoModel . getRandomFieldSamples ( 's' , OVERVIEWS . VIDEOS . SAMPLE_THRESHOLD , OVERVIEWS . VIDEOS . SAMPLES_COUNT ) , VideoModel . getRandomFieldSamples ( 's' , OVERVIEWS . VIDEOS . SAMPLE_THRESHOLD , OVERVIEWS . VIDEOS . SAMPLES_COUNT ) , TagModel . getRandomSamples ( OVERVIEWS . VIDEOS . SAMPLE_THRESHOLD , OVERVIEWS . VIDEOS . SAMPLES_COUNT ) ] ) return { categories , channels , tags } } , { maxAge : MEMOIZE_TTL . OVERVIEWS_SAMPLE } ) async function getVideosOverview ( req : express . Request , res : express . Response ) { const attributes = await buildSamples ( ) const [ categories , channels , tags ] = await Promise . all ( [ Promise . all ( attributes . categories . map ( c => getVideosByCategory ( c , res ) ) ) , Promise . all ( attributes . channels . map ( c => getVideosByChannel ( c , res ) ) ) , Promise . all ( attributes . tags . map ( t => getVideosByTag ( t , res ) ) ) ] ) const result = { categories , channels , tags } for ( const key of Object . keys ( result ) ) { result [ key ] = result [ key ] . filter ( v => v !== undefined ) } return res . json ( result ) } async function getVideosByTag ( tag , res : express . Response ) { const videos = await getVideos ( res , { tagsOneOf : [ tag ] } ) if ( videos . length === 0 ) return undefined return { tag , videos } } async function getVideosByCategory ( category , res : express . Response ) { const videos = await getVideos ( res , { categoryOneOf : [ category ] } ) if ( videos . length === 0 ) return undefined return { category : videos [ 0 ] . category , videos } } async function getVideosByChannel ( channelId , res : express . Response ) { const videos = await getVideos ( res , { videoChannelId : channelId } ) if ( videos . length === 0 ) return undefined return { channel : videos [ 0 ] . channel , videos } } async function getVideos ( res : express . Response , where : { videoChannelId ? : number , tagsOneOf ? : string [ ] , categoryOneOf ? : number [ ] } ) { const query = Object . assign ( { start : 0 , count : 0 , sort : 's' , includeLocalVideos : true , nsfw : buildNSFWFilter ( res ) , withFiles : false } , where ) const { data } = await VideoModel . listForApi ( query , false ) return data . map ( d => d . toFormattedJSON ( ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosOverview$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface VideoPlaylistReorder { startPosition : number insertAfterPosition : number reorderLength ? : number }	O O O O O O O O O O O O O O O
import * as express from 's' import { getFormattedObjects , getServerActor } from 's' import { asyncMiddleware , asyncRetryTransactionMiddleware , authenticate , optionalAuthenticate , paginationValidator , setDefaultPagination , setDefaultSort } from 's' import { videoPlaylistsSortValidator } from 's' import { buildNSFWFilter , createReqFiles } from 's' import { MIMETYPES , VIDEO_PLAYLIST_PRIVACIES } from 's' import { logger } from 's' import { resetSequelizeInstance } from 's' import { VideoPlaylistModel } from 's' import { commonVideoPlaylistFiltersValidator , videoPlaylistsAddValidator , videoPlaylistsAddVideoValidator , videoPlaylistsDeleteValidator , videoPlaylistsGetValidator , videoPlaylistsReorderVideosValidator , videoPlaylistsUpdateOrRemoveVideoValidator , videoPlaylistsUpdateValidator } from 's' import { VideoPlaylistCreate } from 's' import { VideoPlaylistPrivacy } from 's' import { join } from 's' import { sendCreateVideoPlaylist , sendDeleteVideoPlaylist , sendUpdateVideoPlaylist } from 's' import { getVideoPlaylistActivityPubUrl , getVideoPlaylistElementActivityPubUrl } from 's' import { VideoPlaylistUpdate } from 's' import { VideoPlaylistElementModel } from 's' import { VideoPlaylistElementCreate } from 's' import { VideoPlaylistElementUpdate } from 's' import { AccountModel } from 's' import { VideoPlaylistReorder } from 's' import { JobQueue } from 's' import { CONFIG } from 's' import { sequelizeTypescript } from 's' import { createPlaylistMiniatureFromExisting } from 's' import { MVideoPlaylistFull , MVideoPlaylistThumbnail , MVideoThumbnail } from 's' const reqThumbnailFile = createReqFiles ( [ 's' ] , MIMETYPES . IMAGE . MIMETYPE_EXT , { thumbnailfile : CONFIG . STORAGE . TMP_DIR } ) const videoPlaylistRouter = express . Router ( ) videoPlaylistRouter . get ( 's' , listVideoPlaylistPrivacies ) videoPlaylistRouter . get ( 's' , paginationValidator , videoPlaylistsSortValidator , setDefaultSort , setDefaultPagination , commonVideoPlaylistFiltersValidator , asyncMiddleware ( listVideoPlaylists ) ) videoPlaylistRouter . get ( 's' , asyncMiddleware ( videoPlaylistsGetValidator ( 's' ) ) , getVideoPlaylist ) videoPlaylistRouter . post ( 's' , authenticate , reqThumbnailFile , asyncMiddleware ( videoPlaylistsAddValidator ) , asyncRetryTransactionMiddleware ( addVideoPlaylist ) ) videoPlaylistRouter . put ( 's' , authenticate , reqThumbnailFile , asyncMiddleware ( videoPlaylistsUpdateValidator ) , asyncRetryTransactionMiddleware ( updateVideoPlaylist ) ) videoPlaylistRouter . delete ( 's' , authenticate , asyncMiddleware ( videoPlaylistsDeleteValidator ) , asyncRetryTransactionMiddleware ( removeVideoPlaylist ) ) videoPlaylistRouter . get ( 's' , asyncMiddleware ( videoPlaylistsGetValidator ( 's' ) ) , paginationValidator , setDefaultPagination , optionalAuthenticate , asyncMiddleware ( getVideoPlaylistVideos ) ) videoPlaylistRouter . post ( 's' , authenticate , asyncMiddleware ( videoPlaylistsAddVideoValidator ) , asyncRetryTransactionMiddleware ( addVideoInPlaylist ) ) videoPlaylistRouter . post ( 's' , authenticate , asyncMiddleware ( videoPlaylistsReorderVideosValidator ) , asyncRetryTransactionMiddleware ( reorderVideosPlaylist ) ) videoPlaylistRouter . put ( 's' , authenticate , asyncMiddleware ( videoPlaylistsUpdateOrRemoveVideoValidator ) , asyncRetryTransactionMiddleware ( updateVideoPlaylistElement ) ) videoPlaylistRouter . delete ( 's' , authenticate , asyncMiddleware ( videoPlaylistsUpdateOrRemoveVideoValidator ) , asyncRetryTransactionMiddleware ( removeVideoFromPlaylist ) ) export { videoPlaylistRouter } function listVideoPlaylistPrivacies ( req : express . Request , res : express . Response ) { res . json ( VIDEO_PLAYLIST_PRIVACIES ) } async function listVideoPlaylists ( req : express . Request , res : express . Response ) { const serverActor = await getServerActor ( ) const resultList = await VideoPlaylistModel . listForApi ( { followerActorId : serverActor . id , start : req . query . start , count : req . query . count , sort : req . query . sort , type : req . query . type } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } function getVideoPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylist = res . locals . videoPlaylistSummary if ( videoPlaylist . isOutdated ( ) ) { JobQueue . Instance . createJob ( { type : 's' , payload : { type : 's' , url : videoPlaylist . url } } ) . catch ( err => logger . error ( 's' , videoPlaylist . url , { err } ) ) } return res . json ( videoPlaylist . toFormattedJSON ( ) ) } async function addVideoPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylistInfo = req . body const user = res . locals . oauth . token . User const videoPlaylist = new VideoPlaylistModel ( { name : videoPlaylistInfo . displayName , description : videoPlaylistInfo . description , privacy : videoPlaylistInfo . privacy || VideoPlaylistPrivacy . PRIVATE , ownerAccountId : user . Account . id } ) as MVideoPlaylistFull videoPlaylist . url = getVideoPlaylistActivityPubUrl ( videoPlaylist ) if ( videoPlaylistInfo . videoChannelId ) { const videoChannel = res . locals . videoChannel videoPlaylist . videoChannelId = videoChannel . id videoPlaylist . VideoChannel = videoChannel } const thumbnailField = req . files [ 's' ] const thumbnailModel = thumbnailField ? await createPlaylistMiniatureFromExisting ( thumbnailField [ 0 ] . path , videoPlaylist , false ) : undefined const videoPlaylistCreated = await sequelizeTypescript . transaction ( async t => { const videoPlaylistCreated = await videoPlaylist . save ( { transaction : t } ) as MVideoPlaylistFull if ( thumbnailModel ) { thumbnailModel . automaticallyGenerated = false await videoPlaylistCreated . setAndSaveThumbnail ( thumbnailModel , t ) } videoPlaylistCreated . OwnerAccount = await AccountModel . load ( user . Account . id , t ) await sendCreateVideoPlaylist ( videoPlaylistCreated , t ) return videoPlaylistCreated } ) logger . info ( 's' , videoPlaylist . uuid ) return res . json ( { videoPlaylist : { id : videoPlaylistCreated . id , uuid : videoPlaylistCreated . uuid } } ) . end ( ) } async function updateVideoPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylistInstance = res . locals . videoPlaylistFull const videoPlaylistFieldsSave = videoPlaylistInstance . toJSON ( ) const videoPlaylistInfoToUpdate = req . body as VideoPlaylistUpdate const wasPrivatePlaylist = videoPlaylistInstance . privacy === VideoPlaylistPrivacy . PRIVATE const wasNotPrivatePlaylist = videoPlaylistInstance . privacy !== VideoPlaylistPrivacy . PRIVATE const thumbnailField = req . files [ 's' ] const thumbnailModel = thumbnailField ? await createPlaylistMiniatureFromExisting ( thumbnailField [ 0 ] . path , videoPlaylistInstance , false ) : undefined try { await sequelizeTypescript . transaction ( async t => { const sequelizeOptions = { transaction : t } if ( videoPlaylistInfoToUpdate . videoChannelId !== undefined ) { if ( videoPlaylistInfoToUpdate . videoChannelId === null ) { videoPlaylistInstance . videoChannelId = null } else { const videoChannel = res . locals . videoChannel videoPlaylistInstance . videoChannelId = videoChannel . id videoPlaylistInstance . VideoChannel = videoChannel } } if ( videoPlaylistInfoToUpdate . displayName !== undefined ) videoPlaylistInstance . name = videoPlaylistInfoToUpdate . displayName if ( videoPlaylistInfoToUpdate . description !== undefined ) videoPlaylistInstance . description = videoPlaylistInfoToUpdate . description if ( videoPlaylistInfoToUpdate . privacy !== undefined ) { videoPlaylistInstance . privacy = parseInt ( videoPlaylistInfoToUpdate . privacy . toString ( ) , 0 ) if ( wasNotPrivatePlaylist === true && videoPlaylistInstance . privacy === VideoPlaylistPrivacy . PRIVATE ) { await sendDeleteVideoPlaylist ( videoPlaylistInstance , t ) } } const playlistUpdated = await videoPlaylistInstance . save ( sequelizeOptions ) if ( thumbnailModel ) { thumbnailModel . automaticallyGenerated = false await playlistUpdated . setAndSaveThumbnail ( thumbnailModel , t ) } const isNewPlaylist = wasPrivatePlaylist && playlistUpdated . privacy !== VideoPlaylistPrivacy . PRIVATE if ( isNewPlaylist ) { await sendCreateVideoPlaylist ( playlistUpdated , t ) } else { await sendUpdateVideoPlaylist ( playlistUpdated , t ) } logger . info ( 's' , videoPlaylistInstance . uuid ) return playlistUpdated } ) } catch ( err ) { logger . debug ( 's' , { err } ) resetSequelizeInstance ( videoPlaylistInstance , videoPlaylistFieldsSave ) throw err } return res . type ( 's' ) . status ( 0 ) . end ( ) } async function removeVideoPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylistInstance = res . locals . videoPlaylistSummary await sequelizeTypescript . transaction ( async t => { await videoPlaylistInstance . destroy ( { transaction : t } ) await sendDeleteVideoPlaylist ( videoPlaylistInstance , t ) logger . info ( 's' , videoPlaylistInstance . uuid ) } ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function addVideoInPlaylist ( req : express . Request , res : express . Response ) { const body = req . body const videoPlaylist = res . locals . videoPlaylistFull const video = res . locals . onlyVideo const playlistElement = await sequelizeTypescript . transaction ( async t => { const position = await VideoPlaylistElementModel . getNextPositionOf ( videoPlaylist . id , t ) const playlistElement = await VideoPlaylistElementModel . create ( { url : getVideoPlaylistElementActivityPubUrl ( videoPlaylist , video ) , position , startTimestamp : body . startTimestamp || null , stopTimestamp : body . stopTimestamp || null , videoPlaylistId : videoPlaylist . id , videoId : video . id } , { transaction : t } ) videoPlaylist . changed ( 's' , true ) await videoPlaylist . save ( { transaction : t } ) return playlistElement } ) if ( videoPlaylist . hasThumbnail ( ) === false || ( videoPlaylist . hasGeneratedThumbnail ( ) && playlistElement . position === 0 ) ) { await generateThumbnailForPlaylist ( videoPlaylist , video ) } sendUpdateVideoPlaylist ( videoPlaylist , undefined ) . catch ( err => logger . error ( 's' , { err } ) ) logger . info ( 's' , videoPlaylist . uuid , playlistElement . position ) return res . json ( { videoPlaylistElement : { id : playlistElement . id } } ) . end ( ) } async function updateVideoPlaylistElement ( req : express . Request , res : express . Response ) { const body = req . body const videoPlaylist = res . locals . videoPlaylistFull const videoPlaylistElement = res . locals . videoPlaylistElement const playlistElement = await sequelizeTypescript . transaction ( async t => { if ( body . startTimestamp !== undefined ) videoPlaylistElement . startTimestamp = body . startTimestamp if ( body . stopTimestamp !== undefined ) videoPlaylistElement . stopTimestamp = body . stopTimestamp const element = await videoPlaylistElement . save ( { transaction : t } ) videoPlaylist . changed ( 's' , true ) await videoPlaylist . save ( { transaction : t } ) await sendUpdateVideoPlaylist ( videoPlaylist , t ) return element } ) logger . info ( 's' , playlistElement . position , videoPlaylist . uuid ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function removeVideoFromPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylistElement = res . locals . videoPlaylistElement const videoPlaylist = res . locals . videoPlaylistFull const positionToDelete = videoPlaylistElement . position await sequelizeTypescript . transaction ( async t => { await videoPlaylistElement . destroy ( { transaction : t } ) await VideoPlaylistElementModel . increasePositionOf ( videoPlaylist . id , positionToDelete , null , - 0 , t ) videoPlaylist . changed ( 's' , true ) await videoPlaylist . save ( { transaction : t } ) logger . info ( 's' , videoPlaylistElement . position , videoPlaylist . uuid ) } ) if ( positionToDelete === 0 && videoPlaylist . hasGeneratedThumbnail ( ) ) { await regeneratePlaylistThumbnail ( videoPlaylist ) } sendUpdateVideoPlaylist ( videoPlaylist , undefined ) . catch ( err => logger . error ( 's' , { err } ) ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function reorderVideosPlaylist ( req : express . Request , res : express . Response ) { const videoPlaylist = res . locals . videoPlaylistFull const body = req . body const start = body . startPosition const insertAfter = body . insertAfterPosition const reorderLength = body . reorderLength || 0 if ( start === insertAfter ) { return res . status ( 0 ) . end ( ) } await sequelizeTypescript . transaction ( async t => { const newPosition = insertAfter + 0 await VideoPlaylistElementModel . increasePositionOf ( videoPlaylist . id , newPosition , null , reorderLength , t ) let oldPosition = start if ( start >= newPosition ) oldPosition += reorderLength const endOldPosition = oldPosition + reorderLength - 0 await VideoPlaylistElementModel . reassignPositionOf ( videoPlaylist . id , oldPosition , endOldPosition , newPosition , t ) await VideoPlaylistElementModel . increasePositionOf ( videoPlaylist . id , oldPosition , null , - reorderLength , t ) videoPlaylist . changed ( 's' , true ) await videoPlaylist . save ( { transaction : t } ) await sendUpdateVideoPlaylist ( videoPlaylist , t ) } ) if ( ( start === 0 || insertAfter === 0 ) && videoPlaylist . hasGeneratedThumbnail ( ) ) { await regeneratePlaylistThumbnail ( videoPlaylist ) } logger . info ( 's' , videoPlaylist . uuid , insertAfter , start , start + reorderLength - 0 ) return res . type ( 's' ) . status ( 0 ) . end ( ) } async function getVideoPlaylistVideos ( req : express . Request , res : express . Response ) { const videoPlaylistInstance = res . locals . videoPlaylistSummary const user = res . locals . oauth ? res . locals . oauth . token . User : undefined const server = await getServerActor ( ) const resultList = await VideoPlaylistElementModel . listForApi ( { start : req . query . start , count : req . query . count , videoPlaylistId : videoPlaylistInstance . id , serverAccount : server . Account , user } ) const options = { displayNSFW : buildNSFWFilter ( res , req . query . nsfw ) , accountId : user ? user . Account . id : undefined } return res . json ( getFormattedObjects ( resultList . data , resultList . total , options ) ) } async function regeneratePlaylistThumbnail ( videoPlaylist ) { await videoPlaylist . Thumbnail . destroy ( ) videoPlaylist . Thumbnail = null const firstElement = await VideoPlaylistElementModel . loadFirstElementWithVideoThumbnail ( videoPlaylist . id ) if ( firstElement ) await generateThumbnailForPlaylist ( videoPlaylist , firstElement . Video ) } async function generateThumbnailForPlaylist ( videoPlaylist , video ) { logger . info ( 's' , videoPlaylist . url ) const inputPath = join ( CONFIG . STORAGE . THUMBNAILS_DIR , video . getMiniature ( ) . filename ) const thumbnailModel = await createPlaylistMiniatureFromExisting ( inputPath , videoPlaylist , true , true ) thumbnailModel . videoPlaylistId = videoPlaylist . id videoPlaylist . Thumbnail = await thumbnailModel . save ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElementCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElementUpdate$ O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElementModel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistReorder$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoPlaylistThumbnail$ O $MVideoThumbnail$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface InstallOrUpdatePlugin { npmName ? : string path ? : string }	O O O O O O O O O O O O O
import * as express from 's' import { body , param , query } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isNpmPluginNameValid , isPluginNameValid , isPluginTypeValid , isPluginVersionValid } from 's' import { PluginManager } from 's' import { isBooleanValid , isSafePath , toBooleanOrNull } from 's' import { PluginModel } from 's' import { InstallOrUpdatePlugin } from 's' import { PluginType } from 's' import { CONFIG } from 's' const servePluginStaticDirectoryValidator = ( pluginType ) => [ param ( 's' ) . custom ( isPluginNameValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isPluginVersionValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isSafePath ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const npmName = PluginModel . buildNpmName ( req . params . pluginName , pluginType ) const plugin = PluginManager . Instance . getRegisteredPluginOrTheme ( npmName ) if ( ! plugin || plugin . version !== req . params . pluginVersion ) { return res . sendStatus ( 0 ) } res . locals . registeredPlugin = plugin return next ( ) } ] const listPluginsValidator = [ query ( 's' ) . optional ( ) . custom ( isPluginTypeValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . customSanitizer ( toBooleanOrNull ) . custom ( isBooleanValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const installOrUpdatePluginValidator = [ body ( 's' ) . optional ( ) . custom ( isNpmPluginNameValid ) . withMessage ( 's' ) , body ( 's' ) . optional ( ) . custom ( isSafePath ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return const body = req . body if ( ! body . path && ! body . npmName ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] const uninstallPluginValidator = [ body ( 's' ) . custom ( isNpmPluginNameValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const existingPluginValidator = [ param ( 's' ) . custom ( isNpmPluginNameValid ) . withMessage ( 's' ) , async ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const plugin = await PluginModel . loadByNpmName ( req . params . npmName ) if ( ! plugin ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } res . locals . plugin = plugin return next ( ) } ] const updatePluginSettingsValidator = [ body ( 's' ) . exists ( ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . body } ) if ( areValidationErrors ( req , res ) ) return return next ( ) } ] const listAvailablePluginsValidator = [ query ( 's' ) . optional ( ) . exists ( ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isPluginTypeValid ) . withMessage ( 's' ) , query ( 's' ) . optional ( ) . custom ( isPluginVersionValid ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . query } ) if ( areValidationErrors ( req , res ) ) return if ( CONFIG . PLUGINS . INDEX . ENABLED === false ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return next ( ) } ] export { servePluginStaticDirectoryValidator , updatePluginSettingsValidator , uninstallPluginValidator , listAvailablePluginsValidator , existingPluginValidator , installOrUpdatePluginValidator , listPluginsValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InstallOrUpdatePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ManagePlugin { npmName : string }	O O O O O O O O
export interface PeertubePluginLatestVersionRequest { currentPeerTubeEngine ? : string , npmNames : string [ ] } export type PeertubePluginLatestVersionResponse = { npmName : string latestVersion : string | null } [ ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { PluginType } from 's' export interface PeertubePluginIndexList { start : number count : number sort : string pluginType ? : PluginType currentPeerTubeEngine ? : string search ? : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface PeerTubePluginIndex { npmName : string description : string homepage : string createdAt : Date updatedAt : Date popularity : number latestVersion : string name ? : string installed ? : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { doRequest } from 's' import { CONFIG } from 's' import { PeertubePluginLatestVersionRequest , PeertubePluginLatestVersionResponse } from 's' import { PeertubePluginIndexList } from 's' import { ResultList } from 's' import { PeerTubePluginIndex } from 's' import { PluginModel } from 's' import { PluginManager } from 's' import { logger } from 's' import { PEERTUBE_VERSION } from 's' async function listAvailablePluginsFromIndex ( options ) { const { start = 0 , count = 0 , search , sort = 's' , pluginType } = options const qs = { start , count , sort , pluginType , search , currentPeerTubeEngine : options . currentPeerTubeEngine || PEERTUBE_VERSION } const uri = CONFIG . PLUGINS . INDEX . URL + 's' try { const { body } = await doRequest ( { uri , qs , json : true } ) logger . debug ( 's' , { body } ) await addInstanceInformation ( body ) return body as ResultList < PeerTubePluginIndex > } catch ( err ) { logger . error ( 's' , uri , { err } ) return undefined } } async function addInstanceInformation ( result < PeerTubePluginIndex > ) { for ( const d of result . data ) { d . installed = PluginManager . Instance . isRegistered ( d . npmName ) d . name = PluginModel . normalizePluginName ( d . npmName ) } return result } async function getLatestPluginsVersion ( npmNames : string [ ] ) < PeertubePluginLatestVersionResponse > { const bodyRequest = { npmNames , currentPeerTubeEngine : PEERTUBE_VERSION } const uri = CONFIG . PLUGINS . INDEX . URL + 's' const { body } = await doRequest ( { uri , body : bodyRequest , json : true , method : 's' } ) return body } export { listAvailablePluginsFromIndex , getLatestPluginsVersion }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeertubePluginIndexList$ O O O O O O O O O O O O O O O O O O O O O O O $PeertubePluginIndexList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O $PeertubePluginLatestVersionRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface PublicServerSetting { publicSettings : { [ name ] : string } }	O O O O O O O O $string$ O O O O O
import * as express from 's' import { getFormattedObjects } from 's' import { asyncMiddleware , authenticate , ensureUserHasRight , paginationValidator , setDefaultPagination , setDefaultSort } from 's' import { availablePluginsSortValidator , pluginsSortValidator } from 's' import { PluginModel } from 's' import { UserRight } from 's' import { existingPluginValidator , installOrUpdatePluginValidator , listAvailablePluginsValidator , listPluginsValidator , uninstallPluginValidator , updatePluginSettingsValidator } from 's' import { PluginManager } from 's' import { InstallOrUpdatePlugin } from 's' import { ManagePlugin } from 's' import { logger } from 's' import { listAvailablePluginsFromIndex } from 's' import { PeertubePluginIndexList } from 's' import { RegisteredServerSettings } from 's' import { PublicServerSetting } from 's' const pluginRouter = express . Router ( ) pluginRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , listAvailablePluginsValidator , paginationValidator , availablePluginsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listAvailablePlugins ) ) pluginRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , listPluginsValidator , paginationValidator , pluginsSortValidator , setDefaultSort , setDefaultPagination , asyncMiddleware ( listPlugins ) ) pluginRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , asyncMiddleware ( existingPluginValidator ) , getPluginRegisteredSettings ) pluginRouter . get ( 's' , asyncMiddleware ( existingPluginValidator ) , getPublicPluginSettings ) pluginRouter . put ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , updatePluginSettingsValidator , asyncMiddleware ( existingPluginValidator ) , asyncMiddleware ( updatePluginSettings ) ) pluginRouter . get ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , asyncMiddleware ( existingPluginValidator ) , getPlugin ) pluginRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , installOrUpdatePluginValidator , asyncMiddleware ( installPlugin ) ) pluginRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , installOrUpdatePluginValidator , asyncMiddleware ( updatePlugin ) ) pluginRouter . post ( 's' , authenticate , ensureUserHasRight ( UserRight . MANAGE_PLUGINS ) , uninstallPluginValidator , asyncMiddleware ( uninstallPlugin ) ) export { pluginRouter } async function listPlugins ( req : express . Request , res : express . Response ) { const pluginType = req . query . pluginType const uninstalled = req . query . uninstalled const resultList = await PluginModel . listForApi ( { pluginType , uninstalled , start : req . query . start , count : req . query . count , sort : req . query . sort } ) return res . json ( getFormattedObjects ( resultList . data , resultList . total ) ) } function getPlugin ( req : express . Request , res : express . Response ) { const plugin = res . locals . plugin return res . json ( plugin . toFormattedJSON ( ) ) } async function installPlugin ( req : express . Request , res : express . Response ) { const body = req . body const fromDisk = ! ! body . path const toInstall = body . npmName || body . path try { const plugin = await PluginManager . Instance . install ( toInstall , undefined , fromDisk ) return res . json ( plugin . toFormattedJSON ( ) ) } catch ( err ) { logger . warn ( 's' , toInstall , { err } ) return res . sendStatus ( 0 ) } } async function updatePlugin ( req : express . Request , res : express . Response ) { const body = req . body const fromDisk = ! ! body . path const toUpdate = body . npmName || body . path try { const plugin = await PluginManager . Instance . update ( toUpdate , undefined , fromDisk ) return res . json ( plugin . toFormattedJSON ( ) ) } catch ( err ) { logger . warn ( 's' , toUpdate , { err } ) return res . sendStatus ( 0 ) } } async function uninstallPlugin ( req : express . Request , res : express . Response ) { const body = req . body await PluginManager . Instance . uninstall ( body . npmName ) return res . sendStatus ( 0 ) } function getPublicPluginSettings ( req : express . Request , res : express . Response ) { const plugin = res . locals . plugin const registeredSettings = PluginManager . Instance . getRegisteredSettings ( req . params . npmName ) const publicSettings = plugin . getPublicSettings ( registeredSettings ) const json = { publicSettings } return res . json ( json ) } function getPluginRegisteredSettings ( req : express . Request , res : express . Response ) { const registeredSettings = PluginManager . Instance . getRegisteredSettings ( req . params . npmName ) const json = { registeredSettings } return res . json ( json ) } async function updatePluginSettings ( req : express . Request , res : express . Response ) { const plugin = res . locals . plugin plugin . settings = req . body . settings await plugin . save ( ) return res . sendStatus ( 0 ) } async function listAvailablePlugins ( req : express . Request , res : express . Response ) { const query = req . query const resultList = await listAvailablePluginsFromIndex ( query ) if ( ! resultList ) { return res . status ( 0 ) . json ( { error : 's' } ) . end ( ) } return res . json ( resultList ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InstallOrUpdatePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InstallOrUpdatePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ManagePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PublicServerSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisteredServerSettings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeertubePluginIndexList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import * as RateLimit from 's' import { configRouter } from 's' import { jobsRouter } from 's' import { oauthClientsRouter } from 's' import { serverRouter } from 's' import { usersRouter } from 's' import { accountsRouter } from 's' import { videosRouter } from 's' import { badRequest } from 's' import { videoChannelRouter } from 's' import * as cors from 's' import { searchRouter } from 's' import { overviewsRouter } from 's' import { videoPlaylistRouter } from 's' import { CONFIG } from 's' import { pluginRouter } from 's' const apiRouter = express . Router ( ) apiRouter . use ( cors ( { origin : 's' , exposedHeaders : 's' , credentials : true } ) ) const apiRateLimiter = RateLimit ( { windowMs : CONFIG . RATES_LIMIT . API . WINDOW_MS , max : CONFIG . RATES_LIMIT . API . MAX } ) apiRouter . use ( apiRateLimiter ) apiRouter . use ( 's' , serverRouter ) apiRouter . use ( 's' , oauthClientsRouter ) apiRouter . use ( 's' , configRouter ) apiRouter . use ( 's' , usersRouter ) apiRouter . use ( 's' , accountsRouter ) apiRouter . use ( 's' , videoChannelRouter ) apiRouter . use ( 's' , videoPlaylistRouter ) apiRouter . use ( 's' , videosRouter ) apiRouter . use ( 's' , jobsRouter ) apiRouter . use ( 's' , searchRouter ) apiRouter . use ( 's' , overviewsRouter ) apiRouter . use ( 's' , pluginRouter ) apiRouter . use ( 's' , pong ) apiRouter . use ( 's' , badRequest ) export { apiRouter } function pong ( req : express . Request , res : express . Response ) { return res . send ( 's' ) . status ( 0 ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware } from 's' import { ROUTE_CACHE_LIFETIME , WEBSERVER } from 's' import * as sitemapModule from 's' import { logger } from 's' import { VideoModel } from 's' import { VideoChannelModel } from 's' import { AccountModel } from 's' import { cacheRoute } from 's' import { buildNSFWFilter } from 's' import { truncate } from 's' const botsRouter = express . Router ( ) botsRouter . use ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . SITEMAP ) ) , asyncMiddleware ( getSitemap ) ) export { botsRouter } async function getSitemap ( req : express . Request , res : express . Response ) { let urls = getSitemapBasicUrls ( ) urls = urls . concat ( await getSitemapLocalVideoUrls ( ) ) urls = urls . concat ( await getSitemapVideoChannelUrls ( ) ) urls = urls . concat ( await getSitemapAccountUrls ( ) ) const sitemap = sitemapModule . createSitemap ( { hostname : WEBSERVER . URL , urls : urls } ) sitemap . toXML ( ( err , xml ) => { if ( err ) { logger . error ( 's' , { err } ) return res . sendStatus ( 0 ) } res . header ( 's' , 's' ) res . send ( xml ) } ) } async function getSitemapVideoChannelUrls ( ) { const rows = await VideoChannelModel . listLocalsForSitemap ( 's' ) return rows . map ( channel => ( { url : WEBSERVER . URL + 's' + channel . Actor . preferredUsername } ) ) } async function getSitemapAccountUrls ( ) { const rows = await AccountModel . listLocalsForSitemap ( 's' ) return rows . map ( channel => ( { url : WEBSERVER . URL + 's' + channel . Actor . preferredUsername } ) ) } async function getSitemapLocalVideoUrls ( ) { const resultList = await VideoModel . listForApi ( { start : 0 , count : undefined , sort : 's' , includeLocalVideos : true , nsfw : buildNSFWFilter ( ) , filter : 's' , withFiles : false } ) return resultList . data . map ( v => ( { url : WEBSERVER . URL + 's' + v . uuid , video : [ { title : v . name , description : truncate ( v . description || v . name , { length : 0 , omission : 's' } ) , player_loc : WEBSERVER . URL + 's' + v . uuid , thumbnail_loc : WEBSERVER . URL + v . getMiniatureStaticPath ( ) } ] } ) ) } function getSitemapBasicUrls ( ) { const paths = [ 's' , 's' ] return paths . map ( p => ( { url : WEBSERVER . URL + p } ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { join } from 's' import { root } from 's' import { ACCEPT_HEADERS , STATIC_MAX_AGE } from 's' import { asyncMiddleware , embedCSP } from 's' import { buildFileLocale , getCompleteLocale , 0 , LOCALE_FILES } from 's' import { ClientHtml } from 's' import { logger } from 's' const clientsRouter = express . Router ( ) const distPath = join ( root ( ) , 's' , 's' ) const embedPath = join ( distPath , 's' , 's' , 's' ) const testEmbedPath = join ( distPath , 's' , 's' , 's' ) clientsRouter . use ( 's' , asyncMiddleware ( generateWatchHtmlPage ) ) clientsRouter . use ( 's' , asyncMiddleware ( generateAccountHtmlPage ) ) clientsRouter . use ( 's' , asyncMiddleware ( generateVideoChannelHtmlPage ) ) clientsRouter . use ( 's' , embedCSP , ( req : express . Request , res : express . Response ) => { res . removeHeader ( 's' ) res . sendFile ( embedPath ) } ) clientsRouter . use ( 's' , ( req : express . Request , res : express . Response ) => res . sendFile ( testEmbedPath ) ) const staticClientFiles = [ 's' , 's' , 's' ] for ( const staticClientFile of staticClientFiles ) { const path = join ( root ( ) , 's' , 's' , staticClientFile ) clientsRouter . get ( 's' + staticClientFile , ( req : express . Request , res : express . Response ) => { res . sendFile ( path , { maxAge : STATIC_MAX_AGE . SERVER } ) } ) } clientsRouter . use ( 's' , serveServerTranslations ) clientsRouter . use ( 's' , express . static ( distPath , { maxAge : STATIC_MAX_AGE . CLIENT } ) ) clientsRouter . use ( 's' , ( req : express . Request , res : express . Response ) => { res . sendStatus ( 0 ) } ) clientsRouter . use ( 's' , asyncMiddleware ( serveIndexHTML ) ) export { clientsRouter } async function serveServerTranslations ( req : express . Request , res : express . Response ) { const locale = req . params . locale const file = req . params . file if ( 0 ( locale ) && LOCALE_FILES . indexOf ( file ) !== - 0 ) { const completeLocale = getCompleteLocale ( locale ) const completeFileLocale = buildFileLocale ( completeLocale ) const path = join ( __dirname , `template` ) return res . sendFile ( path , { maxAge : STATIC_MAX_AGE . SERVER } ) } return res . sendStatus ( 0 ) } async function serveIndexHTML ( req : express . Request , res : express . Response ) { if ( req . accepts ( ACCEPT_HEADERS ) === 's' ) { try { await generateHTMLPage ( req , res , req . params . language ) return } catch ( err ) { logger . error ( 's' , err ) } } return res . status ( 0 ) . end ( ) } async function generateHTMLPage ( req : express . Request , res : express . Response , paramLang ? ) { const html = await ClientHtml . getDefaultHTMLPage ( req , res , paramLang ) return sendHTML ( html , res ) } async function generateWatchHtmlPage ( req : express . Request , res : express . Response ) { const html = await ClientHtml . getWatchHTMLPage ( req . params . id + 's' , req , res ) return sendHTML ( html , res ) } async function generateAccountHtmlPage ( req : express . Request , res : express . Response ) { const html = await ClientHtml . getAccountHTMLPage ( req . params . nameWithHost , req , res ) return sendHTML ( html , res ) } async function generateVideoChannelHtmlPage ( req : express . Request , res : express . Response ) { const html = await ClientHtml . getVideoChannelHTMLPage ( req . params . nameWithHost , req , res ) return sendHTML ( html , res ) } function sendHTML ( html , res : express . Response ) { res . set ( 's' , 's' ) return res . send ( html ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { FEEDS , ROUTE_CACHE_LIFETIME , THUMBNAILS_SIZE , WEBSERVER } from 's' import { asyncMiddleware , commonVideosFiltersValidator , setDefaultSort , videoCommentsFeedsValidator , videoFeedsValidator , videosSortValidator } from 's' import { VideoModel } from 's' import * as Feed from 's' import { cacheRoute } from 's' import { VideoCommentModel } from 's' import { buildNSFWFilter } from 's' import { CONFIG } from 's' const feedsRouter = express . Router ( ) feedsRouter . get ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . FEEDS ) ) , asyncMiddleware ( videoCommentsFeedsValidator ) , asyncMiddleware ( generateVideoCommentsFeed ) ) feedsRouter . get ( 's' , videosSortValidator , setDefaultSort , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . FEEDS ) ) , commonVideosFiltersValidator , asyncMiddleware ( videoFeedsValidator ) , asyncMiddleware ( generateVideoFeed ) ) export { feedsRouter } async function generateVideoCommentsFeed ( req : express . Request , res : express . Response ) { const start = 0 const video = res . locals . videoAll const videoId = video ? video . id : undefined const comments = await VideoCommentModel . listForFeed ( start , FEEDS . COUNT , videoId ) const name = video ? video . name : CONFIG . INSTANCE . NAME const description = video ? video . description : CONFIG . INSTANCE . DESCRIPTION const feed = initFeed ( name , description ) comments . forEach ( comment => { const link = WEBSERVER . URL + comment . getCommentStaticPath ( ) feed . addItem ( { title : `template` , id : comment . url , link , content : comment . text , author : [ { name : comment . Account . getDisplayName ( ) , link : comment . Account . Actor . url } ] , date : comment . createdAt } ) } ) return sendFeed ( feed , req , res ) } async function generateVideoFeed ( req : express . Request , res : express . Response ) { const start = 0 const account = res . locals . account const videoChannel = res . locals . videoChannel const nsfw = buildNSFWFilter ( res , req . query . nsfw ) let name let description if ( videoChannel ) { name = videoChannel . getDisplayName ( ) description = videoChannel . description } else if ( account ) { name = account . getDisplayName ( ) description = account . description } else { name = CONFIG . INSTANCE . NAME description = CONFIG . INSTANCE . DESCRIPTION } const feed = initFeed ( name , description ) const resultList = await VideoModel . listForApi ( { start , count : FEEDS . COUNT , sort : req . query . sort , includeLocalVideos : true , nsfw , filter : req . query . filter , withFiles : true , accountId : account ? account . id : null , videoChannelId : videoChannel ? videoChannel . id : null } ) resultList . data . forEach ( video => { const formattedVideoFiles = video . getFormattedVideoFilesJSON ( ) const torrents = formattedVideoFiles . map ( videoFile => ( { title : video . name , url : videoFile . torrentUrl , size_in_bytes : videoFile . size } ) ) feed . addItem ( { title : video . name , id : video . url , link : WEBSERVER . URL + 's' + video . uuid , description : video . getTruncatedDescription ( ) , content : video . description , author : [ { name : video . VideoChannel . Account . getDisplayName ( ) , link : video . VideoChannel . Account . Actor . url } ] , date : video . publishedAt , language : video . language , nsfw : video . nsfw , torrent : torrents , thumbnail : [ { url : WEBSERVER . URL + video . getMiniatureStaticPath ( ) , height : THUMBNAILS_SIZE . height , width : THUMBNAILS_SIZE . width } ] } ) } ) return sendFeed ( feed , req , res ) } function initFeed ( name , description ) { const webserverUrl = WEBSERVER . URL return new Feed ( { title : name , description , id : webserverUrl , link : webserverUrl , image : webserverUrl + 's' , favicon : webserverUrl + 's' , copyright : `template` + `template` , generator : `template` , feedLinks : { json : `template` , atom : `template` , rss : `template` } , author : { name : 's' + CONFIG . INSTANCE . NAME , email : CONFIG . ADMIN . EMAIL , link : `template` } } ) } function sendFeed ( feed , req : express . Request , res : express . Response ) { const format = req . params . format if ( format === 's' || format === 's' ) { res . set ( 's' , 's' ) return res . send ( feed . 0 ( ) ) . end ( ) } if ( format === 's' || format === 's' ) { res . set ( 's' , 's' ) return res . send ( feed . 0 ( ) ) . end ( ) } if ( format === 's' || format === 's' ) { res . set ( 's' , 's' ) return res . send ( feed . 0 ( ) ) . end ( ) } if ( req . query . format === 's' || req . query . format === 's' ) { res . set ( 's' , 's' ) return res . send ( feed . 0 ( ) ) . end ( ) } res . set ( 's' , 's' ) return res . send ( feed . 0 ( ) ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { EMBED_SIZE , PREVIEWS_SIZE , WEBSERVER } from 's' import { asyncMiddleware , oembedValidator } from 's' import { accountNameWithHostGetValidator } from 's' const servicesRouter = express . Router ( ) servicesRouter . use ( 's' , asyncMiddleware ( oembedValidator ) , generateOEmbed ) servicesRouter . use ( 's' , asyncMiddleware ( accountNameWithHostGetValidator ) , redirectToAccountUrl ) export { servicesRouter } function generateOEmbed ( req : express . Request , res : express . Response ) { const video = res . locals . videoAll const webserverUrl = WEBSERVER . URL const maxHeight = parseInt ( req . query . maxheight , 0 ) const maxWidth = parseInt ( req . query . maxwidth , 0 ) const embedUrl = webserverUrl + video . getEmbedStaticPath ( ) let thumbnailUrl = webserverUrl + video . getPreviewStaticPath ( ) let embedWidth = EMBED_SIZE . width let embedHeight = EMBED_SIZE . height if ( maxHeight < embedHeight ) embedHeight = maxHeight if ( maxWidth < embedWidth ) embedWidth = maxWidth if ( ( maxHeight !== undefined && maxHeight < PREVIEWS_SIZE . height ) || ( maxWidth !== undefined && maxWidth < PREVIEWS_SIZE . width ) ) { thumbnailUrl = undefined } const html = `template` + `template` const json = { type : 's' , version : 's' , html , width : embedWidth , height : embedHeight , title : video . name , author_name : video . VideoChannel . Account . name , author_url : video . VideoChannel . Account . Actor . url , provider_name : 's' , provider_url : webserverUrl } if ( thumbnailUrl !== undefined ) { json . thumbnail_url = thumbnailUrl json . thumbnail_width = PREVIEWS_SIZE . width json . thumbnail_height = PREVIEWS_SIZE . height } return res . json ( json ) } function redirectToAccountUrl ( req : express . Request , res : express . Response , next : express . NextFunction ) { return res . redirect ( res . locals . account . Actor . url ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cors from 's' import * as express from 's' import { LAZY_STATIC_PATHS , STATIC_MAX_AGE } from 's' import { VideosCaptionCache , VideosPreviewCache } from 's' import { asyncMiddleware } from 's' import { AvatarModel } from 's' import { logger } from 's' import { avatarPathUnsafeCache , pushAvatarProcessInQueue } from 's' const lazyStaticRouter = express . Router ( ) lazyStaticRouter . use ( cors ( ) ) lazyStaticRouter . use ( LAZY_STATIC_PATHS . AVATARS + 's' , asyncMiddleware ( getAvatar ) ) lazyStaticRouter . use ( LAZY_STATIC_PATHS . PREVIEWS + 's' , asyncMiddleware ( getPreview ) ) lazyStaticRouter . use ( LAZY_STATIC_PATHS . VIDEO_CAPTIONS + 's' , asyncMiddleware ( getVideoCaption ) ) export { lazyStaticRouter , getPreview , getVideoCaption } async function getAvatar ( req : express . Request , res : express . Response ) { const filename = req . params . filename if ( avatarPathUnsafeCache . has ( filename ) ) { return res . sendFile ( avatarPathUnsafeCache . get ( filename ) , { maxAge : STATIC_MAX_AGE . SERVER } ) } const avatar = await AvatarModel . loadByName ( filename ) if ( ! avatar ) return res . sendStatus ( 0 ) if ( avatar . onDisk === false ) { if ( ! avatar . fileUrl ) return res . sendStatus ( 0 ) logger . info ( 's' , avatar . fileUrl ) try { await pushAvatarProcessInQueue ( { filename : avatar . filename , fileUrl : avatar . fileUrl } ) } catch ( err ) { logger . warn ( 's' , avatar . fileUrl , { err } ) return res . sendStatus ( 0 ) } avatar . onDisk = true avatar . save ( ) . catch ( err => logger . error ( 's' , { err } ) ) } const path = avatar . getPath ( ) avatarPathUnsafeCache . set ( filename , path ) return res . sendFile ( path , { maxAge : STATIC_MAX_AGE . SERVER } ) } async function getPreview ( req : express . Request , res : express . Response ) { const result = await VideosPreviewCache . Instance . getFilePath ( req . params . uuid ) if ( ! result ) return res . sendStatus ( 0 ) return res . sendFile ( result . path , { maxAge : STATIC_MAX_AGE . SERVER } ) } async function getVideoCaption ( req : express . Request , res : express . Response ) { const result = await VideosCaptionCache . Instance . getFilePath ( { videoId : req . params . videoId , language : req . params . captionLanguage } ) if ( ! result ) return res . sendStatus ( 0 ) return res . sendFile ( result . path , { maxAge : STATIC_MAX_AGE . SERVER } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cors from 's' import * as express from 's' import { HLS_STREAMING_PLAYLIST_DIRECTORY , PEERTUBE_VERSION , ROUTE_CACHE_LIFETIME , STATIC_DOWNLOAD_PATHS , STATIC_MAX_AGE , STATIC_PATHS , WEBSERVER } from 's' import { cacheRoute } from 's' import { asyncMiddleware , videosGetValidator } from 's' import { VideoModel } from 's' import { UserModel } from 's' import { VideoCommentModel } from 's' import { 0 } from 's' import { join } from 's' import { root } from 's' import { CONFIG } from 's' import { getPreview , getVideoCaption } from 's' const staticRouter = express . Router ( ) staticRouter . use ( cors ( ) ) const torrentsPhysicalPath = CONFIG . STORAGE . TORRENTS_DIR staticRouter . use ( STATIC_PATHS . TORRENTS , cors ( ) , express . static ( torrentsPhysicalPath , { maxAge : 0 } ) ) staticRouter . use ( STATIC_DOWNLOAD_PATHS . TORRENTS + 's' , asyncMiddleware ( videosGetValidator ) , asyncMiddleware ( downloadTorrent ) ) staticRouter . use ( STATIC_PATHS . WEBSEED , cors ( ) , express . static ( CONFIG . STORAGE . VIDEOS_DIR , { fallthrough : false } ) ) staticRouter . use ( STATIC_PATHS . REDUNDANCY , cors ( ) , express . static ( CONFIG . STORAGE . REDUNDANCY_DIR , { fallthrough : false } ) ) staticRouter . use ( STATIC_DOWNLOAD_PATHS . VIDEOS + 's' , asyncMiddleware ( videosGetValidator ) , asyncMiddleware ( downloadVideoFile ) ) staticRouter . use ( STATIC_PATHS . STREAMING_PLAYLISTS . HLS , cors ( ) , express . static ( HLS_STREAMING_PLAYLIST_DIRECTORY , { fallthrough : false } ) ) const thumbnailsPhysicalPath = CONFIG . STORAGE . THUMBNAILS_DIR staticRouter . use ( STATIC_PATHS . THUMBNAILS , express . static ( thumbnailsPhysicalPath , { maxAge : STATIC_MAX_AGE . SERVER , fallthrough : false } ) ) const avatarsPhysicalPath = CONFIG . STORAGE . AVATARS_DIR staticRouter . use ( STATIC_PATHS . AVATARS , express . static ( avatarsPhysicalPath , { maxAge : STATIC_MAX_AGE . SERVER , fallthrough : false } ) ) staticRouter . use ( STATIC_PATHS . PREVIEWS + 's' , asyncMiddleware ( getPreview ) ) staticRouter . use ( STATIC_PATHS . VIDEO_CAPTIONS + 's' , asyncMiddleware ( getVideoCaption ) ) staticRouter . get ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . ROBOTS ) ) , ( _ , res : express . Response ) => { res . type ( 's' ) return res . send ( CONFIG . INSTANCE . ROBOTS ) } ) staticRouter . get ( 's' , ( _ , res : express . Response ) => { return res . redirect ( 0 , 's' ) } ) staticRouter . get ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . SECURITYTXT ) ) , ( _ , res : express . Response ) => { res . type ( 's' ) return res . send ( CONFIG . INSTANCE . SECURITYTXT + CONFIG . INSTANCE . SECURITYTXT_CONTACT ) } ) staticRouter . use ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . NODEINFO ) ) , ( _ , res : express . Response ) => { return res . json ( { links : [ { rel : 's' , href : WEBSERVER . URL + 's' } ] } ) } ) staticRouter . use ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . NODEINFO ) ) , asyncMiddleware ( generateNodeinfo ) ) staticRouter . use ( 's' , asyncMiddleware ( cacheRoute ( ROUTE_CACHE_LIFETIME . DNT_POLICY ) ) , ( _ , res : express . Response ) => { res . type ( 's' ) return res . sendFile ( join ( root ( ) , 's' ) ) } ) staticRouter . use ( 's' , ( _ , res : express . Response ) => { res . json ( { tracking : 's' } ) } ) staticRouter . use ( 's' , ( _ , res : express . Response ) => { res . redirect ( 's' ) } ) staticRouter . use ( 's' , ( _ , res : express . Response ) => { res . type ( 's' ) const xml = 's' + 's' + `template` + 's' res . send ( xml ) . end ( ) } ) export { staticRouter } async function generateNodeinfo ( req : express . Request , res : express . Response ) { const { totalVideos } = await VideoModel . getStats ( ) const { totalLocalVideoComments } = await VideoCommentModel . getStats ( ) const { totalUsers } = await UserModel . getStats ( ) let json = { } if ( req . params . version && ( req . params . version === 's' ) ) { json = { version : 's' , software : { name : 's' , version : PEERTUBE_VERSION } , protocols : [ 's' ] , services : { inbound : [ ] , outbound : [ 's' , 's' ] } , openRegistrations : CONFIG . SIGNUP . ENABLED , usage : { users : { total : totalUsers } , localPosts : totalVideos , localComments : totalLocalVideoComments } , metadata : { taxonomy : { postsName : 's' } , nodeName : CONFIG . INSTANCE . NAME , nodeDescription : CONFIG . INSTANCE . SHORT_DESCRIPTION } } as 0 res . contentType ( 's' ) } else { json = { error : 's' } res . status ( 0 ) } return res . send ( json ) . end ( ) } async function downloadTorrent ( req : express . Request , res : express . Response ) { const { video , videoFile } = getVideoAndFile ( req , res ) if ( ! videoFile ) return res . status ( 0 ) . end ( ) return res . download ( video . getTorrentFilePath ( videoFile ) , `template` ) } async function downloadVideoFile ( req : express . Request , res : express . Response ) { const { video , videoFile } = getVideoAndFile ( req , res ) if ( ! videoFile ) return res . status ( 0 ) . end ( ) return res . download ( video . getVideoFilePath ( videoFile ) , `template` ) } function getVideoAndFile ( req : express . Request , res : express . Response ) { const resolution = parseInt ( req . params . resolution , 0 ) const video = res . locals . videoAll const videoFile = video . VideoFiles . find ( f => f . resolution === resolution ) return { video , videoFile } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { asyncMiddleware } from 's' import { webfingerValidator } from 's' const webfingerRouter = express . Router ( ) webfingerRouter . get ( 's' , asyncMiddleware ( webfingerValidator ) , webfingerController ) export { webfingerRouter } function webfingerController ( req : express . Request , res : express . Response ) { const actor = res . locals . actorFull const json = { subject : req . query . resource , aliases : [ actor . url ] , links : [ { rel : 's' , type : 's' , href : actor . url } ] } return res . json ( json ) . end ( ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import * as express from 's' import * as http from 's' import * as bitTorrentTracker from 's' import * as proxyAddr from 's' import { Server as WebSocketServer } from 's' import { TRACKER_RATE_LIMITS } from 's' import { VideoFileModel } from 's' import { parse } from 's' import { VideoStreamingPlaylistModel } from 's' import { CONFIG } from 's' const TrackerServer = bitTorrentTracker . Server const trackerRouter = express . Router ( ) let peersIps = { } let peersIpInfoHash = { } runPeersChecker ( ) const trackerServer = new TrackerServer ( { http : false , udp : false , ws : false , dht : false , filter : async function ( infoHash , params , cb ) { if ( CONFIG . TRACKER . ENABLED === false ) { return cb ( new Error ( 's' ) ) } let ip if ( params . type === 's' ) { ip = params . socket . ip } else { ip = params . httpReq . ip } const key = ip + 's' + infoHash peersIps [ ip ] = peersIps [ ip ] ? peersIps [ ip ] + 0 : 0 peersIpInfoHash [ key ] = peersIpInfoHash [ key ] ? peersIpInfoHash [ key ] + 0 : 0 if ( CONFIG . TRACKER . REJECT_TOO_MANY_ANNOUNCES && peersIpInfoHash [ key ] > TRACKER_RATE_LIMITS . ANNOUNCES_PER_IP_PER_INFOHASH ) { return cb ( new Error ( `template` ) ) } try { if ( CONFIG . TRACKER . PRIVATE === false ) return cb ( ) const videoFileExists = await VideoFileModel . doesInfohashExist ( infoHash ) if ( videoFileExists === true ) return cb ( ) const playlistExists = await VideoStreamingPlaylistModel . doesInfohashExist ( infoHash ) if ( playlistExists === true ) return cb ( ) return cb ( new Error ( `template` ) ) } catch ( err ) { logger . error ( 's' , { err } ) return cb ( err ) } } } ) if ( CONFIG . TRACKER . ENABLED !== false ) { trackerServer . on ( 's' , function ( err ) { logger . error ( 's' , { err } ) } ) trackerServer . on ( 's' , function ( err ) { logger . warn ( 's' , { err } ) } ) } const onHttpRequest = trackerServer . onHttpRequest . bind ( trackerServer ) trackerRouter . get ( 's' , ( req , res ) => onHttpRequest ( req , res , { action : 's' } ) ) trackerRouter . get ( 's' , ( req , res ) => onHttpRequest ( req , res , { action : 's' } ) ) function createWebsocketTrackerServer ( app : express . Application ) { const server = http . createServer ( app ) const wss = new WebSocketServer ( { noServer : true } ) wss . on ( 's' , function ( ws , req ) { ws [ 's' ] = proxyAddr ( req , CONFIG . TRUST_PROXY ) trackerServer . onWebSocketConnection ( ws ) } ) server . on ( 's' , ( request , socket , head ) => { const pathname = parse ( request . url ) . pathname if ( pathname === 's' ) { wss . handleUpgrade ( request , socket , head , ws => wss . emit ( 's' , ws , request ) ) } } ) return server } export { trackerRouter , createWebsocketTrackerServer } function runPeersChecker ( ) { setInterval ( ( ) => { logger . debug ( 's' ) for ( const ip of Object . keys ( peersIpInfoHash ) ) { if ( peersIps [ ip ] > TRACKER_RATE_LIMITS . ANNOUNCES_PER_IP ) { logger . warn ( 's' , ip , peersIps [ ip ] ) } } peersIpInfoHash = { } peersIps = { } } , TRACKER_RATE_LIMITS . INTERVAL ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { param } from 's' import { logger } from 's' import { areValidationErrors } from 's' import { isPluginNameValid , isPluginVersionValid } from 's' import { PluginManager } from 's' import { isSafePath } from 's' const serveThemeCSSValidator = [ param ( 's' ) . custom ( isPluginNameValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isPluginVersionValid ) . withMessage ( 's' ) , param ( 's' ) . custom ( isSafePath ) . withMessage ( 's' ) , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { logger . debug ( 's' , { parameters : req . params } ) if ( areValidationErrors ( req , res ) ) return const theme = PluginManager . Instance . getRegisteredTheme ( req . params . themeName ) if ( ! theme || theme . version !== req . params . themeVersion ) { return res . sendStatus ( 0 ) } if ( theme . css . includes ( req . params . staticEndpoint ) === false ) { return res . sendStatus ( 0 ) } res . locals . registeredPlugin = theme return next ( ) } ] export { serveThemeCSSValidator }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' import { PLUGIN_GLOBAL_CSS_PATH } from 's' import { join } from 's' import { PluginManager , RegisteredPlugin } from 's' import { servePluginStaticDirectoryValidator } from 's' import { serveThemeCSSValidator } from 's' import { PluginType } from 's' import { isTestInstance } from 's' import { getCompleteLocale , 0 } from 's' const sendFileOptions = { maxAge : 's' , immutable : ! isTestInstance ( ) } const pluginsRouter = express . Router ( ) pluginsRouter . get ( 's' , servePluginGlobalCSS ) pluginsRouter . get ( 's' , getPluginTranslations ) pluginsRouter . get ( 's' , servePluginStaticDirectoryValidator ( PluginType . PLUGIN ) , servePluginStaticDirectory ) pluginsRouter . get ( 's' , servePluginStaticDirectoryValidator ( PluginType . PLUGIN ) , servePluginClientScripts ) pluginsRouter . get ( 's' , servePluginStaticDirectoryValidator ( PluginType . THEME ) , servePluginStaticDirectory ) pluginsRouter . get ( 's' , servePluginStaticDirectoryValidator ( PluginType . THEME ) , servePluginClientScripts ) pluginsRouter . get ( 's' , serveThemeCSSValidator , serveThemeCSSDirectory ) export { pluginsRouter } function servePluginGlobalCSS ( req : express . Request , res : express . Response ) { const globalCSSOptions = req . query . hash ? sendFileOptions : { } return res . sendFile ( PLUGIN_GLOBAL_CSS_PATH , globalCSSOptions ) } function getPluginTranslations ( req : express . Request , res : express . Response ) { const locale = req . params . locale if ( 0 ( locale ) ) { const completeLocale = getCompleteLocale ( locale ) const json = PluginManager . Instance . getTranslations ( completeLocale ) return res . json ( json ) } return res . sendStatus ( 0 ) } function servePluginStaticDirectory ( req : express . Request , res : express . Response ) { const plugin = res . locals . registeredPlugin const staticEndpoint = req . params . staticEndpoint const [ directory , ... file ] = staticEndpoint . split ( 's' ) const staticPath = plugin . staticDirs [ directory ] if ( ! staticPath ) { return res . sendStatus ( 0 ) } const filepath = file . join ( 's' ) return res . sendFile ( join ( plugin . path , staticPath , filepath ) , sendFileOptions ) } function servePluginClientScripts ( req : express . Request , res : express . Response ) { const plugin = res . locals . registeredPlugin const staticEndpoint = req . params . staticEndpoint const file = plugin . clientScripts [ staticEndpoint ] if ( ! file ) { return res . sendStatus ( 0 ) } return res . sendFile ( join ( plugin . path , staticEndpoint ) , sendFileOptions ) } function serveThemeCSSDirectory ( req : express . Request , res : express . Response ) { const plugin = res . locals . registeredPlugin const staticEndpoint = req . params . staticEndpoint if ( plugin . css . includes ( staticEndpoint ) === false ) { return res . sendStatus ( 0 ) } return res . sendFile ( join ( plugin . path , staticEndpoint ) , sendFileOptions ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisteredPlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisteredPlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegisteredPlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ModelAttributeColumnOptions } from 's' declare namespace Migration { interface Boolean extends ModelAttributeColumnOptions { defaultValue : boolean | null } interface String extends ModelAttributeColumnOptions { defaultValue : string | null } interface Integer extends ModelAttributeColumnOptions { defaultValue : number | null } interface BigInteger extends ModelAttributeColumnOptions { defaultValue : number | null } interface UUID extends ModelAttributeColumnOptions { defaultValue : null } } export { Migration }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . STRING ( 0 ) , allowNull : false , defaultValue : 's' } as Migration . String return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query , { transaction : utils . transaction } ) } ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . STRING ( 0 ) , allowNull : false , defaultValue : 's' } as Migration . String return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query , { transaction : utils . transaction } ) } ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : 0 } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : 0 } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : 0 } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : 0 } as Migration . Integer return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : 0 } as Migration . Integer return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } as Migration . Boolean return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const dataUUID = { type : Sequelize . UUID , defaultValue : Sequelize . 0 , allowNull : true } as Migration . UUID return q . addColumn ( 's' , 's' , dataUUID ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { dataUUID . defaultValue = null return q . changeColumn ( 's' , 's' , dataUUID ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { return removeForeignKey ( utils . sequelize , 's' ) } ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { return q . renameColumn ( 's' , 's' , 's' ) } ) . then ( ( ) => { return q . renameColumn ( 's' , 's' , 's' ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , false ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , false ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , false ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , false ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , false ) } ) . then ( ( ) => { return changeForeignKey ( q , utils . sequelize , 's' , true ) } ) . then ( ( ) => { return q . removeColumn ( 's' , 's' ) } ) . then ( ( ) => { const dataRemote = { type : Sequelize . BOOLEAN , defaultValue : false , allowNull : false } return q . addColumn ( 's' , 's' , dataRemote ) } ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { const query = 's' return utils . sequelize . query ( query ) } ) . then ( ( ) => { return q . removeColumn ( 's' , 's' ) } ) } function down ( options ) { throw new Error ( 's' ) } function removeForeignKey ( sequelize : Sequelize . Sequelize , tableName ) { const query = 's' + tableName + 's' + tableName + 's' + 's' return sequelize . query ( query ) } function changeForeignKey ( q : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , tableName , allowNull ) { const data = { type : Sequelize . INTEGER , allowNull : true } return q . addColumn ( tableName , 's' , data ) . then ( ( ) => { const query = 's' + tableName + 's' + 's' + tableName + 's' return sequelize . query ( query ) } ) . then ( ( ) => { if ( allowNull === false ) { data . allowNull = false return q . changeColumn ( tableName , 's' , data ) } return Promise . resolve ( ) } ) . then ( ( ) => { return q . removeColumn ( tableName , 's' ) } ) . then ( ( ) => { return q . renameColumn ( tableName , 's' , 's' ) } ) . then ( ( ) => { return q . addIndex ( tableName , [ 's' ] ) } ) . then ( ( ) => { const constraintName = tableName + 's' const query = 's' + tableName + 's' + 's' + constraintName + 's' + 's' return sequelize . query ( query ) } ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const query = 's' + 's' + 's' + 's' return utils . db . VideoFile . sync ( ) . then ( ( ) => utils . sequelize . query ( query ) ) . then ( ( ) => { return q . removeColumn ( 's' , 's' ) } ) . then ( ( ) => { return q . removeColumn ( 's' , 's' ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { stat } from 's' import { VideoModel } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { return utils . db . Video . listOwnedAndPopulateAuthorAndTags ( ) . then ( ( videos : VideoModel [ ] ) => { const tasks : Promise < any > [ ] = [ ] videos . forEach ( video => { video . VideoFiles . forEach ( videoFile => { const p = new Promise ( ( res , rej ) => { stat ( video . getVideoFilePath ( videoFile ) , ( err , stats ) => { if ( err ) return rej ( err ) videoFile . size = stats . size videoFile . save ( ) . then ( res ) . catch ( rej ) } ) } ) tasks . push ( p ) } ) } ) return tasks } ) . then ( ( tasks : Promise < any > [ ] ) => { return Promise . all ( tasks ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' import { Migration } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . BIGINT , allowNull : false , defaultValue : - 0 } as Migration . BigInteger return q . addColumn ( 's' , 's' , data ) . then ( ( ) => { data . defaultValue = null return q . changeColumn ( 's' , 's' , data ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { join } from 's' import { CONFIG } from 's' import { getVideoFileResolution } from 's' import { readdir , rename } from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const torrentDir = CONFIG . STORAGE . TORRENTS_DIR const videoFileDir = CONFIG . STORAGE . VIDEOS_DIR return readdir ( videoFileDir ) . then ( videoFiles => { const tasks : Promise < any > [ ] = [ ] for ( const videoFile of videoFiles ) { const matches = "s" . exec ( videoFile ) if ( matches === null ) { console . log ( 's' , videoFile ) continue } const uuid = matches [ 0 ] const ext = matches [ 0 ] const p = getVideoFileResolution ( join ( videoFileDir , videoFile ) ) . then ( height => { const oldTorrentName = uuid + 's' const newTorrentName = uuid + 's' + height + 's' return rename ( join ( torrentDir , oldTorrentName ) , join ( torrentDir , newTorrentName ) ) . then ( ( ) => height ) } ) . then ( height => { const newVideoFileName = uuid + 's' + height + 's' + ext return rename ( join ( videoFileDir , videoFile ) , join ( videoFileDir , newVideoFileName ) ) . then ( ( ) => height ) } ) . then ( height => { const query = 's' + height + 's' + uuid + 's' return utils . sequelize . query ( query ) } ) tasks . push ( p ) } return Promise . all ( tasks ) . then ( ( ) => undefined ) } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as 0 from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const dataAuthorUUID = { type : Sequelize . UUID , defaultValue : Sequelize . 0 , allowNull : true } await q . addColumn ( 's' , 's' , dataAuthorUUID ) { const authors = await utils . db . Author . findAll ( ) for ( const author of authors ) { author . uuid = 0 ( ) await author . save ( ) } } dataAuthorUUID . allowNull = false await q . changeColumn ( 's' , 's' , dataAuthorUUID ) const users = await utils . db . User . findAll ( ) for ( const user of users ) { const author = await utils . db . Author . find ( { where : { userId : user . id } } ) if ( ! author ) { await utils . db . Author . create ( { name : user . username , podId : null , userId : user . id } ) } } await utils . db . VideoChannel . sync ( ) const authors = await utils . db . Author . findAll ( ) for ( const author of authors ) { await utils . db . VideoChannel . create ( { name : `template` , remote : false , authorId : author . id } ) } const dataChannelId = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await q . addColumn ( 's' , 's' , dataChannelId ) const query = 's' const options = { type : Sequelize . QueryTypes . SELECT } const rawVideos = await utils . sequelize . query ( query , options ) as any for ( const rawVideo of rawVideos ) { const videoChannel = await utils . db . VideoChannel . findOne ( { where : { authorId : rawVideo . authorId } } ) const video = await utils . db . Video . findByPk ( rawVideo . id ) video . channelId = videoChannel . id await video . save ( ) } dataChannelId . allowNull = false await q . changeColumn ( 's' , 's' , dataChannelId ) const constraintName = 's' const queryForeignKey = 's' + 's' + constraintName + 's' + 's' await utils . sequelize . query ( queryForeignKey ) await q . removeColumn ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface await q . renameColumn ( 's' , 's' , 's' ) const data = { type : Sequelize . INTEGER , allowNull : true } await q . addColumn ( 's' , 's' , data ) let query = 's' await utils . sequelize . query ( query ) query = 's' await utils . sequelize . query ( query ) data . allowNull = false await q . changeColumn ( 's' , 's' , data ) await q . removeColumn ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . STRING ( 0 ) , allowNull : false } await q . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await q . addColumn ( 's' , 's' , data ) const query = 's' const options = { type : Sequelize . QueryTypes . BULKUPDATE } await utils . sequelize . query ( query , options ) data . allowNull = false await q . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { createPrivateAndPublicKeys } from 's' import { shareVideoByServerAndChannel } from 's' import { getVideoActivityPubUrl , getVideoChannelActivityPubUrl } from 's' import { createLocalAccountWithoutKeys } from 's' import { ApplicationModel } from 's' import { SERVER_ACTOR_NAME } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const q = utils . queryInterface const db = utils . db { const query = 's' const options = { type : Sequelize . QueryTypes . SELECT } const res = await utils . sequelize . query ( query , options ) as any if ( ! res [ 0 ] || res [ 0 ] . total !== 0 ) { throw new Error ( 's' ) } } await utils . queryInterface . renameTable ( 's' , 's' ) await db . Account . sync ( ) await db . AccountFollow . sync ( ) await db . VideoAbuse . destroy ( { truncate : true } ) await utils . queryInterface . removeColumn ( 's' , 's' ) await utils . queryInterface . removeColumn ( 's' , 's' ) { const data = { type : Sequelize . INTEGER , allowNull : false , references : { model : 's' , key : 's' } , onDelete : 's' } await q . addColumn ( 's' , 's' , data ) } await utils . queryInterface . dropTable ( 's' ) await utils . queryInterface . dropTable ( 's' ) await utils . queryInterface . dropTable ( 's' ) await utils . queryInterface . dropTable ( 's' ) { const applicationInstance = await ApplicationModel . findOne ( ) const accountCreated = await createLocalAccountWithoutKeys ( { name : SERVER_ACTOR_NAME , userId : null , applicationId : applicationInstance . id , t : undefined } ) const { publicKey , privateKey } = await createPrivateAndPublicKeys ( ) accountCreated . Actor . publicKey = publicKey accountCreated . Actor . privateKey = privateKey await accountCreated . save ( ) } { const query = 's' await utils . sequelize . query ( query ) } const users = await db . User . findAll ( ) for ( const user of users ) { const account = await createLocalAccountWithoutKeys ( { name : user . username , userId : user . id , applicationId : null , t : undefined } ) const { publicKey , privateKey } = await createPrivateAndPublicKeys ( ) account . Actor . publicKey = publicKey account . Actor . privateKey = privateKey await account . save ( ) } { const data = { type : Sequelize . INTEGER , allowNull : true , onDelete : 's' , reference : { model : 's' , key : 's' } } await q . addColumn ( 's' , 's' , data ) { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } data . allowNull = false await q . changeColumn ( 's' , 's' , data ) await q . removeColumn ( 's' , 's' ) } { const data = { type : Sequelize . STRING , defaultValue : null , allowNull : true } await q . addColumn ( 's' , 's' , data ) const videos = await db . Video . findAll ( ) for ( const video of videos ) { video . url = getVideoActivityPubUrl ( video ) await video . save ( ) } data . allowNull = false await q . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING , defaultValue : null , allowNull : true } await q . addColumn ( 's' , 's' , data ) const videoChannels = await db . VideoChannel . findAll ( ) for ( const videoChannel of videoChannels ) { videoChannel . url = getVideoChannelActivityPubUrl ( videoChannel ) await videoChannel . save ( ) } data . allowNull = false await q . changeColumn ( 's' , 's' , data ) } await utils . queryInterface . dropTable ( 's' ) await db . AccountVideoRate . sync ( ) { const data = { type : Sequelize . ENUM ( 's' , 's' ) , defaultValue : 's' , allowNull : false } await q . addColumn ( 's' , 's' , data ) } await db . VideoShare . sync ( ) await db . VideoChannelShare . sync ( ) { const videos = await db . Video . findAll ( { include : [ { model : db . Video [ 's' ] . models . VideoChannel , include : [ { model : db . Video [ 's' ] . models . Account , include : [ { model : db . Video [ 's' ] . models . Server , required : false } ] } ] } , { model : db . Video [ 's' ] . models . AccountVideoRate , include : [ db . Video [ 's' ] . models . Account ] } , { model : db . Video [ 's' ] . models . VideoShare , include : [ db . Video [ 's' ] . models . Account ] } , db . Video [ 's' ] . models . Tag , db . Video [ 's' ] . models . VideoFile ] } ) for ( const video of videos ) { await shareVideoByServerAndChannel ( video , undefined ) } } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { await utils . queryInterface . removeColumn ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { await utils . queryInterface . removeColumn ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { await utils . db . Avatar . sync ( ) const data = { type : Sequelize . INTEGER , allowNull : true , references : { model : 's' , key : 's' } , onDelete : 's' } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameTable ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import * as Promise from 's' function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const q = utils . queryInterface const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } return q . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { DataType } from 's' import { createPrivateAndPublicKeys } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const queries = [ `template` , `template` , `template` , `template` , `template` , `template` , `template` , `template` , `template` , `template` ] for ( const query of queries ) { await utils . sequelize . query ( query ) } } { const 0 = `template` await utils . sequelize . query ( 0 ) const 0 = `template` await utils . sequelize . query ( 0 ) } { const data = { type : DataType . INTEGER , allowNull : true , references : { model : 's' , key : 's' } , onDelete : 's' } await utils . queryInterface . addColumn ( 's' , 's' , data ) const 0 = `template` await utils . sequelize . query ( 0 ) data . allowNull = false await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const query = `template` await utils . sequelize . query ( query ) } { const data = { type : DataType . INTEGER , allowNull : true , references : { model : 's' , key : 's' } , onDelete : 's' } await utils . queryInterface . addColumn ( 's' , 's' , data ) const 0 = `template` await utils . sequelize . query ( 0 ) data . allowNull = false await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { await utils . queryInterface . renameTable ( 's' , 's' ) await utils . queryInterface . renameColumn ( 's' , 's' , 's' ) await utils . queryInterface . renameColumn ( 's' , 's' , 's' ) try { await utils . queryInterface . removeConstraint ( 's' , 's' ) await utils . queryInterface . removeConstraint ( 's' , 's' ) } catch { await utils . queryInterface . removeConstraint ( 's' , 's' ) await utils . queryInterface . removeConstraint ( 's' , 's' ) } { const 0 = `template` await utils . sequelize . query ( 0 ) const 0 = `template` await utils . sequelize . query ( 0 ) } { const 0 = `template` await utils . sequelize . query ( 0 ) const 0 = `template` await utils . sequelize . query ( 0 ) } } { await utils . queryInterface . renameColumn ( 's' , 's' , 's' ) try { await utils . queryInterface . removeConstraint ( 's' , 's' ) } catch { await utils . queryInterface . removeConstraint ( 's' , 's' ) } const query = `template` await utils . sequelize . query ( query ) { const 0 = `template` await utils . sequelize . query ( 0 ) const 0 = `template` await utils . sequelize . query ( 0 ) } } { const columnsToDelete = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] for ( const columnToDelete of columnsToDelete ) { await utils . queryInterface . removeColumn ( 's' , columnToDelete ) } } { const columnsToDelete = [ 's' , 's' , 's' ] for ( const columnToDelete of columnsToDelete ) { await utils . queryInterface . removeColumn ( 's' , columnToDelete ) } } { const query = 's' const options = { type : Sequelize . QueryTypes . SELECT as Sequelize . QueryTypes . SELECT } const [ res ] = await utils . sequelize . query ( query , options ) for ( const actor of res ) { const { privateKey , publicKey } = await createPrivateAndPublicKeys ( ) const queryUpdate = `template` await utils . sequelize . query ( queryUpdate ) } } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { WEBSERVER } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const toReplace = WEBSERVER . HOSTNAME + 's' const by = WEBSERVER . HOST const replacer = column => `template` { const query = `template` await utils . sequelize . query ( query ) } { const query = `template` await utils . sequelize . query ( query ) } { const query = `template` await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { await utils . queryInterface . dropTable ( 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { await utils . queryInterface . removeConstraint ( 's' , 's' ) await utils . queryInterface . addConstraint ( 's' , [ 's' ] , { type : 's' , references : { table : 's' , field : 's' } , onDelete : 's' , onUpdate : 's' } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { Migration } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } as Migration . Boolean await utils . queryInterface . addColumn ( 's' , 's' , data ) data . defaultValue = null return utils . queryInterface . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const toReplace = 's' const by = 's' const replacer = column => `template` const query = `template` await utils . sequelize . query ( query ) } { const toReplace = 's' const by = 's' const replacer = column => `template` const query = `template` await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const toReplace = 's' const by = 's' const replacer = column => `template` const query = `template` await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { ACTOR_FOLLOW_SCORE } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { await utils . queryInterface . removeColumn ( 's' , 's' ) const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : ACTOR_FOLLOW_SCORE . BASE } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const query = 's' + 's' + 's' + 's' await utils . sequelize . query ( query ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { await utils . queryInterface . dropTable ( 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . STRING , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) const query = `template` await utils . sequelize . query ( query ) data . allowNull = false await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . DATE , allowNull : true , defaultValue : Sequelize . NOW } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . DATE , allowNull : false , defaultValue : Sequelize . NOW } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . ENUM ( 's' , 's' , 's' ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const query = 's' await utils . sequelize . query ( query ) } { const query = 's' await utils . sequelize . query ( query ) } { await utils . queryInterface . removeColumn ( 's' , 's' ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { CONSTRAINTS_FIELDS } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { await utils . queryInterface . renameColumn ( 's' , 's' , 's' ) } { const data = { type : Sequelize . STRING ( CONSTRAINTS_FIELDS . VIDEOS . LANGUAGE . max ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const languages = [ { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } , { oldLanguage : 0 , newLanguage : 's' } ] for ( const language of languages ) { const query = 's' + language . newLanguage + 's' + language . oldLanguage await utils . sequelize . query ( query ) } } { await utils . queryInterface . removeColumn ( 's' , 's' ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { await utils . sequelize . query ( 's' ) await utils . sequelize . query ( 's' ) for ( let i = 0 ; i < 0 ; i ++ ) { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } for ( let i = 0 ; i < 0 ; i ++ ) { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } for ( let i = 0 ; i < 0 ; i ++ ) { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { const indexNames = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] for ( const indexName of indexNames ) { await utils . sequelize . query ( 's' + indexName + 's' ) } await utils . sequelize . query ( 's' ) await utils . sequelize . query ( 's' ) await utils . sequelize . query ( 's' ) await utils . sequelize . query ( 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . BOOLEAN , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { VideoAbuseState } from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' + VideoAbuseState . PENDING await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { VideoAbuseState } from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . BIGINT , allowNull : false , defaultValue : - 0 } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . BOOLEAN , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const query = 's' await utils . sequelize . query ( query ) } { const query = 's' + 's' await utils . sequelize . query ( query ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : - 0 } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } async function down ( utils : { transaction : Sequelize . Transaction queryInterface : Sequelize . QueryInterface sequelize : Sequelize . Sequelize } ) < any > { await utils . queryInterface . removeColumn ( 's' , 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const builtUrlQuery = `template` + 's' + 's' + 's' + 's' const query = 's' + builtUrlQuery + 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { await utils . queryInterface . renameColumn ( 's' , 's' , 's' ) } { const data = { type : Sequelize . STRING , defaultValue : null , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . STRING , defaultValue : null , allowNull : false } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { await utils . queryInterface . removeColumn ( 's' , 's' ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const query = `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` await utils . sequelize . query ( query ) } { const query = `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` + `template` await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const indexNames = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] for ( const indexName of indexNames ) { await utils . sequelize . query ( 's' + indexName + 's' ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const query = `template` await utils . sequelize . query ( query ) } { const query = 's' + 's' + 's' + 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const data = { type : Sequelize . STRING ( 0 ) , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { { const query = `template` await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const query = 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { Migration } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } as Migration . Boolean await utils . queryInterface . addColumn ( 's' , 's' , data ) data . defaultValue = null return utils . queryInterface . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const data = { type : Sequelize . DATE , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { VideoPlaylistPrivacy , VideoPlaylistType } from 's' import * as 0 from 's' import { WEBSERVER } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize } ) < void > { const transaction = utils . transaction { const query = `template` await utils . sequelize . query ( query , { transaction } ) } { const query = `template` await utils . sequelize . query ( query , { transaction } ) } { const userQuery = 's' const options = { transaction , type : Sequelize . QueryTypes . SELECT as Sequelize . QueryTypes . SELECT } const userResult = await utils . sequelize . query < { username : string } > ( userQuery , options ) const usernames = userResult . map ( r => r . username ) for ( const username of usernames ) { const uuid = 0 ( ) const baseUrl = WEBSERVER . URL + 's' + uuid const query = `template` await utils . sequelize . query ( query , { transaction } ) } } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' import { VideoBlacklistType } from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' + VideoBlacklistType . MANUAL await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : false } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = `template` await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : false } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : false } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const query = `template` await utils . sequelize . query ( query ) } { const query = 's' + 's' await utils . sequelize . query ( query ) } { const query = 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { try { await utils . queryInterface . removeColumn ( 's' , 's' ) } catch { } try { await utils . queryInterface . removeColumn ( 's' , 's' ) } catch { } try { await utils . queryInterface . removeColumn ( 's' , 's' ) } catch { } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { await utils . queryInterface . removeColumn ( 's' , 's' ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const data = { type : Sequelize . STRING ( 0 ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const data = { type : Sequelize . ARRAY ( Sequelize . STRING ) , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const data = { type : Sequelize . STRING , allowNull : false , defaultValue : 's' } await utils . queryInterface . addColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const query = `template` await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , allowNull : true , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } await utils . queryInterface . removeConstraint ( 's' , 's' ) await utils . queryInterface . addConstraint ( 's' , [ 's' ] , { type : 's' , references : { table : 's' , field : 's' } , onDelete : 's' , onUpdate : 's' } ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' + 's' await utils . sequelize . query ( query ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const query = 's' + 's' + 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . STRING , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . BOOLEAN , allowNull : true , defaultValue : null } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : null } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { const data = { type : Sequelize . STRING , allowNull : true } await utils . queryInterface . changeColumn ( 's' , 's' , data ) await utils . queryInterface . changeColumn ( 's' , 's' , data ) await utils . queryInterface . changeColumn ( 's' , 's' , data ) } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const query = 's' await utils . sequelize . query ( query ) } { const data = { type : Sequelize . INTEGER , defaultValue : null , allowNull : false } await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } await utils . queryInterface . addColumn ( 's' , 's' , data ) } { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : true } await utils . queryInterface . addColumn ( 's' , 's' , data ) data . defaultValue = false await utils . queryInterface . changeColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Sequelize from 's' async function up ( utils : { transaction : Sequelize . Transaction , queryInterface : Sequelize . QueryInterface , sequelize : Sequelize . Sequelize , db : any } ) < void > { { const data = { type : Sequelize . BOOLEAN , allowNull : false , defaultValue : false } await utils . queryInterface . addColumn ( 's' , 's' , data ) } } function down ( options ) { throw new Error ( 's' ) } export { up , down }	O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import * as Bluebird from 's' export abstract class AbstractScheduler { protected abstract schedulerIntervalMs : number private interval : NodeJS . Timer private isRunning = false enable ( ) { if ( ! this . schedulerIntervalMs ) throw new Error ( 's' ) this . interval = setInterval ( ( ) => this . execute ( ) , this . schedulerIntervalMs ) } disable ( ) { clearInterval ( this . interval ) } async execute ( ) { if ( this . isRunning === true ) return this . isRunning = true try { await this . internalExecute ( ) } catch ( err ) { logger . error ( 's' , this . constructor . name , { err } ) } finally { this . isRunning = false } } protected abstract internalExecute ( ) : Promise < any > | Bluebird < any > }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isTestInstance } from 's' import { logger } from 's' import { ActorFollowModel } from 's' import { AbstractScheduler } from 's' import { ACTOR_FOLLOW_SCORE , SCHEDULER_INTERVALS_MS } from 's' import { ActorFollowScoreCache } from 's' export class ActorFollowScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . actorFollowScores private constructor ( ) { super ( ) } protected async internalExecute ( ) { await this . processPendingScores ( ) await this . removeBadActorFollows ( ) } private async processPendingScores ( ) { const pendingScores = ActorFollowScoreCache . Instance . getPendingFollowsScore ( ) const badServerIds = ActorFollowScoreCache . Instance . getBadFollowingServerIds ( ) const goodServerIds = ActorFollowScoreCache . Instance . getGoodFollowingServerIds ( ) ActorFollowScoreCache . Instance . clearPendingFollowsScore ( ) ActorFollowScoreCache . Instance . clearBadFollowingServerIds ( ) ActorFollowScoreCache . Instance . clearGoodFollowingServerIds ( ) for ( const inbox of Object . keys ( pendingScores ) ) { await ActorFollowModel . updateScore ( inbox , pendingScores [ inbox ] ) } await ActorFollowModel . updateScoreByFollowingServers ( badServerIds , ACTOR_FOLLOW_SCORE . PENALTY ) await ActorFollowModel . updateScoreByFollowingServers ( goodServerIds , ACTOR_FOLLOW_SCORE . BONUS ) } private async removeBadActorFollows ( ) { if ( ! isTestInstance ( ) ) logger . info ( 's' ) try { await ActorFollowModel . removeBadActorFollows ( ) } catch ( err ) { logger . error ( 's' , { err } ) } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { AbstractScheduler } from 's' import { INSTANCES_INDEX , SCHEDULER_INTERVALS_MS , SERVER_ACTOR_NAME } from 's' import { CONFIG } from 's' import { chunk } from 's' import { doRequest } from 's' import { ActorFollowModel } from 's' import { JobQueue } from 's' import { getServerActor } from 's' export class AutoFollowIndexInstances extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . autoFollowIndexInstances private lastCheck : Date private constructor ( ) { super ( ) } protected async internalExecute ( ) { return this . autoFollow ( ) } private async autoFollow ( ) { if ( CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_INDEX . ENABLED === false ) return const indexUrl = CONFIG . FOLLOWINGS . INSTANCE . AUTO_FOLLOW_INDEX . INDEX_URL logger . info ( 's' , indexUrl ) try { const serverActor = await getServerActor ( ) const uri = indexUrl + INSTANCES_INDEX . HOSTS_PATH const qs = this . lastCheck ? { since : this . lastCheck . toISOString ( ) } : { } this . lastCheck = new Date ( ) const { body } = await doRequest ( { uri , qs , json : true } ) const hosts : string [ ] = body . data . map ( o => o . host ) const chunks = chunk ( hosts , 0 ) for ( const chunk of chunks ) { const unfollowedHosts = await ActorFollowModel . keepUnfollowedInstance ( chunk ) for ( const unfollowedHost of unfollowedHosts ) { const payload = { host : unfollowedHost , name : SERVER_ACTOR_NAME , followerActorId : serverActor . id , isAutoFollow : true } await JobQueue . Instance . createJob ( { type : 's' , payload } ) . catch ( err => logger . error ( 's' , unfollowedHost , err ) ) } } } catch ( err ) { logger . error ( 's' , indexUrl , { err } ) } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { AbstractScheduler } from 's' import { SCHEDULER_INTERVALS_MS } from 's' import { CONFIG } from 's' import { PluginModel } from 's' import { chunk } from 's' import { getLatestPluginsVersion } from 's' import { compareSemVer } from 's' export class PluginsCheckScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . checkPlugins private constructor ( ) { super ( ) } protected async internalExecute ( ) { return this . checkLatestPluginsVersion ( ) } private async checkLatestPluginsVersion ( ) { if ( CONFIG . PLUGINS . INDEX . ENABLED === false ) return logger . info ( 's' ) const plugins = await PluginModel . listInstalled ( ) const chunks = chunk ( plugins , 0 ) for ( const chunk of chunks ) { const pluginIndex : { [ npmName ] : PluginModel } = { } for ( const plugin of chunk ) { pluginIndex [ PluginModel . buildNpmName ( plugin . name , plugin . type ) ] = plugin } const npmNames = Object . keys ( pluginIndex ) try { const results = await getLatestPluginsVersion ( npmNames ) for ( const result of results ) { const plugin = pluginIndex [ result . npmName ] if ( ! result . latestVersion ) continue if ( ! plugin . latestVersion || ( plugin . latestVersion !== result . latestVersion && compareSemVer ( plugin . latestVersion , result . latestVersion ) < 0 ) ) { plugin . latestVersion = result . latestVersion await plugin . save ( ) logger . info ( 's' , result . npmName , plugin . latestVersion ) } } } catch ( err ) { logger . error ( 's' , { npmNames , err } ) } } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { AbstractScheduler } from 's' import { SCHEDULER_INTERVALS_MS } from 's' import { UserVideoHistoryModel } from 's' import { CONFIG } from 's' export class RemoveOldHistoryScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . removeOldHistory private constructor ( ) { super ( ) } protected internalExecute ( ) { if ( CONFIG . HISTORY . VIDEOS . MAX_AGE === - 0 ) return logger . info ( 's' ) const now = new Date ( ) const beforeDate = new Date ( now . getTime ( ) - CONFIG . HISTORY . VIDEOS . MAX_AGE ) . toISOString ( ) return UserVideoHistoryModel . removeOldHistory ( beforeDate ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { isTestInstance } from 's' import { logger } from 's' import { JobQueue } from 's' import { AbstractScheduler } from 's' import { SCHEDULER_INTERVALS_MS } from 's' export class RemoveOldJobsScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . removeOldJobs private constructor ( ) { super ( ) } protected internalExecute ( ) { if ( ! isTestInstance ( ) ) logger . info ( 's' ) return JobQueue . Instance . removeOldJobs ( ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { AbstractScheduler } from 's' import { SCHEDULER_INTERVALS_MS } from 's' import { UserVideoHistoryModel } from 's' import { CONFIG } from 's' import { isTestInstance } from 's' import { VideoViewModel } from 's' export class RemoveOldViewsScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . removeOldViews private constructor ( ) { super ( ) } protected internalExecute ( ) { if ( CONFIG . VIEWS . VIDEOS . REMOTE . MAX_AGE === - 0 ) return logger . info ( 's' ) const now = new Date ( ) const beforeDate = new Date ( now . getTime ( ) - CONFIG . VIEWS . VIDEOS . REMOTE . MAX_AGE ) . toISOString ( ) return VideoViewModel . removeOldRemoteViewsHistory ( beforeDate ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { logger } from 's' import { AbstractScheduler } from 's' import { ScheduleVideoUpdateModel } from 's' import { retryTransactionWrapper } from 's' import { federateVideoIfNeeded } from 's' import { SCHEDULER_INTERVALS_MS } from 's' import { VideoPrivacy } from 's' import { Notifier } from 's' import { VideoModel } from 's' import { sequelizeTypescript } from 's' export class UpdateVideosScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . updateVideos private constructor ( ) { super ( ) } protected async internalExecute ( ) { return retryTransactionWrapper ( this . updateVideos . bind ( this ) ) } private async updateVideos ( ) { if ( ! await ScheduleVideoUpdateModel . areVideosToUpdate ( ) ) return undefined const publishedVideos = await sequelizeTypescript . transaction ( async t => { const schedules = await ScheduleVideoUpdateModel . listVideosToUpdate ( t ) const publishedVideos : VideoModel [ ] = [ ] for ( const schedule of schedules ) { const video = schedule . Video logger . info ( 's' , video . uuid ) if ( schedule . privacy ) { const oldPrivacy = video . privacy const isNewVideo = oldPrivacy === VideoPrivacy . PRIVATE video . privacy = schedule . privacy if ( isNewVideo === true ) video . publishedAt = new Date ( ) await video . save ( { transaction : t } ) await federateVideoIfNeeded ( video , isNewVideo , t ) if ( oldPrivacy === VideoPrivacy . UNLISTED || oldPrivacy === VideoPrivacy . PRIVATE ) { video . ScheduleVideoUpdate = schedule publishedVideos . push ( video ) } } await schedule . destroy ( { transaction : t } ) } return publishedVideos } ) for ( const v of publishedVideos ) { Notifier . Instance . notifyOnNewVideoIfNeeded ( v ) Notifier . Instance . notifyOnVideoPublishedAfterScheduledUpdate ( v ) } } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AbstractScheduler } from 's' import { HLS_REDUNDANCY_DIRECTORY , REDUNDANCY , VIDEO_IMPORT_TIMEOUT , WEBSERVER } from 's' import { logger } from 's' import { VideosRedundancy } from 's' import { VideoRedundancyModel } from 's' import { downloadWebTorrentVideo } from 's' import { join } from 's' import { move } from 's' import { getServerActor } from 's' import { sendCreateCacheFile , sendUpdateCacheFile } from 's' import { getVideoCacheFileActivityPubUrl , getVideoCacheStreamingPlaylistActivityPubUrl } from 's' import { removeVideoRedundancy } from 's' import { getOrCreateVideoAndAccountAndChannel } from 's' import { downloadPlaylistSegments } from 's' import { CONFIG } from 's' import { MStreamingPlaylist , MStreamingPlaylistVideo , MVideoAccountLight , MVideoFile , MVideoFileVideo , MVideoRedundancyFileVideo , MVideoRedundancyStreamingPlaylistVideo , MVideoRedundancyVideo , MVideoWithAllFiles } from 's' type CandidateToDuplicate = { redundancy : VideosRedundancy , video : MVideoWithAllFiles , files : MVideoFile [ ] , streamingPlaylists : MStreamingPlaylist [ ] } function isMVideoRedundancyFileVideo ( o : MVideoRedundancyFileVideo | MVideoRedundancyStreamingPlaylistVideo ) : o is MVideoRedundancyFileVideo { return ! ! ( o as MVideoRedundancyFileVideo ) . VideoFile } export class VideosRedundancyScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = CONFIG . REDUNDANCY . VIDEOS . CHECK_INTERVAL private constructor ( ) { super ( ) } protected async internalExecute ( ) { for ( const redundancyConfig of CONFIG . REDUNDANCY . VIDEOS . STRATEGIES ) { logger . info ( 's' , redundancyConfig . strategy ) try { const videoToDuplicate = await this . findVideoToDuplicate ( redundancyConfig ) if ( ! videoToDuplicate ) continue const candidateToDuplicate = { video : videoToDuplicate , redundancy : redundancyConfig , files : videoToDuplicate . VideoFiles , streamingPlaylists : videoToDuplicate . VideoStreamingPlaylists } await this . purgeCacheIfNeeded ( candidateToDuplicate ) if ( await this . isTooHeavy ( candidateToDuplicate ) ) { logger . info ( 's' , videoToDuplicate . url ) continue } logger . info ( 's' , videoToDuplicate . url , redundancyConfig . strategy ) await this . createVideoRedundancies ( candidateToDuplicate ) } catch ( err ) { logger . error ( 's' , redundancyConfig . strategy , { err } ) } } await this . extendsLocalExpiration ( ) await this . purgeRemoteExpired ( ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } private async extendsLocalExpiration ( ) { const expired = await VideoRedundancyModel . listLocalExpired ( ) for ( const redundancyModel of expired ) { try { const redundancyConfig = CONFIG . REDUNDANCY . VIDEOS . STRATEGIES . find ( s => s . strategy === redundancyModel . strategy ) const candidate = { redundancy : redundancyConfig , video : null , files : [ ] , streamingPlaylists : [ ] } if ( ! redundancyConfig || await this . isTooHeavy ( candidate ) ) { logger . info ( 's' , redundancyModel . url , redundancyModel . strategy ) await removeVideoRedundancy ( redundancyModel ) } else { await this . extendsRedundancy ( redundancyModel ) } } catch ( err ) { logger . error ( 's' , this . buildEntryLogId ( redundancyModel ) , { err } ) } } } private async extendsRedundancy ( redundancyModel ) { const redundancy = CONFIG . REDUNDANCY . VIDEOS . STRATEGIES . find ( s => s . strategy === redundancyModel . strategy ) if ( ! redundancy ) { await removeVideoRedundancy ( redundancyModel ) return } await this . extendsExpirationOf ( redundancyModel , redundancy . minLifetime ) } private async purgeRemoteExpired ( ) { const expired = await VideoRedundancyModel . listRemoteExpired ( ) for ( const redundancyModel of expired ) { try { await removeVideoRedundancy ( redundancyModel ) } catch ( err ) { logger . error ( 's' , this . buildEntryLogId ( redundancyModel ) ) } } } private findVideoToDuplicate ( cache ) { if ( cache . strategy === 's' ) { return VideoRedundancyModel . findMostViewToDuplicate ( REDUNDANCY . VIDEOS . RANDOMIZED_FACTOR ) } if ( cache . strategy === 's' ) { return VideoRedundancyModel . findTrendingToDuplicate ( REDUNDANCY . VIDEOS . RANDOMIZED_FACTOR ) } if ( cache . strategy === 's' ) { const minViews = cache . minViews return VideoRedundancyModel . findRecentlyAddedToDuplicate ( REDUNDANCY . VIDEOS . RANDOMIZED_FACTOR , minViews ) } } private async createVideoRedundancies ( data ) { const video = await this . loadAndRefreshVideo ( data . video . url ) if ( ! video ) { logger . info ( 's' , data . video . url ) return } for ( const file of data . files ) { const existingRedundancy = await VideoRedundancyModel . loadLocalByFileId ( file . id ) if ( existingRedundancy ) { await this . extendsRedundancy ( existingRedundancy ) continue } await this . createVideoFileRedundancy ( data . redundancy , video , file ) } for ( const streamingPlaylist of data . streamingPlaylists ) { const existingRedundancy = await VideoRedundancyModel . loadLocalByStreamingPlaylistId ( streamingPlaylist . id ) if ( existingRedundancy ) { await this . extendsRedundancy ( existingRedundancy ) continue } await this . createStreamingPlaylistRedundancy ( data . redundancy , video , streamingPlaylist ) } } private async createVideoFileRedundancy ( redundancy , video , fileArg ) { const file = fileArg as MVideoFileVideo file . Video = video const serverActor = await getServerActor ( ) logger . info ( 's' , video . url , file . resolution , redundancy . strategy ) const { baseUrlHttp , baseUrlWs } = video . getBaseUrls ( ) const magnetUri = video . generateMagnetUri ( file , baseUrlHttp , baseUrlWs ) const tmpPath = await downloadWebTorrentVideo ( { magnetUri } , VIDEO_IMPORT_TIMEOUT ) const destPath = join ( CONFIG . STORAGE . REDUNDANCY_DIR , video . getVideoFilename ( file ) ) await move ( tmpPath , destPath , { overwrite : true } ) const createdModel = await VideoRedundancyModel . create ( { expiresOn : this . buildNewExpiration ( redundancy . minLifetime ) , url : getVideoCacheFileActivityPubUrl ( file ) , fileUrl : video . getVideoRedundancyUrl ( file , WEBSERVER . URL ) , strategy : redundancy . strategy , videoFileId : file . id , actorId : serverActor . id } ) createdModel . VideoFile = file await sendCreateCacheFile ( serverActor , video , createdModel ) logger . info ( 's' , video . url , file . resolution , createdModel . url ) } private async createStreamingPlaylistRedundancy ( redundancy , video , playlistArg ) { const playlist = playlistArg as MStreamingPlaylistVideo playlist . Video = video const serverActor = await getServerActor ( ) logger . info ( 's' , video . url , redundancy . strategy ) const destDirectory = join ( HLS_REDUNDANCY_DIRECTORY , video . uuid ) await downloadPlaylistSegments ( playlist . playlistUrl , destDirectory , VIDEO_IMPORT_TIMEOUT ) const createdModel = await VideoRedundancyModel . create ( { expiresOn : this . buildNewExpiration ( redundancy . minLifetime ) , url : getVideoCacheStreamingPlaylistActivityPubUrl ( video , playlist ) , fileUrl : playlist . getVideoRedundancyUrl ( WEBSERVER . URL ) , strategy : redundancy . strategy , videoStreamingPlaylistId : playlist . id , actorId : serverActor . id } ) createdModel . VideoStreamingPlaylist = playlist await sendCreateCacheFile ( serverActor , video , createdModel ) logger . info ( 's' , playlist . playlistUrl , createdModel . url ) } private async extendsExpirationOf ( redundancy , expiresAfterMs ) { logger . info ( 's' , redundancy . url ) const serverActor = await getServerActor ( ) redundancy . expiresOn = this . buildNewExpiration ( expiresAfterMs ) await redundancy . save ( ) await sendUpdateCacheFile ( serverActor , redundancy ) } private async purgeCacheIfNeeded ( candidateToDuplicate ) { while ( await this . isTooHeavy ( candidateToDuplicate ) ) { const redundancy = candidateToDuplicate . redundancy const toDelete = await VideoRedundancyModel . loadOldestLocalExpired ( redundancy . strategy , redundancy . minLifetime ) if ( ! toDelete ) return await removeVideoRedundancy ( toDelete ) } } private async isTooHeavy ( candidateToDuplicate ) { const maxSize = candidateToDuplicate . redundancy . size const totalDuplicated = await VideoRedundancyModel . getTotalDuplicated ( candidateToDuplicate . redundancy . strategy ) const totalWillDuplicate = totalDuplicated + this . getTotalFileSizes ( candidateToDuplicate . files , candidateToDuplicate . streamingPlaylists ) return totalWillDuplicate > maxSize } private buildNewExpiration ( expiresAfterMs ) { return new Date ( Date . now ( ) + expiresAfterMs ) } private buildEntryLogId ( object : MVideoRedundancyFileVideo | MVideoRedundancyStreamingPlaylistVideo ) { if ( isMVideoRedundancyFileVideo ( object ) ) return `template` return `template` } private getTotalFileSizes ( files : MVideoFile [ ] , playlists : MStreamingPlaylist [ ] ) { const fileReducer = ( previous , current ) => previous + current . size const totalSize = files . reduce ( fileReducer , 0 ) return totalSize + ( totalSize * playlists . length ) } private async loadAndRefreshVideo ( videoUrl ) { const getVideoOptions = { videoObject : videoUrl , syncParam : { likes : false , dislikes : false , shares : false , comments : false , thumbnail : false , refreshVideo : true } , fetchType : 's' as 's' } const { video } = await getOrCreateVideoAndAccountAndChannel ( getVideoOptions ) return video } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoRedundancyVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosRedundancy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CandidateToDuplicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosRedundancy$ O $MVideoAccountLight$ O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoRedundancyFileVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosRedundancy$ O $MVideoAccountLight$ O $MStreamingPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoRedundancyStreamingPlaylistVideo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MVideoRedundancyVideo$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CandidateToDuplicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CandidateToDuplicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $MVideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AbstractScheduler } from 's' import { SCHEDULER_INTERVALS_MS } from 's' import { updateYoutubeDLBinary } from 's' export class YoutubeDlUpdateScheduler extends AbstractScheduler { private static instance : AbstractScheduler protected schedulerIntervalMs = SCHEDULER_INTERVALS_MS . youtubeDLUpdate private constructor ( ) { super ( ) } protected internalExecute ( ) { return updateYoutubeDLBinary ( ) } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' function makeActivityPubGetRequest ( url , path , expectedStatus = 0 ) { return request ( url ) . get ( path ) . set ( 's' , 's' ) . expect ( expectedStatus ) } export { makeActivityPubGetRequest }	O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import { basename , dirname , isAbsolute , join , resolve } from 's' import * as request from 's' import * as WebTorrent from 's' import { ensureDir , pathExists , readFile } from 's' import * as ffmpeg from 's' const expect = chai . expect let webtorrent : WebTorrent . Instance function immutableAssign < T , U > ( target : T , source : U ) { return Object . assign < { } , T , U > ( { } , target , source ) } function dateIsValid ( dateString , interval = 0 ) { const dateToCheck = new Date ( dateString ) const now = new Date ( ) return Math . abs ( now . getTime ( ) - dateToCheck . getTime ( ) ) <= interval } function wait ( milliseconds ) { return new Promise ( resolve => setTimeout ( resolve , milliseconds ) ) } function webtorrentAdd ( torrent , refreshWebTorrent = false ) { const WebTorrent = require ( 's' ) if ( ! webtorrent ) webtorrent = new WebTorrent ( ) if ( refreshWebTorrent === true ) webtorrent = new WebTorrent ( ) return new Promise < WebTorrent . Torrent > ( res => webtorrent . add ( torrent , res ) ) } function root ( ) { let root = join ( __dirname , 's' , 's' , 's' ) if ( basename ( root ) === 's' ) root = resolve ( root , 's' ) return root } function buildServerDirectory ( internalServerNumber , directory ) { return join ( root ( ) , 's' + internalServerNumber , directory ) } async function testImage ( url , imageName , imagePath , extension = 's' ) { const res = await request ( url ) . get ( imagePath ) . expect ( 0 ) const body = res . body const data = await readFile ( join ( root ( ) , 's' , 's' , 's' , imageName + extension ) ) const minLength = body . length - ( ( 0 * body . length ) / 0 ) const maxLength = body . length + ( ( 0 * body . length ) / 0 ) expect ( data . length ) . to . be . above ( minLength ) expect ( data . length ) . to . be . below ( maxLength ) } function buildAbsoluteFixturePath ( path , customCIPath = false ) { if ( isAbsolute ( path ) ) { return path } if ( customCIPath ) { if ( process . env . GITLAB_CI ) return join ( root ( ) , 's' , path ) if ( process . env . TRAVIS ) return join ( process . env . HOME , 's' , path ) } return join ( root ( ) , 's' , 's' , 's' , path ) } async function generateHighBitrateVideo ( ) { const tempFixturePath = buildAbsoluteFixturePath ( 's' , true ) await ensureDir ( dirname ( tempFixturePath ) ) const exists = await pathExists ( tempFixturePath ) if ( ! exists ) { return new Promise < string > ( async ( res , rej ) => { ffmpeg ( ) . outputOptions ( [ 's' , 's' , 's' ] ) . outputOptions ( [ 's' , 's' , 's' , 's' ] ) . outputOptions ( [ 's' , 's' ] ) . output ( tempFixturePath ) . on ( 's' , rej ) . on ( 's' , ( ) => res ( tempFixturePath ) ) . run ( ) } ) } return tempFixturePath } export { dateIsValid , wait , buildServerDirectory , webtorrentAdd , immutableAssign , testImage , buildAbsoluteFixturePath , root , generateHighBitrateVideo }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChildProcess , exec , fork } from 's' import { join } from 's' import { root , wait } from 's' import { copy , pathExists , readdir , readFile , remove } from 's' import { existsSync } from 's' import { expect } from 's' import { VideoChannel } from 's' import { randomInt } from 's' interface ServerInfo { app : ChildProcess , url : string host : string port : number parallel : boolean internalServerNumber : number serverNumber : number client : { id : string , secret : string } user : { username : string , password : string , email ? : string } customConfigFile ? : string accessToken ? : string videoChannel ? : VideoChannel video ? : { id : number uuid : string name : string account : { name : string } } remoteVideo ? : { id : number uuid : string } videos ? : { id : number , uuid : string } [ ] } function parallelTests ( ) { return process . env . MOCHA_PARALLEL === 's' } function flushAndRunMultipleServers ( totalServers , configOverride ? ) { let apps = [ ] let i = 0 return new Promise < ServerInfo [ ] > ( res => { function anotherServerDone ( serverNumber , app ) { apps [ serverNumber - 0 ] = app i ++ if ( i === totalServers ) { return res ( apps ) } } for ( let j = 0 ; j <= totalServers ; j ++ ) { flushAndRunServer ( j , configOverride ) . then ( app => anotherServerDone ( j , app ) ) } } ) } function flushTests ( serverNumber ? ) { return new Promise < void > ( ( res , rej ) => { const suffix = serverNumber ? `template` : 's' return exec ( 's' + suffix , ( err , _stdout , stderr ) => { if ( err || stderr ) return rej ( err || new Error ( stderr ) ) return res ( ) } ) } ) } function randomServer ( ) { const low = 0 const high = 0 return randomInt ( low , high ) } async function flushAndRunServer ( serverNumber , configOverride ? , args = [ ] ) { const parallel = parallelTests ( ) const internalServerNumber = parallel ? randomServer ( ) : serverNumber const port = 0 + internalServerNumber await flushTests ( internalServerNumber ) const server = { app : null , port , internalServerNumber , parallel , serverNumber , url : `template` , host : `template` , client : { id : null , secret : null } , user : { username : null , password : null } } return runServer ( server , configOverride , args ) } async function runServer ( server , configOverrideArg ? , args = [ ] ) { const serverRunString = { 's' : false } const key = 's' + server . internalServerNumber + 's' serverRunString [ key ] = false const regexps = { client_id : 's' , client_secret : 's' , user_username : 's' , user_password : 's' } if ( server . internalServerNumber !== server . serverNumber ) { const basePath = join ( root ( ) , 's' ) const tmpConfigFile = join ( basePath , `template` ) await copy ( join ( basePath , `template` ) , tmpConfigFile ) server . customConfigFile = tmpConfigFile } const configOverride = { } if ( server . parallel ) { Object . assign ( configOverride , { listen : { port : server . port } , webserver : { port : server . port } , database : { suffix : 's' + server . internalServerNumber } , storage : { tmp : `template` , avatars : `template` , videos : `template` , streaming_playlists : `template` , redundancy : `template` , logs : `template` , previews : `template` , thumbnails : `template` , torrents : `template` , captions : `template` , cache : `template` , plugins : `template` } , admin : { email : `template` } } ) } if ( configOverrideArg !== undefined ) { Object . assign ( configOverride , configOverrideArg ) } const env = Object . create ( process . env ) env [ 's' ] = 's' env [ 's' ] = server . internalServerNumber . toString ( ) env [ 's' ] = JSON . stringify ( configOverride ) const options = { silent : true , env , detached : true } return new Promise < ServerInfo > ( res => { server . app = fork ( join ( root ( ) , 's' , 's' ) , args , options ) server . app . stdout . on ( 's' , function onStdout ( data ) { let dontContinue = false for ( const key of Object . keys ( regexps ) ) { const regexp = regexps [ key ] const matches = data . toString ( ) . match ( regexp ) if ( matches !== null ) { if ( key === 's' ) server . client . id = matches [ 0 ] else if ( key === 's' ) server . client . secret = matches [ 0 ] else if ( key === 's' ) server . user . username = matches [ 0 ] else if ( key === 's' ) server . user . password = matches [ 0 ] } } for ( const key of Object . keys ( serverRunString ) ) { if ( data . toString ( ) . indexOf ( key ) !== - 0 ) serverRunString [ key ] = true if ( serverRunString [ key ] === false ) dontContinue = true } if ( dontContinue === true ) return server . app . stdout . removeListener ( 's' , onStdout ) process . on ( 's' , ( ) => { try { process . kill ( server . app . pid ) } catch { } } ) res ( server ) } ) } ) } async function reRunServer ( server , configOverride ? ) { const newServer = await runServer ( server , configOverride ) server . app = newServer . app return server } function checkTmpIsEmpty ( server ) { return checkDirectoryIsEmpty ( server , 's' , [ 's' ] ) } async function checkDirectoryIsEmpty ( server , directory , exceptions : string [ ] = [ ] ) { const testDirectory = 's' + server . internalServerNumber const directoryPath = join ( root ( ) , testDirectory , directory ) const directoryExists = await pathExists ( directoryPath ) expect ( directoryExists ) . to . be . true const files = await readdir ( directoryPath ) const filtered = files . filter ( f => exceptions . includes ( f ) === false ) expect ( filtered ) . to . have . lengthOf ( 0 ) } function killallServers ( servers : ServerInfo [ ] ) { for ( const server of servers ) { if ( ! server . app ) continue process . kill ( - server . app . pid ) server . app = null } } function cleanupTests ( servers : ServerInfo [ ] ) { killallServers ( servers ) const p : Promise < any > [ ] = [ ] for ( const server of servers ) { if ( server . parallel ) { p . push ( flushTests ( server . internalServerNumber ) ) } if ( server . customConfigFile ) { p . push ( remove ( server . customConfigFile ) ) } } return Promise . all ( p ) } async function waitUntilLog ( server , str , count = 0 ) { const logfile = join ( root ( ) , 's' + server . internalServerNumber , 's' ) while ( true ) { const buf = await readFile ( logfile ) const matches = buf . toString ( ) . match ( new RegExp ( str , 's' ) ) if ( matches && matches . length === count ) return await wait ( 0 ) } } export { checkDirectoryIsEmpty , checkTmpIsEmpty , ServerInfo , parallelTests , cleanupTests , flushAndRunMultipleServers , flushTests , flushAndRunServer , killallServers , reRunServer , waitUntilLog }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $Object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exec } from 's' import { ServerInfo } from 's' function getEnvCli ( server ? ) { return `template` } async function execCLI ( command ) { return new Promise < string > ( ( res , rej ) => { exec ( command , ( err , stdout , stderr ) => { if ( err ) return rej ( err ) return res ( stdout ) } ) } ) } export { execCLI , getEnvCli }	O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import * as urlUtil from 's' function getClient ( url ) { const path = 's' return request ( url ) . get ( path ) . set ( 's' , urlUtil . parse ( url ) . host ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } export { getClient }	O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { buildAbsoluteFixturePath , root } from 's' import { isAbsolute , join } from 's' import { parse } from 's' function 0 ( ) { return 's' } function makeRawRequest ( url , statusCodeExpected ? , range ? ) { const { host , protocol , pathname } = parse ( url ) return makeGetRequest ( { url : `template` , path : pathname , statusCodeExpected , range } ) } function makeGetRequest ( options : { url : string , path ? : string , query ? : any , token ? : string , statusCodeExpected ? : number , contentType ? : string , range ? : string } ) { if ( ! options . statusCodeExpected ) options . statusCodeExpected = 0 if ( options . contentType === undefined ) options . contentType = 's' const req = request ( options . url ) . get ( options . path ) if ( options . contentType ) req . set ( 's' , options . contentType ) if ( options . token ) req . set ( 's' , 's' + options . token ) if ( options . query ) req . query ( options . query ) if ( options . range ) req . set ( 's' , options . range ) return req . expect ( options . statusCodeExpected ) } function makeDeleteRequest ( options : { url : string , path : string , token ? : string , statusCodeExpected ? : number } ) { if ( ! options . statusCodeExpected ) options . statusCodeExpected = 0 const req = request ( options . url ) . delete ( options . path ) . set ( 's' , 's' ) if ( options . token ) req . set ( 's' , 's' + options . token ) return req . expect ( options . statusCodeExpected ) } function makeUploadRequest ( options : { url : string , method ? : 's' | 's' , path : string , token ? : string , fields : { [ fieldName ] : any } , attaches : { [ attachName ] : any | any [ ] } , statusCodeExpected ? : number } ) { if ( ! options . statusCodeExpected ) options . statusCodeExpected = 0 let req : request . Test if ( options . method === 's' ) { req = request ( options . url ) . put ( options . path ) } else { req = request ( options . url ) . post ( options . path ) } req . set ( 's' , 's' ) if ( options . token ) req . set ( 's' , 's' + options . token ) Object . keys ( options . fields ) . forEach ( field => { const value = options . fields [ field ] if ( value === undefined ) return if ( Array . isArray ( value ) ) { for ( let i = 0 ; i < value . length ; i ++ ) { req . field ( field + 's' + i + 's' , value [ i ] ) } } else { req . field ( field , value ) } } ) Object . keys ( options . attaches ) . forEach ( attach => { const value = options . attaches [ attach ] if ( Array . isArray ( value ) ) { req . attach ( attach , buildAbsoluteFixturePath ( value [ 0 ] ) , value [ 0 ] ) } else { req . attach ( attach , buildAbsoluteFixturePath ( value ) ) } } ) return req . expect ( options . statusCodeExpected ) } function makePostBodyRequest ( options : { url : string , path : string , token ? : string , fields ? : { [ fieldName ] : any } , statusCodeExpected ? : number } ) { if ( ! options . fields ) options . fields = { } if ( ! options . statusCodeExpected ) options . statusCodeExpected = 0 const req = request ( options . url ) . post ( options . path ) . set ( 's' , 's' ) if ( options . token ) req . set ( 's' , 's' + options . token ) return req . send ( options . fields ) . expect ( options . statusCodeExpected ) } function makePutBodyRequest ( options : { url : string , path : string , token ? : string , fields : { [ fieldName ] : any } , statusCodeExpected ? : number } ) { if ( ! options . statusCodeExpected ) options . statusCodeExpected = 0 const req = request ( options . url ) . put ( options . path ) . set ( 's' , 's' ) if ( options . token ) req . set ( 's' , 's' + options . token ) return req . send ( options . fields ) . expect ( options . statusCodeExpected ) } function makeHTMLRequest ( url , path ) { return request ( url ) . get ( path ) . set ( 's' , 's' ) . expect ( 0 ) } function updateAvatarRequest ( options : { url : string , path : string , accessToken : string , fixture : string } ) { let filePath = 's' if ( isAbsolute ( options . fixture ) ) { filePath = options . fixture } else { filePath = join ( root ( ) , 's' , 's' , 's' , options . fixture ) } return makeUploadRequest ( { url : options . url , path : options . path , token : options . accessToken , fields : { } , attaches : { avatarfile : filePath } , statusCodeExpected : 0 } ) } export { 0 , makeHTMLRequest , makeGetRequest , makeUploadRequest , makePostBodyRequest , makePutBodyRequest , makeDeleteRequest , makeRawRequest , updateAvatarRequest }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeDeleteRequest , makeGetRequest , makePutBodyRequest } from 's' import { CustomConfig } from 's' import { DeepPartial } from 's' import { merge } from 's' function getConfig ( url ) { const path = 's' return makeGetRequest ( { url , path , statusCodeExpected : 0 } ) } function getAbout ( url ) { const path = 's' return makeGetRequest ( { url , path , statusCodeExpected : 0 } ) } function getCustomConfig ( url , token , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , token , path , statusCodeExpected } ) } function updateCustomConfig ( url , token , newCustomConfig , statusCodeExpected = 0 ) { const path = 's' return makePutBodyRequest ( { url , token , path , fields : newCustomConfig , statusCodeExpected } ) } function updateCustomSubConfig ( url , token , newConfig < CustomConfig > ) { const updateParams = { instance : { name : 's' , shortDescription : 's' , description : 's' , terms : 's' , codeOfConduct : 's' , creationReason : 's' , moderationInformation : 's' , administrator : 's' , maintenanceLifetime : 's' , businessModel : 's' , hardwareInformation : 's' , languages : [ 's' , 's' ] , categories : [ 0 , 0 ] , defaultClientRoute : 's' , isNSFW : true , defaultNSFWPolicy : 's' , customizations : { javascript : 's' , css : 's' } } , theme : { default : 's' } , services : { twitter : { username : 's' , whitelisted : true } } , cache : { previews : { size : 0 } , captions : { size : 0 } } , signup : { enabled : false , limit : 0 , requiresEmailVerification : false } , admin : { email : 's' } , contactForm : { enabled : true } , user : { videoQuota : 0 , videoQuotaDaily : 0 } , transcoding : { enabled : true , allowAdditionalExtensions : true , allowAudioFiles : true , threads : 0 , resolutions : { 's' : false , 's' : true , 's' : true , 's' : false , 's' : false , 's' : false } , hls : { enabled : false } } , import : { videos : { http : { enabled : false } , torrent : { enabled : false } } } , autoBlacklist : { videos : { ofUsers : { enabled : false } } } , followers : { instance : { enabled : true , manualApproval : false } } , followings : { instance : { autoFollowBack : { enabled : false } , autoFollowIndex : { indexUrl : 's' , enabled : false } } } } merge ( updateParams , newConfig ) return updateCustomConfig ( url , token , updateParams ) } function deleteCustomConfig ( url , token , statusCodeExpected = 0 ) { const path = 's' return makeDeleteRequest ( { url , token , path , statusCodeExpected } ) } export { getConfig , getCustomConfig , updateCustomConfig , getAbout , deleteCustomConfig , updateCustomSubConfig }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $DeepPartial$ O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { Job , JobState } from 's' import { wait } from 's' import { ServerInfo } from 's' function getJobsList ( url , accessToken , state ) { const path = 's' + state return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( 0 ) . expect ( 's' , "s" ) } function getJobsListPaginationAndSort ( url , accessToken , state , start , count , sort ) { const path = 's' + state return request ( url ) . get ( path ) . query ( { start } ) . query ( { count } ) . query ( { sort } ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( 0 ) . expect ( 's' , "s" ) } async function waitJobs ( serversArg : ServerInfo [ ] | ServerInfo ) { const pendingJobWait = process . env . NODE_PENDING_JOB_WAIT ? parseInt ( process . env . NODE_PENDING_JOB_WAIT , 0 ) : 0 let servers : ServerInfo [ ] if ( Array . isArray ( serversArg ) === false ) servers = [ serversArg as ServerInfo ] else servers = serversArg as ServerInfo [ ] const states : JobState [ ] = [ 's' , 's' , 's' ] let pendingRequests function tasksBuilder ( ) { const tasks : Promise < any > [ ] = [ ] for ( const server of servers ) { for ( const state of states ) { const p = getJobsListPaginationAndSort ( server . url , server . accessToken , state , 0 , 0 , 's' ) . then ( res => res . body . data ) . then ( ( jobs : Job [ ] ) => jobs . filter ( j => j . type !== 's' ) ) . then ( jobs => { if ( jobs . length !== 0 ) { pendingRequests = true } } ) tasks . push ( p ) } } return tasks } do { pendingRequests = false await Promise . all ( tasksBuilder ( ) ) if ( pendingRequests === false ) { await wait ( pendingJobWait ) await Promise . all ( tasksBuilder ( ) ) } if ( pendingRequests ) { await wait ( 0 ) } } while ( pendingRequests ) } export { getJobsList , waitJobs , getJobsListPaginationAndSort }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $JobState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $JobState$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { ServerInfo } from 's' import { getClient } from 's' type Client = { id : string , secret : string } type User = { username : string , password : string } type Server = { url : string , client : Client , user : User } function login ( url , client , user , expectedStatus = 0 ) { const path = 's' const body = { client_id : client . id , client_secret : client . secret , username : user . username , password : user . password , response_type : 's' , grant_type : 's' , scope : 's' } return request ( url ) . post ( path ) . type ( 's' ) . send ( body ) . expect ( expectedStatus ) } async function serverLogin ( server ) { const res = await login ( server . url , server . client , server . user , 0 ) return res . body . access_token as string } async function userLogin ( server , user , expectedStatus = 0 ) { const res = await login ( server . url , server . client , user , expectedStatus ) return res . body . access_token as string } async function getAccessToken ( url , username , password ) { const resClient = await getClient ( url ) const client = { id : resClient . body . client_id , secret : resClient . body . client_secret } const user = { username , password } try { const res = await login ( url , client , user ) return res . body . access_token } catch ( err ) { throw new Error ( 's' ) } } function setAccessTokensToServers ( servers : ServerInfo [ ] ) { const tasks : Promise < any > [ ] = [ ] for ( const server of servers ) { const p = serverLogin ( server ) . then ( t => server . accessToken = t ) tasks . push ( p ) } return Promise . all ( tasks ) } export { login , serverLogin , userLogin , getAccessToken , setAccessTokensToServers , Server , Client , User }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Client$ O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Server$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Server$ O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
function buildRequestStub ( ) { return { } } function buildResponseStub ( ) { return { locals : { } } } export { buildResponseStub , buildRequestStub }	O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O O O O O
import { QueryTypes , Sequelize } from 's' import { ServerInfo } from 's' let sequelizes : { [ id ] : Sequelize } = { } function getSequelize ( internalServerNumber ) { if ( sequelizes [ internalServerNumber ] ) return sequelizes [ internalServerNumber ] const dbname = 's' + internalServerNumber const username = 's' const password = 's' const host = process . env . GITLAB_CI ? 's' : 's' const port = 0 const seq = new Sequelize ( dbname , username , password , { dialect : 's' , host , port , logging : false } ) sequelizes [ internalServerNumber ] = seq return seq } function setActorField ( internalServerNumber , to , field , value ) { const seq = getSequelize ( internalServerNumber ) const options = { type : QueryTypes . UPDATE } return seq . query ( `template` , options ) } function setVideoField ( internalServerNumber , uuid , field , value ) { const seq = getSequelize ( internalServerNumber ) const options = { type : QueryTypes . UPDATE } return seq . query ( `template` , options ) } function setPlaylistField ( internalServerNumber , uuid , field , value ) { const seq = getSequelize ( internalServerNumber ) const options = { type : QueryTypes . UPDATE } return seq . query ( `template` , options ) } async function countVideoViewsOf ( internalServerNumber , uuid ) { const seq = getSequelize ( internalServerNumber ) const query = `template` const options = { type : QueryTypes . SELECT as QueryTypes . SELECT } const [ { total } ] = await seq . query < { total : number } > ( query , options ) if ( ! total ) return 0 return parseInt ( total + 's' , 0 ) } async function closeAllSequelize ( servers : ServerInfo [ ] ) { for ( const server of servers ) { if ( sequelizes [ server . internalServerNumber ] ) { await sequelizes [ server . internalServerNumber ] . close ( ) delete sequelizes [ server . internalServerNumber ] } } } function setPluginVersion ( internalServerNumber , pluginName , newVersion ) { const seq = getSequelize ( internalServerNumber ) const options = { type : QueryTypes . UPDATE } return seq . query ( `template` , options ) } function setActorFollowScores ( internalServerNumber , newScore ) { const seq = getSequelize ( internalServerNumber ) const options = { type : QueryTypes . UPDATE } return seq . query ( `template` , options ) } export { setVideoField , setPlaylistField , setActorField , countVideoViewsOf , setPluginVersion , setActorFollowScores , closeAllSequelize }	O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { ServerInfo } from 's' import { waitJobs } from 's' import { makePostBodyRequest } from 's' function getFollowersListPaginationAndSort ( url , start , count , sort , search ? ) { const path = 's' const query = { start , count , sort , search } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function acceptFollower ( url , token , follower , statusCodeExpected = 0 ) { const path = 's' + follower + 's' return makePostBodyRequest ( { url , token , path , statusCodeExpected } ) } function rejectFollower ( url , token , follower , statusCodeExpected = 0 ) { const path = 's' + follower + 's' return makePostBodyRequest ( { url , token , path , statusCodeExpected } ) } function getFollowingListPaginationAndSort ( url , start , count , sort , search ? ) { const path = 's' const query = { start , count , sort , search } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function follow ( follower , following : string [ ] , accessToken , expectedStatus = 0 ) { const path = 's' const followingHosts = following . map ( f => f . replace ( "s" , 's' ) ) return request ( follower ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . send ( { 's' : followingHosts } ) . expect ( expectedStatus ) } async function unfollow ( url , accessToken , target , expectedStatus = 0 ) { const path = 's' + target . host return request ( url ) . delete ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( expectedStatus ) } function removeFollower ( url , accessToken , follower , expectedStatus = 0 ) { const path = 's' + follower . host return request ( url ) . delete ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( expectedStatus ) } async function doubleFollow ( 0 , 0 ) { await Promise . all ( [ follow ( 0 . url , [ 0 . url ] , 0 . accessToken ) , follow ( 0 . url , [ 0 . url ] , 0 . accessToken ) ] ) await waitJobs ( [ 0 , 0 ] ) return true } export { getFollowersListPaginationAndSort , getFollowingListPaginationAndSort , unfollow , removeFollower , follow , doubleFollow , acceptFollower , rejectFollower }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest } from 's' import { immutableAssign } from 's' function checkBadStartPagination ( url , path , token ? , query = { } ) { return makeGetRequest ( { url , path , token , query : immutableAssign ( query , { start : 's' } ) , statusCodeExpected : 0 } ) } function checkBadCountPagination ( url , path , token ? , query = { } ) { return makeGetRequest ( { url , path , token , query : immutableAssign ( query , { count : 's' } ) , statusCodeExpected : 0 } ) } function checkBadSortPagination ( url , path , token ? , query = { } ) { return makeGetRequest ( { url , path , token , query : immutableAssign ( query , { sort : 's' } ) , statusCodeExpected : 0 } ) } export { checkBadStartPagination , checkBadCountPagination , checkBadSortPagination }	O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest , makePostBodyRequest , makePutBodyRequest } from 's' import { PluginType } from 's' import { PeertubePluginIndexList } from 's' import { readJSON , writeJSON } from 's' import { ServerInfo } from 's' import { root } from 's' import { join } from 's' function listPlugins ( parameters : { url : string , accessToken : string , start ? : number , count ? : number , sort ? : string , pluginType ? : PluginType , uninstalled ? : boolean , expectedStatus ? : number } ) { const { url , accessToken , start , count , sort , pluginType , uninstalled , expectedStatus = 0 } = parameters const path = 's' return makeGetRequest ( { url , path , token : accessToken , query : { start , count , sort , pluginType , uninstalled } , statusCodeExpected : expectedStatus } ) } function listAvailablePlugins ( parameters : { url : string , accessToken : string , start ? : number , count ? : number , sort ? : string , pluginType ? : PluginType , currentPeerTubeEngine ? : string , search ? : string expectedStatus ? : number } ) { const { url , accessToken , start , count , sort , pluginType , search , currentPeerTubeEngine , expectedStatus = 0 } = parameters const path = 's' const query = { start , count , sort , pluginType , currentPeerTubeEngine , search } return makeGetRequest ( { url , path , token : accessToken , query , statusCodeExpected : expectedStatus } ) } function getPlugin ( parameters : { url : string , accessToken : string , npmName : string , expectedStatus ? : number } ) { const { url , accessToken , npmName , expectedStatus = 0 } = parameters const path = 's' + npmName return makeGetRequest ( { url , path , token : accessToken , statusCodeExpected : expectedStatus } ) } function updatePluginSettings ( parameters : { url : string , accessToken : string , npmName : string , settings : any , expectedStatus ? : number } ) { const { url , accessToken , npmName , settings , expectedStatus = 0 } = parameters const path = 's' + npmName + 's' return makePutBodyRequest ( { url , path , token : accessToken , fields : { settings } , statusCodeExpected : expectedStatus } ) } function getPluginRegisteredSettings ( parameters : { url : string , accessToken : string , npmName : string , expectedStatus ? : number } ) { const { url , accessToken , npmName , expectedStatus = 0 } = parameters const path = 's' + npmName + 's' return makeGetRequest ( { url , path , token : accessToken , statusCodeExpected : expectedStatus } ) } function getPublicSettings ( parameters : { url : string , npmName : string , expectedStatus ? : number } ) { const { url , npmName , expectedStatus = 0 } = parameters const path = 's' + npmName + 's' return makeGetRequest ( { url , path , statusCodeExpected : expectedStatus } ) } function getPluginTranslations ( parameters : { url : string , locale : string , expectedStatus ? : number } ) { const { url , locale , expectedStatus = 0 } = parameters const path = 's' + locale + 's' return makeGetRequest ( { url , path , statusCodeExpected : expectedStatus } ) } function installPlugin ( parameters : { url : string , accessToken : string , path ? : string , npmName ? : string expectedStatus ? : number } ) { const { url , accessToken , npmName , path , expectedStatus = 0 } = parameters const apiPath = 's' return makePostBodyRequest ( { url , path : apiPath , token : accessToken , fields : { npmName , path } , statusCodeExpected : expectedStatus } ) } function updatePlugin ( parameters : { url : string , accessToken : string , path ? : string , npmName ? : string expectedStatus ? : number } ) { const { url , accessToken , npmName , path , expectedStatus = 0 } = parameters const apiPath = 's' return makePostBodyRequest ( { url , path : apiPath , token : accessToken , fields : { npmName , path } , statusCodeExpected : expectedStatus } ) } function uninstallPlugin ( parameters : { url : string , accessToken : string , npmName : string expectedStatus ? : number } ) { const { url , accessToken , npmName , expectedStatus = 0 } = parameters const apiPath = 's' return makePostBodyRequest ( { url , path : apiPath , token : accessToken , fields : { npmName } , statusCodeExpected : expectedStatus } ) } function getPluginsCSS ( url ) { const path = 's' return makeGetRequest ( { url , path , statusCodeExpected : 0 } ) } function getPackageJSONPath ( server , npmName ) { return join ( root ( ) , 's' + server . internalServerNumber , 's' , 's' , npmName , 's' ) } function updatePluginPackageJSON ( server , npmName , json ) { const path = getPackageJSONPath ( server , npmName ) return writeJSON ( path , json ) } function getPluginPackageJSON ( server , npmName ) { const path = getPackageJSONPath ( server , npmName ) return readJSON ( path ) } function getPluginTestPath ( suffix = 's' ) { return join ( root ( ) , 's' , 's' , 's' , 's' + suffix ) } export { listPlugins , listAvailablePlugins , installPlugin , getPluginTranslations , getPluginsCSS , updatePlugin , getPlugin , uninstallPlugin , updatePluginSettings , getPluginRegisteredSettings , getPackageJSONPath , updatePluginPackageJSON , getPluginPackageJSON , getPluginTestPath , getPublicSettings }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeertubePluginIndexList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' function getOEmbed ( url , oembedUrl , format ? , maxHeight ? , maxWidth ? ) { const path = 's' const query = { url : oembedUrl , format , maxheight : maxHeight , maxwidth : maxWidth } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . expect ( 0 ) } export { getOEmbed }	O O O O O O O O O $string$ O $string$ O O $string$ O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeDeleteRequest , makeGetRequest , makePostBodyRequest , makePutBodyRequest , makeUploadRequest } from 's' import { VideoPlaylistCreate } from 's' import { omit } from 's' import { VideoPlaylistUpdate } from 's' import { VideoPlaylistElementCreate } from 's' import { VideoPlaylistElementUpdate } from 's' import { videoUUIDToId } from 's' import { join } from 's' import { root } from 's' import { readdir } from 's' import { expect } from 's' import { VideoPlaylistType } from 's' function getVideoPlaylistsList ( url , start , count , sort ? ) { const path = 's' const query = { start , count , sort } return makeGetRequest ( { url , path , query , statusCodeExpected : 0 } ) } function getVideoChannelPlaylistsList ( url , videoChannelName , start , count , sort ? ) { const path = 's' + videoChannelName + 's' const query = { start , count , sort } return makeGetRequest ( { url , path , query , statusCodeExpected : 0 } ) } function getAccountPlaylistsList ( url , accountName , start , count , sort ? ) { const path = 's' + accountName + 's' const query = { start , count , sort } return makeGetRequest ( { url , path , query , statusCodeExpected : 0 } ) } function getAccountPlaylistsListWithToken ( url , token , accountName , start , count , playlistType ? , sort ? ) { const path = 's' + accountName + 's' const query = { start , count , playlistType , sort } return makeGetRequest ( { url , token , path , query , statusCodeExpected : 0 } ) } function getVideoPlaylist ( url , playlistId : number | string , statusCodeExpected = 0 ) { const path = 's' + playlistId return makeGetRequest ( { url , path , statusCodeExpected } ) } function getVideoPlaylistWithToken ( url , token , playlistId : number | string , statusCodeExpected = 0 ) { const path = 's' + playlistId return makeGetRequest ( { url , token , path , statusCodeExpected } ) } function deleteVideoPlaylist ( url , token , playlistId : number | string , statusCodeExpected = 0 ) { const path = 's' + playlistId return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } function createVideoPlaylist ( options : { url : string , token : string , playlistAttrs : VideoPlaylistCreate , expectedStatus ? : number } ) { const path = 's' const fields = omit ( options . playlistAttrs , 's' ) const attaches = options . playlistAttrs . thumbnailfile ? { thumbnailfile : options . playlistAttrs . thumbnailfile } : { } return makeUploadRequest ( { method : 's' , url : options . url , path , token : options . token , fields , attaches , statusCodeExpected : options . expectedStatus || 0 } ) } function updateVideoPlaylist ( options : { url : string , token : string , playlistAttrs : VideoPlaylistUpdate , playlistId : number | string , expectedStatus ? : number } ) { const path = 's' + options . playlistId const fields = omit ( options . playlistAttrs , 's' ) const attaches = options . playlistAttrs . thumbnailfile ? { thumbnailfile : options . playlistAttrs . thumbnailfile } : { } return makeUploadRequest ( { method : 's' , url : options . url , path , token : options . token , fields , attaches , statusCodeExpected : options . expectedStatus || 0 } ) } async function addVideoInPlaylist ( options : { url : string , token : string , playlistId : number | string , elementAttrs : VideoPlaylistElementCreate | { videoId : string } expectedStatus ? : number } ) { options . elementAttrs . videoId = await videoUUIDToId ( options . url , options . elementAttrs . videoId ) const path = 's' + options . playlistId + 's' return makePostBodyRequest ( { url : options . url , path , token : options . token , fields : options . elementAttrs , statusCodeExpected : options . expectedStatus || 0 } ) } function updateVideoPlaylistElement ( options : { url : string , token : string , playlistId : number | string , playlistElementId : number | string , elementAttrs : VideoPlaylistElementUpdate , expectedStatus ? : number } ) { const path = 's' + options . playlistId + 's' + options . playlistElementId return makePutBodyRequest ( { url : options . url , path , token : options . token , fields : options . elementAttrs , statusCodeExpected : options . expectedStatus || 0 } ) } function removeVideoFromPlaylist ( options : { url : string , token : string , playlistId : number | string , playlistElementId : number , expectedStatus ? : number } ) { const path = 's' + options . playlistId + 's' + options . playlistElementId return makeDeleteRequest ( { url : options . url , path , token : options . token , statusCodeExpected : options . expectedStatus || 0 } ) } function reorderVideosPlaylist ( options : { url : string , token : string , playlistId : number | string , elementAttrs : { startPosition : number , insertAfterPosition : number , reorderLength ? : number } , expectedStatus ? : number } ) { const path = 's' + options . playlistId + 's' return makePostBodyRequest ( { url : options . url , path , token : options . token , fields : options . elementAttrs , statusCodeExpected : options . expectedStatus || 0 } ) } async function checkPlaylistFilesWereRemoved ( playlistUUID , internalServerNumber , directories = [ 's' ] ) { const testDirectory = 's' + internalServerNumber for ( const directory of directories ) { const directoryPath = join ( root ( ) , testDirectory , directory ) const files = await readdir ( directoryPath ) for ( const file of files ) { expect ( file ) . to . not . contain ( playlistUUID ) } } } function getVideoPlaylistPrivacies ( url ) { const path = 's' return makeGetRequest ( { url , path , statusCodeExpected : 0 } ) } function doVideosExistInMyPlaylist ( url , token , videoIds : number [ ] ) { const path = 's' return makeGetRequest ( { url , token , path , query : { videoIds } , statusCodeExpected : 0 } ) } export { getVideoPlaylistPrivacies , getVideoPlaylistsList , getVideoChannelPlaylistsList , getAccountPlaylistsList , getAccountPlaylistsListWithToken , getVideoPlaylist , getVideoPlaylistWithToken , createVideoPlaylist , updateVideoPlaylist , deleteVideoPlaylist , addVideoInPlaylist , updateVideoPlaylistElement , removeVideoFromPlaylist , reorderVideosPlaylist , checkPlaylistFilesWereRemoved , doVideosExistInMyPlaylist }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $number$ O $number$ O O $VideoPlaylistType$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { makePostBodyRequest , makePutBodyRequest , updateAvatarRequest } from 's' import { UserAdminFlag } from 's' import { UserRegister } from 's' import { UserRole } from 's' import { ServerInfo } from 's' import { userLogin } from 's' import { UserUpdateMe } from 's' import { omit } from 's' type CreateUserArgs = { url : string , accessToken : string , username : string , password : string , videoQuota ? : number , videoQuotaDaily ? : number , role ? : UserRole , adminFlags ? : UserAdminFlag , specialStatus ? : number } function createUser ( parameters ) { const { url , accessToken , username , adminFlags , password = 's' , videoQuota = 0 , videoQuotaDaily = - 0 , role = UserRole . USER , specialStatus = 0 } = parameters const path = 's' const body = { username , password , role , adminFlags , email : username + 's' , videoQuota , videoQuotaDaily } return request ( url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . send ( body ) . expect ( specialStatus ) } async function generateUserAccessToken ( server , username ) { const password = 's' await createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : password } ) return userLogin ( server , { username , password } ) } function registerUser ( url , username , password , specialStatus = 0 ) { const path = 's' const body = { username , password , email : username + 's' } return request ( url ) . post ( path ) . set ( 's' , 's' ) . send ( body ) . expect ( specialStatus ) } function registerUserWithChannel ( options : { url : string , user : { username : string , password : string , displayName ? : string } , channel : { name : string , displayName : string } } ) { const path = 's' const body = { username : options . user . username , password : options . user . password , email : options . user . username + 's' , channel : options . channel } if ( options . user . displayName ) { Object . assign ( body , { displayName : options . user . displayName } ) } return makePostBodyRequest ( { url : options . url , path , fields : body , statusCodeExpected : 0 } ) } function getMyUserInformation ( url , accessToken , specialStatus = 0 ) { const path = 's' return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( specialStatus ) . expect ( 's' , "s" ) } function deleteMe ( url , accessToken , specialStatus = 0 ) { const path = 's' return request ( url ) . delete ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( specialStatus ) } function getMyUserVideoQuotaUsed ( url , accessToken , specialStatus = 0 ) { const path = 's' return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( specialStatus ) . expect ( 's' , "s" ) } function getUserInformation ( url , accessToken , userId ) { const path = 's' + userId return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( 0 ) . expect ( 's' , "s" ) } function getMyUserVideoRating ( url , accessToken , videoId : number | string , specialStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( specialStatus ) . expect ( 's' , "s" ) } function getUsersList ( url , accessToken ) { const path = 's' return request ( url ) . get ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( 0 ) . expect ( 's' , "s" ) } function getUsersListPaginationAndSort ( url , accessToken , start , count , sort , search ? ) { const path = 's' const query = { start , count , sort , search } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( 0 ) . expect ( 's' , "s" ) } function removeUser ( url , userId : number | string , accessToken , expectedStatus = 0 ) { const path = 's' return request ( url ) . delete ( path + 's' + userId ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( expectedStatus ) } function blockUser ( url , userId : number | string , accessToken , expectedStatus = 0 , reason ? ) { const path = 's' let body if ( reason ) body = { reason } return request ( url ) . post ( path + 's' + userId + 's' ) . send ( body ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( expectedStatus ) } function unblockUser ( url , userId : number | string , accessToken , expectedStatus = 0 ) { const path = 's' return request ( url ) . post ( path + 's' + userId + 's' ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( expectedStatus ) } function updateMyUser ( options : { url : string , accessToken : string } & UserUpdateMe ) { const path = 's' const toSend = omit ( options , 's' , 's' ) return makePutBodyRequest ( { url : options . url , path , token : options . accessToken , fields : toSend , statusCodeExpected : 0 } ) } function updateMyAvatar ( options : { url : string , accessToken : string , fixture : string } ) { const path = 's' return updateAvatarRequest ( Object . assign ( options , { path } ) ) } function updateUser ( options : { url : string userId : number , accessToken : string , email ? : string , emailVerified ? : boolean , videoQuota ? : number , videoQuotaDaily ? : number , password ? : string , adminFlags ? : UserAdminFlag , role ? : UserRole } ) { const path = 's' + options . userId const toSend = { } if ( options . password !== undefined && options . password !== null ) toSend [ 's' ] = options . password if ( options . email !== undefined && options . email !== null ) toSend [ 's' ] = options . email if ( options . emailVerified !== undefined && options . emailVerified !== null ) toSend [ 's' ] = options . emailVerified if ( options . videoQuota !== undefined && options . videoQuota !== null ) toSend [ 's' ] = options . videoQuota if ( options . videoQuotaDaily !== undefined && options . videoQuotaDaily !== null ) toSend [ 's' ] = options . videoQuotaDaily if ( options . role !== undefined && options . role !== null ) toSend [ 's' ] = options . role if ( options . adminFlags !== undefined && options . adminFlags !== null ) toSend [ 's' ] = options . adminFlags return makePutBodyRequest ( { url : options . url , path , token : options . accessToken , fields : toSend , statusCodeExpected : 0 } ) } function askResetPassword ( url , email ) { const path = 's' return makePostBodyRequest ( { url , path , fields : { email } , statusCodeExpected : 0 } ) } function resetPassword ( url , userId , verificationString , password , statusCodeExpected = 0 ) { const path = 's' + userId + 's' return makePostBodyRequest ( { url , path , fields : { password , verificationString } , statusCodeExpected } ) } function askSendVerifyEmail ( url , email ) { const path = 's' return makePostBodyRequest ( { url , path , fields : { email } , statusCodeExpected : 0 } ) } function verifyEmail ( url , userId , verificationString , isPendingEmail = false , statusCodeExpected = 0 ) { const path = 's' + userId + 's' return makePostBodyRequest ( { url , path , fields : { verificationString , isPendingEmail } , statusCodeExpected } ) } export { createUser , registerUser , getMyUserInformation , getMyUserVideoRating , deleteMe , registerUserWithChannel , getMyUserVideoQuotaUsed , getUsersList , getUsersListPaginationAndSort , removeUser , updateUser , updateMyUser , getUserInformation , blockUser , unblockUser , askResetPassword , resetPassword , updateMyAvatar , askSendVerifyEmail , generateUserAccessToken , verifyEmail }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CreateUserArgs$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserRegister$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserUpdateMe$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { expect } from 's' import { existsSync , readdir } from 's' import { join } from 's' import { Account } from 's' import { root } from 's' import { makeGetRequest } from 's' import { VideoRateType } from 's' function getAccountsList ( url , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , query : { sort } , path , statusCodeExpected } ) } function getAccount ( url , accountName , statusCodeExpected = 0 ) { const path = 's' + accountName return makeGetRequest ( { url , path , statusCodeExpected } ) } async function expectAccountFollows ( url , nameWithDomain , followersCount , followingCount ) { const res = await getAccountsList ( url ) const account = res . body . data . find ( ( a ) => a . name + 's' + a . host === nameWithDomain ) const message = `template` expect ( account . followersCount ) . to . equal ( followersCount , message ) expect ( account . followingCount ) . to . equal ( followingCount , message ) } async function checkActorFilesWereRemoved ( filename , serverNumber ) { const testDirectory = 's' + serverNumber for ( const directory of [ 's' ] ) { const directoryPath = join ( root ( ) , testDirectory , directory ) const directoryExists = existsSync ( directoryPath ) expect ( directoryExists ) . to . be . true const files = await readdir ( directoryPath ) for ( const file of files ) { expect ( file ) . to . not . contain ( filename ) } } } function getAccountRatings ( url , accountName , accessToken , rating ? , statusCodeExpected = 0 ) { const path = 's' + accountName + 's' const query = rating ? { rating } : { } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . set ( 's' , 's' + accessToken ) . expect ( statusCodeExpected ) . expect ( 's' , "s" ) } export { getAccount , expectAccountFollows , getAccountsList , checkActorFilesWereRemoved , getAccountRatings }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { VideoAbuseUpdate } from 's' import { makeDeleteRequest , makePutBodyRequest } from 's' function reportVideoAbuse ( url , token , videoId : number | string , reason , specialStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . send ( { reason } ) . expect ( specialStatus ) } function getVideoAbusesList ( url , token ) { const path = 's' return request ( url ) . get ( path ) . query ( { sort : 's' } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( 0 ) . expect ( 's' , "s" ) } function updateVideoAbuse ( url , token , videoId : string | number , videoAbuseId , body , statusCodeExpected = 0 ) { const path = 's' + videoId + 's' + videoAbuseId return makePutBodyRequest ( { url , token , path , fields : body , statusCodeExpected } ) } function deleteVideoAbuse ( url , token , videoId : string | number , videoAbuseId , statusCodeExpected = 0 ) { const path = 's' + videoId + 's' + videoAbuseId return makeDeleteRequest ( { url , token , path , statusCodeExpected } ) } export { reportVideoAbuse , getVideoAbusesList , updateVideoAbuse , deleteVideoAbuse }	O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $number$ O $VideoAbuseUpdate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { VideoBlacklistType } from 's' import { makeGetRequest } from 's' function addVideoToBlacklist ( url , token , videoId : number | string , reason ? , unfederate ? , specialStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . post ( path ) . send ( { reason , unfederate } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( specialStatus ) } function updateVideoBlacklist ( url , token , videoId , reason ? , specialStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . put ( path ) . send ( { reason } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( specialStatus ) } function removeVideoFromBlacklist ( url , token , videoId : number | string , specialStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . delete ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( specialStatus ) } function getBlacklistedVideosList ( parameters : { url : string , token : string , sort ? : string , type ? : VideoBlacklistType , specialStatus ? : number } ) { let { url , token , sort , type , specialStatus = 0 } = parameters const path = 's' const query = { sort , type } return makeGetRequest ( { url , path , query , token , statusCodeExpected : specialStatus } ) } export { addVideoToBlacklist , removeVideoFromBlacklist , getBlacklistedVideosList , updateVideoBlacklist }	O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O $string$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { VideoChannelUpdate } from 's' import { VideoChannelCreate } from 's' import { makeGetRequest , updateAvatarRequest } from 's' import { ServerInfo } from 's' import { User } from 's' import { getMyUserInformation } from 's' function getVideoChannelsList ( url , start , count , sort ? ) { const path = 's' const req = request ( url ) . get ( path ) . query ( { start : start } ) . query ( { count : count } ) if ( sort ) req . query ( { sort } ) return req . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function getAccountVideoChannelsList ( parameters : { url : string , accountName : string , start ? : number , count ? : number , sort ? : string , specialStatus ? : number } ) { const { url , accountName , start , count , sort = 's' , specialStatus = 0 } = parameters const path = 's' + accountName + 's' return makeGetRequest ( { url , path , query : { start , count , sort } , statusCodeExpected : specialStatus } ) } function addVideoChannel ( url , token , videoChannelAttributesArg , expectedStatus = 0 ) { const path = 's' let attributes = { displayName : 's' , description : 's' , support : 's' } attributes = Object . assign ( attributes , videoChannelAttributesArg ) return request ( url ) . post ( path ) . send ( attributes ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } function updateVideoChannel ( url , token , channelName , attributes , expectedStatus = 0 ) { const body = { } const path = 's' + channelName if ( attributes . displayName ) body . displayName = attributes . displayName if ( attributes . description ) body . description = attributes . description if ( attributes . support ) body . support = attributes . support if ( attributes . bulkVideosSupportUpdate ) body . bulkVideosSupportUpdate = attributes . bulkVideosSupportUpdate return request ( url ) . put ( path ) . send ( body ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } function deleteVideoChannel ( url , token , channelName , expectedStatus = 0 ) { const path = 's' + channelName return request ( url ) . delete ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } function getVideoChannel ( url , channelName ) { const path = 's' + channelName return request ( url ) . get ( path ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function updateVideoChannelAvatar ( options : { url : string , accessToken : string , fixture : string , videoChannelName : string | number } ) { const path = 's' + options . videoChannelName + 's' return updateAvatarRequest ( Object . assign ( options , { path } ) ) } function setDefaultVideoChannel ( servers : ServerInfo [ ] ) { const tasks : Promise < any > [ ] = [ ] for ( const server of servers ) { const p = getMyUserInformation ( server . url , server . accessToken ) . then ( res => server . videoChannel = ( res . body as User ) . videoChannels [ 0 ] ) tasks . push ( p ) } return Promise . all ( tasks ) } export { updateVideoChannelAvatar , getVideoChannelsList , getAccountVideoChannelsList , addVideoChannel , updateVideoChannel , deleteVideoChannel , getVideoChannel , setDefaultVideoChannel }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $VideoChannelCreate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $VideoChannelUpdate$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { makeDeleteRequest } from 's' function getVideoCommentThreads ( url , videoId : number | string , start , count , sort ? , token ? ) { const path = 's' + videoId + 's' const req = request ( url ) . get ( path ) . query ( { start : start } ) . query ( { count : count } ) if ( sort ) req . query ( { sort } ) if ( token ) req . set ( 's' , 's' + token ) return req . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function getVideoThreadComments ( url , videoId : number | string , threadId , token ? ) { const path = 's' + videoId + 's' + threadId const req = request ( url ) . get ( path ) . set ( 's' , 's' ) if ( token ) req . set ( 's' , 's' + token ) return req . expect ( 0 ) . expect ( 's' , "s" ) } function addVideoCommentThread ( url , token , videoId : number | string , text , expectedStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . post ( path ) . send ( { text } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } function addVideoCommentReply ( url , token , videoId : number | string , inReplyToCommentId , text , expectedStatus = 0 ) { const path = 's' + videoId + 's' + inReplyToCommentId return request ( url ) . post ( path ) . send ( { text } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } function deleteVideoComment ( url , token , videoId : number | string , commentId , statusCodeExpected = 0 ) { const path = 's' + videoId + 's' + commentId return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } export { getVideoCommentThreads , getVideoThreadComments , addVideoCommentThread , addVideoCommentReply , deleteVideoComment }	O O O O O O O O O O O O O O O $string$ O O O O O O O $number$ O $number$ O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeRawRequest } from 's' import { 0 } from 's' import { VideoStreamingPlaylist } from 's' import { expect } from 's' function getPlaylist ( url , statusCodeExpected = 0 ) { return makeRawRequest ( url , statusCodeExpected ) } function getSegment ( url , statusCodeExpected = 0 , range ? ) { return makeRawRequest ( url , statusCodeExpected , range ) } function 0 ( url , statusCodeExpected = 0 ) { return makeRawRequest ( url , statusCodeExpected ) } async function checkSegmentHash ( baseUrlPlaylist , baseUrlSegment , videoUUID , resolution , hlsPlaylist ) { const res = await getPlaylist ( `template` ) const playlist = res . text const videoName = `template` const matches = "s" . exec ( playlist ) const length = parseInt ( matches [ 0 ] , 0 ) const offset = parseInt ( matches [ 0 ] , 0 ) const range = `template` const 0 = await getSegment ( `template` , 0 , `template` ) const resSha = await 0 ( hlsPlaylist . 0 ) const 0 = resSha . body [ videoName ] [ range ] expect ( 0 ( 0 . body ) ) . to . equal ( 0 ) } export { getPlaylist , getSegment , 0 , checkSegmentHash }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $number$ O $VideoStreamingPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' function changeVideoOwnership ( url , token , videoId : number | string , username , expectedStatus = 0 ) { const path = 's' + videoId + 's' return request ( url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . send ( { username } ) . expect ( expectedStatus ) } function getVideoChangeOwnershipList ( url , token ) { const path = 's' return request ( url ) . get ( path ) . query ( { sort : 's' } ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( 0 ) . expect ( 's' , "s" ) } function acceptChangeOwnership ( url , token , ownershipId , channelId , expectedStatus = 0 ) { const path = 's' + ownershipId + 's' return request ( url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . send ( { channelId } ) . expect ( expectedStatus ) } function refuseChangeOwnership ( url , token , ownershipId , expectedStatus = 0 ) { const path = 's' + ownershipId + 's' return request ( url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + token ) . expect ( expectedStatus ) } export { changeVideoOwnership , getVideoChangeOwnershipList , acceptChangeOwnership , refuseChangeOwnership }	O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' type FeedType = 's' | 's' function getXMLfeed ( url , feed , format ? ) { const path = 's' + feed + 's' return request ( url ) . get ( path ) . query ( ( format ) ? { format : format } : { } ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function getJSONfeed ( url , feed , query = { } ) { const path = 's' + feed + 's' return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } export { getXMLfeed , getJSONfeed }	O O O O O O O O O O O O O O O $string$ O $FeedType$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $FeedType$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as express from 's' export class MockInstancesIndex { private indexInstances : { host : string , createdAt : string } [ ] = [ ] initialize ( ) { return new Promise ( res => { const app = express ( ) app . use ( 's' , ( req : express . Request , res : express . Response , next : express . NextFunction ) => { if ( process . env . DEBUG ) console . log ( 's' , req . url ) return next ( ) } ) app . get ( 's' , ( req : express . Request , res : express . Response ) => { const since = req . query . since const filtered = this . indexInstances . filter ( i => { if ( ! since ) return true return i . createdAt > since } ) return res . json ( { total : filtered . length , data : filtered } ) } ) app . listen ( 0 , ( ) => res ( ) ) } ) } addInstance ( host ) { this . indexInstances . push ( { host , createdAt : new Date ( ) . toISOString ( ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { VideosSearchQuery } from 's' import { immutableAssign } from 's' function searchVideo ( url , search ) { const path = 's' const query = { sort : 's' , search : search } const req = request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) return req . expect ( 0 ) . expect ( 's' , "s" ) } function searchVideoWithToken ( url , search , token , query : { nsfw ? : boolean } = { } ) { const path = 's' const req = request ( url ) . get ( path ) . set ( 's' , 's' + token ) . query ( immutableAssign ( query , { sort : 's' , search } ) ) . set ( 's' , 's' ) return req . expect ( 0 ) . expect ( 's' , "s" ) } function searchVideoWithPagination ( url , search , start , count , sort ? ) { const path = 's' const query = { start , search , count } const req = request ( url ) . get ( path ) . query ( query ) if ( sort ) req . query ( { sort } ) return req . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function searchVideoWithSort ( url , search , sort ) { const path = 's' const query = { search , sort } return request ( url ) . get ( path ) . query ( query ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } function advancedVideosSearch ( url , options ) { const path = 's' return request ( url ) . get ( path ) . query ( options ) . set ( 's' , 's' ) . expect ( 0 ) . expect ( 's' , "s" ) } export { searchVideo , advancedVideosSearch , searchVideoWithToken , searchVideoWithPagination , searchVideoWithSort }	O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideosSearchQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , doubleFollow , flushAndRunMultipleServers , flushTests , killallServers , makeActivityPubGetRequest , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let videoUUID before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) videoUUID = res . body . video . uuid } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { const res = await makeActivityPubGetRequest ( servers [ 0 ] . url , 's' ) const object = res . body expect ( object . type ) . to . equal ( 's' ) expect ( object . id ) . to . equal ( 's' + servers [ 0 ] . port + 's' ) expect ( object . name ) . to . equal ( 's' ) expect ( object . preferredUsername ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeActivityPubGetRequest ( servers [ 0 ] . url , 's' + videoUUID ) const object = res . body expect ( object . type ) . to . equal ( 's' ) expect ( object . id ) . to . equal ( 's' + servers [ 0 ] . port + 's' + videoUUID ) expect ( object . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeActivityPubGetRequest ( servers [ 0 ] . url , 's' + videoUUID , 0 ) expect ( res . header . location ) . to . equal ( 's' + servers [ 0 ] . port + 's' + videoUUID ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , closeAllSequelize , createUser , doubleFollow , flushAndRunMultipleServers , flushTests , getVideosListSort , killallServers , ServerInfo , setAccessTokensToServers , setActorField , setVideoField , uploadVideo , userLogin , waitJobs } from 's' import * as chai from 's' import { Video } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) const user = { username : 's' , password : 's' } for ( const server of servers ) { await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) } const userAccessToken = await userLogin ( servers [ 0 ] , user ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const badVideoUUID = res . body . video . uuid await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) { const to = 's' + servers [ 0 ] . port + 's' const value = 's' + servers [ 0 ] . port + 's' await setActorField ( servers [ 0 ] . internalServerNumber , to , 's' , value ) } { const value = 's' + servers [ 0 ] . port + 's' + badVideoUUID await setVideoField ( servers [ 0 ] . internalServerNumber , badVideoUUID , 's' , value ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await waitJobs ( servers ) { const res = await getVideosListSort ( servers [ 0 ] . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : Video [ ] = res . body . data expect ( data [ 0 ] . name ) . to . equal ( 's' ) expect ( data [ 0 ] . name ) . to . equal ( 's' ) expect ( data [ 0 ] . name ) . to . equal ( 's' ) } { const res = await getVideosListSort ( servers [ 0 ] . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : Video [ ] = res . body . data expect ( data [ 0 ] . name ) . to . equal ( 's' ) } } ) after ( async function ( ) { this . timeout ( 0 ) await cleanupTests ( servers ) await closeAllSequelize ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { expect } from 's' import { buildRequestStub } from 's' import { isHTTPSignatureVerified , isJsonLDSignatureVerified , parseHTTPSignature } from 's' import { cloneDeep } from 's' import { buildSignedActivity } from 's' describe ( 's' , function ( ) { describe ( 's' , function ( ) { it ( 's' , async function ( ) { const body = require ( 's' ) const publicKey = require ( 's' ) . publicKey const fromActor = { publicKey , url : 's' } const result = await isJsonLDSignatureVerified ( fromActor as any , body ) expect ( result ) . to . be . false } ) it ( 's' , async function ( ) { const body = require ( 's' ) const publicKey = require ( 's' ) . publicKey const fromActor = { publicKey , url : 's' } const result = await isJsonLDSignatureVerified ( fromActor as any , body ) expect ( result ) . to . be . false } ) it ( 's' , async function ( ) { const body = require ( 's' ) const publicKey = require ( 's' ) . publicKey const fromActor = { publicKey , url : 's' } const result = await isJsonLDSignatureVerified ( fromActor as any , body ) expect ( result ) . to . be . true } ) it ( 's' , async function ( ) { const keys = require ( 's' ) const body = require ( 's' ) const actorSignature = { url : 's' , privateKey : keys . privateKey } const signedBody = await buildSignedActivity ( actorSignature as any , body ) const fromActor = { publicKey : keys . publicKey , url : 's' } const result = await isJsonLDSignatureVerified ( fromActor as any , signedBody ) expect ( result ) . to . be . false } ) it ( 's' , async function ( ) { const keys = require ( 's' ) const body = require ( 's' ) const actorSignature = { url : 's' , privateKey : keys . privateKey } const signedBody = await buildSignedActivity ( actorSignature as any , body ) const fromActor = { publicKey : keys . publicKey , url : 's' } const result = await isJsonLDSignatureVerified ( fromActor as any , signedBody ) expect ( result ) . to . be . true } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const req = buildRequestStub ( ) req . method = 's' req . url = 's' const mastodonObject = cloneDeep ( require ( 's' ) ) req . body = mastodonObject . body req . headers = mastodonObject . headers req . headers . signature = 's' + req . headers . signature const parsed = parseHTTPSignature ( req , 0 * 0 * 0 * 0 ) const publicKey = require ( 's' ) . publicKey const actor = { publicKey } const verified = isHTTPSignatureVerified ( parsed , actor as any ) expect ( verified ) . to . be . false } ) it ( 's' , async function ( ) { const req = buildRequestStub ( ) req . method = 's' req . url = 's' const mastodonObject = cloneDeep ( require ( 's' ) ) req . body = mastodonObject . body req . headers = mastodonObject . headers req . headers . signature = 's' + req . headers . signature const parsed = parseHTTPSignature ( req , 0 * 0 * 0 * 0 ) const publicKey = require ( 's' ) . publicKey const actor = { publicKey } const verified = isHTTPSignatureVerified ( parsed , actor as any ) expect ( verified ) . to . be . false } ) it ( 's' , async function ( ) { const req = buildRequestStub ( ) req . method = 's' req . url = 's' const mastodonObject = cloneDeep ( require ( 's' ) ) req . body = mastodonObject . body req . headers = mastodonObject . headers req . headers . signature = 's' + req . headers . signature let errored = false try { parseHTTPSignature ( req ) } catch { errored = true } expect ( errored ) . to . be . true } ) it ( 's' , async function ( ) { const req = buildRequestStub ( ) req . method = 's' req . url = 's' const mastodonObject = cloneDeep ( require ( 's' ) ) req . body = mastodonObject . body req . headers = mastodonObject . headers let errored = false try { parseHTTPSignature ( req , 0 * 0 * 0 * 0 ) } catch { errored = true } expect ( errored ) . to . be . true } ) it ( 's' , async function ( ) { const req = buildRequestStub ( ) req . method = 's' req . url = 's' const mastodonObject = cloneDeep ( require ( 's' ) ) req . body = mastodonObject . body req . headers = mastodonObject . headers req . headers . signature = 's' + req . headers . signature const parsed = parseHTTPSignature ( req , 0 * 0 * 0 * 0 ) const publicKey = require ( 's' ) . publicKey const actor = { publicKey } const verified = isHTTPSignatureVerified ( parsed , actor as any ) expect ( verified ) . to . be . true } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , closeAllSequelize , createVideoPlaylist , doubleFollow , flushAndRunMultipleServers , generateUserAccessToken , getVideo , getVideoPlaylist , killallServers , reRunServer , ServerInfo , setAccessTokensToServers , setActorField , setDefaultVideoChannel , setPlaylistField , setVideoField , uploadVideo , uploadVideoAndGetId , wait , waitJobs } from 's' import { getAccount } from 's' import { VideoPlaylistPrivacy } from 's' describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 let 0 let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 , { transcoding : { enabled : false } } ) await setAccessTokensToServers ( servers ) await setDefaultVideoChannel ( servers ) { 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid } { const 0 = await generateUserAccessToken ( servers [ 0 ] , 's' ) await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' } ) const 0 = await generateUserAccessToken ( servers [ 0 ] , 's' ) await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' } ) } { const playlistAttrs = { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs } ) 0 = res . body . videoPlaylist . uuid } { const playlistAttrs = { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs } ) 0 = res . body . videoPlaylist . uuid } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await setVideoField ( servers [ 0 ] . internalServerNumber , 0 , 's' , 's' ) await getVideo ( servers [ 0 ] . url , 0 ) await getVideo ( servers [ 0 ] . url , 0 ) await waitJobs ( servers ) await getVideo ( servers [ 0 ] . url , 0 , 0 ) await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) await setVideoField ( servers [ 0 ] . internalServerNumber , 0 , 's' , 's' ) await wait ( 0 ) await getVideo ( servers [ 0 ] . url , 0 ) await waitJobs ( [ servers [ 0 ] ] ) await reRunServer ( servers [ 0 ] ) await getVideo ( servers [ 0 ] . url , 0 ) await waitJobs ( servers ) await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) const to = 's' + servers [ 0 ] . port + 's' await setActorField ( servers [ 0 ] . internalServerNumber , to , 's' , 's' ) await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port ) await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 ) await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await setPlaylistField ( servers [ 0 ] . internalServerNumber , 0 , 's' , 's' ) await getVideoPlaylist ( servers [ 0 ] . url , 0 ) await getVideoPlaylist ( servers [ 0 ] . url , 0 ) await waitJobs ( servers ) await getVideoPlaylist ( servers [ 0 ] . url , 0 , 0 ) await getVideoPlaylist ( servers [ 0 ] . url , 0 , 0 ) } ) } ) after ( async function ( ) { this . timeout ( 0 ) await cleanupTests ( servers ) await closeAllSequelize ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { doRequest } from 's' import { HTTP_SIGNATURE } from 's' import { buildGlobalHeaders } from 's' import { activityPubContextify } from 's' function makePOSTAPRequest ( url , body , httpSignature , headers ) { const options = { method : 's' , uri : url , json : body , httpSignature , headers } return doRequest ( options ) } async function makeFollowRequest ( to : { url : string } , by : { url : string , privateKey } ) { const follow = { type : 's' , id : by . url + 's' , actor : by . url , object : to . url } const body = activityPubContextify ( follow ) const httpSignature = { algorithm : HTTP_SIGNATURE . ALGORITHM , authorizationHeaderName : HTTP_SIGNATURE . HEADER_NAME , keyId : by . url , key : by . privateKey , headers : HTTP_SIGNATURE . HEADERS_TO_SIGN } const headers = buildGlobalHeaders ( body ) return makePOSTAPRequest ( to . url , body , httpSignature , headers ) } export { makePOSTAPRequest , makeFollowRequest }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , closeAllSequelize , flushAndRunMultipleServers , killallServers , ServerInfo , setActorField } from 's' import { HTTP_SIGNATURE } from 's' import { buildDigest , buildGlobalHeaders } from 's' import * as chai from 's' import { activityPubContextify , buildSignedActivity } from 's' import { makeFollowRequest , makePOSTAPRequest } from 's' const expect = chai . expect function setKeysOfServer ( onServer , ofServer , publicKey , privateKey ) { return Promise . all ( [ setActorField ( onServer . internalServerNumber , 's' + ofServer . port + 's' , 's' , publicKey ) , setActorField ( onServer . internalServerNumber , 's' + ofServer . port + 's' , 's' , privateKey ) ] ) } function getAnnounceWithoutContext ( 0 ) { const json = require ( 's' ) const result : typeof json = { } for ( const key of Object . keys ( json ) ) { if ( Array . isArray ( json [ key ] ) ) { result [ key ] = json [ key ] . map ( v => v . replace ( 's' , `template` ) ) } else { result [ key ] = json [ key ] . replace ( 's' , `template` ) } } return result } describe ( 's' , function ( ) { let servers : ServerInfo [ ] let url const keys = require ( 's' ) const invalidKeys = require ( 's' ) const baseHttpSignature = ( ) => ( { algorithm : HTTP_SIGNATURE . ALGORITHM , authorizationHeaderName : HTTP_SIGNATURE . HEADER_NAME , keyId : 's' + servers [ 0 ] . port , key : keys . privateKey , headers : HTTP_SIGNATURE . HEADERS_TO_SIGN } ) before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) url = servers [ 0 ] . url + 's' await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) const to = { url : 's' + servers [ 0 ] . port + 's' } const by = { url : 's' + servers [ 0 ] . port + 's' , privateKey : keys . privateKey } await makeFollowRequest ( to , by ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const body = activityPubContextify ( getAnnounceWithoutContext ( servers [ 0 ] ) ) const headers = { Digest : buildDigest ( { hello : 's' } ) } const { response } = await makePOSTAPRequest ( url , body , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const body = activityPubContextify ( getAnnounceWithoutContext ( servers [ 0 ] ) ) const headers = buildGlobalHeaders ( body ) headers [ 's' ] = 's' const { response } = await makePOSTAPRequest ( url , body , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , invalidKeys . publicKey , invalidKeys . privateKey ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , invalidKeys . publicKey , invalidKeys . privateKey ) const body = activityPubContextify ( getAnnounceWithoutContext ( servers [ 0 ] ) ) const headers = buildGlobalHeaders ( body ) const { response } = await makePOSTAPRequest ( url , body , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) const body = activityPubContextify ( getAnnounceWithoutContext ( servers [ 0 ] ) ) const headers = buildGlobalHeaders ( body ) const { response } = await makePOSTAPRequest ( url , body , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) } ) describe ( 's' , function ( ) { before ( async ( ) => { await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) const to = { url : 's' + servers [ 0 ] . port + 's' } const by = { url : 's' + servers [ 0 ] . port + 's' , privateKey : keys . privateKey } await makeFollowRequest ( to , by ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , invalidKeys . publicKey , invalidKeys . privateKey ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , invalidKeys . publicKey , invalidKeys . privateKey ) const body = getAnnounceWithoutContext ( servers [ 0 ] ) body . actor = 's' + servers [ 0 ] . port + 's' const signer = { privateKey : invalidKeys . privateKey , url : 's' + servers [ 0 ] . port + 's' } const signedBody = await buildSignedActivity ( signer , body ) const headers = buildGlobalHeaders ( signedBody ) const { response } = await makePOSTAPRequest ( url , signedBody , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) await setKeysOfServer ( servers [ 0 ] , servers [ 0 ] , keys . publicKey , keys . privateKey ) const body = getAnnounceWithoutContext ( servers [ 0 ] ) body . actor = 's' + servers [ 0 ] . port + 's' const signer = { privateKey : keys . privateKey , url : 's' + servers [ 0 ] . port + 's' } const signedBody = await buildSignedActivity ( signer , body ) signedBody . actor = 's' + servers [ 0 ] . port + 's' const headers = buildGlobalHeaders ( signedBody ) const { response } = await makePOSTAPRequest ( url , signedBody , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const body = getAnnounceWithoutContext ( servers [ 0 ] ) body . actor = 's' + servers [ 0 ] . port + 's' const signer = { privateKey : keys . privateKey , url : 's' + servers [ 0 ] . port + 's' } const signedBody = await buildSignedActivity ( signer , body ) const headers = buildGlobalHeaders ( signedBody ) const { response } = await makePOSTAPRequest ( url , signedBody , baseHttpSignature ( ) , headers ) expect ( response . statusCode ) . to . equal ( 0 ) } ) } ) after ( async function ( ) { this . timeout ( 0 ) await cleanupTests ( servers ) await closeAllSequelize ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $ServerInfo$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O
import 's' import { cleanupTests , flushAndRunServer , ServerInfo } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { getAccount } from 's' describe ( 's' , function ( ) { const path = 's' let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getAccount ( server . url , 's' , 0 ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , makeDeleteRequest , makeGetRequest , makePostBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' describe ( 's' , function ( ) { let servers : ServerInfo [ ] let server let userAccessToken before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) server = servers [ 0 ] const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) describe ( 's' , function ( ) { describe ( 's' , function ( ) { const path = 's' describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) } ) describe ( 's' , function ( ) { const path = 's' describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { host : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' + server . port } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' + servers [ 0 ] . port } , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + servers [ 0 ] . port , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + servers [ 0 ] . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) } ) } ) describe ( 's' , function ( ) { describe ( 's' , function ( ) { const path = 's' describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : userAccessToken , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : userAccessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { accountName : 's' } , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) } ) describe ( 's' , function ( ) { const path = 's' describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : userAccessToken , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { host : 's' + servers [ 0 ] . port } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : userAccessToken , path , fields : { host : 's' + servers [ 0 ] . port } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' + server . port } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path , fields : { host : 's' + servers [ 0 ] . port } , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + servers [ 0 ] . port , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + servers [ 0 ] . port , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + servers [ 0 ] . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { omit } from 's' import 's' import { CustomConfig } from 's' import { cleanupTests , createUser , flushAndRunServer , immutableAssign , makeDeleteRequest , makeGetRequest , makePutBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken const updateParams = { instance : { name : 's' , shortDescription : 's' , description : 's' , terms : 's' , codeOfConduct : 's' , creationReason : 's' , moderationInformation : 's' , administrator : 's' , maintenanceLifetime : 's' , businessModel : 's' , hardwareInformation : 's' , languages : [ 's' , 's' ] , categories : [ 0 , 0 ] , isNSFW : true , defaultClientRoute : 's' , defaultNSFWPolicy : 's' , customizations : { javascript : 's' , css : 's' } } , theme : { default : 's' } , services : { twitter : { username : 's' , whitelisted : true } } , cache : { previews : { size : 0 } , captions : { size : 0 } } , signup : { enabled : false , limit : 0 , requiresEmailVerification : false } , admin : { email : 's' } , contactForm : { enabled : false } , user : { videoQuota : 0 , videoQuotaDaily : 0 } , transcoding : { enabled : true , allowAdditionalExtensions : true , allowAudioFiles : true , threads : 0 , resolutions : { 's' : false , 's' : true , 's' : true , 's' : false , 's' : false , 's' : false } , hls : { enabled : false } } , import : { videos : { http : { enabled : false } , torrent : { enabled : false } } } , autoBlacklist : { videos : { ofUsers : { enabled : false } } } , followers : { instance : { enabled : false , manualApproval : true } } , followings : { instance : { autoFollowBack : { enabled : true } , autoFollowIndex : { enabled : true , indexUrl : 's' } } } } before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , fields : updateParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , fields : updateParams , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const newUpdateParams = omit ( updateParams , 's' ) await makePutBodyRequest ( { url : server . url , path , fields : newUpdateParams , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const newUpdateParams = immutableAssign ( updateParams , { instance : { defaultNSFWPolicy : 's' } } ) await makePutBodyRequest ( { url : server . url , path , fields : newUpdateParams , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const newUpdateParams = immutableAssign ( updateParams , { signup : { enabled : true , limit : 0 , requiresEmailVerification : true } } ) await makePutBodyRequest ( { url : server . url , path , fields : newUpdateParams , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , fields : updateParams , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as request from 's' import { ContactForm } from 's' function sendContactForm ( options : { url : string , fromEmail : string , fromName : string , subject : string , body : string , expectedStatus ? : number } ) { const path = 's' const body = { fromEmail : options . fromEmail , fromName : options . fromName , subject : options . subject , body : options . body } return request ( options . url ) . post ( path ) . send ( body ) . expect ( options . expectedStatus || 0 ) } export { sendContactForm }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ContactForm$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChildProcess , fork } from 's' import { randomInt } from 's' import { parallelTests } from 's' class MockSmtpServer { private static instance : MockSmtpServer private started = false private emailChildProcess : ChildProcess private emails : object [ ] private constructor ( ) { this . emailChildProcess = fork ( `template` , [ ] ) this . emailChildProcess . on ( 's' , ( msg ) => { if ( msg . email ) { return this . emails . push ( msg . email ) } } ) process . on ( 's' , ( ) => this . kill ( ) ) } collectEmails ( emailsCollection : object [ ] ) { return new Promise < number > ( ( res , rej ) => { const port = parallelTests ( ) ? randomInt ( 0 , 0 ) : 0 if ( this . started ) { this . emails = emailsCollection return res ( ) } this . emailChildProcess . send ( { start : true , port } ) this . emailChildProcess . on ( 's' , ( ) => { return rej ( new Error ( 's' ) ) } ) this . emailChildProcess . on ( 's' , ( msg ) => { if ( msg . err ) { return rej ( new Error ( msg . err ) ) } this . started = true this . emails = emailsCollection return res ( port ) } ) } ) } kill ( ) { if ( ! this . emailChildProcess ) return process . kill ( this . emailChildProcess . pid ) this . emailChildProcess = null MockSmtpServer . instance = null } static get Instance ( ) { return this . instance || ( this . instance = new this ( ) ) } } export { MockSmtpServer }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { flushTests , immutableAssign , killallServers , reRunServer , flushAndRunServer , ServerInfo , setAccessTokensToServers , cleanupTests } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { getAccount } from 's' import { sendContactForm } from 's' import { MockSmtpServer } from 's' describe ( 's' , function ( ) { let server const emails : object [ ] = [ ] const defaultBody = { fromName : 's' , fromEmail : 's' , subject : 's' , body : 's' } let emailPort before ( async function ( ) { this . timeout ( 0 ) emailPort = await MockSmtpServer . Instance . collectEmails ( emails ) server = await flushAndRunServer ( 0 ) } ) it ( 's' , async function ( ) { await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 } ) ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server , { smtp : { hostname : 's' , port : emailPort } , contact_form : { enabled : false } } ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 } ) ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server , { smtp : { hostname : 's' , port : emailPort } } ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromEmail : 's' } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromEmail : 's' } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromEmail : undefined } ) ) } ) it ( 's' , async function ( ) { await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromName : 's' . repeat ( 0 ) } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromName : 's' } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , fromName : undefined } ) ) } ) it ( 's' , async function ( ) { await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , body : 's' . repeat ( 0 ) } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , body : 's' } ) ) await sendContactForm ( immutableAssign ( defaultBody , { url : server . url , expectedStatus : 0 , body : undefined } ) ) } ) it ( 's' , async function ( ) { await sendContactForm ( immutableAssign ( defaultBody , { url : server . url } ) ) } ) after ( async function ( ) { MockSmtpServer . Instance . kill ( ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { createUser , flushTests , killallServers , flushAndRunServer , ServerInfo , setAccessTokensToServers , userLogin , cleanupTests } from 's' import { makeGetRequest } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : { startDate : new Date ( ) . toISOString ( ) } , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , flushAndRunServer , makeDeleteRequest , makePostBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) describe ( 's' , function ( ) { let userAccessToken = null before ( async function ( ) { const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { hosts : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { hosts : [ 's' , 's' ] } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { hosts : [ 's' , 's' ] } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { urls : [ 's' , 's' ] } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { hosts : [ 's' ] } , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { hosts : [ 's' ] } , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { createUser , flushTests , killallServers , flushAndRunServer , ServerInfo , setAccessTokensToServers , userLogin , cleanupTests } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { makeGetRequest } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : server . accessToken , path : path + 's' } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { createUser , flushTests , killallServers , flushAndRunServer , ServerInfo , setAccessTokensToServers , userLogin , cleanupTests } from 's' import { makeGetRequest } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : { startDate : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : { startDate : new Date ( ) . toISOString ( ) , endDate : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : { startDate : new Date ( ) . toISOString ( ) , level : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : { startDate : new Date ( ) . toISOString ( ) } , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination , cleanupTests , createUser , flushAndRunServer , immutableAssign , installPlugin , makeGetRequest , makePostBodyRequest , makePutBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' import { PluginType } from 's' import { PeerTubePlugin } from 's' describe ( 's' , function ( ) { let server let userAccessToken = null const npmPlugin = 's' const pluginName = 's' let npmVersion const themePlugin = 's' const themeName = 's' let themeVersion before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) { const res = await installPlugin ( { url : server . url , accessToken : server . accessToken , npmName : npmPlugin } ) const plugin = res . body as PeerTubePlugin npmVersion = plugin . version } { const res = await installPlugin ( { url : server . url , accessToken : server . accessToken , npmName : themePlugin } ) const plugin = res . body as PeerTubePlugin themeVersion = plugin . version } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const paths = [ 's' + pluginName + 's' , 's' + pluginName + 's' , 's' + themeName + 's' , 's' + themeName + 's' , 's' + themeName + 's' ] for ( const p of paths ) { await makeGetRequest ( { url : server . url , path : p , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' + pluginName + 's' + npmVersion + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const paths = [ 's' + pluginName + 's' , 's' + pluginName + 's' , 's' + themeName + 's' , 's' + themeName + 's' , 's' + themeName + 's' ] for ( const p of paths ) { await makeGetRequest ( { url : server . url , path : p , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { const paths = [ 's' + pluginName + 's' + npmVersion + 's' , 's' + pluginName + 's' + npmVersion + 's' , 's' + themeName + 's' + themeVersion + 's' , 's' + themeName + 's' + themeVersion + 's' , 's' + themeName + 's' + themeVersion + 's' ] for ( const p of paths ) { await makeGetRequest ( { url : server . url , path : p , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { const paths = [ 's' + pluginName + 's' + npmVersion + 's' , 's' + pluginName + 's' + npmVersion + 's' , 's' + themeName + 's' + themeVersion + 's' , 's' + themeName + 's' + themeVersion + 's' ] for ( const p of paths ) { await makeGetRequest ( { url : server . url , path : p , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' + themeName + 's' + themeVersion + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const paths = [ 's' + pluginName + 's' + npmVersion + 's' , 's' + pluginName + 's' + npmVersion + 's' , 's' + themeName + 's' + themeVersion + 's' , 's' + themeName + 's' + themeVersion + 's' , 's' + themeName + 's' + themeVersion + 's' ] for ( const p of paths ) { await makeGetRequest ( { url : server . url , path : p , statusCodeExpected : 0 } ) } } ) } ) describe ( 's' , function ( ) { const path = 's' const baseQuery = { search : 's' , pluginType : PluginType . PLUGIN , currentPeerTubeEngine : 's' } it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : 's' , query : baseQuery , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , query : baseQuery , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { const query = immutableAssign ( baseQuery , { pluginType : 0 } ) await makeGetRequest ( { url : server . url , path , token : server . accessToken , query } ) } ) it ( 's' , async function ( ) { const query = immutableAssign ( baseQuery , { currentPeerTubeEngine : 's' } ) await makeGetRequest ( { url : server . url , path , token : server . accessToken , query } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : baseQuery , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' const baseQuery = { pluginType : PluginType . THEME } it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : 's' , query : baseQuery , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , query : baseQuery , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { const query = immutableAssign ( baseQuery , { pluginType : 0 } ) await makeGetRequest ( { url : server . url , path , token : server . accessToken , query } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , query : baseQuery , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { for ( const suffix of [ npmPlugin , `template` ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : 's' , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ npmPlugin , `template` ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : userAccessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ 's' , 's' , 's' ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : server . accessToken , statusCodeExpected : 0 } ) } for ( const suffix of [ 's' , 's' , 's' ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : server . accessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ 's' , 's' , 's' ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : server . accessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ npmPlugin , `template` , `template` ] ) { await makeGetRequest ( { url : server . url , path : path + suffix , token : server . accessToken , statusCodeExpected : 0 } ) } } ) } ) describe ( 's' , function ( ) { const path = 's' const settings = { 0 : 's' } it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path : path + npmPlugin + 's' , fields : { settings } , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path : path + npmPlugin + 's' , fields : { settings } , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path : path + 's' , fields : { settings } , token : server . accessToken , statusCodeExpected : 0 } ) await makePutBodyRequest ( { url : server . url , path : path + 's' , fields : { settings } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path : path + 's' , fields : { settings } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path : path + npmPlugin + 's' , fields : { settings } , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { for ( const suffix of [ 's' , 's' , 's' ] ) { await makePostBodyRequest ( { url : server . url , path : path + suffix , fields : { npmName : npmPlugin } , token : 's' , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ 's' , 's' , 's' ] ) { await makePostBodyRequest ( { url : server . url , path : path + suffix , fields : { npmName : npmPlugin } , token : userAccessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { for ( const suffix of [ 's' , 's' , 's' ] ) { await makePostBodyRequest ( { url : server . url , path : path + suffix , fields : { npmName : 's' } , token : server . accessToken , statusCodeExpected : 0 } ) } for ( const suffix of [ 's' , 's' , 's' ] ) { await makePostBodyRequest ( { url : server . url , path : path + suffix , fields : { npmName : 's' } , token : server . accessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { const it = [ { suffix : 's' , status : 0 } , { suffix : 's' , status : 0 } , { suffix : 's' , status : 0 } ] for ( const obj of it ) { await makePostBodyRequest ( { url : server . url , path : path + obj . suffix , fields : { npmName : npmPlugin } , token : server . accessToken , statusCodeExpected : obj . status } ) } } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , flushTests , killallServers , makePutBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' describe ( 's' , function ( ) { let servers : ServerInfo [ ] let userAccessToken = null before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( servers [ 0 ] , user ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePutBodyRequest ( { url : servers [ 0 ] . url , path : path + 's' + servers [ 0 ] . port , fields : { redundancyAllowed : true } , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : servers [ 0 ] . url , path : path + 's' + servers [ 0 ] . port , fields : { redundancyAllowed : true } , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : servers [ 0 ] . url , path : path + 's' , fields : { redundancyAllowed : true } , token : servers [ 0 ] . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : servers [ 0 ] . url , path : path + 's' + servers [ 0 ] . port , fields : { blabla : true } , token : servers [ 0 ] . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : servers [ 0 ] . url , path : path + 's' + servers [ 0 ] . port , fields : { redundancyAllowed : true } , token : servers [ 0 ] . accessToken , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , flushAndRunServer , immutableAssign , makeGetRequest , ServerInfo } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) } ) describe ( 's' , function ( ) { const path = 's' const query = { search : 's' } it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , query , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { categoryOneOf : [ 's' , 's' ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { categoryOneOf : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { categoryOneOf : [ 0 , 0 ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { categoryOneOf : 0 } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { licenceOneOf : [ 's' , 's' ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { licenceOneOf : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { licenceOneOf : [ 0 , 0 ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { licenceOneOf : 0 } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { languageOneOf : [ 's' , 's' ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { languageOneOf : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { tagsOneOf : [ 's' , 's' ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { tagsOneOf : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { tagsAllOf : [ 's' , 's' ] } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { tagsAllOf : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { durationMin : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { durationMax : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const 0 = immutableAssign ( query , { startDate : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { endDate : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { originallyPublishedStartDate : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) const 0 = immutableAssign ( query , { originallyPublishedEndDate : 's' } ) await makeGetRequest ( { url : server . url , path , query : 0 , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' const query = { search : 's' } it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , null , query ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , query , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , flushAndRunServer , makeGetRequest , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const res = await uploadVideo ( server . url , server . accessToken , { name : 's' } ) server . video = res . body . video } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const embedUrl = 's' await checkParamEmbed ( server , embedUrl ) } ) it ( 's' , async function ( ) { const embedUrl = 's' + server . video . uuid await checkParamEmbed ( server , embedUrl ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl , 0 ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl , 0 , { maxheight : 's' } ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl , 0 , { maxwidth : 's' } ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl , 0 , { format : 's' } ) } ) it ( 's' , async function ( ) { const embedUrl = `template` await checkParamEmbed ( server , embedUrl , 0 , { format : 's' } ) } ) it ( 's' , async function ( ) { const embedUrl = `template` const query = { format : 's' , maxheight : 0 , maxwidth : 0 } await checkParamEmbed ( server , embedUrl , 0 , query ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } ) function checkParamEmbed ( server , embedUrl , statusCodeExpected = 0 , query = { } ) { const path = 's' return makeGetRequest ( { url : server . url , path , query : Object . assign ( query , { url : embedUrl } ) , statusCodeExpected } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as io from 's' import { cleanupTests , flushAndRunServer , immutableAssign , makeGetRequest , makePostBodyRequest , makePutBodyRequest , ServerInfo , setAccessTokensToServers , wait } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { UserNotificationSetting , UserNotificationSettingValue } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , query : { unread : 's' } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { ids : [ 's' ] } , token : server . accessToken , statusCodeExpected : 0 } ) await makePostBodyRequest ( { url : server . url , path , fields : { ids : [ ] } , token : server . accessToken , statusCodeExpected : 0 } ) await makePostBodyRequest ( { url : server . url , path , fields : { ids : 0 } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { ids : [ 0 ] } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { ids : [ 0 ] } , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' const correctFields = { newVideoFromSubscription : UserNotificationSettingValue . WEB , newCommentOnMyVideo : UserNotificationSettingValue . WEB , videoAbuseAsModerator : UserNotificationSettingValue . WEB , videoAutoBlacklistAsModerator : UserNotificationSettingValue . WEB , blacklistOnMyVideo : UserNotificationSettingValue . WEB , myVideoImportFinished : UserNotificationSettingValue . WEB , myVideoPublished : UserNotificationSettingValue . WEB , commentMention : UserNotificationSettingValue . WEB , newFollow : UserNotificationSettingValue . WEB , newUserRegistration : UserNotificationSettingValue . WEB , newInstanceFollower : UserNotificationSettingValue . WEB , autoInstanceFollowing : UserNotificationSettingValue . WEB } it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { newVideoFromSubscription : UserNotificationSettingValue . WEB } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { { const fields = immutableAssign ( correctFields , { newCommentOnMyVideo : 0 } ) await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } { const fields = immutableAssign ( correctFields , { newCommentOnMyVideo : 's' } ) await makePutBodyRequest ( { url : server . url , path , fields , token : server . accessToken , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , fields : correctFields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields : correctFields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , function ( next ) { const socket = io ( `template` , { reconnection : false } ) socket . on ( 's' , ( ) => { socket . removeListener ( 's' , this ) socket . disconnect ( ) next ( ) } ) socket . on ( 's' , ( ) => { socket . disconnect ( ) next ( new Error ( 's' ) ) } ) } ) it ( 's' , function ( next ) { const socket = io ( `template` , { query : { accessToken : 's' } , reconnection : false } ) socket . on ( 's' , ( ) => { socket . removeListener ( 's' , this ) socket . disconnect ( ) next ( ) } ) socket . on ( 's' , ( ) => { socket . disconnect ( ) next ( new Error ( 's' ) ) } ) } ) it ( 's' , function ( next ) { const socket = io ( `template` , { query : { accessToken : server . accessToken } , reconnection : false } ) const errorListener = socket . on ( 's' , err => { next ( new Error ( 's' + err ) ) } ) socket . on ( 's' , async ( ) => { socket . removeListener ( 's' , errorListener ) socket . disconnect ( ) await wait ( 0 ) next ( ) } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , flushAndRunServer , makeDeleteRequest , makeGetRequest , makePostBodyRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { waitJobs } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , fields : { uri : 's' + server . port } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { uri : 's' } , statusCodeExpected : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { uri : 's' } , statusCodeExpected : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { uri : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : { uri : 's' + server . port } , statusCodeExpected : 0 } ) await waitJobs ( [ server ] ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' + server . port , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) await makeGetRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) await makeGetRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' + server . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' + server . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const existPath = path + 's' it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : existPath , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : existPath , query : { uris : 's' } , token : server . accessToken , statusCodeExpected : 0 } ) await makeGetRequest ( { url : server . url , path : existPath , query : { 's' : 0 } , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : existPath , query : { 's' : 's' + server . port } , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + server . port , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + server . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' + server . port , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoImportCreate } from 's' import { makeGetRequest , makeUploadRequest } from 's' function getYoutubeVideoUrl ( ) { return 's' } function getMagnetURI ( ) { return 's' } function getBadVideoUrl ( ) { return 's' } function importVideo ( url , token , attributes ) { const path = 's' let attaches = { } if ( attributes . torrentfile ) attaches = { torrentfile : attributes . torrentfile } return makeUploadRequest ( { url , path , token , attaches , fields : attributes , statusCodeExpected : 0 } ) } function getMyVideoImports ( url , token , sort ? ) { const path = 's' const query = { } if ( sort ) query [ 's' ] = sort return makeGetRequest ( { url , query , path , token , statusCodeExpected : 0 } ) } export { getBadVideoUrl , getYoutubeVideoUrl , importVideo , getMagnetURI , getMyVideoImports }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $VideoImportCreate$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { omit } from 's' import 's' import { join } from 's' import { User , UserRole , VideoImport , VideoImportState } from 's' import { addVideoChannel , blockUser , cleanupTests , createUser , deleteMe , flushAndRunServer , getMyUserInformation , getMyUserVideoRating , getUsersList , immutableAssign , makeGetRequest , makePostBodyRequest , makePutBodyRequest , makeUploadRequest , registerUser , removeUser , ServerInfo , setAccessTokensToServers , unblockUser , updateUser , uploadVideo , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { getMagnetURI , getMyVideoImports , getYoutubeVideoUrl , importVideo } from 's' import { VideoPrivacy } from 's' import { waitJobs } from 's' import { expect } from 's' import { UserAdminFlag } from 's' describe ( 's' , function ( ) { const path = 's' let userId let rootId let moderatorId let videoId let server let serverWithRegistrationDisabled let userAccessToken = 's' let moderatorAccessToken = 's' let channelId before ( async function ( ) { this . timeout ( 0 ) { const res = await Promise . all ( [ flushAndRunServer ( 0 , { signup : { limit : 0 } } ) , flushAndRunServer ( 0 ) ] ) server = res [ 0 ] serverWithRegistrationDisabled = res [ 0 ] await setAccessTokensToServers ( [ server ] ) } { const user = { username : 's' , password : 's' } const videoQuota = 0 await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password , videoQuota : videoQuota } ) userAccessToken = await userLogin ( server , user ) } { const moderator = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : moderator . username , password : moderator . password , role : UserRole . MODERATOR } ) moderatorAccessToken = await userLogin ( server , moderator ) } { const moderator = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : moderator . username , password : moderator . password , role : UserRole . MODERATOR } ) } { const res = await getMyUserInformation ( server . url , server . accessToken ) channelId = res . body . videoChannels [ 0 ] . id } { const res = await uploadVideo ( server . url , server . accessToken , { } ) videoId = res . body . video . id } { const res = await getUsersList ( server . url , server . accessToken ) const users : User [ ] = res . body . data userId = users . find ( u => u . username === 's' ) . id rootId = users . find ( u => u . username === 's' ) . id moderatorId = users . find ( u => u . username === 's' ) . id } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const baseCorrectParams = { username : 's' , email : 's' , password : 's' , videoQuota : - 0 , videoQuotaDaily : - 0 , role : UserRole . USER , adminFlags : UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST } it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { email : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { password : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { password : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { adminFlags : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : 's' , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { email : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { videoQuota : - 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { videoQuotaDaily : - 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { role : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { for ( const role of [ UserRole . MODERATOR , UserRole . ADMINISTRATOR ] ) { const fields = immutableAssign ( baseCorrectParams , { role } ) await makePostBodyRequest ( { url : server . url , path , token : moderatorAccessToken , fields , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' , email : 's' , role : UserRole . USER } ) await makePostBodyRequest ( { url : server . url , path , token : moderatorAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const user = { username : 's' , password : 's' } userAccessToken = await userLogin ( server , user ) const fields = { username : 's' , email : 's' , password : 's' , videoQuota : 0 } await makePostBodyRequest ( { url : server . url , path , token : userAccessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { email : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { nsfwPolicy : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { autoPlayVideo : - 0 } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { autoPlayNextVideo : - 0 } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { videosHistoryEnabled : - 0 } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { description : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { { const fields = { videoLanguages : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } { const languages = [ ] for ( let i = 0 ; i < 0 ; i ++ ) { languages . push ( 's' ) } const fields = { videoLanguages : languages } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } } ) it ( 's' , async function ( ) { const fields = { theme : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { theme : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { noInstanceConfigWarningModal : - 0 } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { noWelcomeModal : - 0 } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' , nsfwPolicy : 's' , autoPlayVideo : false , email : 's' , theme : 's' , noInstanceConfigWarningModal : true , noWelcomeModal : true } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { nsfwPolicy : 's' , autoPlayVideo : false } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , fields , attaches , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + userId , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + userId , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { email : 's' } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { emailVerified : 's' } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { videoQuota : - 0 } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { role : 0 } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { currentPassword : 's' , password : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { videoQuota : 0 } await makePutBodyRequest ( { url : server . url , path : path + userId , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { role : UserRole . MODERATOR } await makePutBodyRequest ( { url : server . url , path : path + rootId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { adminFlags : 's' } await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { videoQuota : 0 } await makePutBodyRequest ( { url : server . url , path : path + moderatorId , token : moderatorAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { videoQuota : 0 } await makePutBodyRequest ( { url : server . url , path : path + userId , token : moderatorAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { email : 's' , emailVerified : true , videoQuota : 0 , role : UserRole . USER } await makePutBodyRequest ( { url : server . url , path : path + userId , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getMyUserInformation ( server . url , 's' , 0 ) } ) it ( 's' , async function ( ) { await getMyUserInformation ( server . url , userAccessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getMyUserVideoRating ( server . url , 's' , videoId , 0 ) } ) it ( 's' , async function ( ) { await getMyUserVideoRating ( server . url , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await getMyUserVideoRating ( server . url , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await getMyUserVideoRating ( server . url , server . accessToken , videoId ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , userAccessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , userAccessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , userAccessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , query : { rating : 's' } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await removeUser ( server . url , 's' , server . accessToken , 0 ) await blockUser ( server . url , 's' , server . accessToken , 0 ) await unblockUser ( server . url , 's' , server . accessToken , 0 ) } ) it ( 's' , async function ( ) { await removeUser ( server . url , rootId , server . accessToken , 0 ) await blockUser ( server . url , rootId , server . accessToken , 0 ) await unblockUser ( server . url , rootId , server . accessToken , 0 ) } ) it ( 's' , async function ( ) { await removeUser ( server . url , 0 , server . accessToken , 0 ) await blockUser ( server . url , 0 , server . accessToken , 0 ) await unblockUser ( server . url , 0 , server . accessToken , 0 ) } ) it ( 's' , async function ( ) { await removeUser ( server . url , userId , userAccessToken , 0 ) await blockUser ( server . url , userId , userAccessToken , 0 ) await unblockUser ( server . url , userId , userAccessToken , 0 ) } ) it ( 's' , async function ( ) { await removeUser ( server . url , moderatorId , moderatorAccessToken , 0 ) await blockUser ( server . url , moderatorId , moderatorAccessToken , 0 ) await unblockUser ( server . url , moderatorId , moderatorAccessToken , 0 ) } ) it ( 's' , async function ( ) { await blockUser ( server . url , userId , moderatorAccessToken ) await unblockUser ( server . url , userId , moderatorAccessToken ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await deleteMe ( server . url , server . accessToken , 0 ) } ) } ) describe ( 's' , function ( ) { const registrationPath = path + 's' const baseCorrectParams = { username : 's' , displayName : 's' , email : 's' , password : 's' } it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { email : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { password : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { password : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { username : 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { email : 's' + server . internalServerNumber + 's' } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { displayName : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channel : { name : 's' , displayName : 's' } } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channel : { name : 's' , displayName : 's' } } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const source = { username : 's' , channel : { name : 's' , displayName : 's' } } const fields = immutableAssign ( baseCorrectParams , source ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const videoChannelAttributesArg = { name : 's' , displayName : 's' , description : 's' } await addVideoChannel ( server . url , server . accessToken , videoChannelAttributesArg ) const fields = immutableAssign ( baseCorrectParams , { channel : { name : 's' , displayName : 's' } } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channel : { name : 's' , displayName : 's' } } ) await makePostBodyRequest ( { url : server . url , path : registrationPath , token : server . accessToken , fields : fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { username : 's' , email : 's' , password : 's' } await makePostBodyRequest ( { url : serverWithRegistrationDisabled . url , path : registrationPath , token : serverWithRegistrationDisabled . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await registerUser ( server . url , 's' , 's' , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId : rootId , accessToken : server . accessToken , videoQuota : 0 } ) await uploadVideo ( server . url , server . accessToken , { } , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const user = { username : 's' , password : 's' } userAccessToken = await userLogin ( server , user ) const videoAttributes = { fixture : 's' } await uploadVideo ( server . url , userAccessToken , videoAttributes ) await uploadVideo ( server . url , userAccessToken , videoAttributes ) await uploadVideo ( server . url , userAccessToken , videoAttributes ) await uploadVideo ( server . url , userAccessToken , videoAttributes ) await uploadVideo ( server . url , userAccessToken , videoAttributes ) await uploadVideo ( server . url , userAccessToken , videoAttributes , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const baseAttributes = { channelId : 0 , privacy : VideoPrivacy . PUBLIC } await importVideo ( server . url , server . accessToken , immutableAssign ( baseAttributes , { targetUrl : getYoutubeVideoUrl ( ) } ) ) await importVideo ( server . url , server . accessToken , immutableAssign ( baseAttributes , { magnetUri : getMagnetURI ( ) } ) ) await importVideo ( server . url , server . accessToken , immutableAssign ( baseAttributes , { torrentfile : 's' } ) ) await waitJobs ( [ server ] ) const res = await getMyVideoImports ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const videoImports : VideoImport [ ] = res . body . data expect ( videoImports ) . to . have . lengthOf ( 0 ) for ( const videoImport of videoImports ) { expect ( videoImport . state . id ) . to . equal ( VideoImportState . FAILED ) expect ( videoImport . error ) . not . to . be . undefined expect ( videoImport . error ) . to . contain ( 's' ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId : rootId , accessToken : server . accessToken , videoQuotaDaily : 0 } ) await uploadVideo ( server . url , server . accessToken , { } , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId : rootId , accessToken : server . accessToken , videoQuota : 0 , videoQuotaDaily : 0 * 0 * 0 } ) await uploadVideo ( server . url , server . accessToken , { } , 0 ) } ) it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId : rootId , accessToken : server . accessToken , videoQuota : 0 * 0 * 0 , videoQuotaDaily : 0 } ) await uploadVideo ( server . url , server . accessToken , { } , 0 ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { email : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { email : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { email : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { email : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server , serverWithRegistrationDisabled ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $ServerInfo$ O $ServerInfo$ O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , deleteVideoAbuse , flushAndRunServer , makeGetRequest , makePostBodyRequest , ServerInfo , setAccessTokensToServers , updateVideoAbuse , uploadVideo , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { VideoAbuseState } from 's' describe ( 's' , function ( ) { let server let userAccessToken = 's' let videoAbuseId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const username = 's' const password = 's' await createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : password } ) userAccessToken = await userLogin ( server , { username , password } ) const res = await uploadVideo ( server . url , server . accessToken , { } ) server . video = res . body . video } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , token : userAccessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const basePath = 's' let path before ( ( ) => { path = basePath + server . video . id + 's' } ) it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const wrongPath = 's' const fields = { reason : 's' } await makePostBodyRequest ( { url : server . url , path : wrongPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { reason : 's' } await makePostBodyRequest ( { url : server . url , path , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { reason : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { reason : 's' . repeat ( 0 ) } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { reason : 's' } const res = await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) videoAbuseId = res . body . videoAbuse . id } ) } ) describe ( 's' , function ( ) { const basePath = 's' let path before ( ( ) => { path = basePath + server . video . id + 's' + videoAbuseId } ) it ( 's' , async function ( ) { await updateVideoAbuse ( server . url , 's' , server . video . uuid , videoAbuseId , { } , 0 ) } ) it ( 's' , async function ( ) { await updateVideoAbuse ( server . url , userAccessToken , server . video . uuid , videoAbuseId , { } , 0 ) } ) it ( 's' , async function ( ) { await updateVideoAbuse ( server . url , server . accessToken , server . video . uuid , 0 , { } , 0 ) await updateVideoAbuse ( server . url , server . accessToken , 0 , videoAbuseId , { } , 0 ) } ) it ( 's' , async function ( ) { const body = { state : 0 } await updateVideoAbuse ( server . url , server . accessToken , server . video . uuid , videoAbuseId , body , 0 ) } ) it ( 's' , async function ( ) { const body = { moderationComment : 's' . repeat ( 0 ) } await updateVideoAbuse ( server . url , server . accessToken , server . video . uuid , videoAbuseId , body , 0 ) } ) it ( 's' , async function ( ) { const body = { state : VideoAbuseState . ACCEPTED } await updateVideoAbuse ( server . url , server . accessToken , server . video . uuid , videoAbuseId , body ) } ) } ) describe ( 's' , function ( ) { const basePath = 's' let path before ( ( ) => { path = basePath + server . video . id + 's' + videoAbuseId } ) it ( 's' , async function ( ) { await deleteVideoAbuse ( server . url , 's' , server . video . uuid , videoAbuseId , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoAbuse ( server . url , userAccessToken , server . video . uuid , videoAbuseId , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoAbuse ( server . url , server . accessToken , server . video . uuid , 0 , 0 ) await deleteVideoAbuse ( server . url , server . accessToken , 0 , videoAbuseId , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoAbuse ( server . url , server . accessToken , server . video . uuid , videoAbuseId ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , flushTests , getBlacklistedVideosList , getVideo , getVideoWithToken , killallServers , makePostBodyRequest , makePutBodyRequest , removeVideoFromBlacklist , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin , waitJobs } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { VideoDetails , VideoBlacklistType } from 's' import { expect } from 's' describe ( 's' , function ( ) { let servers : ServerInfo [ ] let notBlacklistedVideoId let remoteVideoUUID let 0 = 's' let 0 = 's' before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const username = 's' const password = 's' await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : username , password : password } ) 0 = await userLogin ( servers [ 0 ] , { username , password } ) } { const username = 's' const password = 's' await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : username , password : password } ) 0 = await userLogin ( servers [ 0 ] , { username , password } ) } { const res = await uploadVideo ( servers [ 0 ] . url , 0 , { } ) servers [ 0 ] . video = res . body . video } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { } ) notBlacklistedVideoId = res . body . video . uuid } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { } ) remoteVideoUUID = res . body . video . uuid } await waitJobs ( servers ) } ) describe ( 's' , function ( ) { const basePath = 's' it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video + 's' const fields = { } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields } ) } ) it ( 's' , async function ( ) { const wrongPath = 's' const fields = { } await makePostBodyRequest ( { url : servers [ 0 ] . url , path : wrongPath , token : servers [ 0 ] . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video + 's' const fields = { } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video + 's' const fields = { } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : 0 , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video . uuid + 's' const fields = { reason : 's' . repeat ( 0 ) } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = basePath + remoteVideoUUID + 's' const fields = { unfederate : true } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video . uuid + 's' const fields = { } await makePostBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const basePath = 's' it ( 's' , async function ( ) { const wrongPath = 's' const fields = { } await makePutBodyRequest ( { url : servers [ 0 ] . url , path : wrongPath , token : servers [ 0 ] . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = 's' + notBlacklistedVideoId + 's' const fields = { } await makePutBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video + 's' const fields = { } await makePutBodyRequest ( { url : servers [ 0 ] . url , path , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video + 's' const fields = { } await makePutBodyRequest ( { url : servers [ 0 ] . url , path , token : 0 , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video . uuid + 's' const fields = { reason : 's' . repeat ( 0 ) } await makePutBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = basePath + servers [ 0 ] . video . uuid + 's' const fields = { reason : 's' } await makePutBodyRequest ( { url : servers [ 0 ] . url , path , token : servers [ 0 ] . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , servers [ 0 ] . video . uuid , 0 ) } ) it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , 0 , servers [ 0 ] . video . uuid , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoWithToken ( servers [ 0 ] . url , 0 , servers [ 0 ] . video . uuid , 0 ) const video = res . body expect ( video . blacklisted ) . to . be . true } ) it ( 's' , async function ( ) { const res = await getVideoWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . video . uuid , 0 ) const video = res . body expect ( video . blacklisted ) . to . be . true } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await removeVideoFromBlacklist ( servers [ 0 ] . url , 's' , servers [ 0 ] . video . uuid , 0 ) } ) it ( 's' , async function ( ) { await removeVideoFromBlacklist ( servers [ 0 ] . url , 0 , servers [ 0 ] . video . uuid , 0 ) } ) it ( 's' , async function ( ) { await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , notBlacklistedVideoId , 0 ) } ) it ( 's' , async function ( ) { await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . video . uuid , 0 ) } ) } ) describe ( 's' , function ( ) { const basePath = 's' it ( 's' , async function ( ) { await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : 's' , specialStatus : 0 } ) } ) it ( 's' , async function ( ) { await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : 0 , specialStatus : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( servers [ 0 ] . url , basePath , servers [ 0 ] . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( servers [ 0 ] . url , basePath , servers [ 0 ] . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( servers [ 0 ] . url , basePath , servers [ 0 ] . accessToken ) } ) it ( 's' , async function ( ) { await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : 0 , specialStatus : 0 } ) } ) it ( 's' , async function ( ) { await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : VideoBlacklistType . MANUAL } ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeDeleteRequest , makeGetRequest , makeUploadRequest } from 's' import * as request from 's' import * as chai from 's' import { buildAbsoluteFixturePath } from 's' const expect = chai . expect function createVideoCaption ( args : { url : string , accessToken : string videoId : string | number language : string fixture : string , mimeType ? : string , statusCodeExpected ? : number } ) { const path = 's' + args . videoId + 's' + args . language const captionfile = buildAbsoluteFixturePath ( args . fixture ) const captionfileAttach = args . mimeType ? [ captionfile , { contentType : args . mimeType } ] : captionfile return makeUploadRequest ( { method : 's' , url : args . url , path , token : args . accessToken , fields : { } , attaches : { captionfile : captionfileAttach } , statusCodeExpected : args . statusCodeExpected || 0 } ) } function listVideoCaptions ( url , videoId : string | number ) { const path = 's' + videoId + 's' return makeGetRequest ( { url , path , statusCodeExpected : 0 } ) } function deleteVideoCaption ( url , token , videoId : string | number , language ) { const path = 's' + videoId + 's' + language return makeDeleteRequest ( { url , token , path , statusCodeExpected : 0 } ) } async function testCaptionFile ( url , captionPath , containsString ) { const res = await request ( url ) . get ( captionPath ) . expect ( 0 ) expect ( res . text ) . to . contain ( containsString ) } export { createVideoCaption , listVideoCaptions , testCaptionFile , deleteVideoCaption }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , flushAndRunServer , makeDeleteRequest , makeGetRequest , makeUploadRequest , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin } from 's' import { join } from 's' import { createVideoCaption } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken let videoUUID before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const res = await uploadVideo ( server . url , server . accessToken , { } ) videoUUID = res . body . video . uuid } { const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } } ) describe ( 's' , function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } it ( 's' , async function ( ) { await makeUploadRequest ( { method : 's' , url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { await makeUploadRequest ( { method : 's' , url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , fields , attaches , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , token : 's' , fields , attaches , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await createVideoCaption ( { url : server . url , accessToken : server . accessToken , language : 's' , videoId : videoUUID , fixture : 's' , mimeType : 's' } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeUploadRequest ( { method : 's' , url : server . url , path : captionPath , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + videoUUID + 's' , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : path + 's' , token : server . accessToken } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , token : server . accessToken } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , token : server . accessToken } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const captionPath = path + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path : captionPath , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import { omit } from 's' import 's' import { cleanupTests , createUser , deleteVideoChannel , flushAndRunServer , getAccountVideoChannelsList , immutableAssign , makeGetRequest , makePostBodyRequest , makePutBodyRequest , makeUploadRequest , ServerInfo , setAccessTokensToServers , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { join } from 's' import { VideoChannelUpdate } from 's' const expect = chai . expect describe ( 's' , function ( ) { const videoChannelPath = 's' let server let accessTokenUser before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const user = { username : 's' , password : 's' } { await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) accessTokenUser = await userLogin ( server , user ) } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , videoChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , videoChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , videoChannelPath , server . accessToken ) } ) } ) describe ( 's' , function ( ) { const accountChannelPath = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , accountChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , accountChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , accountChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await getAccountVideoChannelsList ( { url : server . url , accountName : 's' , specialStatus : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : accountChannelPath , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const baseCorrectParams = { name : 's' , displayName : 's' , description : 's' , support : 's' } it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : 's' , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { name : 's' } ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { displayName : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { description : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { support : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : videoChannelPath , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const baseCorrectParams = { displayName : 's' , description : 's' , support : 's' , bulkVideosSupportUpdate : false } let path before ( async function ( ) { path = videoChannelPath + 's' } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , token : 's' , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , token : accessTokenUser , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { displayName : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { description : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { support : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { bulkVideosSupportUpdate : 's' } ) await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { let path before ( async function ( ) { path = videoChannelPath + 's' } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , fields , attaches , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { } const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : videoChannelPath , statusCodeExpected : 0 } ) expect ( res . body . data ) . to . be . an ( 's' ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : videoChannelPath + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : videoChannelPath + 's' , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await deleteVideoChannel ( server . url , 's' , 's' , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoChannel ( server . url , accessTokenUser , 's' , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoChannel ( server . url , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoChannel ( server . url , server . accessToken , 's' ) } ) it ( 's' , async function ( ) { await deleteVideoChannel ( server . url , server . accessToken , 's' , 0 ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannelUpdate$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , createUser , flushAndRunServer , makeDeleteRequest , makeGetRequest , makePostBodyRequest , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { addVideoCommentThread } from 's' const expect = chai . expect describe ( 's' , function ( ) { let pathThread let pathComment let server let videoUUID let userAccessToken let commentId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const res = await uploadVideo ( server . url , server . accessToken , { } ) videoUUID = res . body . video . uuid pathThread = 's' + videoUUID + 's' } { const res = await addVideoCommentThread ( server . url , server . accessToken , videoUUID , 's' ) commentId = res . body . comment . id pathComment = 's' + videoUUID + 's' + commentId } { const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , pathThread , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , pathThread , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , pathThread , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' + commentId , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' + videoUUID + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' + videoUUID + 's' + commentId , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathThread , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path : pathThread , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathThread , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' . repeat ( 0 ) } await makePostBodyRequest ( { url : server . url , path : pathThread , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = 's' const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathThread , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathComment , token : 's' , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path : pathComment , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathComment , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' . repeat ( 0 ) } await makePostBodyRequest ( { url : server . url , path : pathComment , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const path = 's' + commentId const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = 's' + videoUUID + 's' const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathComment , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : pathComment , token : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : pathComment , token : userAccessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = 's' + commentId await makeDeleteRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const path = 's' + videoUUID + 's' await makeDeleteRequest ( { url : server . url , path , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path : pathComment , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { before ( async function ( ) { const res = await uploadVideo ( server . url , server . accessToken , { commentsEnabled : false } ) videoUUID = res . body . video . uuid pathThread = 's' + videoUUID + 's' } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : pathThread , statusCodeExpected : 0 } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { const fields = { text : 's' } await makePostBodyRequest ( { url : server . url , path : pathThread , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $ServerInfo$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { omit } from 's' import 's' import { join } from 's' import { VideoPrivacy } from 's' import { cleanupTests , createUser , flushAndRunServer , getMyUserInformation , immutableAssign , makeGetRequest , makePostBodyRequest , makeUploadRequest , ServerInfo , setAccessTokensToServers , updateCustomSubConfig , userLogin } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { getMagnetURI , getYoutubeVideoUrl } from 's' describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' let accountName let channelId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const username = 's' const password = 's' await createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : password } ) userAccessToken = await userLogin ( server , { username , password } ) { const res = await getMyUserInformation ( server . url , server . accessToken ) channelId = res . body . videoChannels [ 0 ] . id accountName = res . body . account . name + 's' + res . body . account . host } } ) describe ( 's' , function ( ) { const myPath = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , myPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , myPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , myPath , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : myPath , statusCodeExpected : 0 , token : server . accessToken } ) } ) } ) describe ( 's' , function ( ) { let baseCorrectParams before ( function ( ) { baseCorrectParams = { targetUrl : getYoutubeVideoUrl ( ) , name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , commentsEnabled : true , downloadEnabled : true , waitTranscoding : true , description : 's' , support : 's' , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , channelId } } ) it ( 's' , async function ( ) { const fields = { } await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { targetUrl : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { name : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { category : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { licence : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { language : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { description : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { support : 's' . repeat ( 0 ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channelId : 0 } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) const accessTokenUser = await userLogin ( server , user ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const customChannelId = res . body . videoChannels [ 0 ] . id const fields = immutableAssign ( baseCorrectParams , { channelId : customChannelId } ) await makePostBodyRequest ( { url : server . url , path , token : userAccessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' , 's' , 's' , 's' , 's' ] } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { let fields = omit ( baseCorrectParams , 's' ) fields = immutableAssign ( fields , { magnetUri : 's' } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } } ) it ( 's' , async function ( ) { await updateCustomSubConfig ( server . url , server . accessToken , { import : { videos : { http : { enabled : false } , torrent : { enabled : true } } } } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields : baseCorrectParams , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await updateCustomSubConfig ( server . url , server . accessToken , { import : { videos : { http : { enabled : true } , torrent : { enabled : false } } } } ) let fields = omit ( baseCorrectParams , 's' ) fields = immutableAssign ( fields , { magnetUri : getMagnetURI ( ) } ) await makePostBodyRequest ( { url : server . url , path , token : server . accessToken , fields , statusCodeExpected : 0 } ) fields = omit ( fields , 's' ) const attaches = { 's' : join ( __dirname , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { addVideoInPlaylist , cleanupTests , createVideoPlaylist , deleteVideoPlaylist , flushAndRunServer , generateUserAccessToken , getAccountPlaylistsListWithToken , getVideoPlaylist , immutableAssign , makeGetRequest , removeVideoFromPlaylist , reorderVideosPlaylist , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , updateVideoPlaylist , updateVideoPlaylistElement , uploadVideoAndGetId } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' import { VideoPlaylistPrivacy } from 's' import { VideoPlaylistType } from 's' describe ( 's' , function ( ) { let server let userAccessToken let playlistUUID let privatePlaylistUUID let watchLaterPlaylistId let videoId let 0 let playlistElementId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await setDefaultVideoChannel ( [ server ] ) userAccessToken = await generateUserAccessToken ( server , 's' ) videoId = ( await uploadVideoAndGetId ( { server , videoName : 's' } ) ) . id 0 = ( await uploadVideoAndGetId ( { server , videoName : 's' } ) ) . id { const res = await getAccountPlaylistsListWithToken ( server . url , server . accessToken , 's' , 0 , 0 , VideoPlaylistType . WATCH_LATER ) watchLaterPlaylistId = res . body . data [ 0 ] . id } { const res = await createVideoPlaylist ( { url : server . url , token : server . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : server . videoChannel . id } } ) playlistUUID = res . body . videoPlaylist . uuid } { const res = await createVideoPlaylist ( { url : server . url , token : server . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PRIVATE } } ) privatePlaylistUUID = res . body . videoPlaylist . uuid } } ) describe ( 's' , function ( ) { const globalPath = 's' const accountPath = 's' const videoChannelPath = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , globalPath , server . accessToken ) await checkBadStartPagination ( server . url , accountPath , server . accessToken ) await checkBadStartPagination ( server . url , videoChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , globalPath , server . accessToken ) await checkBadCountPagination ( server . url , accountPath , server . accessToken ) await checkBadCountPagination ( server . url , videoChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , globalPath , server . accessToken ) await checkBadSortPagination ( server . url , accountPath , server . accessToken ) await checkBadSortPagination ( server . url , videoChannelPath , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : globalPath , query : { playlistType : 0 } } ) await makeGetRequest ( { url : server . url , path : accountPath , query : { playlistType : 0 } } ) await makeGetRequest ( { url : server . url , path : videoChannelPath , query : { playlistType : 0 } } ) } ) it ( 's' , async function ( ) { const accountPath = 's' await makeGetRequest ( { url : server . url , path : accountPath , statusCodeExpected : 0 , token : server . accessToken } ) } ) it ( 's' , async function ( ) { const accountPath = 's' await makeGetRequest ( { url : server . url , path : accountPath , statusCodeExpected : 0 , token : server . accessToken } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : globalPath , statusCodeExpected : 0 , token : server . accessToken } ) await makeGetRequest ( { url : server . url , path : accountPath , statusCodeExpected : 0 , token : server . accessToken } ) await makeGetRequest ( { url : server . url , path : videoChannelPath , statusCodeExpected : 0 , token : server . accessToken } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path + playlistUUID + 's' , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path + playlistUUID + 's' , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : path + playlistUUID + 's' , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideoPlaylist ( server . url , 's' , 0 ) } ) it ( 's' , async function ( ) { await getVideoPlaylist ( server . url , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await createVideoPlaylist ( { url : server . url , token : server . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . UNLISTED } } ) const playlist = res . body . videoPlaylist await getVideoPlaylist ( server . url , playlist . id , 0 ) await getVideoPlaylist ( server . url , playlist . uuid , 0 ) } ) it ( 's' , async function ( ) { await getVideoPlaylist ( server . url , playlistUUID , 0 ) } ) } ) describe ( 's' , function ( ) { const getBase = ( playlistAttrs = { } , wrapper = { } ) => { return Object . assign ( { expectedStatus : 0 , url : server . url , token : server . accessToken , playlistAttrs : Object . assign ( { displayName : 's' , privacy : VideoPlaylistPrivacy . UNLISTED , thumbnailfile : 's' , videoChannelId : server . videoChannel . id } , playlistAttrs ) } , wrapper ) } const getUpdate = ( params , playlistId : number | string ) => { return immutableAssign ( params , { playlistId : playlistId } ) } it ( 's' , async function ( ) { const params = getBase ( { } , { token : null , expectedStatus : 0 } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { displayName : undefined } ) await createVideoPlaylist ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { displayName : 's' . repeat ( 0 ) } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { description : 's' } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { privacy : 0 } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { videoChannelId : 0 } , { expectedStatus : 0 } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { thumbnailfile : 's' } ) await createVideoPlaylist ( params ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } ) it ( 's' , async function ( ) { const params = getBase ( { privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : undefined } ) const 0 = getBase ( { privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : 's' } ) const 0 = getBase ( { privacy : undefined , videoChannelId : 's' } ) await createVideoPlaylist ( params ) await createVideoPlaylist ( 0 ) await updateVideoPlaylist ( getUpdate ( params , privatePlaylistUUID ) ) await updateVideoPlaylist ( getUpdate ( 0 , playlistUUID ) ) await updateVideoPlaylist ( getUpdate ( 0 , playlistUUID ) ) } ) it ( 's' , async function ( ) { await updateVideoPlaylist ( getUpdate ( getBase ( { } , { expectedStatus : 0 } ) , 0 ) ) } ) it ( 's' , async function ( ) { await updateVideoPlaylist ( getUpdate ( getBase ( { } , { token : userAccessToken , expectedStatus : 0 } ) , playlistUUID ) ) } ) it ( 's' , async function ( ) { await updateVideoPlaylist ( getUpdate ( getBase ( { } , { expectedStatus : 0 } ) , watchLaterPlaylistId ) ) } ) it ( 's' , async function ( ) { { const params = getBase ( { } , { expectedStatus : 0 } ) await createVideoPlaylist ( params ) } { const params = getBase ( { } , { expectedStatus : 0 } ) await updateVideoPlaylist ( getUpdate ( params , playlistUUID ) ) } } ) } ) describe ( 's' , function ( ) { const getBase = ( elementAttrs = { } , wrapper = { } ) => { return Object . assign ( { expectedStatus : 0 , url : server . url , token : server . accessToken , playlistId : playlistUUID , elementAttrs : Object . assign ( { videoId , startTimestamp : 0 , stopTimestamp : 0 } , elementAttrs ) } , wrapper ) } it ( 's' , async function ( ) { const params = getBase ( { } , { token : null , expectedStatus : 0 } ) await addVideoInPlaylist ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { } , { token : userAccessToken , expectedStatus : 0 } ) await addVideoInPlaylist ( params ) } ) it ( 's' , async function ( ) { { const params = getBase ( { } , { playlistId : 's' } ) await addVideoInPlaylist ( params ) } { const params = getBase ( { } , { playlistId : 0 , expectedStatus : 0 } ) await addVideoInPlaylist ( params ) } } ) it ( 's' , async function ( ) { const params = getBase ( { videoId : 0 } , { expectedStatus : 0 } ) await addVideoInPlaylist ( params ) } ) it ( 's' , async function ( ) { { const params = getBase ( { startTimestamp : - 0 } ) await addVideoInPlaylist ( params ) } { const params = getBase ( { stopTimestamp : 's' as any } ) await addVideoInPlaylist ( params ) } } ) it ( 's' , async function ( ) { const params = getBase ( { } , { expectedStatus : 0 } ) const res = await addVideoInPlaylist ( params ) playlistElementId = res . body . videoPlaylistElement . id } ) it ( 's' , async function ( ) { const params = getBase ( { } , { expectedStatus : 0 } ) await addVideoInPlaylist ( params ) } ) } ) describe ( 's' , function ( ) { const getBase = ( elementAttrs = { } , wrapper = { } ) => { return Object . assign ( { url : server . url , token : server . accessToken , elementAttrs : Object . assign ( { startTimestamp : 0 , stopTimestamp : 0 } , elementAttrs ) , playlistElementId , playlistId : playlistUUID , expectedStatus : 0 } , wrapper ) } it ( 's' , async function ( ) { const params = getBase ( { } , { token : null , expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { } , { token : userAccessToken , expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } ) it ( 's' , async function ( ) { { const params = getBase ( { } , { playlistId : 's' } ) await updateVideoPlaylistElement ( params ) } { const params = getBase ( { } , { playlistId : 0 , expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { } , { playlistElementId : 's' } ) await updateVideoPlaylistElement ( params ) } { const params = getBase ( { } , { playlistElementId : 0 , expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { startTimestamp : 's' as any } ) await updateVideoPlaylistElement ( params ) } { const params = getBase ( { stopTimestamp : - 0 } ) await updateVideoPlaylistElement ( params ) } } ) it ( 's' , async function ( ) { const params = getBase ( { } , { playlistElementId : 0 , expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { } , { expectedStatus : 0 } ) await updateVideoPlaylistElement ( params ) } ) } ) describe ( 's' , function ( ) { let 0 let 0 const getBase = ( elementAttrs = { } , wrapper = { } ) => { return Object . assign ( { url : server . url , token : server . accessToken , playlistId : playlistUUID , elementAttrs : Object . assign ( { startPosition : 0 , insertAfterPosition : 0 , reorderLength : 0 } , elementAttrs ) , expectedStatus : 0 } , wrapper ) } before ( async function ( ) { 0 = ( await uploadVideoAndGetId ( { server , videoName : 's' } ) ) . id 0 = ( await uploadVideoAndGetId ( { server , videoName : 's' } ) ) . id for ( let id of [ 0 , 0 ] ) { await addVideoInPlaylist ( { url : server . url , token : server . accessToken , playlistId : playlistUUID , elementAttrs : { videoId : id } } ) } } ) it ( 's' , async function ( ) { const params = getBase ( { } , { token : null , expectedStatus : 0 } ) await reorderVideosPlaylist ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { } , { token : userAccessToken , expectedStatus : 0 } ) await reorderVideosPlaylist ( params ) } ) it ( 's' , async function ( ) { { const params = getBase ( { } , { playlistId : 's' } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { } , { playlistId : 0 , expectedStatus : 0 } ) await reorderVideosPlaylist ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { startPosition : - 0 } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { startPosition : 's' as any } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { startPosition : 0 } ) await reorderVideosPlaylist ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { insertAfterPosition : 's' as any } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { insertAfterPosition : - 0 } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { insertAfterPosition : 0 } ) await reorderVideosPlaylist ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { reorderLength : 's' as any } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { reorderLength : - 0 } ) await reorderVideosPlaylist ( params ) } { const params = getBase ( { reorderLength : 0 } ) await reorderVideosPlaylist ( params ) } } ) it ( 's' , async function ( ) { const params = getBase ( { } , { expectedStatus : 0 } ) await reorderVideosPlaylist ( params ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , query : { videoIds : [ 0 , 0 ] } , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : server . accessToken , path , query : { videoIds : 's' } } ) await makeGetRequest ( { url : server . url , token : server . accessToken , path , query : { videoIds : [ 's' ] } } ) await makeGetRequest ( { url : server . url , token : server . accessToken , path , query : { videoIds : [ 0 , 's' ] } } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : server . accessToken , path , query : { videoIds : [ 0 , 0 ] } , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const getBase = ( wrapper = { } ) => { return Object . assign ( { url : server . url , token : server . accessToken , playlistElementId , playlistId : playlistUUID , expectedStatus : 0 } , wrapper ) } it ( 's' , async function ( ) { const params = getBase ( { token : null , expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { token : userAccessToken , expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } ) it ( 's' , async function ( ) { { const params = getBase ( { playlistId : 's' } ) await removeVideoFromPlaylist ( params ) } { const params = getBase ( { playlistId : 0 , expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } } ) it ( 's' , async function ( ) { { const params = getBase ( { playlistElementId : 's' } ) await removeVideoFromPlaylist ( params ) } { const params = getBase ( { playlistElementId : 0 , expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } } ) it ( 's' , async function ( ) { const params = getBase ( { playlistElementId : 0 , expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } ) it ( 's' , async function ( ) { const params = getBase ( { expectedStatus : 0 } ) await removeVideoFromPlaylist ( params ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await deleteVideoPlaylist ( server . url , server . accessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoPlaylist ( server . url , userAccessToken , playlistUUID , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoPlaylist ( server . url , server . accessToken , watchLaterPlaylistId , 0 ) } ) it ( 's' , async function ( ) { await deleteVideoPlaylist ( server . url , server . accessToken , playlistUUID ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O $string$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import { omit } from 's' import 's' import { join } from 's' import { VideoPrivacy } from 's' import { cleanupTests , createUser , flushAndRunServer , getMyUserInformation , getVideo , getVideosList , immutableAssign , makeDeleteRequest , makeGetRequest , makePutBodyRequest , makeUploadRequest , removeVideo , ServerInfo , setAccessTokensToServers , userLogin , root } from 's' import { checkBadCountPagination , checkBadSortPagination , checkBadStartPagination } from 's' const expect = chai . expect describe ( 's' , function ( ) { const path = 's' let server let userAccessToken = 's' let accountName let channelId let channelName let videoId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const username = 's' const password = 's' await createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : password } ) userAccessToken = await userLogin ( server , { username , password } ) { const res = await getMyUserInformation ( server . url , server . accessToken ) channelId = res . body . videoChannels [ 0 ] . id channelName = res . body . videoChannels [ 0 ] . name accountName = res . body . account . name + 's' + res . body . account . host } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : join ( path , 's' ) , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , join ( path , 's' , 's' ) ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , join ( path , 's' , 's' ) ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , join ( path , 's' , 's' ) ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { const path = 's' it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : server . accessToken , path , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { let path before ( async function ( ) { path = 's' + accountName + 's' } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { let path before ( async function ( ) { path = 's' + channelName + 's' } ) it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadSortPagination ( server . url , path , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { let baseCorrectParams const baseCorrectAttaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } before ( function ( ) { baseCorrectParams = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , commentsEnabled : true , downloadEnabled : true , waitTranscoding : true , description : 's' , support : 's' , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , channelId : channelId , originallyPublishedAt : new Date ( ) . toISOString ( ) } } ) it ( 's' , async function ( ) { const fields = { } const attaches = { } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { name : 's' . repeat ( 0 ) } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { category : 0 } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { licence : 0 } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { language : 's' . repeat ( 0 ) } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { description : 's' . repeat ( 0 ) } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { support : 's' . repeat ( 0 ) } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = omit ( baseCorrectParams , 's' ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channelId : 0 } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) const accessTokenUser = await userLogin ( server , user ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const customChannelId = res . body . videoChannels [ 0 ] . id const fields = immutableAssign ( baseCorrectParams , { channelId : customChannelId } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : userAccessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' , 's' , 's' , 's' , 's' ] } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { 's' : VideoPrivacy . PUBLIC } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { 's' : VideoPrivacy . PUBLIC , 's' : 's' } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { 's' : 's' } ) const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams let attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) , 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) , 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) , 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) , 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const fields = baseCorrectParams { const attaches = baseCorrectAttaches await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } { const attaches = immutableAssign ( baseCorrectAttaches , { videofile : join ( root ( ) , 's' , 's' , 's' , 's' ) } ) await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } { const attaches = immutableAssign ( baseCorrectAttaches , { videofile : join ( root ( ) , 's' , 's' , 's' , 's' ) } ) await makeUploadRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , attaches , statusCodeExpected : 0 } ) } } ) } ) describe ( 's' , function ( ) { const baseCorrectParams = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , commentsEnabled : false , downloadEnabled : false , description : 's' , privacy : VideoPrivacy . PUBLIC , tags : [ 's' , 's' ] } before ( async function ( ) { const res = await getVideosList ( server . url ) videoId = res . body . data [ 0 ] . uuid } ) it ( 's' , async function ( ) { const fields = { } await makePutBodyRequest ( { url : server . url , path , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams await makePutBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams await makePutBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { name : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { category : 0 } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { licence : 0 } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { language : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { description : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { support : 's' . repeat ( 0 ) } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { channelId : 0 } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' , 's' , 's' , 's' , 's' ] } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { tags : [ 's' , 's' ] } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { scheduleUpdate : { privacy : VideoPrivacy . PUBLIC } } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { scheduleUpdate : { updateAt : 's' , privacy : VideoPrivacy . PUBLIC } } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = immutableAssign ( baseCorrectParams , { originallyPublishedAt : 's' } ) await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , method : 's' , path : path + videoId , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , method : 's' , path : path + videoId , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , method : 's' , path : path + videoId , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams const attaches = { 's' : join ( root ( ) , 's' , 's' , 's' , 's' ) } await makeUploadRequest ( { url : server . url , method : 's' , path : path + videoId , token : server . accessToken , fields , attaches } ) } ) it ( 's' , async function ( ) { const fields = baseCorrectParams await makePutBodyRequest ( { url : server . url , path : path + videoId , token : userAccessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' ) it ( 's' , async function ( ) { const fields = baseCorrectParams await makePutBodyRequest ( { url : server . url , path : path + videoId , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path , statusCodeExpected : 0 } ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await getVideo ( server . url , 's' , 0 ) } ) it ( 's' , async function ( ) { await getVideo ( server . url , 's' , 0 ) } ) it ( 's' , async function ( ) { await getVideo ( server . url , videoId ) } ) } ) describe ( 's' , function ( ) { let videoId before ( async function ( ) { const res = await getVideosList ( server . url ) videoId = res . body . data [ 0 ] . id } ) it ( 's' , async function ( ) { const fields = { rating : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { rating : 's' } await makePutBodyRequest ( { url : server . url , path : path + 's' , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { rating : 's' } await makePutBodyRequest ( { url : server . url , path : path + videoId + 's' , token : server . accessToken , fields } ) } ) it ( 's' , async function ( ) { const fields = { rating : 's' } await makePutBodyRequest ( { url : server . url , path : path + videoId + 's' , token : server . accessToken , fields , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makeDeleteRequest ( { url : server . url , path , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await removeVideo ( server . url , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await removeVideo ( server . url , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await removeVideo ( server . url , userAccessToken , videoId , 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { await removeVideo ( server . url , server . accessToken , videoId ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O $string$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , createVideoPlaylist , flushAndRunServer , makeGetRequest , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , userLogin } from 's' import { UserRole } from 's' import { VideoPlaylistPrivacy } from 's' async function testEndpoints ( server , token , filter , statusCodeExpected ) { const paths = [ 's' , 's' , 's' , 's' ] for ( const path of paths ) { await makeGetRequest ( { url : server . url , path , token , query : { filter } , statusCodeExpected } ) } } describe ( 's' , function ( ) { let server let userAccessToken let moderatorAccessToken let playlistUUID before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await setDefaultVideoChannel ( [ server ] ) const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) const moderator = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : moderator . username , password : moderator . password , videoQuota : undefined , videoQuotaDaily : undefined , role : UserRole . MODERATOR } ) moderatorAccessToken = await userLogin ( server , moderator ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await testEndpoints ( server , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await testEndpoints ( server , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await testEndpoints ( server , userAccessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await testEndpoints ( server , moderatorAccessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await testEndpoints ( server , server . accessToken , 's' , 0 ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 , query : { filter : 's' } } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 , query : { filter : 's' } } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { checkBadCountPagination , checkBadStartPagination , cleanupTests , flushAndRunServer , makeGetRequest , makePostBodyRequest , makePutBodyRequest , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let watchingPath let myHistoryPath = 's' let myHistoryRemove = myHistoryPath + 's' let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const res = await uploadVideo ( server . url , server . accessToken , { } ) const videoUUID = res . body . video . uuid watchingPath = 's' + videoUUID + 's' } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const fields = { currentTime : 0 } await makePutBodyRequest ( { url : server . url , path : watchingPath , fields , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { currentTime : 0 } const path = 's' await makePutBodyRequest ( { url : server . url , path , fields , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { currentTime : 0 } const path = 's' await makePutBodyRequest ( { url : server . url , path , fields , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { currentTime : 's' } await makePutBodyRequest ( { url : server . url , path : watchingPath , fields , token : server . accessToken , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const fields = { currentTime : 0 } await makePutBodyRequest ( { url : server . url , path : watchingPath , fields , token : server . accessToken , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await checkBadStartPagination ( server . url , myHistoryPath , server . accessToken ) } ) it ( 's' , async function ( ) { await checkBadCountPagination ( server . url , myHistoryPath , server . accessToken ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : myHistoryPath , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , token : server . accessToken , path : myHistoryPath , statusCodeExpected : 0 } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , path : myHistoryPath + 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const body = { beforeDate : 's' } await makePostBodyRequest ( { url : server . url , token : server . accessToken , path : myHistoryRemove , fields : body , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const body = { beforeDate : new Date ( ) . toISOString ( ) } await makePostBodyRequest ( { url : server . url , token : server . accessToken , path : myHistoryRemove , fields : body , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { await makePostBodyRequest ( { url : server . url , token : server . accessToken , path : myHistoryRemove , statusCodeExpected : 0 } ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as io from 's' function getUserNotificationSocket ( serverUrl , accessToken ) { return io ( serverUrl + 's' , { query : { accessToken } } ) } export { getUserNotificationSocket }	O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest , makePostBodyRequest , makePutBodyRequest } from 's' import { UserNotification , UserNotificationSetting , UserNotificationType } from 's' import { ServerInfo } from 's' import { expect } from 's' import { inspect } from 's' function updateMyNotificationSettings ( url , token , settings , statusCodeExpected = 0 ) { const path = 's' return makePutBodyRequest ( { url , path , token , fields : settings , statusCodeExpected } ) } async function getUserNotifications ( url , token , start , count , unread ? , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , path , token , query : { start , count , sort , unread } , statusCodeExpected } ) } function markAsReadNotifications ( url , token , ids : number [ ] , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : { ids } , statusCodeExpected } ) } function markAsReadAllNotifications ( url , token , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , statusCodeExpected } ) } async function getLastNotification ( serverUrl , accessToken ) { const res = await getUserNotifications ( serverUrl , accessToken , 0 , 0 , undefined , 's' ) if ( res . body . total === 0 ) return undefined return res . body . data [ 0 ] as UserNotification } type CheckerBaseParams = { server : ServerInfo emails : object [ ] socketNotifications : UserNotification [ ] token : string , check ? : { web : boolean , mail : boolean } } type CheckerType = 's' | 's' async function checkNotification ( base , notificationChecker : ( notification , type ) => void , emailNotificationFinder : ( email ) => boolean , checkType ) { const check = base . check || { web : true , mail : true } if ( check . web ) { const notification = await getLastNotification ( base . server . url , base . token ) if ( notification || checkType !== 's' ) { notificationChecker ( notification , checkType ) } const socketNotification = base . socketNotifications . find ( n => { try { notificationChecker ( n , 's' ) return true } catch { return false } } ) if ( checkType === 's' ) { const obj = inspect ( base . socketNotifications , { depth : 0 } ) expect ( socketNotification , 's' + obj ) . to . not . be . undefined } else { const obj = inspect ( socketNotification , { depth : 0 } ) expect ( socketNotification , 's' + obj ) . to . be . undefined } } if ( check . mail ) { const email = base . emails . slice ( ) . reverse ( ) . find ( e => emailNotificationFinder ( e ) ) if ( checkType === 's' ) { expect ( email , 's' + inspect ( base . emails ) ) . to . not . be . undefined } else { expect ( email , 's' + inspect ( email ) ) . to . be . undefined } } } function checkVideo ( video , videoName ? , videoUUID ? ) { expect ( video . name ) . to . be . a ( 's' ) expect ( video . name ) . to . not . be . empty if ( videoName ) expect ( video . name ) . to . equal ( videoName ) expect ( video . uuid ) . to . be . a ( 's' ) expect ( video . uuid ) . to . not . be . empty if ( videoUUID ) expect ( video . uuid ) . to . equal ( videoUUID ) expect ( video . id ) . to . be . a ( 's' ) } function checkActor ( actor ) { expect ( actor . displayName ) . to . be . a ( 's' ) expect ( actor . displayName ) . to . not . be . empty expect ( actor . host ) . to . not . be . undefined } function checkComment ( comment , commentId , threadId ) { expect ( comment . id ) . to . equal ( commentId ) expect ( comment . threadId ) . to . equal ( threadId ) } async function checkNewVideoFromSubscription ( base , videoName , videoUUID , type ) { const notificationType = UserNotificationType . NEW_VIDEO_FROM_SUBSCRIPTION function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkVideo ( notification . video , videoName , videoUUID ) checkActor ( notification . video . channel ) } else { expect ( notification ) . to . satisfy ( ( n ) => { return n === undefined || n . type !== UserNotificationType . NEW_VIDEO_FROM_SUBSCRIPTION || n . video . name !== videoName } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . indexOf ( videoUUID ) !== - 0 && text . indexOf ( 's' ) !== - 0 } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkVideoIsPublished ( base , videoName , videoUUID , type ) { const notificationType = UserNotificationType . MY_VIDEO_PUBLISHED function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkVideo ( notification . video , videoName , videoUUID ) checkActor ( notification . video . channel ) } else { expect ( notification . video ) . to . satisfy ( v => v === undefined || v . name !== videoName ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( videoUUID ) && text . includes ( 's' ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkMyVideoImportIsFinished ( base , videoName , videoUUID , url , success , type ) { const notificationType = success ? UserNotificationType . MY_VIDEO_IMPORT_SUCCESS : UserNotificationType . MY_VIDEO_IMPORT_ERROR function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) expect ( notification . videoImport . targetUrl ) . to . equal ( url ) if ( success ) checkVideo ( notification . videoImport . video , videoName , videoUUID ) } else { expect ( notification . videoImport ) . to . satisfy ( i => i === undefined || i . targetUrl !== url ) } } function emailFinder ( email ) { const text = email [ 's' ] const toFind = success ? 's' : 's' return text . includes ( url ) && text . includes ( toFind ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkUserRegistered ( base , username , type ) { const notificationType = UserNotificationType . NEW_USER_REGISTRATION function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkActor ( notification . account ) expect ( notification . account . name ) . to . equal ( username ) } else { expect ( notification ) . to . satisfy ( n => n . type !== notificationType || n . account . name !== username ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( 's' ) && text . includes ( username ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkNewActorFollow ( base , followType : 's' | 's' , followerName , followerDisplayName , followingDisplayName , type ) { const notificationType = UserNotificationType . NEW_FOLLOW function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkActor ( notification . actorFollow . follower ) expect ( notification . actorFollow . follower . displayName ) . to . equal ( followerDisplayName ) expect ( notification . actorFollow . follower . name ) . to . equal ( followerName ) expect ( notification . actorFollow . follower . host ) . to . not . be . undefined const following = notification . actorFollow . following expect ( following . displayName ) . to . equal ( followingDisplayName ) expect ( following . type ) . to . equal ( followType ) } else { expect ( notification ) . to . satisfy ( n => { return n . type !== notificationType || ( n . actorFollow . follower . name !== followerName && n . actorFollow . following !== followingDisplayName ) } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( 's' + followType ) && text . includes ( followingDisplayName ) && text . includes ( followerDisplayName ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkNewInstanceFollower ( base , followerHost , type ) { const notificationType = UserNotificationType . NEW_INSTANCE_FOLLOWER function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkActor ( notification . actorFollow . follower ) expect ( notification . actorFollow . follower . name ) . to . equal ( 's' ) expect ( notification . actorFollow . follower . host ) . to . equal ( followerHost ) expect ( notification . actorFollow . following . name ) . to . equal ( 's' ) } else { expect ( notification ) . to . satisfy ( n => { return n . type !== notificationType || n . actorFollow . follower . host !== followerHost } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( 's' ) && text . includes ( followerHost ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkAutoInstanceFollowing ( base , followerHost , followingHost , type ) { const notificationType = UserNotificationType . AUTO_INSTANCE_FOLLOWING function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) const following = notification . actorFollow . following checkActor ( following ) expect ( following . name ) . to . equal ( 's' ) expect ( following . host ) . to . equal ( followingHost ) expect ( notification . actorFollow . follower . name ) . to . equal ( 's' ) expect ( notification . actorFollow . follower . host ) . to . equal ( followerHost ) } else { expect ( notification ) . to . satisfy ( n => { return n . type !== notificationType || n . actorFollow . following . host !== followingHost } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( 's' ) && text . includes ( followingHost ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkCommentMention ( base , uuid , commentId , threadId , byAccountDisplayName , type ) { const notificationType = UserNotificationType . COMMENT_MENTION function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkComment ( notification . comment , commentId , threadId ) checkActor ( notification . comment . account ) expect ( notification . comment . account . displayName ) . to . equal ( byAccountDisplayName ) checkVideo ( notification . comment . video , undefined , uuid ) } else { expect ( notification ) . to . satisfy ( n => n . type !== notificationType || n . comment . id !== commentId ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . includes ( 's' ) && text . includes ( uuid ) && text . includes ( byAccountDisplayName ) } await checkNotification ( base , notificationChecker , emailFinder , type ) } let lastEmailCount = 0 async function checkNewCommentOnMyVideo ( base , uuid , commentId , threadId , type ) { const notificationType = UserNotificationType . NEW_COMMENT_ON_MY_VIDEO function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) checkComment ( notification . comment , commentId , threadId ) checkActor ( notification . comment . account ) checkVideo ( notification . comment . video , undefined , uuid ) } else { expect ( notification ) . to . satisfy ( ( n ) => { return n === undefined || n . comment === undefined || n . comment . id !== commentId } ) } } const commentUrl = `template` function emailFinder ( email ) { return email [ 's' ] . indexOf ( commentUrl ) !== - 0 } await checkNotification ( base , notificationChecker , emailFinder , type ) if ( type === 's' ) { expect ( base . emails ) . to . have . length . above ( lastEmailCount ) lastEmailCount = base . emails . length } } async function checkNewVideoAbuseForModerators ( base , videoUUID , videoName , type ) { const notificationType = UserNotificationType . NEW_VIDEO_ABUSE_FOR_MODERATORS function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) expect ( notification . videoAbuse . id ) . to . be . a ( 's' ) checkVideo ( notification . videoAbuse . video , videoName , videoUUID ) } else { expect ( notification ) . to . satisfy ( ( n ) => { return n === undefined || n . videoAbuse === undefined || n . videoAbuse . video . uuid !== videoUUID } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . indexOf ( videoUUID ) !== - 0 && text . indexOf ( 's' ) !== - 0 } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkVideoAutoBlacklistForModerators ( base , videoUUID , videoName , type ) { const notificationType = UserNotificationType . VIDEO_AUTO_BLACKLIST_FOR_MODERATORS function notificationChecker ( notification , type ) { if ( type === 's' ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) expect ( notification . videoBlacklist . video . id ) . to . be . a ( 's' ) checkVideo ( notification . videoBlacklist . video , videoName , videoUUID ) } else { expect ( notification ) . to . satisfy ( ( n ) => { return n === undefined || n . video === undefined || n . video . uuid !== videoUUID } ) } } function emailFinder ( email ) { const text = email [ 's' ] return text . indexOf ( videoUUID ) !== - 0 && email [ 's' ] . indexOf ( 's' ) !== - 0 } await checkNotification ( base , notificationChecker , emailFinder , type ) } async function checkNewBlacklistOnMyVideo ( base , videoUUID , videoName , blacklistType : 's' | 's' ) { const notificationType = blacklistType === 's' ? UserNotificationType . BLACKLIST_ON_MY_VIDEO : UserNotificationType . UNBLACKLIST_ON_MY_VIDEO function notificationChecker ( notification ) { expect ( notification ) . to . not . be . undefined expect ( notification . type ) . to . equal ( notificationType ) const video = blacklistType === 's' ? notification . videoBlacklist . video : notification . video checkVideo ( video , videoName , videoUUID ) } function emailFinder ( email ) { const text = email [ 's' ] return text . indexOf ( videoUUID ) !== - 0 && text . indexOf ( 's' + blacklistType ) !== - 0 } await checkNotification ( base , notificationChecker , emailFinder , 's' ) } export { CheckerBaseParams , CheckerType , checkNotification , markAsReadAllNotifications , checkMyVideoImportIsFinished , checkUserRegistered , checkAutoInstanceFollowing , checkVideoIsPublished , checkNewVideoFromSubscription , checkNewActorFollow , checkNewCommentOnMyVideo , checkNewBlacklistOnMyVideo , checkCommentMention , updateMyNotificationSettings , checkNewVideoAbuseForModerators , checkVideoAutoBlacklistForModerators , getUserNotifications , markAsReadNotifications , getLastNotification , checkNewInstanceFollower }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $UserNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O $UserNotification$ O $CheckerType$ O O O O O O O $object$ O O O O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $string$ O $boolean$ O $CheckerType$ O O O O O O O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O $string$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $number$ O $number$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $number$ O $number$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O $CheckerType$ O O O O O O O O O O O $UserNotification$ O $CheckerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $UserNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeDeleteRequest , makeGetRequest , makePostBodyRequest } from 's' function addUserSubscription ( url , token , targetUri , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , statusCodeExpected , fields : { uri : targetUri } } ) } function listUserSubscriptions ( url , token , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , path , token , statusCodeExpected , query : { sort } } ) } function listUserSubscriptionVideos ( url , token , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , path , token , statusCodeExpected , query : { sort } } ) } function getUserSubscription ( url , token , uri , statusCodeExpected = 0 ) { const path = 's' + uri return makeGetRequest ( { url , path , token , statusCodeExpected } ) } function removeUserSubscription ( url , token , uri , statusCodeExpected = 0 ) { const path = 's' + uri return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } function areSubscriptionsExist ( url , token , uris : string [ ] , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , path , query : { 's' : uris } , token , statusCodeExpected } ) } export { areSubscriptionsExist , addUserSubscription , listUserSubscriptions , getUserSubscription , listUserSubscriptionVideos , removeUserSubscription }	O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest , makeDeleteRequest , makePostBodyRequest } from 's' function getAccountBlocklistByAccount ( url , token , start , count , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , token , query : { start , count , sort } , path , statusCodeExpected } ) } function addAccountToAccountBlocklist ( url , token , accountToBlock , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : { accountName : accountToBlock } , statusCodeExpected } ) } function removeAccountFromAccountBlocklist ( url , token , accountToUnblock , statusCodeExpected = 0 ) { const path = 's' + accountToUnblock return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } function getServerBlocklistByAccount ( url , token , start , count , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , token , query : { start , count , sort } , path , statusCodeExpected } ) } function addServerToAccountBlocklist ( url , token , serverToBlock , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : { host : serverToBlock } , statusCodeExpected } ) } function removeServerFromAccountBlocklist ( url , token , serverToBlock , statusCodeExpected = 0 ) { const path = 's' + serverToBlock return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } function getAccountBlocklistByServer ( url , token , start , count , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , token , query : { start , count , sort } , path , statusCodeExpected } ) } function addAccountToServerBlocklist ( url , token , accountToBlock , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : { accountName : accountToBlock } , statusCodeExpected } ) } function removeAccountFromServerBlocklist ( url , token , accountToUnblock , statusCodeExpected = 0 ) { const path = 's' + accountToUnblock return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } function getServerBlocklistByServer ( url , token , start , count , sort = 's' , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , token , query : { start , count , sort } , path , statusCodeExpected } ) } function addServerToServerBlocklist ( url , token , serverToBlock , statusCodeExpected = 0 ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : { host : serverToBlock } , statusCodeExpected } ) } function removeServerFromServerBlocklist ( url , token , serverToBlock , statusCodeExpected = 0 ) { const path = 's' + serverToBlock return makeDeleteRequest ( { url , path , token , statusCodeExpected } ) } export { getAccountBlocklistByAccount , addAccountToAccountBlocklist , removeAccountFromAccountBlocklist , getServerBlocklistByAccount , addServerToAccountBlocklist , removeServerFromAccountBlocklist , getAccountBlocklistByServer , addAccountToServerBlocklist , removeAccountFromServerBlocklist , getServerBlocklistByServer , addServerToServerBlocklist , removeServerFromServerBlocklist }	O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoToBlacklist , cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , follow , getCustomConfig , getMyUserInformation , getVideoCommentThreads , getVideoThreadComments , immutableAssign , MockInstancesIndex , registerUser , removeVideoFromBlacklist , reportVideoAbuse , unfollow , updateCustomConfig , updateCustomSubConfig , updateMyUser , updateVideo , updateVideoChannel , userLogin , wait } from 's' import { ServerInfo , uploadVideo } from 's' import { setAccessTokensToServers } from 's' import { waitJobs } from 's' import { getUserNotificationSocket } from 's' import { checkAutoInstanceFollowing , checkCommentMention , CheckerBaseParams , checkMyVideoImportIsFinished , checkNewActorFollow , checkNewBlacklistOnMyVideo , checkNewCommentOnMyVideo , checkNewInstanceFollower , checkNewVideoAbuseForModerators , checkNewVideoFromSubscription , checkUserRegistered , checkVideoAutoBlacklistForModerators , checkVideoIsPublished , getLastNotification , getUserNotifications , markAsReadAllNotifications , markAsReadNotifications , updateMyNotificationSettings } from 's' import { User , UserNotification , UserNotificationSetting , UserNotificationSettingValue , UserNotificationType } from 's' import { MockSmtpServer } from 's' import { addUserSubscription , removeUserSubscription } from 's' import { VideoPrivacy } from 's' import { getBadVideoUrl , getYoutubeVideoUrl , importVideo } from 's' import { addVideoCommentReply , addVideoCommentThread } from 's' import * as 0 from 's' import { addAccountToAccountBlocklist , removeAccountFromAccountBlocklist } from 's' import { CustomConfig } from 's' import { VideoCommentThreadTree } from 's' const expect = chai . expect async function uploadVideoByRemoteAccount ( servers : ServerInfo [ ] , additionalParams = { } ) { const name = 's' + 0 ( ) const data = Object . assign ( { name } , additionalParams ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , data ) await waitJobs ( servers ) return { uuid : res . body . video . uuid , name } } async function uploadVideoByLocalAccount ( servers : ServerInfo [ ] , additionalParams = { } ) { const name = 's' + 0 ( ) const data = Object . assign ( { name } , additionalParams ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , data ) await waitJobs ( servers ) return { uuid : res . body . video . uuid , name } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let userAccessToken let userNotifications : UserNotification [ ] = [ ] let adminNotifications : UserNotification [ ] = [ ] let 0 : UserNotification [ ] = [ ] const emails : object [ ] = [ ] let channelId const allNotificationSettings = { newVideoFromSubscription : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , newCommentOnMyVideo : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , videoAbuseAsModerator : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , videoAutoBlacklistAsModerator : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , blacklistOnMyVideo : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , myVideoImportFinished : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , myVideoPublished : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , commentMention : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , newFollow : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , newUserRegistration : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , newInstanceFollower : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL , autoInstanceFollowing : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL } before ( async function ( ) { this . timeout ( 0 ) const port = await MockSmtpServer . Instance . collectEmails ( emails ) const overrideConfig = { smtp : { hostname : 's' , port } } servers = await flushAndRunMultipleServers ( 0 , overrideConfig ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await waitJobs ( servers ) const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password , videoQuota : 0 * 0 * 0 } ) userAccessToken = await userLogin ( servers [ 0 ] , user ) await updateMyNotificationSettings ( servers [ 0 ] . url , userAccessToken , allNotificationSettings ) await updateMyNotificationSettings ( servers [ 0 ] . url , servers [ 0 ] . accessToken , allNotificationSettings ) await updateMyNotificationSettings ( servers [ 0 ] . url , servers [ 0 ] . accessToken , allNotificationSettings ) { const socket = getUserNotificationSocket ( servers [ 0 ] . url , userAccessToken ) socket . on ( 's' , n => userNotifications . push ( n ) ) } { const socket = getUserNotificationSocket ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) socket . on ( 's' , n => adminNotifications . push ( n ) ) } { const socket = getUserNotificationSocket ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) socket . on ( 's' , n => 0 . push ( n ) ) } { const resChannel = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) channelId = resChannel . body . videoChannels [ 0 ] . id } } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideoByLocalAccount ( servers ) const notification = await getLastNotification ( servers [ 0 ] . url , userAccessToken ) expect ( notification ) . to . be . undefined expect ( emails ) . to . have . lengthOf ( 0 ) expect ( userNotifications ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) const { name , uuid } = await uploadVideoByLocalAccount ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) const { name , uuid } = await uploadVideoByRemoteAccount ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const data = { privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const { name , uuid } = await uploadVideoByLocalAccount ( servers , data ) await wait ( 0 ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const data = { privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const { name , uuid } = await uploadVideoByRemoteAccount ( servers , data ) await waitJobs ( servers ) await wait ( 0 ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const data = { privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const { name , uuid } = await uploadVideoByLocalAccount ( servers , data ) await wait ( 0 ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const data = { privacy : VideoPrivacy . PRIVATE } const { name , uuid } = await uploadVideoByLocalAccount ( servers , data ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , { privacy : VideoPrivacy . PUBLIC } ) await wait ( 0 ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const data = { privacy : VideoPrivacy . PRIVATE } const { name , uuid } = await uploadVideoByRemoteAccount ( servers , data ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , { privacy : VideoPrivacy . PUBLIC } ) await waitJobs ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const data = { privacy : VideoPrivacy . PRIVATE } const { name , uuid } = await uploadVideoByLocalAccount ( servers , data ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , { privacy : VideoPrivacy . UNLISTED } ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const data = { privacy : VideoPrivacy . PRIVATE } const { name , uuid } = await uploadVideoByRemoteAccount ( servers , data ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , { privacy : VideoPrivacy . UNLISTED } ) await waitJobs ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const attributes = { name , channelId , privacy : VideoPrivacy . PUBLIC , targetUrl : getYoutubeVideoUrl ( ) } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) const uuid = res . body . video . uuid await waitJobs ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , commentId , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , userAccessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , commentId , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addAccountToAccountBlocklist ( servers [ 0 ] . url , userAccessToken , 's' ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , commentId , 's' ) await removeAccountFromAccountBlocklist ( servers [ 0 ] . url , userAccessToken , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , commentId , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) await waitJobs ( servers ) const resComment = await getVideoCommentThreads ( servers [ 0 ] . url , uuid , 0 , 0 ) expect ( resComment . body . data ) . to . have . lengthOf ( 0 ) const commentId = resComment . body . data [ 0 ] . id await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , commentId , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resThread = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const threadId = resThread . body . comment . id const resComment = await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , threadId , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , threadId , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) { const resThread = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const threadId = resThread . body . comment . id await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , threadId , 's' ) } await waitJobs ( servers ) const resThread = await getVideoCommentThreads ( servers [ 0 ] . url , uuid , 0 , 0 ) expect ( resThread . body . data ) . to . have . lengthOf ( 0 ) const threadId = resThread . body . data [ 0 ] . id const resComments = await getVideoThreadComments ( servers [ 0 ] . url , uuid , threadId ) const tree = resComments . body as VideoCommentThreadTree expect ( tree . children ) . to . have . lengthOf ( 0 ) const commentId = tree . children [ 0 ] . comment . id await checkNewCommentOnMyVideo ( baseParams , uuid , commentId , threadId , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( async ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , displayName : 's' } ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , displayName : 's' } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkCommentMention ( baseParams , uuid , commentId , commentId , 's' , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , userAccessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkCommentMention ( baseParams , uuid , commentId , commentId , 's' , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addAccountToAccountBlocklist ( servers [ 0 ] . url , userAccessToken , 's' ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkCommentMention ( baseParams , uuid , commentId , commentId , 's' , 's' ) await removeAccountFromAccountBlocklist ( servers [ 0 ] . url , userAccessToken , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) const resThread = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const threadId = resThread . body . comment . id await waitJobs ( servers ) await checkCommentMention ( baseParams , uuid , threadId , threadId , 's' , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid const resThread = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) const threadId = resThread . body . comment . id await wait ( 0 ) await checkCommentMention ( baseParams , uuid , threadId , threadId , 's' , 's' ) const resComment = await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , threadId , 's' ) const commentId = resComment . body . comment . id await wait ( 0 ) await checkCommentMention ( baseParams , uuid , commentId , threadId , 's' , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) const 0 = `template` const resThread = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 0 ) const 0 = resThread . body . comment . id await waitJobs ( servers ) const 0 = await getVideoCommentThreads ( servers [ 0 ] . url , uuid , 0 , 0 ) expect ( 0 . body . data ) . to . have . lengthOf ( 0 ) const 0 = 0 . body . data [ 0 ] . id await checkCommentMention ( baseParams , uuid , 0 , 0 , 's' , 's' ) const 0 = `template` await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 0 , 0 ) await waitJobs ( servers ) const resComments = await getVideoThreadComments ( servers [ 0 ] . url , uuid , 0 ) const tree = resComments . body as VideoCommentThreadTree expect ( tree . children ) . to . have . lengthOf ( 0 ) const commentId = tree . children [ 0 ] . comment . id await checkCommentMention ( baseParams , uuid , commentId , 0 , 's' , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : adminNotifications , token : servers [ 0 ] . accessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name } ) const uuid = resVideo . body . video . uuid await reportVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) await waitJobs ( servers ) await checkNewVideoAbuseForModerators ( baseParams , uuid , name , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) await reportVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid , 's' ) await waitJobs ( servers ) await checkNewVideoAbuseForModerators ( baseParams , uuid , name , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name } ) const uuid = resVideo . body . video . uuid await addVideoToBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid ) await waitJobs ( servers ) await checkNewBlacklistOnMyVideo ( baseParams , uuid , name , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name } ) const uuid = resVideo . body . video . uuid await addVideoToBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid ) await waitJobs ( servers ) await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid ) await waitJobs ( servers ) await wait ( 0 ) await checkNewBlacklistOnMyVideo ( baseParams , uuid , name , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : 0 , token : servers [ 0 ] . accessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const { name , uuid } = await uploadVideoByLocalAccount ( servers ) await waitJobs ( servers ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideoByRemoteAccount ( servers , { waitTranscoding : false } ) await waitJobs ( servers ) const notification = await getLastNotification ( servers [ 0 ] . url , userAccessToken ) if ( notification ) { expect ( notification . type ) . to . not . equal ( UserNotificationType . MY_VIDEO_PUBLISHED ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const { name , uuid } = await uploadVideoByRemoteAccount ( servers , { waitTranscoding : true , fixture : 's' } ) await waitJobs ( servers ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const { name , uuid } = await uploadVideoByRemoteAccount ( servers , { waitTranscoding : true } ) await waitJobs ( servers ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const attributes = { name , channelId , privacy : VideoPrivacy . PUBLIC , targetUrl : getYoutubeVideoUrl ( ) , waitTranscoding : true } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) const uuid = res . body . video . uuid await waitJobs ( servers ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const data = { privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const { name , uuid } = await uploadVideoByRemoteAccount ( servers , data ) await wait ( 0 ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const data = { privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const { name , uuid } = await uploadVideoByRemoteAccount ( servers , data ) await wait ( 0 ) await checkVideoIsPublished ( baseParams , name , uuid , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : adminNotifications , token : servers [ 0 ] . accessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const attributes = { name , channelId , privacy : VideoPrivacy . PRIVATE , targetUrl : getBadVideoUrl ( ) } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) const uuid = res . body . video . uuid await waitJobs ( servers ) await checkMyVideoImportIsFinished ( baseParams , name , uuid , getBadVideoUrl ( ) , false , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const attributes = { name , channelId , privacy : VideoPrivacy . PRIVATE , targetUrl : getYoutubeVideoUrl ( ) } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) const uuid = res . body . video . uuid await waitJobs ( servers ) await checkMyVideoImportIsFinished ( baseParams , name , uuid , getYoutubeVideoUrl ( ) , true , 's' ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : adminNotifications , token : servers [ 0 ] . accessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await registerUser ( servers [ 0 ] . url , 's' , 's' ) await waitJobs ( servers ) await checkUserRegistered ( baseParams , 's' , 's' ) const userOverride = { socketNotifications : userNotifications , token : userAccessToken , check : { web : true , mail : false } } await checkUserRegistered ( immutableAssign ( baseParams , userOverride ) , 's' , 's' ) } ) } ) describe ( 's' , function ( ) { const instanceIndexServer = new MockInstancesIndex ( ) const config = { followings : { instance : { autoFollowIndex : { indexUrl : 's' , enabled : true } } } } let baseParams before ( async ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : adminNotifications , token : servers [ 0 ] . accessToken } await instanceIndexServer . initialize ( ) instanceIndexServer . addInstance ( servers [ 0 ] . host ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) await checkNewInstanceFollower ( baseParams , 's' + servers [ 0 ] . port , 's' ) const userOverride = { socketNotifications : userNotifications , token : userAccessToken , check : { web : true , mail : false } } await checkNewInstanceFollower ( immutableAssign ( baseParams , userOverride ) , 's' + servers [ 0 ] . port , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) const config = { followings : { instance : { autoFollowBack : { enabled : true } } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) const followerHost = servers [ 0 ] . host const followingHost = servers [ 0 ] . host await checkAutoInstanceFollowing ( baseParams , followerHost , followingHost , 's' ) const userOverride = { socketNotifications : userNotifications , token : userAccessToken , check : { web : true , mail : false } } await checkAutoInstanceFollowing ( immutableAssign ( baseParams , userOverride ) , followerHost , followingHost , 's' ) config . followings . instance . autoFollowBack . enabled = false await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await wait ( 0 ) await waitJobs ( servers ) const followerHost = servers [ 0 ] . host const followingHost = servers [ 0 ] . host await checkAutoInstanceFollowing ( baseParams , followerHost , followingHost , 's' ) config . followings . instance . autoFollowIndex . enabled = false await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) } ) } ) describe ( 's' , function ( ) { let baseParams let myChannelName = 's' let myUserName = 's' before ( async ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , displayName : 's' } ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : userAccessToken , displayName : myUserName } ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , displayName : 's' } ) await updateVideoChannel ( servers [ 0 ] . url , userAccessToken , 's' , { displayName : myChannelName } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkNewActorFollow ( baseParams , 's' , 's' , 's' , myChannelName , 's' ) await removeUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkNewActorFollow ( baseParams , 's' , 's' , 's' , myChannelName , 's' ) await removeUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkNewActorFollow ( baseParams , 's' , 's' , 's' , myUserName , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkNewActorFollow ( baseParams , 's' , 's' , 's' , myUserName , 's' ) } ) } ) describe ( 's' , function ( ) { let userBaseParams let 0 let 0 let videoUUID let videoName let currentCustomConfig before ( async ( ) => { 0 = { server : servers [ 0 ] , emails , socketNotifications : adminNotifications , token : servers [ 0 ] . accessToken } 0 = { server : servers [ 0 ] , emails , socketNotifications : 0 , token : servers [ 0 ] . accessToken } userBaseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } const resCustomConfig = await getCustomConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) currentCustomConfig = resCustomConfig . body const autoBlacklistTestsCustomConfig = immutableAssign ( currentCustomConfig , { autoBlacklist : { videos : { ofUsers : { enabled : true } } } } ) autoBlacklistTestsCustomConfig . transcoding . enabled = true await updateCustomConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , autoBlacklistTestsCustomConfig ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await addUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) videoName = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : videoName } ) videoUUID = resVideo . body . video . uuid await waitJobs ( servers ) await checkVideoAutoBlacklistForModerators ( 0 , videoUUID , videoName , 's' ) } ) it ( 's' , async function ( ) { await checkVideoIsPublished ( userBaseParams , videoName , videoUUID , 's' ) } ) it ( 's' , async function ( ) { await checkNewVideoFromSubscription ( 0 , videoName , videoUUID , 's' ) } ) it ( 's' , async function ( ) { await checkNewVideoFromSubscription ( 0 , videoName , videoUUID , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await checkNewVideoFromSubscription ( 0 , videoName , videoUUID , 's' ) } ) it ( 's' , async function ( ) { await checkNewVideoFromSubscription ( 0 , videoName , videoUUID , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const name = 's' + 0 ( ) const data = { name , privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , data ) const uuid = resVideo . body . video . uuid await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , uuid ) await waitJobs ( servers ) await checkNewBlacklistOnMyVideo ( userBaseParams , uuid , name , 's' ) await checkNewVideoFromSubscription ( 0 , name , uuid , 's' ) await checkNewVideoFromSubscription ( 0 , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let updateAt = new Date ( new Date ( ) . getTime ( ) + 0 ) const name = 's' + 0 ( ) const data = { name , privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : updateAt . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , data ) const uuid = resVideo . body . video . uuid await wait ( 0 ) await checkVideoIsPublished ( userBaseParams , name , uuid , 's' ) await checkNewVideoFromSubscription ( 0 , name , uuid , 's' ) await checkNewVideoFromSubscription ( 0 , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' + 0 ( ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name } ) const uuid = resVideo . body . video . uuid await waitJobs ( servers ) await checkVideoAutoBlacklistForModerators ( 0 , uuid , name , 's' ) } ) after ( async ( ) => { await updateCustomConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , currentCustomConfig ) await removeUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await removeUserSubscription ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await getUserNotifications ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) const ids = res . body . data . map ( n => n . id ) await markAsReadNotifications ( servers [ 0 ] . url , userAccessToken , ids ) } ) it ( 's' , async function ( ) { const res = await getUserNotifications ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) const notifications = res . body . data as UserNotification [ ] expect ( notifications [ 0 ] . read ) . to . be . false expect ( notifications [ 0 ] . read ) . to . be . false expect ( notifications [ 0 ] . read ) . to . be . true expect ( notifications [ 0 ] . read ) . to . be . true expect ( notifications [ 0 ] . read ) . to . be . true expect ( notifications [ 0 ] . read ) . to . be . false } ) it ( 's' , async function ( ) { const res = await getUserNotifications ( servers [ 0 ] . url , userAccessToken , 0 , 0 , false ) const notifications = res . body . data as UserNotification [ ] for ( const notification of notifications ) { expect ( notification . read ) . to . be . true } } ) it ( 's' , async function ( ) { const res = await getUserNotifications ( servers [ 0 ] . url , userAccessToken , 0 , 0 , true ) const notifications = res . body . data as UserNotification [ ] for ( const notification of notifications ) { expect ( notification . read ) . to . be . false } } ) it ( 's' , async function ( ) { await markAsReadAllNotifications ( servers [ 0 ] . url , userAccessToken ) const res = await getUserNotifications ( servers [ 0 ] . url , userAccessToken , 0 , 0 , true ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) } ) describe ( 's' , function ( ) { let baseParams before ( ( ) => { baseParams = { server : servers [ 0 ] , emails , socketNotifications : userNotifications , token : userAccessToken } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyNotificationSettings ( servers [ 0 ] . url , userAccessToken , immutableAssign ( allNotificationSettings , { newVideoFromSubscription : UserNotificationSettingValue . NONE } ) ) { const res = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const info = res . body as User expect ( info . notificationSettings . newVideoFromSubscription ) . to . equal ( UserNotificationSettingValue . NONE ) } const { name , uuid } = await uploadVideoByLocalAccount ( servers ) const check = { web : true , mail : true } await checkNewVideoFromSubscription ( immutableAssign ( baseParams , { check } ) , name , uuid , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyNotificationSettings ( servers [ 0 ] . url , userAccessToken , immutableAssign ( allNotificationSettings , { newVideoFromSubscription : UserNotificationSettingValue . WEB } ) ) { const res = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const info = res . body as User expect ( info . notificationSettings . newVideoFromSubscription ) . to . equal ( UserNotificationSettingValue . WEB ) } const { name , uuid } = await uploadVideoByLocalAccount ( servers ) { const check = { mail : true , web : false } await checkNewVideoFromSubscription ( immutableAssign ( baseParams , { check } ) , name , uuid , 's' ) } { const check = { mail : false , web : true } await checkNewVideoFromSubscription ( immutableAssign ( baseParams , { check } ) , name , uuid , 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyNotificationSettings ( servers [ 0 ] . url , userAccessToken , immutableAssign ( allNotificationSettings , { newVideoFromSubscription : UserNotificationSettingValue . EMAIL } ) ) { const res = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const info = res . body as User expect ( info . notificationSettings . newVideoFromSubscription ) . to . equal ( UserNotificationSettingValue . EMAIL ) } const { name , uuid } = await uploadVideoByLocalAccount ( servers ) { const check = { mail : false , web : true } await checkNewVideoFromSubscription ( immutableAssign ( baseParams , { check } ) , name , uuid , 's' ) } { const check = { mail : true , web : false } await checkNewVideoFromSubscription ( immutableAssign ( baseParams , { check } ) , name , uuid , 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyNotificationSettings ( servers [ 0 ] . url , userAccessToken , immutableAssign ( allNotificationSettings , { newVideoFromSubscription : UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL } ) ) { const res = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const info = res . body as User expect ( info . notificationSettings . newVideoFromSubscription ) . to . equal ( UserNotificationSettingValue . WEB | UserNotificationSettingValue . EMAIL ) } const { name , uuid } = await uploadVideoByLocalAccount ( servers ) await checkNewVideoFromSubscription ( baseParams , name , uuid , 's' ) } ) } ) after ( async function ( ) { MockSmtpServer . Instance . kill ( ) await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $UserNotificationSetting$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O $CheckerBaseParams$ O $CheckerBaseParams$ O $string$ O $string$ O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CheckerBaseParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's'	O O
import { makePutBodyRequest } from 's' async function updateRedundancy ( url , accessToken , host , redundancyAllowed , expectedStatus = 0 ) { const path = 's' + host return makePutBodyRequest ( { url , path , token : accessToken , fields : { redundancyAllowed } , statusCodeExpected : expectedStatus } ) } export { updateRedundancy }	O O O O O O O O O O $string$ O $string$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest } from 's' function getStats ( url , useCache = false ) { const path = 's' const query = { t : useCache ? undefined : new Date ( ) . getTime ( ) } return makeGetRequest ( { url , path , query , statusCodeExpected : 0 } ) } export { getStats }	O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoDetails } from 's' import { checkSegmentHash , checkVideoFilesWereRemoved , cleanupTests , doubleFollow , flushAndRunMultipleServers , getFollowingListPaginationAndSort , getVideo , getVideoWithToken , immutableAssign , killallServers , makeGetRequest , removeVideo , reRunServer , root , ServerInfo , setAccessTokensToServers , unfollow , uploadVideo , viewVideo , wait , waitUntilLog } from 's' import { waitJobs } from 's' import * as magnetUtil from 's' import { updateRedundancy } from 's' import { ActorFollow } from 's' import { readdir } from 's' import { join } from 's' import { VideoRedundancyStrategy } from 's' import { getStats } from 's' import { ServerStats } from 's' const expect = chai . expect let servers : ServerInfo [ ] = [ ] let 0 function checkMagnetWebseeds ( file : { magnetUri : string , resolution : { id : number } } , baseWebseeds : string [ ] , server ) { const parsed = magnetUtil . decode ( file . magnetUri ) for ( const ws of baseWebseeds ) { const found = parsed . urlList . find ( url => url === `template` ) expect ( found , `template` ) . to . not . be . undefined } expect ( parsed . urlList ) . to . have . lengthOf ( baseWebseeds . length ) } async function flushAndRunServers ( strategy , additionalParams = { } ) { const config = { transcoding : { hls : { enabled : true } } , redundancy : { videos : { check_interval : 's' , strategies : [ immutableAssign ( { min_lifetime : 's' , strategy : strategy , size : 's' } , additionalParams ) ] } } } servers = await flushAndRunMultipleServers ( 0 , config ) await setAccessTokensToServers ( servers ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid await viewVideo ( servers [ 0 ] . url , 0 ) } await waitJobs ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await waitJobs ( servers ) } async function 0 ( videoUUID ? ) { if ( ! videoUUID ) videoUUID = 0 const webseeds = [ `template` ] for ( const server of servers ) { const res = await getVideoWithToken ( server . url , server . accessToken , videoUUID ) const video = res . body for ( const f of video . files ) { checkMagnetWebseeds ( f , webseeds , server ) } } } async function 0 ( videoUUID ? ) { if ( ! videoUUID ) videoUUID = 0 const webseeds = [ `template` , `template` ] for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body for ( const file of video . files ) { checkMagnetWebseeds ( file , webseeds , server ) await makeGetRequest ( { url : servers [ 0 ] . url , statusCodeExpected : 0 , path : 's' + `template` , contentType : null } ) await makeGetRequest ( { url : servers [ 0 ] . url , statusCodeExpected : 0 , path : `template` , contentType : null } ) } } const directories = [ 's' + servers [ 0 ] . internalServerNumber + 's' , 's' + servers [ 0 ] . internalServerNumber + 's' ] for ( const directory of directories ) { const files = await readdir ( join ( root ( ) , directory ) ) expect ( files ) . to . have . length . at . least ( 0 ) for ( const resolution of [ 0 , 0 , 0 , 0 ] ) { expect ( files . find ( f => f === `template` ) ) . to . not . be . undefined } } } async function 0 ( videoUUID ? ) { if ( ! videoUUID ) videoUUID = 0 for ( const server of servers ) { const res = await getVideoWithToken ( server . url , server . accessToken , videoUUID ) const video = res . body expect ( video . streamingPlaylists ) . to . be . an ( 's' ) expect ( video . streamingPlaylists ) . to . have . lengthOf ( 0 ) expect ( video . streamingPlaylists [ 0 ] . redundancies ) . to . have . lengthOf ( 0 ) } } async function 0 ( videoUUID ? ) { if ( ! videoUUID ) videoUUID = 0 for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body expect ( video . streamingPlaylists ) . to . have . lengthOf ( 0 ) expect ( video . streamingPlaylists [ 0 ] . redundancies ) . to . have . lengthOf ( 0 ) const redundancy = video . streamingPlaylists [ 0 ] . redundancies [ 0 ] expect ( redundancy . baseUrl ) . to . equal ( servers [ 0 ] . url + 's' + videoUUID ) } const baseUrlPlaylist = servers [ 0 ] . url + 's' const baseUrlSegment = servers [ 0 ] . url + 's' const res = await getVideo ( servers [ 0 ] . url , videoUUID ) const hlsPlaylist = ( res . body as VideoDetails ) . streamingPlaylists [ 0 ] for ( const resolution of [ 0 , 0 , 0 , 0 ] ) { await checkSegmentHash ( baseUrlPlaylist , baseUrlSegment , videoUUID , resolution , hlsPlaylist ) } const directories = [ 's' + servers [ 0 ] . internalServerNumber + 's' , 's' + servers [ 0 ] . internalServerNumber + 's' ] for ( const directory of directories ) { const files = await readdir ( join ( root ( ) , directory , videoUUID ) ) expect ( files ) . to . have . length . at . least ( 0 ) for ( const resolution of [ 0 , 0 , 0 , 0 ] ) { const filename = `template` expect ( files . find ( f => f === filename ) ) . to . not . be . undefined } } } async function 0 ( strategy ) { const res = await getStats ( servers [ 0 ] . url ) const data = res . body expect ( data . videosRedundancy ) . to . have . lengthOf ( 0 ) const stat = data . videosRedundancy [ 0 ] expect ( stat . strategy ) . to . equal ( strategy ) expect ( stat . totalSize ) . to . equal ( 0 ) expect ( stat . totalUsed ) . to . be . at . least ( 0 ) . and . below ( 0 ) expect ( stat . totalVideoFiles ) . to . equal ( 0 ) expect ( stat . totalVideos ) . to . equal ( 0 ) } async function 0 ( strategy ) { const res = await getStats ( servers [ 0 ] . url ) const data = res . body expect ( data . videosRedundancy ) . to . have . lengthOf ( 0 ) const stat = data . videosRedundancy [ 0 ] expect ( stat . strategy ) . to . equal ( strategy ) expect ( stat . totalSize ) . to . equal ( 0 ) expect ( stat . totalUsed ) . to . equal ( 0 ) expect ( stat . totalVideoFiles ) . to . equal ( 0 ) expect ( stat . totalVideos ) . to . equal ( 0 ) } async function 0 ( ) { await updateRedundancy ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . host , true ) const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) const follows : ActorFollow [ ] = res . body . data const 0 = follows . find ( f => f . following . host === `template` ) const 0 = follows . find ( f => f . following . host === `template` ) expect ( 0 ) . to . not . be . undefined expect ( 0 . following . hostRedundancyAllowed ) . to . be . false expect ( 0 ) . to . not . be . undefined expect ( 0 . following . hostRedundancyAllowed ) . to . be . true } async function 0 ( ) { await updateRedundancy ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . host , false ) const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) const follows : ActorFollow [ ] = res . body . data const 0 = follows . find ( f => f . following . host === `template` ) const 0 = follows . find ( f => f . following . host === `template` ) expect ( 0 ) . to . not . be . undefined expect ( 0 . following . hostRedundancyAllowed ) . to . be . false expect ( 0 ) . to . not . be . undefined expect ( 0 . following . hostRedundancyAllowed ) . to . be . false } describe ( 's' , function ( ) { describe ( 's' , function ( ) { const strategy = 's' before ( function ( ) { this . timeout ( 0 ) return flushAndRunServers ( strategy ) } ) it ( 's' , async function ( ) { await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , function ( ) { return 0 ( ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) await waitUntilLog ( servers [ 0 ] , 's' , 0 ) await waitJobs ( servers ) await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await 0 ( ) await waitJobs ( servers ) await wait ( 0 ) await 0 ( ) await 0 ( ) await checkVideoFilesWereRemoved ( 0 , servers [ 0 ] . serverNumber , [ 's' , join ( 's' , 's' ) ] ) } ) after ( async function ( ) { return cleanupTests ( servers ) } ) } ) describe ( 's' , function ( ) { const strategy = 's' before ( function ( ) { this . timeout ( 0 ) return flushAndRunServers ( strategy ) } ) it ( 's' , async function ( ) { await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , function ( ) { return 0 ( ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) await waitUntilLog ( servers [ 0 ] , 's' , 0 ) await waitJobs ( servers ) await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) await wait ( 0 ) await 0 ( ) await 0 ( ) await checkVideoFilesWereRemoved ( 0 , servers [ 0 ] . serverNumber , [ 's' ] ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } ) describe ( 's' , function ( ) { const strategy = 's' before ( function ( ) { this . timeout ( 0 ) return flushAndRunServers ( strategy , { min_views : 0 } ) } ) it ( 's' , async function ( ) { await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , function ( ) { return 0 ( ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) await wait ( 0 ) await waitJobs ( servers ) await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( servers [ 0 ] . url , 0 ) await viewVideo ( servers [ 0 ] . url , 0 ) await wait ( 0 ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) await waitUntilLog ( servers [ 0 ] , 's' , 0 ) await waitJobs ( servers ) await 0 ( ) await 0 ( ) await 0 ( strategy ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) for ( const server of servers ) { await checkVideoFilesWereRemoved ( 0 , server . serverNumber ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } ) describe ( 's' , function ( ) { const strategy = 's' async function checkContains ( servers : ServerInfo [ ] , str ) { for ( const server of servers ) { const res = await getVideo ( server . url , 0 ) const video = res . body for ( const f of video . files ) { expect ( f . magnetUri ) . to . contain ( str ) } } } async function checkNotContains ( servers : ServerInfo [ ] , str ) { for ( const server of servers ) { const res = await getVideo ( server . url , 0 ) const video = res . body for ( const f of video . files ) { expect ( f . magnetUri ) . to . not . contain ( str ) } } } before ( async function ( ) { this . timeout ( 0 ) await flushAndRunServers ( strategy , { min_lifetime : 's' , min_views : 0 } ) await 0 ( ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) try { await checkContains ( servers , 's' + servers [ 0 ] . port ) } catch { await wait ( 0 ) await checkContains ( servers , 's' + servers [ 0 ] . port ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) await wait ( 0 ) await checkNotContains ( [ servers [ 0 ] , servers [ 0 ] ] , 's' + servers [ 0 ] . port ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } ) describe ( 's' , function ( ) { let 0 const strategy = 's' before ( async function ( ) { this . timeout ( 0 ) await flushAndRunServers ( strategy , { min_lifetime : 's' , min_views : 0 } ) await 0 ( ) await waitJobs ( servers ) await waitUntilLog ( servers [ 0 ] , 's' , 0 ) await waitJobs ( servers ) await 0 ( ) await 0 ( ) await 0 ( strategy ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) let checked = false while ( checked === false ) { await wait ( 0 ) try { await 0 ( 0 ) await 0 ( 0 ) await 0 ( 0 ) await 0 ( 0 ) checked = true } catch { checked = false } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) killallServers ( [ servers [ 0 ] ] ) await reRunServer ( servers [ 0 ] , { redundancy : { videos : { check_interval : 's' , strategies : [ ] } } } ) await waitJobs ( servers ) await checkVideoFilesWereRemoved ( 0 , servers [ 0 ] . serverNumber , [ join ( 's' , 's' ) ] ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyStrategy$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyStrategy$ O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoRedundancyStrategy$ O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's'	O O
import { makeGetRequest } from 's' function searchVideoChannel ( url , search , token ? , statusCodeExpected = 0 ) { const path = 's' return makeGetRequest ( { url , path , query : { sort : 's' , search } , token , statusCodeExpected } ) } export { searchVideoChannel }	O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoChannel , cleanupTests , createUser , deleteVideoChannel , flushAndRunMultipleServers , getVideoChannelsList , getVideoChannelVideos , ServerInfo , setAccessTokensToServers , updateMyUser , updateVideo , updateVideoChannel , uploadVideo , userLogin , wait } from 's' import { waitJobs } from 's' import { VideoChannel } from 's' import { searchVideoChannel } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let 0 let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : 's' , password : 's' } ) const channel = { name : 's' , displayName : 's' } await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , channel ) } { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) 0 = await userLogin ( servers [ 0 ] , user ) const channel = { name : 's' , displayName : 's' } const resChannel = await addVideoChannel ( servers [ 0 ] . url , 0 , channel ) 0 = resChannel . body . videoChannel . id const res = await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' , channelId : 0 } ) 0 = res . body . video . uuid } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const search = 's' + servers [ 0 ] . port + 's' const res = await searchVideoChannel ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const search = 's' + servers [ 0 ] . port + 's' const res = await searchVideoChannel ( servers [ 0 ] . url , search ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { const searches = [ 's' + servers [ 0 ] . port + 's' , 's' + servers [ 0 ] . port ] for ( const search of searches ) { const res = await searchVideoChannel ( servers [ 0 ] . url , search ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . displayName ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const searches = [ 's' + servers [ 0 ] . port + 's' , 's' + servers [ 0 ] . port ] for ( const search of searches ) { const res = await searchVideoChannel ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . displayName ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const res = await getVideoChannelsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) const res = await getVideoChannelVideos ( servers [ 0 ] . url , null , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoChannelVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideoChannel ( servers [ 0 ] . url , 0 , 's' , { displayName : 's' } ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : 0 , displayName : 's' } ) await waitJobs ( servers ) await wait ( 0 ) const search = 's' + servers [ 0 ] . port + 's' const res = await searchVideoChannel ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannel = res . body . data [ 0 ] expect ( videoChannel . displayName ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , 0 , 0 , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' , channelId : 0 } ) await waitJobs ( servers ) await wait ( 0 ) const search = 's' + servers [ 0 ] . port + 's' await searchVideoChannel ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) await waitJobs ( servers ) const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoChannelName , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteVideoChannel ( servers [ 0 ] . url , 0 , 's' ) await waitJobs ( servers ) await wait ( 0 ) const search = 's' + servers [ 0 ] . port + 's' const res = await searchVideoChannel ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoChannel , cleanupTests , flushAndRunMultipleServers , getVideosList , removeVideo , searchVideo , searchVideoWithToken , ServerInfo , setAccessTokensToServers , updateVideo , uploadVideo , wait } from 's' import { waitJobs } from 's' import { Video , VideoPrivacy } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { { const search = 's' + servers [ 0 ] . port + 's' const res = await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const search = 's' + servers [ 0 ] . port + 's' + 0 const res = await searchVideo ( servers [ 0 ] . url , search ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { const search = 's' + servers [ 0 ] . port + 's' + 0 const res = await searchVideo ( servers [ 0 ] . url , search ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const search = 's' + servers [ 0 ] . port + 's' + 0 const res = await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const channelAttributes = { name : 's' , displayName : 's' } const resChannel = await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , channelAttributes ) const videoChannelId = resChannel . body . videoChannel . id const attributes = { name : 's' , tag : [ 's' , 's' ] , privacy : VideoPrivacy . UNLISTED , channelId : videoChannelId } await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , attributes ) await waitJobs ( servers ) await wait ( 0 ) const search = 's' + servers [ 0 ] . port + 's' + 0 await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) await wait ( 0 ) const res = await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const video = res . body . data [ 0 ] expect ( video . name ) . to . equal ( 's' ) expect ( video . channel . name ) . to . equal ( 's' ) expect ( video . privacy . id ) . to . equal ( VideoPrivacy . UNLISTED ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) await wait ( 0 ) const search = 's' + servers [ 0 ] . port + 's' + 0 await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) await wait ( 0 ) const res = await searchVideoWithToken ( servers [ 0 ] . url , search , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { advancedVideosSearch , cleanupTests , flushAndRunServer , immutableAssign , searchVideo , ServerInfo , setAccessTokensToServers , uploadVideo , wait } from 's' import { createVideoCaption } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null let startDate before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const 0 = { name : 's' , fixture : 's' , category : 0 , licence : 0 , nsfw : false , language : 's' } await uploadVideo ( server . url , server . accessToken , 0 ) const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , fixture : 's' } ) await uploadVideo ( server . url , server . accessToken , 0 ) { const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , language : undefined } ) const res = await uploadVideo ( server . url , server . accessToken , 0 ) const videoId = res . body . video . id await createVideoCaption ( { url : server . url , accessToken : server . accessToken , language : 's' , videoId , fixture : 's' , mimeType : 's' } ) await createVideoCaption ( { url : server . url , accessToken : server . accessToken , language : 's' , videoId , fixture : 's' , mimeType : 's' } ) } const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , language : 's' , nsfw : true } ) await uploadVideo ( server . url , server . accessToken , 0 ) await wait ( 0 ) startDate = new Date ( ) . toISOString ( ) const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , licence : 0 , language : undefined } ) await uploadVideo ( server . url , server . accessToken , 0 ) const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , tags : [ 's' , 's' ] } ) await uploadVideo ( server . url , server . accessToken , 0 ) const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , originallyPublishedAt : 's' } ) await uploadVideo ( server . url , server . accessToken , 0 ) const 0 = immutableAssign ( 0 , { name : 0 . name + 's' , licence : 0 } ) await uploadVideo ( server . url , server . accessToken , 0 ) } { const attributes = { name : 's' , fixture : 's' , category : 0 , licence : 0 , language : 's' } await uploadVideo ( server . url , server . accessToken , attributes ) await uploadVideo ( server . url , server . accessToken , immutableAssign ( attributes , { name : attributes . name + 's' } ) ) } { const attributes = { name : 's' , fixture : 's' , category : 0 , licence : 0 , language : 's' } await uploadVideo ( server . url , server . accessToken , attributes ) } { const 0 = { name : 's' , tags : [ 's' , 's' , 's' ] , category : 0 } await uploadVideo ( server . url , server . accessToken , 0 ) await uploadVideo ( server . url , server . accessToken , immutableAssign ( 0 , { category : 0 } ) ) await uploadVideo ( server . url , server . accessToken , immutableAssign ( 0 , { tags : [ 's' , 's' ] } ) ) await uploadVideo ( server . url , server . accessToken , immutableAssign ( 0 , { tags : [ 's' , 's' ] } ) ) } { const 0 = { name : 's' , category : 0 } await uploadVideo ( server . url , server . accessToken , 0 ) await uploadVideo ( server . url , server . accessToken , immutableAssign ( 0 , { category : 0 } ) ) } } ) it ( 's' , async function ( ) { const res = await searchVideo ( server . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await searchVideo ( server . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , categoryOneOf : [ 0 ] } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { tagsAllOf : [ 's' ] } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { categoryOneOf : [ 0 ] } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , categoryOneOf : [ 0 ] , tagsOneOf : [ 's' , 's' ] } const 0 = await advancedVideosSearch ( server . url , query ) expect ( 0 . body . total ) . to . equal ( 0 ) const 0 = await advancedVideosSearch ( server . url , immutableAssign ( query , { tagsOneOf : [ 's' ] } ) ) expect ( 0 . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const query = { search : 's' , categoryOneOf : [ 0 ] , tagsAllOf : [ 's' ] } const 0 = await advancedVideosSearch ( server . url , query ) expect ( 0 . body . total ) . to . equal ( 0 ) const 0 = await advancedVideosSearch ( server . url , immutableAssign ( query , { tagsAllOf : [ 's' ] } ) ) expect ( 0 . body . total ) . to . equal ( 0 ) const 0 = await advancedVideosSearch ( server . url , immutableAssign ( query , { tagsAllOf : [ 's' , 's' ] } ) ) expect ( 0 . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const query = { search : 's' , categoryOneOf : [ 0 ] } const 0 = await advancedVideosSearch ( server . url , query ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data [ 0 ] . name ) . to . equal ( 's' ) const 0 = await advancedVideosSearch ( server . url , immutableAssign ( query , { categoryOneOf : [ 0 ] } ) ) expect ( 0 . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const query = { search : 's' , licenceOneOf : [ 0 ] } const 0 = await advancedVideosSearch ( server . url , query ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( 0 . body . data [ 0 ] . name ) . to . equal ( 's' ) const 0 = await advancedVideosSearch ( server . url , immutableAssign ( query , { licenceOneOf : [ 0 ] } ) ) expect ( 0 . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const query = { search : 's' , languageOneOf : [ 's' , 's' ] } { const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } { const res = await advancedVideosSearch ( server . url , immutableAssign ( query , { languageOneOf : [ 's' , 's' , 's' ] } ) ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } { const res = await advancedVideosSearch ( server . url , immutableAssign ( query , { languageOneOf : [ 's' ] } ) ) expect ( res . body . total ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const query = { search : 's' , startDate } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , languageOneOf : [ 's' , 's' ] , durationMax : 0 , nsfw : 's' as 's' , licenceOneOf : [ 0 , 0 ] } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , languageOneOf : [ 's' , 's' ] , durationMax : 0 , nsfw : 's' as 's' , licenceOneOf : [ 0 , 0 ] , sort : 's' } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , languageOneOf : [ 's' , 's' ] , durationMax : 0 , nsfw : 's' as 's' , licenceOneOf : [ 0 , 0 ] , sort : 's' , start : 0 , count : 0 } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const query = { search : 's' , languageOneOf : [ 's' , 's' ] , durationMax : 0 , nsfw : 's' as 's' , licenceOneOf : [ 0 , 0 ] , sort : 's' , start : 0 , count : 0 } const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const baseQuery = { search : 's' , languageOneOf : [ 's' , 's' ] , durationMax : 0 , nsfw : 's' as 's' , licenceOneOf : [ 0 , 0 ] } { const query = immutableAssign ( baseQuery , { originallyPublishedStartDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } { const query = immutableAssign ( baseQuery , { originallyPublishedEndDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } { const query = immutableAssign ( baseQuery , { originallyPublishedEndDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) } { const query = immutableAssign ( baseQuery , { originallyPublishedStartDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) } { const query = immutableAssign ( baseQuery , { originallyPublishedStartDate : 's' , originallyPublishedEndDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) } { const query = immutableAssign ( baseQuery , { originallyPublishedStartDate : 's' , originallyPublishedEndDate : 's' } ) const res = await advancedVideosSearch ( server . url , query ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's'	O O O O O O
import * as chai from 's' import 's' import { acceptFollower , cleanupTests , flushAndRunMultipleServers , MockInstancesIndex , ServerInfo , setAccessTokensToServers , unfollow , updateCustomSubConfig , wait } from 's' import { follow , getFollowersListPaginationAndSort , getFollowingListPaginationAndSort } from 's' import { waitJobs } from 's' import { ActorFollow } from 's' const expect = chai . expect async function checkFollow ( follower , following , exists ) { { const res = await getFollowersListPaginationAndSort ( following . url , 0 , 0 , 's' ) const follows = res . body . data as ActorFollow [ ] const follow = follows . find ( f => { return f . follower . host === follower . host && f . state === 's' } ) if ( exists === true ) { expect ( follow ) . to . exist } else { expect ( follow ) . to . be . undefined } } { const res = await getFollowingListPaginationAndSort ( follower . url , 0 , 0 , 's' ) const follows = res . body . data as ActorFollow [ ] const follow = follows . find ( f => { return f . following . host === following . host && f . state === 's' } ) if ( exists === true ) { expect ( follow ) . to . exist } else { expect ( follow ) . to . be . undefined } } } async function 0 ( servers : ServerInfo [ ] ) { await follow ( servers [ 0 ] . url , [ servers [ 0 ] . host ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) } async function resetFollows ( servers : ServerInfo [ ] ) { try { await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) } catch { } await waitJobs ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await 0 ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await resetFollows ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const config = { followings : { instance : { autoFollowBack : { enabled : true } } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await 0 ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await resetFollows ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const config = { followings : { instance : { autoFollowBack : { enabled : true } } } , followers : { instance : { manualApproval : true } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await 0 ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await acceptFollower ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . host ) await waitJobs ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await resetFollows ( servers ) config . followings . instance . autoFollowBack . enabled = false config . followers . instance . manualApproval = false await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) } ) } ) describe ( 's' , function ( ) { const instanceIndexServer = new MockInstancesIndex ( ) before ( async ( ) => { await instanceIndexServer . initialize ( ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await waitJobs ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) instanceIndexServer . addInstance ( servers [ 0 ] . host ) const config = { followings : { instance : { autoFollowIndex : { indexUrl : 's' , enabled : true } } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , config ) await wait ( 0 ) await waitJobs ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) await resetFollows ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) instanceIndexServer . addInstance ( servers [ 0 ] . host ) await wait ( 0 ) await waitJobs ( servers ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , false ) await checkFollow ( servers [ 0 ] , servers [ 0 ] , true ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $ServerInfo$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { About } from 's' import { CustomConfig } from 's' import { cleanupTests , deleteCustomConfig , flushAndRunServer , getAbout , getConfig , getCustomConfig , killallServers , parallelTests , registerUser , reRunServer , ServerInfo , setAccessTokensToServers , updateCustomConfig , uploadVideo } from 's' import { ServerConfig } from 's' const expect = chai . expect function checkInitialConfig ( server , data ) { expect ( data . instance . name ) . to . equal ( 's' ) expect ( data . instance . shortDescription ) . to . equal ( 's' + 's' ) expect ( data . instance . description ) . to . equal ( 's' ) expect ( data . instance . terms ) . to . equal ( 's' ) expect ( data . instance . creationReason ) . to . be . empty expect ( data . instance . codeOfConduct ) . to . be . empty expect ( data . instance . moderationInformation ) . to . be . empty expect ( data . instance . administrator ) . to . be . empty expect ( data . instance . maintenanceLifetime ) . to . be . empty expect ( data . instance . businessModel ) . to . be . empty expect ( data . instance . hardwareInformation ) . to . be . empty expect ( data . instance . languages ) . to . have . lengthOf ( 0 ) expect ( data . instance . categories ) . to . have . lengthOf ( 0 ) expect ( data . instance . defaultClientRoute ) . to . equal ( 's' ) expect ( data . instance . isNSFW ) . to . be . false expect ( data . instance . defaultNSFWPolicy ) . to . equal ( 's' ) expect ( data . instance . customizations . css ) . to . be . empty expect ( data . instance . customizations . javascript ) . to . be . empty expect ( data . services . twitter . username ) . to . equal ( 's' ) expect ( data . services . twitter . whitelisted ) . to . be . false expect ( data . cache . previews . size ) . to . equal ( 0 ) expect ( data . cache . captions . size ) . to . equal ( 0 ) expect ( data . signup . enabled ) . to . be . true expect ( data . signup . limit ) . to . equal ( 0 ) expect ( data . signup . requiresEmailVerification ) . to . be . false expect ( data . admin . email ) . to . equal ( 's' + server . internalServerNumber + 's' ) expect ( data . contactForm . enabled ) . to . be . true expect ( data . user . videoQuota ) . to . equal ( 0 ) expect ( data . user . videoQuotaDaily ) . to . equal ( - 0 ) expect ( data . transcoding . enabled ) . to . be . false expect ( data . transcoding . allowAdditionalExtensions ) . to . be . false expect ( data . transcoding . allowAudioFiles ) . to . be . false expect ( data . transcoding . threads ) . to . equal ( 0 ) expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . hls . enabled ) . to . be . true expect ( data . import . videos . http . enabled ) . to . be . true expect ( data . import . videos . torrent . enabled ) . to . be . true expect ( data . autoBlacklist . videos . ofUsers . enabled ) . to . be . false expect ( data . followers . instance . enabled ) . to . be . true expect ( data . followers . instance . manualApproval ) . to . be . false expect ( data . followings . instance . autoFollowBack . enabled ) . to . be . false expect ( data . followings . instance . autoFollowIndex . enabled ) . to . be . false expect ( data . followings . instance . autoFollowIndex . indexUrl ) . to . equal ( 's' ) } function checkUpdatedConfig ( data ) { expect ( data . instance . name ) . to . equal ( 's' ) expect ( data . instance . shortDescription ) . to . equal ( 's' ) expect ( data . instance . description ) . to . equal ( 's' ) expect ( data . instance . terms ) . to . equal ( 's' ) expect ( data . instance . creationReason ) . to . equal ( 's' ) expect ( data . instance . codeOfConduct ) . to . equal ( 's' ) expect ( data . instance . moderationInformation ) . to . equal ( 's' ) expect ( data . instance . administrator ) . to . equal ( 's' ) expect ( data . instance . maintenanceLifetime ) . to . equal ( 's' ) expect ( data . instance . businessModel ) . to . equal ( 's' ) expect ( data . instance . hardwareInformation ) . to . equal ( 's' ) expect ( data . instance . languages ) . to . deep . equal ( [ 's' , 's' ] ) expect ( data . instance . categories ) . to . deep . equal ( [ 0 , 0 ] ) expect ( data . instance . defaultClientRoute ) . to . equal ( 's' ) expect ( data . instance . isNSFW ) . to . be . true expect ( data . instance . defaultNSFWPolicy ) . to . equal ( 's' ) expect ( data . instance . customizations . javascript ) . to . equal ( 's' ) expect ( data . instance . customizations . css ) . to . equal ( 's' ) expect ( data . services . twitter . username ) . to . equal ( 's' ) expect ( data . services . twitter . whitelisted ) . to . be . true expect ( data . cache . previews . size ) . to . equal ( 0 ) expect ( data . cache . captions . size ) . to . equal ( 0 ) expect ( data . signup . enabled ) . to . be . false expect ( data . signup . limit ) . to . equal ( 0 ) expect ( data . signup . requiresEmailVerification ) . to . be . false if ( parallelTests ( ) === false ) { expect ( data . admin . email ) . to . equal ( 's' ) } expect ( data . contactForm . enabled ) . to . be . false expect ( data . user . videoQuota ) . to . equal ( 0 ) expect ( data . user . videoQuotaDaily ) . to . equal ( 0 ) expect ( data . transcoding . enabled ) . to . be . true expect ( data . transcoding . threads ) . to . equal ( 0 ) expect ( data . transcoding . allowAdditionalExtensions ) . to . be . true expect ( data . transcoding . allowAudioFiles ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . false expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . true expect ( data . transcoding . resolutions [ 's' ] ) . to . be . false expect ( data . transcoding . resolutions [ 's' ] ) . to . be . false expect ( data . transcoding . resolutions [ 's' ] ) . to . be . false expect ( data . transcoding . hls . enabled ) . to . be . false expect ( data . import . videos . http . enabled ) . to . be . false expect ( data . import . videos . torrent . enabled ) . to . be . false expect ( data . autoBlacklist . videos . ofUsers . enabled ) . to . be . true expect ( data . followers . instance . enabled ) . to . be . false expect ( data . followers . instance . manualApproval ) . to . be . true expect ( data . followings . instance . autoFollowBack . enabled ) . to . be . true expect ( data . followings . instance . autoFollowIndex . enabled ) . to . be . true expect ( data . followings . instance . autoFollowIndex . indexUrl ) . to . equal ( 's' ) } describe ( 's' , function ( ) { let server = null before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { const res = await getConfig ( server . url ) const data = res . body expect ( data . signup . allowed ) . to . be . true } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await Promise . all ( [ registerUser ( server . url , 's' , 's' ) , registerUser ( server . url , 's' , 's' ) , registerUser ( server . url , 's' , 's' ) ] ) const res = await getConfig ( server . url ) const data = res . body expect ( data . signup . allowed ) . to . be . false } ) it ( 's' , async function ( ) { const res = await getConfig ( server . url ) const data = res . body expect ( data . video . file . extensions ) . to . have . lengthOf ( 0 ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) await uploadVideo ( server . url , server . accessToken , { fixture : 's' } , 0 ) await uploadVideo ( server . url , server . accessToken , { fixture : 's' } , 0 ) expect ( data . contactForm . enabled ) . to . be . true } ) it ( 's' , async function ( ) { const res = await getCustomConfig ( server . url , server . accessToken ) const data = res . body as CustomConfig checkInitialConfig ( server , data ) } ) it ( 's' , async function ( ) { const newCustomConfig = { instance : { name : 's' , shortDescription : 's' , description : 's' , terms : 's' , codeOfConduct : 's' , creationReason : 's' , moderationInformation : 's' , administrator : 's' , maintenanceLifetime : 's' , businessModel : 's' , hardwareInformation : 's' , languages : [ 's' , 's' ] , categories : [ 0 , 0 ] , defaultClientRoute : 's' , isNSFW : true , defaultNSFWPolicy : 's' as 's' , customizations : { javascript : 's' , css : 's' } } , theme : { default : 's' } , services : { twitter : { username : 's' , whitelisted : true } } , cache : { previews : { size : 0 } , captions : { size : 0 } } , signup : { enabled : false , limit : 0 , requiresEmailVerification : false } , admin : { email : 's' } , contactForm : { enabled : false } , user : { videoQuota : 0 , videoQuotaDaily : 0 } , transcoding : { enabled : true , allowAdditionalExtensions : true , allowAudioFiles : true , threads : 0 , resolutions : { 's' : false , 's' : true , 's' : true , 's' : false , 's' : false , 's' : false } , hls : { enabled : false } } , import : { videos : { http : { enabled : false } , torrent : { enabled : false } } } , autoBlacklist : { videos : { ofUsers : { enabled : true } } } , followers : { instance : { enabled : false , manualApproval : true } } , followings : { instance : { autoFollowBack : { enabled : true } , autoFollowIndex : { enabled : true , indexUrl : 's' } } } } await updateCustomConfig ( server . url , server . accessToken , newCustomConfig ) const res = await getCustomConfig ( server . url , server . accessToken ) const data = res . body checkUpdatedConfig ( data ) } ) it ( 's' , async function ( ) { const res = await getConfig ( server . url ) const data = res . body expect ( data . video . file . extensions ) . to . have . length . above ( 0 ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) expect ( data . video . file . extensions ) . to . contain ( 's' ) await uploadVideo ( server . url , server . accessToken , { fixture : 's' } , 0 ) await uploadVideo ( server . url , server . accessToken , { fixture : 's' } , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server ) const res = await getCustomConfig ( server . url , server . accessToken ) const data = res . body checkUpdatedConfig ( data ) } ) it ( 's' , async function ( ) { const res = await getAbout ( server . url ) const data = res . body expect ( data . instance . name ) . to . equal ( 's' ) expect ( data . instance . shortDescription ) . to . equal ( 's' ) expect ( data . instance . description ) . to . equal ( 's' ) expect ( data . instance . terms ) . to . equal ( 's' ) expect ( data . instance . codeOfConduct ) . to . equal ( 's' ) expect ( data . instance . creationReason ) . to . equal ( 's' ) expect ( data . instance . moderationInformation ) . to . equal ( 's' ) expect ( data . instance . administrator ) . to . equal ( 's' ) expect ( data . instance . maintenanceLifetime ) . to . equal ( 's' ) expect ( data . instance . businessModel ) . to . equal ( 's' ) expect ( data . instance . hardwareInformation ) . to . equal ( 's' ) expect ( data . instance . languages ) . to . deep . equal ( [ 's' , 's' ] ) expect ( data . instance . categories ) . to . deep . equal ( [ 0 , 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteCustomConfig ( server . url , server . accessToken ) const res = await getCustomConfig ( server . url , server . accessToken ) const data = res . body checkInitialConfig ( server , data ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CustomConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $About$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { flushTests , killallServers , flushAndRunServer , ServerInfo , setAccessTokensToServers , wait , cleanupTests } from 's' import { MockSmtpServer } from 's' import { waitJobs } from 's' import { sendContactForm } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server const emails : object [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) const port = await MockSmtpServer . Instance . collectEmails ( emails ) const overrideConfig = { smtp : { hostname : 's' , port } } server = await flushAndRunServer ( 0 , overrideConfig ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await sendContactForm ( { url : server . url , fromEmail : 's' , body : 's' , subject : 's' , fromName : 's' } ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . internalServerNumber + 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) } ) it ( 's' , async function ( ) { await sendContactForm ( { url : server . url , fromEmail : 's' , body : 's' , subject : 's' , fromName : 's' } ) await sendContactForm ( { url : server . url , fromEmail : 's' , body : 's' , fromName : 's' , subject : 's' , expectedStatus : 0 } ) } ) it ( 's' , async function ( ) { await wait ( 0 ) await sendContactForm ( { url : server . url , fromEmail : 's' , fromName : 's' , subject : 's' , body : 's' } ) } ) after ( async function ( ) { MockSmtpServer . Instance . kill ( ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoToBlacklist , askResetPassword , askSendVerifyEmail , blockUser , cleanupTests , createUser , flushAndRunServer , removeVideoFromBlacklist , reportVideoAbuse , resetPassword , ServerInfo , setAccessTokensToServers , unblockUser , uploadVideo , userLogin , verifyEmail } from 's' import { MockSmtpServer } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server let userId let userAccessToken let videoUUID let videoUserUUID let verificationString const emails : object [ ] = [ ] const user = { username : 's' , password : 's' } let emailPort before ( async function ( ) { this . timeout ( 0 ) emailPort = await MockSmtpServer . Instance . collectEmails ( emails ) const overrideConfig = { smtp : { hostname : 's' , port : emailPort } } server = await flushAndRunServer ( 0 , overrideConfig ) await setAccessTokensToServers ( [ server ] ) { const res = await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userId = res . body . user . id userAccessToken = await userLogin ( server , user ) } { const attributes = { name : 's' } const res = await uploadVideo ( server . url , userAccessToken , attributes ) videoUserUUID = res . body . video . uuid } { const attributes = { name : 's' } const res = await uploadVideo ( server . url , server . accessToken , attributes ) videoUUID = res . body . video . uuid } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await askResetPassword ( server . url , 's' ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) const verificationStringMatches = "s" . exec ( email [ 's' ] ) expect ( verificationStringMatches ) . not . to . be . null verificationString = verificationStringMatches [ 0 ] expect ( verificationString ) . to . have . length . above ( 0 ) const userIdMatches = "s" . exec ( email [ 's' ] ) expect ( userIdMatches ) . not . to . be . null userId = parseInt ( userIdMatches [ 0 ] , 0 ) expect ( verificationString ) . to . not . be . undefined } ) it ( 's' , async function ( ) { await resetPassword ( server . url , userId , verificationString + 's' , 's' , 0 ) } ) it ( 's' , async function ( ) { await resetPassword ( server . url , userId , verificationString , 's' ) } ) it ( 's' , async function ( ) { user . password = 's' await userLogin ( server , user ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const reason = 's' await reportVideoAbuse ( server . url , server . accessToken , videoUUID , reason ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . internalServerNumber + 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( videoUUID ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const reason = 's' await blockUser ( server . url , userId , server . accessToken , 0 , reason ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( reason ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unblockUser ( server . url , userId , server . accessToken , 0 ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const reason = 's' await addVideoToBlacklist ( server . url , server . accessToken , videoUserUUID , reason ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromBlacklist ( server . url , server . accessToken , videoUserUUID ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await askSendVerifyEmail ( server . url , 's' ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( 0 ) const email = emails [ 0 ] expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' + server . port ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] [ 0 ] [ 's' ] ) . equal ( 's' ) expect ( email [ 's' ] ) . contains ( 's' ) const verificationStringMatches = "s" . exec ( email [ 's' ] ) expect ( verificationStringMatches ) . not . to . be . null verificationString = verificationStringMatches [ 0 ] expect ( verificationString ) . to . not . be . undefined expect ( verificationString ) . to . have . length . above ( 0 ) const userIdMatches = "s" . exec ( email [ 's' ] ) expect ( userIdMatches ) . not . to . be . null userId = parseInt ( userIdMatches [ 0 ] , 0 ) } ) it ( 's' , async function ( ) { await verifyEmail ( server . url , userId , verificationString + 's' , false , 0 ) } ) it ( 's' , async function ( ) { await verifyEmail ( server . url , userId , verificationString ) } ) } ) after ( async function ( ) { MockSmtpServer . Instance . kill ( ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $number$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , doubleFollow , flushAndRunMultipleServers , getAccountVideos , getVideo , getVideoChannelVideos , getVideoWithToken , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { unfollow } from 's' import { userLogin } from 's' import { createUser } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 let userAccessToken before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( servers [ 0 ] , user ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) describe ( 's' , function ( ) { describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , undefined , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , undefined , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , undefined , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , undefined , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , userAccessToken , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , userAccessToken , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) } ) } ) describe ( 's' , function ( ) { before ( async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , undefined , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , undefined , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , undefined , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , undefined , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , userAccessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getAccountVideos ( servers [ 0 ] . url , userAccessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , userAccessToken , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const videoChannelName = 's' + servers [ 0 ] . port const res = await getVideoChannelVideos ( servers [ 0 ] . url , userAccessToken , videoChannelName , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { Video , VideoPrivacy } from 's' import { VideoComment , VideoCommentThreadTree } from 's' import { cleanupTests , completeVideoCheck } from 's' import { flushAndRunMultipleServers , getVideosList , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { dateIsValid } from 's' import { follow , getFollowersListPaginationAndSort , getFollowingListPaginationAndSort , unfollow } from 's' import { expectAccountFollows } from 's' import { userLogin } from 's' import { createUser } from 's' import { addVideoCommentReply , addVideoCommentThread , getVideoCommentThreads , getVideoThreadComments } from 's' import { rateVideo } from 's' import { waitJobs } from 's' import { createVideoCaption , listVideoCaptions , testCaptionFile } from 's' import { VideoCaption } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getFollowersListPaginationAndSort ( server . url , 0 , 0 , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getFollowingListPaginationAndSort ( server . url , 0 , 0 , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url , servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { let res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) let follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) follows = follows . concat ( res . body . data ) const 0 = follows . find ( f => f . following . host === 's' + servers [ 0 ] . port ) const 0 = follows . find ( f => f . following . host === 's' + servers [ 0 ] . port ) expect ( 0 ) . to . not . be . undefined expect ( 0 ) . to . not . be . undefined expect ( 0 . state ) . to . equal ( 's' ) expect ( 0 . state ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' , 's' + servers [ 0 ] . port ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows . length ) . to . equal ( 0 ) expect ( follows [ 0 ] . following . host ) . to . equal ( 's' + servers [ 0 ] . port ) } { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { const res = await getFollowingListPaginationAndSort ( server . url , 0 , 0 , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { let res = await getFollowersListPaginationAndSort ( server . url , 0 , 0 , 's' ) let follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) expect ( follows [ 0 ] . follower . host ) . to . equal ( 's' + servers [ 0 ] . port ) } } ) it ( 's' , async function ( ) { { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' , servers [ 0 ] . port + 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows . length ) . to . equal ( 0 ) expect ( follows [ 0 ] . following . host ) . to . equal ( 's' + servers [ 0 ] . port ) } { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) const follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) let follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) expect ( follows [ 0 ] . following . host ) . to . equal ( 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) let follows = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( follows ) . to . be . an ( 's' ) expect ( follows . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await waitJobs ( servers ) let res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } ) describe ( 's' , function ( ) { let 0 before ( async function ( ) { this . timeout ( 0 ) const 0 = { name : 's' , category : 0 , nsfw : true , licence : 0 , tags : [ 's' , 's' , 's' ] } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) const userAccessToken = await userLogin ( servers [ 0 ] , user ) const resVideos = await getVideosList ( servers [ 0 ] . url ) 0 = resVideos . body . data . find ( v => v . name === 's' ) { await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . id , 's' ) await rateVideo ( servers [ 0 ] . url , userAccessToken , 0 . id , 's' ) } { const text = 's' const res = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . id , text ) const threadId = res . body . comment . id const 0 = 's' const childCommentRes = await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . id , threadId , 0 ) const childCommentId = childCommentRes . body . comment . id const 0 = 's' await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . id , childCommentId , 0 ) const 0 = 's' await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . id , threadId , 0 ) } { await createVideoCaption ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , language : 's' , videoId : 0 . id , fixture : 's' } ) } } await waitJobs ( servers ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) await expectAccountFollows ( servers [ 0 ] . url , 's' + servers [ 0 ] . port , 0 , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) const 0 = res . body . data . find ( v => v . name === 's' ) 0 = res . body . data . find ( v => v . name === 's' ) const 0 = res . body . data . find ( v => v . name === 's' ) expect ( 0 ) . to . not . be . undefined expect ( 0 ) . to . not . be . undefined expect ( 0 ) . to . not . be . undefined const isLocal = false const checkAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , commentsEnabled : true , downloadEnabled : true , duration : 0 , tags : [ 's' , 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , likes : 0 , dislikes : 0 , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } await completeVideoCheck ( servers [ 0 ] . url , 0 , checkAttributes ) } ) it ( 's' , async function ( ) { const 0 = await getVideoCommentThreads ( servers [ 0 ] . url , 0 . id , 0 , 0 ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data ) . to . have . lengthOf ( 0 ) const comment = 0 . body . data [ 0 ] expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . text ) . equal ( 's' ) expect ( comment . videoId ) . to . equal ( 0 . id ) expect ( comment . id ) . to . equal ( comment . threadId ) expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true const threadId = comment . threadId const 0 = await getVideoThreadComments ( servers [ 0 ] . url , 0 . id , threadId ) const tree = 0 . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) const secondChild = tree . children [ 0 ] expect ( secondChild . comment . text ) . to . equal ( 's' ) expect ( secondChild . children ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await listVideoCaptions ( servers [ 0 ] . url , 0 . id ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const 0 = res . body . data [ 0 ] expect ( 0 . language . id ) . to . equal ( 's' ) expect ( 0 . language . label ) . to . equal ( 's' ) expect ( 0 . captionPath ) . to . equal ( 's' + 0 . uuid + 's' ) await testCaptionFile ( servers [ 0 ] . url , 0 . captionPath , 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) let res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { acceptFollower , cleanupTests , flushAndRunMultipleServers , ServerInfo , setAccessTokensToServers , updateCustomSubConfig } from 's' import { follow , getFollowersListPaginationAndSort , getFollowingListPaginationAndSort , rejectFollower , removeFollower } from 's' import { waitJobs } from 's' import { ActorFollow } from 's' const expect = chai . expect async function 0 ( servers : ServerInfo [ ] , state = 's' ) { { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const follow = res . body . data [ 0 ] as ActorFollow expect ( follow . state ) . to . equal ( state ) expect ( follow . follower . url ) . to . equal ( 's' + servers [ 0 ] . port + 's' ) expect ( follow . following . url ) . to . equal ( 's' + servers [ 0 ] . port + 's' ) } { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const follow = res . body . data [ 0 ] as ActorFollow expect ( follow . state ) . to . equal ( state ) expect ( follow . follower . url ) . to . equal ( 's' + servers [ 0 ] . port + 's' ) expect ( follow . following . url ) . to . equal ( 's' + servers [ 0 ] . port + 's' ) } } async function checkNoFollowers ( servers : ServerInfo [ ] ) { { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await 0 ( servers ) } ) it ( 's' , async function ( ) { await removeFollower ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await checkNoFollowers ( servers ) } ) it ( 's' , async function ( ) { const subConfig = { followers : { instance : { enabled : false , manualApproval : false } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , subConfig ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) await checkNoFollowers ( servers ) } ) it ( 's' , async function ( ) { const subConfig = { followers : { instance : { enabled : true , manualApproval : false } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , subConfig ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) await 0 ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeFollower ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) const subConfig = { followers : { instance : { enabled : true , manualApproval : true } } } await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , subConfig ) await updateCustomSubConfig ( servers [ 0 ] . url , servers [ 0 ] . accessToken , subConfig ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) await 0 ( servers , 's' ) } ) it ( 's' , async function ( ) { await acceptFollower ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await 0 ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) { const res = await getFollowingListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } await rejectFollower ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await 0 ( servers ) { const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { JobState , Video } from 's' import { VideoPrivacy } from 's' import { VideoCommentThreadTree } from 's' import { cleanupTests , completeVideoCheck , flushAndRunMultipleServers , getVideo , getVideosList , immutableAssign , killallServers , reRunServer , ServerInfo , setAccessTokensToServers , unfollow , updateVideo , uploadVideo , uploadVideoAndGetId , wait , setActorFollowScores , closeAllSequelize } from 's' import { follow , getFollowersListPaginationAndSort } from 's' import { getJobsListPaginationAndSort , waitJobs } from 's' import { addVideoCommentReply , addVideoCommentThread , getVideoCommentThreads , getVideoThreadComments } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 let 0 let 0 let 0 let 0 let unlistedVideo let 0 : number [ ] = [ ] const videoAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , privacy : VideoPrivacy . PUBLIC , description : 's' , support : 's' , tags : [ 's' , 's' ] , fixture : 's' } const unlistedVideoAttributes = immutableAssign ( videoAttributes , { privacy : VideoPrivacy . UNLISTED } ) let checkAttributes let unlistedCheckAttributes before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) checkAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal : false , duration : 0 , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , commentsEnabled : true , downloadEnabled : true , channel : { name : 's' , displayName : 's' , description : 's' , isLocal : false } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } unlistedCheckAttributes = immutableAssign ( checkAttributes , { privacy : VideoPrivacy . UNLISTED } ) await setAccessTokensToServers ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } killallServers ( [ servers [ 0 ] ] ) for ( let i = 0 ; i < 0 ; i ++ ) { await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) } await waitJobs ( servers [ 0 ] ) killallServers ( [ servers [ 0 ] ] ) const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) 0 = 0 . body . video const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) 0 = 0 . body . video let resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , unlistedVideoAttributes ) unlistedVideo = resVideo . body . video { const text = 's' let resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , text ) let comment = resComment . body . comment 0 = comment . id resComment = await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , comment . id , 's' ) comment = resComment . body . comment resComment = await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , comment . id , 's' ) 0 = resComment . body . comment . id } await waitJobs ( servers [ 0 ] ) await wait ( 0 ) const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . follower . host ) . to . equal ( 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { const states : JobState [ ] = [ 's' , 's' ] for ( const state of states ) { const res = await getJobsListPaginationAndSort ( servers [ 0 ] . url , servers [ 0 ] . accessToken , state , 0 , 0 , 's' ) expect ( res . body . data ) . to . have . length ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await reRunServer ( servers [ 0 ] ) await reRunServer ( servers [ 0 ] ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) const res = await getFollowersListPaginationAndSort ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const 0 = await getVideosList ( servers [ 0 ] . url ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data ) . to . have . lengthOf ( 0 ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , { } ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , unlistedVideo . uuid , { } ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const resVideo = await getVideo ( servers [ 0 ] . url , unlistedVideo . uuid ) expect ( resVideo . body ) . not . to . be . undefined await completeVideoCheck ( servers [ 0 ] . url , resVideo . body , unlistedCheckAttributes ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , 0 , 's' ) await waitJobs ( servers ) const resVideo = await getVideo ( servers [ 0 ] . url , 0 . uuid ) expect ( resVideo . body ) . not . to . be . undefined { let resComment = await getVideoCommentThreads ( servers [ 0 ] . url , 0 . uuid , 0 , 0 ) expect ( resComment . body . data ) . to . be . an ( 's' ) expect ( resComment . body . data ) . to . have . lengthOf ( 0 ) 0 = resComment . body . data [ 0 ] . id resComment = await getVideoThreadComments ( servers [ 0 ] . url , 0 . uuid , 0 ) const tree = resComment . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) const childOfChildFirstChild = childOfFirstChild . children [ 0 ] expect ( childOfChildFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfChildFirstChild . children ) . to . have . lengthOf ( 0 ) 0 = childOfChildFirstChild . comment . id } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . uuid , 0 , 's' ) await waitJobs ( servers ) { const resComment = await getVideoThreadComments ( servers [ 0 ] . url , 0 . uuid , 0 ) const tree = resComment . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) const childOfChildFirstChild = childOfFirstChild . children [ 0 ] expect ( childOfChildFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfChildFirstChild . children ) . to . have . lengthOf ( 0 ) const childOfChildOfChildOfFirstChild = childOfChildFirstChild . children [ 0 ] expect ( childOfChildOfChildOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfChildOfChildOfFirstChild . children ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( let i = 0 ; i < 0 ; i ++ ) { const uuid = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' + i } ) ) . uuid 0 . push ( uuid ) } await waitJobs ( servers ) for ( const id of 0 ) { await getVideo ( servers [ 0 ] . url , id ) } await waitJobs ( servers ) await setActorFollowScores ( servers [ 0 ] . internalServerNumber , 0 ) await wait ( 0 ) await getVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) await wait ( 0 ) for ( let i = 0 ; i < 0 ; i ++ ) { await getVideo ( servers [ 0 ] . url , 0 [ i ] ) await wait ( 0 ) await waitJobs ( [ servers [ 0 ] ] ) } for ( const id of 0 ) { await getVideo ( servers [ 0 ] . url , id , 0 ) } } ) after ( async function ( ) { await closeAllSequelize ( [ servers [ 0 ] ] ) await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $Video$ O $Video$ O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , killallServers , ServerInfo , setAccessTokensToServers } from 's' import { doubleFollow } from 's' import { getJobsList , getJobsListPaginationAndSort , waitJobs } from 's' import { flushAndRunMultipleServers } from 's' import { uploadVideo } from 's' import { dateIsValid } from 's' import { Job } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getJobsList ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . be . above ( 0 ) expect ( res . body . data ) . to . have . length . above ( 0 ) } ) it ( 's' , async function ( ) { const res = await getJobsListPaginationAndSort ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' , 0 , 0 , 's' ) expect ( res . body . total ) . to . be . above ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) let job = res . body . data [ 0 ] if ( job . type === 's' ) job = res . body . data [ 0 ] expect ( job . state ) . to . equal ( 's' ) expect ( job . type . startsWith ( 's' ) ) . to . be . true expect ( dateIsValid ( job . createdAt ) ) . to . be . true expect ( dateIsValid ( job . processedOn ) ) . to . be . true expect ( dateIsValid ( job . finishedOn ) ) . to . be . true } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest } from 's' import { LogLevel } from 's' function getLogs ( url , accessToken , startDate , endDate ? , level ? ) { const path = 's' return makeGetRequest ( { url , path , token : accessToken , query : { startDate , endDate , level } , statusCodeExpected : 0 } ) } export { getLogs }	O O O O O O O O O O O O O O O $string$ O $string$ O $Date$ O O $Date$ O O $LogLevel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { flushTests , killallServers , flushAndRunServer , ServerInfo , setAccessTokensToServers , cleanupTests } from 's' import { waitJobs } from 's' import { uploadVideo } from 's' import { getLogs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) const now = new Date ( ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) const res = await getLogs ( server . url , server . accessToken , now ) const logsString = JSON . stringify ( res . body ) expect ( logsString . includes ( 's' ) ) . to . be . false expect ( logsString . includes ( 's' ) ) . to . be . true } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) const 0 = new Date ( ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) const 0 = new Date ( ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) const res = await getLogs ( server . url , server . accessToken , 0 , 0 ) const logsString = JSON . stringify ( res . body ) expect ( logsString . includes ( 's' ) ) . to . be . false expect ( logsString . includes ( 's' ) ) . to . be . true expect ( logsString . includes ( 's' ) ) . to . be . false } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const now = new Date ( ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await waitJobs ( [ server ] ) { const res = await getLogs ( server . url , server . accessToken , now , undefined , 's' ) const logsString = JSON . stringify ( res . body ) expect ( logsString . includes ( 's' ) ) . to . be . true } { const res = await getLogs ( server . url , server . accessToken , now , undefined , 's' ) const logsString = JSON . stringify ( res . body ) expect ( logsString . includes ( 's' ) ) . to . be . false } } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { cleanupTests , getVideo , registerUser , uploadVideo , userLogin , viewVideo , wait } from 's' import { flushAndRunServer , setAccessTokensToServers } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null let videoId before ( async function ( ) { this . timeout ( 0 ) const config = { rates_limit : { api : { max : 0 , window : 0 } , signup : { max : 0 , window : 0 } , login : { max : 0 } } , signup : { limit : 0 } } server = await flushAndRunServer ( 0 , config ) await setAccessTokensToServers ( [ server ] ) const { body } = await uploadVideo ( server . url , server . accessToken , { } ) videoId = body . video . uuid } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( server . url , videoId ) await viewVideo ( server . url , videoId ) await wait ( 0 ) const { body } = await getVideo ( server . url , videoId ) expect ( body . views ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( server . url , videoId , 0 , 's' ) await viewVideo ( server . url , videoId , 0 , 's' ) await wait ( 0 ) const { body } = await getVideo ( server . url , videoId ) expect ( body . views ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( server . url , videoId , 0 , 's' ) await viewVideo ( server . url , videoId , 0 , 's' ) await wait ( 0 ) const { body } = await getVideo ( server . url , videoId ) expect ( body . views ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( server . url , videoId , 0 , 's' ) await viewVideo ( server . url , videoId , 0 , 's' ) await wait ( 0 ) const { body } = await getVideo ( server . url , videoId ) expect ( body . views ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const user = { username : 's' , password : 's' } for ( let i = 0 ; i < 0 ; i ++ ) { await userLogin ( server , user , 0 ) } await userLogin ( server , user , 0 ) } ) it ( 's' , async function ( ) { for ( let i = 0 ; i < 0 ; i ++ ) { await registerUser ( server . url , 's' + i , 's' ) } await registerUser ( server . url , 's' , 's' , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) for ( let i = 0 ; i < 0 ; i ++ ) { await registerUser ( server . url , 's' + i , 's' , 0 ) } await registerUser ( server . url , 's' , 's' , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) for ( let i = 0 ; i < 0 ; i ++ ) { try { await getVideo ( server . url , videoId ) } catch { } } await getVideo ( server . url , videoId , 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { ServerStats } from 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , follow , killallServers , ServerInfo , uploadVideo , viewVideo , wait } from 's' import { flushTests , setAccessTokensToServers } from 's' import { getStats } from 's' import { addVideoCommentThread } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { fixture : 's' } ) const videoUUID = resVideo . body . video . uuid await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , 's' ) await viewVideo ( servers [ 0 ] . url , videoUUID ) await wait ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getStats ( servers [ 0 ] . url ) const data = res . body expect ( data . totalLocalVideoComments ) . to . equal ( 0 ) expect ( data . totalLocalVideos ) . to . equal ( 0 ) expect ( data . totalLocalVideoViews ) . to . equal ( 0 ) expect ( data . totalLocalVideoFilesSize ) . to . equal ( 0 ) expect ( data . totalUsers ) . to . equal ( 0 ) expect ( data . totalVideoComments ) . to . equal ( 0 ) expect ( data . totalVideos ) . to . equal ( 0 ) expect ( data . totalInstanceFollowers ) . to . equal ( 0 ) expect ( data . totalInstanceFollowing ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getStats ( servers [ 0 ] . url ) const data = res . body expect ( data . totalLocalVideoComments ) . to . equal ( 0 ) expect ( data . totalLocalVideos ) . to . equal ( 0 ) expect ( data . totalLocalVideoViews ) . to . equal ( 0 ) expect ( data . totalLocalVideoFilesSize ) . to . equal ( 0 ) expect ( data . totalUsers ) . to . equal ( 0 ) expect ( data . totalVideoComments ) . to . equal ( 0 ) expect ( data . totalVideos ) . to . equal ( 0 ) expect ( data . totalInstanceFollowers ) . to . equal ( 0 ) expect ( data . totalInstanceFollowing ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getStats ( servers [ 0 ] . url ) const data = res . body expect ( data . totalLocalVideoComments ) . to . equal ( 0 ) expect ( data . totalLocalVideos ) . to . equal ( 0 ) expect ( data . totalLocalVideoViews ) . to . equal ( 0 ) expect ( data . totalUsers ) . to . equal ( 0 ) expect ( data . totalVideoComments ) . to . equal ( 0 ) expect ( data . totalVideos ) . to . equal ( 0 ) expect ( data . totalInstanceFollowing ) . to . equal ( 0 ) expect ( data . totalInstanceFollowers ) . to . equal ( 0 ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerStats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as magnetUtil from 's' import 's' import { cleanupTests , flushAndRunServer , getVideo , killallServers , reRunServer , ServerInfo , uploadVideo } from 's' import { setAccessTokensToServers } from 's' import { VideoDetails } from 's' import * as WebTorrent from 's' describe ( 's' , function ( ) { let server let badMagnet let goodMagnet before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const res = await uploadVideo ( server . url , server . accessToken , { } ) const videoUUID = res . body . video . uuid const resGet = await getVideo ( server . url , videoUUID ) const video = resGet . body goodMagnet = video . files [ 0 ] . magnetUri const parsed = magnetUtil . decode ( goodMagnet ) parsed . infoHash = 's' badMagnet = magnetUtil . encode ( parsed ) } } ) it ( 's' , function ( done ) { this . timeout ( 0 ) const webtorrent = new WebTorrent ( ) const torrent = webtorrent . add ( badMagnet ) torrent . on ( 's' , done ) torrent . on ( 's' , warn => { const message = typeof warn === 's' ? warn : warn . message if ( message . indexOf ( 's' ) !== - 0 ) return done ( ) } ) torrent . on ( 's' , ( ) => done ( new Error ( 's' ) ) ) } ) it ( 's' , function ( done ) { this . timeout ( 0 ) const webtorrent = new WebTorrent ( ) const torrent = webtorrent . add ( goodMagnet ) torrent . on ( 's' , done ) torrent . on ( 's' , warn => { const message = typeof warn === 's' ? warn : warn . message if ( message . indexOf ( 's' ) !== - 0 ) return done ( new Error ( 's' ) ) } ) torrent . on ( 's' , done ) } ) it ( 's' , function ( done ) { this . timeout ( 0 ) killallServers ( [ server ] ) reRunServer ( server , { tracker : { enabled : false } } ) . then ( ( ) => { const webtorrent = new WebTorrent ( ) const torrent = webtorrent . add ( goodMagnet ) torrent . on ( 's' , done ) torrent . on ( 's' , warn => { const message = typeof warn === 's' ? warn : warn . message if ( message . indexOf ( 's' ) !== - 0 ) return done ( ) } ) torrent . on ( 's' , ( ) => done ( new Error ( 's' ) ) ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as request from 's' import { ServerInfo } from 's' import { cleanupTests , flushAndRunServer } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 , { } , [ 's' ] ) } ) it ( 's' , function ( ) { const req = request ( server . url ) . get ( 's' ) return req . expect ( 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { cleanupTests , closeAllSequelize , flushAndRunServer , getConfig , getMyUserInformation , getPluginPackageJSON , getPlugin , getPluginRegisteredSettings , getPluginsCSS , installPlugin , killallServers , listAvailablePlugins , listPlugins , reRunServer , ServerInfo , setAccessTokensToServers , setPluginVersion , uninstallPlugin , updateCustomSubConfig , updateMyUser , updatePluginPackageJSON , updatePlugin , updatePluginSettings , wait , getPublicSettings } from 's' import { PluginType } from 's' import { PeerTubePluginIndex } from 's' import { ServerConfig } from 's' import { PeerTubePlugin } from 's' import { User } from 's' import { PluginPackageJson } from 's' import { RegisteredServerSettings } from 's' import { PublicServerSetting } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null before ( async function ( ) { this . timeout ( 0 ) const configOverride = { plugins : { index : { check_latest_versions_interval : 's' } } } server = await flushAndRunServer ( 0 , configOverride ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const res = await listAvailablePlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , pluginType : PluginType . THEME , search : 's' } ) expect ( res . body . total ) . to . be . at . least ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const 0 = await listAvailablePlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , sort : 's' } ) const 0 : PeerTubePluginIndex [ ] = 0 . body . data expect ( 0 . body . total ) . to . be . at . least ( 0 ) expect ( 0 ) . to . have . lengthOf ( 0 ) const 0 = await listAvailablePlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , sort : 's' } ) const 0 : PeerTubePluginIndex [ ] = 0 . body . data expect ( 0 . body . total ) . to . be . at . least ( 0 ) expect ( 0 ) . to . have . lengthOf ( 0 ) expect ( 0 [ 0 ] . npmName ) . to . not . equal ( 0 [ 0 ] . npmName ) } { const res = await listAvailablePlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , pluginType : PluginType . THEME , search : 's' , currentPeerTubeEngine : 's' } ) const data : PeerTubePluginIndex [ ] = res . body . data const p = data . find ( p => p . npmName === 's' ) expect ( p ) . to . be . undefined } } ) it ( 's' , async function ( ) { const res = await getPluginsCSS ( server . url ) expect ( res . text ) . to . be . empty } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await installPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) await installPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) } ) it ( 's' , async function ( ) { const res = await getPluginsCSS ( server . url ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await getConfig ( server . url ) const config = res . body const theme = config . theme . registered . find ( r => r . name === 's' ) expect ( theme ) . to . not . be . undefined const plugin = config . plugin . registered . find ( r => r . name === 's' ) expect ( plugin ) . to . not . be . undefined } ) it ( 's' , async function ( ) { await updateCustomSubConfig ( server . url , server . accessToken , { theme : { default : 's' } } ) const res = await getConfig ( server . url ) const config = res . body expect ( config . theme . default ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : server . accessToken , theme : 's' } ) const res = await getMyUserInformation ( server . url , server . accessToken ) expect ( ( res . body as User ) . theme ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , pluginType : PluginType . THEME } ) const data : PeerTubePlugin [ ] = res . body . data expect ( res . body . total ) . to . be . at . least ( 0 ) expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . name ) . to . equal ( 's' ) } { const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , sort : 's' } ) const data : PeerTubePlugin [ ] = res . body . data expect ( data [ 0 ] . name ) . to . equal ( 's' ) expect ( data [ 0 ] . name ) . to . equal ( 's' ) } { const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , count : 0 , start : 0 , sort : 's' } ) const data : PeerTubePlugin [ ] = res . body . data expect ( data [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const res = await getPluginRegisteredSettings ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) const registeredSettings = ( res . body as RegisteredServerSettings ) . registeredSettings expect ( registeredSettings ) . to . have . length . at . least ( 0 ) const adminNameSettings = registeredSettings . find ( s => s . name === 's' ) expect ( adminNameSettings ) . to . not . be . undefined } ) it ( 's' , async function ( ) { const res = await getPublicSettings ( { url : server . url , npmName : 's' } ) const publicSettings = ( res . body as PublicServerSetting ) . publicSettings expect ( Object . keys ( publicSettings ) ) . to . have . lengthOf ( 0 ) expect ( Object . keys ( publicSettings ) ) . to . deep . equal ( [ 's' ] ) expect ( publicSettings [ 's' ] ) . to . be . null } ) it ( 's' , async function ( ) { const settings = { 's' : 's' } await updatePluginSettings ( { url : server . url , accessToken : server . accessToken , npmName : 's' , settings } ) } ) it ( 's' , async function ( ) { { const res = await getPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) const plugin = res . body expect ( plugin . type ) . to . equal ( PluginType . PLUGIN ) expect ( plugin . name ) . to . equal ( 's' ) expect ( plugin . description ) . to . exist expect ( plugin . homepage ) . to . exist expect ( plugin . uninstalled ) . to . be . false expect ( plugin . enabled ) . to . be . true expect ( plugin . description ) . to . exist expect ( plugin . version ) . to . exist expect ( plugin . peertubeEngine ) . to . exist expect ( plugin . createdAt ) . to . exist expect ( plugin . settings ) . to . not . be . undefined expect ( plugin . settings [ 's' ] ) . to . equal ( 's' ) } { const res = await getPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) const plugin = res . body expect ( plugin . type ) . to . equal ( PluginType . THEME ) expect ( plugin . name ) . to . equal ( 's' ) expect ( plugin . description ) . to . exist expect ( plugin . homepage ) . to . exist expect ( plugin . uninstalled ) . to . be . false expect ( plugin . enabled ) . to . be . true expect ( plugin . description ) . to . exist expect ( plugin . version ) . to . exist expect ( plugin . peertubeEngine ) . to . exist expect ( plugin . createdAt ) . to . exist expect ( plugin . settings ) . to . be . null } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await setPluginVersion ( server . internalServerNumber , 's' , 's' ) const packageJSON = await getPluginPackageJSON ( server , 's' ) const oldVersion = packageJSON . version packageJSON . version = 's' await updatePluginPackageJSON ( server , 's' , packageJSON ) killallServers ( [ server ] ) await reRunServer ( server ) { const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , pluginType : PluginType . PLUGIN } ) const plugin = res . body . data [ 0 ] expect ( plugin . version ) . to . equal ( 's' ) expect ( plugin . latestVersion ) . to . exist expect ( plugin . latestVersion ) . to . not . equal ( 's' ) } { await updatePlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , pluginType : PluginType . PLUGIN } ) const plugin = res . body . data [ 0 ] expect ( plugin . version ) . to . equal ( oldVersion ) const updatedPackageJSON = await getPluginPackageJSON ( server , 's' ) expect ( updatedPackageJSON . version ) . to . equal ( oldVersion ) } } ) it ( 's' , async function ( ) { await uninstallPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , pluginType : PluginType . PLUGIN } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getPluginsCSS ( server . url ) expect ( res . text ) . to . be . empty } ) it ( 's' , async function ( ) { const res = await listPlugins ( { url : server . url , accessToken : server . accessToken , pluginType : PluginType . PLUGIN , uninstalled : true } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const plugin = res . body . data [ 0 ] expect ( plugin . name ) . to . equal ( 's' ) expect ( plugin . enabled ) . to . be . false expect ( plugin . uninstalled ) . to . be . true } ) it ( 's' , async function ( ) { await uninstallPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) } ) it ( 's' , async function ( ) { const res = await getConfig ( server . url ) const config = res . body expect ( config . theme . default ) . to . equal ( 's' ) const theme = config . theme . registered . find ( r => r . name === 's' ) expect ( theme ) . to . be . undefined const plugin = config . plugin . registered . find ( r => r . name === 's' ) expect ( plugin ) . to . be . undefined } ) it ( 's' , async function ( ) { const res = await getMyUserInformation ( server . url , server . accessToken ) expect ( ( res . body as User ) . theme ) . to . equal ( 's' ) } ) after ( async function ( ) { await closeAllSequelize ( [ server ] ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginPackageJson$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O $PluginPackageJson$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PeerTubePlugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunServer , getMyUserInformation , getUserInformation , login , registerUser , ServerInfo , updateCustomSubConfig , updateMyUser , userLogin , verifyEmail } from 's' import { setAccessTokensToServers } from 's' import { MockSmtpServer } from 's' import { waitJobs } from 's' import { User } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server let userId let userAccessToken let verificationString let expectedEmailsLength = 0 const 0 = { username : 's' , password : 's' } const 0 = { username : 's' , password : 's' } const emails : object [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) const port = await MockSmtpServer . Instance . collectEmails ( emails ) const overrideConfig = { smtp : { hostname : 's' , port } } server = await flushAndRunServer ( 0 , overrideConfig ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateCustomSubConfig ( server . url , server . accessToken , { signup : { enabled : true , requiresEmailVerification : true , limit : 0 } } ) await registerUser ( server . url , 0 . username , 0 . password ) await waitJobs ( server ) expectedEmailsLength ++ expect ( emails ) . to . have . lengthOf ( expectedEmailsLength ) const email = emails [ expectedEmailsLength - 0 ] const verificationStringMatches = "s" . exec ( email [ 's' ] ) expect ( verificationStringMatches ) . not . to . be . null verificationString = verificationStringMatches [ 0 ] expect ( verificationString ) . to . have . length . above ( 0 ) const userIdMatches = "s" . exec ( email [ 's' ] ) expect ( userIdMatches ) . not . to . be . null userId = parseInt ( userIdMatches [ 0 ] , 0 ) const resUserInfo = await getUserInformation ( server . url , server . accessToken , userId ) expect ( resUserInfo . body . emailVerified ) . to . be . false } ) it ( 's' , async function ( ) { const resLogin = await login ( server . url , server . client , 0 , 0 ) expect ( resLogin . body . error ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { await verifyEmail ( server . url , userId , verificationString ) const res = await login ( server . url , server . client , 0 ) userAccessToken = res . body . access_token const resUserVerified = await getUserInformation ( server . url , server . accessToken , userId ) expect ( resUserVerified . body . emailVerified ) . to . be . true } ) it ( 's' , async function ( ) { let updateVerificationString { await updateMyUser ( { url : server . url , accessToken : userAccessToken , email : 's' , currentPassword : 0 . password } ) await waitJobs ( server ) expectedEmailsLength ++ expect ( emails ) . to . have . lengthOf ( expectedEmailsLength ) const email = emails [ expectedEmailsLength - 0 ] const verificationStringMatches = "s" . exec ( email [ 's' ] ) updateVerificationString = verificationStringMatches [ 0 ] } { const res = await getMyUserInformation ( server . url , userAccessToken ) const me = res . body expect ( me . email ) . to . equal ( 's' ) expect ( me . pendingEmail ) . to . equal ( 's' ) } { await verifyEmail ( server . url , userId , updateVerificationString , true ) const res = await getMyUserInformation ( server . url , userAccessToken ) const me = res . body expect ( me . email ) . to . equal ( 's' ) expect ( me . pendingEmail ) . to . be . null } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateCustomSubConfig ( server . url , server . accessToken , { signup : { enabled : true , requiresEmailVerification : false , limit : 0 } } ) await registerUser ( server . url , 0 . username , 0 . password ) await waitJobs ( server ) expect ( emails ) . to . have . lengthOf ( expectedEmailsLength ) const accessToken = await userLogin ( server , 0 ) const resMyUserInfo = await getMyUserInformation ( server . url , accessToken ) expect ( resMyUserInfo . body . emailVerified ) . to . be . null } ) it ( 's' , async function ( ) { await updateCustomSubConfig ( server . url , server . accessToken , { signup : { enabled : true , requiresEmailVerification : true , limit : 0 } } ) await userLogin ( server , 0 ) } ) after ( async function ( ) { MockSmtpServer . Instance . kill ( ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { AccountBlock , ServerBlock , Video } from 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , flushTests , killallServers , ServerInfo , uploadVideo , userLogin } from 's' import { setAccessTokensToServers } from 's' import { getVideosListWithToken , getVideosList } from 's' import { addVideoCommentReply , addVideoCommentThread , getVideoCommentThreads , getVideoThreadComments } from 's' import { waitJobs } from 's' import { VideoComment , VideoCommentThreadTree } from 's' import { addAccountToAccountBlocklist , addAccountToServerBlocklist , addServerToAccountBlocklist , addServerToServerBlocklist , getAccountBlocklistByAccount , getAccountBlocklistByServer , getServerBlocklistByAccount , getServerBlocklistByServer , removeAccountFromAccountBlocklist , removeAccountFromServerBlocklist , removeServerFromAccountBlocklist , removeServerFromServerBlocklist } from 's' const expect = chai . expect async function checkAllVideos ( url , token ) { { const res = await getVideosListWithToken ( url , token ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await getVideosList ( url ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } async function checkAllComments ( url , token , videoUUID ) { const resThreads = await getVideoCommentThreads ( url , videoUUID , 0 , 0 , 's' , token ) const threads : VideoComment [ ] = resThreads . body . data expect ( threads ) . to . have . lengthOf ( 0 ) for ( const thread of threads ) { const res = await getVideoThreadComments ( url , videoUUID , thread . id , token ) const tree = res . body expect ( tree . children ) . to . have . lengthOf ( 0 ) } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] let 0 let 0 let 0 let userModeratorToken let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) 0 = await userLogin ( servers [ 0 ] , user ) await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' } ) } { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) userModeratorToken = await userLogin ( servers [ 0 ] , user ) } { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) 0 = await userLogin ( servers [ 0 ] , user ) await uploadVideo ( servers [ 0 ] . url , 0 , { name : 's' } ) } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const resComment = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 's' ) const resReply = await addVideoCommentReply ( servers [ 0 ] . url , 0 , 0 , resComment . body . comment . id , 's' ) await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , resReply . body . comment . id , 's' ) } { const resComment = await addVideoCommentThread ( servers [ 0 ] . url , 0 , 0 , 's' ) await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , resComment . body . comment . id , 's' ) } await waitJobs ( servers ) } ) describe ( 's' , function ( ) { describe ( 's' , function ( ) { it ( 's' , function ( ) { return checkAllVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) } ) it ( 's' , function ( ) { return checkAllComments ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) } ) it ( 's' , async function ( ) { await addAccountToAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . to . be . undefined } ) it ( 's' , async function ( ) { await addAccountToAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) } ) it ( 's' , async function ( ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . to . be . undefined } ) it ( 's' , async function ( ) { const resThreads = await getVideoCommentThreads ( servers [ 0 ] . url , 0 , 0 , 0 , 's' , servers [ 0 ] . accessToken ) const threads : VideoComment [ ] = resThreads . body . data expect ( threads ) . to . have . lengthOf ( 0 ) expect ( threads [ 0 ] . totalReplies ) . to . equal ( 0 ) const t = threads . find ( t => t . text === 's' ) expect ( t ) . to . be . undefined for ( const thread of threads ) { const res = await getVideoThreadComments ( servers [ 0 ] . url , 0 , thread . id , servers [ 0 ] . accessToken ) const tree = res . body expect ( tree . children ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { return checkAllVideos ( servers [ 0 ] . url , 0 ) } ) it ( 's' , async function ( ) { return checkAllComments ( servers [ 0 ] . url , 0 , 0 ) } ) it ( 's' , async function ( ) { { const res = await getAccountBlocklistByAccount ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : AccountBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . displayName ) . to . equal ( 's' ) expect ( block . blockedAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) } { const res = await getAccountBlocklistByAccount ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : AccountBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . displayName ) . to . equal ( 's' ) expect ( block . blockedAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) } } ) it ( 's' , async function ( ) { await removeAccountFromAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . not . to . be . undefined } ) it ( 's' , async function ( ) { await removeAccountFromAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) } ) it ( 's' , function ( ) { return checkAllComments ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , function ( ) { return checkAllVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) } ) it ( 's' , function ( ) { return checkAllComments ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) } ) it ( 's' , async function ( ) { await addServerToAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const 0 = videos . find ( v => v . name === 's' ) const 0 = videos . find ( v => v . name === 's' ) expect ( 0 ) . to . be . undefined expect ( 0 ) . to . be . undefined } ) it ( 's' , async function ( ) { return checkAllVideos ( servers [ 0 ] . url , 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { const res = await getServerBlocklistByAccount ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : ServerBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedServer . host ) . to . equal ( 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { await removeServerFromAccountBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , function ( ) { return checkAllVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) } ) it ( 's' , function ( ) { return checkAllComments ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) } ) } ) } ) describe ( 's' , function ( ) { describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllVideos ( servers [ 0 ] . url , token ) } } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllComments ( servers [ 0 ] . url , token , 0 ) } } ) it ( 's' , async function ( ) { await addAccountToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , token ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . to . be . undefined } } ) it ( 's' , async function ( ) { await addAccountToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , token ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . to . be . undefined } } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { const resThreads = await getVideoCommentThreads ( servers [ 0 ] . url , 0 , 0 , 0 , 's' , token ) const threads : VideoComment [ ] = resThreads . body . data expect ( threads ) . to . have . lengthOf ( 0 ) expect ( threads [ 0 ] . totalReplies ) . to . equal ( 0 ) const t = threads . find ( t => t . text === 's' ) expect ( t ) . to . be . undefined for ( const thread of threads ) { const res = await getVideoThreadComments ( servers [ 0 ] . url , 0 , thread . id , token ) const tree = res . body expect ( tree . children ) . to . have . lengthOf ( 0 ) } } } ) it ( 's' , async function ( ) { { const res = await getAccountBlocklistByServer ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : AccountBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . displayName ) . to . equal ( 's' ) expect ( block . blockedAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) } { const res = await getAccountBlocklistByServer ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : AccountBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . displayName ) . to . equal ( 's' ) expect ( block . blockedAccount . name ) . to . equal ( 's' ) expect ( block . blockedAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) } } ) it ( 's' , async function ( ) { await removeAccountFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { const res = await getVideosListWithToken ( servers [ 0 ] . url , token ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const v = videos . find ( v => v . name === 's' ) expect ( v ) . not . to . be . undefined } } ) it ( 's' , async function ( ) { await removeAccountFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllComments ( servers [ 0 ] . url , token , 0 ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllVideos ( servers [ 0 ] . url , token ) } } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllComments ( servers [ 0 ] . url , token , 0 ) } } ) it ( 's' , async function ( ) { await addServerToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { const 0 = await getVideosList ( servers [ 0 ] . url ) const 0 = await getVideosListWithToken ( servers [ 0 ] . url , token ) for ( const res of [ 0 , 0 ] ) { const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const 0 = videos . find ( v => v . name === 's' ) const 0 = videos . find ( v => v . name === 's' ) expect ( 0 ) . to . be . undefined expect ( 0 ) . to . be . undefined } } } ) it ( 's' ) it ( 's' , async function ( ) { const res = await getServerBlocklistByServer ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) const blocks : ServerBlock [ ] = res . body . data expect ( res . body . total ) . to . equal ( 0 ) const block = blocks [ 0 ] expect ( block . byAccount . displayName ) . to . equal ( 's' ) expect ( block . byAccount . name ) . to . equal ( 's' ) expect ( block . blockedServer . host ) . to . equal ( 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { await removeServerFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllVideos ( servers [ 0 ] . url , token ) } } ) it ( 's' , async function ( ) { for ( const token of [ userModeratorToken , servers [ 0 ] . accessToken ] ) { await checkAllComments ( servers [ 0 ] . url , token , 0 ) } } ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , follow , getVideosList , unfollow , updateVideo , userLogin } from 's' import { killallServers , ServerInfo , uploadVideo } from 's' import { setAccessTokensToServers } from 's' import { Video , VideoChannel } from 's' import { waitJobs } from 's' import { addUserSubscription , listUserSubscriptions , listUserSubscriptionVideos , removeUserSubscription , getUserSubscription , areSubscriptionsExist } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] const users : { accessToken : string } [ ] = [ ] let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { for ( const server of servers ) { const user = { username : 's' + server . serverNumber , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) const accessToken = await userLogin ( server , user ) users . push ( { accessToken } ) const 0 = 's' + server . serverNumber await uploadVideo ( server . url , accessToken , { name : 0 } ) const 0 = 's' + server . serverNumber await uploadVideo ( server . url , accessToken , { name : 0 } ) } } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await addUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) const res = await uploadVideo ( servers [ 0 ] . url , users [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) } } ) it ( 's' , async function ( ) { { const res = await listUserSubscriptions ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await listUserSubscriptions ( servers [ 0 ] . url , users [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const subscriptions : VideoChannel [ ] = res . body . data expect ( subscriptions ) . to . be . an ( 's' ) expect ( subscriptions ) . to . have . lengthOf ( 0 ) expect ( subscriptions [ 0 ] . name ) . to . equal ( 's' ) expect ( subscriptions [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { { const res = await getUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) const videoChannel = res . body expect ( videoChannel . name ) . to . equal ( 's' ) expect ( videoChannel . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( videoChannel . displayName ) . to . equal ( 's' ) expect ( videoChannel . followingCount ) . to . equal ( 0 ) expect ( videoChannel . followersCount ) . to . equal ( 0 ) } { const res = await getUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) const videoChannel = res . body expect ( videoChannel . name ) . to . equal ( 's' ) expect ( videoChannel . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( videoChannel . displayName ) . to . equal ( 's' ) expect ( videoChannel . followingCount ) . to . equal ( 0 ) expect ( videoChannel . followersCount ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const uris = [ 's' + servers [ 0 ] . port , 's' + servers [ 0 ] . port , 's' + servers [ 0 ] . port , 's' + servers [ 0 ] . port ] const res = await areSubscriptionsExist ( servers [ 0 ] . url , users [ 0 ] . accessToken , uris ) const body = res . body expect ( body [ 's' + servers [ 0 ] . port ] ) . to . be . true expect ( body [ 's' + servers [ 0 ] . port ] ) . to . be . false expect ( body [ 's' + servers [ 0 ] . port ] ) . to . be . true expect ( body [ 's' + servers [ 0 ] . port ] ) . to . be . false } ) it ( 's' , async function ( ) { { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoName = 's' await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : videoName } ) await waitJobs ( servers ) { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await follow ( servers [ 0 ] . url , [ servers [ 0 ] . url ] , servers [ 0 ] . accessToken ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) const names = [ 's' , 's' , 's' ] for ( const name of names ) { const video = res . body . data . find ( v => v . name . indexOf ( name ) === - 0 ) expect ( video ) . to . not . be . undefined } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) } } ) it ( 's' , async function ( ) { { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , users [ 0 ] . accessToken , 0 , { name : 's' } ) await waitJobs ( servers ) const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) const videos : Video [ ] = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addUserSubscription ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) { const res = await listUserSubscriptionVideos ( servers [ 0 ] . url , users [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) expect ( video . name ) . to . not . contain ( 's' ) } } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { User , UserRole , Video } from 's' import { blockUser , cleanupTests , createUser , deleteMe , flushAndRunServer , getAccountRatings , getBlacklistedVideosList , getMyUserInformation , getMyUserVideoQuotaUsed , getMyUserVideoRating , getUserInformation , getUsersList , getUsersListPaginationAndSort , getVideoChannel , getVideosList , installPlugin , login , makePutBodyRequest , rateVideo , registerUserWithChannel , removeUser , removeVideo , ServerInfo , testImage , unblockUser , updateMyAvatar , updateMyUser , updateUser , uploadVideo , userLogin } from 's' import { follow } from 's' import { setAccessTokensToServers } from 's' import { getMyVideos } from 's' import { UserAdminFlag } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server let accessToken let accessTokenUser let videoId let userId const user = { username : 's' , password : 's' } before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await installPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) } ) describe ( 's' , function ( ) { it ( 's' ) it ( 's' ) it ( 's' ) it ( 's' , async function ( ) { const client = { id : 's' , secret : server . client . secret } const res = await login ( server . url , client , server . user , 0 ) expect ( res . body . error ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const client = { id : server . client . id , secret : 's' } const res = await login ( server . url , client , server . user , 0 ) expect ( res . body . error ) . to . contain ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const user = { username : 's' , password : server . user . password } const res = await login ( server . url , server . client , user , 0 ) expect ( res . body . error ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const user = { username : server . user . username , password : 's' } const res = await login ( server . url , server . client , user , 0 ) expect ( res . body . error ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { accessToken = 's' const videoAttributes = { } await uploadVideo ( server . url , accessToken , videoAttributes , 0 ) } ) it ( 's' , async function ( ) { accessToken = 's' await follow ( server . url , [ 's' ] , accessToken , 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { const res = await login ( server . url , server . client , server . user , 0 ) accessToken = res . body . access_token } ) it ( 's' , async function ( ) { const user = { username : 's' , password : server . user . password } const res = await login ( server . url , server . client , user , 0 ) const 0 = { username : 's' , password : server . user . password } const 0 = await login ( server . url , server . client , 0 , 0 ) const 0 = { username : 's' , password : server . user . password } const 0 = await login ( server . url , server . client , 0 , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const videoAttributes = { } await uploadVideo ( server . url , accessToken , videoAttributes ) const res = await getVideosList ( server . url ) const video = res . body . data [ 0 ] expect ( video . account . name ) . to . equal ( 's' ) videoId = video . id } ) it ( 's' , async function ( ) { const videoAttributes = { } await uploadVideo ( server . url , accessToken , videoAttributes ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await rateVideo ( server . url , accessToken , videoId , 's' ) const res = await getMyUserVideoRating ( server . url , accessToken , videoId ) const rating = res . body expect ( rating . videoId ) . to . equal ( videoId ) expect ( rating . rating ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { await rateVideo ( server . url , accessToken , videoId , 's' ) const res = await getAccountRatings ( server . url , server . user . username , server . accessToken , null , 0 ) const ratings = res . body expect ( ratings . total ) . to . equal ( 0 ) expect ( ratings . data [ 0 ] . video . id ) . to . equal ( videoId ) expect ( ratings . data [ 0 ] . rating ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await getAccountRatings ( server . url , server . user . username , server . accessToken , 's' ) const ratings = res . body expect ( ratings . data . length ) . to . equal ( 0 ) } { const res = await getAccountRatings ( server . url , server . user . username , server . accessToken , 's' ) const ratings = res . body expect ( ratings . data . length ) . to . equal ( 0 ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await removeVideo ( server . url , 's' , videoId , 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { await removeVideo ( server . url , accessToken , videoId ) } ) } ) describe ( 's' , function ( ) { it ( 's' ) it ( 's' ) it ( 's' ) it ( 's' ) it ( 's' , async function ( ) { const path = 's' const data = { rating : 's' } const options = { url : server . url , path : path + videoId , token : 's' , fields : data , statusCodeExpected : 0 } await makePutBodyRequest ( options ) } ) it ( 's' ) it ( 's' ) it ( 's' ) it ( 's' ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await createUser ( { url : server . url , accessToken : accessToken , username : user . username , password : user . password , videoQuota : 0 * 0 * 0 , adminFlags : UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST } ) } ) it ( 's' , async function ( ) { accessTokenUser = await userLogin ( server , user ) } ) it ( 's' , async function ( ) { const 0 = await getMyUserInformation ( server . url , accessTokenUser ) const userMe = 0 . body const 0 = await getUserInformation ( server . url , server . accessToken , userMe . id ) const userGet = 0 . body for ( const user of [ userMe , userGet ] ) { expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) expect ( user . roleLabel ) . to . equal ( 's' ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . be . null } expect ( userMe . adminFlags ) . to . be . undefined expect ( userGet . adminFlags ) . to . equal ( UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , fixture : 's' } await uploadVideo ( server . url , accessTokenUser , videoAttributes ) } ) it ( 's' , async function ( ) { const res = await getMyUserVideoQuotaUsed ( server . url , accessTokenUser ) const data = res . body expect ( data . videoQuotaUsed ) . to . equal ( 0 ) const resUsers = await getUsersList ( server . url , server . accessToken ) const users : User [ ] = resUsers . body . data const tmpUser = users . find ( u => u . username === user . username ) expect ( tmpUser . videoQuotaUsed ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getMyVideos ( server . url , accessTokenUser , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const video = videos [ 0 ] expect ( video . name ) . to . equal ( 's' ) expect ( video . thumbnailPath ) . to . not . be . null expect ( video . previewPath ) . to . not . be . null } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await getUsersList ( server . url , server . accessToken ) const result = res . body const total = result . total const users = result . data expect ( total ) . to . equal ( 0 ) expect ( users ) . to . be . an ( 's' ) expect ( users . length ) . to . equal ( 0 ) const user = users [ 0 ] expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) const rootUser = users [ 0 ] expect ( rootUser . username ) . to . equal ( 's' ) expect ( rootUser . email ) . to . equal ( 's' + server . internalServerNumber + 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) userId = user . id } ) it ( 's' , async function ( ) { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' ) const result = res . body const total = result . total const users = result . data expect ( total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) const user = users [ 0 ] expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' + server . internalServerNumber + 's' ) expect ( user . roleLabel ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' ) const result = res . body const total = result . total const users = result . data expect ( total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) const user = users [ 0 ] expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' ) const result = res . body const total = result . total const users = result . data expect ( total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) const user = users [ 0 ] expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' ) const result = res . body const total = result . total const users = result . data expect ( total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) expect ( users [ 0 ] . email ) . to . equal ( 's' + server . internalServerNumber + 's' ) expect ( users [ 0 ] . nsfwPolicy ) . to . equal ( 's' ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) expect ( users [ 0 ] . email ) . to . equal ( 's' ) expect ( users [ 0 ] . nsfwPolicy ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' , 's' ) const users = res . body . data as User [ ] expect ( res . body . total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' , 's' ) const users = res . body . data as User [ ] expect ( res . body . total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) expect ( users [ 0 ] . email ) . to . equal ( 's' ) } { const res = await getUsersListPaginationAndSort ( server . url , server . accessToken , 0 , 0 , 's' , 's' ) const users = res . body . data as User [ ] expect ( res . body . total ) . to . equal ( 0 ) expect ( users . length ) . to . equal ( 0 ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) expect ( users [ 0 ] . username ) . to . equal ( 's' ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , currentPassword : 's' , password : 's' } ) user . password = 's' await userLogin ( server , user , 0 ) } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , nsfwPolicy : 's' } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . be . null } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , autoPlayVideo : false } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . autoPlayVideo ) . to . be . false } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , autoPlayNextVideo : true } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . autoPlayNextVideo ) . to . be . true } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , currentPassword : 's' , email : 's' } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . be . null } ) it ( 's' , async function ( ) { const fixture = 's' await updateMyAvatar ( { url : server . url , accessToken : accessTokenUser , fixture } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body await testImage ( server . url , 's' , user . account . avatar . path , 's' ) } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , displayName : 's' } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . be . null } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , description : 's' } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . equal ( 's' ) expect ( user . noWelcomeModal ) . to . be . false expect ( user . noInstanceConfigWarningModal ) . to . be . false } ) it ( 's' , async function ( ) { for ( const theme of [ 's' , 's' , 's' ] ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , theme } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const body = res . body expect ( body . theme ) . to . equal ( theme ) } } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : accessTokenUser , noInstanceConfigWarningModal : true , noWelcomeModal : true } ) const res = await getMyUserInformation ( server . url , accessTokenUser ) const user = res . body expect ( user . noWelcomeModal ) . to . be . true expect ( user . noInstanceConfigWarningModal ) . to . be . true } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId , accessToken , email : 's' , emailVerified : true , videoQuota : 0 , role : UserRole . MODERATOR , adminFlags : UserAdminFlag . NONE } ) const res = await getUserInformation ( server . url , accessToken , userId ) const user = res . body expect ( user . username ) . to . equal ( 's' ) expect ( user . email ) . to . equal ( 's' ) expect ( user . emailVerified ) . to . be . true expect ( user . nsfwPolicy ) . to . equal ( 's' ) expect ( user . videoQuota ) . to . equal ( 0 ) expect ( user . roleLabel ) . to . equal ( 's' ) expect ( user . id ) . to . be . a ( 's' ) expect ( user . adminFlags ) . to . equal ( UserAdminFlag . NONE ) } ) it ( 's' , async function ( ) { await getMyUserVideoQuotaUsed ( server . url , accessTokenUser , 0 ) accessTokenUser = await userLogin ( server , user ) } ) it ( 's' , async function ( ) { await updateUser ( { url : server . url , userId , accessToken , password : 's' } ) await getMyUserVideoQuotaUsed ( server . url , accessTokenUser , 0 ) await userLogin ( server , user , 0 ) user . password = 's' accessTokenUser = await userLogin ( server , user ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await getBlacklistedVideosList ( { url : server . url , token : accessTokenUser } ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await removeUser ( server . url , userId , accessToken ) } ) it ( 's' , async function ( ) { await userLogin ( server , user , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const video = res . body . data [ 0 ] expect ( video . account . name ) . to . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const user = { displayName : 's' , username : 's' , password : 's' } const channel = { name : 's' , displayName : 's' } await registerUserWithChannel ( { url : server . url , user , channel } ) } ) it ( 's' , async function ( ) { const 0 = { username : 's' , password : 's' } accessToken = await userLogin ( server , 0 ) } ) it ( 's' , async function ( ) { const res = await getMyUserInformation ( server . url , accessToken ) const user = res . body expect ( user . account . displayName ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getMyUserInformation ( server . url , accessToken ) const user = res . body expect ( user . videoQuota ) . to . equal ( 0 * 0 * 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoChannel ( server . url , 's' ) expect ( res . body . displayName ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await getUsersList ( server . url , server . accessToken ) expect ( res . body . data . find ( u => u . username === 's' ) ) . to . not . be . undefined } await deleteMe ( server . url , accessToken ) { const res = await getUsersList ( server . url , server . accessToken ) expect ( res . body . data . find ( u => u . username === 's' ) ) . to . be . undefined } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const 0 = { username : 's' , password : 's' } const resUser = await createUser ( { url : server . url , accessToken : server . accessToken , username : 0 . username , password : 0 . password } ) const 0 = resUser . body . user . id accessToken = await userLogin ( server , 0 ) await getMyUserInformation ( server . url , accessToken , 0 ) await blockUser ( server . url , 0 , server . accessToken ) await getMyUserInformation ( server . url , accessToken , 0 ) await userLogin ( server , 0 , 0 ) await unblockUser ( server . url , 0 , server . accessToken ) accessToken = await userLogin ( server , 0 ) await getMyUserInformation ( server . url , accessToken , 0 ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { Account } from 's' import { checkTmpIsEmpty , checkVideoFilesWereRemoved , cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , getAccountVideos , getVideoChannelsList , removeUser , updateMyUser , userLogin } from 's' import { getMyUserInformation , ServerInfo , testImage , updateMyAvatar , uploadVideo } from 's' import { checkActorFilesWereRemoved , getAccount , getAccountsList } from 's' import { setAccessTokensToServers } from 's' import { User } from 's' import { VideoChannel } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let user let userId let videoUUID let userAccessToken let userAvatarFilename before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { } ) { const user = { username : 's' , password : 's' } const res = await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) userId = res . body . user . id userAccessToken = await userLogin ( servers [ 0 ] , user ) } { const resVideo = await uploadVideo ( servers [ 0 ] . url , userAccessToken , { } ) videoUUID = resVideo . body . video . uuid } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , displayName : 's' } ) const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) user = res . body const account = user . account expect ( user . account . displayName ) . to . equal ( 's' ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateMyUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , description : 's' } ) const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) user = res . body expect ( user . account . displayName ) . to . equal ( 's' ) expect ( user . account . description ) . to . equal ( 's' ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const fixture = 's' await updateMyAvatar ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , fixture } ) const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) user = res . body userAvatarFilename = user . account . avatar . path await testImage ( servers [ 0 ] . url , 's' , userAvatarFilename , 's' ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const resAccounts = await getAccountsList ( server . url , 's' ) const 0 = resAccounts . body . data . find ( a => a . name === 's' && a . host === 's' + servers [ 0 ] . port ) as Account expect ( 0 ) . not . to . be . undefined const resAccount = await getAccount ( server . url , 0 . name + 's' + 0 . host ) const 0 = resAccount . body as Account expect ( 0 . name ) . to . equal ( 's' ) expect ( 0 . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( 0 . displayName ) . to . equal ( 's' ) expect ( 0 . description ) . to . equal ( 's' ) if ( server . serverNumber === 0 ) { expect ( 0 . userId ) . to . be . a ( 's' ) } else { expect ( 0 . userId ) . to . be . undefined } await testImage ( server . url , 's' , 0 . avatar . path , 's' ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getAccountVideos ( server . url , server . accessToken , 's' + servers [ 0 ] . port , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . uuid ) . to . equal ( videoUUID ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const resAccounts = await getAccountsList ( server . url , 's' ) const accountDeleted = resAccounts . body . data . find ( a => a . name === 's' && a . host === 's' + servers [ 0 ] . port ) as Account expect ( accountDeleted ) . not . to . be . undefined const resVideoChannels = await getVideoChannelsList ( server . url , 0 , 0 ) const videoChannelDeleted = resVideoChannels . body . data . find ( a => { return a . displayName === 's' && a . host === 's' + servers [ 0 ] . port } ) as VideoChannel expect ( videoChannelDeleted ) . not . to . be . undefined } await removeUser ( servers [ 0 ] . url , userId , servers [ 0 ] . accessToken ) await waitJobs ( servers ) for ( const server of servers ) { const resAccounts = await getAccountsList ( server . url , 's' ) const accountDeleted = resAccounts . body . data . find ( a => a . name === 's' && a . host === 's' + servers [ 0 ] . port ) as Account expect ( accountDeleted ) . to . be . undefined const resVideoChannels = await getVideoChannelsList ( server . url , 0 , 0 ) const videoChannelDeleted = resVideoChannels . body . data . find ( a => { return a . name === 's' && a . host === 's' + servers [ 0 ] . port } ) as VideoChannel expect ( videoChannelDeleted ) . to . be . undefined } } ) it ( 's' , async ( ) => { for ( const server of servers ) { await checkActorFilesWereRemoved ( userAvatarFilename , server . internalServerNumber ) } } ) it ( 's' , async ( ) => { for ( const server of servers ) { await checkVideoFilesWereRemoved ( videoUUID , server . internalServerNumber ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { await checkTmpIsEmpty ( server ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O $number$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O
import * as chai from 's' import 's' import { join } from 's' import * as request from 's' import { VideoPrivacy } from 's' import { VideoComment , VideoCommentThreadTree } from 's' import { addVideoChannel , checkTmpIsEmpty , checkVideoFilesWereRemoved , cleanupTests , completeVideoCheck , createUser , dateIsValid , doubleFollow , flushAndRunMultipleServers , getLocalVideos , getVideo , getVideoChannelsList , getVideosList , rateVideo , removeVideo , ServerInfo , setAccessTokensToServers , testImage , updateVideo , uploadVideo , userLogin , viewVideo , wait , webtorrentAdd } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getVideoCommentThreads , getVideoThreadComments } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] const toRemove = [ ] let videoUUID = 's' let videoChannelId before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const videoChannel = { name : 's' , displayName : 's' , description : 's' } await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoChannel ) const channelRes = await getVideoChannelsList ( servers [ 0 ] . url , 0 , 0 ) videoChannelId = channelRes . body . data [ 0 ] . id } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , originallyPublishedAt : 's' , tags : [ 's' , 's' ] , channelId : videoChannelId , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) let publishedAt = null for ( const server of servers ) { const isLocal = server . port === servers [ 0 ] . port const checkAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , originallyPublishedAt : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , publishedAt , duration : 0 , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , commentsEnabled : true , downloadEnabled : true , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) const video = videos [ 0 ] await completeVideoCheck ( server . url , video , checkAttributes ) publishedAt = video . publishedAt } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) const userAccessToken = await userLogin ( servers [ 0 ] , user ) const videoAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , tags : [ 's' , 's' , 's' ] , fixture : 's' , thumbnailfile : 's' , previewfile : 's' } await uploadVideo ( servers [ 0 ] . url , userAccessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const isLocal = server . url === 's' + servers [ 0 ] . port const checkAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , commentsEnabled : true , downloadEnabled : true , duration : 0 , tags : [ 's' , 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } ] , thumbnailfile : 's' , previewfile : 's' } const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) const video = videos [ 0 ] await completeVideoCheck ( server . url , video , checkAttributes ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const 0 = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , tags : [ 's' ] , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) const 0 = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , description : 's' , support : 's' , tags : [ 's' , 's' , 's' ] , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) for ( const server of servers ) { const isLocal = server . url === 's' + servers [ 0 ] . port const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) let 0 = null let 0 = null if ( videos [ 0 ] . name === 's' ) { 0 = videos [ 0 ] 0 = videos [ 0 ] } else { 0 = videos [ 0 ] 0 = videos [ 0 ] } const 0 = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , duration : 0 , commentsEnabled : true , downloadEnabled : true , tags : [ 's' ] , privacy : VideoPrivacy . PUBLIC , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } await completeVideoCheck ( server . url , 0 , 0 ) const 0 = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , description : 's' , support : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , commentsEnabled : true , downloadEnabled : true , isLocal , duration : 0 , tags : [ 's' , 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } await completeVideoCheck ( server . url , 0 , 0 ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const { body } = await getLocalVideos ( servers [ 0 ] . url ) expect ( body . total ) . to . equal ( 0 ) expect ( body . data ) . to . be . an ( 's' ) expect ( body . data . length ) . to . equal ( 0 ) expect ( body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const { body } = await getLocalVideos ( servers [ 0 ] . url ) expect ( body . total ) . to . equal ( 0 ) expect ( body . data ) . to . be . an ( 's' ) expect ( body . data . length ) . to . equal ( 0 ) expect ( body . data [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const { body } = await getLocalVideos ( servers [ 0 ] . url ) expect ( body . total ) . to . equal ( 0 ) expect ( body . data ) . to . be . an ( 's' ) expect ( body . data . length ) . to . equal ( 0 ) expect ( body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( body . data [ 0 ] . name ) . to . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( servers [ 0 ] . url ) const video = res . body . data [ 0 ] toRemove . push ( res . body . data [ 0 ] ) toRemove . push ( res . body . data [ 0 ] ) const 0 = await getVideo ( servers [ 0 ] . url , video . id ) const videoDetails = 0 . body const torrent = await webtorrentAdd ( videoDetails . files [ 0 ] . magnetUri , true ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . to . exist . and . to . not . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( servers [ 0 ] . url ) const video = res . body . data [ 0 ] const 0 = await getVideo ( servers [ 0 ] . url , video . id ) const videoDetails = 0 . body const torrent = await webtorrentAdd ( videoDetails . files [ 0 ] . magnetUri , true ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . to . exist . and . to . not . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( servers [ 0 ] . url ) const video = res . body . data [ 0 ] const 0 = await getVideo ( servers [ 0 ] . url , video . id ) const videoDetails = 0 . body const torrent = await webtorrentAdd ( videoDetails . files [ 0 ] . magnetUri , true ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . to . exist . and . to . not . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( servers [ 0 ] . url ) const video = res . body . data [ 0 ] const 0 = await getVideo ( servers [ 0 ] . url , video . id ) const videoDetails = 0 . body const torrent = await webtorrentAdd ( videoDetails . files [ 0 ] . magnetUri ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . to . exist . and . to . not . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( servers [ 0 ] . url ) const video = res . body . data . find ( v => v . name === 's' ) const 0 = await getVideo ( servers [ 0 ] . url , video . id ) const videoDetails = 0 . body const file = videoDetails . files . find ( f => f . resolution . id === 0 ) expect ( file ) . not . to . be . undefined const torrent = await webtorrentAdd ( file . magnetUri ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . to . exist . and . to . not . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { let 0 = [ ] let 0 = [ ] let 0 = [ ] let 0 = [ ] before ( async function ( ) { const 0 = await getVideosList ( servers [ 0 ] . url ) 0 = 0 . body . data . filter ( video => video . isLocal === false ) . map ( video => video . uuid ) const 0 = await getVideosList ( servers [ 0 ] . url ) 0 = 0 . body . data . filter ( video => video . isLocal === false ) . map ( video => video . uuid ) const 0 = await getVideosList ( servers [ 0 ] . url ) 0 = 0 . body . data . filter ( video => video . isLocal === true ) . map ( video => video . uuid ) 0 = 0 . body . data . filter ( video => video . isLocal === false ) . map ( video => video . uuid ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await wait ( 0 ) await viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await wait ( 0 ) await viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) await waitJobs ( servers ) await wait ( 0 ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data const 0 = videos . find ( v => v . uuid === 0 [ 0 ] ) const 0 = videos . find ( v => v . uuid === 0 [ 0 ] ) expect ( 0 . views ) . to . equal ( 0 ) expect ( 0 . views ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const tasks : Promise < any > [ ] = [ ] tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) tasks . push ( viewVideo ( servers [ 0 ] . url , 0 [ 0 ] ) ) await Promise . all ( tasks ) await waitJobs ( servers ) await wait ( 0 ) let baseVideos = null for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data if ( baseVideos === null ) { baseVideos = videos continue } for ( const baseVideo of baseVideos ) { const sameVideo = videos . find ( video => video . name === baseVideo . name ) expect ( baseVideo . views ) . to . equal ( sameVideo . views ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await wait ( 0 ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await wait ( 0 ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await wait ( 0 ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await wait ( 0 ) await rateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 [ 0 ] , 's' ) await waitJobs ( servers ) let baseVideos = null for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data if ( baseVideos === null ) { baseVideos = videos continue } for ( const baseVideo of baseVideos ) { const sameVideo = videos . find ( video => video . name === baseVideo . name ) expect ( baseVideo . likes ) . to . equal ( sameVideo . likes ) expect ( baseVideo . dislikes ) . to . equal ( sameVideo . dislikes ) } } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , tags : [ 's' , 's' ] , thumbnailfile : 's' , originallyPublishedAt : 's' , previewfile : 's' } await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , toRemove [ 0 ] . id , attributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data const videoUpdated = videos . find ( video => video . name === 's' ) expect ( ! ! videoUpdated ) . to . be . true const isLocal = server . url === 's' + servers [ 0 ] . port const checkAttributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , originallyPublishedAt : 's' , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , duration : 0 , commentsEnabled : true , downloadEnabled : true , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] , thumbnailfile : 's' , previewfile : 's' } await completeVideoCheck ( server . url , videoUpdated , checkAttributes ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , toRemove [ 0 ] . id ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , toRemove [ 0 ] . id ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { await checkVideoFilesWereRemoved ( toRemove [ 0 ] . uuid , server . serverNumber ) await checkVideoFilesWereRemoved ( toRemove [ 0 ] . uuid , server . serverNumber ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . not . to . equal ( videos [ 0 ] . name ) expect ( videos [ 0 ] . name ) . not . to . equal ( toRemove [ 0 ] . name ) expect ( videos [ 0 ] . name ) . not . to . equal ( toRemove [ 0 ] . name ) expect ( videos [ 0 ] . name ) . not . to . equal ( toRemove [ 0 ] . name ) expect ( videos [ 0 ] . name ) . not . to . equal ( toRemove [ 0 ] . name ) videoUUID = videos . find ( video => video . name === 's' ) . uuid } } ) it ( 's' , async function ( ) { let baseVideo = null for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body if ( baseVideo === null ) { baseVideo = video continue } expect ( baseVideo . name ) . to . equal ( video . name ) expect ( baseVideo . uuid ) . to . equal ( video . uuid ) expect ( baseVideo . category . id ) . to . equal ( video . category . id ) expect ( baseVideo . language . id ) . to . equal ( video . language . id ) expect ( baseVideo . licence . id ) . to . equal ( video . licence . id ) expect ( baseVideo . nsfw ) . to . equal ( video . nsfw ) expect ( baseVideo . account . name ) . to . equal ( video . account . name ) expect ( baseVideo . account . displayName ) . to . equal ( video . account . displayName ) expect ( baseVideo . account . url ) . to . equal ( video . account . url ) expect ( baseVideo . account . host ) . to . equal ( video . account . host ) expect ( baseVideo . tags ) . to . deep . equal ( video . tags ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body await testImage ( server . url , 's' , video . previewPath ) } } ) } ) describe ( 's' , function ( ) { let childOfFirstChild it ( 's' , async function ( ) { this . timeout ( 0 ) { const text = 's' await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , text ) } { const text = 's' await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , text ) } await waitJobs ( servers ) { const res = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) const threadId = res . body . data . find ( c => c . text === 's' ) . id const text = 's' await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId , text ) } await waitJobs ( servers ) { const 0 = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) const threadId = 0 . body . data . find ( c => c . text === 's' ) . id const 0 = await getVideoThreadComments ( servers [ 0 ] . url , videoUUID , threadId ) const childCommentId = 0 . body . children [ 0 ] . comment . id const 0 = 's' await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId , 0 ) const 0 = 's' await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , childCommentId , 0 ) } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) { const comment = res . body . data . find ( c => c . text === 's' ) expect ( comment ) . to . not . be . undefined expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true } { const comment = res . body . data . find ( c => c . text === 's' ) expect ( comment ) . to . not . be . undefined expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true } } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const 0 = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) const threadId = 0 . body . data . find ( c => c . text === 's' ) . id const 0 = await getVideoThreadComments ( server . url , videoUUID , threadId ) const tree = 0 . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . comment . account . name ) . equal ( 's' ) expect ( tree . comment . account . host ) . equal ( 's' + servers [ 0 ] . port ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . comment . account . name ) . equal ( 's' ) expect ( firstChild . comment . account . host ) . equal ( 's' + servers [ 0 ] . port ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . comment . account . name ) . equal ( 's' ) expect ( childOfFirstChild . comment . account . host ) . equal ( 's' + servers [ 0 ] . port ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) const secondChild = tree . children [ 0 ] expect ( secondChild . comment . text ) . to . equal ( 's' ) expect ( secondChild . comment . account . name ) . equal ( 's' ) expect ( secondChild . comment . account . host ) . equal ( 's' + servers [ 0 ] . port ) expect ( secondChild . children ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteVideoComment ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , childOfFirstChild . comment . id ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const 0 = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) const threadId = 0 . body . data . find ( c => c . text === 's' ) . id const 0 = await getVideoThreadComments ( server . url , videoUUID , threadId ) const tree = 0 . body expect ( tree . comment . text ) . equal ( 's' ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const secondChild = tree . children [ 0 ] expect ( secondChild . comment . text ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) const threadId = res . body . data . find ( c => c . text === 's' ) . id await deleteVideoComment ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) { const comment = res . body . data [ 0 ] expect ( comment ) . to . not . be . undefined expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true } } } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) const threadId = res . body . data . find ( c => c . text === 's' ) . id await deleteVideoComment ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { commentsEnabled : false , downloadEnabled : false } await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , attributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) expect ( res . body . commentsEnabled ) . to . be . false expect ( res . body . downloadEnabled ) . to . be . false const text = 's' await addVideoCommentThread ( server . url , server . accessToken , videoUUID , text , 0 ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const path = 's' const req = request ( servers [ 0 ] . url ) . post ( path ) . set ( 's' , 's' ) . set ( 's' , 's' + servers [ 0 ] . accessToken ) . field ( 's' , 's' ) . field ( 's' , 's' ) . field ( 's' , 's' ) const filePath = join ( __dirname , 's' , 's' , 's' , 's' ) await req . attach ( 's' , filePath ) . expect ( 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === 's' ) const isLocal = server . url === 's' + servers [ 0 ] . port const checkAttributes = { name : 's' , category : null , licence : null , language : null , nsfw : false , description : null , support : null , account : { name : 's' , host : 's' + servers [ 0 ] . port } , isLocal , duration : 0 , commentsEnabled : true , downloadEnabled : true , tags : [ ] , privacy : VideoPrivacy . PUBLIC , channel : { displayName : 's' , name : 's' , description : 's' , isLocal } , fixture : 's' , files : [ { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } , { resolution : 0 , size : 0 } ] } await completeVideoCheck ( server . url , video , checkAttributes ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const server of servers ) { await checkTmpIsEmpty ( server ) } } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { getOEmbed , getVideosList , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { cleanupTests , flushAndRunServer } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const videoAttributes = { name : 's' } await uploadVideo ( server . url , server . accessToken , videoAttributes ) const res = await getVideosList ( server . url ) server . video = res . body . data [ 0 ] } ) it ( 's' , async function ( ) { const oembedUrl = 's' + server . port + 's' + server . video . uuid const res = await getOEmbed ( server . url , oembedUrl ) const expectedHtml = 's' + `template` + 's' const expectedThumbnailUrl = 's' + server . port + 's' + server . video . uuid + 's' expect ( res . body . html ) . to . equal ( expectedHtml ) expect ( res . body . title ) . to . equal ( server . video . name ) expect ( res . body . author_name ) . to . equal ( server . video . account . name ) expect ( res . body . width ) . to . equal ( 0 ) expect ( res . body . height ) . to . equal ( 0 ) expect ( res . body . thumbnail_url ) . to . equal ( expectedThumbnailUrl ) expect ( res . body . thumbnail_width ) . to . equal ( 0 ) expect ( res . body . thumbnail_height ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const oembedUrl = 's' + server . port + 's' + server . video . uuid const format = 's' const maxHeight = 0 const maxWidth = 0 const res = await getOEmbed ( server . url , oembedUrl , format , maxHeight , maxWidth ) const expectedHtml = 's' + `template` + 's' expect ( res . body . html ) . to . equal ( expectedHtml ) expect ( res . body . title ) . to . equal ( server . video . name ) expect ( res . body . author_name ) . to . equal ( server . video . account . name ) expect ( res . body . height ) . to . equal ( 0 ) expect ( res . body . width ) . to . equal ( 0 ) expect ( res . body ) . to . not . have . property ( 's' ) expect ( res . body ) . to . not . have . property ( 's' ) expect ( res . body ) . to . not . have . property ( 's' ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import { keyBy } from 's' import 's' import { VideoPrivacy } from 's' import { checkVideoFilesWereRemoved , cleanupTests , completeVideoCheck , flushAndRunServer , getVideo , getVideoCategories , getVideoLanguages , getVideoLicences , getVideoPrivacies , getVideosList , getVideosListPagination , getVideosListSort , getVideosWithFilters , rateVideo , removeVideo , ServerInfo , setAccessTokensToServers , testImage , updateVideo , uploadVideo , viewVideo , wait } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null let videoId = - 0 let videoUUID = 's' let videosListBase : any [ ] = null const getCheckAttributes = ( ) => ( { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , description : 's' , support : 's' , account : { name : 's' , host : 's' + server . port } , isLocal : true , duration : 0 , tags : [ 's' , 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , commentsEnabled : true , downloadEnabled : true , channel : { displayName : 's' , name : 's' , description : 's' , isLocal : true } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } ) const updateCheckAttributes = ( ) => ( { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , description : 's' , support : 's' , account : { name : 's' , host : 's' + server . port } , isLocal : true , tags : [ 's' , 's' ] , privacy : VideoPrivacy . PUBLIC , duration : 0 , commentsEnabled : false , downloadEnabled : false , channel : { name : 's' , displayName : 's' , description : 's' , isLocal : true } , fixture : 's' , files : [ { resolution : 0 , size : 0 } ] } ) before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { const res = await getVideoCategories ( server . url ) const categories = res . body expect ( Object . keys ( categories ) ) . to . have . length . above ( 0 ) expect ( categories [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoLicences ( server . url ) const licences = res . body expect ( Object . keys ( licences ) ) . to . have . length . above ( 0 ) expect ( licences [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoLanguages ( server . url ) const languages = res . body expect ( Object . keys ( languages ) ) . to . have . length . above ( 0 ) expect ( languages [ 's' ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoPrivacies ( server . url ) const privacies = res . body expect ( Object . keys ( privacies ) ) . to . have . length . at . least ( 0 ) expect ( privacies [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const videoAttributes = { name : 's' , category : 0 , nsfw : true , licence : 0 , tags : [ 's' , 's' , 's' ] } const res = await uploadVideo ( server . url , server . accessToken , videoAttributes ) expect ( res . body . video ) . to . not . be . undefined expect ( res . body . video . id ) . to . equal ( 0 ) expect ( res . body . video . uuid ) . to . have . length . above ( 0 ) videoId = res . body . video . id videoUUID = res . body . video . uuid } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) const video = res . body . data [ 0 ] await completeVideoCheck ( server . url , video , getCheckAttributes ( ) ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideo ( server . url , videoUUID ) const video = res . body await completeVideoCheck ( server . url , video , getCheckAttributes ( ) ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await viewVideo ( server . url , videoId ) await viewVideo ( server . url , videoId ) await viewVideo ( server . url , videoId ) await wait ( 0 ) await viewVideo ( server . url , videoId ) await viewVideo ( server . url , videoId ) await wait ( 0 ) await viewVideo ( server . url , videoId ) await viewVideo ( server . url , videoId ) await wait ( 0 ) const res = await getVideo ( server . url , videoId ) const video = res . body expect ( video . views ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await removeVideo ( server . url , server . accessToken , videoId ) await checkVideoFilesWereRemoved ( videoUUID , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videos = [ 's' , 's' , 's' , 's' , 's' , 's' ] const tasks : Promise < any > [ ] = [ ] for ( const video of videos ) { const videoAttributes = { name : video + 's' , description : video + 's' , category : 0 , licence : 0 , language : 's' , nsfw : true , tags : [ 's' , 's' , 's' ] , fixture : video } const p = uploadVideo ( server . url , server . accessToken , videoAttributes ) tasks . push ( p ) } await Promise . all ( tasks ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) const videosByName = keyBy < { duration : number } > ( videos , 's' ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) expect ( videosByName [ 's' ] . duration ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) const videos = res . body . data videosListBase = videos for ( const video of videos ) { const videoName = video . name . replace ( 's' , 's' ) await testImage ( server . url , videoName , video . thumbnailPath ) } } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( server . url , 0 , 0 , 's' ) const videos = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( server . url , 0 , 0 , 's' ) const videos = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( server . url , 0 , 0 , 's' ) const videos = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( videosListBase [ 0 ] . name ) } ) it ( 's' , async function ( ) { const res = await getVideosListSort ( server . url , 's' ) const videos = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) videoId = videos [ 0 ] . uuid } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( server . url , 0 , 0 , 's' ) const videos = res . body . data expect ( res . body . total ) . to . equal ( 0 ) expect ( videos . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const attributes = { name : 's' , category : 0 , licence : 0 , language : 's' , nsfw : false , description : 's' , commentsEnabled : false , downloadEnabled : false , tags : [ 's' , 's' ] } await updateVideo ( server . url , server . accessToken , videoId , attributes ) } ) it ( 's' , async function ( ) { const 0 = await getVideosWithFilters ( server . url , { tagsAllOf : [ 's' , 's' ] , categoryOneOf : 0 } ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data [ 0 ] . name ) . to . equal ( 's' ) const 0 = await getVideosWithFilters ( server . url , { tagsAllOf : [ 's' , 's' ] , categoryOneOf : 0 } ) expect ( 0 . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideo ( server . url , videoId ) const video = res . body await completeVideoCheck ( server . url , video , updateCheckAttributes ( ) ) } ) it ( 's' , async function ( ) { const attributes = { tags : [ 's' , 's' , 's' ] } await updateVideo ( server . url , server . accessToken , videoId , attributes ) const res = await getVideo ( server . url , videoId ) const video = res . body await completeVideoCheck ( server . url , video , Object . assign ( updateCheckAttributes ( ) , attributes ) ) } ) it ( 's' , async function ( ) { const attributes = { description : 's' } await updateVideo ( server . url , server . accessToken , videoId , attributes ) const res = await getVideo ( server . url , videoId ) const video = res . body const expectedAttributes = Object . assign ( updateCheckAttributes ( ) , { tags : [ 's' , 's' , 's' ] } , attributes ) await completeVideoCheck ( server . url , video , expectedAttributes ) } ) it ( 's' , async function ( ) { await rateVideo ( server . url , server . accessToken , videoId , 's' ) const res = await getVideo ( server . url , videoId ) const video = res . body expect ( video . likes ) . to . equal ( 0 ) expect ( video . dislikes ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await rateVideo ( server . url , server . accessToken , videoId , 's' ) const res = await getVideo ( server . url , videoId ) const video = res . body expect ( video . likes ) . to . equal ( 0 ) expect ( video . dislikes ) . to . equal ( 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoAbuse , VideoAbuseState } from 's' import { cleanupTests , deleteVideoAbuse , flushAndRunMultipleServers , getVideoAbusesList , getVideosList , reportVideoAbuse , ServerInfo , setAccessTokensToServers , updateVideoAbuse , uploadVideo } from 's' import { doubleFollow } from 's' import { waitJobs } from 's' import { addAccountToServerBlocklist , addServerToServerBlocklist , removeAccountFromServerBlocklist , removeServerFromServerBlocklist } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const 0 = { name : 's' , description : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) const 0 = { name : 's' , description : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) const videos = res . body . data expect ( videos . length ) . to . equal ( 0 ) servers [ 0 ] . video = videos . find ( video => video . name === 's' ) servers [ 0 ] . video = videos . find ( video => video . name === 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const reason = 's' await reportVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . video . id , reason ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const 0 = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data . length ) . to . equal ( 0 ) const abuse = 0 . body . data [ 0 ] expect ( abuse . reason ) . to . equal ( 's' ) expect ( abuse . reporterAccount . name ) . to . equal ( 's' ) expect ( abuse . reporterAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( abuse . video . id ) . to . equal ( servers [ 0 ] . video . id ) const 0 = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const reason = 's' await reportVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . video . id , reason ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const 0 = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data . length ) . to . equal ( 0 ) const 0 = 0 . body . data [ 0 ] expect ( 0 . reason ) . to . equal ( 's' ) expect ( 0 . reporterAccount . name ) . to . equal ( 's' ) expect ( 0 . reporterAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( 0 . video . id ) . to . equal ( servers [ 0 ] . video . id ) expect ( 0 . state . id ) . to . equal ( VideoAbuseState . PENDING ) expect ( 0 . state . label ) . to . equal ( 's' ) expect ( 0 . moderationComment ) . to . be . null const 0 = 0 . body . data [ 0 ] expect ( 0 . reason ) . to . equal ( 's' ) expect ( 0 . reporterAccount . name ) . to . equal ( 's' ) expect ( 0 . reporterAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( 0 . video . id ) . to . equal ( servers [ 0 ] . video . id ) expect ( 0 . state . id ) . to . equal ( VideoAbuseState . PENDING ) expect ( 0 . state . label ) . to . equal ( 's' ) expect ( 0 . moderationComment ) . to . be . null const 0 = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data . length ) . to . equal ( 0 ) 0 = 0 . body . data [ 0 ] expect ( 0 . reason ) . to . equal ( 's' ) expect ( 0 . reporterAccount . name ) . to . equal ( 's' ) expect ( 0 . reporterAccount . host ) . to . equal ( 's' + servers [ 0 ] . port ) expect ( 0 . state . id ) . to . equal ( VideoAbuseState . PENDING ) expect ( 0 . state . label ) . to . equal ( 's' ) expect ( 0 . moderationComment ) . to . be . null } ) it ( 's' , async function ( ) { const body = { state : VideoAbuseState . REJECTED } await updateVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . video . uuid , 0 . id , body ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . data [ 0 ] . state . id ) . to . equal ( VideoAbuseState . REJECTED ) } ) it ( 's' , async function ( ) { const body = { state : VideoAbuseState . ACCEPTED , moderationComment : 's' } await updateVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . video . uuid , 0 . id , body ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . data [ 0 ] . state . id ) . to . equal ( VideoAbuseState . ACCEPTED ) expect ( res . body . data [ 0 ] . moderationComment ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { await reportVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . video . uuid , 's' ) await waitJobs ( servers ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } const accountToBlock = 's' + servers [ 0 ] . port { await addAccountToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , accountToBlock ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const abuse = res . body . data . find ( a => a . reason === 's' ) expect ( abuse ) . to . be . undefined } { await removeAccountFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , accountToBlock ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const serverToBlock = servers [ 0 ] . host { await addServerToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] . host ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const abuse = res . body . data . find ( a => a . reason === 's' ) expect ( abuse ) . to . be . undefined } { await removeServerFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , serverToBlock ) const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteVideoAbuse ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 . video . uuid , 0 . id ) await waitJobs ( servers ) { const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data . length ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . id ) . to . not . equal ( 0 . id ) } { const res = await getVideoAbusesList ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoAbuse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import { orderBy } from 's' import 's' import { addVideoToBlacklist , cleanupTests , createUser , flushAndRunMultipleServers , getBlacklistedVideosList , getMyUserInformation , getMyVideos , getVideosList , killallServers , removeVideoFromBlacklist , reRunServer , searchVideo , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , updateVideo , updateVideoBlacklist , uploadVideo , userLogin } from 's' import { doubleFollow } from 's' import { waitJobs } from 's' import { VideoBlacklist , VideoBlacklistType } from 's' import { UserAdminFlag } from 's' import { User , UserRole , UserUpdateMe } from 's' import { getMagnetURI , getYoutubeVideoUrl , importVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let videoId async function blacklistVideosOnServer ( server ) { const res = await getVideosList ( server . url ) const videos = res . body . data for ( let video of videos ) { await addVideoToBlacklist ( server . url , server . accessToken , video . id , 's' ) } } before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , description : 's' } ) await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , description : 's' } ) await waitJobs ( servers ) await blacklistVideosOnServer ( servers [ 0 ] ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } { const res = await searchVideo ( servers [ 0 ] . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } { const res = await searchVideo ( servers [ 0 ] . url , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) for ( const blacklistedVideo of blacklistedVideos ) { expect ( blacklistedVideo . reason ) . to . equal ( 's' ) videoId = blacklistedVideo . video . id } } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : VideoBlacklistType . MANUAL } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) const result = orderBy ( res . body . data , [ 's' ] , [ 's' ] ) expect ( blacklistedVideos ) . to . deep . equal ( result ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) const result = orderBy ( res . body . data , [ 's' ] , [ 's' ] ) expect ( blacklistedVideos ) . to . deep . equal ( result ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) const blacklistedVideos = res . body . data expect ( blacklistedVideos ) . to . be . an ( 's' ) expect ( blacklistedVideos . length ) . to . equal ( 0 ) const result = orderBy ( res . body . data , [ 's' ] ) expect ( blacklistedVideos ) . to . deep . equal ( result ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await updateVideoBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , 's' ) const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) const video = res . body . data . find ( b => b . video . id === videoId ) expect ( video . reason ) . to . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { await blacklistVideosOnServer ( servers [ 0 ] ) const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) for ( const video of res . body . data ) { expect ( video . blacklisted ) . to . be . true expect ( video . blacklistedReason ) . to . equal ( 's' ) } } ) } ) describe ( 's' , function ( ) { let videoToRemove let blacklist = [ ] it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) videoToRemove = res . body . data [ 0 ] blacklist = res . body . data . slice ( 0 ) await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoToRemove . video . id ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( videoToRemove . video . name ) expect ( videos [ 0 ] . id ) . to . equal ( videoToRemove . video . id ) } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos . length ) . to . equal ( 0 ) expect ( videos ) . to . deep . equal ( blacklist ) } ) } ) describe ( 's' , function ( ) { let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = res . body . video . uuid } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addVideoToBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 's' , false ) await waitJobs ( servers ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . data . find ( v => v . uuid === 0 ) ) . to . be . undefined } { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . data . find ( v => v . uuid === 0 ) ) . to . not . be . undefined } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await addVideoToBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 's' , true ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . data . find ( v => v . uuid === 0 ) ) . to . be . undefined } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , { description : 's' } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . data . find ( v => v . uuid === 0 ) ) . to . be . undefined } } ) it ( 's' , async function ( ) { const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' } ) const blacklistedVideos : VideoBlacklist [ ] = res . body . data const 0 = blacklistedVideos . find ( b => b . video . uuid === 0 ) const 0 = blacklistedVideos . find ( b => b . video . uuid === 0 ) expect ( 0 . unfederated ) . to . be . false expect ( 0 . unfederated ) . to . be . true } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . data . find ( v => v . uuid === 0 ) ) . to . not . be . undefined } } ) } ) describe ( 's' , function ( ) { let userWithoutFlag let userWithFlag let channelOfUserWithoutFlag before ( async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) const config = { 's' : { videos : { 's' : { enabled : true } } } } await reRunServer ( servers [ 0 ] , config ) { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , adminFlags : UserAdminFlag . NONE , password : user . password , role : UserRole . USER } ) userWithoutFlag = await userLogin ( servers [ 0 ] , user ) const res = await getMyUserInformation ( servers [ 0 ] . url , userWithoutFlag ) const body = res . body channelOfUserWithoutFlag = body . videoChannels [ 0 ] . id } { const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , adminFlags : UserAdminFlag . BY_PASS_VIDEO_AUTO_BLACKLIST , password : user . password , role : UserRole . USER } ) userWithFlag = await userLogin ( servers [ 0 ] , user ) } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await uploadVideo ( servers [ 0 ] . url , userWithoutFlag , { name : 's' } ) const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . video . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { targetUrl : getYoutubeVideoUrl ( ) , name : 's' , channelId : channelOfUserWithoutFlag } await importVideo ( servers [ 0 ] . url , userWithoutFlag , attributes ) const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . video . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const attributes = { magnetUri : getMagnetURI ( ) , name : 's' , channelId : channelOfUserWithoutFlag } await importVideo ( servers [ 0 ] . url , userWithoutFlag , attributes ) const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , sort : 's' , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . video . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { await uploadVideo ( servers [ 0 ] . url , userWithFlag , { name : 's' } ) const res = await getBlacklistedVideosList ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , type : VideoBlacklistType . AUTO_BEFORE_PUBLISHED } ) expect ( res . body . total ) . to . equal ( 0 ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoBlacklist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { checkVideoFilesWereRemoved , cleanupTests , doubleFollow , flushAndRunMultipleServers , removeVideo , uploadVideo , wait } from 's' import { flushTests , killallServers , ServerInfo , setAccessTokensToServers } from 's' import { waitJobs } from 's' import { createVideoCaption , deleteVideoCaption , listVideoCaptions , testCaptionFile } from 's' import { VideoCaption } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let videoUUID before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await waitJobs ( servers ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) videoUUID = res . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await listVideoCaptions ( server . url , videoUUID ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await createVideoCaption ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , language : 's' , videoId : videoUUID , fixture : 's' } ) await createVideoCaption ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , language : 's' , videoId : videoUUID , fixture : 's' , mimeType : 's' } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await listVideoCaptions ( server . url , videoUUID ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const 0 = res . body . data [ 0 ] expect ( 0 . language . id ) . to . equal ( 's' ) expect ( 0 . language . label ) . to . equal ( 's' ) expect ( 0 . captionPath ) . to . equal ( 's' + videoUUID + 's' ) await testCaptionFile ( server . url , 0 . captionPath , 's' ) const 0 = res . body . data [ 0 ] expect ( 0 . language . id ) . to . equal ( 's' ) expect ( 0 . language . label ) . to . equal ( 's' ) expect ( 0 . captionPath ) . to . equal ( 's' + videoUUID + 's' ) await testCaptionFile ( server . url , 0 . captionPath , 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await createVideoCaption ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , language : 's' , videoId : videoUUID , fixture : 's' } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await listVideoCaptions ( server . url , videoUUID ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const 0 = res . body . data [ 0 ] expect ( 0 . language . id ) . to . equal ( 's' ) expect ( 0 . language . label ) . to . equal ( 's' ) expect ( 0 . captionPath ) . to . equal ( 's' + videoUUID + 's' ) await testCaptionFile ( server . url , 0 . captionPath , 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await createVideoCaption ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , language : 's' , videoId : videoUUID , fixture : 's' } ) await waitJobs ( servers ) await wait ( 0 ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await listVideoCaptions ( server . url , videoUUID ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const 0 = res . body . data [ 0 ] expect ( 0 . language . id ) . to . equal ( 's' ) expect ( 0 . language . label ) . to . equal ( 's' ) expect ( 0 . captionPath ) . to . equal ( 's' + videoUUID + 's' ) const expected = 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' + 's' await testCaptionFile ( server . url , 0 . captionPath , expected ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteVideoCaption ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , 's' ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await listVideoCaptions ( server . url , videoUUID ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const caption = res . body . data [ 0 ] expect ( caption . language . id ) . to . equal ( 's' ) expect ( caption . language . label ) . to . equal ( 's' ) expect ( caption . captionPath ) . to . equal ( 's' + videoUUID + 's' ) await testCaptionFile ( server . url , caption . captionPath , 's' ) } } ) it ( 's' , async function ( ) { await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID ) await checkVideoFilesWereRemoved ( videoUUID , 0 ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCaption$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { acceptChangeOwnership , changeVideoOwnership , cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , flushAndRunServer , getMyUserInformation , getVideo , getVideoChangeOwnershipList , getVideosList , refuseChangeOwnership , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin } from 's' import { waitJobs } from 's' import { User } from 's' import { VideoDetails } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] const firstUser = { username : 's' , password : 's' } const secondUser = { username : 's' , password : 's' } let firstUserAccessToken = 's' let secondUserAccessToken = 's' let lastRequestChangeOwnershipId = undefined before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) const videoQuota = 0 await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : firstUser . username , password : firstUser . password , videoQuota : videoQuota } ) await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : secondUser . username , password : secondUser . password , videoQuota : videoQuota } ) firstUserAccessToken = await userLogin ( servers [ 0 ] , firstUser ) secondUserAccessToken = await userLogin ( servers [ 0 ] , secondUser ) const videoAttributes = { name : 's' , description : 's' } await uploadVideo ( servers [ 0 ] . url , firstUserAccessToken , videoAttributes ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) const videos = res . body . data expect ( videos . length ) . to . equal ( 0 ) const video = videos . find ( video => video . name === 's' ) expect ( video . channel . name ) . to . equal ( 's' ) servers [ 0 ] . video = video await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { const resFirstUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , firstUserAccessToken ) expect ( resFirstUser . body . total ) . to . equal ( 0 ) expect ( resFirstUser . body . data ) . to . be . an ( 's' ) expect ( resFirstUser . body . data . length ) . to . equal ( 0 ) const resSecondUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , secondUserAccessToken ) expect ( resSecondUser . body . total ) . to . equal ( 0 ) expect ( resSecondUser . body . data ) . to . be . an ( 's' ) expect ( resSecondUser . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await changeVideoOwnership ( servers [ 0 ] . url , firstUserAccessToken , servers [ 0 ] . video . id , secondUser . username ) } ) it ( 's' , async function ( ) { const resFirstUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , firstUserAccessToken ) expect ( resFirstUser . body . total ) . to . equal ( 0 ) expect ( resFirstUser . body . data ) . to . be . an ( 's' ) expect ( resFirstUser . body . data . length ) . to . equal ( 0 ) const resSecondUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , secondUserAccessToken ) expect ( resSecondUser . body . total ) . to . equal ( 0 ) expect ( resSecondUser . body . data ) . to . be . an ( 's' ) expect ( resSecondUser . body . data . length ) . to . equal ( 0 ) lastRequestChangeOwnershipId = resSecondUser . body . data [ 0 ] . id } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await changeVideoOwnership ( servers [ 0 ] . url , firstUserAccessToken , servers [ 0 ] . video . id , secondUser . username ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const resSecondUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , secondUserAccessToken ) expect ( resSecondUser . body . total ) . to . equal ( 0 ) expect ( resSecondUser . body . data ) . to . be . an ( 's' ) expect ( resSecondUser . body . data . length ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await refuseChangeOwnership ( servers [ 0 ] . url , firstUserAccessToken , lastRequestChangeOwnershipId , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await refuseChangeOwnership ( servers [ 0 ] . url , secondUserAccessToken , lastRequestChangeOwnershipId ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await changeVideoOwnership ( servers [ 0 ] . url , firstUserAccessToken , servers [ 0 ] . video . id , secondUser . username ) } ) it ( 's' , async function ( ) { const resFirstUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , firstUserAccessToken ) expect ( resFirstUser . body . total ) . to . equal ( 0 ) expect ( resFirstUser . body . data ) . to . be . an ( 's' ) expect ( resFirstUser . body . data . length ) . to . equal ( 0 ) const resSecondUser = await getVideoChangeOwnershipList ( servers [ 0 ] . url , secondUserAccessToken ) expect ( resSecondUser . body . total ) . to . equal ( 0 ) expect ( resSecondUser . body . data ) . to . be . an ( 's' ) expect ( resSecondUser . body . data . length ) . to . equal ( 0 ) lastRequestChangeOwnershipId = resSecondUser . body . data [ 0 ] . id } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const secondUserInformationResponse = await getMyUserInformation ( servers [ 0 ] . url , secondUserAccessToken ) const secondUserInformation = secondUserInformationResponse . body const channelId = secondUserInformation . videoChannels [ 0 ] . id await acceptChangeOwnership ( servers [ 0 ] . url , firstUserAccessToken , lastRequestChangeOwnershipId , channelId , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const secondUserInformationResponse = await getMyUserInformation ( servers [ 0 ] . url , secondUserAccessToken ) const secondUserInformation = secondUserInformationResponse . body const channelId = secondUserInformation . videoChannels [ 0 ] . id await acceptChangeOwnership ( servers [ 0 ] . url , secondUserAccessToken , lastRequestChangeOwnershipId , channelId ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , servers [ 0 ] . video . uuid ) const video = res . body expect ( video . name ) . to . equal ( 's' ) expect ( video . channel . displayName ) . to . equal ( 's' ) expect ( video . channel . name ) . to . equal ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } ) describe ( 's' , function ( ) { let server = undefined const firstUser = { username : 's' , password : 's' } const secondUser = { username : 's' , password : 's' } let firstUserAccessToken = 's' let secondUserAccessToken = 's' let lastRequestChangeOwnershipId = undefined before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const videoQuota = 0 const limitedVideoQuota = 0 await createUser ( { url : server . url , accessToken : server . accessToken , username : firstUser . username , password : firstUser . password , videoQuota : videoQuota } ) await createUser ( { url : server . url , accessToken : server . accessToken , username : secondUser . username , password : secondUser . password , videoQuota : limitedVideoQuota } ) firstUserAccessToken = await userLogin ( server , firstUser ) secondUserAccessToken = await userLogin ( server , secondUser ) const 0 = { name : 's' , description : 's' } await uploadVideo ( server . url , firstUserAccessToken , 0 ) await waitJobs ( server ) const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos . length ) . to . equal ( 0 ) server . video = videos . find ( video => video . name === 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await changeVideoOwnership ( server . url , firstUserAccessToken , server . video . id , secondUser . username ) } ) it ( 's' , async function ( ) { const resFirstUser = await getVideoChangeOwnershipList ( server . url , firstUserAccessToken ) expect ( resFirstUser . body . total ) . to . equal ( 0 ) expect ( resFirstUser . body . data ) . to . be . an ( 's' ) expect ( resFirstUser . body . data . length ) . to . equal ( 0 ) const resSecondUser = await getVideoChangeOwnershipList ( server . url , secondUserAccessToken ) expect ( resSecondUser . body . total ) . to . equal ( 0 ) expect ( resSecondUser . body . data ) . to . be . an ( 's' ) expect ( resSecondUser . body . data . length ) . to . equal ( 0 ) lastRequestChangeOwnershipId = resSecondUser . body . data [ 0 ] . id } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const secondUserInformationResponse = await getMyUserInformation ( server . url , secondUserAccessToken ) const secondUserInformation = secondUserInformationResponse . body const channelId = secondUserInformation . videoChannels [ 0 ] . id await acceptChangeOwnership ( server . url , secondUserAccessToken , lastRequestChangeOwnershipId , channelId , 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { User , Video , VideoChannel , VideoDetails } from 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , getVideo , getVideoChannelVideos , testImage , updateVideo , updateVideoChannelAvatar , uploadVideo , userLogin } from 's' import { addVideoChannel , deleteVideoChannel , getAccountVideoChannelsList , getMyUserInformation , getVideoChannel , getVideoChannelsList , ServerInfo , setAccessTokensToServers , updateVideoChannel } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let userInfo let firstVideoChannelId let secondVideoChannelId let videoUUID before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const user = res . body firstVideoChannelId = user . videoChannels [ 0 ] . id } await waitJobs ( servers ) } ) it ( 's' , async ( ) => { const res = await getVideoChannelsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const videoChannel = { name : 's' , displayName : 's' , description : 's' , support : 's' } const res = await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoChannel ) secondVideoChannelId = res . body . videoChannel . id } { const videoAttributesArg = { name : 's' , channelId : secondVideoChannelId , support : 's' } const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributesArg ) videoUUID = res . body . video . uuid } await waitJobs ( servers ) } ) it ( 's' , async ( ) => { const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) userInfo = res . body expect ( userInfo . videoChannels ) . to . be . an ( 's' ) expect ( userInfo . videoChannels ) . to . have . lengthOf ( 0 ) const videoChannels = userInfo . videoChannels expect ( videoChannels [ 0 ] . name ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . displayName ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . name ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . displayName ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . description ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . support ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getAccountVideoChannelsList ( { url : servers [ 0 ] . url , accountName : userInfo . account . name + 's' + userInfo . account . host } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannels = res . body . data expect ( videoChannels [ 0 ] . name ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . displayName ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . name ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . displayName ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . description ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . support ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const res = await getAccountVideoChannelsList ( { url : servers [ 0 ] . url , accountName : userInfo . account . name + 's' + userInfo . account . host , start : 0 , count : 0 , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannel = res . body . data [ 0 ] expect ( videoChannel . name ) . to . equal ( 's' ) } { const res = await getAccountVideoChannelsList ( { url : servers [ 0 ] . url , accountName : userInfo . account . name + 's' + userInfo . account . host , start : 0 , count : 0 , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannel = res . body . data [ 0 ] expect ( videoChannel . name ) . to . equal ( 's' ) } { const res = await getAccountVideoChannelsList ( { url : servers [ 0 ] . url , accountName : userInfo . account . name + 's' + userInfo . account . host , start : 0 , count : 0 , sort : 's' } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannel = res . body . data [ 0 ] expect ( videoChannel . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const res = await getAccountVideoChannelsList ( { url : servers [ 0 ] . url , accountName : userInfo . account . name + 's' + userInfo . account . host } ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const videoChannels = res . body . data expect ( videoChannels [ 0 ] . name ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . displayName ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . description ) . to . equal ( 's' ) expect ( videoChannels [ 0 ] . support ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoChannelsList ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . displayName ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoChannelAttributes = { displayName : 's' , description : 's' , support : 's' } await updateVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' , videoChannelAttributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideoChannelsList ( server . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . displayName ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . description ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . support ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body expect ( video . support ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoChannelAttributes = { support : 's' , bulkVideosSupportUpdate : true } await updateVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' , videoChannelAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body expect ( video . support ) . to . equal ( videoChannelAttributes . support ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const fixture = 's' await updateVideoChannelAvatar ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , videoChannelName : 's' , fixture } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideoChannelsList ( server . url , 0 , 0 , 's' ) const videoChannel = res . body . data . find ( c => c . id === secondVideoChannelId ) await testImage ( server . url , 's' , videoChannel . avatar . path , 's' ) } } ) it ( 's' , async function ( ) { const res = await getVideoChannel ( servers [ 0 ] . url , 's' ) const videoChannel = res . body expect ( videoChannel . name ) . to . equal ( 's' ) expect ( videoChannel . displayName ) . to . equal ( 's' ) expect ( videoChannel . description ) . to . equal ( 's' ) expect ( videoChannel . support ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const channelURI = 's' + servers [ 0 ] . port const 0 = await getVideoChannelVideos ( server . url , server . accessToken , channelURI , 0 , 0 ) expect ( 0 . body . total ) . to . equal ( 0 ) expect ( 0 . body . data ) . to . be . an ( 's' ) expect ( 0 . body . data ) . to . have . lengthOf ( 0 ) expect ( 0 . body . data [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , { channelId : firstVideoChannelId } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const secondChannelURI = 's' + servers [ 0 ] . port const 0 = await getVideoChannelVideos ( server . url , server . accessToken , secondChannelURI , 0 , 0 ) expect ( 0 . body . total ) . to . equal ( 0 ) const channelURI = 's' + servers [ 0 ] . port const 0 = await getVideoChannelVideos ( server . url , server . accessToken , channelURI , 0 , 0 ) expect ( 0 . body . total ) . to . equal ( 0 ) const videos : Video [ ] = 0 . body . data expect ( videos ) . to . be . an ( 's' ) expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { await deleteVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoChannelsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . displayName ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { { const videoChannel = { name : 's' , displayName : 's' } await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoChannel ) } { await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : 's' , password : 's' } ) const accessToken = await userLogin ( servers [ 0 ] , { username : 's' , password : 's' } ) const res = await getMyUserInformation ( servers [ 0 ] . url , accessToken ) const videoChannel = res . body . videoChannels [ 0 ] expect ( videoChannel . name ) . to . match ( "s" ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoComment , VideoCommentThreadTree } from 's' import { cleanupTests , testImage } from 's' import { dateIsValid , flushAndRunServer , ServerInfo , setAccessTokensToServers , updateMyAvatar , uploadVideo } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getVideoCommentThreads , getVideoThreadComments } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server let videoId let videoUUID let threadId let replyToDeleteId before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) const res = await uploadVideo ( server . url , server . accessToken , { } ) videoUUID = res . body . video . uuid videoId = res . body . video . id await updateMyAvatar ( { url : server . url , accessToken : server . accessToken , fixture : 's' } ) } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const text = 's' const res = await addVideoCommentThread ( server . url , server . accessToken , videoUUID , text ) const comment = res . body . comment expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . text ) . equal ( 's' ) expect ( comment . videoId ) . to . equal ( videoId ) expect ( comment . id ) . to . equal ( comment . threadId ) expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + server . port ) expect ( comment . account . url ) . to . equal ( 's' + server . port + 's' ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const comment = res . body . data [ 0 ] expect ( comment . inReplyToCommentId ) . to . be . null expect ( comment . text ) . equal ( 's' ) expect ( comment . videoId ) . to . equal ( videoId ) expect ( comment . id ) . to . equal ( comment . threadId ) expect ( comment . account . name ) . to . equal ( 's' ) expect ( comment . account . host ) . to . equal ( 's' + server . port ) await testImage ( server . url , 's' , comment . account . avatar . path , 's' ) expect ( comment . totalReplies ) . to . equal ( 0 ) expect ( dateIsValid ( comment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( comment . updatedAt as string ) ) . to . be . true threadId = comment . threadId } ) it ( 's' , async function ( ) { const res = await getVideoThreadComments ( server . url , videoUUID , threadId ) const rootComment = res . body . comment expect ( rootComment . inReplyToCommentId ) . to . be . null expect ( rootComment . text ) . equal ( 's' ) expect ( rootComment . videoId ) . to . equal ( videoId ) expect ( dateIsValid ( rootComment . createdAt as string ) ) . to . be . true expect ( dateIsValid ( rootComment . updatedAt as string ) ) . to . be . true } ) it ( 's' , async function ( ) { const 0 = 's' const childCommentRes = await addVideoCommentReply ( server . url , server . accessToken , videoId , threadId , 0 ) const childCommentId = childCommentRes . body . comment . id const 0 = 's' await addVideoCommentReply ( server . url , server . accessToken , videoId , childCommentId , 0 ) const 0 = 's' await addVideoCommentReply ( server . url , server . accessToken , videoId , threadId , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoThreadComments ( server . url , videoUUID , threadId ) const tree = res . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) const secondChild = tree . children [ 0 ] expect ( secondChild . comment . text ) . to . equal ( 's' ) expect ( secondChild . children ) . to . have . lengthOf ( 0 ) replyToDeleteId = secondChild . comment . id } ) it ( 's' , async function ( ) { const 0 = 's' await addVideoCommentThread ( server . url , server . accessToken , videoUUID , 0 ) const 0 = 's' await addVideoCommentThread ( server . url , server . accessToken , videoUUID , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . text ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . totalReplies ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . text ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . totalReplies ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . text ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . totalReplies ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { await deleteVideoComment ( server . url , server . accessToken , videoId , replyToDeleteId ) const res = await getVideoThreadComments ( server . url , videoUUID , threadId ) const tree = res . body expect ( tree . comment . text ) . equal ( 's' ) expect ( tree . children ) . to . have . lengthOf ( 0 ) const firstChild = tree . children [ 0 ] expect ( firstChild . comment . text ) . to . equal ( 's' ) expect ( firstChild . children ) . to . have . lengthOf ( 0 ) const childOfFirstChild = firstChild . children [ 0 ] expect ( childOfFirstChild . comment . text ) . to . equal ( 's' ) expect ( childOfFirstChild . children ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { await deleteVideoComment ( server . url , server . accessToken , videoId , threadId ) const res = await getVideoCommentThreads ( server . url , videoUUID , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . be . an ( 's' ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . text ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . totalReplies ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . text ) . to . equal ( 's' ) expect ( res . body . data [ 0 ] . totalReplies ) . to . equal ( 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoComment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoCommentThreadTree$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunMultipleServers , getVideo , getVideoDescription , getVideosList , killallServers , ServerInfo , setAccessTokensToServers , updateVideo , uploadVideo } from 's' import { doubleFollow } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let videoUUID = 's' let videoId let longDescription = 's' . repeat ( 0 ) before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { description : longDescription } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) await waitJobs ( servers ) const res = await getVideosList ( servers [ 0 ] . url ) videoId = res . body . data [ 0 ] . id videoUUID = res . body . data [ 0 ] . uuid } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body const truncatedDescription = 's' . repeat ( 0 ) + 's' expect ( video . description ) . to . equal ( truncatedDescription ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body const 0 = await getVideoDescription ( server . url , video . descriptionPath ) expect ( 0 . body . description ) . to . equal ( longDescription ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { description : 's' } await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , attributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body expect ( video . description ) . to . equal ( 's' ) const 0 = await getVideoDescription ( server . url , video . descriptionPath ) expect ( 0 . body . description ) . to . equal ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { checkDirectoryIsEmpty , checkSegmentHash , checkTmpIsEmpty , cleanupTests , doubleFollow , flushAndRunMultipleServers , getPlaylist , getVideo , removeVideo , ServerInfo , setAccessTokensToServers , updateVideo , uploadVideo , waitJobs } from 's' import { VideoDetails } from 's' import { VideoStreamingPlaylistType } from 's' import { join } from 's' import { DEFAULT_AUDIO_RESOLUTION } from 's' const expect = chai . expect async function checkHlsPlaylist ( servers : ServerInfo [ ] , videoUUID , resolutions = [ 0 , 0 , 0 , 0 ] ) { for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const videoDetails = res . body expect ( videoDetails . streamingPlaylists ) . to . have . lengthOf ( 0 ) const hlsPlaylist = videoDetails . streamingPlaylists . find ( p => p . type === VideoStreamingPlaylistType . HLS ) expect ( hlsPlaylist ) . to . not . be . undefined { const 0 = await getPlaylist ( hlsPlaylist . playlistUrl ) const masterPlaylist = 0 . text for ( const resolution of resolutions ) { expect ( masterPlaylist ) . to . match ( new RegExp ( 's' + resolution + 's' ) ) expect ( masterPlaylist ) . to . contain ( `template` ) } } { for ( const resolution of resolutions ) { const 0 = await getPlaylist ( `template` ) const subPlaylist = 0 . text expect ( subPlaylist ) . to . contain ( `template` ) } } { const baseUrl = 's' + servers [ 0 ] . port + 's' for ( const resolution of resolutions ) { await checkSegmentHash ( baseUrl , baseUrl , videoUUID , resolution , hlsPlaylist ) } } } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let videoUUID = 's' let videoAudioUUID = 's' before ( async function ( ) { this . timeout ( 0 ) const configOverride = { transcoding : { enabled : true , allow_audio_files : true , hls : { enabled : true } } } servers = await flushAndRunMultipleServers ( 0 , configOverride ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , fixture : 's' } ) videoUUID = res . body . video . uuid await waitJobs ( servers ) await checkHlsPlaylist ( servers , videoUUID ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , fixture : 's' } ) videoAudioUUID = res . body . video . uuid await waitJobs ( servers ) await checkHlsPlaylist ( servers , videoAudioUUID , [ DEFAULT_AUDIO_RESOLUTION ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , { name : 's' } ) await waitJobs ( servers ) await checkHlsPlaylist ( servers , videoUUID ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID ) await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAudioUUID ) await waitJobs ( servers ) for ( const server of servers ) { await getVideo ( server . url , videoUUID , 0 ) await getVideo ( server . url , videoAudioUUID , 0 ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { await checkDirectoryIsEmpty ( server , 's' ) await checkDirectoryIsEmpty ( server , join ( 's' , 's' ) ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { await checkTmpIsEmpty ( server ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoDetails , VideoImport , VideoPrivacy } from 's' import { cleanupTests , doubleFollow , flushAndRunMultipleServers , getMyUserInformation , getMyVideos , getVideo , getVideosList , immutableAssign , killallServers , ServerInfo , setAccessTokensToServers } from 's' import { waitJobs } from 's' import { getMagnetURI , getYoutubeVideoUrl , importVideo , getMyVideoImports } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 async function 0 ( url , idHttp , idMagnet , idTorrent ) { const resHttp = await getVideo ( url , idHttp ) const videoHttp = resHttp . body expect ( videoHttp . name ) . to . equal ( 's' ) expect ( videoHttp . category . label ) . to . equal ( 's' ) expect ( videoHttp . licence . label ) . to . equal ( 's' ) expect ( videoHttp . language . label ) . to . equal ( 's' ) expect ( videoHttp . nsfw ) . to . be . false expect ( videoHttp . description ) . to . equal ( 's' ) expect ( videoHttp . tags ) . to . deep . equal ( [ 's' , 's' ] ) expect ( videoHttp . files ) . to . have . lengthOf ( 0 ) const originallyPublishedAt = new Date ( videoHttp . originallyPublishedAt ) expect ( originallyPublishedAt . getDate ( ) ) . to . equal ( 0 ) expect ( originallyPublishedAt . getMonth ( ) ) . to . equal ( 0 ) expect ( originallyPublishedAt . getFullYear ( ) ) . to . equal ( 0 ) const resMagnet = await getVideo ( url , idMagnet ) const videoMagnet = resMagnet . body const resTorrent = await getVideo ( url , idTorrent ) const videoTorrent = resTorrent . body for ( const video of [ videoMagnet , videoTorrent ] ) { expect ( video . category . label ) . to . equal ( 's' ) expect ( video . licence . label ) . to . equal ( 's' ) expect ( video . language . label ) . to . equal ( 's' ) expect ( video . nsfw ) . to . be . false expect ( video . description ) . to . equal ( 's' ) expect ( video . tags ) . to . deep . equal ( [ 's' , 's' ] ) expect ( video . files ) . to . have . lengthOf ( 0 ) } expect ( videoTorrent . name ) . to . contain ( 's' ) expect ( videoMagnet . name ) . to . contain ( 's' ) } async function 0 ( url , id : number | string ) { const res = await getVideo ( url , id ) const video = res . body expect ( video . name ) . to . equal ( 's' ) expect ( video . category . label ) . to . equal ( 's' ) expect ( video . licence . label ) . to . equal ( 's' ) expect ( video . language . label ) . to . equal ( 's' ) expect ( video . nsfw ) . to . be . false expect ( video . description ) . to . equal ( 's' ) expect ( video . tags ) . to . deep . equal ( [ 's' , 's' ] ) expect ( video . files ) . to . have . lengthOf ( 0 ) } before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) { const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) 0 = res . body . videoChannels [ 0 ] . id } { const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) 0 = res . body . videoChannels [ 0 ] . id } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const baseAttributes = { channelId : 0 , privacy : VideoPrivacy . PUBLIC } { const attributes = immutableAssign ( baseAttributes , { targetUrl : getYoutubeVideoUrl ( ) } ) const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) expect ( res . body . video . name ) . to . equal ( 's' ) } { const attributes = immutableAssign ( baseAttributes , { magnetUri : getMagnetURI ( ) , description : 's' , tags : [ 's' , 's' ] } ) const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) expect ( res . body . video . name ) . to . equal ( 's' ) } { const attributes = immutableAssign ( baseAttributes , { torrentfile : 's' , description : 's' , tags : [ 's' , 's' ] } ) const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) expect ( res . body . video . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getMyVideoImports ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const videoImports : VideoImport [ ] = res . body . data expect ( videoImports ) . to . have . lengthOf ( 0 ) expect ( videoImports [ 0 ] . targetUrl ) . to . equal ( getYoutubeVideoUrl ( ) ) expect ( videoImports [ 0 ] . magnetUri ) . to . be . null expect ( videoImports [ 0 ] . torrentName ) . to . be . null expect ( videoImports [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoImports [ 0 ] . targetUrl ) . to . be . null expect ( videoImports [ 0 ] . magnetUri ) . to . equal ( getMagnetURI ( ) ) expect ( videoImports [ 0 ] . torrentName ) . to . be . null expect ( videoImports [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoImports [ 0 ] . targetUrl ) . to . be . null expect ( videoImports [ 0 ] . magnetUri ) . to . be . null expect ( videoImports [ 0 ] . torrentName ) . to . equal ( 's' ) expect ( videoImports [ 0 ] . video . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const [ videoHttp , videoMagnet , videoTorrent ] = res . body . data await 0 ( server . url , videoHttp . uuid , videoMagnet . uuid , videoTorrent . uuid ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { targetUrl : getYoutubeVideoUrl ( ) , channelId : 0 , privacy : VideoPrivacy . PUBLIC , category : 0 , licence : 0 , language : 's' , name : 's' , description : 's' , tags : [ 's' , 's' ] } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) expect ( res . body . video . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) await 0 ( server . url , res . body . data [ 0 ] . uuid ) const [ , videoHttp , videoMagnet , videoTorrent ] = res . body . data await 0 ( server . url , videoHttp . uuid , videoMagnet . uuid , videoTorrent . uuid ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { name : 's' , magnetUri : getMagnetURI ( ) , channelId : 0 , privacy : VideoPrivacy . PUBLIC } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) const videoUUID = res . body . video . uuid await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideo ( server . url , videoUUID ) const video = res . body expect ( video . name ) . to . equal ( 's' ) expect ( video . files ) . to . have . lengthOf ( 0 ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , getVideosList , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { userLogin } from 's' import { createUser } from 's' import { getMyVideos } from 's' import { flushAndRunServer , getAccountVideos , getConfig , getCustomConfig , getMyUserInformation , getVideoChannelVideos , getVideosListWithToken , searchVideo , searchVideoWithToken , updateCustomConfig , updateMyUser } from 's' import { ServerConfig } from 's' import { CustomConfig } from 's' import { User } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server let userAccessToken let customConfig function getVideosFunctions ( token ? , query = { } ) { return getMyUserInformation ( server . url , server . accessToken ) . then ( res => { const user = res . body const videoChannelName = user . videoChannels [ 0 ] . name const accountName = user . account . name + 's' + user . account . host if ( token ) { return Promise . all ( [ getVideosListWithToken ( server . url , token , query ) , searchVideoWithToken ( server . url , 's' , token , query ) , getAccountVideos ( server . url , token , accountName , 0 , 0 , undefined , query ) , getVideoChannelVideos ( server . url , token , videoChannelName , 0 , 0 , undefined , query ) ] ) } return Promise . all ( [ getVideosList ( server . url ) , searchVideo ( server . url , 's' ) , getAccountVideos ( server . url , undefined , accountName , 0 , 0 ) , getVideoChannelVideos ( server . url , undefined , videoChannelName , 0 , 0 ) ] ) } ) } before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const attributes = { name : 's' , nsfw : true } await uploadVideo ( server . url , server . accessToken , attributes ) } { const attributes = { name : 's' , nsfw : false } await uploadVideo ( server . url , server . accessToken , attributes ) } { const res = await getCustomConfig ( server . url , server . accessToken ) customConfig = res . body } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const resConfig = await getConfig ( server . url ) const serverConfig = resConfig . body expect ( serverConfig . instance . defaultNSFWPolicy ) . to . equal ( 's' ) for ( const res of await getVideosFunctions ( ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { customConfig . instance . defaultNSFWPolicy = 's' await updateCustomConfig ( server . url , server . accessToken , customConfig ) const resConfig = await getConfig ( server . url ) const serverConfig = resConfig . body expect ( serverConfig . instance . defaultNSFWPolicy ) . to . equal ( 's' ) for ( const res of await getVideosFunctions ( ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { customConfig . instance . defaultNSFWPolicy = 's' await updateCustomConfig ( server . url , server . accessToken , customConfig ) const resConfig = await getConfig ( server . url ) const serverConfig = resConfig . body expect ( serverConfig . instance . defaultNSFWPolicy ) . to . equal ( 's' ) for ( const res of await getVideosFunctions ( ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const username = 's' const password = 's' await createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : password } ) userAccessToken = await userLogin ( server , { username , password } ) const res = await getMyUserInformation ( server . url , userAccessToken ) const user = res . body expect ( user . nsfwPolicy ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { customConfig . instance . defaultNSFWPolicy = 's' await updateCustomConfig ( server . url , server . accessToken , customConfig ) for ( const res of await getVideosFunctions ( userAccessToken ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : server . accessToken , nsfwPolicy : 's' } ) for ( const res of await getVideosFunctions ( server . accessToken ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : server . accessToken , nsfwPolicy : 's' } ) for ( const res of await getVideosFunctions ( server . accessToken ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { const res = await getMyVideos ( server . url , server . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { for ( const res of await getVideosFunctions ( server . accessToken , { nsfw : true } ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { for ( const res of await getVideosFunctions ( server . accessToken , { nsfw : false } ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { for ( const res of await getVideosFunctions ( server . accessToken , { nsfw : 's' } ) ) { expect ( res . body . total ) . to . equal ( 0 ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $CustomConfig$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoChannel , addVideoInPlaylist , addVideoToBlacklist , checkPlaylistFilesWereRemoved , cleanupTests , createUser , createVideoPlaylist , deleteVideoChannel , deleteVideoPlaylist , doubleFollow , doVideosExistInMyPlaylist , flushAndRunMultipleServers , generateUserAccessToken , getAccessToken , getAccountPlaylistsList , getAccountPlaylistsListWithToken , getMyUserInformation , getPlaylistVideos , getVideoChannelPlaylistsList , getVideoPlaylist , getVideoPlaylistPrivacies , getVideoPlaylistsList , getVideoPlaylistWithToken , removeUser , removeVideoFromBlacklist , removeVideoFromPlaylist , reorderVideosPlaylist , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , testImage , unfollow , updateVideo , updateVideoPlaylist , updateVideoPlaylistElement , uploadVideo , uploadVideoAndGetId , userLogin , waitJobs } from 's' import { VideoPlaylistPrivacy } from 's' import { VideoPlaylist } from 's' import { VideoPrivacy } from 's' import { VideoPlaylistType } from 's' import { VideoExistInPlaylist } from 's' import { User } from 's' import { VideoPlaylistElement , VideoPlaylistElementType } from 's' import { addAccountToAccountBlocklist , addAccountToServerBlocklist , addServerToAccountBlocklist , addServerToServerBlocklist , removeAccountFromAccountBlocklist , removeAccountFromServerBlocklist , removeServerFromAccountBlocklist , removeServerFromServerBlocklist } from 's' const expect = chai . expect async function checkPlaylistElementType ( servers : ServerInfo [ ] , playlistId , type , position , name , total ) { for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , playlistId , 0 , 0 ) expect ( res . body . total ) . to . equal ( total ) const videoElement = res . body . data . find ( ( e ) => e . position === position ) expect ( videoElement . type ) . to . equal ( type , 's' + server . url ) if ( type === VideoPlaylistElementType . REGULAR ) { expect ( videoElement . video ) . to . not . be . null expect ( videoElement . video . name ) . to . equal ( name ) } else { expect ( videoElement . video ) . to . be . null } } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 let 0 let 0 let 0 let 0 let 0 let 0 let playlistElementNSFW let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 , { transcoding : { enabled : false } } ) await setAccessTokensToServers ( servers ) await setDefaultVideoChannel ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const serverPromises : Promise < any > [ ] [ ] = [ ] for ( const server of servers ) { const videoPromises : Promise < any > [ ] = [ ] for ( let i = 0 ; i < 0 ; i ++ ) { videoPromises . push ( uploadVideo ( server . url , server . accessToken , { name : `template` , nsfw : false } ) . then ( res => res . body . video ) ) } serverPromises . push ( videoPromises ) } servers [ 0 ] . videos = await Promise . all ( serverPromises [ 0 ] ) servers [ 0 ] . videos = await Promise . all ( serverPromises [ 0 ] ) servers [ 0 ] . videos = await Promise . all ( serverPromises [ 0 ] ) } 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' , nsfw : true } ) ) . id { await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : 's' , password : 's' } ) 0 = await getAccessToken ( servers [ 0 ] . url , 's' , 's' ) } await waitJobs ( servers ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await getVideoPlaylistPrivacies ( servers [ 0 ] . url ) const privacies = res . body expect ( Object . keys ( privacies ) ) . to . have . length . at . least ( 0 ) expect ( privacies [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const url = servers [ 0 ] . url const accessToken = servers [ 0 ] . accessToken { const res = await getAccountPlaylistsListWithToken ( url , accessToken , 's' , 0 , 0 , VideoPlaylistType . WATCH_LATER ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const playlist = res . body . data [ 0 ] expect ( playlist . displayName ) . to . equal ( 's' ) expect ( playlist . type . id ) . to . equal ( VideoPlaylistType . WATCH_LATER ) expect ( playlist . type . label ) . to . equal ( 's' ) } { const res = await getAccountPlaylistsListWithToken ( url , accessToken , 's' , 0 , 0 , VideoPlaylistType . REGULAR ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await getAccountPlaylistsList ( url , 's' , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { const token = await generateUserAccessToken ( servers [ 0 ] , 's' ) const res = await getAccountPlaylistsListWithToken ( servers [ 0 ] . url , token , 's' , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const playlistId = res . body . data [ 0 ] . id await getPlaylistVideos ( servers [ 0 ] . url , token , playlistId , 0 , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , description : 's' , thumbnailfile : 's' , videoChannelId : servers [ 0 ] . videoChannel . id } } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) const playlistFromList = res . body . data [ 0 ] as VideoPlaylist const 0 = await getVideoPlaylist ( server . url , playlistFromList . uuid ) const playlistFromGet = 0 . body for ( const playlist of [ playlistFromGet , playlistFromList ] ) { expect ( playlist . id ) . to . be . a ( 's' ) expect ( playlist . uuid ) . to . be . a ( 's' ) expect ( playlist . isLocal ) . to . equal ( server . serverNumber === 0 ) expect ( playlist . displayName ) . to . equal ( 's' ) expect ( playlist . description ) . to . equal ( 's' ) expect ( playlist . privacy . id ) . to . equal ( VideoPlaylistPrivacy . PUBLIC ) expect ( playlist . privacy . label ) . to . equal ( 's' ) expect ( playlist . type . id ) . to . equal ( VideoPlaylistType . REGULAR ) expect ( playlist . type . label ) . to . equal ( 's' ) expect ( playlist . videosLength ) . to . equal ( 0 ) expect ( playlist . ownerAccount . name ) . to . equal ( 's' ) expect ( playlist . ownerAccount . displayName ) . to . equal ( 's' ) expect ( playlist . videoChannel . name ) . to . equal ( 's' ) expect ( playlist . videoChannel . displayName ) . to . equal ( 's' ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } } ) 0 = res . body . videoPlaylist . id } { const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , thumbnailfile : 's' , videoChannelId : servers [ 0 ] . videoChannel . id } } ) 0 = res . body . videoPlaylist . id 0 = res . body . videoPlaylist . uuid } for ( let id of [ 0 , 0 ] ) { await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : id , elementAttrs : { videoId : servers [ 0 ] . videos [ 0 ] . id , startTimestamp : 0 , stopTimestamp : 0 } } ) await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : id , elementAttrs : { videoId : servers [ 0 ] . videos [ 0 ] . id } } ) } await waitJobs ( servers ) for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) const 0 = res . body . data . find ( p => p . displayName === 's' ) expect ( 0 ) . to . not . be . undefined await testImage ( server . url , 's' , 0 . thumbnailPath ) const 0 = res . body . data . find ( p => p . displayName === 's' ) expect ( 0 ) . to . not . be . undefined await testImage ( server . url , 's' , 0 . thumbnailPath ) } const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . data . find ( p => p . displayName === 's' ) ) . to . be . undefined expect ( res . body . data . find ( p => p . displayName === 's' ) ) . to . be . undefined } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 ) const 0 = res . body . data . find ( p => p . displayName === 's' ) expect ( 0 ) . to . not . be . undefined await testImage ( servers [ 0 ] . url , 's' , 0 . thumbnailPath ) expect ( res . body . data . find ( p => p . displayName === 's' ) ) . to . not . be . undefined } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) { const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } { const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const res = await getVideoChannelPlaylistsList ( servers [ 0 ] . url , 's' , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const res = await getAccountPlaylistsList ( servers [ 0 ] . url , 's' , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } { const res = await getAccountPlaylistsList ( servers [ 0 ] . url , 's' , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . UNLISTED } } ) await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PRIVATE } } ) await waitJobs ( servers ) for ( const server of servers ) { const results = [ await getAccountPlaylistsList ( server . url , 's' + servers [ 0 ] . port , 0 , 0 , 's' ) , await getVideoPlaylistsList ( server . url , 0 , 0 , 's' ) ] expect ( results [ 0 ] . body . total ) . to . equal ( 0 ) expect ( results [ 0 ] . body . total ) . to . equal ( 0 ) for ( const res of results ) { const data : VideoPlaylist [ ] = res . body . data expect ( data ) . to . have . lengthOf ( 0 ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) expect ( data [ 0 ] . displayName ) . to . equal ( 's' ) } } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , description : 's' , privacy : VideoPlaylistPrivacy . UNLISTED , thumbnailfile : 's' , videoChannelId : servers [ 0 ] . videoChannel . id } , playlistId : 0 } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideoPlaylist ( server . url , 0 ) const playlist = res . body expect ( playlist . displayName ) . to . equal ( 's' ) expect ( playlist . description ) . to . equal ( 's' ) expect ( playlist . privacy . id ) . to . equal ( VideoPlaylistPrivacy . UNLISTED ) expect ( playlist . privacy . label ) . to . equal ( 's' ) expect ( playlist . type . id ) . to . equal ( VideoPlaylistType . REGULAR ) expect ( playlist . type . label ) . to . equal ( 's' ) expect ( playlist . videosLength ) . to . equal ( 0 ) expect ( playlist . ownerAccount . name ) . to . equal ( 's' ) expect ( playlist . ownerAccount . displayName ) . to . equal ( 's' ) expect ( playlist . videoChannel . name ) . to . equal ( 's' ) expect ( playlist . videoChannel . displayName ) . to . equal ( 's' ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const addVideo = ( elementAttrs ) => { return addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , elementAttrs } ) } const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } } ) 0 = res . body . videoPlaylist . id 0 = res . body . videoPlaylist . uuid await addVideo ( { videoId : servers [ 0 ] . videos [ 0 ] . uuid , startTimestamp : 0 , stopTimestamp : 0 } ) await addVideo ( { videoId : servers [ 0 ] . videos [ 0 ] . uuid , startTimestamp : 0 } ) await addVideo ( { videoId : servers [ 0 ] . videos [ 0 ] . uuid } ) { const res = await addVideo ( { videoId : servers [ 0 ] . videos [ 0 ] . uuid , stopTimestamp : 0 } ) 0 = res . body . videoPlaylistElement . id } { const res = await addVideo ( { videoId : servers [ 0 ] . videos [ 0 ] . uuid , startTimestamp : 0 , stopTimestamp : 0 } ) 0 = res . body . videoPlaylistElement . id } { const res = await addVideo ( { videoId : 0 , startTimestamp : 0 } ) playlistElementNSFW = res . body . videoPlaylistElement . id } await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const videoElements : VideoPlaylistElement [ ] = res . body . data expect ( videoElements ) . to . have . lengthOf ( 0 ) expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . stopTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . stopTimestamp ) . to . be . null expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . be . null expect ( videoElements [ 0 ] . stopTimestamp ) . to . be . null expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . be . null expect ( videoElements [ 0 ] . stopTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . stopTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( videoElements [ 0 ] . position ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( videoElements [ 0 ] . stopTimestamp ) . to . be . null const 0 = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) expect ( 0 . body . data ) . to . have . lengthOf ( 0 ) } } ) } ) describe ( 's' , function ( ) { let 0 : ServerInfo [ ] let 0 : ServerInfo [ ] let 0 : ServerInfo [ ] let 0 : ServerInfo [ ] let 0 let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) 0 = [ Object . assign ( { } , servers [ 0 ] , { accessToken : 0 } ) ] 0 = [ Object . assign ( { } , servers [ 0 ] , { accessToken : undefined } ) ] 0 = [ servers [ 0 ] ] 0 = [ servers [ 0 ] , servers [ 0 ] ] const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : 0 , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } } ) const 0 = res . body . videoPlaylist . id 0 = res . body . videoPlaylist . uuid const addVideo = ( elementAttrs ) => { return addVideoInPlaylist ( { url : servers [ 0 ] . url , token : 0 , playlistId : 0 , elementAttrs } ) } 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' , token : 0 } ) ) . uuid 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' , nsfw : true } ) ) . uuid await addVideo ( { videoId : 0 , startTimestamp : 0 , stopTimestamp : 0 } ) await addVideo ( { videoId : 0 , startTimestamp : 0 } ) await addVideo ( { videoId : 0 } ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' const position = 0 { await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , { privacy : VideoPrivacy . PRIVATE } ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . PRIVATE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . PRIVATE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . DELETED , position , name , 0 ) } { await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , { privacy : VideoPrivacy . PUBLIC } ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . DELETED , position , name , 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' const position = 0 { await addVideoToBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 's' , true ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . DELETED , position , name , 0 ) } { await removeVideoFromBlacklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . DELETED , position , name , 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const name = 's' const position = 0 { await addAccountToAccountBlocklist ( servers [ 0 ] . url , 0 , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await removeAccountFromAccountBlocklist ( servers [ 0 ] . url , 0 , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) } { await addServerToAccountBlocklist ( servers [ 0 ] . url , 0 , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await removeServerFromAccountBlocklist ( servers [ 0 ] . url , 0 , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) } { await addAccountToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await removeAccountFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) } { await addServerToServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . UNAVAILABLE , position , name , 0 ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) await removeServerFromServerBlocklist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' + servers [ 0 ] . port ) await waitJobs ( servers ) await checkPlaylistElementType ( 0 , 0 , VideoPlaylistElementType . REGULAR , position , name , 0 ) } } ) it ( 's' , async function ( ) { const res = await getPlaylistVideos ( servers [ 0 ] . url , 0 , 0 , 0 , 0 , { nsfw : false } ) expect ( res . body . total ) . to . equal ( 0 ) const elements : VideoPlaylistElement [ ] = res . body . data const element = elements . find ( e => e . position === 0 ) expect ( element ) . to . exist expect ( element . video ) . to . be . null expect ( element . type ) . to . equal ( VideoPlaylistElementType . UNAVAILABLE ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) { await reorderVideosPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , elementAttrs : { startPosition : 0 , insertAfterPosition : 0 } } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) const names = ( res . body . data as VideoPlaylistElement [ ] ) . map ( v => v . video . name ) expect ( names ) . to . deep . equal ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) } } { await reorderVideosPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , elementAttrs : { startPosition : 0 , reorderLength : 0 , insertAfterPosition : 0 } } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) const names = ( res . body . data as VideoPlaylistElement [ ] ) . map ( v => v . video . name ) expect ( names ) . to . deep . equal ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) } } { await reorderVideosPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , elementAttrs : { startPosition : 0 , insertAfterPosition : 0 } } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) const elements : VideoPlaylistElement [ ] = res . body . data const names = elements . map ( v => v . video . name ) expect ( names ) . to . deep . equal ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) for ( let i = 0 ; i <= elements . length ; i ++ ) { expect ( elements [ i - 0 ] . position ) . to . equal ( i ) } } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideoPlaylistElement ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , playlistElementId : 0 , elementAttrs : { startTimestamp : 0 } } ) await updateVideoPlaylistElement ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , playlistElementId : 0 , elementAttrs : { stopTimestamp : null } } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) const elements : VideoPlaylistElement [ ] = res . body . data expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) expect ( elements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( elements [ 0 ] . stopTimestamp ) . to . equal ( 0 ) expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) expect ( elements [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( elements [ 0 ] . stopTimestamp ) . to . be . null } } ) it ( 's' , async function ( ) { const videoIds = [ servers [ 0 ] . videos [ 0 ] . id , 0 , servers [ 0 ] . videos [ 0 ] . id , 0 , servers [ 0 ] . videos [ 0 ] . id ] const res = await doVideosExistInMyPlaylist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoIds ) const obj = res . body as VideoExistInPlaylist { const elem = obj [ servers [ 0 ] . videos [ 0 ] . id ] expect ( elem ) . to . have . lengthOf ( 0 ) expect ( elem [ 0 ] . playlistElementId ) . to . exist expect ( elem [ 0 ] . playlistId ) . to . equal ( 0 ) expect ( elem [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( elem [ 0 ] . stopTimestamp ) . to . equal ( 0 ) } { const elem = obj [ servers [ 0 ] . videos [ 0 ] . id ] expect ( elem ) . to . have . lengthOf ( 0 ) expect ( elem [ 0 ] . playlistElementId ) . to . equal ( 0 ) expect ( elem [ 0 ] . playlistId ) . to . equal ( 0 ) expect ( elem [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( elem [ 0 ] . stopTimestamp ) . to . equal ( 0 ) } { const elem = obj [ servers [ 0 ] . videos [ 0 ] . id ] expect ( elem ) . to . have . lengthOf ( 0 ) expect ( elem [ 0 ] . playlistId ) . to . equal ( 0 ) expect ( elem [ 0 ] . startTimestamp ) . to . equal ( 0 ) expect ( elem [ 0 ] . stopTimestamp ) . to . equal ( null ) } expect ( obj [ 0 ] ) . to . have . lengthOf ( 0 ) expect ( obj [ 0 ] ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const server = servers [ 0 ] const videoId = servers [ 0 ] . videos [ 0 ] . id async function getPlaylistNames ( ) { const res = await getAccountPlaylistsListWithToken ( server . url , server . accessToken , 's' , 0 , 0 , undefined , 's' ) return ( res . body . data as VideoPlaylist [ ] ) . map ( p => p . displayName ) } const elementAttrs = { videoId } const 0 = await addVideoInPlaylist ( { url : server . url , token : server . accessToken , playlistId : 0 , elementAttrs } ) const 0 = await addVideoInPlaylist ( { url : server . url , token : server . accessToken , playlistId : 0 , elementAttrs } ) const 0 = 0 . body . videoPlaylistElement . id const 0 = 0 . body . videoPlaylistElement . id const 0 = await getPlaylistNames ( ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) await removeVideoFromPlaylist ( { url : server . url , token : server . accessToken , playlistId : 0 , playlistElementId : 0 } ) const 0 = await getPlaylistNames ( ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) await removeVideoFromPlaylist ( { url : server . url , token : server . accessToken , playlistId : 0 , playlistElementId : 0 } ) const 0 = await getPlaylistNames ( ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) expect ( 0 [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , playlistElementId : 0 } ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : 0 , playlistElementId : playlistElementNSFW } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getPlaylistVideos ( server . url , server . accessToken , 0 , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const elements : VideoPlaylistElement [ ] = res . body . data expect ( elements ) . to . have . lengthOf ( 0 ) expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) expect ( elements [ 0 ] . video . name ) . to . equal ( 's' ) expect ( elements [ 0 ] . position ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } } ) const videoPlaylistIds = res . body . videoPlaylist await waitJobs ( servers ) for ( const server of servers ) { await getVideoPlaylist ( server . url , videoPlaylistIds . uuid , 0 ) } const playlistAttrs = { privacy : VideoPlaylistPrivacy . PRIVATE } await updateVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : videoPlaylistIds . id , playlistAttrs } ) await waitJobs ( servers ) for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { await getVideoPlaylist ( server . url , videoPlaylistIds . uuid , 0 ) } await getVideoPlaylist ( servers [ 0 ] . url , videoPlaylistIds . uuid , 0 ) await getVideoPlaylistWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoPlaylistIds . uuid , 0 ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) await deleteVideoPlaylist ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 ) await waitJobs ( servers ) for ( const server of servers ) { await getVideoPlaylist ( server . url , 0 , 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { await checkPlaylistFilesWereRemoved ( 0 , server . internalServerNumber ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const finder = data => data . find ( p => p . displayName === 's' ) { const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( finder ( res . body . data ) ) . to . not . be . undefined } await unfollow ( servers [ 0 ] . url , servers [ 0 ] . accessToken , servers [ 0 ] ) { const res = await getVideoPlaylistsList ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( finder ( res . body . data ) ) . to . be . undefined } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await addVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , displayName : 's' } ) const videoChannelId = res . body . videoChannel . id const 0 = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId } } ) const videoPlaylistUUID = 0 . body . videoPlaylist . uuid await waitJobs ( servers ) await deleteVideoChannel ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 's' ) await waitJobs ( servers ) const 0 = await getVideoPlaylistWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoPlaylistUUID ) expect ( 0 . body . displayName ) . to . equal ( 's' ) expect ( 0 . body . privacy . id ) . to . equal ( VideoPlaylistPrivacy . PRIVATE ) await getVideoPlaylist ( servers [ 0 ] . url , videoPlaylistUUID , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const user = { username : 's' , password : 's' } const res = await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) const userId = res . body . user . id const userAccessToken = await userLogin ( servers [ 0 ] , user ) const resChannel = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const userChannel = ( resChannel . body as User ) . videoChannels [ 0 ] await createVideoPlaylist ( { url : servers [ 0 ] . url , token : userAccessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : userChannel . id } } ) await waitJobs ( servers ) const finder = data => data . find ( p => p . displayName === 's' ) { for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) expect ( finder ( res . body . data ) ) . to . not . be . undefined } } await removeUser ( servers [ 0 ] . url , userId , servers [ 0 ] . accessToken ) await waitJobs ( servers ) { for ( const server of [ servers [ 0 ] , servers [ 0 ] ] ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) expect ( finder ( res . body . data ) ) . to . be . undefined } } } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $VideoPlaylistElementType$ O $number$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O $VideoPlaylistElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $string$ O $string$ O $number$ O $number$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoPlaylist$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { addVideoInPlaylist , cleanupTests , createVideoPlaylist , doubleFollow , flushAndRunMultipleServers , getVideoPlaylistsList , removeVideoFromPlaylist , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , testImage , uploadVideoAndGetId , waitJobs , reorderVideosPlaylist } from 's' import { VideoPlaylistPrivacy } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let playlistWithoutThumbnail let playlistWithThumbnail let 0 let 0 let 0 let 0 let 0 let 0 async function getPlaylistWithoutThumbnail ( server ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) return res . body . data . find ( p => p . displayName === 's' ) } async function getPlaylistWithThumbnail ( server ) { const res = await getVideoPlaylistsList ( server . url , 0 , 0 ) return res . body . data . find ( p => p . displayName === 's' ) } before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 , { transcoding : { enabled : false } } ) await setAccessTokensToServers ( servers ) await setDefaultVideoChannel ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . id 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . id await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id } } ) playlistWithoutThumbnail = res . body . videoPlaylist . id const 0 = await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithoutThumbnail , elementAttrs : { videoId : 0 } } ) 0 = 0 . body . videoPlaylistElement . id await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithoutThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await createVideoPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : servers [ 0 ] . videoChannel . id , thumbnailfile : 's' } } ) playlistWithThumbnail = res . body . videoPlaylist . id const 0 = await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithThumbnail , elementAttrs : { videoId : 0 } } ) 0 = 0 . body . videoPlaylistElement . id await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithoutThumbnail , elementAttrs : { videoId : 0 } } ) 0 = res . body . videoPlaylistElement . id await reorderVideosPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithoutThumbnail , elementAttrs : { startPosition : 0 , insertAfterPosition : 0 } } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithoutThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await addVideoInPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithThumbnail , elementAttrs : { videoId : 0 } } ) 0 = res . body . videoPlaylistElement . id await reorderVideosPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithThumbnail , elementAttrs : { startPosition : 0 , insertAfterPosition : 0 } } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithoutThumbnail , playlistElementId : 0 } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithoutThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithThumbnail , playlistElementId : 0 } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithoutThumbnail , playlistElementId : 0 } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithoutThumbnail ( server ) expect ( p . thumbnailPath ) . to . be . null } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await removeVideoFromPlaylist ( { url : servers [ 0 ] . url , token : servers [ 0 ] . accessToken , playlistId : playlistWithThumbnail , playlistElementId : 0 } ) await waitJobs ( servers ) for ( const server of servers ) { const p = await getPlaylistWithThumbnail ( server ) await testImage ( server . url , 's' , p . thumbnailPath ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoPrivacy } from 's' import { cleanupTests , flushAndRunMultipleServers , getVideosList , getVideosListWithToken , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { doubleFollow } from 's' import { userLogin } from 's' import { createUser } from 's' import { getMyVideos , getVideo , getVideoWithToken , updateVideo } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let privateVideoId let privateVideoUUID let unlistedVideoUUID let now before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { privacy : VideoPrivacy . PRIVATE } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( servers [ 0 ] . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) privateVideoId = res . body . data [ 0 ] . id privateVideoUUID = res . body . data [ 0 ] . uuid } ) it ( 's' , async function ( ) { await getVideo ( servers [ 0 ] . url , privateVideoUUID , 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const user = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : user . username , password : user . password } ) const token = await userLogin ( servers [ 0 ] , user ) await getVideoWithToken ( servers [ 0 ] . url , token , privateVideoUUID , 0 ) } ) it ( 's' , async function ( ) { await getVideoWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , privateVideoUUID ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attributes = { name : 's' , privacy : VideoPrivacy . UNLISTED } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } } ) it ( 's' , async function ( ) { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) unlistedVideoUUID = res . body . data [ 0 ] . uuid } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideo ( server . url , unlistedVideoUUID ) expect ( res . body . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const attribute = { name : 's' , privacy : VideoPrivacy . PUBLIC } now = Date . now ( ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , privateVideoId , attribute ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) expect ( new Date ( res . body . data [ 0 ] . publishedAt ) . getTime ( ) ) . to . be . at . least ( now ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , privateVideoId , { privacy : VideoPrivacy . PRIVATE } ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoPrivacy } from 's' import { cleanupTests , doubleFollow , flushAndRunMultipleServers , getMyVideos , getVideosList , getVideoWithToken , killallServers , ServerInfo , setAccessTokensToServers , updateVideo , uploadVideo , wait } from 's' import { waitJobs } from 's' const expect = chai . expect function 0 ( ) { const now = new Date ( ) now . setSeconds ( now . getSeconds ( ) + 0 ) return now } describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , privacy : VideoPrivacy . PRIVATE , scheduleUpdate : { updateAt : 0 ( ) . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const videoFromList = res . body . data [ 0 ] const 0 = await getVideoWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoFromList . uuid ) const videoFromGet = 0 . body for ( const video of [ videoFromList , videoFromGet ] ) { expect ( video . name ) . to . equal ( 's' ) expect ( video . privacy . id ) . to . equal ( VideoPrivacy . PRIVATE ) expect ( new Date ( video . scheduledUpdate . updateAt ) ) . to . be . above ( new Date ( ) ) expect ( video . scheduledUpdate . privacy ) . to . equal ( VideoPrivacy . PUBLIC ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data [ 0 ] . name ) . to . equal ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , privacy : VideoPrivacy . PRIVATE } const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) 0 = res . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , scheduleUpdate : { updateAt : 0 ( ) . toISOString ( ) , privacy : VideoPrivacy . PUBLIC } } await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , videoAttributes ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) } } ) it ( 's' , async function ( ) { const res = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) const video = res . body . data . find ( v => v . uuid === 0 ) expect ( video ) . not . to . be . undefined expect ( video . name ) . to . equal ( 's' ) expect ( video . privacy . id ) . to . equal ( VideoPrivacy . PRIVATE ) expect ( new Date ( video . scheduledUpdate . updateAt ) ) . to . be . above ( new Date ( ) ) expect ( video . scheduledUpdate . privacy ) . to . equal ( VideoPrivacy . PUBLIC ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await wait ( 0 ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const video = res . body . data . find ( v => v . uuid === 0 ) expect ( video ) . not . to . be . undefined expect ( video . name ) . to . equal ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { omit } from 's' import { getMaxBitrate , VideoDetails , VideoResolution , VideoState } from 's' import { audio , canDoQuickTranscode , getVideoFileBitrate , getVideoFileFPS , getVideoFileResolution } from 's' import { buildAbsoluteFixturePath , cleanupTests , doubleFollow , flushAndRunMultipleServers , generateHighBitrateVideo , getMyVideos , getVideo , getVideosList , makeGetRequest , root , ServerInfo , setAccessTokensToServers , uploadVideo , waitJobs , webtorrentAdd } from 's' import { join } from 's' import { VIDEO_TRANSCODING_FPS } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , description : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data [ 0 ] const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const magnetUri = videoDetails . files [ 0 ] . magnetUri expect ( magnetUri ) . to . match ( "s" ) const torrent = await webtorrentAdd ( magnetUri , true ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . match ( "s" ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , description : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const magnetUri = videoDetails . files [ 0 ] . magnetUri expect ( magnetUri ) . to . match ( "s" ) const torrent = await webtorrentAdd ( magnetUri , true ) expect ( torrent . files ) . to . be . an ( 's' ) expect ( torrent . files . length ) . to . equal ( 0 ) expect ( torrent . files [ 0 ] . path ) . match ( "s" ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' ) const probe = await audio . get ( path ) if ( probe . audioStream ) { expect ( probe . audioStream [ 's' ] ) . to . be . equal ( 's' ) expect ( probe . audioStream [ 's' ] ) . to . be . at . most ( 0 * 0 ) } else { this . fail ( 's' + probe . absolutePath ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' ) const probe = await audio . get ( path ) expect ( probe ) . to . not . have . property ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const fixturePath = buildAbsoluteFixturePath ( videoAttributes . fixture ) const fixtureVideoProbe = await audio . get ( fixturePath ) const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' ) const videoProbe = await audio . get ( path ) if ( videoProbe . audioStream && fixtureVideoProbe . audioStream ) { const toOmit = [ 's' , 's' , 's' , 's' , 's' , 's' ] expect ( omit ( videoProbe . audioStream , toOmit ) ) . to . be . deep . equal ( omit ( fixtureVideoProbe . audioStream , toOmit ) ) } else { this . fail ( 's' + videoProbe . absolutePath ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributes = { name : 's' , description : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) expect ( videoDetails . files [ 0 ] . fps ) . to . be . above ( 0 ) . and . below ( 0 ) expect ( videoDetails . files [ 0 ] . fps ) . to . be . below ( 0 ) expect ( videoDetails . files [ 0 ] . fps ) . to . be . below ( 0 ) expect ( videoDetails . files [ 0 ] . fps ) . to . be . below ( 0 ) for ( const resolution of [ 's' , 's' , 's' ] ) { const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' + resolution + 's' ) const fps = await getVideoFileFPS ( path ) expect ( fps ) . to . be . below ( 0 ) } const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' ) const fps = await getVideoFileFPS ( path ) expect ( fps ) . to . be . above ( 0 ) . and . below ( 0 ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) { const videoAttributes = { name : 's' , fixture : 's' , waitTranscoding : true } const resVideo = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) const videoId = resVideo . body . video . uuid const { body } = await getVideo ( servers [ 0 ] . url , videoId ) expect ( body . name ) . to . equal ( 's' ) expect ( body . state . id ) . to . equal ( VideoState . TO_TRANSCODE ) expect ( body . state . label ) . to . equal ( 's' ) expect ( body . waitTranscoding ) . to . be . true const resMyVideos = await getMyVideos ( servers [ 0 ] . url , servers [ 0 ] . accessToken , 0 , 0 ) const videoToFindInMine = resMyVideos . body . data . find ( v => v . name === videoAttributes . name ) expect ( videoToFindInMine ) . not . to . be . undefined expect ( videoToFindInMine . state . id ) . to . equal ( VideoState . TO_TRANSCODE ) expect ( videoToFindInMine . state . label ) . to . equal ( 's' ) expect ( videoToFindInMine . waitTranscoding ) . to . be . true const resVideos = await getVideosList ( servers [ 0 ] . url ) const videoToFindInList = resVideos . body . data . find ( v => v . name === videoAttributes . name ) expect ( videoToFindInList ) . to . be . undefined await getVideo ( servers [ 0 ] . url , videoId , 0 ) } await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videoToFind = res . body . data . find ( v => v . name === 's' ) expect ( videoToFind ) . not . to . be . undefined const 0 = await getVideo ( server . url , videoToFind . id ) const videoDetails = 0 . body expect ( videoDetails . state . id ) . to . equal ( VideoState . PUBLISHED ) expect ( videoDetails . state . label ) . to . equal ( 's' ) expect ( videoDetails . waitTranscoding ) . to . be . true } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let tempFixturePath { tempFixturePath = await generateHighBitrateVideo ( ) const bitrate = await getVideoFileBitrate ( tempFixturePath ) expect ( bitrate ) . to . be . above ( getMaxBitrate ( VideoResolution . 0 , 0 , VIDEO_TRANSCODING_FPS ) ) } const videoAttributes = { name : 's' , description : 's' , fixture : tempFixturePath } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) for ( const resolution of [ 's' , 's' , 's' , 's' , 's' ] ) { const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' + resolution + 's' ) const bitrate = await getVideoFileBitrate ( path ) const fps = await getVideoFileFPS ( path ) const 0 = await getVideoFileResolution ( path ) expect ( 0 . videoFileResolution . toString ( ) ) . to . equal ( resolution ) expect ( bitrate ) . to . be . below ( getMaxBitrate ( 0 . videoFileResolution , fps , VIDEO_TRANSCODING_FPS ) ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) let tempFixturePath { tempFixturePath = await generateHighBitrateVideo ( ) const bitrate = await getVideoFileBitrate ( tempFixturePath ) expect ( bitrate ) . to . be . above ( getMaxBitrate ( VideoResolution . 0 , 0 , VIDEO_TRANSCODING_FPS ) ) } for ( const fixture of [ 's' , 's' ] ) { const videoAttributes = { name : fixture , fixture } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === videoAttributes . name ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) const magnetUri = videoDetails . files [ 0 ] . magnetUri expect ( magnetUri ) . to . contain ( 's' ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) expect ( await canDoQuickTranscode ( buildAbsoluteFixturePath ( 's' ) ) ) . to . be . true expect ( await canDoQuickTranscode ( buildAbsoluteFixturePath ( 's' ) ) ) . to . be . false } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributesArg = { name : 's' , previewfile : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributesArg ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === 's' ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) await makeGetRequest ( { url : server . url , path : videoDetails . thumbnailPath , statusCodeExpected : 0 } ) await makeGetRequest ( { url : server . url , path : videoDetails . previewPath , statusCodeExpected : 0 } ) const magnetUri = videoDetails . files [ 0 ] . magnetUri expect ( magnetUri ) . to . contain ( 's' ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const videoAttributesArg = { name : 's' , fixture : 's' } await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributesArg ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const video = res . body . data . find ( v => v . name === 's' ) const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) await makeGetRequest ( { url : server . url , path : videoDetails . thumbnailPath , statusCodeExpected : 0 } ) await makeGetRequest ( { url : server . url , path : videoDetails . previewPath , statusCodeExpected : 0 } ) const magnetUri = videoDetails . files [ 0 ] . magnetUri expect ( magnetUri ) . to . contain ( 's' ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , flushTests , killallServers , makeGetRequest , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin } from 's' import { Video , VideoPrivacy } from 's' import { UserRole } from 's' const expect = chai . expect async function getVideosNames ( server , token , filter , statusCodeExpected = 0 ) { const paths = [ 's' , 's' , 's' , 's' ] const videosResults : Video [ ] [ ] = [ ] for ( const path of paths ) { const res = await makeGetRequest ( { url : server . url , path , token , query : { sort : 's' , filter } , statusCodeExpected } ) videosResults . push ( res . body . data . map ( v => v . name ) ) } return videosResults } describe ( 's' , function ( ) { let servers : ServerInfo [ ] before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) for ( const server of servers ) { const moderator = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : moderator . username , password : moderator . password , videoQuota : undefined , videoQuotaDaily : undefined , role : UserRole . MODERATOR } ) server [ 's' ] = await userLogin ( server , moderator ) await uploadVideo ( server . url , server . accessToken , { name : 's' + server . serverNumber } ) { const attributes = { name : 's' + server . serverNumber , privacy : VideoPrivacy . UNLISTED } await uploadVideo ( server . url , server . accessToken , attributes ) } { const attributes = { name : 's' + server . serverNumber , privacy : VideoPrivacy . PRIVATE } await uploadVideo ( server . url , server . accessToken , attributes ) } } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const server of servers ) { const namesResults = await getVideosNames ( server , server . accessToken , 's' ) for ( const names of namesResults ) { expect ( names ) . to . have . lengthOf ( 0 ) expect ( names [ 0 ] ) . to . equal ( 's' + server . serverNumber ) } } } ) it ( 's' , async function ( ) { for ( const server of servers ) { for ( const token of [ server . accessToken , server [ 's' ] ] ) { const namesResults = await getVideosNames ( server , token , 's' ) for ( const names of namesResults ) { expect ( names ) . to . have . lengthOf ( 0 ) expect ( names [ 0 ] ) . to . equal ( 's' + server . serverNumber ) expect ( names [ 0 ] ) . to . equal ( 's' + server . serverNumber ) expect ( names [ 0 ] ) . to . equal ( 's' + server . serverNumber ) } } } } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest , makePostBodyRequest , makePutBodyRequest } from 's' function userWatchVideo ( url , token , videoId : number | string , currentTime , statusCodeExpected = 0 ) { const path = 's' + videoId + 's' const fields = { currentTime } return makePutBodyRequest ( { url , path , token , fields , statusCodeExpected } ) } function listMyVideosHistory ( url , token ) { const path = 's' return makeGetRequest ( { url , path , token , statusCodeExpected : 0 } ) } function removeMyVideosHistory ( url , token , beforeDate ? ) { const path = 's' return makePostBodyRequest ( { url , path , token , fields : beforeDate ? { beforeDate } : { } , statusCodeExpected : 0 } ) } export { userWatchVideo , listMyVideosHistory , removeMyVideosHistory }	O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , createUser , flushAndRunServer , getVideosListWithToken , getVideoWithToken , killallServers , reRunServer , searchVideoWithToken , ServerInfo , setAccessTokensToServers , updateMyUser , uploadVideo , userLogin , wait } from 's' import { Video , VideoDetails } from 's' import { listMyVideosHistory , removeMyVideosHistory , userWatchVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null let 0 let 0 let 0 let 0 let userAccessToken before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) { const res = await uploadVideo ( server . url , server . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( server . url , server . accessToken , { name : 's' } ) 0 = res . body . video . uuid } { const res = await uploadVideo ( server . url , server . accessToken , { name : 's' } ) 0 = res . body . video . uuid } const user = { username : 's' , password : 's' } await createUser ( { url : server . url , accessToken : server . accessToken , username : user . username , password : user . password } ) userAccessToken = await userLogin ( server , user ) } ) it ( 's' , async function ( ) { const res = await getVideosListWithToken ( server . url , server . accessToken ) const videos : Video [ ] = res . body . data for ( const video of videos ) { const resDetail = await getVideoWithToken ( server . url , server . accessToken , video . id ) const videoDetails = resDetail . body expect ( video . userHistory ) . to . be . undefined expect ( videoDetails . userHistory ) . to . be . undefined } } ) it ( 's' , async function ( ) { await userWatchVideo ( server . url , server . accessToken , 0 , 0 ) await userWatchVideo ( server . url , server . accessToken , 0 , 0 ) } ) it ( 's' , async function ( ) { const videosOfVideos : Video [ ] [ ] = [ ] { const res = await getVideosListWithToken ( server . url , server . accessToken ) videosOfVideos . push ( res . body . data ) } { const res = await searchVideoWithToken ( server . url , 's' , server . accessToken ) videosOfVideos . push ( res . body . data ) } for ( const videos of videosOfVideos ) { const 0 = videos . find ( v => v . uuid === 0 ) const 0 = videos . find ( v => v . uuid === 0 ) const 0 = videos . find ( v => v . uuid === 0 ) expect ( 0 . userHistory ) . to . not . be . undefined expect ( 0 . userHistory . currentTime ) . to . equal ( 0 ) expect ( 0 . userHistory ) . to . not . be . undefined expect ( 0 . userHistory . currentTime ) . to . equal ( 0 ) expect ( 0 . userHistory ) . to . be . undefined } { const resDetail = await getVideoWithToken ( server . url , server . accessToken , 0 ) const videoDetails = resDetail . body expect ( videoDetails . userHistory ) . to . not . be . undefined expect ( videoDetails . userHistory . currentTime ) . to . equal ( 0 ) } { const resDetail = await getVideoWithToken ( server . url , server . accessToken , 0 ) const videoDetails = resDetail . body expect ( videoDetails . userHistory ) . to . not . be . undefined expect ( videoDetails . userHistory . currentTime ) . to . equal ( 0 ) } { const resDetail = await getVideoWithToken ( server . url , server . accessToken , 0 ) const videoDetails = resDetail . body expect ( videoDetails . userHistory ) . to . be . undefined } } ) it ( 's' , async function ( ) { 0 = new Date ( ) await userWatchVideo ( server . url , server . accessToken , 0 , 0 ) const res = await listMyVideosHistory ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await listMyVideosHistory ( server . url , userAccessToken ) expect ( res . body . total ) . to . equal ( 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { await removeMyVideosHistory ( server . url , server . accessToken , 0 . toISOString ( ) ) } ) it ( 's' , async function ( ) { const res = await listMyVideosHistory ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : server . accessToken , videosHistoryEnabled : false } ) await userWatchVideo ( server . url , server . accessToken , 0 , 0 , 0 ) } ) it ( 's' , async function ( ) { await updateMyUser ( { url : server . url , accessToken : server . accessToken , videosHistoryEnabled : true } ) await userWatchVideo ( server . url , server . accessToken , 0 , 0 ) const res = await listMyVideosHistory ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data expect ( videos [ 0 ] . name ) . to . equal ( 's' ) expect ( videos [ 0 ] . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server , { history : { videos : { max_age : 's' } } } ) await wait ( 0 ) const res = await listMyVideosHistory ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server , { history : { videos : { max_age : 's' } } } ) await wait ( 0 ) const res = await listMyVideosHistory ( server . url , server . accessToken ) expect ( res . body . total ) . to . equal ( 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O $string$ O $string$ O $string$ O $Date$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeGetRequest } from 's' function getVideosOverview ( url , useCache = false ) { const path = 's' const query = { t : useCache ? undefined : new Date ( ) . getTime ( ) } return makeGetRequest ( { url , path , query , statusCodeExpected : 0 } ) } export { getVideosOverview }	O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunServer , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { getVideosOverview } from 's' import { VideosOverview } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server = null before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { const res = await getVideosOverview ( server . url ) const overview = res . body expect ( overview . tags ) . to . have . lengthOf ( 0 ) expect ( overview . categories ) . to . have . lengthOf ( 0 ) expect ( overview . channels ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( let i = 0 ; i < 0 ; i ++ ) { await uploadVideo ( server . url , server . accessToken , { name : 's' + i , category : 0 , tags : [ 's' , 's' ] } ) } const res = await getVideosOverview ( server . url ) const overview = res . body expect ( overview . tags ) . to . have . lengthOf ( 0 ) expect ( overview . categories ) . to . have . lengthOf ( 0 ) expect ( overview . channels ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { await uploadVideo ( server . url , server . accessToken , { name : 's' , category : 0 , tags : [ 's' , 's' ] } ) const res = await getVideosOverview ( server . url ) const overview = res . body expect ( overview . tags ) . to . have . lengthOf ( 0 ) expect ( overview . categories ) . to . have . lengthOf ( 0 ) expect ( overview . channels ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosOverview ( server . url ) const overview = res . body for ( const attr of [ 's' , 's' , 's' ] ) { const obj = overview [ attr ] [ 0 ] expect ( obj . videos ) . to . have . lengthOf ( 0 ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) expect ( obj . videos [ 0 ] . name ) . to . equal ( 's' ) } expect ( overview . tags . find ( t => t . tag === 's' ) ) . to . not . be . undefined expect ( overview . tags . find ( t => t . tag === 's' ) ) . to . not . be . undefined expect ( overview . categories [ 0 ] . category . id ) . to . equal ( 0 ) expect ( overview . channels [ 0 ] . channel . name ) . to . equal ( 's' ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosOverview$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosOverview$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosOverview$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideosOverview$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { flushAndRunMultipleServers , flushTests , killallServers , reRunServer , flushAndRunServer , ServerInfo , setAccessTokensToServers , uploadVideo , uploadVideoAndGetId , viewVideo , wait , countVideoViewsOf , doubleFollow , waitJobs , cleanupTests , closeAllSequelize } from 's' import { getVideosOverview } from 's' import { VideosOverview } from 's' import { listMyVideosHistory } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid 0 = ( await uploadVideoAndGetId ( { server : servers [ 0 ] , videoName : 's' } ) ) . uuid await waitJobs ( servers ) await viewVideo ( servers [ 0 ] . url , 0 ) await viewVideo ( servers [ 0 ] . url , 0 ) await viewVideo ( servers [ 0 ] . url , 0 ) await viewVideo ( servers [ 0 ] . url , 0 ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) await reRunServer ( servers [ 0 ] , { views : { videos : { remote : { max_age : 's' } } } } ) await wait ( 0 ) { for ( const server of servers ) { const total = await countVideoViewsOf ( server . internalServerNumber , 0 ) expect ( total ) . to . equal ( 0 ) } } { for ( const server of servers ) { const total = await countVideoViewsOf ( server . internalServerNumber , 0 ) expect ( total ) . to . equal ( 0 ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ servers [ 0 ] ] ) await reRunServer ( servers [ 0 ] , { views : { videos : { remote : { max_age : 's' } } } } ) await wait ( 0 ) { for ( const server of servers ) { const total = await countVideoViewsOf ( server . internalServerNumber , 0 ) expect ( total ) . to . equal ( 0 ) } } { const 0 = await countVideoViewsOf ( servers [ 0 ] . internalServerNumber , 0 ) expect ( 0 ) . to . equal ( 0 ) const 0 = await countVideoViewsOf ( servers [ 0 ] . internalServerNumber , 0 ) expect ( 0 ) . to . equal ( 0 ) } } ) after ( async function ( ) { await closeAllSequelize ( servers ) await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { VideoDetails , VideoFile } from 's' import { cleanupTests , doubleFollow , execCLI , flushAndRunMultipleServers , flushTests , getEnvCli , getVideo , getVideosList , killallServers , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { waitJobs } from 's' const expect = chai . expect function assertVideoProperties ( video , resolution , extname , size ? ) { expect ( video ) . to . have . nested . property ( 's' , resolution ) expect ( video ) . to . have . property ( 's' ) . that . includes ( `template` ) expect ( video ) . to . have . property ( 's' ) . that . includes ( `template` ) expect ( video ) . to . have . property ( 's' ) . that . includes ( `template` ) expect ( video ) . to . have . property ( 's' ) . that . is . above ( 0 ) if ( size ) expect ( video . size ) . to . equal ( size ) } describe ( 's' , function ( ) { this . timeout ( 0 ) let servers : ServerInfo [ ] = [ ] let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = 0 . body . video . uuid const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = 0 . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) let magnetUri for ( const server of servers ) { const { data : videos } = ( await getVideosList ( server . url ) ) . body expect ( videos ) . to . have . lengthOf ( 0 ) const video = videos . find ( ( { uuid } ) => uuid === 0 ) const videoDetail = ( await getVideo ( server . url , video . uuid ) ) . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) const [ originalVideo , transcodedVideo ] = videoDetail . files assertVideoProperties ( originalVideo , 0 , 's' , 0 ) assertVideoProperties ( transcodedVideo , 0 , 's' , 0 ) if ( ! magnetUri ) magnetUri = transcodedVideo . magnetUri else expect ( transcodedVideo . magnetUri ) . to . equal ( magnetUri ) } } ) it ( 's' , async function ( ) { const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) let magnetUri for ( const server of servers ) { const { data : videos } = ( await getVideosList ( server . url ) ) . body expect ( videos ) . to . have . lengthOf ( 0 ) const video = videos . find ( ( { uuid } ) => uuid === 0 ) const videoDetail = ( await getVideo ( server . url , video . uuid ) ) . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) const [ originalVideo , 0 , 0 , 0 ] = videoDetail . files assertVideoProperties ( originalVideo , 0 , 's' , 0 ) assertVideoProperties ( 0 , 0 , 's' ) assertVideoProperties ( 0 , 0 , 's' ) assertVideoProperties ( 0 , 0 , 's' ) if ( ! magnetUri ) magnetUri = originalVideo . magnetUri else expect ( originalVideo . magnetUri ) . to . equal ( magnetUri ) } } ) it ( 's' , async function ( ) { const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) let magnetUri for ( const server of servers ) { const { data : videos } = ( await getVideosList ( server . url ) ) . body expect ( videos ) . to . have . lengthOf ( 0 ) const video = videos . find ( ( { uuid } ) => uuid === 0 ) const videoDetail = ( await getVideo ( server . url , video . uuid ) ) . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) const [ 0 , 0 ] = videoDetail . files assertVideoProperties ( 0 , 0 , 's' , 0 ) assertVideoProperties ( 0 , 0 , 's' , 0 ) if ( ! magnetUri ) magnetUri = 0 . magnetUri else expect ( 0 . magnetUri ) . to . equal ( magnetUri ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFile$ O $number$ O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { VideoDetails } from 's' import { cleanupTests , doubleFollow , execCLI , flushAndRunMultipleServers , flushTests , getEnvCli , getVideo , getVideosList , killallServers , ServerInfo , setAccessTokensToServers , uploadVideo , wait } from 's' import { waitJobs } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = 0 . body . video . uuid const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) 0 = 0 . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) for ( const video of videos ) { const 0 = await getVideo ( server . url , video . uuid ) const videoDetail = 0 . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) let infoHashes : { [ id ] : string } for ( const video of videos ) { const 0 = await getVideo ( server . url , video . uuid ) const videoDetail = 0 . body if ( video . uuid === 0 ) { expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) if ( ! infoHashes ) { infoHashes = { } for ( const file of videoDetail . files ) { infoHashes [ file . resolution . id . toString ( ) ] = file . magnetUri } } else { for ( const resolution of Object . keys ( infoHashes ) ) { const file = videoDetail . files . find ( f => f . resolution . id . toString ( ) === resolution ) expect ( file . magnetUri ) . to . equal ( infoHashes [ resolution ] ) } } } else { expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) } } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) const 0 = await getVideo ( server . url , 0 ) const videoDetail = 0 . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) expect ( videoDetail . files [ 0 ] . resolution . id ) . to . equal ( 0 ) expect ( videoDetail . files [ 0 ] . resolution . id ) . to . equal ( 0 ) } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { getMaxBitrate , Video , VideoDetails , VideoResolution } from 's' import { cleanupTests , doubleFollow , execCLI , flushAndRunMultipleServers , generateHighBitrateVideo , getEnvCli , getVideo , getVideosList , root , ServerInfo , setAccessTokensToServers , uploadVideo , viewVideo , wait } from 's' import { waitJobs } from 's' import { getVideoFileBitrate , getVideoFileFPS , getVideoFileResolution } from 's' import { VIDEO_TRANSCODING_FPS } from 's' import { join } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] = [ ] let 0 let 0 before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) let tempFixturePath { tempFixturePath = await generateHighBitrateVideo ( ) const bitrate = await getVideoFileBitrate ( tempFixturePath ) expect ( bitrate ) . to . be . above ( getMaxBitrate ( VideoResolution . 0 , 0 , VIDEO_TRANSCODING_FPS ) ) } const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , fixture : tempFixturePath } ) 0 = 0 . body . video . uuid const 0 = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' , fixture : tempFixturePath } ) 0 = 0 . body . video . uuid await waitJobs ( servers ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) for ( const video of videos ) { const 0 = await getVideo ( server . url , video . uuid ) const videoDetail = 0 . body expect ( videoDetail . files ) . to . have . lengthOf ( 0 ) } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) await waitJobs ( servers ) for ( const server of servers ) { const res = await getVideosList ( server . url ) const videos : Video [ ] = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) for ( const video of videos ) { await viewVideo ( server . url , video . uuid ) await waitJobs ( servers ) await wait ( 0 ) await waitJobs ( servers ) const 0 = await getVideo ( server . url , video . uuid ) const videosDetails = 0 . body expect ( videosDetails . files ) . to . have . lengthOf ( 0 ) const file = videosDetails . files [ 0 ] expect ( file . size ) . to . be . below ( 0 ) const path = join ( root ( ) , 's' + servers [ 0 ] . internalServerNumber , 's' , video . uuid + 's' + file . resolution . id + 's' ) const bitrate = await getVideoFileBitrate ( path ) const fps = await getVideoFileFPS ( path ) const resolution = await getVideoFileResolution ( path ) expect ( resolution . videoFileResolution ) . to . equal ( file . resolution . id ) expect ( bitrate ) . to . be . below ( getMaxBitrate ( resolution . videoFileResolution , fps , VIDEO_TRANSCODING_FPS ) ) } } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { expect } from 's' import { addVideoChannel , buildAbsoluteFixturePath , cleanupTests , createUser , execCLI , flushAndRunServer , getEnvCli , getVideo , getVideosList , getVideosListWithToken , removeVideo , ServerInfo , setAccessTokensToServers , userLogin , waitJobs } from 's' import { Video , VideoDetails } from 's' import { getYoutubeVideoUrl } from 's' describe ( 's' , function ( ) { let server let userAccessToken const cmd = 's' before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await createUser ( { url : server . url , accessToken : server . accessToken , username : 's' , password : 's' } ) userAccessToken = await userLogin ( server , { username : 's' , password : 's' } ) { const args = { name : 's' , displayName : 's' , support : 's' } await addVideoChannel ( server . url , userAccessToken , args ) } } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const stdout = await execCLI ( `template` ) expect ( stdout ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const stdout = await execCLI ( `template` ) expect ( stdout ) . to . contain ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const stdout = await execCLI ( `template` ) expect ( stdout ) . to . contain ( server . url ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const fixture = buildAbsoluteFixturePath ( 's' ) const params = `template` await execCLI ( `template` ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data const video = ( await getVideo ( server . url , videos [ 0 ] . uuid ) ) . body expect ( video . name ) . to . equal ( 's' ) expect ( video . support ) . to . equal ( 's' ) expect ( video . channel . name ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const params = `template` await execCLI ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await waitJobs ( [ server ] ) const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data const video = videos . find ( v => v . name === 's' ) expect ( video ) . to . not . be . undefined const videoDetails = ( await getVideo ( server . url , video . id ) ) . body expect ( videoDetails . channel . name ) . to . equal ( 's' ) expect ( videoDetails . support ) . to . equal ( 's' ) expect ( videoDetails . nsfw ) . to . be . false await removeVideo ( server . url , userAccessToken , video . id ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) const params = `template` await execCLI ( `template` ) await waitJobs ( [ server ] ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) const videos : Video [ ] = res . body . data const video = videos . find ( v => v . name === 's' ) expect ( video ) . to . not . be . undefined const videoDetails = ( await getVideo ( server . url , video . id ) ) . body expect ( videoDetails . channel . name ) . to . equal ( 's' ) expect ( videoDetails . support ) . to . equal ( 's' ) expect ( videoDetails . nsfw ) . to . be . true expect ( videoDetails . commentsEnabled ) . to . be . true } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const env = getEnvCli ( server ) await execCLI ( `template` ) const stdout = await execCLI ( `template` ) expect ( stdout ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const env = getEnvCli ( server ) await execCLI ( `template` ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { const env = getEnvCli ( server ) const res = await execCLI ( `template` ) expect ( res ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const env = getEnvCli ( server ) const res = await execCLI ( `template` ) expect ( res ) . to . not . contain ( 's' ) } ) } ) after ( async function ( ) { this . timeout ( 0 ) await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , execCLI , flushAndRunServer , getConfig , getEnvCli , getPluginTestPath , killallServers , reRunServer , ServerInfo , setAccessTokensToServers } from 's' import { ServerConfig } from 's' import { expect } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const packagePath = getPluginTestPath ( ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server ) const res = await getConfig ( server . url ) const config = res . body const plugin = config . plugin . registered . find ( p => p . name === 's' ) expect ( plugin ) . to . not . be . undefined const theme = config . theme . registered . find ( t => t . name === 's' ) expect ( theme ) . to . not . be . undefined } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server ) const res = await getConfig ( server . url ) const config = res . body const plugin = config . plugin . registered . find ( p => p . name === 's' ) expect ( plugin ) . to . be . undefined } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { waitJobs } from 's' import { buildServerDirectory , cleanupTests , createVideoPlaylist , doubleFollow , execCLI , flushAndRunMultipleServers , getAccount , getEnvCli , ServerInfo , setAccessTokensToServers , setDefaultVideoChannel , updateMyAvatar , uploadVideo , wait } from 's' import { Account , VideoPlaylistPrivacy } from 's' import { createFile , readdir } from 's' import * as 0 from 's' import { join } from 's' import * as request from 's' const expect = chai . expect async function countFiles ( internalServerNumber , directory ) { const files = await readdir ( buildServerDirectory ( internalServerNumber , directory ) ) return files . length } async function assertNotExists ( internalServerNumber , directory , substring ) { const files = await readdir ( buildServerDirectory ( internalServerNumber , directory ) ) for ( const f of files ) { expect ( f ) . to . not . contain ( substring ) } } async function assertCountAreOkay ( servers : ServerInfo [ ] ) { for ( const server of servers ) { const videosCount = await countFiles ( server . internalServerNumber , 's' ) expect ( videosCount ) . to . equal ( 0 ) const torrentsCount = await countFiles ( server . internalServerNumber , 's' ) expect ( torrentsCount ) . to . equal ( 0 ) const previewsCount = await countFiles ( server . internalServerNumber , 's' ) expect ( previewsCount ) . to . equal ( 0 ) const thumbnailsCount = await countFiles ( server . internalServerNumber , 's' ) expect ( thumbnailsCount ) . to . equal ( 0 ) const avatarsCount = await countFiles ( server . internalServerNumber , 's' ) expect ( avatarsCount ) . to . equal ( 0 ) } } describe ( 's' , function ( ) { let servers : ServerInfo [ ] const badNames : { [ directory ] : string [ ] } = { } before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 , { transcoding : { enabled : true } } ) await setAccessTokensToServers ( servers ) await setDefaultVideoChannel ( servers ) for ( const server of servers ) { await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await uploadVideo ( server . url , server . accessToken , { name : 's' } ) await updateMyAvatar ( { url : server . url , accessToken : server . accessToken , fixture : 's' } ) await createVideoPlaylist ( { url : server . url , token : server . accessToken , playlistAttrs : { displayName : 's' , privacy : VideoPlaylistPrivacy . PUBLIC , videoChannelId : server . videoChannel . id , thumbnailfile : 's' } } ) } await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const res = await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port ) const account = res . body await request ( 's' + servers [ 0 ] . port ) . get ( account . avatar . path ) . expect ( 0 ) } { const res = await getAccount ( servers [ 0 ] . url , 's' + servers [ 0 ] . port ) const account = res . body await request ( 's' + servers [ 0 ] . port ) . get ( account . avatar . path ) . expect ( 0 ) } await wait ( 0 ) await waitJobs ( servers ) } ) it ( 's' , async function ( ) { await assertCountAreOkay ( servers ) } ) it ( 's' , async function ( ) { for ( let i = 0 ; i < 0 ; i ++ ) { { const base = buildServerDirectory ( servers [ 0 ] . internalServerNumber , 's' ) const 0 = 0 ( ) + 's' const 0 = 0 ( ) + 's' await createFile ( join ( base , 0 ) ) await createFile ( join ( base , 0 ) ) badNames [ 's' ] = [ 0 , 0 ] } { const base = buildServerDirectory ( servers [ 0 ] . internalServerNumber , 's' ) const 0 = 0 ( ) + 's' const 0 = 0 ( ) + 's' await createFile ( join ( base , 0 ) ) await createFile ( join ( base , 0 ) ) badNames [ 's' ] = [ 0 , 0 ] } { const base = buildServerDirectory ( servers [ 0 ] . internalServerNumber , 's' ) const 0 = 0 ( ) + 's' const 0 = 0 ( ) + 's' await createFile ( join ( base , 0 ) ) await createFile ( join ( base , 0 ) ) badNames [ 's' ] = [ 0 , 0 ] } { const base = buildServerDirectory ( servers [ 0 ] . internalServerNumber , 's' ) const 0 = 0 ( ) + 's' const 0 = 0 ( ) + 's' await createFile ( join ( base , 0 ) ) await createFile ( join ( base , 0 ) ) badNames [ 's' ] = [ 0 , 0 ] } { const base = buildServerDirectory ( servers [ 0 ] . internalServerNumber , 's' ) const 0 = 0 ( ) + 's' const 0 = 0 ( ) + 's' await createFile ( join ( base , 0 ) ) await createFile ( join ( base , 0 ) ) badNames [ 's' ] = [ 0 , 0 ] } } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( servers [ 0 ] ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { await assertCountAreOkay ( servers ) for ( const directory of Object . keys ( badNames ) ) { for ( const name of badNames [ directory ] ) { await assertNotExists ( servers [ 0 ] . internalServerNumber , directory , name ) } } } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Account$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { cleanupTests , createUser , execCLI , flushAndRunServer , getEnvCli , login , ServerInfo , setAccessTokensToServers } from 's' describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await createUser ( { url : server . url , accessToken : server . accessToken , username : 's' , password : 's' } ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const env = getEnvCli ( server ) await execCLI ( `template` ) await login ( server . url , server . client , { username : 's' , password : 's' } , 0 ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import { VideoDetails } from 's' import { waitJobs } from 's' import { addVideoCommentThread } from 's' import { addVideoChannel , cleanupTests , createUser , execCLI , flushAndRunServer , getEnvCli , getVideo , getVideoChannelsList , getVideosList , killallServers , makeActivityPubGetRequest , parseTorrentVideo , reRunServer , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { getAccountsList } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) const overrideConfig = { webserver : { port : 0 } } server = await flushAndRunServer ( 0 , overrideConfig ) await setAccessTokensToServers ( [ server ] ) const videoAttributes = { } const 0 = await uploadVideo ( server . url , server . accessToken , videoAttributes ) const 0 = 0 . body . video . uuid await uploadVideo ( server . url , server . accessToken , videoAttributes ) await createUser ( { url : server . url , accessToken : server . accessToken , username : 's' , password : 's' } ) const videoChannel = { name : 's' , displayName : 's' , description : 's' } await addVideoChannel ( server . url , server . accessToken , videoChannel ) const text = 's' await addVideoCommentThread ( server . url , server . accessToken , 0 , text ) await waitJobs ( server ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) killallServers ( [ server ] ) await reRunServer ( server ) const env = getEnvCli ( server ) await execCLI ( `template` ) } ) it ( 's' , async function ( ) { const res = await getVideosList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const video of res . body . data ) { const { body } = await makeActivityPubGetRequest ( server . url , 's' + video . uuid ) expect ( body . id ) . to . equal ( 's' + video . uuid ) const res = await getVideo ( server . url , video . uuid ) const videoDetails = res . body expect ( videoDetails . trackerUrls [ 0 ] ) . to . include ( server . host ) expect ( videoDetails . streamingPlaylists [ 0 ] . playlistUrl ) . to . include ( server . host ) expect ( videoDetails . streamingPlaylists [ 0 ] . 0 ) . to . include ( server . host ) } } ) it ( 's' , async function ( ) { const res = await getVideoChannelsList ( server . url , 0 , 0 , 's' ) expect ( res . body . total ) . to . equal ( 0 ) for ( const channel of res . body . data ) { const { body } = await makeActivityPubGetRequest ( server . url , 's' + channel . name ) expect ( body . id ) . to . equal ( 's' + channel . name ) } } ) it ( 's' , async function ( ) { const res = await getAccountsList ( server . url ) expect ( res . body . total ) . to . equal ( 0 ) for ( const account of res . body . data ) { const usernameWithDomain = account . name const { body } = await makeActivityPubGetRequest ( server . url , 's' + usernameWithDomain ) expect ( body . id ) . to . equal ( 's' + usernameWithDomain ) } } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos ) . to . have . lengthOf ( 0 ) for ( const video of videos ) { const 0 = await getVideo ( server . url , video . id ) const videoDetails = 0 . body expect ( videoDetails . files ) . to . have . lengthOf ( 0 ) for ( const file of videoDetails . files ) { expect ( file . magnetUri ) . to . contain ( 's' ) expect ( file . magnetUri ) . to . contain ( 's' ) const torrent = await parseTorrentVideo ( server , videoDetails . uuid , file . resolution . id ) const announceWS = torrent . announce . find ( a => a === 's' ) expect ( announceWS ) . to . not . be . undefined const announceHttp = torrent . announce . find ( a => a === 's' ) expect ( announceHttp ) . to . not . be . undefined expect ( torrent . urlList [ 0 ] ) . to . contain ( 's' ) } } } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O
import 's' import * as chai from 's' import * as request from 's' import { cleanupTests , flushAndRunServer , getCustomConfig , getVideosList , makeHTMLRequest , ServerInfo , serverLogin , updateCustomConfig , updateCustomSubConfig , uploadVideo } from 's' const expect = chai . expect function checkIndexTags ( html , title , description , css ) { expect ( html ) . to . contain ( 's' + title + 's' ) expect ( html ) . to . contain ( 's' + description + 's' ) expect ( html ) . to . contain ( 's' + css + 's' ) } describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) server . accessToken = await serverLogin ( server ) const videoAttributes = { name : 's' , description : 's' } await uploadVideo ( server . url , server . accessToken , videoAttributes ) const res = await getVideosList ( server . url ) const videos = res . body . data expect ( videos . length ) . to . equal ( 0 ) server . video = videos [ 0 ] } ) it ( 's' , async function ( ) { const res = await request ( server . url ) . get ( 's' + server . video . id ) . set ( 's' , 's' ) . expect ( 0 ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await request ( server . url ) . get ( 's' + server . video . uuid ) . set ( 's' , 's' ) . expect ( 0 ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const path = 's' + server . video . uuid const res = await request ( server . url ) . get ( path ) . set ( 's' , 's' ) . expect ( 0 ) const expectedLink = 's' + `template` + `template` expect ( res . text ) . to . contain ( expectedLink ) } ) it ( 's' , async function ( ) { const res = await request ( server . url ) . get ( 's' + server . video . uuid ) . set ( 's' , 's' ) . expect ( 0 ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const 0 = await getCustomConfig ( server . url , server . accessToken ) const config = 0 . body config . services . twitter = { username : 's' , whitelisted : true } await updateCustomConfig ( server . url , server . accessToken , config ) const res = await request ( server . url ) . get ( 's' + server . video . uuid ) . set ( 's' , 's' ) . expect ( 0 ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeHTMLRequest ( server . url , 's' ) const description = 's' + 's' checkIndexTags ( res . text , 's' , description , 's' ) } ) it ( 's' , async function ( ) { await updateCustomSubConfig ( server . url , server . accessToken , { instance : { name : 's' , shortDescription : 's' , description : 's' , terms : 's' , defaultClientRoute : 's' , defaultNSFWPolicy : 's' , customizations : { javascript : 's' , css : 's' } } } ) const res = await makeHTMLRequest ( server . url , 's' ) checkIndexTags ( res . text , 's' , 's' , 's' ) } ) it ( 's' , async function ( ) { const res = await makeHTMLRequest ( server . url , 's' ) checkIndexTags ( res . text , 's' , 's' , 's' ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , createUser , doubleFollow , flushAndRunMultipleServers , getJSONfeed , getMyUserInformation , getXMLfeed , ServerInfo , setAccessTokensToServers , uploadVideo , userLogin } from 's' import * as libxmljs from 's' import { addVideoCommentThread } from 's' import { waitJobs } from 's' import { User } from 's' chai . use ( require ( 's' ) ) chai . use ( require ( 's' ) ) chai . config . includeStack = true const expect = chai . expect describe ( 's' , ( ) => { let servers : ServerInfo [ ] = [ ] let userAccessToken let rootAccountId let rootChannelId let userAccountId let userChannelId before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) { const res = await getMyUserInformation ( servers [ 0 ] . url , servers [ 0 ] . accessToken ) const user = res . body rootAccountId = user . account . id rootChannelId = user . videoChannels [ 0 ] . id } { const attr = { username : 's' , password : 's' } await createUser ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , username : attr . username , password : attr . password } ) userAccessToken = await userLogin ( servers [ 0 ] , attr ) const res = await getMyUserInformation ( servers [ 0 ] . url , userAccessToken ) const user = res . body userAccountId = user . account . id userChannelId = user . videoChannels [ 0 ] . id } { await uploadVideo ( servers [ 0 ] . url , userAccessToken , { name : 's' } ) } { const videoAttributes = { name : 's' , description : 's' , fixture : 's' } const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoAttributes ) const videoId = res . body . video . id await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , 's' ) await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , 's' ) } await waitJobs ( servers ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const feed of [ 's' as 's' , 's' as 's' ] ) { const rss = await getXMLfeed ( servers [ 0 ] . url , feed ) expect ( rss . text ) . xml . to . be . valid ( ) const atom = await getXMLfeed ( servers [ 0 ] . url , feed , 's' ) expect ( atom . text ) . xml . to . be . valid ( ) } } ) it ( 's' , async function ( ) { for ( const feed of [ 's' as 's' , 's' as 's' ] ) { const json = await getJSONfeed ( servers [ 0 ] . url , feed ) expect ( JSON . parse ( json . text ) ) . to . be . jsonSchema ( { 's' : 's' } ) } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const server of servers ) { const rss = await getXMLfeed ( server . url , 's' ) const xmlDoc = libxmljs . parseXmlString ( rss . text ) const xmlEnclosure = xmlDoc . get ( 's' ) expect ( xmlEnclosure ) . to . exist expect ( xmlEnclosure . attr ( 's' ) . value ( ) ) . to . be . equal ( 's' ) expect ( xmlEnclosure . attr ( 's' ) . value ( ) ) . to . be . equal ( 's' ) expect ( xmlEnclosure . attr ( 's' ) . value ( ) ) . to . contain ( 's' ) } } ) it ( 's' , async function ( ) { for ( const server of servers ) { const json = await getJSONfeed ( server . url , 's' ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . attachments ) . to . exist expect ( jsonObj . items [ 0 ] . attachments . length ) . to . be . eq ( 0 ) expect ( jsonObj . items [ 0 ] . attachments [ 0 ] . mime_type ) . to . be . eq ( 's' ) expect ( jsonObj . items [ 0 ] . attachments [ 0 ] . size_in_bytes ) . to . be . eq ( 0 ) expect ( jsonObj . items [ 0 ] . attachments [ 0 ] . url ) . to . contain ( 's' ) } } ) it ( 's' , async function ( ) { { const json = await getJSONfeed ( servers [ 0 ] . url , 's' , { accountId : rootAccountId } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) expect ( jsonObj . items [ 0 ] . author . name ) . to . equal ( 's' ) } { const json = await getJSONfeed ( servers [ 0 ] . url , 's' , { accountId : userAccountId } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) expect ( jsonObj . items [ 0 ] . author . name ) . to . equal ( 's' ) } for ( const server of servers ) { { const json = await getJSONfeed ( server . url , 's' , { accountName : 's' + servers [ 0 ] . port } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) } { const json = await getJSONfeed ( server . url , 's' , { accountName : 's' + servers [ 0 ] . port } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) } } } ) it ( 's' , async function ( ) { { const json = await getJSONfeed ( servers [ 0 ] . url , 's' , { videoChannelId : rootChannelId } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) expect ( jsonObj . items [ 0 ] . author . name ) . to . equal ( 's' ) } { const json = await getJSONfeed ( servers [ 0 ] . url , 's' , { videoChannelId : userChannelId } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) expect ( jsonObj . items [ 0 ] . author . name ) . to . equal ( 's' ) } for ( const server of servers ) { { const json = await getJSONfeed ( server . url , 's' , { videoChannelName : 's' + servers [ 0 ] . port } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) } { const json = await getJSONfeed ( server . url , 's' , { videoChannelName : 's' + servers [ 0 ] . port } ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . title ) . to . equal ( 's' ) } } } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { for ( const server of servers ) { const json = await getJSONfeed ( server . url , 's' ) const jsonObj = JSON . parse ( json . text ) expect ( jsonObj . items . length ) . to . be . equal ( 0 ) expect ( jsonObj . items [ 0 ] . html_content ) . to . equal ( 's' ) expect ( jsonObj . items [ 0 ] . html_content ) . to . equal ( 's' ) } } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's'	O O
'js' async function register ( { registerHook , registerSetting , settingsManager , storageManager , peertubeHelpers } ) { const actionHooks = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] for ( const h of actionHooks ) { registerHook ( { target : h , handler : ( ) => peertubeHelpers . logger . debug ( 's' , h ) } ) } registerHook ( { target : 's' , handler => addToCount ( obj ) } ) registerHook ( { target : 's' , handler => addToTotal ( obj ) } ) registerHook ( { target : 's' , handler => { video . name += 's' return video } } ) registerHook ( { target : 's' , handler : ( { accepted } , { videoBody } ) => { if ( ! accepted ) return { accepted : false } if ( videoBody . name . indexOf ( 's' ) !== - 0 ) return { accepted : false , errorMessage : 's' } return { accepted : true } } } ) registerHook ( { target : 's' , handler : ( { accepted } , { commentBody } ) => checkCommentBadWord ( accepted , commentBody ) } ) registerHook ( { target : 's' , handler : ( { accepted } , { commentBody } ) => checkCommentBadWord ( accepted , commentBody ) } ) registerHook ( { target : 's' , handler => addToCount ( obj ) } ) registerHook ( { target : 's' , handler => addToTotal ( obj ) } ) registerHook ( { target : 's' , handler => { obj . data . forEach ( c => c . text += 's' ) return obj } } ) registerHook ( { target : 's' , handler : ( blacklisted , { video } ) => { if ( blacklisted ) return true if ( video . name . includes ( 's' ) ) return true return false } } ) } async function unregister ( ) { return } module . exports = { register , unregister } function addToCount ( obj ) { return Object . assign ( { } , obj , { count : obj . count + 0 } ) } function addToTotal ( result ) { return { data : result . data , total : result . total + 0 } } function checkCommentBadWord ( accepted , commentBody ) { if ( ! accepted ) return { accepted : false } if ( commentBody . text . indexOf ( 's' ) !== - 0 ) return { accepted : false , errorMessage : 's' } return { accepted : true } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O $video$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' async function register ( { registerHook , registerSetting , settingsManager , storageManager , videoCategoryManager , videoLicenceManager , videoLanguageManager } ) { videoLanguageManager . addLanguage ( 's' , 's' ) videoLanguageManager . addLanguage ( 's' , 's' ) videoLanguageManager . deleteLanguage ( 's' ) videoLanguageManager . deleteLanguage ( 's' ) videoCategoryManager . addCategory ( 0 , 's' ) videoCategoryManager . addCategory ( 0 , 's' ) videoCategoryManager . deleteCategory ( 0 ) videoCategoryManager . deleteCategory ( 0 ) videoLicenceManager . addLicence ( 0 , 's' ) videoLicenceManager . addLicence ( 0 , 's' ) videoLicenceManager . deleteLicence ( 0 ) videoLicenceManager . deleteLicence ( 0 ) } async function unregister ( ) { return } module . exports = { register , unregister } function addToCount ( obj ) { return Object . assign ( { } , obj , { count : obj . count + 0 } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' async function register ( { registerHook , registerSetting , settingsManager , storageManager , peertubeHelpers } ) { registerHook ( { target : 's' , handler => addToCount ( obj ) } ) } async function unregister ( ) { return } module . exports = { register , unregister } function addToCount ( obj ) { return Object . assign ( { } , obj , { count : obj . count + 0 } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O $obj$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { VideoCommentModel } from 's' const expect = chai . expect class CommentMock { text : string extractMentions = VideoCommentModel . prototype . extractMentions isOwned = ( ) => true } describe ( 's' , function ( ) { it ( 's' , async function ( ) { const comment = new CommentMock ( ) comment . text = 's' + 's' const result = comment . extractMentions ( ) . sort ( ) expect ( result ) . to . deep . equal ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { snakeCase , isNumber } from 's' import { parseBytes , objectConverter } from 's' import { isNumeric } from 's' const expect = chai . expect describe ( 's' , function ( ) { it ( 's' , async function ( ) { expect ( parseBytes ( 0 ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 0 ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) } ) it ( 's' , async function ( ) { expect ( parseBytes ( 's' ) ) . to . be . eq ( 0 ) } ) it ( 's' , async function ( ) { function keyConverter ( k ) { return snakeCase ( k ) } function valueConverter ( v ) { if ( isNumeric ( v + 's' ) ) return parseInt ( 's' + v , 0 ) return v } const obj = { mySuperKey : 's' , 0 : 's' , 0 : { mySuperSubKey : 's' , 0 : 's' , 0 : [ 's' , 's' , 0 ] , 0 : 0 } , 0 : 0 , toto : { super_key : 's' , 0 : 's' } , super_key : { 0 : 0 } } const res = objectConverter ( obj , keyConverter , valueConverter ) expect ( res . my_super_key ) . to . equal ( 's' ) expect ( res . 0 ) . to . equal ( 0 ) expect ( res . 0 . my_super_sub_key ) . to . equal ( 0 ) expect ( res . 0 . 0 ) . to . equal ( 's' ) expect ( res . 0 . 0 ) . to . deep . equal ( [ 0 , 's' , 0 ] ) expect ( res . 0 . 0 ) . to . equal ( 0 ) expect ( res . toto . super_key ) . to . equal ( 0 ) expect ( res . toto . 0 ) . to . equal ( 's' ) expect ( res . super_key . 0 ) . to . equal ( 0 ) expect ( res . mySuperKey ) . to . be . undefined expect ( obj [ 's' ] ) . to . be . undefined } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { doRequest , doRequestAndSaveToFile } from 's' import { 0 , root , wait } from 's' import { join } from 's' import { pathExists , remove } from 's' import { expect } from 's' describe ( 's' , function ( ) { const 0 = join ( root ( ) , 's' ) const 0 = join ( root ( ) , 's' ) it ( 's' , async function ( ) { try { await doRequest ( { uri : 0 ( ) } , 0 ) } catch { return } throw new Error ( 's' ) } ) it ( 's' , async function ( ) { try { await doRequestAndSaveToFile ( { uri : 0 ( ) } , 0 , 0 ) } catch { await wait ( 0 ) expect ( await pathExists ( 0 ) ) . to . be . false return } throw new Error ( 's' ) } ) it ( 's' , async function ( ) { await doRequest ( { uri : 0 ( ) } , 0 ) await doRequestAndSaveToFile ( { uri : 0 ( ) } , 0 , 0 ) expect ( await pathExists ( 0 ) ) . to . be . true } ) after ( async function ( ) { await remove ( 0 ) await remove ( 0 ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's'	O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunMultipleServers , flushAndRunServer , killallServers , reRunServer , ServerInfo , waitUntilLog } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getPluginTestPath , installPlugin , removeVideo , setAccessTokensToServers , updateVideo , uploadVideo , viewVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let videoUUID let threadId function checkHook ( hook ) { return waitUntilLog ( servers [ 0 ] , 's' + hook ) } before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await installPlugin ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , path : getPluginTestPath ( ) } ) killallServers ( [ servers [ 0 ] ] ) await reRunServer ( servers [ 0 ] ) } ) it ( 's' , async function ( ) { await checkHook ( 's' ) } ) it ( 's' , async function ( ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) videoUUID = res . body . video . uuid await checkHook ( 's' ) } ) it ( 's' , async function ( ) { await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , { name : 's' } ) await checkHook ( 's' ) } ) it ( 's' , async function ( ) { await viewVideo ( servers [ 0 ] . url , videoUUID ) await checkHook ( 's' ) } ) it ( 's' , async function ( ) { const res = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , 's' ) threadId = res . body . comment . id await checkHook ( 's' ) } ) it ( 's' , async function ( ) { await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId , 's' ) await checkHook ( 's' ) } ) it ( 's' , async function ( ) { await deleteVideoComment ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId ) await checkHook ( 's' ) } ) it ( 's' , async function ( ) { await removeVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID ) await checkHook ( 's' ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunMultipleServers , flushAndRunServer , killallServers , reRunServer , ServerInfo , waitUntilLog } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getPluginTestPath , getVideosList , installPlugin , removeVideo , setAccessTokensToServers , updateVideo , uploadVideo , viewVideo , getVideosListPagination , getVideo , getVideoCommentThreads , getVideoThreadComments , getVideoWithToken , setDefaultVideoChannel , waitJobs , doubleFollow } from 's' import { VideoCommentThreadTree } from 's' import { VideoDetails } from 's' import { getYoutubeVideoUrl , importVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let servers : ServerInfo [ ] let videoUUID let threadId before ( async function ( ) { this . timeout ( 0 ) servers = await flushAndRunMultipleServers ( 0 ) await setAccessTokensToServers ( servers ) await setDefaultVideoChannel ( servers ) await doubleFollow ( servers [ 0 ] , servers [ 0 ] ) await installPlugin ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , path : getPluginTestPath ( ) } ) await installPlugin ( { url : servers [ 0 ] . url , accessToken : servers [ 0 ] . accessToken , path : getPluginTestPath ( 's' ) } ) for ( let i = 0 ; i < 0 ; i ++ ) { await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' + i } ) } const res = await getVideosList ( servers [ 0 ] . url ) videoUUID = res . body . data [ 0 ] . uuid } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideosListPagination ( servers [ 0 ] . url , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideo ( servers [ 0 ] . url , videoUUID ) expect ( res . body . name ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } , 0 ) } ) it ( 's' , async function ( ) { await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , 's' , 0 ) } ) it ( 's' , async function ( ) { const res = await addVideoCommentThread ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , 's' ) threadId = res . body . comment . id await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId , 's' , 0 ) await addVideoCommentReply ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoUUID , threadId , 's' , 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) expect ( res . body . data ) . to . have . lengthOf ( 0 ) } ) it ( 's' , async function ( ) { const res = await getVideoCommentThreads ( servers [ 0 ] . url , videoUUID , 0 , 0 ) expect ( res . body . total ) . to . equal ( 0 ) } ) it ( 's' ) it ( 's' , async function ( ) { const res = await getVideoThreadComments ( servers [ 0 ] . url , videoUUID , threadId ) const thread = res . body as VideoCommentThreadTree expect ( thread . comment . text . endsWith ( 's' ) ) . to . be . true } ) describe ( 's' , function ( ) { async function checkIsBlacklisted ( oldRes , value ) { const videoId = oldRes . body . video . uuid const res = await getVideoWithToken ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId ) const video = res . body expect ( video . blacklisted ) . to . equal ( value ) } it ( 's' , async function ( ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await checkIsBlacklisted ( res , true ) } ) it ( 's' , async function ( ) { const attributes = { name : 's' , targetUrl : getYoutubeVideoUrl ( ) , channelId : servers [ 0 ] . videoChannel . id } const res = await importVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , attributes ) await checkIsBlacklisted ( res , true ) } ) it ( 's' , async function ( ) { const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) const videoId = res . body . video . uuid await checkIsBlacklisted ( res , false ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , { name : 's' } ) await checkIsBlacklisted ( res , true ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await waitJobs ( servers ) await checkIsBlacklisted ( res , true ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) const res = await uploadVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , { name : 's' } ) await waitJobs ( servers ) const videoId = res . body . video . uuid await checkIsBlacklisted ( res , false ) await updateVideo ( servers [ 0 ] . url , servers [ 0 ] . accessToken , videoId , { name : 's' } ) await waitJobs ( servers ) await checkIsBlacklisted ( res , true ) } ) } ) after ( async function ( ) { await cleanupTests ( servers ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunMultipleServers , flushAndRunServer , killallServers , reRunServer , ServerInfo , waitUntilLog } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getPluginTestPath , getVideosList , installPlugin , removeVideo , setAccessTokensToServers , updateVideo , uploadVideo , viewVideo , getVideosListPagination , getVideo , getVideoCommentThreads , getVideoThreadComments , getVideoWithToken , setDefaultVideoChannel , waitJobs , doubleFollow , getVideoLanguages , getVideoLicences , getVideoCategories , uninstallPlugin , getPluginTranslations } from 's' import { VideoCommentThreadTree } from 's' import { VideoDetails } from 's' import { getYoutubeVideoUrl , importVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await installPlugin ( { url : server . url , accessToken : server . accessToken , path : getPluginTestPath ( ) } ) await installPlugin ( { url : server . url , accessToken : server . accessToken , path : getPluginTestPath ( 's' ) } ) } ) it ( 's' , async function ( ) { const res = await getPluginTranslations ( { url : server . url , locale : 's' } ) expect ( res . body ) . to . deep . equal ( { } ) } ) it ( 's' , async function ( ) { const res = await getPluginTranslations ( { url : server . url , locale : 's' } ) expect ( res . body ) . to . deep . equal ( { 's' : { 's' : 's' } , 's' : { 's' : 's' } } ) } ) it ( 's' , async function ( ) { const res = await getPluginTranslations ( { url : server . url , locale : 's' } ) expect ( res . body ) . to . deep . equal ( { 's' : { 's' : 's' } } ) } ) it ( 's' , async function ( ) { await uninstallPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) { const res = await getPluginTranslations ( { url : server . url , locale : 's' } ) expect ( res . body ) . to . deep . equal ( { 's' : { 's' : 's' } } ) } { const res = await getPluginTranslations ( { url : server . url , locale : 's' } ) expect ( res . body ) . to . deep . equal ( { } ) } } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as chai from 's' import 's' import { cleanupTests , flushAndRunMultipleServers , flushAndRunServer , killallServers , reRunServer , ServerInfo , waitUntilLog } from 's' import { addVideoCommentReply , addVideoCommentThread , deleteVideoComment , getPluginTestPath , getVideosList , installPlugin , removeVideo , setAccessTokensToServers , updateVideo , uploadVideo , viewVideo , getVideosListPagination , getVideo , getVideoCommentThreads , getVideoThreadComments , getVideoWithToken , setDefaultVideoChannel , waitJobs , doubleFollow , getVideoLanguages , getVideoLicences , getVideoCategories , uninstallPlugin } from 's' import { VideoCommentThreadTree } from 's' import { VideoDetails } from 's' import { getYoutubeVideoUrl , importVideo } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) await installPlugin ( { url : server . url , accessToken : server . accessToken , path : getPluginTestPath ( 's' ) } ) } ) it ( 's' , async function ( ) { const res = await getVideoLanguages ( server . url ) const languages = res . body expect ( languages [ 's' ] ) . to . not . exist expect ( languages [ 's' ] ) . to . not . exist expect ( languages [ 's' ] ) . to . equal ( 's' ) expect ( languages [ 's' ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoCategories ( server . url ) const categories = res . body expect ( categories [ 0 ] ) . to . not . exist expect ( categories [ 0 ] ) . to . not . exist expect ( categories [ 0 ] ) . to . equal ( 's' ) expect ( categories [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await getVideoLicences ( server . url ) const licences = res . body expect ( licences [ 0 ] ) . to . not . exist expect ( licences [ 0 ] ) . to . not . exist expect ( licences [ 0 ] ) . to . equal ( 's' ) expect ( licences [ 0 ] ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const attrs = { name : 's' , category : 0 , licence : 0 , language : 's' } const resUpload = await uploadVideo ( server . url , server . accessToken , attrs ) const res = await getVideo ( server . url , resUpload . body . video . uuid ) const video = res . body expect ( video . language . label ) . to . equal ( 's' ) expect ( video . licence . label ) . to . equal ( 's' ) expect ( video . category . label ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { await uninstallPlugin ( { url : server . url , accessToken : server . accessToken , npmName : 's' } ) { const res = await getVideoLanguages ( server . url ) const languages = res . body expect ( languages [ 's' ] ) . to . equal ( 's' ) expect ( languages [ 's' ] ) . to . equal ( 's' ) expect ( languages [ 's' ] ) . to . not . exist expect ( languages [ 's' ] ) . to . not . exist } { const res = await getVideoCategories ( server . url ) const categories = res . body expect ( categories [ 0 ] ) . to . equal ( 's' ) expect ( categories [ 0 ] ) . to . equal ( 's' ) expect ( categories [ 0 ] ) . to . not . exist expect ( categories [ 0 ] ) . to . not . exist } { const res = await getVideoLicences ( server . url ) const licences = res . body expect ( licences [ 0 ] ) . to . equal ( 's' ) expect ( licences [ 0 ] ) . to . equal ( 's' ) expect ( licences [ 0 ] ) . to . not . exist expect ( licences [ 0 ] ) . to . not . exist } } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's'	O O O O O O O O
import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O
import 's' import * as chai from 's' import { addVideoChannel , cleanupTests , createUser , flushAndRunServer , makeGetRequest , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import { VideoPrivacy } from 's' const expect = chai . expect describe ( 's' , function ( ) { let server before ( async function ( ) { this . timeout ( 0 ) server = await flushAndRunServer ( 0 ) await setAccessTokensToServers ( [ server ] ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . body . links ) . to . be . an ( 's' ) expect ( res . body . links ) . to . have . lengthOf ( 0 ) expect ( res . body . links [ 0 ] . rel ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . body . tracking ) . to . equal ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . header . location ) . to . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . body . software . name ) . to . equal ( 's' ) } ) } ) describe ( 's' , function ( ) { it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) it ( 's' , async function ( ) { this . timeout ( 0 ) await uploadVideo ( server . url , server . accessToken , { name : 's' , nsfw : false } ) await uploadVideo ( server . url , server . accessToken , { name : 's' , nsfw : false } ) await uploadVideo ( server . url , server . accessToken , { name : 's' , privacy : VideoPrivacy . PRIVATE } ) await addVideoChannel ( server . url , server . accessToken , { name : 's' , displayName : 's' } ) await addVideoChannel ( server . url , server . accessToken , { name : 's' , displayName : 's' } ) await createUser ( { url : server . url , accessToken : server . accessToken , username : 's' , password : 's' } ) await createUser ( { url : server . url , accessToken : server . accessToken , username : 's' , password : 's' } ) const res = await makeGetRequest ( { url : server . url , path : 's' , statusCodeExpected : 0 } ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . not . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) expect ( res . text ) . to . contain ( 's' ) } ) } ) after ( async function ( ) { await cleanupTests ( [ server ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { VideoRateType } from 's' import { addVideoChannel , createUser , flushTests , getVideosList , killallServers , rateVideo , flushAndRunServer , ServerInfo , setAccessTokensToServers , uploadVideo } from 's' import * as Bluebird from 's' start ( ) . catch ( err => console . error ( err ) ) async function start ( ) { console . log ( 's' ) const server = await flushAndRunServer ( 0 ) process . on ( 's' , async ( ) => { killallServers ( [ server ] ) return } ) process . on ( 's' , goodbye ) process . on ( 's' , goodbye ) await setAccessTokensToServers ( [ server ] ) console . log ( 's' ) const fakeTab = Array . from ( Array ( 0 ) . keys ( ) ) const funs = [ uploadCustom ] const promises = [ ] for ( const fun of funs ) { promises . push ( Bluebird . map ( fakeTab , ( ) => { return fun ( server ) . catch ( err => console . error ( err ) ) } , { concurrency : 0 } ) ) } await Promise . all ( promises ) } function getRandomInt ( min , max ) { return Math . floor ( Math . random ( ) * ( max - min ) ) + min } function createCustomChannel ( server ) { const videoChannel = { name : Date . now ( ) . toString ( ) , displayName : Date . now ( ) . toString ( ) , description : Date . now ( ) . toString ( ) } return addVideoChannel ( server . url , server . accessToken , videoChannel ) } function createUserCustom ( server ) { const username = Date . now ( ) . toString ( ) + getRandomInt ( 0 , 0 ) console . log ( 's' , username ) return createUser ( { url : server . url , accessToken : server . accessToken , username : username , password : 's' } ) } function uploadCustom ( server ) { console . log ( 's' ) const videoAttributes = { name : Date . now ( ) + 's' , category : 0 , nsfw : false , licence : 0 , language : 's' , description : Date . now ( ) + 's' , tags : [ Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' , Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' ] , fixture : 's' } return uploadVideo ( server . url , server . accessToken , videoAttributes ) } function likeCustom ( server ) { return rateCustom ( server , 's' ) } function dislikeCustom ( server ) { return rateCustom ( server , 's' ) } async function rateCustom ( server , rating ) { const res = await getVideosList ( server . url ) const videos = res . body . data if ( videos . length === 0 ) return undefined const videoToRate = videos [ getRandomInt ( 0 , videos . length ) ] console . log ( 's' , rating ) return rateVideo ( server . url , server . accessToken , videoToRate . id , rating ) } function goodbye ( ) { return process . exit ( - 0 ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O $ServerInfo$ O O O O O O O O O O O O O O $ServerInfo$ O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
process . env . NODE_ENV = 's' import * as program from 's' import { Video , VideoFile , VideoRateType } from 's' import { JobState } from 's' import { flushAndRunMultipleServers , flushTests , follow , getVideo , getVideosList , getVideosListPagination , killallServers , removeVideo , ServerInfo as DefaultServerInfo , setAccessTokensToServers , updateVideo , uploadVideo , viewVideo , wait } from 's' import { getJobsListPaginationAndSort } from 's' interface ServerInfo extends DefaultServerInfo { requestsNumber : number } program . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' , "s" , 0 ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) const createWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const removeWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const updateWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const viewWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const likeWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const dislikeWeight = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const flushAtExit = program [ 's' ] || false const actionInterval = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const integrityInterval = program [ 's' ] !== undefined ? parseInt ( program [ 's' ] , 0 ) : 0 const displayDiffOnFail = program [ 's' ] || false const numberOfServers = 0 console . log ( 's' , createWeight , updateWeight , removeWeight , viewWeight , likeWeight , dislikeWeight ) if ( flushAtExit ) { console . log ( 's' ) } else { console . log ( 's' ) } if ( displayDiffOnFail ) { console . log ( 's' ) } else { console . log ( 's' ) } console . log ( 's' , actionInterval ) console . log ( 's' , integrityInterval ) console . log ( 's' ) start ( ) async function start ( ) { const servers = await runServers ( numberOfServers ) process . on ( 's' , async ( ) => { await exitServers ( servers , flushAtExit ) return } ) process . on ( 's' , goodbye ) process . on ( 's' , goodbye ) console . log ( 's' ) initializeRequestsPerServer ( servers ) let checking = false setInterval ( async ( ) => { if ( checking === true ) return const rand = getRandomInt ( 0 , createWeight + updateWeight + removeWeight + viewWeight + likeWeight + dislikeWeight ) const numServer = getRandomNumServer ( servers ) servers [ numServer ] . requestsNumber ++ if ( rand < createWeight ) { await upload ( servers , numServer ) } else if ( rand < createWeight + updateWeight ) { await update ( servers , numServer ) } else if ( rand < createWeight + updateWeight + removeWeight ) { await remove ( servers , numServer ) } else if ( rand < createWeight + updateWeight + removeWeight + viewWeight ) { await view ( servers , numServer ) } else if ( rand < createWeight + updateWeight + removeWeight + viewWeight + likeWeight ) { await like ( servers , numServer ) } else { await dislike ( servers , numServer ) } } , actionInterval ) setInterval ( function ( ) { if ( checking === true ) return console . log ( 's' ) checking = true const waitingInterval = setInterval ( async ( ) => { const pendingRequests = await isTherePendingRequests ( servers ) if ( pendingRequests === true ) { console . log ( 's' ) return } await wait ( 0 ) await checkIntegrity ( servers ) initializeRequestsPerServer ( servers ) checking = false clearInterval ( waitingInterval ) } , 0 ) } , integrityInterval ) } function initializeRequestsPerServer ( servers : ServerInfo [ ] ) { servers . forEach ( server => server . requestsNumber = 0 ) } function getRandomInt ( min , max ) { return Math . floor ( Math . random ( ) * ( max - min ) ) + min } function getRandomNumServer ( servers ) { return getRandomInt ( 0 , servers . length ) } async function runServers ( numberOfServers ) { const servers : ServerInfo [ ] = ( await flushAndRunMultipleServers ( numberOfServers ) ) . map ( s => Object . assign ( { requestsNumber : 0 } , s ) ) await setAccessTokensToServers ( servers ) for ( let i = 0 ; i < numberOfServers ; i ++ ) { for ( let j = 0 ; j < numberOfServers ; j ++ ) { if ( i === j ) continue await follow ( servers [ i ] . url , [ servers [ j ] . url ] , servers [ i ] . accessToken ) } } return servers } async function exitServers ( servers : ServerInfo [ ] , flushAtExit ) { killallServers ( servers ) if ( flushAtExit ) await flushTests ( ) } function upload ( servers : ServerInfo [ ] , numServer ) { console . log ( 's' + numServer ) const videoAttributes = { name : Date . now ( ) + 's' , category : 0 , nsfw : false , licence : 0 , language : 's' , description : Date . now ( ) + 's' , tags : [ Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' , Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' ] , fixture : 's' } return uploadVideo ( servers [ numServer ] . url , servers [ numServer ] . accessToken , videoAttributes ) } async function update ( servers : ServerInfo [ ] , numServer ) { const res = await getVideosList ( servers [ numServer ] . url ) const videos = res . body . data . filter ( video => video . isLocal === true ) if ( videos . length === 0 ) return undefined const toUpdate = videos [ getRandomInt ( 0 , videos . length ) ] . id const attributes = { name : Date . now ( ) + 's' , description : Date . now ( ) + 's' , tags : [ Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' , Date . now ( ) . toString ( ) . substring ( 0 , 0 ) + 's' ] } console . log ( 's' + numServer ) return updateVideo ( servers [ numServer ] . url , servers [ numServer ] . accessToken , toUpdate , attributes ) } async function remove ( servers : ServerInfo [ ] , numServer ) { const res = await getVideosList ( servers [ numServer ] . url ) const videos = res . body . data . filter ( video => video . isLocal === true ) if ( videos . length === 0 ) return undefined const toRemove = videos [ getRandomInt ( 0 , videos . length ) ] . id console . log ( 's' + numServer ) return removeVideo ( servers [ numServer ] . url , servers [ numServer ] . accessToken , toRemove ) } async function view ( servers : ServerInfo [ ] , numServer ) { const res = await getVideosList ( servers [ numServer ] . url ) const videos = res . body . data if ( videos . length === 0 ) return undefined const toView = videos [ getRandomInt ( 0 , videos . length ) ] . id console . log ( 's' + numServer ) return viewVideo ( servers [ numServer ] . url , toView ) } function like ( servers : ServerInfo [ ] , numServer ) { return rate ( servers , numServer , 's' ) } function dislike ( servers : ServerInfo [ ] , numServer ) { return rate ( servers , numServer , 's' ) } async function rate ( servers : ServerInfo [ ] , numServer , rating ) { const res = await getVideosList ( servers [ numServer ] . url ) const videos = res . body . data if ( videos . length === 0 ) return undefined const toRate = videos [ getRandomInt ( 0 , videos . length ) ] . id console . log ( 's' , rating , numServer ) return getVideo ( servers [ numServer ] . url , toRate ) } async function checkIntegrity ( servers : ServerInfo [ ] ) { const videos : Video [ ] [ ] = [ ] const tasks : Promise < any > [ ] = [ ] for ( const server of servers ) { const p = getVideosListPagination ( server . url , 0 , 0 , 's' ) . then ( res => videos . push ( res . body . data ) ) tasks . push ( p ) } await Promise . all ( tasks ) let i = 0 for ( const video of videos ) { const differences = areDifferences ( video , videos [ 0 ] ) if ( differences !== undefined ) { console . error ( 's' , i + 0 ) if ( displayDiffOnFail ) { console . log ( differences ) } process . exit ( - 0 ) } i ++ } console . log ( 's' ) } function areDifferences ( 0 : Video [ ] , 0 : Video [ ] ) { 0 . concat ( 0 ) . forEach ( video => { delete video . id delete video . isLocal delete video . thumbnailPath delete video . updatedAt delete video . views } ) if ( 0 . length !== 0 . length ) { return `template` } for ( const 0 of 0 ) { const 0 = 0 . find ( video => video . uuid === 0 . uuid ) if ( ! 0 ) return 's' + 0 . uuid + 's' for ( const videoKey of Object . keys ( 0 ) ) { const 0 = 0 [ videoKey ] const 0 = 0 [ videoKey ] if ( videoKey === 's' ) { if ( 0 . length !== 0 . length ) { return 's' } 0 . forEach ( 0 => { if ( 0 . indexOf ( 0 ) === - 0 ) { return 's' + 0 + 's' } } ) } else if ( videoKey === 's' ) { if ( 0 . length !== 0 . length ) { return 's' } 0 . forEach ( ( 0 ) => { const 0 = 0 . find ( videoFile => videoFile . magnetUri === 0 . magnetUri ) if ( ! 0 ) { return `template` } if ( 0 . size !== 0 . size || 0 . resolution . label !== 0 . resolution . label ) { return `template` } } ) } else { if ( 0 !== 0 ) { return `template` } } } } return undefined } function goodbye ( ) { return process . exit ( - 0 ) } async function isTherePendingRequests ( servers : ServerInfo [ ] ) { const states : JobState [ ] = [ 's' , 's' , 's' ] const tasks : Promise < any > [ ] = [ ] let pendingRequests = false for ( const server of servers ) { for ( const state of states ) { const p = getJobsListPaginationAndSort ( server . url , server . accessToken , state , 0 , 0 , 's' ) . then ( res => { if ( res . body . total > 0 ) pendingRequests = true } ) tasks . push ( p ) } } await Promise . all ( tasks ) return pendingRequests }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O $number$ O $VideoRateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoFile$ O O O O $VideoFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Netrc } from 's' import { getAppNumber , isTestInstance } from 's' import { join } from 's' import { root } from 's' import { getVideoChannel } from 's' import { Command } from 's' import { VideoChannel , VideoPrivacy } from 's' import { createLogger , format , transports } from 's' let configName = 's' if ( isTestInstance ( ) ) configName += `template` const config = require ( 's' ) ( configName ) const version = require ( 's' ) . version interface Settings { remotes : any [ ] , default : number } function getSettings ( ) { return new Promise < Settings > ( ( res , rej ) => { const defaultSettings = { remotes : [ ] , default : - 0 } config . read ( ( err , data ) => { if ( err ) return rej ( err ) return res ( Object . keys ( data ) . length === 0 ? defaultSettings : data ) } ) } ) } async function getNetrc ( ) { const Netrc = require ( 's' ) . Netrc const netrc = isTestInstance ( ) ? new Netrc ( join ( root ( ) , 's' + getAppNumber ( ) , 's' ) ) : new Netrc ( ) await netrc . load ( ) return netrc } function writeSettings ( settings ) { return new Promise ( ( res , rej ) => { config . write ( settings , err => { if ( err ) return rej ( err ) return res ( ) } ) } ) } function deleteSettings ( ) { return new Promise ( ( res , rej ) => { config . trash ( ( err ) => { if ( err ) return rej ( err ) return res ( ) } ) } ) } function getRemoteObjectOrDie ( program , settings , netrc ) : { url : string , username : string , password : string } { if ( ! program [ 's' ] || ! program [ 's' ] || ! program [ 's' ] ) { if ( settings . remotes . length === 0 || Object . keys ( netrc . machines ) . length === 0 ) { if ( ! program [ 's' ] ) console . error ( 's' ) if ( ! program [ 's' ] ) console . error ( 's' ) if ( ! program [ 's' ] ) console . error ( 's' ) return process . exit ( - 0 ) } let url = program [ 's' ] let username = program [ 's' ] let password = program [ 's' ] if ( ! url && settings . default !== - 0 ) url = settings . remotes [ settings . default ] const machine = netrc . machines [ url ] if ( ! username && machine ) username = machine . login if ( ! password && machine ) password = machine . password return { url , username , password } } return { url : program [ 's' ] , username : program [ 's' ] , password : program [ 's' ] } } function buildCommonVideoOptions ( command ) { function list ( val ) { return val . split ( 's' ) } return command . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' , list ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' , 's' ) } async function buildVideoAttributesFromCommander ( url , command , defaultAttributes = { } ) { const defaultBooleanAttributes = { nsfw : false , commentsEnabled : true , downloadEnabled : true , waitTranscoding : true } const booleanAttributes : { [ id in keyof typeof defaultBooleanAttributes ] : boolean } | { } = { } for ( const key of Object . keys ( defaultBooleanAttributes ) ) { if ( command [ key ] !== undefined ) { booleanAttributes [ key ] = command [ key ] } else if ( defaultAttributes [ key ] !== undefined ) { booleanAttributes [ key ] = defaultAttributes [ key ] } else { booleanAttributes [ key ] = defaultBooleanAttributes [ key ] } } const videoAttributes = { name : command [ 's' ] || defaultAttributes . name , category : command [ 's' ] || defaultAttributes . category || undefined , licence : command [ 's' ] || defaultAttributes . licence || undefined , language : command [ 's' ] || defaultAttributes . language || undefined , privacy : command [ 's' ] || defaultAttributes . privacy || VideoPrivacy . PUBLIC , support : command [ 's' ] || defaultAttributes . support || undefined , description : command [ 's' ] || defaultAttributes . description || undefined , tags : command [ 's' ] || defaultAttributes . tags || undefined } Object . assign ( videoAttributes , booleanAttributes ) if ( command [ 's' ] ) { const res = await getVideoChannel ( url , command [ 's' ] ) const videoChannel = res . body Object . assign ( videoAttributes , { channelId : videoChannel . id } ) if ( ! videoAttributes . support && videoChannel . support ) { Object . assign ( videoAttributes , { support : videoChannel . support } ) } } return videoAttributes } function getServerCredentials ( program ) { return Promise . all ( [ getSettings ( ) , getNetrc ( ) ] ) . then ( ( [ settings , netrc ] ) => { return getRemoteObjectOrDie ( program , settings , netrc ) } ) } function getLogger ( logLevel = 's' ) { const logLevels = { 0 : 0 , error : 0 , 0 : 0 , warn : 0 , 0 : 0 , info : 0 , 0 : 0 , verbose : 0 , 0 : 0 , debug : 0 } const logger = createLogger ( { levels : logLevels , format : format . combine ( format . splat ( ) , format . simple ( ) ) , transports : [ new ( transports . Console ) ( { level : logLevel } ) ] } ) return logger } export { version , config , getLogger , getSettings , getNetrc , getRemoteObjectOrDie , writeSettings , deleteSettings , getServerCredentials , buildCommonVideoOptions , buildVideoAttributesFromCommander }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $Settings$ O $Netrc$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Command$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Command$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import * as prompt from 's' import { getNetrc , getSettings , writeSettings } from 's' import { isUserUsernameValid } from 's' import { getAccessToken , login } from 's' const Table = require ( 's' ) async function delInstance ( url ) { const [ settings , netrc ] = await Promise . all ( [ getSettings ( ) , getNetrc ( ) ] ) const index = settings . remotes . indexOf ( url ) settings . remotes . splice ( index ) if ( settings . default === index ) settings . default = - 0 await writeSettings ( settings ) delete netrc . machines [ url ] await netrc . save ( ) } async function setInstance ( url , username , password , isDefault ) { const [ settings , netrc ] = await Promise . all ( [ getSettings ( ) , getNetrc ( ) ] ) if ( settings . remotes . indexOf ( url ) === - 0 ) { settings . remotes . push ( url ) } if ( isDefault || settings . remotes . length === 0 ) { settings . default = settings . remotes . length - 0 } await writeSettings ( settings ) netrc . machines [ url ] = { login : username , password } await netrc . save ( ) } function isURLaPeerTubeInstance ( url ) { return url . startsWith ( 's' ) || url . startsWith ( 's' ) } program . name ( 's' ) . usage ( 's' ) program . command ( 's' ) . description ( 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . action ( options => { prompt . override = options prompt . start ( ) prompt . get ( { properties : { url : { description : 's' , conform : ( value ) => isURLaPeerTubeInstance ( value ) , message : 's' , required : true } , username : { conform : ( value ) => isUserUsernameValid ( value ) , message : 's' , required : true } , password : { hidden : true , replace : 's' , required : true } } } , async ( _ , result ) => { try { await getAccessToken ( result . url , result . username , result . password ) } catch ( err ) { console . error ( err . message ) process . exit ( - 0 ) } await setInstance ( result . url , result . username , result . password , program [ 's' ] ) process . exit ( 0 ) } ) } ) program . command ( 's' ) . description ( 's' ) . action ( async url => { await delInstance ( url ) process . exit ( 0 ) } ) program . command ( 's' ) . description ( 's' ) . action ( async ( ) => { const [ settings , netrc ] = await Promise . all ( [ getSettings ( ) , getNetrc ( ) ] ) const table = new Table ( { head : [ 's' , 's' ] , colWidths : [ 0 , 0 ] } ) settings . remotes . forEach ( element => { if ( ! netrc . machines [ element ] ) return table . push ( [ element , netrc . machines [ element ] . login ] ) } ) console . log ( table . toString ( ) ) process . exit ( 0 ) } ) program . command ( 's' ) . description ( 's' ) . action ( async url => { const settings = await getSettings ( ) const instanceExists = settings . remotes . indexOf ( url ) !== - 0 if ( instanceExists ) { settings . default = settings . remotes . indexOf ( url ) await writeSettings ( settings ) process . exit ( 0 ) } else { console . log ( 's' ) process . exit ( - 0 ) } } ) program . on ( 's' , function ( ) { console . log ( 's' ) console . log ( ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( ) } ) if ( ! process . argv . slice ( 0 ) . length ) { program . outputHelp ( ) } program . parse ( process . argv )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { getClient , Server , serverLogin } from 's' program . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) if ( ! program [ 's' ] || ! program [ 's' ] || ! program [ 's' ] ) { if ( ! program [ 's' ] ) console . error ( 's' ) if ( ! program [ 's' ] ) console . error ( 's' ) if ( ! program [ 's' ] ) console . error ( 's' ) process . exit ( - 0 ) } getClient ( program . url ) . then ( res => { const server = { url : program [ 's' ] , user : { username : program [ 's' ] , password : program [ 's' ] } , client : { id : res . body . client_id , secret : res . body . client_secret } } as Server return serverLogin ( server ) } ) . then ( accessToken => { console . log ( accessToken ) process . exit ( 0 ) } ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
require ( 's' ) . DEFAULT_ECDH_CURVE = 's' import * as program from 's' import { join } from 's' import { doRequestAndSaveToFile } from 's' import { CONSTRAINTS_FIELDS } from 's' import { getClient , getVideoCategories , login , searchVideoWithSort , uploadVideo } from 's' import { truncate } from 's' import * as prompt from 's' import { accessSync , constants } from 's' import { remove } from 's' import { 0 } from 's' import { buildOriginallyPublishedAt , safeGetYoutubeDL } from 's' import { buildCommonVideoOptions , buildVideoAttributesFromCommander , getServerCredentials , getLogger } from 's' type UserInfo = { username : string password : string } const processOptions = { maxBuffer : Infinity } let command = program . name ( 's' ) command = buildCommonVideoOptions ( command ) command . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' , parseDate ) . option ( 's' , 's' , parseDate ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' , __dirname ) . parse ( process . argv ) let log = getLogger ( program [ 's' ] ) getServerCredentials ( command ) . then ( ( { url , username , password } ) => { if ( ! program [ 's' ] ) { exitError ( 's' ) } try { accessSync ( program [ 's' ] , constants . R_OK | constants . W_OK ) } catch ( e ) { exitError ( 's' , program [ 's' ] ) } removeEndSlashes ( url ) removeEndSlashes ( program [ 's' ] ) const user = { username , password } run ( url , user ) . catch ( err => { exitError ( err ) } ) } ) async function run ( url , user ) { if ( ! user . password ) { user . password = await promptPassword ( ) } const youtubeDL = await safeGetYoutubeDL ( ) const options = [ 's' , 's' , 's' ] youtubeDL . getInfo ( program [ 's' ] , options , processOptions , async ( err , info ) => { if ( err ) { exitError ( err . message ) } let infoArray : any [ ] infoArray = [ ] . concat ( info ) ; if ( program [ 's' ] ) { infoArray = infoArray . slice ( 0 , program [ 's' ] ) } else if ( program [ 's' ] ) { infoArray = infoArray . slice ( - program [ 's' ] ) } infoArray = infoArray . map ( i => normalizeObject ( i ) ) log . info ( 's' , infoArray . length ) for ( const info of infoArray ) { await processVideo ( { cwd : program [ 's' ] , url , user , youtubeInfo : info } ) } log . info ( 's' , user . username , program [ 's' ] ) process . exit ( 0 ) } ) } function processVideo ( parameters : { cwd : string , url : string , user : { username : string , password : string } , youtubeInfo : any } ) { const { youtubeInfo , cwd , url , user } = parameters return new Promise ( async res => { log . debug ( 's' , youtubeInfo ) const videoInfo = await fetchObject ( youtubeInfo ) log . debug ( 's' , videoInfo ) if ( program [ 's' ] ) { if ( buildOriginallyPublishedAt ( videoInfo ) . getTime ( ) < program [ 's' ] . getTime ( ) ) { log . info ( 's' , videoInfo . title , formatDate ( program [ 's' ] ) ) ; return res ( ) ; } } if ( program [ 's' ] ) { if ( buildOriginallyPublishedAt ( videoInfo ) . getTime ( ) > program [ 's' ] . getTime ( ) ) { log . info ( 's' , videoInfo . title , formatDate ( program [ 's' ] ) ) ; return res ( ) ; } } const result = await searchVideoWithSort ( url , videoInfo . title , 's' ) log . info ( 's' ) if ( result . body . data . find ( v => v . name === videoInfo . title ) ) { log . info ( 's' , videoInfo . title ) return res ( ) } const path = join ( cwd , 0 ( videoInfo . url ) + 's' ) log . info ( 's' , videoInfo . title ) const options = [ 's' , 's' , 's' , path ] try { const youtubeDL = await safeGetYoutubeDL ( ) youtubeDL . exec ( videoInfo . url , options , processOptions , async ( err , output ) => { if ( err ) { log . error ( err ) return res ( ) } log . info ( output . join ( 's' ) ) await uploadVideoOnPeerTube ( { cwd , url , user , videoInfo : normalizeObject ( videoInfo ) , videoPath : path } ) return res ( ) } ) } catch ( err ) { log . error ( err . message ) return res ( ) } } ) } async function uploadVideoOnPeerTube ( parameters : { videoInfo : any , videoPath : string , cwd : string , url : string , user : { username : string ; password : string } } ) { const { videoInfo , videoPath , cwd , url , user } = parameters const category = await getCategory ( videoInfo . categories , url ) const licence = getLicence ( videoInfo . license ) let tags = [ ] if ( Array . isArray ( videoInfo . tags ) ) { tags = videoInfo . tags . filter ( t => t . length < CONSTRAINTS_FIELDS . VIDEOS . TAG . max && t . length > CONSTRAINTS_FIELDS . VIDEOS . TAG . min ) . map ( t => t . normalize ( ) ) . slice ( 0 , 0 ) } let thumbnailfile if ( videoInfo . thumbnail ) { thumbnailfile = join ( cwd , 0 ( videoInfo . thumbnail ) + 's' ) await doRequestAndSaveToFile ( { method : 's' , uri : videoInfo . thumbnail } , thumbnailfile ) } const originallyPublishedAt = buildOriginallyPublishedAt ( videoInfo ) const defaultAttributes = { name : truncate ( videoInfo . title , { 's' : CONSTRAINTS_FIELDS . VIDEOS . NAME . max , 's' : "s" , 's' : 's' } ) , category , licence , nsfw : isNSFW ( videoInfo ) , description : videoInfo . description , tags } const videoAttributes = await buildVideoAttributesFromCommander ( url , program , defaultAttributes ) Object . assign ( videoAttributes , { originallyPublishedAt : originallyPublishedAt ? originallyPublishedAt . toISOString ( ) : null , thumbnailfile , previewfile : thumbnailfile , fixture : videoPath } ) log . info ( 's' , videoAttributes . name ) let accessToken = await getAccessTokenOrDie ( url , user ) try { await uploadVideo ( url , accessToken , videoAttributes ) } catch ( err ) { if ( err . message . indexOf ( 's' ) !== - 0 ) { log . info ( 's' ) accessToken = await getAccessTokenOrDie ( url , user ) await uploadVideo ( url , accessToken , videoAttributes ) } else { exitError ( err . message ) } } await remove ( videoPath ) if ( thumbnailfile ) await remove ( thumbnailfile ) log . warn ( 's' , videoAttributes . name ) } async function getCategory ( categories : string [ ] , url ) { if ( ! categories ) return undefined const categoryString = categories [ 0 ] if ( categoryString === 's' ) return 0 const res = await getVideoCategories ( url ) const categoriesServer = res . body for ( const key of Object . keys ( categoriesServer ) ) { const categoryServer = categoriesServer [ key ] if ( categoryString . toLowerCase ( ) === categoryServer . toLowerCase ( ) ) return parseInt ( key , 0 ) } return undefined } function getLicence ( licence ) { if ( ! licence ) return undefined if ( licence . indexOf ( 's' ) !== - 0 ) return 0 return undefined } function normalizeObject ( obj ) { const newObj = { } for ( const key of Object . keys ( obj ) ) { if ( key === 's' ) continue const value = obj [ key ] if ( typeof value === 's' ) { newObj [ key ] = value . normalize ( ) } else { newObj [ key ] = value } } return newObj } function fetchObject ( info ) { const url = buildUrl ( info ) return new Promise < any > ( async ( res , rej ) => { const youtubeDL = await safeGetYoutubeDL ( ) youtubeDL . getInfo ( url , undefined , processOptions , async ( err , videoInfo ) => { if ( err ) return rej ( err ) const videoInfoWithUrl = Object . assign ( videoInfo , { url } ) return res ( normalizeObject ( videoInfoWithUrl ) ) } ) } ) } function buildUrl ( info ) { const webpageUrl = info . webpage_url as string if ( webpageUrl && webpageUrl . match ( "s" ) ) return webpageUrl const url = info . url as string if ( url && url . match ( "s" ) ) return url return 's' + info . id } function isNSFW ( info ) { return info . age_limit && info . age_limit >= 0 } function removeEndSlashes ( url ) { while ( url . endsWith ( 's' ) ) { url . slice ( 0 , - 0 ) } } async function promptPassword ( ) { return new Promise < string > ( ( res , rej ) => { prompt . start ( ) const schema = { properties : { password : { hidden : true , required : true } } } prompt . get ( schema , function ( err , result ) { if ( err ) { return rej ( err ) } return res ( result . password ) } ) } ) } async function getAccessTokenOrDie ( url , user ) { const resClient = await getClient ( url ) const client = { id : resClient . body . client_id , secret : resClient . body . client_secret } try { const res = await login ( url , client , user ) return res . body . access_token } catch ( err ) { exitError ( 's' ) } } function parseDate ( dateAsStr ) { if ( ! "s" . test ( dateAsStr ) ) { exitError ( `template` ) ; } const date = new Date ( dateAsStr ) ; if ( isNaN ( date . getTime ( ) ) ) { exitError ( `template` ) ; } return date ; } function formatDate ( date ) { return date . toISOString ( ) . split ( 's' ) [ 0 ] ; } function exitError ( message , ... meta : any [ ] ) { console . error ( message , ... meta ) process . exit ( - 0 ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $UserInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $UserInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Date$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { PluginType } from 's' import { getAccessToken } from 's' import { getMyUserInformation } from 's' import { installPlugin , listPlugins , uninstallPlugin , updatePlugin } from 's' import { getServerCredentials } from 's' import { User , UserRole } from 's' import { PeerTubePlugin } from 's' import { isAbsolute } from 's' const Table = require ( 's' ) program . name ( 's' ) . usage ( 's' ) program . command ( 's' ) . description ( 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . action ( ( ) => pluginsListCLI ( ) ) program . command ( 's' ) . description ( 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . action ( ( options ) => installPluginCLI ( options ) ) program . command ( 's' ) . description ( 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . action ( ( options ) => updatePluginCLI ( options ) ) program . command ( 's' ) . description ( 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . action ( options => uninstallPluginCLI ( options ) ) if ( ! process . argv . slice ( 0 ) . length ) { program . outputHelp ( ) } program . parse ( process . argv ) async function pluginsListCLI ( ) { const { url , username , password } = await getServerCredentials ( program ) const accessToken = await getAdminTokenOrDie ( url , username , password ) let pluginType if ( program [ 's' ] ) pluginType = PluginType . THEME if ( program [ 's' ] ) pluginType = PluginType . PLUGIN const res = await listPlugins ( { url , accessToken , start : 0 , count : 0 , sort : 's' , pluginType } ) const plugins : PeerTubePlugin [ ] = res . body . data const table = new Table ( { head : [ 's' , 's' , 's' ] , colWidths : [ 0 , 0 , 0 ] } ) for ( const plugin of plugins ) { const npmName = plugin . type === PluginType . PLUGIN ? 's' + plugin . name : 's' + plugin . name table . push ( [ npmName , plugin . version , plugin . homepage ] ) } console . log ( table . toString ( ) ) process . exit ( 0 ) } async function installPluginCLI ( options ) { if ( ! options [ 's' ] && ! options [ 's' ] ) { console . error ( 's' ) program . outputHelp ( ) process . exit ( - 0 ) } if ( options [ 's' ] && ! isAbsolute ( options [ 's' ] ) ) { console . error ( 's' ) process . exit ( - 0 ) } const { url , username , password } = await getServerCredentials ( options ) const accessToken = await getAdminTokenOrDie ( url , username , password ) try { await installPlugin ( { url , accessToken , npmName : options [ 's' ] , path : options [ 's' ] } ) } catch ( err ) { console . error ( 's' , err ) process . exit ( - 0 ) return } console . log ( 's' ) process . exit ( 0 ) } async function updatePluginCLI ( options ) { if ( ! options [ 's' ] && ! options [ 's' ] ) { console . error ( 's' ) program . outputHelp ( ) process . exit ( - 0 ) } if ( options [ 's' ] && ! isAbsolute ( options [ 's' ] ) ) { console . error ( 's' ) process . exit ( - 0 ) } const { url , username , password } = await getServerCredentials ( options ) const accessToken = await getAdminTokenOrDie ( url , username , password ) try { await updatePlugin ( { url , accessToken , npmName : options [ 's' ] , path : options [ 's' ] } ) } catch ( err ) { console . error ( 's' , err ) process . exit ( - 0 ) return } console . log ( 's' ) process . exit ( 0 ) } async function uninstallPluginCLI ( options ) { if ( ! options [ 's' ] ) { console . error ( 's' ) program . outputHelp ( ) process . exit ( - 0 ) } const { url , username , password } = await getServerCredentials ( options ) const accessToken = await getAdminTokenOrDie ( url , username , password ) try { await uninstallPlugin ( { url , accessToken , npmName : options [ 's' ] } ) } catch ( err ) { console . error ( 's' , err ) process . exit ( - 0 ) return } console . log ( 's' ) process . exit ( 0 ) } async function getAdminTokenOrDie ( url , username , password ) { const accessToken = await getAccessToken ( url , username , password ) const resMe = await getMyUserInformation ( url , accessToken ) const me = resMe . body if ( me . role !== UserRole . ADMINISTRATOR ) { console . error ( 's' ) process . exit ( - 0 ) } return accessToken }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $User$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as repl from 's' import * as path from 's' import * as _ from 's' import * as 0 from 's' import * as 0 from 's' import * as 0 from 's' import * as 0 from 's' import * as Sequelize from 's' import * as YoutubeDL from 's' import { initDatabaseModels , sequelizeTypescript } from 's' import * as cli from 's' import { logger } from 's' import * as constants from 's' import * as modelsUtils from 's' import * as coreUtils from 's' import * as ffmpegUtils from 's' import * as peertubeCryptoUtils from 's' import * as signupUtils from 's' import * as utils from 's' import * as YoutubeDLUtils from 's' const start = async ( ) => { await initDatabaseModels ( true ) const versionCommitHash = await utils . getServerCommit ( ) const initContext = ( replServer ) => { return ( context ) => { const properties = { context , repl : replServer , env : process . env , lodash : _ , path , 0 , 0 , 0 , 0 , cli , logger , constants , Sequelize , sequelizeTypescript , modelsUtils , models : sequelizeTypescript . models , transaction : sequelizeTypescript . transaction , query : sequelizeTypescript . query , queryInterface : sequelizeTypescript . getQueryInterface ( ) , YoutubeDL , coreUtils , ffmpegUtils , peertubeCryptoUtils , signupUtils , utils , YoutubeDLUtils } for ( let prop in properties ) { Object . defineProperty ( context , prop , { configurable : false , enumerable : true , value : properties [ prop ] } ) } } } const replServer = repl . start ( { prompt : `template` } ) initContext ( replServer ) ( replServer . context ) replServer . on ( 's' , initContext ( replServer ) ) replServer . on ( 's' , ( ) => process . exit ( ) ) const resetCommand = { help : 's' , action ( ) { this . write ( 's' ) this . displayPrompt ( ) } } replServer . defineCommand ( 's' , resetCommand ) replServer . defineCommand ( 's' , resetCommand ) } start ( ) . catch ( ( err ) => { console . error ( err ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { access , constants } from 's' import { isAbsolute } from 's' import { getAccessToken } from 's' import { uploadVideo } from 's' import { buildCommonVideoOptions , buildVideoAttributesFromCommander , getServerCredentials } from 's' let command = program . name ( 's' ) command = buildCommonVideoOptions ( command ) command . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) getServerCredentials ( command ) . then ( ( { url , username , password } ) => { if ( ! program [ 's' ] || ! program [ 's' ] ) { if ( ! program [ 's' ] ) console . error ( 's' ) if ( ! program [ 's' ] ) console . error ( 's' ) process . exit ( - 0 ) } if ( isAbsolute ( program [ 's' ] ) === false ) { console . error ( 's' ) process . exit ( - 0 ) } run ( url , username , password ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) } ) async function run ( url , username , password ) { const accessToken = await getAccessToken ( url , username , password ) await access ( program [ 's' ] , constants . F_OK ) console . log ( 's' , program [ 's' ] ) const videoAttributes = await buildVideoAttributesFromCommander ( url , program ) Object . assign ( videoAttributes , { fixture : program [ 's' ] , thumbnailfile : program [ 's' ] , previewfile : program [ 's' ] } ) try { await uploadVideo ( url , accessToken , videoAttributes ) console . log ( `template` ) process . exit ( 0 ) } catch ( err ) { console . error ( require ( 's' ) . inspect ( err ) ) process . exit ( - 0 ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { join } from 's' import { execSync } from 's' program . name ( 's' ) . arguments ( 's' ) . option ( 's' , 's' , "s" , 's' ) . option ( 's' , 's' , 's' ) . on ( 's' , function ( ) { console . log ( 's' ) console . log ( ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( ) console . log ( ) console . log ( 's' ) console . log ( ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( ) } ) . action ( ( url , cmd ) => { run ( url , cmd ) . catch ( err => { console . error ( err ) process . exit ( - 0 ) } ) } ) . parse ( process . argv ) async function run ( url , program ) { if ( ! url ) { console . error ( 's' ) process . exit ( - 0 ) } const cmd = 's' + join ( __dirname , 's' , 's' , 's' , 's' ) const args = `template` + url . replace ( 's' , 's' ) + `template` execSync ( cmd + args ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as program from 's' import { version , getSettings } from 's' program . version ( version , 's' ) . usage ( 's' ) program . command ( 's' , 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' , { noHelp : true } ) . alias ( 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' ) . command ( 's' , 's' ) . alias ( 's' ) program . command ( 's' , 's' , { noHelp : true } as program . CommandOptions ) . alias ( 's' ) . command ( 's' , 's' , { noHelp : true } as program . CommandOptions ) . alias ( 's' ) if ( ! process . argv . slice ( 0 ) . length ) { const logo = 's' console . log ( `template` + logo + `template` ) } getSettings ( ) . then ( settings => { const state = ( settings . default === undefined || settings . default === - 0 ) ? 's' : 's' + settings . remotes [ settings . default ] + 's' program . on ( 's' , function ( ) { console . log ( ) console . log ( 's' + state ) console . log ( ) console . log ( 's' ) console . log ( ) console . log ( 's' ) console . log ( 's' ) console . log ( 's' ) console . log ( ) } ) . parse ( process . argv ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RegisteredPlugin } from 's' import { MAccountDefault , MActorAccountChannelId , MActorFollowActorsDefault , MActorFollowActorsDefaultSubscription , MActorFull , MChannelAccountDefault , MComment , MCommentOwnerVideoReply , MUserDefault , MVideoAbuse , MVideoBlacklist , MVideoCaptionVideo , MVideoFullLight , MVideoIdThumbnail , MVideoRedundancyVideo , MVideoShareActor , MVideoThumbnail , MVideoWithRights } from 's' import { MVideoPlaylistFull , MVideoPlaylistFullSummary } from 's' import { MVideoImportDefault } from 's' import { MAccountBlocklist , MStreamingPlaylist , MVideoFile } from 's' import { MVideoPlaylistElement , MVideoPlaylistElementVideoUrlPlaylistPrivacy } from 's' import { MAccountVideoRateAccountVideo } from 's' import { MVideoChangeOwnershipFull } from 's' import { MPlugin , MServer } from 's' import { MServerBlocklist } from 's' import { MOAuthTokenUser } from 's' declare module 's' { interface Response { locals : { videoAll ? : MVideoFullLight onlyVideo ? : MVideoThumbnail onlyVideoWithRights ? : MVideoWithRights videoId ? : MVideoIdThumbnail videoShare ? : MVideoShareActor videoFile ? : MVideoFile videoImport ? : MVideoImportDefault videoBlacklist ? : MVideoBlacklist videoCaption ? : MVideoCaptionVideo videoAbuse ? : MVideoAbuse videoStreamingPlaylist ? : MStreamingPlaylist videoChannel ? : MChannelAccountDefault videoPlaylistFull ? : MVideoPlaylistFull videoPlaylistSummary ? : MVideoPlaylistFullSummary videoPlaylistElement ? : MVideoPlaylistElement videoPlaylistElementAP ? : MVideoPlaylistElementVideoUrlPlaylistPrivacy accountVideoRate ? : MAccountVideoRateAccountVideo videoCommentFull ? : MCommentOwnerVideoReply videoCommentThread ? : MComment follow ? : MActorFollowActorsDefault subscription ? : MActorFollowActorsDefaultSubscription nextOwner ? : MAccountDefault videoChangeOwnership ? : MVideoChangeOwnershipFull account ? : MAccountDefault actorFull ? : MActorFull user ? : MUserDefault server ? : MServer videoRedundancy ? : MVideoRedundancyVideo accountBlock ? : MAccountBlocklist serverBlock ? : MServerBlocklist oauth ? : { token : MOAuthTokenUser } signature ? : { actor : MActorAccountChannelId } authenticated ? : boolean registeredPlugin ? : RegisteredPlugin plugin ? : MPlugin } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
require ( 's' ) import { PluginManager } from 's' require ( 's' ) . DEFAULT_ECDH_CURVE = 's' import { isTestInstance } from 's' if ( isTestInstance ( ) ) { require ( 's' ) . install ( ) } import * as bodyParser from 's' import * as express from 's' import * as morgan from 's' import * as cors from 's' import * as cookieParser from 's' import * as helmet from 's' import * as useragent from 's' import * as anonymize from 's' import * as cli from 's' process . title = 's' const app = express ( ) import { checkMissedConfig , checkFFmpeg , checkNodeVersion } from 's' import { CONFIG } from 's' import { API_VERSION , FILES_CACHE , WEBSERVER , loadLanguages } from 's' import { logger } from 's' const missed = checkMissedConfig ( ) if ( missed . length !== 0 ) { logger . error ( 's' + missed ) process . exit ( - 0 ) } checkFFmpeg ( CONFIG ) . catch ( err => { logger . error ( 's' , { err } ) process . exit ( - 0 ) } ) checkNodeVersion ( ) import { checkConfig , checkActivityPubUrls } from 's' const errorMessage = checkConfig ( ) if ( errorMessage !== null ) { throw new Error ( errorMessage ) } app . set ( 's' , CONFIG . TRUST_PROXY ) import { baseCSP } from 's' if ( CONFIG . CSP . ENABLED ) { app . use ( baseCSP ) app . use ( helmet ( { frameguard : { action : 's' } , hsts : false } ) ) } import { initDatabaseModels } from 's' import { migrate } from 's' migrate ( ) . then ( ( ) => initDatabaseModels ( false ) ) . then ( ( ) => startApplication ( ) ) . catch ( err => { logger . error ( 's' , { err } ) process . exit ( - 0 ) } ) loadLanguages ( ) import { installApplication } from 's' import { Emailer } from 's' import { JobQueue } from 's' import { VideosPreviewCache , VideosCaptionCache } from 's' import { activityPubRouter , apiRouter , clientsRouter , feedsRouter , staticRouter , lazyStaticRouter , servicesRouter , pluginsRouter , webfingerRouter , trackerRouter , createWebsocketTrackerServer , botsRouter } from 's' import { advertiseDoNotTrack } from 's' import { Redis } from 's' import { ActorFollowScheduler } from 's' import { RemoveOldViewsScheduler } from 's' import { RemoveOldJobsScheduler } from 's' import { UpdateVideosScheduler } from 's' import { YoutubeDlUpdateScheduler } from 's' import { VideosRedundancyScheduler } from 's' import { RemoveOldHistoryScheduler } from 's' import { AutoFollowIndexInstances } from 's' import { isHTTPSignatureDigestValid } from 's' import { PeerTubeSocket } from 's' import { updateStreamingPlaylistsInfohashesIfNeeded } from 's' import { PluginsCheckScheduler } from 's' import { Hooks } from 's' cli . option ( 's' , 's' ) . option ( 's' , 's' ) . parse ( process . argv ) if ( isTestInstance ( ) ) { app . use ( cors ( { origin : 's' , exposedHeaders : 's' , credentials : true } ) ) } morgan . token ( 's' , req => { if ( req . get ( 's' ) === 's' ) { return anonymize ( req . ip , 0 , 0 ) } return req . ip } ) morgan . token ( 's' , req => { if ( req . get ( 's' ) === 's' ) { return useragent . parse ( req . get ( 's' ) ) . family } return req . get ( 's' ) } ) app . use ( morgan ( 's' , { stream : { write : logger . info . bind ( logger ) } } ) ) app . use ( bodyParser . urlencoded ( { extended : false } ) ) app . use ( bodyParser . json ( { type : [ 's' , 's' ] , limit : 's' , verify : ( req : express . Request , _ , buf ) => { const valid = isHTTPSignatureDigestValid ( buf , req ) if ( valid !== true ) throw new Error ( 's' ) } } ) ) app . use ( cookieParser ( ) ) app . use ( advertiseDoNotTrack ) const apiRoute = 's' + API_VERSION app . use ( apiRoute , apiRouter ) app . use ( 's' , servicesRouter ) app . use ( 's' , pluginsRouter ) app . use ( 's' , activityPubRouter ) app . use ( 's' , feedsRouter ) app . use ( 's' , webfingerRouter ) app . use ( 's' , trackerRouter ) app . use ( 's' , botsRouter ) app . use ( 's' , staticRouter ) app . use ( 's' , lazyStaticRouter ) if ( cli . client ) app . use ( 's' , clientsRouter ) app . use ( function ( req , res , next ) { const err = new Error ( 's' ) err [ 's' ] = 0 next ( err ) } ) app . use ( function ( err , req , res , next ) { let error = 's' if ( err ) { error = err . stack || err . message || err } const sql = err . parent ? err . parent . sql : undefined logger . error ( 's' , { err : error , sql } ) return res . status ( err . status || 0 ) . end ( ) } ) const server = createWebsocketTrackerServer ( app ) async function startApplication ( ) { const port = CONFIG . LISTEN . PORT const hostname = CONFIG . LISTEN . HOSTNAME await installApplication ( ) checkActivityPubUrls ( ) . catch ( err => { logger . error ( 's' , { err } ) process . exit ( - 0 ) } ) Emailer . Instance . init ( ) await Promise . all ( [ Emailer . Instance . checkConnectionOrDie ( ) , JobQueue . Instance . init ( ) ] ) VideosPreviewCache . Instance . init ( CONFIG . CACHE . PREVIEWS . SIZE , FILES_CACHE . PREVIEWS . MAX_AGE ) VideosCaptionCache . Instance . init ( CONFIG . CACHE . VIDEO_CAPTIONS . SIZE , FILES_CACHE . VIDEO_CAPTIONS . MAX_AGE ) ActorFollowScheduler . Instance . enable ( ) RemoveOldJobsScheduler . Instance . enable ( ) UpdateVideosScheduler . Instance . enable ( ) YoutubeDlUpdateScheduler . Instance . enable ( ) VideosRedundancyScheduler . Instance . enable ( ) RemoveOldHistoryScheduler . Instance . enable ( ) RemoveOldViewsScheduler . Instance . enable ( ) PluginsCheckScheduler . Instance . enable ( ) AutoFollowIndexInstances . Instance . enable ( ) Redis . Instance . init ( ) PeerTubeSocket . Instance . init ( server ) updateStreamingPlaylistsInfohashesIfNeeded ( ) . catch ( err => logger . error ( 's' , { err } ) ) if ( cli . plugins ) await PluginManager . Instance . registerPluginsAndThemes ( ) server . listen ( port , hostname , ( ) => { logger . info ( 's' , hostname , port ) logger . info ( 's' , WEBSERVER . URL ) Hooks . runAction ( 's' ) } ) process . on ( 's' , ( ) => { JobQueue . Instance . terminate ( ) } ) process . on ( 's' , ( ) => process . exit ( 0 ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
function isToday ( d ) { const today = new Date ( ) return areDatesEqual ( d , today ) } function isYesterday ( d ) { const yesterday = new Date ( ) yesterday . setDate ( yesterday . getDate ( ) - 0 ) return areDatesEqual ( d , yesterday ) } function isThisWeek ( d ) { const minDateOfThisWeek = new Date ( ) minDateOfThisWeek . setHours ( 0 , 0 , 0 ) let dayOfWeek = minDateOfThisWeek . getDay ( ) - 0 if ( dayOfWeek < 0 ) dayOfWeek = 0 minDateOfThisWeek . setDate ( minDateOfThisWeek . getDate ( ) - dayOfWeek ) return d >= minDateOfThisWeek } function isThisMonth ( d ) { const thisMonth = new Date ( ) . getMonth ( ) return d . getMonth ( ) === thisMonth } function isLastMonth ( d ) { const now = new Date ( ) return getDaysDifferences ( now , d ) <= 0 } function isLastWeek ( d ) { const now = new Date ( ) return getDaysDifferences ( now , d ) <= 0 } export { isYesterday , isThisWeek , isThisMonth , isToday , isLastMonth , isLastWeek } function areDatesEqual ( 0 , 0 ) { return 0 . getFullYear ( ) === 0 . getFullYear ( ) && 0 . getMonth ( ) === 0 . getMonth ( ) && 0 . getDate ( ) === 0 . getDate ( ) } function getDaysDifferences ( 0 , 0 ) { return ( 0 . getTime ( ) - 0 . getTime ( ) ) / ( 0 ) }	O O O $Date$ O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O $Date$ O O O O O O O O O O O O O O O O O O O O O
'js' const MailDev = require ( 's' ) process . on ( 's' , ( msg ) => { if ( msg . start ) { const maildev = new MailDev ( { ip : 's' , smtp : msg . port , disableWeb : true , silent : true } ) maildev . on ( 's' , email => { process . send ( { email } ) } ) maildev . listen ( err => { if ( err ) { return process . send ( { err : err . message } ) } return process . send ( { err : null } ) } ) } } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const clientFilterHookObject = { 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true , 's' : true } export type ClientFilterHookName = keyof typeof clientFilterHookObject export const clientActionHookObject = { 's' : true , 's' : true , 's' : true , 's' : true , 's' : true } export type ClientActionHookName = keyof typeof clientActionHookObject export const clientHookObject = Object . assign ( { } , clientFilterHookObject , clientActionHookObject ) export type ClientHookName = keyof typeof clientHookObject export interface ClientHook { runHook < T > ( hookName , result ? : T , params ? ) : Promise < T > }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientHookName$ O O O O O O O $any$ O O O O O O O
import { ClientHookName } from 's' export interface RegisterClientHookOptions { target : ClientHookName handler : Function priority ? : number }	O O O O O O O O O O O O O O O O O O O O O