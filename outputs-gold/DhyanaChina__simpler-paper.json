'js' const path = require ( 's' ) const fs = require ( 's' ) const webpack = require ( 's' ) const webpackMerge = require ( 's' ) const lintConfig = require ( 's' ) const promisify = require ( 's' ) . promisify const readDir = promisify ( fs . readdir ) const isDebug = process . env . DEBUG || false const manifest = require ( 's' ) module . exports = ( async ( ) => { const externals = Object . keys ( manifest . dependencies ) . reduce ( ( pre , next ) => Object . assign ( { } , pre , { [ next ] : `template` } ) , { } ) const entries = await readDir ( path . join ( __dirname , 's' ) ) const entryName = fileName => `template` const entriesMap = entries . reduce ( ( pre , next ) => Object . assign ( { } , pre , { [ entryName ( next ) ] : path . resolve ( __dirname , `template` ) } ) , { } ) const base = { output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , } , devtool : isDebug ? 's' : 's' , target : 's' , node : { __dirname : false , __filename : true , } , resolve : { extensions : [ 's' , 's' ] , modules : [ path . join ( __dirname , 's' ) , ] , } , module : { loaders : [ { test : "s" , enforce : 's' , exclude : "s" , loader : 's' , options : { configuration : lintConfig , } , } , { test : "s" , loader : 's' , exclude : "s" , options : { configFile : path . resolve ( __dirname , 's' ) , } } , ] , } , plugins : [ new webpack . BannerPlugin ( { raw : true , banner : 's' , exclude : 's' , } ) , new webpack . optimize . UglifyJsPlugin ( { compress : { warnings : false } , } ) , ] , } const server = { entry : entriesMap , externals : externals , target : 's' , } const client = { entry : { index : path . resolve ( __dirname , 's' ) , } , target : 's' , } return [ webpackMerge ( base , server ) , webpackMerge ( base , client ) ] } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { extends : [ 's' ] }	O O O O O O O O O O O O
'js' ! function ( e ) { var n = "s" == typeof window && window || "s" == typeof self && self ; "s" != typeof exports ? e ( exports ) : n && ( n . hljs = e ( { } ) , "s" == typeof define && define . amd && define ( [ ] , function ( ) { return n . hljs } ) ) } ( function ( e ) { function n ( e ) { return e . replace ( "s" , "s" ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) } function t ( e ) { return e . nodeName . toLowerCase ( ) } function r ( e , n ) { var t = e && e . exec ( n ) ; return t && 0 === t . index } function a ( e ) { return k . test ( e ) } function i ( e ) { var n , t , r , i , o = e . className + "s" ; if ( o += e . parentNode ? e . parentNode . className : "s" , t = B . exec ( o ) ) return w ( t [ 0 ] ) ? t [ 0 ] : "s" ; for ( o = o . split ( "s" ) , n = 0 , r = o . length ; r > n ; n ++ ) if ( i = o [ n ] , a ( i ) || w ( i ) ) return i } function o ( e ) { var n , t = { } , r = Array . prototype . slice . call ( arguments , 0 ) ; for ( n in e ) t [ n ] = e [ n ] ; return r . forEach ( function ( e ) { for ( n in e ) t [ n ] = e [ n ] } ) , t } function u ( e ) { var n = [ ] ; return function r ( e , a ) { for ( var i = e . firstChild ; i ; i = i . nextSibling ) 0 === i . nodeType ? a += i . nodeValue . length : 0 === i . nodeType && ( n . push ( { event : "s" , offset : a , node : i } ) , a = r ( i , a ) , t ( i ) . match ( "s" ) || n . push ( { event : "s" , offset : a , node : i } ) ) ; return a } ( e , 0 ) , n } function c ( e , r , a ) { function i ( ) { return e . length && r . length ? e [ 0 ] . offset !== r [ 0 ] . offset ? e [ 0 ] . offset < r [ 0 ] . offset ? e : r : "s" === r [ 0 ] . event ? e : r : e . length ? e : r } function o ( e ) { function r ( e ) { return "s" + e . nodeName + 's' + n ( e . value ) . replace ( 's' , "s" ) + 's' } s += "s" + t ( e ) + E . map . call ( e . attributes , r ) . join ( "s" ) + "s" } function u ( e ) { s += "s" + t ( e ) + "s" } function c ( e ) { ( "s" === e . event ? o : u ) ( e . node ) } for ( var l = 0 , s = "s" , f = [ ] ; e . length || r . length ; ) { var g = i ( ) ; if ( s += n ( a . substring ( l , g [ 0 ] . offset ) ) , l = g [ 0 ] . offset , g === e ) { f . reverse ( ) . forEach ( u ) ; do c ( g . splice ( 0 , 0 ) [ 0 ] ) , g = i ( ) ; while ( g === e && g . length && g [ 0 ] . offset === l ) ; f . reverse ( ) . forEach ( o ) } else "s" === g [ 0 ] . event ? f . push ( g [ 0 ] . node ) : f . pop ( ) , c ( g . splice ( 0 , 0 ) [ 0 ] ) } return s + n ( a . substr ( l ) ) } function l ( e ) { return e . v && ! e . cached_variants && ( e . cached_variants = e . v . map ( function ( n ) { return o ( e , { v : null } , n ) } ) ) , e . cached_variants || e . eW && [ o ( e ) ] || [ e ] } function s ( e ) { function n ( e ) { return e && e . source || e } function t ( t , r ) { return new RegExp ( n ( t ) , "s" + ( e . cI ? "s" : "s" ) + ( r ? "s" : "s" ) ) } function r ( a , i ) { if ( ! a . compiled ) { if ( a . compiled = ! 0 , a . k = a . k || a . bK , a . k ) { var o = { } , u = function ( n , t ) { e . cI && ( t = t . toLowerCase ( ) ) , t . split ( "s" ) . forEach ( function ( e ) { var t = e . split ( "s" ) ; o [ t [ 0 ] ] = [ n , t [ 0 ] ? Number ( t [ 0 ] ) : 0 ] } ) } ; "s" == typeof a . k ? u ( "s" , a . k ) : x ( a . k ) . forEach ( function ( e ) { u ( e , a . k [ e ] ) } ) , a . k = o } a . lR = t ( a . l || "s" , ! 0 ) , i && ( a . bK && ( a . b = "s" + a . bK . split ( "s" ) . join ( "s" ) + "s" ) , a . b || ( a . b = "s" ) , a . bR = t ( a . b ) , a . e || a . eW || ( a . e = "s" ) , a . e && ( a . eR = t ( a . e ) ) , a . tE = n ( a . e ) || "s" , a . eW && i . tE && ( a . tE += ( a . e ? "s" : "s" ) + i . tE ) ) , a . i && ( a . iR = t ( a . i ) ) , null == a . r && ( a . r = 0 ) , a . c || ( a . c = [ ] ) , a . c = Array . prototype . concat . apply ( [ ] , a . c . map ( function ( e ) { return l ( "s" === e ? a : e ) } ) ) , a . c . forEach ( function ( e ) { r ( e , a ) } ) , a . starts && r ( a . starts , i ) ; var c = a . c . map ( function ( e ) { return e . bK ? "s" + e . b + "s" : e . b } ) . concat ( [ a . tE , a . i ] ) . map ( n ) . filter ( Boolean ) ; a . t = c . length ? t ( c . join ( "s" ) , ! 0 ) : { exec : function ( ) { return null } } } } r ( e ) } function f ( e , t , a , i ) { function o ( e , n ) { var t , a ; for ( t = 0 , a = n . c . length ; a > t ; t ++ ) if ( r ( n . c [ t ] . bR , e ) ) return n . c [ t ] } function u ( e , n ) { if ( r ( e . eR , n ) ) { for ( ; e . endsParent && e . parent ; ) e = e . parent ; return e } return e . eW ? u ( e . parent , n ) : void 0 } function c ( e , n ) { return ! a && r ( n . iR , e ) } function l ( e , n ) { var t = N . cI ? n [ 0 ] . toLowerCase ( ) : n [ 0 ] ; return e . k . hasOwnProperty ( t ) && e . k [ t ] } function p ( e , n , t , r ) { var a = r ? "s" : I . classPrefix , i = 's' + a , o = t ? "s" : C ; return i += e + 's' , i + n + o } function h ( ) { var e , t , r , a ; if ( ! E . k ) return n ( k ) ; for ( a = "s" , t = 0 , E . lR . lastIndex = 0 , r = E . lR . exec ( k ) ; r ; ) a += n ( k . substring ( t , r . index ) ) , e = l ( E , r ) , e ? ( B += e [ 0 ] , a += p ( e [ 0 ] , n ( r [ 0 ] ) ) ) : a += n ( r [ 0 ] ) , t = E . lR . lastIndex , r = E . lR . exec ( k ) ; return a + n ( k . substr ( t ) ) } function d ( ) { var e = "s" == typeof E . sL ; if ( e && ! y [ E . sL ] ) return n ( k ) ; var t = e ? f ( E . sL , k , ! 0 , x [ E . sL ] ) : g ( k , E . sL . length ? E . sL : void 0 ) ; return E . r > 0 && ( B += t . r ) , e && ( x [ E . sL ] = t . top ) , p ( t . language , t . value , ! 0 , ! 0 ) } function b ( ) { L += null != E . sL ? d ( ) : h ( ) , k = "s" } function v ( e ) { L += e . cN ? p ( e . cN , "s" , ! 0 ) : "s" , E = Object . create ( e , { parent : { value : E } } ) } function m ( e , n ) { if ( k += e , null == n ) return b ( ) , 0 ; var t = o ( n , E ) ; if ( t ) return t . skip ? k += n : ( t . eB && ( k += n ) , b ( ) , t . rB || t . eB || ( k = n ) ) , v ( t , n ) , t . rB ? 0 : n . length ; var r = u ( E , n ) ; if ( r ) { var a = E ; a . skip ? k += n : ( a . rE || a . eE || ( k += n ) , b ( ) , a . eE && ( k = n ) ) ; do E . cN && ( L += C ) , E . skip || ( B += E . r ) , E = E . parent ; while ( E !== r . parent ) ; return r . starts && v ( r . starts , "s" ) , a . rE ? 0 : n . length } if ( c ( n , E ) ) throw new Error ( 's' + n + 's' + ( E . cN || "s" ) + 's' ) ; return k += n , n . length || 0 } var N = w ( e ) ; if ( ! N ) throw new Error ( 's' + e + 's' ) ; s ( N ) ; var R , E = i || N , x = { } , L = "s" ; for ( R = E ; R !== N ; R = R . parent ) R . cN && ( L = p ( R . cN , "s" , ! 0 ) + L ) ; var k = "s" , B = 0 ; try { for ( var M , j , O = 0 ; ; ) { if ( E . t . lastIndex = O , M = E . t . exec ( t ) , ! M ) break ; j = m ( t . substring ( O , M . index ) , M [ 0 ] ) , O = M . index + j } for ( m ( t . substr ( O ) ) , R = E ; R . parent ; R = R . parent ) R . cN && ( L += C ) ; return { r : B , value : L , language : e , top : E } } catch ( T ) { if ( T . message && - 0 !== T . message . indexOf ( "s" ) ) return { r : 0 , value : n ( t ) } ; throw T } } function g ( e , t ) { t = t || I . languages || x ( y ) ; var r = { r : 0 , value : n ( e ) } , a = r ; return t . filter ( w ) . forEach ( function ( n ) { var t = f ( n , e , ! 0 ) ; t . language = n , t . r > a . r && ( a = t ) , t . r > r . r && ( a = r , r = t ) } ) , a . language && ( r . second_best = a ) , r } function p ( e ) { return I . tabReplace || I . useBR ? e . replace ( M , function ( e , n ) { return I . useBR && "s" === e ? "s" : I . tabReplace ? n . replace ( "s" , I . tabReplace ) : "s" } ) : e } function h ( e , n , t ) { var r = n ? L [ n ] : t , a = [ e . trim ( ) ] ; return e . match ( "s" ) || a . push ( "s" ) , - 0 === e . indexOf ( r ) && a . push ( r ) , a . join ( "s" ) . trim ( ) } function d ( e ) { var n , t , r , o , l , s = i ( e ) ; a ( s ) || ( I . useBR ? ( n = document . createElementNS ( "s" , "s" ) , n . innerHTML = e . innerHTML . replace ( "s" , "s" ) . replace ( "s" , "s" ) ) : n = e , l = n . textContent , r = s ? f ( s , l , ! 0 ) : g ( l ) , t = u ( n ) , t . length && ( o = document . createElementNS ( "s" , "s" ) , o . innerHTML = r . value , r . value = c ( t , u ( o ) , l ) ) , r . value = p ( r . value ) , e . innerHTML = r . value , e . className = h ( e . className , s , r . language ) , e . result = { language : r . language , re : r . r } , r . second_best && ( e . second_best = { language : r . second_best . language , re : r . second_best . r } ) ) } function b ( e ) { I = o ( I , e ) } function v ( ) { if ( ! v . called ) { v . called = ! 0 ; var e = document . querySelectorAll ( "s" ) ; E . forEach . call ( e , d ) } } function m ( ) { addEventListener ( "s" , v , ! 0 ) , addEventListener ( "s" , v , ! 0 ) } function N ( n , t ) { var r = y [ n ] = t ( e ) ; r . aliases && r . aliases . forEach ( function ( e ) { L [ e ] = n } ) } function R ( ) { return x ( y ) } function w ( e ) { return e = ( e || "s" ) . toLowerCase ( ) , y [ e ] || y [ L [ e ] ] } var E = [ ] , x = Object . keys , y = { } , L = { } , k = "s" , B = "s" , M = "s" , C = "s" , I = { classPrefix : "s" , tabReplace : null , useBR : ! 0 , languages : void 0 } ; return e . highlight = f , e . highlightAuto = g , e . fixMarkup = p , e . highlightBlock = d , e . configure = b , e . initHighlighting = v , e . initHighlightingOnLoad = m , e . registerLanguage = N , e . listLanguages = R , e . getLanguage = w , e . inherit = o , e . IR = "s" , e . UIR = "s" , e . NR = "s" , e . CNR = "s" , e . BNR = "s" , e . RSR = "s" , e . BE = { b : "s" , r : 0 } , e . ASM = { cN : "s" , b : "s" , e : "s" , i : "s" , c : [ e . BE ] } , e . QSM = { cN : "s" , b : 's' , e : 's' , i : "s" , c : [ e . BE ] } , e . PWM = { b : "s" } , e . C = function ( n , t , r ) { var a = e . inherit ( { cN : "s" , b : n , e : t , c : [ ] } , r || { } ) ; return a . c . push ( e . PWM ) , a . c . push ( { cN : "s" , b : "s" , r : 0 } ) , a } , e . CLCM = e . C ( "s" , "s" ) , e . CBCM = e . C ( "s" , "s" ) , e . HCM = e . C ( "s" , "s" ) , e . NM = { cN : "s" , b : e . NR , r : 0 } , e . CNM = { cN : "s" , b : e . CNR , r : 0 } , e . BNM = { cN : "s" , b : e . BNR , r : 0 } , e . CSSNM = { cN : "s" , b : e . NR + "s" , r : 0 } , e . RM = { cN : "s" , b : "s" , e : "s" , i : "s" , c : [ e . BE , { b : "s" , e : "s" , r : 0 , c : [ e . BE ] } ] } , e . TM = { cN : "s" , b : e . IR , r : 0 } , e . UTM = { cN : "s" , b : e . UIR , r : 0 } , e . METHOD_GUARD = { b : "s" + e . UIR , r : 0 } , e } ) ; hljs . registerLanguage ( "s" , function ( s ) { var e = "s" , t = { eW : ! 0 , i : "s" , r : 0 , c : [ { cN : "s" , b : e , r : 0 } , { b : "s" , r : 0 , c : [ { cN : "s" , endsParent : ! 0 , v : [ { b : "s" , e : "s" } , { b : "s" , e : "s" } , { b : "s" } ] } ] } ] } ; return { aliases : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] , cI : ! 0 , c : [ { cN : "s" , b : "s" , e : "s" , r : 0 , c : [ { b : "s" , e : "s" } ] } , s . C ( "s" , "s" , { r : 0 } ) , { b : "s" , e : "s" , r : 0 } , { b : "s" , e : "s" , sL : "s" , c : [ { b : "s" , e : "s" , skip : ! 0 } ] } , { cN : "s" , b : "s" , e : "s" , k : { name : "s" } , c : [ t ] , starts : { e : "s" , rE : ! 0 , sL : [ "s" , "s" ] } } , { cN : "s" , b : "s" , e : "s" , k : { name : "s" } , c : [ t ] , starts : { e : "s" , rE : ! 0 , sL : [ "s" , "s" , "s" , "s" ] } } , { cN : "s" , v : [ { b : "s" , e : "s" , r : 0 } , { b : "s" , e : "s" } ] } , { cN : "s" , b : "s" , e : "s" , c : [ { cN : "s" , b : "s" , r : 0 } , t ] } ] } } ) ; hljs . registerLanguage ( "s" , function ( e ) { var c = "s" , t = { b : "s" , rB : ! 0 , e : "s" , eW : ! 0 , c : [ { cN : "s" , b : "s" , e : "s" , eE : ! 0 , starts : { eW : ! 0 , eE : ! 0 , c : [ { b : "s" , rB : ! 0 , c : [ { cN : "s" , b : "s" } , { b : "s" , e : "s" , c : [ e . ASM , e . QSM ] } ] } , e . CSSNM , e . QSM , e . ASM , e . CBCM , { cN : "s" , b : "s" } , { cN : "s" , b : "s" } ] } } ] } ; return { cI : ! 0 , i : "s" , c : [ e . CBCM , { cN : "s" , b : "s" } , { cN : "s" , b : "s" } , { cN : "s" , b : "s" , e : "s" , i : "s" } , { cN : "s" , b : "s" } , { b : "s" , l : "s" , k : "s" } , { b : "s" , e : "s" , i : "s" , c : [ { cN : "s" , b : "s" } , { b : "s" , eW : ! 0 , eE : ! 0 , r : 0 , c : [ e . ASM , e . QSM , e . CSSNM ] } ] } , { cN : "s" , b : c , r : 0 } , { b : "s" , e : "s" , i : "s" , c : [ e . CBCM , t ] } ] } } ) ; hljs . registerLanguage ( "s" , function ( e ) { var t = { b : "s" , r : 0 } , o = { cN : "s" , v : [ { b : "s" } ] } , r = { cN : "s" , b : "s" } , n = { cN : "s" , v : [ { b : "s" , e : "s" } , { b : "s" , e : "s" } ] , c : [ t , o , { cN : "s" , b : "s" , e : "s" } ] } , a = { cN : "s" , v : [ { b : "s" , e : "s" } , { b : "s" , e : "s" } ] } , i = { cN : "s" , v : [ { b : "s" } , { b : "s" } ] } , s = e . inherit ( e . C ( null , null ) , { v : [ { b : "s" , e : "s" } , { b : "s" , e : "s" } ] , c : [ i ] } ) ; return { aliases : [ "s" ] , l : "s" , cI : ! 0 , k : { keyword : "s" , built_in : "s" , nomarkup : "s" } , c : [ t , e . NM , n , a , r , o , s ] } } ) ; hljs . registerLanguage ( "s" , function ( e ) { var i = { literal : "s" } , n = [ e . QSM , e . CNM ] , r = { e : "s" , eW : ! 0 , eE : ! 0 , c : n , k : i } , t = { b : "s" , e : "s" , c : [ { cN : "s" , b : "s" , e : "s" , c : [ e . BE ] , i : "s" } , e . inherit ( r , { b : "s" } ) ] , i : "s" } , c = { b : "s" , e : "s" , c : [ e . inherit ( r ) ] , i : "s" } ; return n . splice ( n . length , 0 , t , c ) , { c : n , k : i , i : "s" } } ) ; hljs . registerLanguage ( "s" , function ( e ) { var t = { cN : "s" , v : [ { b : "s" } , { b : "s" } ] } , s = { cN : "s" , b : "s" , e : "s" , c : [ e . BE , t , { cN : "s" , b : "s" , e : "s" , c : [ e . BE ] } ] } , a = { cN : "s" , b : "s" , e : "s" } ; return { aliases : [ "s" , "s" ] , l : "s" , k : { keyword : "s" , literal : "s" , built_in : "s" , _ : "s" } , c : [ { cN : "s" , b : "s" , r : 0 } , { cN : "s" , b : "s" , rB : ! 0 , c : [ e . inherit ( e . TM , { b : "s" } ) ] , r : 0 } , e . HCM , s , a , t ] } } ) ; hljs . registerLanguage ( "s" , function ( s ) { return { aliases : [ "s" ] , c : [ { cN : "s" , b : "s" , starts : { e : "s" , sL : "s" } } ] } } ) ; hljs . registerLanguage ( "s" , function ( e ) { var r = "s" , t = { keyword : "s" , literal : "s" , built_in : "s" } , a = { cN : "s" , v : [ { b : "s" } , { b : "s" } , { b : e . CNR } ] , r : 0 } , n = { cN : "s" , b : "s" , e : "s" , k : t , c : [ ] } , c = { cN : "s" , b : "s" , e : "s" , c : [ e . BE , n ] } ; n . c = [ e . ASM , e . QSM , c , a , e . RM ] ; var s = n . c . concat ( [ e . CBCM , e . CLCM ] ) ; return { aliases : [ "s" , "s" ] , k : t , c : [ { cN : "s" , r : 0 , b : "s" } , { cN : "s" , b : "s" , e : "s" } , e . ASM , e . QSM , c , e . CLCM , e . CBCM , a , { b : "s" , r : 0 , c : [ { b : r + "s" , rB : ! 0 , r : 0 , c : [ { cN : "s" , b : r , r : 0 } ] } ] } , { b : "s" + e . RSR + "s" , k : "s" , c : [ e . CLCM , e . CBCM , e . RM , { cN : "s" , b : "s" + r + "s" , rB : ! 0 , e : "s" , c : [ { cN : "s" , v : [ { b : r } , { b : "s" } , { b : "s" , e : "s" , eB : ! 0 , eE : ! 0 , k : t , c : s } ] } ] } , { b : "s" , e : "s" , sL : "s" , c : [ { b : "s" , skip : ! 0 } , { b : "s" , e : "s" , skip : ! 0 , c : [ { b : "s" , skip : ! 0 } , "s" ] } ] } ] , r : 0 } , { cN : "s" , bK : "s" , e : "s" , eE : ! 0 , c : [ e . inherit ( e . TM , { b : r } ) , { cN : "s" , b : "s" , e : "s" , eB : ! 0 , eE : ! 0 , c : s } ] , i : "s" } , { b : "s" } , e . METHOD_GUARD , { cN : "s" , bK : "s" , e : "s" , eE : ! 0 , i : "s" , c : [ { bK : "s" } , e . UTM ] } , { bK : "s" , e : "s" , eE : ! 0 } ] , i : "s" } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const defaultConfig = { alias : { } , title : 's' , docPath : 's' , output : 's' , theme : 's' , miniMap : false , backToTop : false , indicator : true , expandAll : false , }	O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const fs = require ( 's' ) import * as marked from 's' import * as hljs from 's' const promisify = require ( 's' ) const childProcess = require ( 's' ) const renderer = new marked . Renderer ( ) const tipsReg = "s" const classMap = { 's' : 's' , 's' : 's' , 's' : 's' } const paragraphCopy : ( t ) => string = renderer . paragraph renderer . paragraph = ( text ) : string => { if ( ! tipsReg . test ( text ) ) return paragraphCopy ( text ) const content = text . replace ( tipsReg , 's' ) const typeStr = text . match ( tipsReg ) [ 0 ] . replace ( "s" , 's' ) return `template` } marked . setOptions ( { renderer , gfm : true , tables : true , breaks : false , pedantic : false , sanitize : false , smartLists : true , smartypants : false , highlight => ( < any > hljs ) . highlightAuto ( code ) . value , } ) const noErrorPromisifyShim = ( func ) => ( ... args : any [ ] ) => new Promise ( r => { func ( ... args , ( ... results ) => r ( ... results ) ) } ) const makePromisify = ( ) : Function => { const nativePromisify = require ( 's' ) . promisify if ( nativePromisify && typeof nativePromisify === 's' ) { return nativePromisify } return noErrorPromisifyShim } const noErrorPromisify = makePromisify ( ) export default { readdir : promisify ( fs . readdir ) , mkdir : promisify ( fs . mkdir ) , readFile : promisify ( fs . readFile ) , writeFile : promisify ( fs . writeFile ) , exists : noErrorPromisify ( fs . exists ) , stat : promisify ( fs . stat ) , spawnSync : childProcess . spawnSync , exec : promisify ( childProcess . exec ) , marked : promisify ( marked ) , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $code$ O O O O O O O O O O O O O O O O O O $Function$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import chalk from 's' import * as Ora from 's' import { hrtime } from 's' let startTime : [ number , number ] let ora let oraTask export default { sourceError : ( path ? ) => { console . log ( chalk . red ( 's' ) ) path && console . log ( chalk . red ( `template` ) ) console . log ( `template` ) } , configInvalid : ( ) => { console . log ( chalk . red ( 's' ) ) } , configNonUnique : ( directories : string [ ] ) => { console . log ( chalk . red ( 's' ) ) directories . forEach ( dir => console . log ( `template` ) ) console . log ( 's' ) } , configNotFound : ( ) => { console . log ( chalk . red ( `template` ) ) } , notFoundTheme : ( theme ) => { console . log ( chalk . red ( `template` ) ) } , time : { start ( task ) { startTime = hrtime ( ) ora = new Ora ( task ) . start ( ) oraTask = task } , over ( success = true ) { const time : [ number , number ] = hrtime ( startTime ) const show = ( time [ 0 ] / 0 ) . toFixed ( 0 ) if ( ! success ) { ora . fail ( oraTask ) return process . exit ( 0 ) } ora . succeed ( oraTask ) console . log ( `template` ) } , } , }	O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { defaultConfig } from 's' import File from 's' import Log from 's' import { Stats } from 's' export const checkSource = async ( path = 's' ) => { if ( ! await File . exists ( path ) ) { Log . sourceError ( path ) process . exit ( 0 ) } } export const checkConfig = async ( path = 's' ) : Promise < any > => { const configPath = `template` if ( ! await File . exists ( configPath ) ) return { } const config = await File . readFile ( `template` ) let result try { result = JSON . parse ( config . toString ( ) || 's' ) } catch ( e ) { Log . configInvalid ( ) } return result } export const checkTheme = async ( config ) : Promise < boolean > => { const theme = config . theme || 's' const p = `template` if ( ! await File . exists ( p ) ) { Log . notFoundTheme ( theme ) process . exit ( 0 ) return false } return true } export const findSource = async ( userPath ) : Promise < string > => { const files : string [ ] = await File . readdir ( userPath ) const directories : string [ ] = [ ] for ( const f of files ) { const stat = await File . stat ( `template` ) if ( stat . isFile ( ) ) continue if ( await File . exists ( `template` ) ) { directories . push ( f ) } } if ( directories . length > 0 ) { Log . configNonUnique ( directories ) process . exit ( 0 ) } if ( directories . length === 0 ) { Log . configNotFound ( ) process . exit ( 0 ) } return directories [ 0 ] } export const assignConfig = async ( source ) : Promise < Config > => { await checkSource ( source ) const userConfig = await checkConfig ( source ) const config = Object . assign ( { } , defaultConfig , userConfig , { __user_source_path : source } , ) return config }	O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Stats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O
const pathFormat = path => path . replace ( "s" , 's' ) export default { path : pathFormat , }	O O O O O O O O O O O O O O O O O O O O O
const USER_PATH = process . cwd ( ) const __target = `template` import File from 's' let includeStyle = false export const appendHighlight = async ( source , scripts ) => { const docPath = `template` const files : string [ ] = await File . readdir ( docPath ) let hljs = 's' for ( const name of files ) { if ( name === 's' ) { await File . exec ( `template` ) hljs += `template` } if ( name === 's' ) { await File . exec ( `template` ) includeStyle = true } } scripts = hljs + scripts return scripts } export const appendHighlightStyle = ( inlineHtml ) : string => { if ( ! includeStyle ) return inlineHtml return inlineHtml . replace ( 's' , 's' , ) }	O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $string$ O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O
import File from 's' import Log from 's' import Filter from 's' import { Stats } from 's' import { appendHighlight , appendHighlightStyle } from 's' const __app = Filter . path ( `template` ) const __target = Filter . path ( `template` ) const __temp = Filter . path ( `template` ) const USER_PATH = process . cwd ( ) const parseSuffix = ( filePath ) : [ string , string , string , string , number ] => { const suffix = filePath . split ( 's' ) . reverse ( ) [ 0 ] const includeNumberPrefix = "s" . test ( suffix ) && ! Number . isNaN ( + suffix . split ( 's' ) [ 0 ] ) const weight = includeNumberPrefix ? + suffix . split ( 's' ) [ 0 ] : 0 const fileName = includeNumberPrefix ? suffix . replace ( "s" , 's' ) : suffix const path = filePath . replace ( suffix , 's' ) const showPath = path . replace ( "s" , 's' ) return [ path , showPath , suffix , fileName , weight ] } const generateCatalog = ( filePath , config , children : Catalog [ ] = [ ] ) => { const [ path , showPath , suffix , fileName , weight ] = parseSuffix ( filePath ) return { path , showPath , native : suffix , name : config . alias [ fileName ] ? config . alias [ fileName ] : fileName , children , weight , } } const isMarkFileOrDirectory = ( name ) : boolean => name . endsWith ( 's' ) || ! name . includes ( 's' ) const deepEachSource = async ( path , config ) : Promise < Catalog [ ] > => { const files : string [ ] = await File . readdir ( `template` ) const catalogs : Catalog [ ] = [ ] for ( const name of files ) { if ( ! isMarkFileOrDirectory ( name ) ) continue if ( name === 's' ) continue const nextPath = `template` const stat = await File . stat ( nextPath ) if ( stat . isFile ( ) ) { catalogs . push ( generateCatalog ( nextPath , config ) ) continue } if ( stat . isDirectory ( ) ) { catalogs . push ( generateCatalog ( nextPath , config , await deepEachSource ( nextPath , config ) ) ) } } return catalogs . sort ( ( pre , next ) => pre . weight - next . weight ) } export const compileCatalog = async ( config ) => { Log . time . start ( 's' ) const catalogs : Catalog [ ] = await deepEachSource ( config . __user_source_path , config ) Log . time . over ( ) return catalogs } const makeTargetPath = ( path , sourcePath ) : string => { const sourceFullPath = path . split ( sourcePath ) . reverse ( ) [ 0 ] return `template` } const createHtml = async ( source , target ) : Promise < void > => { const content = await File . readFile ( source , 's' ) target = target . replace ( 's' , 's' ) await File . writeFile ( target , await File . marked ( content ) , 's' ) } const generatePages = async ( catalogs : Catalog [ ] , sourcePath ) : Promise < void > => { for ( const unit of catalogs ) { const p = makeTargetPath ( unit . showPath + unit . name , sourcePath ) if ( unit . children && unit . children . length > 0 ) { await File . spawnSync ( 's' , [ p ] ) await generatePages ( unit . children , sourcePath ) continue } await createHtml ( unit . path + unit . native , p ) } } export const compileMarkdown = async ( catalogs : Catalog [ ] , sourcePath ) => { Log . time . start ( 's' ) await File . exists ( __temp ) && await File . exec ( `template` ) await File . mkdir ( __temp ) await File . mkdir ( `template` ) await generatePages ( catalogs , sourcePath ) Log . time . over ( ) } export const copyTheme = async ( config ) : Promise < void > => { const theme = config . theme || 's' const p = `template` const themeStr = await File . readFile ( p , 's' ) await File . writeFile ( `template` , themeStr ) } export const copyAssets = async ( config ) : Promise < void > => { const p = `template` if ( ! ( await File . exists ( p ) ) ) return await File . exec ( `template` ) } export const copyInlineHtml = async ( config , catalogs : Catalog [ ] ) : Promise < void > => { const index = await File . readFile ( `template` , 's' ) const indexs : string [ ] = index . split ( 's' ) let scripts = `template` const foot = `template` await File . exec ( `template` ) scripts = await appendHighlight ( config . __user_source_path , scripts ) let inlineHtml = indexs . reduce ( ( pre , next ) => pre + next , 's' ) + scripts + foot inlineHtml = inlineHtml . replace ( 's' , config . title ) inlineHtml = appendHighlightStyle ( inlineHtml ) inlineHtml = inlineHtml . replace ( "s" , 's' ) . replace ( "s" , 's' ) await File . writeFile ( `template` , inlineHtml , 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $Stats$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { checkTheme , findSource , assignConfig } from 's' import { compileCatalog , compileMarkdown , copyTheme , copyInlineHtml , copyAssets } from 's' import File from 's' import Log from 's' import Filter from 's' import { resolve } from 's' const removeDir = async ( dir ) => { await File . exists ( dir ) && await File . exec ( `template` ) } ; ( async ( ) => { const root = Filter . path ( `template` ) const templateTargetPath = `template` const templateTempPath = `template` Log . time . start ( 's' ) const source = await findSource ( process . cwd ( ) ) const config = await assignConfig ( source ) Log . time . over ( ) const targetPath = `template` const catalogs : Catalog [ ] = await compileCatalog ( config ) await compileMarkdown ( catalogs , source ) Log . time . start ( 's' ) await removeDir ( templateTargetPath ) await checkTheme ( config ) await copyTheme ( config ) await copyAssets ( config ) Log . time . over ( ) await File . exec ( `template` ) await removeDir ( templateTempPath ) await copyInlineHtml ( config , catalogs ) Log . time . start ( 's' ) await removeDir ( targetPath ) await File . exec ( `template` ) Log . time . over ( ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as pages from 's' import * as commander from 's' import File from 's' import Log from 's' import { findSource , assignConfig } from 's' import chalk from 's' const resetDir = async ( path ) => { await File . exists ( path ) && await File . exec ( `template` ) } const checkGit = async ( git ) => { if ( await File . exists ( git ) ) return console . log ( chalk . red ( 's' ) ) process . exit ( 0 ) } commander . option ( 's' , 's' ) . parse ( process . argv ) const message = commander . args [ 0 ] || 's' ; ( async ( ) => { const __user = process . cwd ( ) const cachePath = `template` await checkGit ( `template` ) console . log ( `template` ) if ( ! commander . args [ 0 ] ) { console . log ( `template` ) } Log . time . start ( 's' ) const source = await findSource ( __user ) const config = await assignConfig ( source ) const distPath = `template` if ( ! await File . exists ( distPath ) || ! await File . exists ( `template` ) ) { console . log ( chalk . red ( 's' ) ) console . log ( chalk . green ( 's' ) ) return Log . time . over ( false ) } pages . clean ( ) Log . time . over ( ) Log . time . start ( 's' ) await resetDir ( cachePath ) pages . publish ( distPath , { message , branch : 's' , cache : cachePath , } , err => { resetDir ( cachePath ) . then ( ) if ( err ) { console . log ( chalk . red ( `template` ) ) } Log . time . over ( ! err ) } ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $Config$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as inquirer from 's' import * as Ora from 's' import chalk from 's' import File from 's' const question = [ { type : 's' , name : 's' , message : 's' , } ] ; ( async ( ) => { new Ora ( ) . info ( 's' ) const { answer } = await inquirer . prompt ( question ) const toggle = String ( answer ) . toLowerCase ( ) === 's' if ( ! toggle ) return console . log ( chalk . yellow ( 's' ) ) File . exec ( 's' , [ 's' , 's' , 's' ] ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as inquirer from 's' import chalk from 's' import File from 's' import { defaultConfig } from 's' const __USER_PATH = process . cwd ( ) const createConfig = async ( folder ) => { const configTarget = `template` if ( await File . exists ( configTarget ) ) return false await File . writeFile ( configTarget , JSON . stringify ( defaultConfig ) ) return true } const promps = [ { type : 's' , name : 's' , message : 's' , validate => ! ! input , } ] const question = [ { type : 's' , name : 's' , message : 's' , validate => ! ! input , } ] ; ( async ( ) => { const { folder } = await inquirer . prompt ( promps ) if ( "s" . test ( folder ) ) { console . log ( `template` ) return process . exit ( 0 ) } if ( ! await File . exists ( folder ) ) { await File . exec ( `template` ) await createConfig ( folder ) console . log ( chalk . green ( 's' ) ) return process . exit ( 0 ) } console . log ( `template` ) const { answer } = await inquirer . prompt ( question ) const toggle = String ( answer ) . toLowerCase ( ) === 's' if ( ! toggle ) { console . log ( chalk . yellow ( 's' ) ) return process . exit ( 0 ) } if ( ! await createConfig ( folder ) ) { console . log ( `template` ) return process . exit ( 0 ) } console . log ( chalk . green ( 's' ) ) return process . exit ( 0 ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $input$ O O O O O O O O O O O O O O O O O O O O O O O O $input$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as commander from 's' import * as express from 's' import * as serveStatic from 's' import File from 's' import chalk from 's' commander . option ( 's' , 's' ) . parse ( process . argv ) const port = Number . isNaN ( + commander . args [ 0 ] ) ? 0 : + commander . args [ 0 ] ; ( async ( ) => { const __target = `template` const app = express ( ) if ( ! File . exists ( __target ) ) { console . log ( chalk . red ( 's' ) ) console . log ( chalk . green ( 's' ) ) return process . exit ( 0 ) } app . use ( serveStatic ( __target , { 's' : [ 's' ] , } ) ) console . log ( `template` ) app . listen ( port ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as commander from 's' import chalk from 's' import * as notifier from 's' const pkg = require ( 's' ) const v = process . version . match ( "s" ) [ 0 ] if ( + v < 0 ) { console . log ( chalk . yellow ( 's' ) ) console . log ( chalk . yellow ( 's' ) ) process . exit ( 0 ) } notifier ( { pkg , updateCheckInterval : 0 } ) . notify ( { isGlobal : true } ) commander . version ( pkg . version ) . usage ( 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' ) . alias ( 's' ) . command ( 's' , 's' ) . command ( 's' , 's' ) . parse ( process . argv )	O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
type EventRecord = { type : string , handle : EventListener , } export class EventHub { private source : Text private eventRecords : EventRecord [ ] = [ ] constructor ( ) { this . source = document . createTextNode ( 's' ) } dispath ( eventType , detail ? ) { const event = new CustomEvent ( eventType , Object . assign ( { bubbles : true , cancelable : true , } , { detail } ) ) this . source . dispatchEvent ( event ) } listen ( eventType , done ) { const record = this . eventRecords . find ( record => { return record . type === eventType && record . handle === done } ) if ( ! ! record ) return this . source . addEventListener ( eventType , done ) this . eventRecords . push ( { type : eventType , handle : done , } ) } remove ( eventType , done ? ) { if ( done ) return this . removeOne ( eventType , done ) this . eventRecords . filter ( re => re . type === eventType ) . forEach ( re => this . source . removeEventListener ( re . type , re . handle ) ) } removeAll ( ) { this . eventRecords . forEach ( re => this . source . removeEventListener ( re . type , re . handle ) ) } private removeOne ( eventType , done ? ) { const record = this . eventRecords . find ( record => { return record . type === eventType && record . handle === done } ) if ( ! record ) return this . source . removeEventListener ( eventType , done ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $any$ O O O $CustomEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O $EventListener$ O O O $EventRecord$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $EventListener$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $EventListener$ O O O $EventRecord$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class BackToTop { static toggleBackButton ( btnElement , show ) { btnElement . classList . toggle ( 's' , show ) } static handleBackButton ( container ) { container . scrollTop = 0 } static makeBackButton ( d ) { const _div = d . createElement ( 's' ) _div . classList . add ( 's' ) _div . innerHTML = `template` return _div } constructor ( ) { this . init ( ) } private init ( ) { const container = document . querySelector ( 's' ) const main = document . querySelector ( 's' ) const backButton = BackToTop . makeBackButton ( document ) main . appendChild ( backButton ) backButton . addEventListener ( 's' , ( ) => { BackToTop . handleBackButton ( container ) } ) container . addEventListener ( 's' , ( e ) => { BackToTop . toggleBackButton ( backButton , ( < Element > e . target ) . scrollTop > 0 ) } ) } }	O O O O O $void$ O $Element$ O $boolean$ O O O O O O O O O O O O O O $void$ O $Element$ O O O O O O O O O $Element$ O $Document$ O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $Element$ O O O O O O O O $Element$ O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventHub } from 's' export class Highlight { constructor ( eventHub ) { eventHub . listen ( 's' , this . handle ) } handle ( ) { if ( ! window . hljs ) return const { highlightBlock } = window . hljs const blocks < Element > = document . querySelectorAll ( 's' ) Array . from ( blocks ) . forEach ( code => highlightBlock ( code ) ) } }	O O O O O O O O O O O O $EventHub$ O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $NodeListOf$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventHub } from 's' export class Indicator { private indicatorElement : HTMLElement static toggleIndicator ( indicatorElement , show ) { if ( ! indicatorElement ) return indicatorElement . classList . toggle ( 's' , show ) } static makeIndicatorElement ( d ) { const _div = d . createElement ( 's' ) _div . classList . add ( 's' ) _div . innerHTML = `template` return _div } constructor ( eventHub ) { this . init ( ) eventHub . listen ( 's' , ( ) => this . willChange ( ) ) eventHub . listen ( 's' , ( ) => this . changed ( ) ) } willChange ( ) { Indicator . toggleIndicator ( this . indicatorElement , true ) } changed ( ) { Indicator . toggleIndicator ( this . indicatorElement , false ) } private init ( ) { const main = document . querySelector ( 's' ) this . indicatorElement = Indicator . makeIndicatorElement ( document ) main . appendChild ( this . indicatorElement ) } }	O O O O O O O O O O O O O O O $void$ O $HTMLElement$ O $boolean$ O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O $Document$ O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O $EventHub$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $void$ O O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class Responsive { private trunks : Element [ ] = [ ] private lastSize : string = 's' static TrunksClasses ( ) : string [ ] { return [ 's' , 's' , 's' , 's' , 's' ] } static MakeSize ( width ) { if ( width < 0 ) return 's' if ( width < 0 ) return 's' if ( width < 0 ) return 's' if ( width < 0 ) return 's' return 's' } constructor ( ) { this . init ( ) this . initMobileEvent ( ) } private init ( ) { const body = document . body this . trunks = Responsive . TrunksClasses ( ) . map ( str => body . querySelector ( str ) ) . filter ( r => ! ! r ) . concat ( [ body ] ) window . addEventListener ( 's' , ( ) => this . detector ( ) ) this . detector ( ) } private detector ( ) { const size = Responsive . MakeSize ( window . innerWidth ) if ( size === this . lastSize ) return try { this . trunks . forEach ( el => { el . classList . add ( size ) this . lastSize && el . classList . remove ( this . lastSize ) } ) } catch ( e ) { } this . lastSize = size } private initMobileEvent ( ) { const sideTitle = document . querySelector ( 's' ) const sideBar = document . querySelector ( 's' ) sideTitle . addEventListener ( 's' , ( ) => { const isMobile = sideBar . classList . contains ( 's' ) || sideBar . classList . contains ( 's' ) if ( ! isMobile ) return sideBar . classList . toggle ( 's' ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $Element$ O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BackToTop } from 's' import { Highlight } from 's' import { Indicator } from 's' import { Responsive } from 's' const saveToDefaultRouter = ( link ) : void => { if ( window . __paper . router . default ) return window . __paper . router . default = link } const removeMarkdownSuffix = ( name ) => name . replace ( 's' , 's' ) const makeList = async ( catalogs : Catalog [ ] , path , d ) => { const ul = d . createElement ( 's' ) for ( const unit of catalogs ) { const li = d . createElement ( 's' ) const routerLink = ( unit . showPath + unit . name ) . replace ( path , 's' ) if ( unit . children && unit . children . length > 0 ) { li . innerHTML = `template` li . classList . add ( 's' ) const subList = await makeList ( unit . children , path , d ) subList . classList . add ( 's' ) li . appendChild ( subList ) } else { saveToDefaultRouter ( routerLink ) li . innerHTML = `template` } ul . appendChild ( li ) } return ul } const makeTitle = ( config ) : HTMLElement => { document . title = config . title const title = document . createElement ( 's' ) title . classList . add ( 's' ) title . innerHTML = `template` return title } export const side = async ( catalogs : Catalog [ ] , config ) : Promise < HTMLElement [ ] > => { const title = makeTitle ( config ) const list = await makeList ( catalogs , config . __user_source_path , document ) list . classList . add ( 's' ) return [ title , list ] } const initSubList = async ( config ) => { const containers < Element > = document . querySelectorAll ( 's' ) const subList < Element > = document . querySelectorAll ( 's' ) const subListArr : Element [ ] = ( < Array < Element > > Array . from ( subList ) ) let baseHeight = 0 subListArr . some ( sub => { const li = sub . querySelector ( 's' ) if ( li && li . offsetHeight ) { baseHeight = li . offsetHeight } return ! ! li } ) const handle = ( container , first ? ) : void => { const getUlRealHeight = ( ul ) : number => { const children < Element > = ul . querySelectorAll ( 's' ) return ( Array . from ( children ) . length || 0 ) * baseHeight } const list = ( < HTMLElement > container . querySelector ( 's' ) ) const height = getUlRealHeight ( list ) const isClose = list . offsetHeight > 0 let deep = 0 const syncParentsHeight = ( self ) : any => { if ( deep <= 0 ) return deep -- const parent = self . parentElement const isList = parent . nodeName . toLowerCase ( ) === 's' const isSubList = parent . classList . contains ( 's' ) if ( ! isList || ! isSubList ) return syncParentsHeight ( self . parentElement ) const nativeHeight = getUlRealHeight ( parent ) parent . style . height = `template` deep ++ syncParentsHeight ( self . parentElement ) } syncParentsHeight ( list ) list . style . height = first ? `template` : `template` } Array . from ( containers ) . forEach ( con => { config . expandAll && handle ( con , true ) con . addEventListener ( 's' , ( ) => handle ( con ) ) } ) subListArr . forEach ( sub => { sub . addEventListener ( 's' , ( event ) => event . stopPropagation ( ) ) } ) } const changTitle = ( eventHub , config ) => { const pathToTitle = ( p ) : string => { let hash = p . split ( 's' ) . reverse ( ) [ 0 ] hash = hash . replace ( 's' , 's' ) . replace ( 's' , 's' ) . replace ( 's' , 's' ) . replace ( 's' , 's' ) return hash . split ( 's' ) . map ( path => path . replace ( "s" , 's' ) . replace ( "s" , 's' ) ) . filter ( r => ! ! r ) . map ( str => config . alias [ str ] || str ) . join ( 's' ) } eventHub . listen ( 's' , ( { detail } ) => { document . title = `template` } ) } export const event = async ( config , eventHub ) : Promise < void > => { await initSubList ( config ) config . backToTop && new BackToTop ( ) config . indicator && new Indicator ( eventHub ) new Highlight ( eventHub ) new Responsive ( ) changTitle ( eventHub , config ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $Document$ O O O O $HTMLElement$ O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O $HTMLElement$ O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O $NodeListOf$ O O O O O O O O O O O $NodeListOf$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O $Element$ O O $boolean$ O O O O O O $Function$ O O $HTMLElement$ O O O O O O $NodeListOf$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O $number$ O O O O O O $boolean$ O O O O O O O $number$ O O O $Function$ O O $HTMLElement$ O O O O O O O O O O O O O O O $HTMLElement$ O O O O O $boolean$ O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O $any$ O $Config$ O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const headers = new Headers ( ) headers . append ( 's' , 's' ) export const findHTML = ( url ) : Promise < Response > => { return new Promise ( ( r , j ) => { window . fetch ( url , { method : 's' , mode : 's' , cache : 's' , credentials : 's' , headers , } ) . then ( res => r ( res ) ) . catch ( e => j ( e ) ) } ) } export const init = ( ) : void => { window . __paper = { router : { default : null , } , } }	O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { findHTML } from 's' export class Router { private slotElement : HTMLElement private docPath : string private links : any [ ] = [ ] private lastLink : HTMLElement private eventHub : any private origin : string static removeHashTag ( hash = 's' ) { if ( ! hash . startsWith ( 's' ) ) return hash return hash . substr ( 0 , hash . length ) } static removeSlash ( path ) { return path . replace ( "s" , 's' ) } static replaceSuffix ( name ) { name = name . split ( 's' ) [ 0 ] return `template` } constructor ( slotElement , docPath = 's' ) { this . slotElement = slotElement this . docPath = docPath this . origin = window . location . origin + window . location . pathname this . initList ( ) } listen ( eventHub ) { this . eventHub = eventHub window . onhashchange = ( ) => this . _parseHash ( ) this . _parseHash ( ) } private closeMenu ( ) { const sideBar = document . querySelector ( 's' ) const isMobile = sideBar . classList . contains ( 's' ) || sideBar . classList . contains ( 's' ) if ( ! isMobile ) return sideBar . classList . remove ( 's' ) } private initList ( ) { const sideList = document . querySelector ( 's' ) const links < Element > = sideList . querySelectorAll ( 's' ) Array . from ( links ) . forEach ( ( link ) => { this . links . push ( { el : link , href : link . getAttribute ( 's' ) , } ) } ) } private toggleList ( hash ) { const link = this . links . find ( link => link . href === `template` ) if ( ! link ) return this . lastLink && this . lastLink . parentElement . classList . remove ( 's' ) link . el . parentElement . classList . add ( 's' ) this . lastLink = link . el } private _parseHash ( ) { this . eventHub . dispath ( 's' ) const hash = Router . removeHashTag ( window . location . hash ) this . toggleList ( hash ) let path = 's' + this . docPath + hash if ( path . endsWith ( 's' ) ) { path += window . __paper . router . default } const htmlPath = Router . replaceSuffix ( path ) this . _loader ( Router . removeSlash ( htmlPath ) ) . then ( ) } private async _loader ( path ) < void > { const res = await findHTML ( this . origin + path ) const _div = document . createElement ( 's' ) _div . classList . add ( 's' ) _div . innerHTML = await res . text ( ) this . slotElement . innerHTML = 's' this . slotElement . appendChild ( _div ) this . slotElement . parentElement . scrollTo ( 0 , 0 ) this . eventHub . dispath ( 's' , path ) this . closeMenu ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O $HTMLElement$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $Element$ O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $Element$ O O O O O O O O $NodeListOf$ O O O O O O O O O O O O O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O $Response$ O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const config = window . __config const catalogs : Catalog [ ] = window . __catalogs import * as Generator from 's' import { init } from 's' import { Router } from 's' import { EventHub } from 's' const docker = async ( w , d ) : Promise < void > => { const eventHub = new EventHub ( ) const sidebar = d . getElementById ( 's' ) const sides : HTMLElement [ ] = await Generator . side ( catalogs , config ) sides . forEach ( el => sidebar . appendChild ( el ) ) await Generator . event ( config , eventHub ) new Router ( d . getElementById ( 's' ) , config . docPath ) . listen ( eventHub ) } window . onload = ( ) : void => { init ( ) docker ( window , document ) . then ( ) console . log ( 's' ) }	O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O $Window$ O $Document$ O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O