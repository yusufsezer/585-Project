import dedent from 's' ; export const defaultQuery = `template` ; export const savedQueries = [ { query : `template` , variables : 's' } , { query : `template` , variables : 's' } , { query : `template` , variables : 's' } ] ;	O $any$ O O O O O $any$ O O O O O $complex$ O O O $any$ O O O $string$ O O O O O $any$ O O O $string$ O O O O O $any$ O O O $string$ O O O O O
'js' const webpack = require ( 's' ) ; const ExtractTextPlugin = require ( 's' ) ; const path = require ( 's' ) ; function root ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) ; return path . join . apply ( path , [ __dirname ] . concat ( args ) ) ; } module . exports = { devtool : 's' , performance : { hints : false } , devServer : { contentBase : root ( 's' ) , watchContentBase : true , port : 0 , stats : 's' } , resolve : { extensions : [ 's' , 's' , 's' , 's' ] } , entry : [ 's' ] , output : { path : root ( 's' ) , filename : 's' , sourceMapFilename : 's' } , module : { rules : [ { test : "s" , use : [ 's' ] } , { test : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : 's' } ) } , { test : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : 's' } ) } , { test : "s" , use : 's' } , { test : "s" , use : 's' } ] } , plugins : [ new ExtractTextPlugin ( { filename : 's' , allChunks : true } ) , new webpack . ProvidePlugin ( { "s" : "s" } ) ] }	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $IArguments$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $complex$ O $any$ O O O O $complex$ O $complex$ O O $string$ O O O $complex$ O O $boolean$ O O O O $complex$ O O $any$ O $any$ O O O O $boolean$ O O O $number$ O O O $string$ O O O O $complex$ O O $string[]$ O O O O O O O O O O O O $string[]$ O O O O O $complex$ O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string[]$ O O O O O O O $RegExp$ O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O O $RegExp$ O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $string$ O O O O O O $any[]$ O O O $any$ O O $string$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O O O O
import every from 's' ; import some from 's' ; import startsWith from 's' ; import endsWith from 's' ; import lt from 's' ; import lte from 's' ; import gt from 's' ; import gte from 's' ; import eq from 's' ; import map from 's' ; import keyBy from 's' ; import chunk from 's' ; import drop from 's' ; import dropRight from 's' ; import take from 's' ; import takeRight from 's' ; import flattenDepth from 's' ; import fromPairs from 's' ; import nth from 's' ; import reverse from 's' ; import uniq from 's' ; import uniqBy from 's' ; import countBy from 's' ; import filter from 's' ; import reject from 's' ; import groupBy from 's' ; import sortBy from 's' ; import minBy from 's' ; import maxBy from 's' ; import meanBy from 's' ; import sumBy from 's' ; import join from 's' ; import get from 's' ; import mapValues from 's' ; import at from 's' ; import toPairs from 's' ; import invert from 's' ; import invertBy from 's' ; import keys from 's' ; import values from 's' ; const transformations = { Array : { each : ( array , arg ) => { return map ( array , item => applyTransformations ( item , arg ) ) ; } , map , keyBy , chunk , drop , dropRight , take , takeRight , flattenDepth , fromPairs , nth , reverse , uniq , uniqBy , countBy , filter , reject , filterIf : ( array , arg ) => { return filter ( array , item => applyTransformations ( item , arg ) ) ; } , rejectIf : ( array , arg ) => { return reject ( array , item => applyTransformations ( item , arg ) ) ; } , groupBy , sortBy , minBy , maxBy , meanBy , sumBy , join , } , Object : { get , mapValues , at , toPairs , invert , invertBy , keys , values , } , Number : { lt , lte , gt , gte , eq , } , String : { startsWith , endsWith , } , } ; const opToExpectedType = { } ; for ( const type in transformations ) for ( const name in transformations [ type ] ) opToExpectedType [ name ] = type ; export function applyTransformations ( object , args ) { if ( ! args ) return object ; for ( const op in args ) { if ( object === null ) break ; const arg = args [ op ] ; if ( op === 's' ) { object = every ( arg , predicateArgs => applyTransformations ( object , predicateArgs ) ) ; continue ; } if ( op === 's' ) { object = some ( arg , predicateArgs => applyTransformations ( object , predicateArgs ) ) ; continue ; } const expectedType = opToExpectedType [ op ] ; let type = object . constructor && object . constructor . name ; if ( ! type && ( typeof object === 's' ) ) type = 's' ; if ( expectedType !== type ) throw Error ( `template` ) ; object = transformations [ type ] [ op ] ( object , arg ) ; } return object ; }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O O O O O O ${}$ O O O O O O O $string$ O O O O O O $string$ O O O $string$ O O ${}$ O $string$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O ${}$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O $ErrorConstructor$ O O O O $any$ O O O $any$ O O $string$ O O $any$ O $any$ O O O O $any$ O O
const lodashProps = `template` ; export const lodashIDL = `template` ;	O O O O O O O $string$ O O O
import { Source , Kind , parse , visit , print , DocumentNode , } from 's' ; import { GraphQLError } from 's' ; import { getOperationAST } from 's' ; import { concatAST } from 's' ; import { buildASTSchema } from 's' ; import { getArgumentValues , } from 's' ; import get from 's' ; import set from 's' ; import each from 's' ; import keyBy from 's' ; import isEqual from 's' ; import { applyTransformations } from 's' ; import { lodashIDL } from 's' ; export function graphqlLodash ( query : string | DocumentNode , operationName ? ) { const pathToArgs = { } ; const queryAST = typeof query === 's' ? parse ( query ) : query ; traverseOperationFields ( queryAST , operationName , ( node , resultPath ) => { var args = getLodashDirectiveArgs ( node ) ; if ( args === null ) return ; const argsSetPath = [ ... resultPath , 's' ] ; const previousArgsValue = get ( pathToArgs , argsSetPath , null ) ; if ( previousArgsValue !== null && ! isEqual ( previousArgsValue , args ) ) throw Error ( `template` ) ; set ( pathToArgs , argsSetPath , args ) ; } ) ; const stripedQuery = stripQuery ( queryAST ) ; return { query : typeof query === 's' ? print ( stripedQuery ) : stripedQuery , transform => applyLodashDirective ( pathToArgs , data ) } ; } function getLodashDirectiveArgs ( node ) { let lodashNode = null ; for ( let directive of node . directives || [ ] ) { if ( directive . name . value !== lodashDirectiveDef . name ) continue ; if ( lodashNode ) throw Error ( `template` ) ; lodashNode = directive ; } if ( lodashNode === null ) return null ; const args = getArgumentValues ( lodashDirectiveDef , lodashNode ) ; return normalizeLodashArgs ( lodashNode . arguments , args ) ; } function normalizeLodashArgs ( argNodes , args ) { if ( ! argNodes ) return args ; argNodes = keyBy ( argNodes , argNode => argNode . name . value ) ; const orderedArgs = { } ; each ( argNodes , ( node , name ) => { const argValue = args [ name ] ; if ( node . value . kind === 's' ) orderedArgs [ name ] = normalizeLodashArgs ( node . value . fields , argValue ) ; else if ( node . value . kind === 's' ) { const nodeValues = node . value . values ; orderedArgs [ name ] = [ ] ; for ( let i = 0 ; i < nodeValues . length ; ++ i ) orderedArgs [ name ] [ i ] = normalizeLodashArgs ( nodeValues [ i ] . fields , argValue [ i ] ) ; } else if ( node . value . kind === 's' && node . value . value === 's' ) orderedArgs [ name ] = undefined ; else orderedArgs [ name ] = argValue ; } ) ; return orderedArgs ; } function applyLodashDirective ( pathToArgs , data ) { if ( data === null ) return null ; const changedData = applyOnPath ( data , pathToArgs ) ; return applyLodashArgs ( [ ] , changedData , pathToArgs [ 's' ] ) ; } function applyLodashArgs ( path , object , args ) { try { return applyTransformations ( object , args ) ; } catch ( e ) { console . log ( path ) ; throw e ; } } function applyOnPath ( result , pathToArgs ) { const currentPath = [ ] ; return traverse ( result , pathToArgs ) ; function traverse ( root , pathRoot ) { if ( root === null || root === undefined ) return null ; if ( Array . isArray ( root ) ) return root . map ( item => traverse ( item , pathRoot ) ) ; if ( typeof root === 's' ) { const changedObject = Object . assign ( { } , root ) ; for ( const key in pathRoot ) { if ( key === 's' ) continue ; currentPath . push ( key ) ; let changedValue = traverse ( root [ key ] , pathRoot [ key ] ) ; if ( changedValue === null || changedValue === undefined ) continue ; const lodashArgs = pathRoot [ key ] [ 's' ] ; changedValue = applyLodashArgs ( currentPath , changedValue , lodashArgs ) ; changedObject [ key ] = changedValue ; currentPath . pop ( ) ; } return changedObject ; } else { return root ; } } } function stripQuery ( queryAST ) { return visit ( queryAST , { [ Kind . DIRECTIVE ] : ( node ) => { if ( node . name . value === 's' ) return null ; } , } ) ; } export const lodashDirectiveAST = parse ( new Source ( lodashIDL , 's' ) ) ; const lodashDirectiveDef = getDirectivesFromAST ( lodashDirectiveAST ) [ 0 ] ; function getDirectivesFromAST ( ast ) { const dummyIDL = `template` ; const fullAST = concatAST ( [ ast , parse ( dummyIDL ) ] ) ; const schema = buildASTSchema ( fullAST ) ; ( schema . getTypeMap ( ) [ 's' ] as any ) . parseLiteral = ( x => x . value ) ; ( schema . getTypeMap ( ) [ 's' ] as any ) . parseLiteral = astToJSON ; return schema . getDirectives ( ) ; } function astToJSON ( ast ) { switch ( ast . kind ) { case Kind . NULL : return null ; case Kind . INT : return parseInt ( ast . value , 0 ) ; case Kind . FLOAT : return parseFloat ( ast . value ) ; case Kind . STRING : case Kind . BOOLEAN : return ast . value ; case Kind . LIST : return ast . values . map ( astToJSON ) ; case Kind . OBJECT : return ast . fields . reduce ( ( object , { name , value } ) => { object [ name . value ] = astToJSON ( value ) ; return object ; } , { } ) ; } } function traverseOperationFields ( queryAST , operationName , cb ) { const fragments = { } ; const operationAST = getOperationAST ( queryAST , operationName ) ; if ( ! operationAST ) { throw new GraphQLError ( 's' ) ; } queryAST . definitions . forEach ( definition => { if ( definition . kind === Kind . FRAGMENT_DEFINITION ) fragments [ definition . name . value ] = definition ; } ) ; const resultPath = [ ] ; cb ( operationAST , resultPath ) ; traverse ( operationAST ) ; function traverse ( root ) { visit ( root , { enter ( node ) { if ( node . kind === Kind . FIELD ) resultPath . push ( ( node . alias || node . name ) . value ) ; if ( node . kind === Kind . FRAGMENT_SPREAD ) { const fragmentName = node . name . value ; const fragment = fragments [ fragmentName ] ; if ( ! fragment ) throw Error ( `template` ) ; traverse ( fragment ) ; } } , leave ( node ) { if ( node . kind !== Kind . FIELD ) return ; cb ( node , resultPath ) ; resultPath . pop ( ) ; } } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $complex$ O $any$ O O O $any$ O $string$ $string$ O O O ${}$ O O O O O $any$ O O $any$ O O O $any$ O $string$ O O $any$ O $void$ O $any$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any[]$ O O O $any$ O O O O O $any$ O $any$ O ${}$ O $any[]$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $ErrorConstructor$ O O O O $any$ O ${}$ O $any[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $data$ O $any$ O ${}$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ErrorConstructor$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O ${}$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O ${}$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O ${}$ O $any$ O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O O $number$ O ${}$ O $any$ O O $number$ O O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O ${}$ O $any$ O O $undefined$ O O ${}$ O $any$ O O $any$ O O O O O ${}$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $undefined$ O O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $ObjectConstructor$ O O O O O O $any$ O O O O O $string$ O $any$ O O O O $string$ O O O O O $any[]$ O $number$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $string$ O O O O O $any$ O O O $any$ O $undefined$ O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O $DocumentNode$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $DocumentNode$ O $any$ O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O $number$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O ${}$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O ${}$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any[]$ O O O O $any$ O $any$ O $any[]$ O O $void$ O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O ${}$ O $any$ O O O O O $any$ O O $ErrorConstructor$ O O O O $void$ O $any$ O O O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O O $any[]$ O $any$ O O O O O O O O O
'js' const webpack = require ( 's' ) ; const path = require ( 's' ) ; function root ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) ; return path . join . apply ( path , [ __dirname ] . concat ( args ) ) ; } module . exports = { devtool : 's' , performance : { hints : false } , resolve : { extensions : [ 's' , 's' , 's' , 's' ] } , entry : [ 's' ] , output : { path : root ( 's' ) , filename : 's' , sourceMapFilename : 's' , library : 's' , libraryTarget : 's' , umdNamedDefine : true } , module : { rules : [ { test : "s" , use : [ 's' ] } ] } }	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $IArguments$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $complex$ O $any$ O O O O $complex$ O $complex$ O O $string$ O O O $complex$ O O $boolean$ O O O O $complex$ O O $string[]$ O O O O O O O O O O O O $string[]$ O O O O O $complex$ O O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string[]$ O O O O O O O O