'js' module . exports = { extends : [ 's' , 's' , 's' ] , plugins : [ 's' , 's' ] , env : { browser : true , 0 : true , node : true , } , rules : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : [ 's' , { 's' : 's' } ] , 's' : [ 's' , { mustMatch : 's' , templateFile : require . resolve ( 's' ) , messages : { whenFailedToMatch : 's' , } , } , ] , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : [ 's' , { functions : false , classes : false } ] , } , overrides : [ { files : [ 's' ] , parser : 's' , } , { files : [ 's' ] , env : { jest : true , } , rules : { 's' : 's' , 's' : 's' , } , } , ] , } ;	O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O $boolean$ O O O O O O O $complex$ O O O $string[]$ O O O O O $string$ O O O O O O $string[]$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O O O O O O O O O O O O O O O O O
'js' module . exports = { extends : [ 's' , 's' ] , settings : { react : { version : 's' , } , } , parserOptions : { ecmaVersion : 0 , sourceType : 's' , ecmaFeatures : { jsx : true , } , } , rules : { 's' : 's' , } , overrides : [ { files : [ 's' ] , rules : { 's' : 's' , } , } , ] , } ;	O $complex$ O $complex$ O O $string[]$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O $complex$ O O $number$ O O O $string$ O O O $complex$ O O $boolean$ O O O O O O O $complex$ O O O O O O O O $complex$ O O O $string[]$ O O O O O $complex$ O O O O O O O O O O O O O O
'js' const fs = require ( 's' ) ; const path = require ( 's' ) ; const babelOptions = fs . readJsonSync ( path . join ( __dirname , 's' ) ) ; const transformer = require ( 's' ) ; const { createTransformer } = transformer ; const thisTransformer = createTransformer ( babelOptions ) ; Object . assign ( transformer , thisTransformer ) ; transformer . createTransformer = ( ) => { return thisTransformer } ; module . exports = transformer ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $ObjectConstructor$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O
'js' process . env . COVERALLS_GIT_BRANCH = process . env . BUILD_SOURCEBRANCHNAME ; process . env . COVERALLS_GIT_COMMIT = process . env . BUILD_SOURCEVERSION ; process . env . CI_PULL_REQUEST = process . env . SYSTEM_PULLREQUEST_PULLREQUESTID ;	O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O
'js' module . exports = { } ;	O $complex$ O $any$ O O O O
'js' module . exports = { } ;	O $complex$ O $any$ O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import { BotInfo , newBot } from 's' ; import { BotConfigWithPath , StartConversationParams , User } from 's' ; import { Action } from 's' ; export enum BotActionType { close = 's' , browse = 's' , hashGenerated = 's' , load = 's' , open = 's' , openViaUrl = 's' , openViaFilePath = 's' , restartConversation = 's' , setActive = 's' , setDirectory = 's' , } export interface BotAction < T = any > extends Action { type : BotActionType ; payload : T ; } export interface LoadBotPayload { bots : BotInfo [ ] ; } export interface SetActivePayload { bot : BotConfigWithPath ; } export interface SetDirectoryPayload { directory : string ; } export interface BotConfigWithPathPayload { bot : BotConfigWithPath ; } export interface BotInfosPayload { bots : BotInfo [ ] ; } export interface HashPayload { hash : string ; } export interface RestartConversationPayload { conversationId : string ; documentId : string ; user ? : User ; } export function load ( bots : BotInfo [ ] ) < LoadBotPayload > { bots = bots . filter ( bot => ! ! bot ) ; return { type : BotActionType . load , payload : { bots , } , } ; } export function setActive ( bot ) < SetActivePayload > { return { type : BotActionType . setActive , payload : { bot , } , } ; } export function setDirectory ( directory ) < SetDirectoryPayload > { return { type : BotActionType . setDirectory , payload : { directory , } , } ; } export function close ( ) < { } > { return { type : BotActionType . close , payload : { } , } ; } export function mockAndSetActive ( mock ? ) { const bot = newBot ( { version : 's' , name : 's' , description : 's' , services : [ ] , padlock : 's' , } , mock ) ; return setActive ( bot ) ; } export function botHashGenerated ( hash ) < HashPayload > { return { type : BotActionType . hashGenerated , payload : { hash } , } ; } export function browse ( ) < { } > { return { type : BotActionType . browse , payload : { } , } ; } export function closeBot ( ) < { } > { return { type : BotActionType . close , payload : { } , } ; } export function openBotViaFilePathAction ( path ) < string > { return { type : BotActionType . openViaFilePath , payload : path , } ; } export function openBotViaUrlAction ( startConversationParams < StartConversationParams > ) < Partial < StartConversationParams > > { return { type : BotActionType . openViaUrl , payload : startConversationParams , } ; } export function restartConversation ( conversationId , documentId ) < RestartConversationPayload > { return { type : BotActionType . restartConversation , payload : { conversationId , documentId } , } ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $BotActionType.close$ O O O $BotActionType.browse$ O O O $BotActionType.hashGenerated$ O O O $BotActionType.load$ O O O $BotActionType.open$ O O O $BotActionType.openViaUrl$ O O O $BotActionType.openViaFilePath$ O O O $BotActionType.restartConversation$ O O O $BotActionType.setActive$ O O O $BotActionType.setDirectory$ O O O O O O $any$ O $any$ O O O O $any$ O $BotActionType$ O $any$ O $T$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $any$ O O $any$ O O O O $BotAction$ O $any[]$ O $any$ O O O O $any$ O O $any[]$ O $any[]$ O $complex$ O $any$ O O O $any$ O O O O $BotActionType.load$ O $any$ O $BotActionType.load$ O $complex$ O O $any[]$ O O O O O O O O $BotAction$ O $BotConfigWithPath$ O O $any$ O O O O $BotActionType.setActive$ O $any$ O $BotActionType.setActive$ O $complex$ O O $any$ O O O O O O O O $BotAction$ O $string$ O O $any$ O O O O $BotActionType.setDirectory$ O $any$ O $BotActionType.setDirectory$ O $complex$ O O $string$ O O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.close$ O $any$ O $BotActionType.close$ O ${}$ O O O O O O O O O $BotAction$ O $any$ $BotConfigWithPath$ O O O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O $any$ O O O $BotAction<SetActivePayload>$ O $any$ O O O O O $BotAction$ O $string$ O O $any$ O O O O $BotActionType.hashGenerated$ O $any$ O $BotActionType.hashGenerated$ O $complex$ O O $string$ O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.browse$ O $any$ O $BotActionType.browse$ O ${}$ O O O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.close$ O $any$ O $BotActionType.close$ O ${}$ O O O O O O O O O $BotAction$ O $string$ O O O O O O O $BotActionType.openViaFilePath$ O $any$ O $BotActionType.openViaFilePath$ O $string$ O $string$ O O O O O O $BotAction$ O $Partial$ O $any$ O O O $any$ O $any$ O O O O O $BotActionType.openViaUrl$ O $any$ O $BotActionType.openViaUrl$ O $any$ O $any$ O O O O O O $BotAction$ O $string$ O $string$ O O $any$ O O O O $BotActionType.restartConversation$ O $any$ O $BotActionType.restartConversation$ O $complex$ O O $string$ O $string$ O O O O O
import { BotInfo } from 's' ; import { applyBotConfigOverrides , BotConfigWithPath , botsAreTheSame } from 's' ; import { BotAction , BotActionType } from 's' ; export interface BotState { activeBot : BotConfigWithPath ; activeBotDigest : string ; botFiles : BotInfo [ ] ; currentBotDirectory : string ; } const DEFAULT_STATE = { activeBot : null , activeBotDigest : null , botFiles : [ ] , currentBotDirectory : 's' , } ; export const bot = ( state = DEFAULT_STATE , action ) : BotState => { switch ( action . type ) { case BotActionType . hashGenerated : return { ... state , activeBotDigest : action . payload . hash } ; case BotActionType . load : { state = setBotFilesState ( action . payload . bots , state ) ; break ; } case BotActionType . setActive : { const mostRecentBot = state . botFiles . find ( 0 => 0 && 0 . path === action . payload . bot . path ) ; const recentBots = state . botFiles . filter ( 0 => 0 && 0 . path !== action . payload . bot . path ) ; if ( mostRecentBot ) { recentBots . unshift ( mostRecentBot ) ; } let newActiveBot = action . payload . bot ; if ( botsAreTheSame ( state . activeBot , newActiveBot ) ) { newActiveBot = applyBotConfigOverrides ( newActiveBot , state . activeBot . overrides ) ; } state = setBotFilesState ( recentBots , state ) ; state = setActiveBot ( newActiveBot , state ) ; break ; } case BotActionType . setDirectory : { state = setCurrentBotDirectory ( action . payload . directory , state ) ; break ; } case BotActionType . close : { state = setActiveBot ( null , state ) ; break ; } default : break ; } return state ; } ; function setActiveBot ( 0 , state ) { return { ... state , get activeBot ( ) { return JSON . parse ( JSON . stringify ( 0 ) ) ; } , } ; } function setBotFilesState ( botFilesState : BotInfo [ ] , state ) { const newState = { ... state } ; newState . botFiles = botFilesState ; return newState ; } function setCurrentBotDirectory ( botDirectory , state ) { const newState = { ... state } ; newState . currentBotDirectory = botDirectory ; return newState ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O $any[]$ O $any$ O O O $string$ O O O O O $BotState$ O O $null$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O O $BotState$ O O $BotState$ O $BotState$ O $BotAction$ O O $any$ O O O O $BotAction<any>$ O $BotActionType$ O O O $any$ O $BotActionType.hashGenerated$ O O O O $BotState$ O $any$ O $BotAction<any>$ O $any$ O $any$ O O O $any$ O $BotActionType.load$ O O $BotState$ O $BotState$ O $BotAction<any>$ O $any$ O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.setActive$ O O O $any$ O $BotState$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O $any$ O $any$ O O O $any[]$ O $BotState$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O $any$ O $any$ O O O O $any$ O O $any[]$ O $number$ O $any$ O O O O $any$ O $BotAction<any>$ O $any$ O $any$ O O O $any$ O $BotState$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $BotState$ O $any$ O $any$ O O O $BotState$ O $BotState$ O $any[]$ O $BotState$ O O $BotState$ O O O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.setDirectory$ O O $BotState$ O $BotState$ O $BotAction<any>$ O $any$ O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.close$ O O $BotState$ O O O O O $BotState$ O O O O O O O O O O O $BotState$ O O O O $BotState$ O $BotConfigWithPath$ O $BotState$ O O O O O $BotState$ O O $any$ O O O O $JSON$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O O O O O $BotState$ O $any[]$ O $any$ O O O $BotState$ O O O $complex$ O O O $BotState$ O O $complex$ O $any[]$ O $any[]$ O O $complex$ O O O $BotState$ O $string$ O $BotState$ O O O $complex$ O O O $BotState$ O O $complex$ O $string$ O $string$ O O $complex$ O O
import { IFileService } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; export const TRANSCRIPTS_UPDATED = 's' ; export const TRANSCRIPTS_DIRECTORY_UPDATED = 's' ; export const CHAT_FILES_UPDATED = 's' ; export const CHATS_DIRECTORY_UPDATED = 's' ; export const OPEN_CONTEXT_MENU_FOR_RESOURCE = 's' ; export const EDIT_RESOURCE = 's' ; export const RENAME_RESOURCE = 's' ; export const OPEN_RESOURCE = 's' ; export const OPEN_RESOURCE_SETTINGS = 's' ; export interface ResourcesAction < T > extends Action { payload : T ; } export function transcriptsUpdated ( payload : IFileService [ ] ) < IFileService [ ] > { return { type : TRANSCRIPTS_UPDATED , payload , } ; } export function transcriptDirectoryUpdated ( payload ) < string > { return { type : TRANSCRIPTS_DIRECTORY_UPDATED , payload , } ; } export function chatsDirectoryUpdated ( payload ) < string > { return { type : CHATS_DIRECTORY_UPDATED , payload , } ; } export function chatFilesUpdated ( payload : IFileService [ ] ) < IFileService [ ] > { return { type : CHAT_FILES_UPDATED , payload , } ; } export function openContextMenuForResource ( payload ) < IFileService > { return { type : OPEN_CONTEXT_MENU_FOR_RESOURCE , payload , } ; } export function editResource ( payload ) < IFileService > { return { type : EDIT_RESOURCE , payload , } ; } export function renameResource ( payload ) < IFileService > { return { type : RENAME_RESOURCE , payload , } ; } export function openResource ( payload ) < IFileService > { return { type : OPEN_RESOURCE , payload , } ; } declare interface ResourceSettingsPayload { dialog : ComponentClass < any > ; } export function openResourcesSettings ( payload ) < ResourceSettingsPayload > { return { type : OPEN_RESOURCE_SETTINGS , payload , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $ResourcesAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O $string$ O O O $any[]$ O O O O O O $ResourcesAction$ O $string$ O O O O O O O $string$ O O O $string$ O O O O O O $ResourcesAction$ O $string$ O O O O O O O $string$ O O O $string$ O O O O O O $ResourcesAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O $string$ O O O $any[]$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $ResourcesAction$ O $ResourceSettingsPayload$ O O $any$ O O O O $string$ O O O $ResourceSettingsPayload$ O O O O
import { IFileService } from 's' ; import { CHAT_FILES_UPDATED , CHATS_DIRECTORY_UPDATED , EDIT_RESOURCE , ResourcesAction , TRANSCRIPTS_DIRECTORY_UPDATED , TRANSCRIPTS_UPDATED , } from 's' ; export interface ResourcesState { transcripts : IFileService [ ] ; transcriptsPath : string ; chats : IFileService [ ] ; chatsPath : string ; resourceToRename : IFileService ; } const initialState = { transcripts : [ ] , transcriptsPath : 's' , chats : [ ] , chatsPath : 's' , resourceToRename : null , } ; declare type ResourceActionType = ResourcesAction < IFileService | IFileService [ ] | string > ; export function resources ( state = initialState , action ) { switch ( action . type ) { case TRANSCRIPTS_UPDATED : return { ... state , transcripts : action . payload as IFileService [ ] } ; case TRANSCRIPTS_DIRECTORY_UPDATED : return { ... state , transcriptsPath : action . payload as string } ; case CHAT_FILES_UPDATED : return { ... state , chats : action . payload as IFileService [ ] } ; case CHATS_DIRECTORY_UPDATED : return { ... state , chatsPath : action . payload as string } ; case EDIT_RESOURCE : return { ... state , resourceToRename : action . payload as IFileService } ; default : return state ; } }	O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any[]$ O $any$ O O O $string$ O O O $any[]$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $ResourcesState$ O O $undefined[]$ O O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $ResourcesState$ O $ResourcesState$ O $ResourcesState$ O $ResourceActionType$ O O O O $ResourcesAction<any>$ O $any$ O O O O O O O O $ResourcesState$ O $any[]$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O O O O O O $ResourcesState$ O $string$ O $ResourcesAction<any>$ O $any$ O O O O O O O O O O $ResourcesState$ O $any[]$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O O O O O O $ResourcesState$ O $string$ O $ResourcesAction<any>$ O $any$ O O O O O O O O O O $ResourcesState$ O $any$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O $ResourcesState$ O O O
import { SharedConstants } from 's' ; export const CONTENT_TYPE_DEBUG = 's' ; export const CONTENT_TYPE_MARKDOWN = 's' ; export const CONTENT_TYPE_APP_SETTINGS = 's' ; export const CONTENT_TYPE_WELCOME_PAGE = 's' ; export const CONTENT_TYPE_TRANSCRIPT = 's' ; export const CONTENT_TYPE_LIVE_CHAT = SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT ; export const NAVBAR_BOT_EXPLORER = 's' ; export const NAVBAR_SETTINGS = 's' ; export const NAVBAR_NOTIFICATIONS = 's' ; export const NAVBAR_RESOURCES = 's' ; export const EDITOR_KEY_PRIMARY = 's' ; export const EDITOR_KEY_SECONDARY = 's' ; export const EditorKeys = [ EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY ] ; export const DOCUMENT_ID_APP_SETTINGS = 's' ; export const DOCUMENT_ID_BOT_SETTINGS = 's' ; export const DOCUMENT_ID_WELCOME_PAGE = 's' ; export const DOCUMENT_ID_MARKDOWN_PAGE = 's' ;	O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Middleware } from 's' ; import { ipcRenderer } from 's' ; export const forwardToMain = _store => next => action => { if ( ! action . type ) { return next ( action ) ; } if ( ( action as any ) . meta && ( action as any ) . meta . doNotForward ) { return next ( action ) ; } ipcRenderer . sendSync ( 's' , action ) ; return next ( action ) ; } ;	O O $any$ O O O O O O $any$ O O O O O O $Middleware$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O
let singleton ; class AriaAlertService { constructor ( ) { singleton = this ; } public alert ( msg ) { if ( ! msg ) { return ; } const prevAlert = document . querySelector ( 's' ) ; prevAlert && prevAlert . remove ( ) ; const alert = document . createElement ( 's' ) ; alert . innerText = msg ; alert . setAttribute ( 's' , 's' ) ; alert . setAttribute ( 's' , 's' ) ; alert . setAttribute ( 's' , 's' ) ; document . body . appendChild ( alert ) ; } } export const ariaAlertService = singleton || new AriaAlertService ( ) ;	O $AriaAlertService$ O O $any$ O O O O O $AriaAlertService$ O O O O O $void$ O $string$ O O O O O $string$ O O O O O O $Element$ O $Document$ O O O O O O $Element$ O $Element$ O $void$ O O O O $HTMLSpanElement$ O $Document$ O O O O O O $HTMLSpanElement$ O $string$ O $string$ O $HTMLSpanElement$ O $void$ O O O O O O $HTMLSpanElement$ O $void$ O O O O O O $HTMLSpanElement$ O $void$ O O O O O O $Document$ O $HTMLElement$ O $T$ O $HTMLSpanElement$ O O O O O O $AriaAlertService$ O $AriaAlertService$ O O $any$ O O O
export * from 's' ;	O O O O O
import { connect } from 's' ; import { ariaAlertService } from 's' ; import { BotCreationDialog , BotCreationDialogProps } from 's' ; const mapDispatchToProps = ( _dispatch ) : BotCreationDialogProps => { return { createAriaAlert : ( msg ) => { ariaAlertService . alert ( msg ) ; } , } ; } ; export const BotCreationDialogContainer = connect ( undefined , mapDispatchToProps ) ( BotCreationDialog ) ;	O O $any$ O O O O O O $AriaAlertService$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O $void$ O O $string$ O O O $AriaAlertService$ O $void$ O $string$ O O O O O O O O O O $any$ O $any$ O $undefined$ O $any$ O O $any$ O O
import { connect } from 's' ; import { RootState } from 's' ; import { DialogHost , DialogHostProps } from 's' ; function mapStateToProps ( state ) { return { showing : state . dialog . showing } ; } export const DialogHostContainer = connect ( mapStateToProps ) ( DialogHost ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $DialogHostProps$ O $RootState$ O O O O $boolean$ O $RootState$ O $DialogState$ O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any$ O O
export enum DialogActions { setShowing = 's' , } export interface SetShowingDialogAction { type : DialogActions . setShowing ; payload : { showing : boolean ; } ; } export type DialogAction = SetShowingDialogAction ; export function setShowing ( showing = false ) { return { type : DialogActions . setShowing , payload : { showing , } , } ; }	O O $any$ O $DialogActions.setShowing$ O O O O O O $any$ O $DialogActions$ O $any$ O $DialogActions.setShowing$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $any$ O O O $SetShowingDialogAction$ O $boolean$ O O O O O O $DialogActions.setShowing$ O $any$ O $DialogActions.setShowing$ O $complex$ O O $boolean$ O O O O O O
import * as React from 's' ; import { ComponentClass , StatelessComponent } from 's' ; import * as ReactDOM from 's' ; import { Provider } from 's' ; import * as DialogActions from 's' ; import { store } from 's' ; export interface DialogService { showDialog ( dialog : ComponentClass < any > | StatelessComponent < any > , props : { [ propName ] : any } ) : any ; hideDialog ( ) : any ; setHost ( hostElement ) : void ; } class DialogServiceImpl implements DialogService { private _hostElement : HTMLElement ; private _resolve : ( value ? ) => void ; showDialog < T extends ComponentClass | StatelessComponent , R = any > ( dialog : T , props : { } = { } ) < R > { if ( ! this . _hostElement ) { return new Promise ( resolve => resolve ( null ) ) ; } const reactElement = React . createElement ( Provider , { store } , React . createElement ( dialog , props ) ) ; ReactDOM . render ( reactElement , this . _hostElement , this . notifyHostOfRender ) ; store . dispatch ( DialogActions . setShowing ( true ) ) ; return new Promise ( resolve => { this . _resolve = resolve ; } ) ; } hideDialog ( dialogReturnValue ? ) { if ( ! this . _hostElement || ! this . _resolve ) { return ; } ReactDOM . render ( null , this . _hostElement ) ; store . dispatch ( DialogActions . setShowing ( false ) ) ; this . _resolve ( dialogReturnValue ) ; this . _resolve = null ; } setHost ( hostElement ) { this . _hostElement = hostElement ; } private notifyHostOfRender = ( ) : void => { if ( this . _hostElement ) { this . _hostElement . dispatchEvent ( new Event ( 's' ) ) ; } } ; } export const DialogService = new DialogServiceImpl ( ) ;	O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $DialogServiceImpl$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $complex$ O O O $string$ O O O O O O O O $any$ O O O O O $void$ O $HTMLElement$ O O O O O O $any$ O $DialogServiceImpl$ O O $HTMLElement$ O $complex$ O O $void$ O O $any$ $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O O O O $T$ O $any$ O ${}$ O O O O O O O O $any$ O O O O O O O $HTMLElement$ O O O O $PromiseConstructor$ O $void$ O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $T$ O ${}$ O O O $any$ O $any$ O $any$ O O O $HTMLElement$ O O O $void$ O O $any$ O $any$ O $any$ O $SetShowingDialogAction$ O O O O O O O $PromiseConstructor$ O $void$ O O O O $void$ O $void$ O O O O O $void$ O $any$ $any$ O O O O O O O $HTMLElement$ O O O O $void$ O O O O O $any$ O $any$ O O O O O $HTMLElement$ O O $any$ O $any$ O $any$ O $SetShowingDialogAction$ O O O O O O O $void$ O $any$ O O O O $void$ O O O O $void$ O $HTMLElement$ O O O O $HTMLElement$ O $HTMLElement$ O O O $void$ O O O O O O O O O O O $HTMLElement$ O O O O $HTMLElement$ O $boolean$ O O $complex$ O O O O O O O O O O O $DialogServiceImpl$ O O $any$ O O O
export * from 's' ;	O O O O O
import { Action } from 's' ; export const EXECUTE_COMMAND = 's' ; export interface CommandAction < T > extends Action { payload : T ; } export interface CommandActionPayload { isRemote : boolean ; commandName : string ; args : any [ ] ; resolver ? : Function ; } export function executeCommand ( isRemote , commandName , resolver = null , ... args : any [ ] ) < CommandActionPayload > { return { type : EXECUTE_COMMAND , payload : { isRemote , commandName , resolver , args } , } ; }	O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $boolean$ O O O $string$ O O O $any[]$ O O O O O $Function$ O O $FunctionConstructor$ O O O O $CommandAction$ O $boolean$ O $any$ O $Function$ O O O O $any[]$ O O O O O O $any$ O O O O $string$ O O O $complex$ O O $boolean$ O $any$ O $Function$ O $any[]$ O O O O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { SecretPromptDialog , SecretPromptDialogProps } from 's' ; function mapDispatchToProps ( dispatch : ( action ) => void ) { return { onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , onCancelClick : ( ) => DialogService . hideDialog ( null ) , onSaveClick : ( newSecret ) => DialogService . hideDialog ( newSecret ) , } ; } export const SecretPromptDialogContainer = connect ( undefined , mapDispatchToProps ) ( SecretPromptDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $SecretPromptDialogProps$ O $void$ O O $Action$ O O O O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $string$ O O $DialogServiceImpl$ O $void$ O $string$ O O O O O O O $any$ O $any$ O $undefined$ O $any$ O O $any$ O O
import { connect } from 's' ; import * as EditorActions from 's' ; import { RootState } from 's' ; import { TabManager , TabManagerProps } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) : TabManagerProps => ( { recentTabs : state . editor . editors [ state . editor . activeEditor ] . recentTabs , window , ... ownProps , } ) ; const mapDispatchToProps = ( dispatch ) : TabManagerProps => ( { setActiveTab : ( tab ) => { dispatch ( EditorActions . setActiveTab ( tab ) ) ; } , } ) ; export const TabManagerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( TabManager ) as any ;	O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $complex$ O O O $string$ O O O O O O $any$ O O O $string[]$ O $RootState$ O $EditorState<any>$ O $complex$ O $RootState$ O $EditorState<any>$ O $string$ O O $string[]$ O $complex$ O O $complex$ O O O O O $any$ O O $any$ O O $any$ O O O $void$ O O $string$ O O O $any$ O $any$ O $SetActiveTabAction$ O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O
import { connect } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { AzureLoginSuccessDialog , AzureLoginSuccessDialogProps } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) : AzureLoginSuccessDialogProps => { const { persistLogin } = state . azureAuth ; return { persistLogin , ... ownProps , } ; } ; const mapDispatchToProps = ( _dispatch : ( ) => void ) : AzureLoginSuccessDialogProps => { return { cancel => DialogService . hideDialog ( persistLogin ) , } ; } ; export const AzureLoginSuccessDialogContainer = connect ( mapStateToProps , mapDispatchToProps ) ( AzureLoginSuccessDialog as any ) as any ;	O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $complex$ O O O $string$ O O O O O O $any$ O O O O $boolean$ O O $RootState$ O $AzureAuthState$ O O O $boolean$ O O $complex$ O O O O O O $any$ O O $void$ O O O O O O O $any$ O O O O $persistLogin$ O $DialogServiceImpl$ O $void$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { DialogService } from 's' ; import { store } from 's' ; import { executeCommand } from 's' ; import { AzureLoginPromptDialog , AzureLoginPromptDialogProps } from 's' ; const mapDispatchToProps = ( _dispatch : ( ) => void ) : AzureLoginPromptDialogProps => { return { cancel : ( ) => DialogService . hideDialog ( 0 ) , confirm : ( ) => DialogService . hideDialog ( 0 ) , onAnchorClick : ( url ) => { store . dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } ; export const AzureLoginPromptDialogContainer = connect ( null , mapDispatchToProps ) ( AzureLoginPromptDialog as any ) as any ;	O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O O O $any$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $string$ O O O $any$ O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O
import { connect } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { AzureLoginFailedDialog } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) => { return { ... ownProps , } ; } ; const mapDispatchToProps = ( _dispatch : ( ) => void ) => { return { cancel => DialogService . hideDialog ( persistLogin ) , } ; } ; export const AzureLoginFailedDialogContainer = connect ( mapStateToProps , mapDispatchToProps ) ( AzureLoginFailedDialog as any ) as any ;	O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O O O O O $complex$ O O $RootState$ O $complex$ O O O $string$ O O O O O O O O O O $complex$ O O O O O O $complex$ O O $void$ O O O O O O O O O O $persistLogin$ O $DialogServiceImpl$ O $void$ O $any$ O O O O O O O O $any$ O $any$ O $complex$ O $complex$ O O $any$ O O O O O O
import { connect } from 's' ; import { SharedConstants } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { ConnectServicePromptDialog , ConnectServicePromptDialogProps } from 's' ; const mapDispatchToProps = dispatch => ( _dispatch : ( ) => void , ownProps : { [ propName ] : any } ) : ConnectServicePromptDialogProps => { return { ... ownProps , cancel : ( ) => DialogService . hideDialog ( 0 ) , confirm : ( ) => DialogService . hideDialog ( 0 ) , addServiceManually : ( ) => { DialogService . hideDialog ( 0 ) ; } , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } ; export const ConnectServicePromptDialogContainer = connect ( null , mapDispatchToProps ) ( ConnectServicePromptDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $void$ O O O O O O $complex$ O O O $string$ O O O O O O $any$ O O O O O $complex$ O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O O $DialogServiceImpl$ O $void$ O O O O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { DataCollectionDialog , DataCollectionDialogProps } from 's' ; function mapDispatchToProps ( dispatch : ( action ) => void ) { return { hideDialog : ( collectData ) => { DialogService . hideDialog ( collectData ) ; } , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } export const DataCollectionDialogContainer = connect ( null , mapDispatchToProps ) ( DataCollectionDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $DataCollectionDialogProps$ O $void$ O O $Action$ O O O O O O O $void$ O O $boolean$ O O O $DialogServiceImpl$ O $void$ O $boolean$ O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { GetStartedWithCSDialog , GetStartedWithCSDialogProps } from 's' ; const mapStateToProps = ( state , ownProps ) => { const { access_token : token = 's' } = state . azureAuth ; const [ , payload ] = token . split ( 's' ) ; const pJson = JSON . parse ( atob ( payload ) ) ; return { ... ownProps , user : pJson . upn || pJson . unique_name || pJson . name || pJson . email , } ; } ; const mapDispatchToProps = ( dispatch : ( action ) => void ) : GetStartedWithCSDialogProps => ( { cancel : ( ) => DialogService . hideDialog ( 0 ) , confirm : ( ) => DialogService . hideDialog ( 0 ) , launchConnectedServiceEditor : ( ) => { DialogService . hideDialog ( 0 ) ; } , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ) ; export const GetStartedWithCSDialogContainer = connect ( mapStateToProps , mapDispatchToProps ) ( GetStartedWithCSDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $any$ O O O O O $string$ O $string$ O O O O $RootState$ O $AzureAuthState$ O O O O $string$ O O $string$ O $complex$ O O O O O $any$ O $JSON$ O $any$ O $complex$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $void$ O O $Action$ O O O O O $any$ O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O O $DialogServiceImpl$ O $void$ O O O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { PostMigrationDialog , PostMigrationDialogProps } from 's' ; const mapStateToProps = ( ownProps ) => ownProps ; function mapDispatchToProps ( dispatch : ( action ) => void ) { return { close : ( ) => { DialogService . hideDialog ( ) ; } , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } export const PostMigrationDialogContainer = connect ( mapStateToProps , mapDispatchToProps ) ( PostMigrationDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $PostMigrationDialogProps$ O O $any$ O O $PostMigrationDialogProps$ O $void$ O O $Action$ O O O O O O O $void$ O O O O O $DialogServiceImpl$ O $void$ O O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { Action } from 's' ; export const UPDATE_PROGRESS_INDICATOR = 's' ; export const CANCEL_CURRENT_PROCESS = 's' ; export interface ProgressIndicatorAction < T > extends Action { payload : T ; } export interface ProgressIndicatorPayload { label : string ; progress : number ; } export function updateProgressIndicator ( { label , progress , } ) < ProgressIndicatorPayload > { return { type : UPDATE_PROGRESS_INDICATOR , payload : { label , progress } , } ; } export function cancelCurrentProcess ( ) < void > { return { type : CANCEL_CURRENT_PROCESS , payload : void 0 , } ; }	O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O $number$ O O O O O O $ProgressIndicatorAction$ O O $string$ O $number$ O $ProgressIndicatorPayload$ O O $any$ O O O O $string$ O O O $complex$ O O $string$ O $number$ O O O O O O O $ProgressIndicatorAction$ O O O O O O O O $string$ O O O $undefined$ O O O O O O O
import { connect } from 's' ; import { Action } from 's' ; import { cancelCurrentProcess } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { ProgressIndicator } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) => { const { progressIndicator } = state ; return { ... ownProps , ... progressIndicator , } ; } ; const mapDispatchToProps = ( dispatch : ( action ) => void ) => { return { cancel : ( ) => DialogService . hideDialog ( dispatch ( cancelCurrentProcess ( ) ) ) , close : ( ) => DialogService . hideDialog ( ) , } ; } ; export const ProgressIndicatorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( ProgressIndicator ) ;	O O $any$ O O O O O O $any$ O O O O O O $ProgressIndicatorAction<void>$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O O O O O $complex$ O O $RootState$ O $complex$ O O O $string$ O O O O O O O O O $ProgressIndicatorState$ O O $RootState$ O O O O $complex$ O O $ProgressIndicatorState$ O O O O O O $complex$ O O $void$ O O $Action$ O O O O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O $void$ O $ProgressIndicatorAction<void>$ O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O O O O O O $any$ O $any$ O $complex$ O $complex$ O O $any$ O O
import { Notification } from 's' ; export enum NotificationActions { beginAdd = 's' , finishAdd = 's' , beginRemove = 's' , finishRemove = 's' , markAllAsRead = 's' , beginClear = 's' , finishClear = 's' , } export type NotificationAction = | BeginAddNotificationAction | FinishAddNotificationAction | BeginRemoveNotificationAction | FinishRemoveNotificationAction | MarkAllAsReadNotificationAction | BeginClearNotificationAction | FinishClearNotificationAction ; export interface BeginAddNotificationAction { type : NotificationActions . beginAdd ; payload : { notification : Notification ; read : boolean ; } ; } export interface FinishAddNotificationAction { type : NotificationActions . finishAdd ; payload : { notification : Notification ; } ; } export interface BeginRemoveNotificationAction { type : NotificationActions . beginRemove ; payload : { id : string ; } ; } export interface FinishRemoveNotificationAction { type : NotificationActions . finishRemove ; payload : { id : string ; } ; } export interface MarkAllAsReadNotificationAction { type : NotificationActions . markAllAsRead ; payload : { } ; } export interface BeginClearNotificationAction { type : NotificationActions . beginClear ; payload : { } ; } export interface FinishClearNotificationAction { type : NotificationActions . finishClear ; payload : { } ; } export function beginAdd ( notification , read = false ) { return { type : NotificationActions . beginAdd , payload : { notification , read , } , } ; } export function finishAdd ( notification ) { return { type : NotificationActions . finishAdd , payload : { notification , } , } ; } export function beginRemove ( id ) { return { type : NotificationActions . beginRemove , payload : { id , } , } ; } export function finishRemove ( id ) { return { type : NotificationActions . finishRemove , payload : { id , } , } ; } export function markAllAsRead ( ) { return { type : NotificationActions . markAllAsRead , payload : { } , } ; } export function beginClear ( ) { return { type : NotificationActions . beginClear , payload : { } , } ; } export function finishClear ( ) { return { type : NotificationActions . finishClear , payload : { } , } ; }	O O $any$ O O O O O O $any$ O $NotificationActions.beginAdd$ O O O $NotificationActions.finishAdd$ O O O $NotificationActions.beginRemove$ O O O $NotificationActions.finishRemove$ O O O $NotificationActions.markAllAsRead$ O O O $NotificationActions.beginClear$ O O O $NotificationActions.finishClear$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $NotificationActions.beginAdd$ O $any$ O $NotificationActions.beginAdd$ O $complex$ O O $any$ O $any$ O $boolean$ O O O O O O O O $any$ O $NotificationActions.finishAdd$ O $any$ O $NotificationActions.finishAdd$ O $complex$ O O $any$ O $any$ O O O O O O $any$ O $NotificationActions.beginRemove$ O $any$ O $NotificationActions.beginRemove$ O $complex$ O O $string$ O O O O O O O O $any$ O $NotificationActions.finishRemove$ O $any$ O $NotificationActions.finishRemove$ O $complex$ O O $string$ O O O O O O O O $any$ O $NotificationActions.markAllAsRead$ O $any$ O $NotificationActions.markAllAsRead$ O ${}$ O O O O O O O $any$ O $NotificationActions.beginClear$ O $any$ O $NotificationActions.beginClear$ O ${}$ O O O O O O O $any$ O $NotificationActions.finishClear$ O $any$ O $NotificationActions.finishClear$ O ${}$ O O O O O O O $BeginAddNotificationAction$ O $Notification$ O $boolean$ O O O O O O $NotificationActions.beginAdd$ O $any$ O $NotificationActions.beginAdd$ O $complex$ O O $any$ O $boolean$ O O O O O O O O $FinishAddNotificationAction$ O $Notification$ O O O O $NotificationActions.finishAdd$ O $any$ O $NotificationActions.finishAdd$ O $complex$ O O $any$ O O O O O O O O $BeginRemoveNotificationAction$ O $string$ O O O O $NotificationActions.beginRemove$ O $any$ O $NotificationActions.beginRemove$ O $complex$ O O $string$ O O O O O O O O $FinishRemoveNotificationAction$ O $string$ O O O O $NotificationActions.finishRemove$ O $any$ O $NotificationActions.finishRemove$ O $complex$ O O $string$ O O O O O O O O $MarkAllAsReadNotificationAction$ O O O O O $NotificationActions.markAllAsRead$ O $any$ O $NotificationActions.markAllAsRead$ O ${}$ O O O O O O O O O $BeginClearNotificationAction$ O O O O O $NotificationActions.beginClear$ O $any$ O $NotificationActions.beginClear$ O ${}$ O O O O O O O O O $FinishClearNotificationAction$ O O O O O $NotificationActions.finishClear$ O $any$ O $NotificationActions.finishClear$ O ${}$ O O O O O O O
import { SharedConstants } from 's' ; import { BotConfigWithPathImpl } from 's' ; import { connect } from 's' ; import { beginAdd } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { BotSettingsEditor , BotSettingsEditorProps } from 's' ; const mapStateToProps = ( state , ownProps : { } ) : Partial < BotSettingsEditorProps > => { return { window , bot : BotConfigWithPathImpl . fromJSON ( state . bot . activeBot ) , ... ownProps , } ; } ; const mapDispatchToProps = dispatch => ( { cancel : ( ) => DialogService . hideDialog ( 0 ) , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , sendNotification => dispatch ( beginAdd ( notification ) ) , } ) ; export const BotSettingsEditorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( BotSettingsEditor ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O ${}$ O O O O O $any$ O $any$ O O O O O $complex$ O $any$ O $any$ O $any$ O $RootState$ O $BotState$ O $any$ O O O ${}$ O O O O O O $complex$ O $any$ O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $notification$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O O
import { BotInfo } from 's' ; import { BotConfigWithPath } from 's' ; import { store } from 's' ; export function getActiveBot ( ) { return store . getState ( ) . bot . activeBot ; } const encoder = new ( window as any ) . TextEncoder ( ) ; const decoder = new ( window as any ) . TextDecoder ( ) ; export const generateHash = async ( obj : { [ key ] : any } ) : Promise < string > => { const buffer = encoder . encode ( JSON . stringify ( obj ) ) ; const digest = await window . crypto . subtle . digest ( 's' , buffer ) ; return btoa ( encoder . encode ( decoder . decode ( digest ) ) ) ; } ; export function getBotInfoByPath ( path ) { const state = store . getState ( ) ; const result = state . bot . botFiles . find ( bot => bot && bot . path === path ) ; if ( result ) { return { ... result } ; } return result ; } export function pathExistsInRecentBots ( path ) { const state = store . getState ( ) ; return state . bot . botFiles . some ( bot => bot && bot . path === path ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BotConfigWithPath$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $complex$ O O O O $any$ O O O O $any$ O O O $complex$ O O O O $any$ O O O O O $Promise<string>$ O O O $complex$ O O O $string$ O O O O O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O $JSON$ O $complex$ O $complex$ O O O O $ArrayBuffer$ O O $complex$ O $Crypto$ O $SubtleCrypto$ O O O O O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O $ArrayBuffer$ O O O O O O O O $BotInfo$ O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O
import { BotInfo , SharedConstants } from 's' ; import { connect } from 's' ; import { getBotInfoByPath } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { ResourcesSettings , ResourcesSettingsProps } from 's' ; const mapStateToProps = ( state , ownProps ) => { const { path } = state . bot . activeBot ; const botInfo = getBotInfoByPath ( path ) ; const { transcriptsPath , chatsPath } = botInfo ; return { transcriptsPath , chatsPath , path , ... ownProps } ; } ; const mapDispatchToProps = dispatch => ( { save : ( settings < BotInfo > ) => DialogService . hideDialog ( settings ) , showOpenDialog : ( ) => new Promise ( resolve => dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . ShowOpenDialog , resolve , { properties : [ 's' ] , } ) ) ) , cancel : ( ) => DialogService . hideDialog ( 0 ) , } ) ; export const ResourcesSettingsContainer = connect ( mapStateToProps , mapDispatchToProps ) ( ResourcesSettings ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $ResourcesSettingsProps$ O O O O O $any$ O O $RootState$ O $BotState$ O $any$ O O $BotInfo$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $complex$ O $any$ O O O $void$ O O $Partial$ O $any$ O O O $DialogServiceImpl$ O $void$ O $any$ O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O $string[]$ O O O O O O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O O
import { connect } from 's' ; import { DialogService } from 's' ; import { UpdateAvailableDialog , UpdateAvailableDialogProps } from 's' ; function mapDispatchToProps ( _dispatch ) { return { onCloseClick : ( ) => DialogService . hideDialog ( null ) , onUpdateClick : ( updateOption ) => { DialogService . hideDialog ( updateOption ) ; } , } ; } export const UpdateAvailableDialogContainer = connect ( null , mapDispatchToProps ) ( UpdateAvailableDialog ) ;	O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O $any$ O O O O O $UpdateAvailableDialogProps$ O $any$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $number$ O O O $DialogServiceImpl$ O $void$ O $number$ O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
export * from 's' ;	O O O O O
import { connect } from 's' ; import { DialogService } from 's' ; import { UpdateUnavailableDialog , UpdateUnavailableDialogProps } from 's' ; function mapDispatchToProps ( _dispatch ) { return { onCloseClick : ( ) => DialogService . hideDialog ( null ) , } ; } export const UpdateUnavailableDialogContainer = connect ( null , mapDispatchToProps ) ( UpdateUnavailableDialog ) ;	O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O $any$ O O O O O $UpdateUnavailableDialogProps$ O $any$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
export * from 's' ;	O O O O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { openBotViaFilePathAction , openBotViaUrlAction } from 's' ; import { DialogService } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { OpenBotDialog , OpenBotDialogProps , OpenBotDialogState } from 's' ; const mapDispatchToProps = ( dispatch : ( action ) => void ) : OpenBotDialogProps => { return { onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , openBot : ( componentState ) => { DialogService . hideDialog ( ) ; const { appId = 's' , appPassword = 's' , botUrl = 's' , mode = 's' , isAzureGov } = componentState ; if ( botUrl . startsWith ( 's' ) ) { dispatch ( openBotViaUrlAction ( { appId , appPassword , endpoint : botUrl , mode , channelService : isAzureGov ? 's' : 's' , } ) ) ; } else { dispatch ( openBotViaFilePathAction ( botUrl ) ) ; } } , onDialogCancel : ( ) => DialogService . hideDialog ( ) , } ; } ; const mapStateToProps = ( state , ownProps ) : OpenBotDialogProps => { return { savedBotUrls : state . clientAwareSettings . savedBotUrls , ... ownProps , } ; } ; export const OpenBotDialogContainer = connect ( mapStateToProps , mapDispatchToProps ) ( OpenBotDialog ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BotAction<string>$ O $BotAction<any>$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $void$ O O $Action$ O O O O O $any$ O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $void$ O O $OpenBotDialogState$ O O O $DialogServiceImpl$ O $void$ O O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O O O O $void$ O $BotAction<any>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O O O O O $void$ O $BotAction<string>$ O $any$ O O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O O O O O $any$ O O $RootState$ O $OpenBotDialogProps$ O O $any$ O O O O $any$ O $RootState$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { connect } from 's' ; import { DialogService } from 's' ; import { OpenUrlDialog , OpenUrlDialogProps } from 's' ; const mapDispatchToProps = ( _dispatch : ( ) => void ) : OpenUrlDialogProps => { return { cancel : ( ) => DialogService . hideDialog ( 0 ) , confirm : ( ) => DialogService . hideDialog ( 0 ) , } ; } ; export const OpenUrlDialogContainer = connect ( null , mapDispatchToProps ) ( OpenUrlDialog ) ;	O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $any$ O $any$ O O O O O $any$ O O $void$ O O O O O O O $any$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ComponentClass } from 's' ; import { Action } from 's' ; export const AZURE_ARM_TOKEN_DATA_CHANGED = 's' ; export const AZURE_BEGIN_AUTH_WORKFLOW = 's' ; export const AZURE_INVALIDATE_ARM_TOKEN = 's' ; export const AZURE_LOGGED_IN_USER_CHANGED = 's' ; export const AZURE_PERSIST_LOGIN_CHANGED = 's' ; export interface AzureAuthAction < T > extends Action { payload : T ; } export interface ArmTokenData { access_token : string ; } export interface AzureAuthWorkflow { promptDialog : ComponentClass < any > ; promptDialogProps : { [ propName ] : any } ; loginSuccessDialog : ComponentClass < any > ; loginFailedDialog : ComponentClass < any > ; resolver ? : Function ; } export function beginAzureAuthWorkflow ( promptDialog < any > , promptDialogProps : { [ propName ] : any } , loginSuccessDialog < any > , loginFailedDialog < any > , resolver ? ) < AzureAuthWorkflow > { return { type : AZURE_BEGIN_AUTH_WORKFLOW , payload : { promptDialog , promptDialogProps , loginSuccessDialog , loginFailedDialog , resolver , } , } ; } export function azureArmTokenDataChanged ( armToken ) < ArmTokenData > { return { type : AZURE_ARM_TOKEN_DATA_CHANGED , payload : { access_token : armToken } , } ; } export function invalidateArmToken ( ) < void > { return { type : AZURE_INVALIDATE_ARM_TOKEN , payload : undefined , } ; } export function azurePersistLoginChanged ( persistLogin ) < boolean > { return { type : AZURE_PERSIST_LOGIN_CHANGED , payload : persistLogin , } ; } export function azureLoggedInUserChanged ( signedInUser ) < string > { return { type : AZURE_LOGGED_IN_USER_CHANGED , payload : signedInUser , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Function$ O O $FunctionConstructor$ O O O O $AzureAuthAction$ O $ComponentClass$ O O O O $complex$ O O O $string$ O O O O O $ComponentClass$ O O O O $ComponentClass$ O O O O $Function$ $Function$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $complex$ O $any$ O $any$ O $Function$ O O O O O O O O $AzureAuthAction$ O $string$ O O $any$ O O O O $string$ O O O $complex$ O O $string$ O $string$ O O O O O O O $AzureAuthAction$ O O O O O O O O $string$ O O O $undefined$ O $undefined$ O O O O O O $AzureAuthAction$ O $boolean$ O O O O O O O $string$ O O O $boolean$ O $boolean$ O O O O O O $AzureAuthAction$ O $string$ O O O O O O O $string$ O O O $string$ O $string$ O O O O
import { ArmTokenData , AZURE_ARM_TOKEN_DATA_CHANGED , AZURE_BEGIN_AUTH_WORKFLOW , AZURE_INVALIDATE_ARM_TOKEN , AzureAuthAction , } from 's' ; export interface AzureAuthState { access_token : string ; persistLogin : boolean ; } const initialState = { access_token : null , persistLogin : false , } ; export function azureAuth ( state = initialState , action < ArmTokenData | void > ) { const { payload = { } , type = 's' } = action || { } ; const { access_token } = ( payload || { } ) as ArmTokenData ; switch ( type ) { case AZURE_BEGIN_AUTH_WORKFLOW : case AZURE_INVALIDATE_ARM_TOKEN : return { ... state , access_token : 's' } ; case AZURE_ARM_TOKEN_DATA_CHANGED : return { ... state , access_token } ; default : return state ; } }	O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O $boolean$ O O O O O $AzureAuthState$ O O $null$ O O O $false$ O O O O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction$ O $any$ O O O O O O O ${}$ O O O O $any$ O O O O $complex$ O O O O O O $string$ O O O ${}$ O O O O O $any$ O O O $any$ O O O O O O O O O O O $AzureAuthState$ O $string$ O O O O O O O O O O $AzureAuthState$ O $string$ O O O O O $AzureAuthState$ O O O
import { SharedConstants } from 's' ; import { call , ForkEffect , put , select , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { DialogService } from 's' ; import { AZURE_BEGIN_AUTH_WORKFLOW , azureArmTokenDataChanged , AzureAuthAction , AzureAuthWorkflow , } from 's' ; import { AzureAuthState } from 's' ; import { RootState } from 's' ; const getArmTokenFromState = ( state ) => state . azureAuth ; export class AzureAuthSaga { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * getArmToken ( action < AzureAuthWorkflow > ) < any > { const { resolver } = action . payload ; try { let azureAuth = yield select ( getArmTokenFromState ) ; if ( azureAuth . access_token ) { return azureAuth ; } const result = yield DialogService . showDialog ( action . payload . promptDialog , action . payload . promptDialogProps ) ; if ( result !== 0 ) { return result ; } const { RetrieveArmToken , PersistAzureLoginChanged } = SharedConstants . Commands . Azure ; const { TrackEvent } = SharedConstants . Commands . Telemetry ; azureAuth = yield call ( [ AzureAuthSaga . commandService , AzureAuthSaga . commandService . remoteCall ] , RetrieveArmToken ) ; if ( azureAuth && ! ( 's' in azureAuth ) ) { const persistLogin = yield DialogService . showDialog ( action . payload . loginSuccessDialog , azureAuth ) ; yield call ( AzureAuthSaga . commandService . remoteCall . bind ( AzureAuthSaga . commandService ) , PersistAzureLoginChanged , persistLogin ) ; AzureAuthSaga . commandService . remoteCall ( TrackEvent , 's' ) . catch ( _e => void 0 ) ; } else { yield DialogService . showDialog ( action . payload . loginFailedDialog ) ; AzureAuthSaga . commandService . remoteCall ( TrackEvent , 's' ) . catch ( _e => void 0 ) ; } yield put ( azureArmTokenDataChanged ( azureAuth . access_token ) ) ; return azureAuth ; } finally { resolver && resolver ( ) ; } } } export function * azureAuthSagas ( ) < ForkEffect > { yield takeEvery ( AZURE_BEGIN_AUTH_WORKFLOW , AzureAuthSaga . getArmToken ) ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $DialogServiceImpl$ O O O O O O O O $AzureAuthAction<ArmTokenData>$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $AzureAuthState$ O O $RootState$ O O $RootState$ O $AzureAuthState$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $AzureAuthAction$ O $any$ O O O O O O O O $Function$ O O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O O O O $AzureAuthState$ O O $any$ O $AzureAuthState$ O O O O $AzureAuthState$ O $string$ O O O $AzureAuthState$ O O O $undefined$ O O $DialogServiceImpl$ O $Promise<R>$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $any$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $complex$ O O O O $undefined$ O O O O O $undefined$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $AzureAuthState$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $AzureAuthState$ O O O O O $AzureAuthState$ O O O O $undefined$ O O $DialogServiceImpl$ O $Promise<R>$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $any$ O $AzureAuthState$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $DialogServiceImpl$ O $Promise<R>$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $AzureAuthAction<ArmTokenData>$ O $AzureAuthState$ O $string$ O O O O $AzureAuthState$ O O O O $Function$ O $Function$ O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O
import { LogEntry } from 's' ; import { Activity } from 's' ; import { ChatAction , ChatActions , PendingSpeechTokenRetrievalPayload , WebChatStorePayload , WebSpeechFactoryPayload , } from 's' ; import { EditorAction , EditorActions } from 's' ; import { Document , DocumentUI } from 's' ; export interface ChatState { changeKey ? : number ; chats ? : { [ chatId ] : ChatDocument } ; webSpeechFactories ? : { [ documentId ] : ( ) => any } ; webChatStores : { [ documentId ] : any } ; transcripts ? : string [ ] ; pendingSpeechTokenRetrieval : boolean ; } export interface ChatDocument < I = any > extends Document { endpointId : string ; endpointUrl : string ; highlightedObjects : Activity [ ] ; inspectorObjects : I [ ] ; log : ChatLog ; ui : DocumentUI ; } export interface ChatLog { entries : LogEntry [ ] ; } const DEFAULT_STATE = { changeKey : 0 , chats : { } , transcripts : [ ] , webSpeechFactories : { } , webChatStores : { } , pendingSpeechTokenRetrieval : false , } ; export function chat ( state = DEFAULT_STATE , action : ChatAction | EditorAction ) { switch ( action . type ) { case ChatActions . addTranscript : { const { payload } = action ; const transcriptsCopy = [ ... state . transcripts ] ; const transcripts = transcriptsCopy . filter ( xs => xs !== payload . filename ) ; transcripts . push ( payload . filename ) ; state = setTranscriptsState ( transcripts , state ) ; break ; } case ChatActions . clearTranscripts : { state = setTranscriptsState ( [ ] , state ) ; break ; } case ChatActions . removeTranscript : { const { payload } = action ; const transcriptsCopy = [ ... state . transcripts ] ; const transcripts = transcriptsCopy . filter ( xs => xs !== payload . filename ) ; state = setTranscriptsState ( transcripts , state ) ; break ; } case ChatActions . newChat : { const { payload } = action ; state = { ... state , changeKey : state . changeKey + 0 , chats : { ... state . chats , [ payload . documentId ] : { ... payload } , } , } ; break ; } case ChatActions . webSpeechFactoryUpdated : { const { documentId , factory } = action . payload as WebSpeechFactoryPayload ; const { webSpeechFactories } = state ; state = { ... state , webSpeechFactories : { ... webSpeechFactories , [ documentId ] : factory } , } ; } break ; case ChatActions . webChatStoreUpdated : { const { documentId , store } = action . payload as WebChatStorePayload ; const { webChatStores } = state ; state = { ... state , webChatStores : { ... webChatStores , [ documentId ] : store } , } ; } break ; case ChatActions . updatePendingSpeechTokenRetrieval : state = { ... state , pendingSpeechTokenRetrieval : ( action . payload as PendingSpeechTokenRetrievalPayload ) . pending , } ; break ; case ChatActions . closeDocument : { const { documentId } = action . payload ; if ( documentId in state . chats ) { const copy = { ... state } ; copy . changeKey += 0 ; delete copy . chats [ documentId ] ; state = { ... copy } ; } break ; } case ChatActions . newConversation : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , ... payload . options , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . appendLog : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , log : { ... document . log , entries : [ ... document . log . entries , payload . entry ] , } , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . clearLog : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , log : { entries : [ ] , } , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . setHighlightedObjects : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , highlightedObjects : payload . objs , } ; } state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; case ChatActions . setInspectorObjects : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , inspectorObjects : payload . objs , } ; } state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; break ; } case ChatActions . updateChat : { const { payload } = action ; const { documentId = 's' , updatedValues = { } } = payload ; let document = state . chats [ documentId ] ; if ( document ) { document = { ... document , ... updatedValues , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case EditorActions . closeAll : { return DEFAULT_STATE ; } default : break ; } return state ; } function setTranscriptsState ( transcripts : string [ ] , state ) { const newState = { ... state } ; newState . transcripts = transcripts ; newState . changeKey = state . changeKey + 0 ; return newState ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $number$ O O O O $complex$ O O O O $string$ O O $any$ O O $complex$ O O O O $string$ O O O O O O O O $complex$ O O O $string$ O O O O O $string[]$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $any[]$ O $any$ O O O $I[]$ O $any$ O O O $ChatLog$ O $any$ O $DocumentUI$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O $ChatState$ O O $number$ O O O ${}$ O O O O $undefined[]$ O O O O ${}$ O O O O ${}$ O O O O $false$ O O O O O O O $ChatState$ O $ChatState$ O $ChatState$ O O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $ChatActions.addTranscript$ O O O O $any$ O O O O O $string[]$ O O O $ChatState$ O $string[]$ O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $any$ O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O $ChatState$ O $ChatState$ O $string[]$ O $ChatState$ O O O O O O $any$ O $ChatActions.clearTranscripts$ O O $ChatState$ O $ChatState$ O O O O $ChatState$ O O O O O O $any$ O $ChatActions.removeTranscript$ O O O O $any$ O O O O O $string[]$ O O O $ChatState$ O $string[]$ O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $any$ O $any$ O O $ChatState$ O $ChatState$ O $string[]$ O $ChatState$ O O O O O O $any$ O $ChatActions.newChat$ O O O O $any$ O O O O $ChatState$ O O O $ChatState$ O $number$ O $ChatState$ O $number$ O O O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O $ChatActions.webSpeechFactoryUpdated$ O O O O $string$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O $ChatState$ O $ChatState$ O O O $ChatState$ O $complex$ O O O $complex$ O O $string$ O O $any$ O O O O O O O O $any$ O $ChatActions.webChatStoreUpdated$ O O O O $string$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O $ChatState$ O $ChatState$ O O O $ChatState$ O $complex$ O O O $complex$ O O $string$ O O $any$ O O O O O O O O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O $ChatState$ O O O $ChatState$ O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O O O $any$ O $ChatActions.closeDocument$ O O O O $any$ O O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O $complex$ O O O $ChatState$ O O $complex$ O $number$ O O O O $complex$ O $complex$ O $any$ O O $ChatState$ O O O $complex$ O O O O O O O $any$ O $ChatActions.newConversation$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O O $any$ O $any$ O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.appendLog$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $complex$ O O O $ChatDocument<any>$ O $ChatLog$ O $any[]$ O O O $ChatDocument<any>$ O $ChatLog$ O $any[]$ O $any$ O $any$ O O O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.clearLog$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $complex$ O O $undefined[]$ O O O O O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.setHighlightedObjects$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $any$ O $any$ O $any$ O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O $any$ O $ChatActions.setInspectorObjects$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $any$ O $any$ O $any$ O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O $any$ O $ChatActions.updateChat$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O $any$ O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O O $any$ O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $EditorActions.closeAll$ O O O $ChatState$ O O O O O O O O $ChatState$ O O O $ChatState$ O $string[]$ O O O O O $ChatState$ O O O $complex$ O O O $ChatState$ O O $complex$ O $string[]$ O $string[]$ O $complex$ O $number$ O $ChatState$ O $number$ O O O O $complex$ O O
import { LogEntry } from 's' ; import { Action } from 's' ; import { Activity } from 's' ; import { EmulatorMode } from 's' ; import { ChatDocument } from 's' ; export enum ChatActions { activeInspectorChanged = 's' , newChat = 's' , openChat = 's' , closeConversation = 's' , closeDocument = 's' , newConversation = 's' , appendLog = 's' , clearLog = 's' , setInspectorObjects = 's' , setHighlightedObjects = 's' , addTranscript = 's' , clearTranscripts = 's' , removeTranscript = 's' , updateChat = 's' , showContextMenuForActivity = 's' , webSpeechFactoryUpdated = 's' , webChatStoreUpdated = 's' , updatePendingSpeechTokenRetrieval = 's' , } export interface ActiveInspectorChangedPayload { inspectorWebView : HTMLWebViewElement ; } export interface WebSpeechFactoryPayload { documentId : string ; factory : ( ) => any ; } export interface WebChatStorePayload { documentId : string ; store : any ; } export interface PendingSpeechTokenRetrievalPayload { pending : boolean ; } export interface DocumentIdPayload { documentId : string ; } export interface NewConversationPayload { documentId : string ; options : any ; } export interface AppendLogPayload { documentId : string ; entry : LogEntry ; } export interface ClearLogPayload { documentId : string ; resolver ? : Function ; } export interface SetInspectorObjectsPayload { documentId : string ; objs : any ; } export interface SetHighlightedObjectsPayload { documentId : string ; objs : Activity [ ] ; } export interface AddTranscriptPayload extends RemoveTranscriptPayload { } export interface RemoveTranscriptPayload { filename : string ; } export interface UpdateChatPayload { documentId : string ; updatedValues : any ; } export interface ChatAction < T = any > extends Action { payload : T ; } export function inspectorChanged ( inspectorWebView ) < ActiveInspectorChangedPayload > { return { type : ChatActions . activeInspectorChanged , payload : { inspectorWebView } , } ; } export function addTranscript ( filename ) < AddTranscriptPayload > { return { type : ChatActions . addTranscript , payload : { filename , } , } ; } export function clearTranscripts ( ) < { } > { return { type : ChatActions . clearTranscripts , payload : { } , } ; } export function removeTranscript ( filename ) < RemoveTranscriptPayload > { return { type : ChatActions . removeTranscript , payload : { filename , } , } ; } export function webSpeechFactoryUpdated ( documentId , factory : ( ) => any ) < WebSpeechFactoryPayload > { return { type : ChatActions . webSpeechFactoryUpdated , payload : { documentId , factory } , } ; } export function webChatStoreUpdated ( documentId , store ) < WebChatStorePayload > { return { type : ChatActions . webChatStoreUpdated , payload : { documentId , store } , } ; } export function updatePendingSpeechTokenRetrieval ( pending ) < PendingSpeechTokenRetrievalPayload > { return { type : ChatActions . updatePendingSpeechTokenRetrieval , payload : { pending } , } ; } export function newChat ( documentId , mode , additionalData ? < ChatDocument > ) < Partial < ChatDocument & ClearLogPayload > > { return { type : ChatActions . newChat , payload : { mode , documentId , conversationId : null , directLine : null , log : { entries : [ ] , } , inspectorObjects : [ ] , ui : { horizontalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , verticalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , } , ... additionalData , } , } ; } export function closeDocument ( documentId ) < DocumentIdPayload > { return { type : ChatActions . closeDocument , payload : { documentId , } , } ; } export function closeConversation ( documentId ) < DocumentIdPayload > { return { type : ChatActions . closeConversation , payload : { documentId , } , } ; } export function newConversation ( documentId , options ) < NewConversationPayload > { return { type : ChatActions . newConversation , payload : { documentId , options , } , } ; } export function appendToLog ( documentId , entry ) < AppendLogPayload > { return { type : ChatActions . appendLog , payload : { documentId , entry , } , } ; } export function clearLog ( documentId , resolver ? ) < ClearLogPayload > { return { type : ChatActions . clearLog , payload : { documentId , resolver , } , } ; } export function setInspectorObjects ( documentId , objs ) < SetInspectorObjectsPayload > { objs = Array . isArray ( objs ) ? objs : [ objs ] ; return { type : ChatActions . setInspectorObjects , payload : { documentId , objs , } , } ; } export function setHighlightedObjects ( documentId , objs : Activity | Activity [ ] ) < SetHighlightedObjectsPayload > { objs = Array . isArray ( objs ) ? objs : [ objs ] ; return { type : ChatActions . setHighlightedObjects , payload : { documentId , objs , } , } ; } export function updateChat ( documentId , updatedValues ) < UpdateChatPayload > { return { type : ChatActions . updateChat , payload : { documentId , updatedValues , } , } ; } export function showContextMenuForActivity ( activity < Activity > ) < Partial < Activity > > { return { type : ChatActions . showContextMenuForActivity , payload : activity , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $ChatActions.activeInspectorChanged$ O O O $ChatActions.newChat$ O O O $ChatActions.openChat$ O O O $ChatActions.closeConversation$ O O O $ChatActions.closeDocument$ O O O $ChatActions.newConversation$ O O O $ChatActions.appendLog$ O O O $ChatActions.clearLog$ O O O $ChatActions.setInspectorObjects$ O O O $ChatActions.setHighlightedObjects$ O O O $ChatActions.addTranscript$ O O O $ChatActions.clearTranscripts$ O O O $ChatActions.removeTranscript$ O O O $ChatActions.updateChat$ O O O $ChatActions.showContextMenuForActivity$ O O O $ChatActions.webSpeechFactoryUpdated$ O O O $ChatActions.webChatStoreUpdated$ O O O $ChatActions.updatePendingSpeechTokenRetrieval$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O $any$ O O O O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O O O O $any$ O $string$ O O O $Function$ O O $FunctionConstructor$ O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $string$ O O O $any[]$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $T$ O $any$ O O O O $ChatAction$ O $HTMLWebViewElement$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.activeInspectorChanged$ O $complex$ O O $any$ O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.addTranscript$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O O O O O O O O O $ChatActions$ O $any$ O $ChatActions.clearTranscripts$ O ${}$ O O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.removeTranscript$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O O O O O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.webSpeechFactoryUpdated$ O $complex$ O O $string$ O $any$ O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.webChatStoreUpdated$ O $complex$ O O $string$ O $any$ O O O O O O O $ChatAction$ O $boolean$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O $complex$ O O $boolean$ O O O O O O O $ChatAction$ O $string$ O $EmulatorMode$ O $Partial<ChatDocument<any>>$ $Partial$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $ChatActions$ O $any$ O $ChatActions.newChat$ O O O O $any$ O $string$ O $null$ O O O $null$ O O O $complex$ O O $undefined[]$ O O O O O O $undefined[]$ O O O O $complex$ O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O O O O $Partial<ChatDocument<any>>$ O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.closeDocument$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.closeConversation$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.newConversation$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $LogEntry$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.appendLog$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $Function$ $Function$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.clearLog$ O $complex$ O O $string$ O $Function$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.setInspectorObjects$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.setHighlightedObjects$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.updateChat$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $Partial$ O $any$ O O O $any$ O $any$ O O O O O $ChatActions$ O $any$ O $ChatActions.showContextMenuForActivity$ O $any$ O $any$ O O O O
import { SharedConstants } from 's' ; import { select } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { RootState } from 's' ; export function editorSelector ( state ) { return state . editor ; } export class SharedSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * refreshConversationMenu ( ) < any > { const stateData = yield select ( editorSelector ) ; yield SharedSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . UpdateConversationMenu , stateData ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $EditorState<any>$ O $RootState$ O O O $RootState$ O $EditorState<any>$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O O O O O O O $undefined$ O O $any$ O $EditorState<any>$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O
import { newNotification , ResourceResponse , SharedConstants , UserSettings } from 's' ; import { IEndpointService } from 's' ; import { CommandServiceImpl , CommandServiceInstance , ConversationService , StartConversationParams , } from 's' ; import { call , ForkEffect , put , select , takeEvery , takeLatest } from 's' ; import { ActiveBotHelper } from 's' ; import { BotAction , BotActionType , BotConfigWithPathPayload , botHashGenerated , openBotViaUrlAction , RestartConversationPayload , } from 's' ; import { beginAdd } from 's' ; import { generateHash } from 's' ; import { RootState } from 's' ; import * as ChatActions from 's' ; import { ChatDocument } from 's' ; import { SharedSagas } from 's' ; export class BotSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * browseForBot ( ) < any > { yield call ( [ ActiveBotHelper , ActiveBotHelper . confirmAndOpenBotFromFile ] ) ; } public static * generateHashForActiveBot ( action < BotConfigWithPathPayload > ) < any > { const { bot } = action . payload ; const generatedHash = yield call ( generateHash , bot ) ; yield put ( botHashGenerated ( generatedHash ) ) ; } public static * openBotViaFilePath ( action < string > ) { try { yield call ( [ ActiveBotHelper , ActiveBotHelper . confirmAndOpenBotFromFile ] , action . payload ) ; } catch ( e ) { const errorNotification = beginAdd ( newNotification ( `template` ) ) ; yield put ( errorNotification ) ; } } public static * restartConversation ( action < RestartConversationPayload > ) < any > { const serverUrl = yield select ( ( state ) => state . clientAwareSettings . serverUrl ) ; const { documentId , conversationId , user } = action . payload ; let error ; try { const endpointResponse = yield ConversationService . getConversationEndpoint ( serverUrl , conversationId ) ; if ( ! endpointResponse . ok ) { const error = yield endpointResponse . json ( ) ; throw new Error ( error . error . message ) ; } const endpoint = yield endpointResponse . json ( ) ; const document = yield select ( ( state ) => state . chat . chats [ documentId ] ) ; if ( document . directLine ) { document . directLine . end ( ) ; } document . directLine = null ; let resolver = null ; const awaiter = new Promise ( resolve => { resolver = resolve ; } ) ; yield put ( ChatActions . clearLog ( documentId , resolver ) ) ; yield awaiter ; yield put ( ChatActions . setInspectorObjects ( documentId , [ ] ) ) ; yield * BotSagas . openBotViaUrl ( openBotViaUrlAction ( { conversationId , appPassword : endpoint . appPassword , appId : endpoint . appId , endpoint : endpoint . endpoint , mode : document . mode , user , } ) ) ; } catch ( e ) { error = 's' + e ; } if ( error ) { const errorNotification = beginAdd ( newNotification ( error ) ) ; yield put ( errorNotification ) ; } } public static * openBotViaUrl ( action < Partial < StartConversationParams > > ) { const serverUrl = yield select ( ( state ) => state . clientAwareSettings . serverUrl ) ; if ( ! action . payload . user ) { const customUserId = yield select ( ( state ) => state . framework . userGUID ) ; const users = yield select ( ( state ) => state . clientAwareSettings . users ) ; action . payload . user = customUserId || users . usersById [ users . currentUserId ] ; if ( customUserId ) { action . payload . user = customUserId ; yield call ( [ BotSagas . commandService , BotSagas . commandService . remoteCall ] , SharedConstants . Commands . Emulator . SetCurrentUser , customUserId ) ; } } let error ; try { const response = yield ConversationService . startConversation ( serverUrl , action . payload ) ; if ( ! response . ok ) { error = `template` ; } if ( action . payload . mode === 's' ) { const parsedBody = yield response . json ( ) ; const conversationId = parsedBody . id || 's' ; if ( conversationId ) { const activity = { type : 's' , text : 's' , } ; const postActivityResponse : ResourceResponse & { statusCode : number } = yield call ( [ BotSagas . commandService , BotSagas . commandService . remoteCall ] , SharedConstants . Commands . Emulator . PostActivityToConversation , conversationId , activity ) ; if ( postActivityResponse . statusCode > 0 ) { error = `template` ; } } else { error = 's' ; } } } catch ( e ) { error = e . message ; } if ( error ) { const errorNotification = beginAdd ( newNotification ( error ) ) ; yield put ( errorNotification ) ; } else { yield call ( [ BotSagas . commandService , BotSagas . commandService . remoteCall ] , SharedConstants . Commands . Settings . SaveBotUrl , action . payload . endpoint ) ; } } } export function * botSagas ( ) < ForkEffect > { yield takeEvery ( BotActionType . browse , BotSagas . browseForBot ) ; yield takeEvery ( BotActionType . openViaUrl , BotSagas . openBotViaUrl ) ; yield takeEvery ( BotActionType . openViaFilePath , BotSagas . openBotViaFilePath ) ; yield takeEvery ( BotActionType . restartConversation , BotSagas . restartConversation ) ; yield takeEvery ( BotActionType . setActive , BotSagas . generateHashForActiveBot ) ; yield takeLatest ( [ BotActionType . setActive , BotActionType . load , BotActionType . close ] , SharedSagas . refreshConversationMenu ) ; }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $BotAction<HashPayload>$ O $BotAction<any>$ O $any$ O O O O O O O $BeginAddNotificationAction$ O O O O O O $Promise<string>$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O O O O O O O $any$ O O $any$ O $any$ O $Promise<any>$ O O O O O O O $IterableIterator$ O $BotAction$ O $any$ O O O O O O O O $any$ O O $BotAction<BotConfigWithPathPayload>$ O $BotConfigWithPathPayload$ O O $undefined$ O O $any$ O $Promise<string>$ O $any$ O O O $any$ O $BotAction<HashPayload>$ O $undefined$ O O O O O O O $complex$ O $BotAction$ O O O O O O O O $any$ O O $any$ O $any$ O $Promise<any>$ O O $BotAction<string>$ O $string$ O O O O O $any$ O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O O $any$ O $BeginAddNotificationAction$ O O O O O O O $IterableIterator$ O $BotAction$ O $any$ O O O O O O O $undefined$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O O O O $string$ O $string$ O $any$ O O $BotAction<RestartConversationPayload>$ O $RestartConversationPayload$ O O $any$ O O O O $Response$ O O $any$ O $any$ O $undefined$ O $string$ O O O O O $Response$ O $boolean$ O O O $undefined$ O O $Response$ O $Promise<any>$ O O O O O $ErrorConstructor$ O $undefined$ O $any$ O $any$ O O O O $IEndpointService$ O O $Response$ O $Promise<any>$ O O O O $ChatDocument$ O O $any$ O O $RootState$ O O $RootState$ O $ChatState$ O $complex$ O $string$ O O O O O $ChatDocument<any>$ O $any$ O O $ChatDocument<any>$ O $any$ O $any$ O O O O $ChatDocument<any>$ O $any$ O O O O $any$ O O O O $Promise<unknown>$ O O $PromiseConstructor$ O $void$ O O $any$ O $void$ O O O O O $any$ O $any$ O $ChatAction<ClearLogPayload>$ O $string$ O $any$ O O O O $Promise<unknown>$ O O $any$ O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $string$ O O O O O O O O $any$ O $complex$ O $BotAction<any>$ O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $ChatDocument<any>$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O $any$ O O O O $any$ O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O $any$ O O O O $any$ O $BeginAddNotificationAction$ O O O O O O O $complex$ O $BotAction$ O $any$ O $any$ O O O O O $any$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O O O O O $BotAction<any>$ O $any$ O $any$ O O O $any$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O O O $UserSettings$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O O $BotAction<any>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $BotAction<any>$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $Response$ O O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O O O O O $Response$ O $boolean$ O O $any$ O O O O O O $BotAction<any>$ O $any$ O $any$ O O O O O $any$ O O $Response$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $number$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O $any$ O O O O $any$ O $BeginAddNotificationAction$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O $any$ O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O $any$ O $BotActionType.browse$ O $any$ O $IterableIterator<any>$ O O O $any$ O $any$ O $BotActionType.openViaUrl$ O $any$ O $complex$ O O O $any$ O $any$ O $BotActionType.openViaFilePath$ O $any$ O $complex$ O O O $any$ O $any$ O $BotActionType.restartConversation$ O $any$ O $IterableIterator<any>$ O O O $any$ O $any$ O $BotActionType.setActive$ O $any$ O $IterableIterator<any>$ O O O $any$ O O $any$ O $BotActionType.setActive$ O $any$ O $BotActionType.load$ O $any$ O $BotActionType.close$ O O $any$ O $IterableIterator<any>$ O O O
import { isChatFile , isTranscriptFile , SharedConstants } from 's' ; import { call , ForkEffect , put , select , takeEvery , takeLatest } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { EditorActions , removeDocPendingChange } from 's' ; import { editorSelector , SharedSagas } from 's' ; export class EditorSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * promptUserToReloadDocument ( filename ) < any > { const { Commands } = SharedConstants ; const options = { buttons : [ 's' , 's' ] , title : 's' , message : 's' , } ; const confirmation = yield EditorSagas . commandService . remoteCall ( Commands . Electron . ShowMessageBox , options ) ; yield put ( removeDocPendingChange ( filename ) ) ; const { OpenChatFile , ReloadTranscript } = SharedConstants . Commands . Emulator ; if ( confirmation ) { if ( isChatFile ( filename ) ) { yield EditorSagas . commandService . call ( OpenChatFile , filename , true ) ; } else if ( isTranscriptFile ( filename ) ) { yield EditorSagas . commandService . call ( ReloadTranscript , filename ) ; } } } public static * checkActiveDocForPendingChanges ( ) < any > { const stateData = yield select ( editorSelector ) ; const activeDocId = stateData . editors [ stateData . activeEditor ] . activeDocumentId ; if ( stateData . docsWithPendingChanges . some ( doc => doc === activeDocId ) ) { yield call ( EditorSagas . promptUserToReloadDocument , activeDocId ) ; } return ; } } export function * editorSagas ( ) < ForkEffect > { yield takeEvery ( [ EditorActions . addDocPendingChange , EditorActions . setActiveEditor , EditorActions . setActiveTab , EditorActions . open ] , EditorSagas . checkActiveDocForPendingChanges ) ; yield takeLatest ( [ EditorActions . close , EditorActions . open , EditorActions . setActiveEditor , EditorActions . setActiveTab ] , SharedSagas . refreshConversationMenu ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $RemoveDocPendingChangeAction$ O O O O O O $EditorState<any>$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $string$ O O O O O O O $any$ O O $any$ O O $complex$ O O $string[]$ O O O O O O O $string$ O O O $string$ O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $RemoveDocPendingChangeAction$ O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $undefined$ O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $IterableIterator$ O O O O O O O $undefined$ O O $any$ O $EditorState<any>$ O O O $any$ O $undefined$ O $any$ O $undefined$ O $any$ O O $any$ O O O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $IterableIterator<any>$ O $any$ O O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O $any$ O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveTab$ O $any$ O $EditorActions.open$ O O $any$ O $IterableIterator<any>$ O O O $any$ O O $any$ O $EditorActions.close$ O $any$ O $EditorActions.open$ O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveTab$ O O $any$ O $IterableIterator<any>$ O O O
import { CONNECTED_SERVICES_PANEL_ID , ExplorerAction , ExplorerActions , ExplorerPayload , } from 's' ; export interface ExplorerState { showing : boolean ; sortSelectionByPanelId : { [ panelId ] : SortCriteria } ; } export declare type SortCriteria = string ; const DEFAULT_STATE = { showing : true , sortSelectionByPanelId : { [ CONNECTED_SERVICES_PANEL_ID ] : 's' } , } ; export function explorer ( state = DEFAULT_STATE , action < ExplorerPayload > ) { switch ( action . type ) { case ExplorerActions . Show : state = { ... state , showing : action . payload . show } ; break ; case ExplorerActions . Sort : { const sortSelectionByPanelId = { ... state . sortSelectionByPanelId , ... action . payload . sortSelectionByPanelId , } ; state = { ... state , sortSelectionByPanelId } ; break ; } default : break ; } return state ; }	O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $boolean$ O O O $complex$ O O O $string$ O O $any$ O O O O O O $any$ O O O O $ExplorerState$ O O $true$ O O O $complex$ O O O O O O O O O O O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction$ O $any$ O O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O O $any$ O $ExplorerActions.Show$ O $ExplorerState$ O O O $ExplorerState$ O $boolean$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O $boolean$ O O O O O $any$ O $ExplorerActions.Sort$ O O O $complex$ O O O $ExplorerState$ O $complex$ O O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O $complex$ O O O $ExplorerState$ O O O $ExplorerState$ O $complex$ O O O O O O O O O O O $ExplorerState$ O O
import { Action } from 's' ; import { SortCriteria } from 's' ; export const CONNECTED_SERVICES_PANEL_ID = 's' ; export enum ExplorerActions { Show = 's' , Sort = 's' , } export interface ExplorerAction < T > extends Action { type : ExplorerActions ; payload : T ; } export interface ExplorerPayload { show ? : boolean ; sortSelectionByPanelId ? : { [ panelId ] : SortCriteria } ; } export function showExplorer ( show ) < ExplorerPayload > { return { type : ExplorerActions . Show , payload : { show } , } ; } export function sortExplorerContents ( panelId , sort ) < ExplorerPayload > { return { type : ExplorerActions . Sort , payload : { sortSelectionByPanelId : { [ panelId ] : sort } } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $ExplorerActions.Show$ O O O $ExplorerActions.Sort$ O O O O O O $any$ O $any$ O O $any$ O $ExplorerActions$ O $any$ O $T$ O $any$ O O O O $any$ O $boolean$ O O O O $complex$ O O O O $string$ O O $any$ O O O O O $ExplorerAction$ O $boolean$ O O $any$ O O O O $ExplorerActions.Show$ O $any$ O $ExplorerActions.Show$ O $complex$ O O $boolean$ O O O O O O O $ExplorerAction$ O $string$ O $SortCriteria$ O O $any$ O O O O $ExplorerActions.Sort$ O $any$ O $ExplorerActions.Sort$ O $complex$ O O $complex$ O O O $string$ O O $string$ O O O O O O
import { IConnectedService , ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; import { CONNECTED_SERVICES_PANEL_ID } from 's' ; export const OPEN_SERVICE_DEEP_LINK = 's' ; export const OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE = 's' ; export const OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU = 's' ; export const LAUNCH_EXTERNAL_LINK = 's' ; export const OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU = 's' ; export const LAUNCH_CONNECTED_SERVICE_EDITOR = 's' ; export const LAUNCH_CONNECTED_SERVICE_PICKER = 's' ; export interface ConnectedServiceAction < T > extends Action { payload : T ; } export interface ConnectedServicePayload { serviceType ? : ServiceTypes ; connectedService ? : IConnectedService ; authenticatedUser ? : string ; editorComponent ? : ComponentClass < any > ; panelId ? : string ; } export function launchConnectedServiceEditor < T > ( editorComponent < T > , connectedService ? ) < ConnectedServicePayload > { return { type : LAUNCH_CONNECTED_SERVICE_EDITOR , payload : { editorComponent , connectedService } , } ; } export interface ConnectedServicePickerPayload extends ConnectedServicePayload { azureAuthWorkflowComponents : { promptDialog : ComponentClass < any > ; loginSuccessDialog : ComponentClass < any > ; loginFailedDialog : ComponentClass < any > ; } ; pickerComponent : ComponentClass < any > ; getStartedDialog : ComponentClass < any > ; editorComponent : ComponentClass < any > ; progressIndicatorComponent ? : ComponentClass < any > ; } export interface OpenAddServiceContextMenuPayload extends ConnectedServicePickerPayload { resolver : Function ; } export function launchConnectedServicePicker ( payload ) < ConnectedServicePickerPayload > { return { type : LAUNCH_CONNECTED_SERVICE_PICKER , payload , } ; } export function openServiceDeepLink ( connectedService ) < ConnectedServicePayload > { return { type : OPEN_SERVICE_DEEP_LINK , payload : { connectedService } , } ; } export function openContextMenuForConnectedService < T > ( editorComponent < T > , connectedService ? ) < ConnectedServicePayload > { return { type : OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , payload : { editorComponent , connectedService } , } ; } export function openAddServiceContextMenu ( payload , resolver ) < OpenAddServiceContextMenuPayload > { return { type : OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , payload : { ... payload , resolver , } , } ; } export function launchExternalLink ( payload ) < ConnectedServicePayload > { return { type : LAUNCH_EXTERNAL_LINK , payload , } ; } export function openSortContextMenu ( ) < ConnectedServicePayload > { return { type : OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , payload : { panelId : CONNECTED_SERVICES_PANEL_ID } , } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $string$ O O O O $any$ O O $any$ O O O O $string$ O O O O O O O $ConnectedServiceAction$ O $any$ O O $ComponentClass$ O $any$ O O $any$ $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $ConnectedServiceAction$ O $ConnectedServicePickerPayload$ O O $any$ O O O O $string$ O O O $ConnectedServicePickerPayload$ O O O O O O $ConnectedServiceAction$ O $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O O O $ConnectedServiceAction$ O $any$ O O $ComponentClass$ O $any$ O O $any$ $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O O O $ConnectedServiceAction$ O $ConnectedServicePickerPayload$ O $Function$ O O $any$ O O O O $string$ O O O O O O O $ConnectedServicePickerPayload$ O $Function$ O O O O O O O O $ConnectedServiceAction$ O $ConnectedServicePayload$ O O $any$ O O O O $string$ O O O $ConnectedServicePayload$ O O O O O O $ConnectedServiceAction$ O O O $any$ O O O O $string$ O O O $complex$ O O $string$ O O O O O O O
import { IEndpointService } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; export const OPEN_ENDPOINT_IN_EMULATOR = 's' ; export const OPEN_ENDPOINT_CONTEXT_MENU = 's' ; export const LAUNCH_ENDPOINT_EDITOR = 's' ; export interface EndpointServiceAction < T > extends Action { payload : T ; } export interface EndpointServicePayload { endpointService : IEndpointService ; focusExistingChatIfAvailable ? : boolean ; resolver ? : Function ; } export interface EndpointEditorPayload extends EndpointServicePayload { endpointEditorComponent ? : ComponentClass < any > ; } export function launchEndpointEditor ( endpointEditorComponent < any > , endpointService ? , resolver ? ) < EndpointEditorPayload > { return { type : LAUNCH_ENDPOINT_EDITOR , payload : { endpointEditorComponent , endpointService , resolver } , } ; } export function openEndpointInEmulator ( endpointService , focusExistingChatIfAvailable = false ) < EndpointServicePayload > { return { type : OPEN_ENDPOINT_IN_EMULATOR , payload : { endpointService , focusExistingChatIfAvailable } , } ; } export function openEndpointExplorerContextMenu ( endpointEditorComponent < any > , endpointService ? ) < EndpointEditorPayload > { return { type : OPEN_ENDPOINT_CONTEXT_MENU , payload : { endpointEditorComponent , endpointService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O $any$ O $boolean$ O O O O $Function$ O O $FunctionConstructor$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $EndpointServiceAction$ O $ComponentClass$ O O O O $any$ $IEndpointService$ O $Function$ $Function$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O $Function$ O O O O O O O $EndpointServiceAction$ O $IEndpointService$ O $boolean$ O O O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $boolean$ O O O O O O O $EndpointServiceAction$ O $ComponentClass$ O O O O $any$ $IEndpointService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O
import { SharedConstants } from 's' ; import { IBotService , IEndpointService , ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import { call , ForkEffect , put , select , takeEvery , takeLatest } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { DialogService } from 's' ; import { openServiceDeepLink } from 's' ; import { EndpointEditorPayload , EndpointServiceAction , EndpointServicePayload , LAUNCH_ENDPOINT_EDITOR , OPEN_ENDPOINT_CONTEXT_MENU , OPEN_ENDPOINT_IN_EMULATOR , } from 's' ; import { RootState } from 's' ; const getConnectedAbs = ( state , endpointAppId ) => { return ( state . bot . activeBot . services || [ ] ) . find ( service => { return service . type === ServiceTypes . Bot && ( service as IBotService ) . appId === endpointAppId ; } ) ; } ; export class EndpointSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * launchEndpointEditor ( action < EndpointEditorPayload > ) < any > { const { endpointEditorComponent , endpointService = { } , resolver } = action . payload ; const servicesToUpdate = yield DialogService . showDialog < ComponentClass < any > , IEndpointService [ ] > ( endpointEditorComponent , { endpointService } ) ; if ( servicesToUpdate ) { const { AddOrUpdateService , RemoveService } = SharedConstants . Commands . Bot ; let i = servicesToUpdate . length ; while ( i -- ) { const service = servicesToUpdate [ i ] ; let shouldBeRemoved = false ; if ( service . type === ServiceTypes . Bot ) { const { serviceName , resourceGroup , subscriptionId , tenantId } = service as IBotService ; shouldBeRemoved = ! serviceName && ! resourceGroup && ! subscriptionId && ! tenantId ; } yield EndpointSagas . commandService . remoteCall ( shouldBeRemoved ? RemoveService : AddOrUpdateService , service . type , service ) ; } } resolver && resolver ( ) ; } public static * openEndpointContextMenu ( action < EndpointServicePayload | EndpointEditorPayload > ) < any > { const connectedAbs = yield select < RootState , string > ( getConnectedAbs , action . payload . endpointService . appId ) ; const menuItems = [ { label : 's' , id : 's' } , { label : 's' , id : 's' , enabled : ! ! connectedAbs } , { label : 's' , id : 's' } , { label : 's' , id : 's' } , ] ; const { DisplayContextMenu } = SharedConstants . Commands . Electron ; const response = yield call ( [ EndpointSagas . commandService , EndpointSagas . commandService . remoteCall ] , DisplayContextMenu , menuItems ) ; switch ( response . id ) { case 's' : yield * EndpointSagas . launchEndpointEditor ( action ) ; break ; case 's' : yield * EndpointSagas . openEndpointInEmulator ( action ) ; break ; case 's' : yield put ( openServiceDeepLink ( connectedAbs ) ) ; break ; case 's' : yield * EndpointSagas . removeEndpointServiceFromActiveBot ( action . payload . endpointService ) ; break ; default : return ; } } public static * openEndpointInEmulator ( action < EndpointServicePayload > ) < any > { const { endpointService , focusExistingChatIfAvailable : focusExisting = false } = action . payload ; return EndpointSagas . commandService . call ( SharedConstants . Commands . Emulator . NewLiveChat , endpointService , focusExisting ) ; } public static * removeEndpointServiceFromActiveBot ( endpointService ) < any > { const result = yield EndpointSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . ShowMessageBox , true , { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; if ( result ) { yield EndpointSagas . commandService . remoteCall ( SharedConstants . Commands . Bot . RemoveService , endpointService . type , endpointService . id ) ; } } } export function * endpointSagas ( ) < ForkEffect > { yield takeLatest ( LAUNCH_ENDPOINT_EDITOR , EndpointSagas . launchEndpointEditor ) ; yield takeEvery ( OPEN_ENDPOINT_CONTEXT_MENU , EndpointSagas . openEndpointContextMenu ) ; yield takeEvery ( OPEN_ENDPOINT_IN_EMULATOR , EndpointSagas . openEndpointInEmulator ) ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O O $RootState$ O $string$ O O O O O $RootState$ O $BotState$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $string$ O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $EndpointServiceAction$ O $any$ O O O O O O O O $any$ O $any$ O O O O $Function$ O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointEditorPayload$ O O $undefined$ O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O O O $undefined$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $undefined$ O $any$ O O O $any$ O O O O $any$ O $undefined$ O $any$ O O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $boolean$ O O $any$ O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Function$ O $Function$ O O O O O O O $IterableIterator$ O $EndpointServiceAction$ O $any$ O $any$ O O O O O O O $undefined$ O O $any$ O $any$ O O O O $any$ O $complex$ O $complex$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $boolean$ O O O $undefined$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $undefined$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O $undefined$ O $any$ O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O O O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $undefined$ O O O O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O $complex$ O $any$ O O O O O O O O O O O O O $IterableIterator$ O $EndpointServiceAction$ O $any$ O O O O O O O O $any$ O $boolean$ O $boolean$ O O O O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServicePayload$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O O $IterableIterator$ O $IEndpointService$ O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O
import { FrameworkSettings } from 's' ; import { Action } from 's' ; export enum FrameworkActionType { SET_FRAMEWORK = 's' , PUSH_CLIENT_AWARE_SETTINGS = 's' , SAVE_FRAMEWORK_SETTINGS = 's' , } export interface FrameworkAction < P > extends Action { type : FrameworkActionType ; payload : P ; } export function setFrameworkSettings ( frameworkSettings ) < FrameworkSettings > { return { type : FrameworkActionType . SET_FRAMEWORK , payload : frameworkSettings , } ; } export function pushClientAwareSettings ( ) < undefined > { return { type : FrameworkActionType . PUSH_CLIENT_AWARE_SETTINGS , payload : undefined , } ; } export function saveFrameworkSettings ( payload ) < FrameworkSettings > { return { type : FrameworkActionType . SAVE_FRAMEWORK_SETTINGS , payload , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O O O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O O O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O O O O O O $any$ O $any$ O O $any$ O $FrameworkActionType$ O $any$ O $P$ O $any$ O O O O $FrameworkAction$ O $FrameworkSettings$ O O $any$ O O O O $FrameworkActionType.SET_FRAMEWORK$ O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O $any$ O $any$ O O O O O O $FrameworkAction$ O O O O O O O O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $any$ O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $undefined$ O $undefined$ O O O O O O $FrameworkAction$ O $FrameworkSettings$ O O $any$ O O O O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O O O O
import { newNotification , FrameworkSettings } from 's' ; import { ForkEffect , put , select , takeEvery } from 's' ; import * as EditorActions from 's' ; import { FrameworkAction , FrameworkActionType , setFrameworkSettings } from 's' ; import { beginAdd } from 's' ; import { Document } from 's' ; import { RootState } from 's' ; export const activeDocumentSelector = ( state ) => { const { editors , activeEditor } = state . editor ; const { activeDocumentId } = editors [ activeEditor ] ; return editors [ activeEditor ] . documents [ activeDocumentId ] ; } ; export class FrameworkSettingsSagas { public static * saveFrameworkSettings ( action < FrameworkSettings > ) < any > { try { const activeDoc = yield select ( activeDocumentSelector ) ; yield put ( EditorActions . setDirtyFlag ( activeDoc . documentId , false ) ) ; yield put ( setFrameworkSettings ( action . payload ) ) ; } catch ( e ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; yield put ( beginAdd ( notification ) ) ; } } } export function * frameworkSettingsSagas ( ) < ForkEffect > { yield takeEvery ( FrameworkActionType . SAVE_FRAMEWORK_SETTINGS , FrameworkSettingsSagas . saveFrameworkSettings ) ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $FrameworkAction<any>$ O O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Document<any>$ O O $RootState$ O O O O O $complex$ O $string$ O O $RootState$ O $EditorState<any>$ O O O $string$ O O $complex$ O $string$ O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O $any$ O O O O $IterableIterator$ O $FrameworkAction$ O $any$ O O O O O O O O O $Document$ O O $any$ O $Document<any>$ O O O $any$ O $any$ O $SetDirtyFlagAction$ O $Document<any>$ O $string$ O O O O O O $any$ O $FrameworkAction<any>$ O $FrameworkAction<any>$ O $any$ O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O $any$ O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O $IterableIterator<any>$ O O O
export enum NavBarActions { select = 's' , } export interface SelectNavBarAction { type : NavBarActions . select ; payload : { selection : string ; } ; } export type NavBarAction = SelectNavBarAction ; export function select ( selection ) { return { type : NavBarActions . select , payload : { selection , } , } ; }	O O $any$ O $NavBarActions.select$ O O O O O O $any$ O $NavBarActions$ O $any$ O $NavBarActions.select$ O $complex$ O O $string$ O O O O O O O O $any$ O $any$ O O O $SelectNavBarAction$ O $string$ O O O O $NavBarActions.select$ O $any$ O $NavBarActions.select$ O $complex$ O O $string$ O O O O O O
import { ForkEffect , put , takeEvery } from 's' ; import * as Constants from 's' ; import { NavBarActions , SelectNavBarAction } from 's' ; import { markAllAsRead } from 's' ; export function * markNotificationsAsRead ( action ) < any > { const navBarSelection = action . payload . selection ; if ( navBarSelection === Constants . NAVBAR_NOTIFICATIONS ) { yield put ( markAllAsRead ( ) ) ; } } export function * navBarSagas ( ) < ForkEffect > { yield takeEvery ( NavBarActions . select , markNotificationsAsRead ) ; }	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $MarkAllAsReadNotificationAction$ O O O O O O O $IterableIterator$ O $SelectNavBarAction$ O O O O O O $string$ O $SelectNavBarAction$ O $complex$ O $string$ O O O $string$ O $any$ O O O O O $any$ O $MarkAllAsReadNotificationAction$ O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O $any$ O $NavBarActions.select$ O $IterableIterator<any>$ O O O
import { Notification } from 's' ; export const NotificationManager = new Map < string , Notification > ( ) ;	O O $any$ O O O O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O
import { ForkEffect , put , takeEvery } from 's' ; import { NotificationManager } from 's' ; import { BeginAddNotificationAction , BeginRemoveNotificationAction , finishAdd , finishClear , finishRemove , NotificationActions , } from 's' ; export function * addNotification ( action ) < any > { const { notification } = action . payload ; NotificationManager . set ( notification . id , notification ) ; yield put ( finishAdd ( notification ) ) ; } export function * clearNotifications ( ) < any > { NotificationManager . clear ( ) ; yield put ( finishClear ( ) ) ; } export function * removeNotification ( action ) < any > { const { id : notificationId } = action . payload ; NotificationManager . delete ( notificationId ) ; yield put ( finishRemove ( notificationId ) ) ; } export function markAllAsRead ( ) { NotificationManager . forEach ( notification => { notification . read = true ; } ) ; } export function * notificationSagas ( ) < ForkEffect > { yield takeEvery ( NotificationActions . beginAdd , addNotification ) ; yield takeEvery ( NotificationActions . beginClear , clearNotifications ) ; yield takeEvery ( NotificationActions . beginRemove , removeNotification ) ; yield takeEvery ( NotificationActions . markAllAsRead , markAllAsRead ) ; }	O O $any$ O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O $any$ O $FinishAddNotificationAction$ O $FinishClearNotificationAction$ O $FinishRemoveNotificationAction$ O $any$ O O O O O O O O $IterableIterator$ O $BeginAddNotificationAction$ O O O O O O O $any$ O O $BeginAddNotificationAction$ O $complex$ O $complex$ O $complex$ O $any$ O $any$ O $any$ O O O $any$ O $FinishAddNotificationAction$ O $any$ O O O O O O O $IterableIterator$ O O O O O O $complex$ O $void$ O O O O $any$ O $FinishClearNotificationAction$ O O O O O O O O $IterableIterator$ O $BeginRemoveNotificationAction$ O O O O O O O $string$ O $string$ O O $BeginRemoveNotificationAction$ O $complex$ O $complex$ O $boolean$ O $string$ O O O $any$ O $FinishRemoveNotificationAction$ O $string$ O O O O O O $void$ O O O $complex$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O $any$ O $NotificationActions.beginAdd$ O $IterableIterator<any>$ O O O $any$ O $any$ O $NotificationActions.beginClear$ O $IterableIterator<any>$ O O O $any$ O $any$ O $NotificationActions.beginRemove$ O $IterableIterator<any>$ O O O $any$ O $any$ O $NotificationActions.markAllAsRead$ O $void$ O O O
import { BotInfo , isChatFile , isTranscriptFile , NotificationType , SharedConstants } from 's' ; import { newNotification } from 's' ; import { IFileService } from 's' ; import { ComponentClass } from 's' ; import { ForkEffect , put , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { DialogService } from 's' ; import { beginAdd } from 's' ; import { editResource , OPEN_CONTEXT_MENU_FOR_RESOURCE , OPEN_RESOURCE , OPEN_RESOURCE_SETTINGS , RENAME_RESOURCE , ResourcesAction , } from 's' ; export class ResourcesSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * openContextMenuForResource ( action < IFileService > ) < any > { const menuItems = [ { label : 's' , id : 0 } , { label : 's' , id : 0 } , { label : 's' , id : 0 } ] ; const result = yield ResourcesSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . DisplayContextMenu , menuItems ) ; switch ( result . id ) { case 0 : yield ResourcesSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . OpenFileLocation , action . payload . path ) ; break ; case 0 : yield put ( editResource ( action . payload ) ) ; break ; case 0 : yield * ResourcesSagas . deleteFile ( action ) ; break ; default : break ; } } public static * deleteFile ( action < IFileService > ) < any > { const { name , path } = action . payload ; const { ShowMessageBox , UnlinkFile } = SharedConstants . Commands . Electron ; const result = yield ResourcesSagas . commandService . remoteCall ( ShowMessageBox , true , { type : 's' , title : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; if ( result ) { yield ResourcesSagas . commandService . remoteCall ( UnlinkFile , path ) ; } } public static * doRename ( action < IFileService > ) { const { payload } = action ; const { ShowMessageBox , RenameFile } = SharedConstants . Commands . Electron ; if ( ! payload . name ) { return ResourcesSagas . commandService . remoteCall ( ShowMessageBox , true , { type : 's' , title : 's' , buttons : [ 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; } yield ResourcesSagas . commandService . remoteCall ( RenameFile , payload ) ; yield put ( editResource ( null ) ) ; } public static * doOpenResource ( action < IFileService > ) < any > { const { OpenChatFile , OpenTranscript } = SharedConstants . Commands . Emulator ; const { TrackEvent } = SharedConstants . Commands . Telemetry ; const { path , name } = action . payload ; if ( isChatFile ( path ) ) { yield ResourcesSagas . commandService . call ( OpenChatFile , path , true ) ; ResourcesSagas . commandService . remoteCall ( TrackEvent , 's' ) . catch ( _e => void 0 ) ; } else if ( isTranscriptFile ( path ) ) { yield ResourcesSagas . commandService . call ( OpenTranscript , path , name ) ; ResourcesSagas . commandService . remoteCall ( TrackEvent , 's' , { method : 's' , } ) . catch ( ) ; } } public static * launchResourcesSettingsModal ( action < { dialog : ComponentClass < any > } > ) { const result < BotInfo > = yield DialogService . showDialog ( action . payload . dialog ) ; if ( result ) { try { yield ResourcesSagas . commandService . remoteCall ( SharedConstants . Commands . Bot . PatchBotList , result . path , result ) ; } catch ( e ) { const notification = newNotification ( 's' , NotificationType . Error ) ; yield put ( beginAdd ( notification ) ) ; } } } } export function * resourceSagas ( ) < ForkEffect > { yield takeEvery ( OPEN_CONTEXT_MENU_FOR_RESOURCE , ResourcesSagas . openContextMenuForResource ) ; yield takeEvery ( RENAME_RESOURCE , ResourcesSagas . doRename ) ; yield takeEvery ( OPEN_RESOURCE , ResourcesSagas . doOpenResource ) ; yield takeEvery ( OPEN_RESOURCE_SETTINGS , ResourcesSagas . launchResourcesSettingsModal ) ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $BeginAddNotificationAction$ O O O O O O $ResourcesAction<any>$ O O O O O O O O O $any$ O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $ResourcesAction$ O $any$ O O O O O O O $complex$ O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $undefined$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O O O O $any$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $any$ O O O O O O O O O O $any$ O $IterableIterator<any>$ O $ResourcesAction<any>$ O O O O O O O O O O O O O $IterableIterator$ O $ResourcesAction$ O $any$ O O O O O O O O $any$ O $any$ O O $ResourcesAction<any>$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $ResourcesAction$ O $any$ O O O O O $any$ O O $ResourcesAction<any>$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string[]$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $ResourcesAction<any>$ O O O O O O O O O $IterableIterator$ O $ResourcesAction$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $ResourcesAction<any>$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O O O O O O O O $complex$ O $ResourcesAction$ O O $any$ O $any$ O O O O O O O O $Partial$ O $any$ O O O $DialogServiceImpl$ O $Promise<R>$ O $complex$ O $complex$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $complex$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $complex$ O O O
import { ServiceTypes } from 's' ; export const serviceTypeLabels = { [ ServiceTypes . Luis ] : 's' , [ ServiceTypes . Dispatch ] : 's' , [ ServiceTypes . QnA ] : 's' , [ ServiceTypes . AppInsights ] : 's' , [ ServiceTypes . Bot ] : 's' , [ ServiceTypes . BlobStorage ] : 's' , [ ServiceTypes . CosmosDB ] : 's' , [ ServiceTypes . Generic ] : 's' , } ;	O O $any$ O O O O O O $complex$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O
import { ServiceCodes , SharedConstants } from 's' ; import { BotConfigWithPath , CommandServiceImpl , CommandServiceInstance } from 's' ; import { BotConfigurationBase } from 's' ; import { IAzureService , IConnectedService , IGenericService , ILuisService , IQnAService , ServiceTypes , } from 's' ; import { call , ForkEffect , put , select , takeEvery , takeLatest } from 's' ; import { DialogService } from 's' ; import { serviceTypeLabels } from 's' ; import { ArmTokenData , beginAzureAuthWorkflow } from 's' ; import { ConnectedServiceAction , ConnectedServicePayload , ConnectedServicePickerPayload , LAUNCH_CONNECTED_SERVICE_EDITOR , LAUNCH_CONNECTED_SERVICE_PICKER , LAUNCH_EXTERNAL_LINK , OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , OPEN_SERVICE_DEEP_LINK , OpenAddServiceContextMenuPayload , } from 's' ; import { sortExplorerContents } from 's' ; import { SortCriteria } from 's' ; import { RootState } from 's' ; import { AzureAuthSaga } from 's' ; declare interface ServicesPayload { services : IConnectedService [ ] ; code : ServiceCodes ; } const getArmTokenFromState = ( state ) : ArmTokenData => state . azureAuth ; const geBotConfigFromState = ( state ) : BotConfigWithPath => state . bot . activeBot ; const getSortSelection = ( state ) : { [ paneldId ] : SortCriteria } => state . explorer . sortSelectionByPanelId ; export class ServicesExplorerSagas { @ CommandServiceInstance ( ) protected static commandService : CommandServiceImpl ; public static * launchConnectedServicePicker ( action < ConnectedServicePickerPayload > ) < any > { let armTokenData : ArmTokenData & number = yield select ( getArmTokenFromState ) ; if ( ! armTokenData || ! armTokenData . access_token ) { const { promptDialog , loginSuccessDialog , loginFailedDialog } = action . payload . azureAuthWorkflowComponents ; armTokenData = yield * AzureAuthSaga . getArmToken ( beginAzureAuthWorkflow ( promptDialog , { serviceType : action . payload . serviceType } , loginSuccessDialog , loginFailedDialog ) ) ; } if ( armTokenData === 0 ) { yield * ServicesExplorerSagas . launchConnectedServiceEditor ( action ) ; return ; } if ( ! armTokenData || 's' in armTokenData ) { return null ; } const pJson = JSON . parse ( atob ( armTokenData . access_token . split ( 's' ) [ 0 ] ) ) ; action . payload . authenticatedUser = pJson . upn || pJson . unique_name || pJson . name || pJson . email ; const { serviceType , progressIndicatorComponent } = action . payload ; if ( progressIndicatorComponent ) { DialogService . showDialog ( progressIndicatorComponent ) . catch ( ) ; } const payload = yield * ServicesExplorerSagas . retrieveServicesByServiceType ( serviceType ) ; if ( progressIndicatorComponent ) { DialogService . hideDialog ( ) ; } if ( payload . code !== ServiceCodes . OK || ! payload . services . length ) { const { getStartedDialog , authenticatedUser } = action . payload ; const result = yield DialogService . showDialog ( getStartedDialog , { serviceType , authenticatedUser , showNoModelsFoundContent : ! payload . services . length , } ) ; if ( result === 0 ) { yield * ServicesExplorerSagas . launchExternalLink ( action ) ; } if ( result === 0 ) { yield * ServicesExplorerSagas . launchConnectedServiceEditor ( action ) ; } } else { const servicesToAdd = yield * ServicesExplorerSagas . launchConnectedServicePickList ( action , payload . services , serviceType ) ; if ( servicesToAdd ) { const botFile = yield select ( geBotConfigFromState ) ; botFile . services . push ( ... servicesToAdd ) ; const { Bot } = SharedConstants . Commands ; yield ServicesExplorerSagas . commandService . remoteCall ( Bot . Save , botFile ) ; } } } public static * launchConnectedServicePickList ( action < ConnectedServicePickerPayload > , availableServices : IConnectedService [ ] , serviceType ) < any > { const { pickerComponent , authenticatedUser , serviceType : type } = action . payload ; let result = yield DialogService . showDialog ( pickerComponent , { availableServices , authenticatedUser , serviceType , } ) ; if ( result === 0 ) { action . payload . connectedService = BotConfigurationBase . serviceFromJSON ( { type , hostname : 's' , } as any ) ; result = yield * ServicesExplorerSagas . launchConnectedServiceEditor ( action ) ; } return result ; } public static * retrieveServicesByServiceType ( serviceType ) < any > { const armTokenData = yield select ( getArmTokenFromState ) ; if ( ! armTokenData || ! armTokenData . access_token ) { throw new Error ( 's' ) ; } const { GetConnectedServicesByType } = SharedConstants . Commands . ConnectedService ; let payload ; try { payload = yield ServicesExplorerSagas . commandService . remoteCall ( GetConnectedServicesByType , armTokenData . access_token , serviceType ) ; } catch ( e ) { payload = { services : [ ] , code : ServiceCodes . Error } ; } return payload ; } public static * openConnectedServiceDeepLink ( action < ConnectedServicePayload > ) < any > { const { connectedService } = action . payload ; switch ( connectedService . type ) { case ServiceTypes . AppInsights : return ServicesExplorerSagas . openAzureProviderDeepLink ( 's' , connectedService as IAzureService ) ; case ServiceTypes . BlobStorage : return ServicesExplorerSagas . openAzureProviderDeepLink ( 's' , connectedService as IAzureService ) ; case ServiceTypes . Bot : return ServicesExplorerSagas . openAzureProviderDeepLink ( 's' , connectedService as IAzureService ) ; case ServiceTypes . CosmosDB : return ServicesExplorerSagas . openAzureProviderDeepLink ( 's' , connectedService as IAzureService ) ; case ServiceTypes . Generic : return window . open ( ( connectedService as IGenericService ) . url ) ; case ServiceTypes . Luis : return ServicesExplorerSagas . openLuisDeepLink ( connectedService as ILuisService ) ; case ServiceTypes . QnA : return ServicesExplorerSagas . openQnaMakerDeepLink ( connectedService as IQnAService ) ; default : return window . open ( 's' ) ; } } public static * launchExternalLink ( action < ConnectedServicePayload > ) < any > { const serviceType = action . payload . serviceType ; switch ( serviceType ) { case ServiceTypes . QnA : yield call ( [ ServicesExplorerSagas . commandService , ServicesExplorerSagas . commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ; break ; case ServiceTypes . Dispatch : yield call ( [ ServicesExplorerSagas . commandService , ServicesExplorerSagas . commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ; break ; case ServiceTypes . Luis : yield call ( [ ServicesExplorerSagas . commandService , ServicesExplorerSagas . commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ; break ; default : return ; } } public static * openContextMenuForService ( action < ConnectedServicePayload > ) < any > { const menuItems = [ { label : 's' , id : 's' } , { label : 's' , id : 's' } , { label : 's' , id : 's' } , ] ; const response = yield ServicesExplorerSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . DisplayContextMenu , menuItems ) ; const { connectedService } = action . payload ; action . payload . serviceType = connectedService . type ; switch ( response . id ) { case 's' : yield * ServicesExplorerSagas . openConnectedServiceDeepLink ( action ) ; break ; case 's' : yield * ServicesExplorerSagas . launchConnectedServiceEditor ( action ) ; break ; case 's' : yield * ServicesExplorerSagas . removeServiceFromActiveBot ( connectedService ) ; break ; default : return ; } } public static * openAddConnectedServiceContextMenu ( action < OpenAddServiceContextMenuPayload > ) < any > { const { resolver } = action . payload ; const menuItems = [ { label : 's' , id : ServiceTypes . Luis } , { label : 's' , id : ServiceTypes . QnA } , { label : 's' , id : ServiceTypes . Dispatch } , { type : 's' } , { label : 's' , id : ServiceTypes . CosmosDB } , { label : 's' , id : ServiceTypes . BlobStorage } , { label : 's' , id : ServiceTypes . AppInsights } , { type : 's' } , { label : 's' , id : ServiceTypes . Generic } , ] ; const response = yield ServicesExplorerSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . DisplayContextMenu , menuItems ) ; const { id : serviceType } = response ; action . payload . serviceType = serviceType ; if ( serviceType === ServiceTypes . Generic || serviceType === ServiceTypes . AppInsights ) { yield * ServicesExplorerSagas . launchConnectedServiceEditor ( action ) ; } else { yield * ServicesExplorerSagas . launchConnectedServicePicker ( action ) ; } resolver && resolver ( ) ; } public static * openSortContextMenu ( action < ConnectedServicePayload > ) < any > { const sortSelectionByPanelId = yield select ( getSortSelection ) ; const currentSort = sortSelectionByPanelId [ action . payload . panelId ] ; const menuItems = [ { label : 's' , id : 's' , type : 's' , checked : currentSort === 's' , } , { label : 's' , id : 's' , type : 's' , checked : currentSort === 's' , } , ] ; const response = yield ServicesExplorerSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . DisplayContextMenu , menuItems ) ; yield response . id ? put ( sortExplorerContents ( action . payload . panelId , response . id ) ) : null ; } public static * removeServiceFromActiveBot ( connectedService ) < any > { const result = yield ServicesExplorerSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . ShowMessageBox , true , { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; if ( result ) { const { RemoveService } = SharedConstants . Commands . Bot ; yield ServicesExplorerSagas . commandService . remoteCall ( RemoveService , connectedService . type , connectedService . id ) ; } } public static * launchConnectedServiceEditor ( action < ConnectedServicePayload > ) < any > { const { editorComponent , authenticatedUser , connectedService , serviceType } = action . payload ; const servicesToUpdate : IConnectedService [ ] = yield DialogService . showDialog ( editorComponent , { connectedService , authenticatedUser , serviceType , } ) ; if ( servicesToUpdate ) { let i = servicesToUpdate . length ; while ( i -- ) { const service = servicesToUpdate [ i ] ; yield ServicesExplorerSagas . commandService . remoteCall ( SharedConstants . Commands . Bot . AddOrUpdateService , service . type , service ) ; } } return null ; } public static openAzureProviderDeepLink ( provider , azureService ) { const { tenantId , subscriptionId , resourceGroup , serviceName } = azureService ; const bits = [ `template` , `template` , `template` , `template` , ] ; window . open ( bits . join ( 's' ) ) ; } public static openLuisDeepLink ( luisService ) { const { appId , version , region } = luisService ; let regionPrefix ; switch ( region ) { case 's' : regionPrefix = 's' ; break ; case 's' : regionPrefix = 's' ; break ; default : regionPrefix = 's' ; break ; } const linkArray = [ 's' , `template` , 's' ] ; linkArray . push ( `template` , 's' , `template` , 's' ) ; const link = linkArray . join ( 's' ) ; window . open ( link ) ; } public static openQnaMakerDeepLink ( service ) { const { kbId } = service ; const link = `template` ; window . open ( link ) ; } } export function * servicesExplorerSagas ( ) < ForkEffect > { yield takeLatest ( LAUNCH_CONNECTED_SERVICE_PICKER , ServicesExplorerSagas . launchConnectedServicePicker ) ; yield takeLatest ( LAUNCH_CONNECTED_SERVICE_EDITOR , ServicesExplorerSagas . launchConnectedServiceEditor ) ; yield takeEvery ( LAUNCH_EXTERNAL_LINK , ServicesExplorerSagas . launchExternalLink ) ; yield takeEvery ( OPEN_SERVICE_DEEP_LINK , ServicesExplorerSagas . openConnectedServiceDeepLink ) ; yield takeEvery ( OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , ServicesExplorerSagas . openContextMenuForService ) ; yield takeEvery ( OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , ServicesExplorerSagas . openAddConnectedServiceContextMenu ) ; yield takeEvery ( OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , ServicesExplorerSagas . openSortContextMenu ) ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $complex$ O O O O O O $any$ O $AzureAuthAction<AzureAuthWorkflow>$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O $ExplorerAction<ExplorerPayload>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $ArmTokenData$ O O $RootState$ O O $any$ O $RootState$ O $AzureAuthState$ O O $any$ O O $RootState$ O O $any$ O $RootState$ O $BotState$ O $any$ O O $complex$ O O $RootState$ O O O O $string$ O O $any$ O O $RootState$ O $ExplorerState$ O $complex$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O $complex$ O $any$ O O O O $any$ O $ArmTokenData$ O O O O O $complex$ O O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O $complex$ O $complex$ O O O $any$ O $IterableIterator<any>$ O $AzureAuthAction<AzureAuthWorkflow>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O $any$ O O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O O O O O O $complex$ O O O $complex$ O O O O O O O $any$ O $JSON$ O $any$ O $complex$ O $complex$ O $string$ O $complex$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O O $any$ O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $Promise<any>$ O O O O O $ServicesPayload$ O O O $any$ O $IterableIterator<any>$ O $any$ O O O O $any$ O O $DialogServiceImpl$ O $void$ O O O O O O $ServicesPayload$ O $any$ O $any$ O $any$ O O $ServicesPayload$ O $any[]$ O $number$ O O O O $any$ O $string$ O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O $undefined$ O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $any$ O $string$ O $boolean$ O O $ServicesPayload$ O $any[]$ O $number$ O O O O O O $undefined$ O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O O O $undefined$ O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O O O O O $any$ O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ServicesPayload$ O $any[]$ O $any$ O O O O $any$ O O O $BotConfigWithPath$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O $any[]$ O $any$ O O O $ServiceTypes$ O O O O O O O $any$ O $string$ O $any$ O $any$ O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O $undefined$ O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $any[]$ O $string$ O $any$ O O O O O O $undefined$ O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O $undefined$ O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O O $undefined$ O O O O O $IterableIterator$ O $ServiceTypes$ O O O O O O $ArmTokenData$ O O $any$ O $ArmTokenData$ O O O O O $ArmTokenData$ O O $ArmTokenData$ O $string$ O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $ServicesPayload$ O O O $ServicesPayload$ O O $any$ O $any$ O $any$ O $any$ O $ArmTokenData$ O $string$ O $any$ O O O O O $any$ O O $ServicesPayload$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O O O O $ServicesPayload$ O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O O $any$ O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O $complex$ O $Window)$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $void$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $void$ O $any$ O $any$ O O O O O $complex$ O $Window)$ O O O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $any$ O $any$ O $any$ O O O $undefined$ O $any$ O O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O $any$ O $IterableIterator<any>$ O $any$ O O O O O O O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O O $Function$ O O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $OpenAddServiceContextMenuPayload$ O O $complex$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O O O $string$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O $undefined$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $OpenAddServiceContextMenuPayload$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O O O O O O O $any$ O $IterableIterator<any>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O O O $Function$ O $Function$ O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O $undefined$ O O $any$ O $complex$ O O O $any$ O $undefined$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O $any$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O $any$ O O O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $undefined$ O $any$ O $any$ O $ExplorerAction<ExplorerPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $string$ O $undefined$ O $any$ O O O O O O O O O $IterableIterator$ O $IConnectedService$ O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O $undefined$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $IterableIterator$ O $ConnectedServiceAction$ O $any$ O O O O O O O O $any$ O $string$ O $any$ O $any$ O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any[]$ O $any$ O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $any$ O $string$ O $any$ O O O O O O $any[]$ O O O $number$ O $any[]$ O $number$ O O O $number$ O O O O $any$ O $any[]$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O $string$ O $IAzureService$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string[]$ O O O O O O O O O O O O $complex$ O $Window)$ O $string[]$ O $string$ O O O O O O O O $void$ O $ILuisService$ O O O O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O $any$ O O O O O $string$ O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O $string[]$ O O O O O O O O O $string[]$ O $number$ O O O O O O O O O O O $string$ O $string[]$ O $string$ O O O O $complex$ O $Window)$ O $string$ O O O O O $void$ O $IQnAService$ O O O O $any$ O O $any$ O O $string$ O O O $complex$ O $Window)$ O $string$ O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O
import { BotInfo } from 's' ; import { Action } from 's' ; export const OPEN_CONTEXT_MENU_FOR_BOT = 's' ; export interface WelcomePageAction < T > extends Action { payload : T ; } export function openContextMenuForBot ( bot ) < BotInfo > { return { type : OPEN_CONTEXT_MENU_FOR_BOT , payload : bot , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $WelcomePageAction$ O $BotInfo$ O O $any$ O O O O $string$ O O O $any$ O $any$ O O O O
import { BotInfo , newNotification , SharedConstants } from 's' ; import { ForkEffect , put , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { beginAdd } from 's' ; import { OPEN_CONTEXT_MENU_FOR_BOT , WelcomePageAction } from 's' ; export class WelcomePageSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * openContextMenuForBot ( action < BotInfo > ) < any > { const menuItems = [ { label : 's' , id : 0 } , { label : 's' , id : 0 } , { label : 's' , id : 0 } , ] ; const result = yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . DisplayContextMenu , menuItems ) ; switch ( result . id ) { case 0 : yield * WelcomePageSagas . moveBotToNewLocation ( action . payload ) ; break ; case 0 : yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . OpenFileLocation , action . payload . path ) ; break ; case 0 : yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Bot . RemoveFromBotList , action . payload . path ) ; break ; default : break ; } } public static * moveBotToNewLocation ( bot ) < any > { const newPath = yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . ShowSaveDialog , { defaultPath : bot . path , buttonLabel : 's' , nameFieldLabel : 's' , filters : [ { extensions : [ 's' ] } ] , } ) ; if ( ! newPath ) { return ; } try { const { path : oldPath } = bot ; bot . path = newPath ; yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Electron . RenameFile , { path : oldPath , newPath , } ) ; yield WelcomePageSagas . commandService . remoteCall ( SharedConstants . Commands . Bot . PatchBotList , oldPath , bot ) ; } catch ( e ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; yield put ( beginAdd ( notification ) ) ; } } } export function * welcomePageSagas ( ) < ForkEffect > { yield takeEvery ( OPEN_CONTEXT_MENU_FOR_BOT , WelcomePageSagas . openContextMenuForBot ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $BeginAddNotificationAction$ O O O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $WelcomePageAction$ O $any$ O O O O O O O $complex$ O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $undefined$ O $any$ O O O O O O O $any$ O $IterableIterator<any>$ O $WelcomePageAction<any>$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $WelcomePageAction<any>$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $WelcomePageAction<any>$ O $any$ O $any$ O O O O O O O O O O O O O $IterableIterator$ O $BotInfo$ O O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $complex$ O O O $string[]$ O O O O O O O O O O O O O $undefined$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $undefined$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O
export const debounce = function ( closure : ( args ? : any [ ] | any ) => any , timeout = 0 ) { let lastTick = 0 ; return function ( ... args : any [ ] ) { if ( Date . now ( ) - lastTick > timeout ) { lastTick = Date . now ( ) ; return closure ( ... args ) ; } } ; } ;	O O $any$ O O O $any$ O O $any$ O O O O O O O O O O O $number$ O O O O O $number$ O O O O O O O $any[]$ O O O O O O O O $DateConstructor$ O $number$ O O O $number$ O $number$ O O $number$ O $DateConstructor$ O $number$ O O O O $any$ O O $any[]$ O O O O O O O
export function expandFlatTree ( flattened : any [ ] , delimiter = 's' ) { if ( Array . isArray ( flattened ) ) { flattened = flattened . reduce ( ( map , path ) => { map [ path ] = path ; return map ; } , { } ) ; } return Object . keys ( flattened ) . reduce ( ( expanded , path ) => { const segments = path . split ( delimiter ) ; const filename = segments . pop ( ) ; const parent = segments . reduce ( ( p , segment ) => p [ segment ] || ( p [ segment ] = { } ) , expanded ) ; parent [ filename ] = flattened [ path ] ; return expanded ; } , { } ) ; }	O O ${}$ O $any[]$ O O O O O $string$ O O O O O O $ArrayConstructor$ O $complex$ O $any[]$ O O O $any[]$ O $any[]$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O O $ObjectConstructor$ O $complex$ O $any[]$ O O $complex$ O O ${}$ O $string$ O O O O $string[]$ O $string$ O $complex$ O $string$ O O O $string$ O $string[]$ O $string$ O O O O $any$ O $string[]$ O $complex$ O O ${}$ O $string$ O O ${}$ O $string$ O O O ${}$ O $string$ O O O O O O ${}$ O O $any$ O $string$ O O $any[]$ O $string$ O O O ${}$ O O O O O O O O
import { remote } from 's' ; export function getGlobal ( property ) { return remote . getGlobal ( property ) ; }	O O $any$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O
export function generateBotSecret ( ) { const arr = new 0 ( 0 ) ; window . crypto . getRandomValues ( arr ) ; return window . btoa ( arr . reduce ( ( str , byte ) => ( str += String . fromCharCode ( byte ) ) , 's' ) ) ; }	O O $string$ O O O O O O O O O O O O $complex$ O $Crypto$ O O O O O O O $complex$ O $complex$ O O O O O O $string$ O $number$ O O O $string$ O $StringConstructor$ O $string$ O $number$ O O O O O O O O
import { IEndpointService } from 's' ; import { Activity } from 's' ; import { ValueTypes } from 's' ; export function areActivitiesEqual ( a , b ) { if ( ! a || ! b ) { return false ; } return a . id === b . id ; } export function getActivityTargets ( activities : Activity [ ] ) : Activity [ ] { return activities . reduce ( ( targets : Activity [ ] , activity ) => { if ( activity && activity . valueType === ValueTypes . Activity ) { targets . push ( activity . value as Activity ) ; } else { targets . push ( activity ) ; } return targets ; } , [ ] ) ; } export function isSpeechEnabled ( endpoint ) { return ! ! ( endpoint && endpoint . appId && endpoint . appPassword ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O $Activity$ O $Activity$ O O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $any[]$ O $any$ O O O O $any$ O O O O $any[]$ O $complex$ O O $any[]$ O $any$ O O O $Activity$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $number$ O $any$ O O O O $any[]$ O O O O O O O O O O $boolean$ O $IEndpointService$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Electron from 's' ; import { MenuItemConstructorOptions } from 's' ; import { Activity } from 's' ; import { SharedConstants , ValueTypes , newNotification } from 's' ; import { CommandServiceImpl , CommandServiceInstance , ConversationService } from 's' ; import { IEndpointService } from 's' ; import { createCognitiveServicesSpeechServicesPonyfillFactory } from 's' ; import { createStore as createWebChatStore } from 's' ; import { call , ForkEffect , put , select , takeEvery , takeLatest } from 's' ; import { ChatAction , ChatActions , ClearLogPayload , closeDocument , DocumentIdPayload , updatePendingSpeechTokenRetrieval , webChatStoreUpdated , webSpeechFactoryUpdated , } from 's' ; import { RootState } from 's' ; import { isSpeechEnabled } from 's' ; import { ChatDocument } from 's' ; import { beginAdd } from 's' ; const getConversationIdFromDocumentId = ( state , documentId ) => { return ( state . chat . chats [ documentId ] || { conversationId : null } ) . conversationId ; } ; const getWebSpeechFactoryForDocumentId = ( state , documentId ) : ( ( ) => any ) => { return state . chat . webSpeechFactories [ documentId ] ; } ; const getEndpointServiceByDocumentId = ( state , documentId ) : IEndpointService => { const chat = state . chat . chats [ documentId ] ; return ( ( state . bot . activeBot && state . bot . activeBot . services ) || [ ] ) . find ( s => s . id === chat . endpointId ) as IEndpointService ; } ; const getChatFromDocumentId = ( state , documentId ) : any => { return state . chat . chats [ documentId ] ; } ; export class ChatSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * showContextMenuForActivity ( action < Activity > ) < any > { const { payload : activity } = action ; const menuItems = [ { label : 's' , id : 's' } , { label : 's' , id : 's' } , ] as MenuItemConstructorOptions [ ] ; const { DisplayContextMenu } = SharedConstants . Commands . Electron ; const response : { id : string } = yield call ( [ ChatSagas . commandService , ChatSagas . commandService . remoteCall ] , DisplayContextMenu , menuItems ) ; if ( ! response ) { return ; } switch ( response . id ) { case 's' : return Electron . clipboard . writeText ( ChatSagas . getTextFromActivity ( activity ) ) ; case 's' : return Electron . clipboard . writeText ( JSON . stringify ( activity , null , 0 ) ) ; default : return ; } } public static * closeConversation ( action < DocumentIdPayload > ) < any > { const conversationId = yield select ( getConversationIdFromDocumentId , action . payload . documentId ) ; const { DeleteConversation } = SharedConstants . Commands . Emulator ; const { documentId } = action . payload ; const chat = yield select ( getChatFromDocumentId , documentId ) ; if ( chat && chat . directLine ) { chat . directLine . end ( ) ; } yield put ( closeDocument ( documentId ) ) ; yield put ( webChatStoreUpdated ( documentId , null ) ) ; yield call ( [ ChatSagas . commandService , ChatSagas . commandService . remoteCall ] , DeleteConversation , conversationId ) ; } public static * newChat ( action < Partial < ChatDocument & ClearLogPayload > > ) < any > { const { documentId , resolver } = action . payload ; yield put ( webChatStoreUpdated ( documentId , createWebChatStore ( ) ) ) ; yield put ( webSpeechFactoryUpdated ( documentId , undefined ) ) ; const conversationId = yield select ( getConversationIdFromDocumentId , documentId ) ; let endpoint = yield select ( getEndpointServiceByDocumentId , documentId ) ; if ( ! endpoint ) { try { const serverUrl = yield select ( ( state ) => state . clientAwareSettings . serverUrl ) ; const endpointResponse = yield ConversationService . getConversationEndpoint ( serverUrl , conversationId ) ; if ( ! endpointResponse . ok ) { const error = yield endpointResponse . json ( ) ; throw new Error ( error . error . message ) ; } endpoint = yield endpointResponse . json ( ) ; } catch ( e ) { yield put ( beginAdd ( newNotification ( 's' + e ) ) ) ; } } if ( ! isSpeechEnabled ( endpoint ) ) { if ( resolver ) { resolver ( ) ; } return ; } yield put ( updatePendingSpeechTokenRetrieval ( true ) ) ; const existingFactory = yield select ( getWebSpeechFactoryForDocumentId , documentId ) ; const { GetSpeechToken : command } = SharedConstants . Commands . Emulator ; try { const speechAuthenticationToken < string > = ChatSagas . commandService . remoteCall ( command , endpoint . id , ! ! existingFactory ) ; const factory = yield call ( createCognitiveServicesSpeechServicesPonyfillFactory , { authorizationToken : speechAuthenticationToken , region : 's' , } ) ; yield put ( webSpeechFactoryUpdated ( documentId , factory ) ) ; } catch ( e ) { } yield put ( updatePendingSpeechTokenRetrieval ( false ) ) ; if ( resolver ) { resolver ( ) ; } } private static getTextFromActivity ( activity ) { if ( activity . valueType === ValueTypes . Command ) { return activity . value ; } else if ( activity . valueType === ValueTypes . Activity ) { return 's' in activity . value ? activity . value . text : activity . label ; } return activity . text || activity . label || 's' ; } } export function * chatSagas ( ) < ForkEffect > { yield takeEvery ( ChatActions . showContextMenuForActivity , ChatSagas . showContextMenuForActivity ) ; yield takeEvery ( ChatActions . closeConversation , ChatSagas . closeConversation ) ; yield takeLatest ( [ ChatActions . newChat , ChatActions . clearLog ] , ChatSagas . newChat ) ; }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $ChatAction<DocumentIdPayload>$ O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $ChatAction<WebChatStorePayload>$ O $ChatAction<WebSpeechFactoryPayload>$ O O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $BeginAddNotificationAction$ O O O O O $string$ O O $RootState$ O $string$ O O O O O $RootState$ O $ChatState$ O $complex$ O $string$ O O O $null$ O O O O O $string$ O O O O $any$ O O $RootState$ O $string$ O O O O O O O O O O O $RootState$ O $ChatState$ O $complex$ O $string$ O O O O O $any$ O O $RootState$ O $string$ O O $any$ O O O $ChatDocument<any>$ O $RootState$ O $ChatState$ O $complex$ O $string$ O O O O O $RootState$ O $BotState$ O $any$ O $RootState$ O $BotState$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $ChatDocument<any>$ O $string$ O O $any$ O O O O $any$ O O $RootState$ O $string$ O O O O O O $RootState$ O $ChatState$ O $complex$ O $string$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $Iterable$ O $ChatAction$ O $any$ O O O O O O O O $any$ O $any$ O O $ChatAction<any>$ O O $any[]$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $complex$ O O O O O O O $complex$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O O O O O O O O O O O O $Iterable$ O $ChatAction$ O $any$ O O O O O O O $undefined$ O O $any$ O $string$ O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O $string$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O O $undefined$ O O $any$ O $any$ O $string$ O O O O $undefined$ O $undefined$ O $any$ O O $undefined$ O $any$ O $any$ O O O O O $any$ O $ChatAction<DocumentIdPayload>$ O $string$ O O O O $any$ O $ChatAction<WebChatStorePayload>$ O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O O O O O $Iterable$ O $ChatAction$ O $any$ O $any$ O $any$ O O O O O O O O O $string$ O $Function$ O O $complex$ O $complex$ O O $any$ O $ChatAction<WebChatStorePayload>$ O $string$ O $any$ O O O O O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $string$ O $undefined$ O O O O $undefined$ O O $any$ O $string$ O $string$ O O O $IEndpointService$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O $undefined$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O O O $Response$ O O $any$ O $any$ O $undefined$ O $undefined$ O O O O O $Response$ O $boolean$ O O O $undefined$ O O $Response$ O $Promise<any>$ O O O O O $ErrorConstructor$ O $undefined$ O $any$ O $any$ O O O $any$ O O $Response$ O $Promise<any>$ O O O O O O $any$ O O O $any$ O $BeginAddNotificationAction$ O $any$ O O O $any$ O O O O O O O O O $boolean$ O $any$ O O O O O $Function$ O O $Function$ O O O O O O O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O O O O O O $string$ O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $Promise$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $undefined$ O O $any$ O $any$ O O $Promise<string>$ O $Promise<string>$ O $string$ O O O O O O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $string$ O $undefined$ O O O O O O $any$ O O O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O O O O O O O $Function$ O O $Function$ O O O O O O O $string$ O $Activity$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O $any$ O $ChatActions.showContextMenuForActivity$ O $any$ O $Iterable<any>$ O O O $any$ O $any$ O $ChatActions.closeConversation$ O $any$ O $Iterable<any>$ O O O $any$ O O $any$ O $ChatActions.newChat$ O $any$ O $ChatActions.clearLog$ O O $any$ O $Iterable<any>$ O O O
import { ForkEffect , put , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { newNotification } from 's' ; import { CommandAction , CommandActionPayload , EXECUTE_COMMAND } from 's' ; import { beginAdd } from 's' ; export class CommandSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * executeCommand ( action < CommandActionPayload > ) < any > { const { isRemote , commandName , args , resolver } = action . payload ; try { const result = isRemote ? yield CommandSagas . commandService . remoteCall ( commandName , ... args ) : yield CommandSagas . commandService . call ( commandName , ... args ) ; if ( resolver ) { resolver ( result ) ; } } catch ( e ) { const type = isRemote ? 's' : 's' ; yield put ( beginAdd ( newNotification ( `template` ) ) ) ; } } } export function * commandSagas ( ) < ForkEffect > { yield takeEvery ( EXECUTE_COMMAND , CommandSagas . executeCommand ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $CommandAction$ O $any$ O O O O O O O O $boolean$ O $string$ O $any[]$ O $Function$ O O $CommandAction<CommandActionPayload>$ O $CommandActionPayload$ O O O O $undefined$ O $boolean$ O O $any$ O $any$ O $any$ O $string$ O O $any[]$ O O O $any$ O $any$ O $any$ O $string$ O O $any[]$ O O O O $Function$ O O $Function$ O $undefined$ O O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O
import { Action } from 's' ; export enum PresentationActions { disable = 's' , enable = 's' , } export interface PresentationAction extends Action { type : PresentationActions ; } export function enable ( ) { return { type : PresentationActions . enable , } ; } export function disable ( ) { return { type : PresentationActions . disable , } ; }	O O $any$ O O O O O O $any$ O $PresentationActions.disable$ O O O $PresentationActions.enable$ O O O O O O $any$ O $any$ O $PresentationActions$ O $any$ O O O O $PresentationAction$ O O O O O $PresentationActions.enable$ O $any$ O $PresentationActions.enable$ O O O O O O $PresentationAction$ O O O O O $PresentationActions.disable$ O $any$ O $PresentationActions.disable$ O O O O
import { call , ForkEffect , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { SharedConstants } from 's' ; import { PresentationAction , PresentationActions } from 's' ; export class PresentationSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * presentationModeChanged ( action ) < any > { const enabled = action . type === PresentationActions . enable ; yield call ( [ PresentationSagas . commandService , PresentationSagas . commandService . remoteCall ] , SharedConstants . Commands . Electron . SetFullscreen , enabled ) ; } } export function * presentationSagas ( ) < ForkEffect > { yield takeEvery ( [ PresentationActions . disable , PresentationActions . enable ] , PresentationSagas . presentationModeChanged ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O $PresentationAction$ O O O O O O $boolean$ O $PresentationAction$ O $PresentationActions$ O $any$ O $PresentationActions.enable$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O O O $IterableIterator$ O O O $any$ O O O $any$ O O $any$ O $PresentationActions.disable$ O $any$ O $PresentationActions.enable$ O O $any$ O $IterableIterator<any>$ O O O
import { azureAuthSagas } from 's' ; import { botSagas } from 's' ; import { editorSagas } from 's' ; import { endpointSagas } from 's' ; import { frameworkSettingsSagas } from 's' ; import { navBarSagas } from 's' ; import { notificationSagas } from 's' ; import { resourceSagas } from 's' ; import { servicesExplorerSagas } from 's' ; import { welcomePageSagas } from 's' ; import { chatSagas } from 's' ; import { commandSagas } from 's' ; import { presentationSagas } from 's' ; export const applicationSagas = [ azureAuthSagas , botSagas , chatSagas , commandSagas , editorSagas , endpointSagas , frameworkSettingsSagas , navBarSagas , notificationSagas , presentationSagas , resourceSagas , servicesExplorerSagas , welcomePageSagas , ] ;	O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>)[]$ O O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O O O
import { AzureSettings } from 's' ; import { AZURE_LOGGED_IN_USER_CHANGED , AZURE_PERSIST_LOGIN_CHANGED , AzureAuthAction , } from 's' ; export function azureAuthSettings ( state = { } , action < string | boolean > ) { switch ( action . type ) { case AZURE_PERSIST_LOGIN_CHANGED : return { ... state , persistLogin : action . payload as boolean } ; case AZURE_LOGGED_IN_USER_CHANGED : return { ... state , signedInUser : action . payload as string } ; default : return state ; } }	O O $any$ O O O O O O O O O O $any$ O O O O O O O $AzureSettings$ O $AzureSettings$ O O O O $AzureAuthAction$ O O O O O O O O O $complex$ O $any$ O O O O O O O O $any$ O $boolean$ O $complex$ O $complex$ O O O O O O O O O O $any$ O $string$ O $complex$ O $complex$ O O O O O O O $any$ O O O
import { ClientAwareSettings } from 's' ; import { Action } from 's' ; export const CLIENT_AWARE_SETTINGS_CHANGED = 's' ; export declare type ClientAwareSettingsActionsType = 's' ; export interface ClientAwareSettingsActions extends Action { type : ClientAwareSettingsActionsType ; payload : ClientAwareSettings ; } export function clientAwareSettingsChanged ( settings ) { return { type : CLIENT_AWARE_SETTINGS_CHANGED , payload : settings , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $ClientAwareSettingsActions$ O $ClientAwareSettings$ O O O O O O O O $any$ O $any$ O O O O
import { ClientAwareSettings } from 's' ; import { CLIENT_AWARE_SETTINGS_CHANGED , ClientAwareSettingsActions } from 's' ; export function clientAwareSettings ( state = { } as any , action ) { if ( action . type === CLIENT_AWARE_SETTINGS_CHANGED ) { return { ... state , ... action . payload } ; } return state ; }	O O $any$ O O O O O O O O $any$ O O O O O O $ClientAwareSettings$ O $ClientAwareSettings$ O O O O O O $ClientAwareSettingsActions$ O O O O $ClientAwareSettingsActions$ O O O O O O O O O $any$ O O $ClientAwareSettingsActions$ O $any$ O O O O $any$ O O
import { DialogAction , DialogActions } from 's' ; export interface DialogState { showing : boolean ; } const DEFAULT_STATE = { showing : false , } ; export function dialog ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case DialogActions . setShowing : { state = setShowing ( action . payload . showing , state ) ; break ; } default : break ; } return state ; } export function setShowing ( showing , _state ) { return { showing } ; }	O O $any$ O $any$ O O O O O O $any$ O $boolean$ O O O O O $DialogState$ O O $false$ O O O O O O O $DialogState$ O $DialogState$ O $DialogState$ O $DialogAction$ O O O O $SetShowingDialogAction$ O $DialogActions$ O O O $any$ O $DialogActions.setShowing$ O O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O $complex$ O $boolean$ O $DialogState$ O O O O O O O O O O O $DialogState$ O O O O $DialogState$ O $boolean$ O $DialogState$ O O O O $boolean$ O O O
import { frameworkDefault , FrameworkSettings } from 's' ; import { FrameworkAction , FrameworkActionType } from 's' ; export function framework ( state = frameworkDefault , action < FrameworkSettings > ) { switch ( action . type ) { case FrameworkActionType . SET_FRAMEWORK : return { ... state , ... action . payload } ; default : return state ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $FrameworkSettings$ O $any$ O $FrameworkAction$ O $any$ O O O O O $FrameworkAction<any>$ O $FrameworkActionType$ O O O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O O O O $any$ O O $FrameworkAction<any>$ O $any$ O O O O O $any$ O O O
import { SharedConstants } from 's' ; import { NavBarAction , NavBarActions } from 's' ; export interface NavBarState { selection : string ; } const DEFAULT_STATE = { selection : SharedConstants . NavBarItems . NAVBAR_BOT_EXPLORER , } ; export function navBar ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case NavBarActions . select : { state = { ... state , selection : action . payload . selection , } ; break ; } default : break ; } return state ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O O O $NavBarState$ O O $any$ O $any$ O $any$ O $any$ O O O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $NavBarAction$ O O O O $SelectNavBarAction$ O $NavBarActions$ O O O $any$ O $NavBarActions.select$ O O $NavBarState$ O O O $NavBarState$ O $string$ O $SelectNavBarAction$ O $complex$ O $string$ O O O O O O O O O O O O $NavBarState$ O O
import { NotificationAction , NotificationActions } from 's' ; export interface NotificationState { allIds : string [ ] ; } const DEFAULT_STATE = { allIds : [ ] , } ; export function notification ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case NotificationActions . finishAdd : { const { id : idToAdd } = action . payload . notification ; let allIds ; if ( ! state . allIds . some ( id => id === idToAdd ) ) { allIds = [ ... state . allIds , idToAdd ] ; } else { allIds = state . allIds ; } state = { allIds , } ; break ; } case NotificationActions . finishRemove : { const { id : idToRemove } = action . payload ; const allIds = state . allIds . filter ( id => id !== idToRemove ) ; state = { allIds , } ; break ; } case NotificationActions . finishClear : { state = { allIds : [ ] , } ; break ; } default : break ; } return state ; } export default notification ;	O O $any$ O $any$ O O O O O O $any$ O $string[]$ O O O O O O O $NotificationState$ O O $undefined[]$ O O O O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $NotificationAction$ O O O O $NotificationAction$ O $NotificationActions$ O O O $any$ O $NotificationActions.finishAdd$ O O O O $any$ O $any$ O O $FinishAddNotificationAction$ O $complex$ O $any$ O O $any$ O O O O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O O O $any$ O O O $NotificationState$ O $string[]$ O $any$ O O O O O $any$ O $NotificationState$ O $string[]$ O O $NotificationState$ O O $any$ O O O O O O O $any$ O $NotificationActions.finishRemove$ O O O O $string$ O $string$ O O $FinishRemoveNotificationAction$ O $complex$ O O $string[]$ O $NotificationState$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O $NotificationState$ O O $string[]$ O O O O O O O $any$ O $NotificationActions.finishClear$ O O $NotificationState$ O O $undefined[]$ O O O O O O O O O O O O O O O $NotificationState$ O O O O $NotificationState$ O
import { PresentationAction , PresentationActions } from 's' ; export interface PresentationState { enabled : boolean ; } const DEFAULT_STATE = { enabled : false , } ; export const presentation = ( state = DEFAULT_STATE , action ) : PresentationState => { switch ( action . type ) { case PresentationActions . disable : state = setEnabled ( false , state ) ; break ; case PresentationActions . enable : state = setEnabled ( true , state ) ; break ; default : break ; } return state ; } ; function setEnabled ( enabled , state ) { const newState = { ... state } ; newState . enabled = enabled ; return newState ; }	O O $any$ O $any$ O O O O O O $any$ O $boolean$ O O O O O $PresentationState$ O O $false$ O O O O O O O $PresentationState$ O O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O O O O $PresentationAction$ O $PresentationActions$ O O O $any$ O $PresentationActions.disable$ O $PresentationState$ O $PresentationState$ O O O $PresentationState$ O O O O O $any$ O $PresentationActions.enable$ O $PresentationState$ O $PresentationState$ O O O $PresentationState$ O O O O O O O O O O $PresentationState$ O O O O $PresentationState$ O $boolean$ O $PresentationState$ O O O $complex$ O O O $PresentationState$ O O $complex$ O $boolean$ O $boolean$ O O $complex$ O O
import { CANCEL_CURRENT_PROCESS , ProgressIndicatorAction , ProgressIndicatorPayload , UPDATE_PROGRESS_INDICATOR , } from 's' ; export interface ProgressIndicatorState { progress : number ; label : string ; canceled : boolean ; } export const initialState = { progress : 0 , label : 's' , canceled : false , } ; export function progressIndicator ( state = initialState , action < ProgressIndicatorPayload > ) { switch ( action . type ) { case UPDATE_PROGRESS_INDICATOR : { const { label , progress } = action . payload ; return { ... state , label , progress } ; } case CANCEL_CURRENT_PROCESS : return { ... state , canceled : true } ; default : return state ; } }	O O O O $any$ O $any$ O O O O O O O O O $any$ O $number$ O O O $string$ O O O $boolean$ O O O O O O $ProgressIndicatorState$ O O $number$ O O O $string$ O O O $false$ O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $ProgressIndicatorAction$ O $any$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O O O O O O O $string$ O $number$ O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorPayload$ O O O O $ProgressIndicatorState$ O $string$ O $number$ O O O O O O O O O $ProgressIndicatorState$ O $true$ O O O O O O O $ProgressIndicatorState$ O O O
import { Action } from 's' ; export const SET_OPEN_URLS = 's' ; export interface ProtocolAction < P > extends Action { type : ProtocolActionType ; payload : P ; } export interface ProtocolOpenUrlsPayload { openUrl ? : string ; } export declare type ProtocolActionType = 's' ; export function setOpenUrl ( openUrl ) < ProtocolOpenUrlsPayload > { return { type : SET_OPEN_URLS , payload : { openUrl } , } ; }	O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $P$ O $any$ O O O O $any$ O $string$ O O O O O O O O $any$ O O O O O $ProtocolAction$ O $string$ O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O
import { ProtocolAction , ProtocolOpenUrlsPayload , SET_OPEN_URLS } from 's' ; export interface ProtocolState { openUrls ? : string [ ] ; } const DEFAULT_STATE = { openUrls : [ ] , } ; export function protocol ( state = DEFAULT_STATE , action < ProtocolOpenUrlsPayload > ) { switch ( action . type ) { case SET_OPEN_URLS : { const { openUrls } = state ; return { openUrls : [ ... openUrls , action . payload . openUrl ] } ; } default : return state ; } }	O O $any$ O $any$ O O O O O O O O $any$ O $string[]$ O O O O O O O O $ProtocolState$ O O $undefined[]$ O O O O O O O O $ProtocolState$ O $ProtocolState$ O $ProtocolState$ O $ProtocolAction$ O $any$ O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O O O O O $string[]$ O O $ProtocolState$ O O O $string[]$ O O O $string[]$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolOpenUrlsPayload$ O $string$ O O O O O O O $ProtocolState$ O O O
export const ADD_SAVED_BOT_URL = 's' ; export type SavedBotUrlsActionType = 's' ; export interface SavedBotUrlsAction < P > { type : SavedBotUrlsActionType ; payload : P ; } export type SavedBotUrlsActionPayload = string ; export function addSavedBotUrl ( url ) < string > { return { type : ADD_SAVED_BOT_URL , payload : url , } ; }	O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $P$ O $any$ O O O O $any$ O O O O O $SavedBotUrlsAction$ O $string$ O O O O O O O O O O O $string$ O $string$ O O O O
import { ADD_SAVED_BOT_URL , SavedBotUrlsAction , SavedBotUrlsActionPayload } from 's' ; interface BotUrl { url : string ; lastAccessed : string ; } export function savedBotUrls ( state : BotUrl [ ] = [ ] , action < SavedBotUrlsActionPayload > ) : BotUrl [ ] { switch ( action . type ) { case ADD_SAVED_BOT_URL : { const foundAtIndex = state . findIndex ( element => element . url === action . payload ) ; if ( foundAtIndex === - 0 ) { state . push ( { url : action . payload , lastAccessed : new Date ( ) . toUTCString ( ) } ) ; } else { state [ foundAtIndex ] . lastAccessed = new Date ( ) . toUTCString ( ) ; } if ( state . length > 0 ) { state . sort ( ( prev , curr ) => { return new Date ( curr . lastAccessed ) > new Date ( prev . lastAccessed ) ? 0 : - 0 ; } ) ; } break ; } default : break ; } return state ; }	O O O O $any$ O $any$ O O O O O $any$ O $string$ O O O $string$ O O O O O O $BotUrl[]$ O $BotUrl[]$ O $any$ O O O O O O $SavedBotUrlsAction$ O $any$ O O O $any$ O O O O O $SavedBotUrlsAction<string>$ O O O O O O O O O $number$ O $BotUrl[]$ O $number$ O $BotUrl$ O $BotUrl$ O $string$ O $SavedBotUrlsAction<string>$ O $string$ O O O O $number$ O O O O O $BotUrl[]$ O $number$ O O $string$ O $SavedBotUrlsAction<string>$ O $string$ O $string$ O O $DateConstructor$ O O O $string$ O O O O O O O O $BotUrl[]$ O $number$ O O $string$ O O $DateConstructor$ O O O $string$ O O O O O O $BotUrl[]$ O $number$ O O O O $BotUrl[]$ O $BotUrl[]$ O O $BotUrl$ O $BotUrl$ O O O O O $DateConstructor$ O $BotUrl$ O $string$ O O O $DateConstructor$ O $BotUrl$ O $string$ O O O O O O O O O O O O O O O O O O O O $BotUrl[]$ O O
export const SWITCH_THEME = 's' ; export declare type ThemeType = 's' ; export interface ThemeAction < T > { type : ThemeType ; payload : T ; } export interface SwitchThemePayload { themeName : string ; themeComponents : string [ ] ; } export function switchTheme ( themeName , themeComponents : string [ ] ) < SwitchThemePayload > { return { type : SWITCH_THEME , payload : { themeName , themeComponents } , } ; }	O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O $string[]$ O O O O O O O O $ThemeAction$ O $string$ O $string[]$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O $string[]$ O O O O O
import { SWITCH_THEME , SwitchThemePayload , ThemeAction } from 's' ; export interface ThemeState { themeName : string ; themeComponents : string [ ] ; } const initialState = { themeName : null , themeComponents : [ ] , } ; export function theme ( state = initialState , action < SwitchThemePayload > ) { switch ( action . type ) { case SWITCH_THEME : return { ... state , ... action . payload } ; default : return state ; } }	O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O $string[]$ O O O O O O O $ThemeState$ O O $null$ O O O $undefined[]$ O O O O O O O O $ThemeState$ O $ThemeState$ O $ThemeState$ O $ThemeAction$ O $any$ O O O O O $ThemeAction<SwitchThemePayload>$ O O O O O O O O O O $ThemeState$ O O $ThemeAction<SwitchThemePayload>$ O $SwitchThemePayload$ O O O O O $ThemeState$ O O O
import { UpdateStatus } from 's' ; export const SET_UPDATE_STATUS = 's' ; export type UpdateActionType = 's' ; export interface UpdateAction < P > { type : UpdateActionType ; payload : P ; } export type UpdateActionPayload = UpdateStatus ; export function setUpdateStatus ( status ) < UpdateStatus > { return { type : SET_UPDATE_STATUS , payload : status , } ; }	O O $any$ O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $P$ O $any$ O O O O $any$ O $any$ O O O $UpdateAction$ O $UpdateStatus$ O O $any$ O O O O O O O O $any$ O $any$ O O O O
import { UpdateStatus } from 's' ; import { UpdateAction , UpdateActionPayload , SET_UPDATE_STATUS } from 's' ; const DEFAULT_STATE = { status : UpdateStatus . Idle , } ; export interface UpdateState { status : UpdateStatus ; } export function update ( state = DEFAULT_STATE , action < UpdateActionPayload > ) { switch ( action . type ) { case SET_UPDATE_STATUS : return { ... state , status : action . payload } ; default : return state ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $UpdateState$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $UpdateState$ O $UpdateState$ O $UpdateState$ O $UpdateAction$ O $any$ O O O O O $UpdateAction<any>$ O O O O O O O O O O $UpdateState$ O $any$ O $UpdateAction<any>$ O $any$ O O O O O $UpdateState$ O O O
import { User } from 's' ; import { Action } from 's' ; export const SET_CURRENT_USER = 's' ; export const ADD_USERS = 's' ; export const REMOVE_USERS = 's' ; export interface UserAction < P > extends Action { type : UserActionType ; payload : P ; } export interface UserPayload { user ? : User ; users ? : User [ ] ; } export declare type UserActionType = 's' | 's' | 's' ; export function addUsers ( users : User [ ] ) < UserPayload > { return { type : ADD_USERS , payload : { users } , } ; } export function removeUsers ( users : User [ ] ) < UserPayload > { return { type : REMOVE_USERS , payload : { users } , } ; } export function setCurrentUser ( user ) < UserPayload > { return { type : SET_CURRENT_USER , payload : { user } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $UserActionType$ O $any$ O $P$ O $any$ O O O O $any$ O $any$ O O $any$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O $UserAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O O O $complex$ O O $any[]$ O O O O O O O $UserAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O O O $complex$ O O $any[]$ O O O O O O O $UserAction$ O $User$ O O $any$ O O O O O O O O $complex$ O O $any$ O O O O O
import { UserSettings } from 's' ; import { ADD_USERS , SET_CURRENT_USER , UserAction , UserPayload } from 's' ; export function users ( state = { } , action < UserPayload > ) { switch ( action . type ) { case SET_CURRENT_USER : { const usersById = { ... state . usersById } ; const { user } = action . payload ; usersById [ user . id ] = user ; return { currentUserId : user . id , usersById } ; } case ADD_USERS : { const newUsersById = { ... state . usersById } ; for ( const i in action . payload . users ) { const user = action . payload . users [ i ] ; if ( newUsersById . hasOwnProperty ( user . id ) ) { continue ; } newUsersById [ user . id ] = user ; } return { ... state , usersById : newUsersById } ; } default : return state ; } }	O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $UserSettings$ O O O O $UserAction$ O $any$ O O O O O $UserAction<UserPayload>$ O $UserActionType$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $UserAction<UserPayload>$ O $UserPayload$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $string$ O $UserAction<UserPayload>$ O $UserPayload$ O $any[]$ O O O $any$ O $UserAction<UserPayload>$ O $UserPayload$ O $any[]$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O
import { WindowStateSettings } from 's' ; import { Action } from 's' ; export const REMEMBER_THEME = 's' ; export const REMEMBER_BOUNDS = 's' ; export const REMEMBER_ZOOM_LEVEL = 's' ; export const SET_AVAILABLE_THEMES = 's' ; export interface WindowStateAction < P > extends Action { type : WindowStateActionType ; payload ? : P ; } export declare type WindowStateActionType = | 's' | 's' | 's' | 's' | 's' ; export declare type WindowStatePayload = | RememberZoomLevelPayload | RememberBoundsPayload | RememberThemePayload | SetAvailableThemesPayload ; export interface RememberThemePayload { theme ? : string ; } export interface RememberBoundsPayload { displayId ? : number ; top ? : number ; left ? : number ; width ? : number ; height ? : number ; } export interface RememberZoomLevelPayload { zoomLevel ? : number ; } export interface SetAvailableThemesPayload { availableThemes ? : { name : string ; href : string } [ ] ; } export function rememberTheme ( theme ) < RememberThemePayload > { return { type : REMEMBER_THEME , payload : { theme , } , } ; } export function rememberBounds ( state ) < RememberBoundsPayload > { return { type : REMEMBER_BOUNDS , payload : state , } ; } export function rememberZoomLevel ( state ) < RememberZoomLevelPayload > { return { type : REMEMBER_ZOOM_LEVEL , payload : state , } ; } export function setAvailableThemes ( themes : { name : string ; href : string } [ ] ) < SetAvailableThemesPayload > { return { type : SET_AVAILABLE_THEMES , payload : { availableThemes : themes , } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $WindowStateActionType$ O $any$ O $P$ O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O O O O O O $any$ O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O O O O $any$ O $number$ O O O O O O O $any$ O $complex$ O O O $string$ O O O $string$ O O O O O O O O O $WindowStateAction$ O $string$ O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O $WindowStateAction$ O $WindowStateSettings$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $WindowStateAction$ O $WindowStateSettings$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $WindowStateAction$ O $complex$ O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O $complex$ O O O O O O
import { windowStateDefault , WindowStateSettings } from 's' ; import { REMEMBER_BOUNDS , REMEMBER_THEME , REMEMBER_ZOOM_LEVEL , RememberBoundsPayload , RememberThemePayload , RememberZoomLevelPayload , SetAvailableThemesPayload , WindowStateAction , WindowStatePayload , SET_AVAILABLE_THEMES , } from 's' ; export function windowState ( state = windowStateDefault , action < WindowStatePayload > ) { switch ( action . type ) { case REMEMBER_BOUNDS : { const bounds = action . payload as RememberBoundsPayload ; return { ... state , displayId : bounds . displayId , top : bounds . top , left : bounds . left , width : bounds . width , height : bounds . height , } ; } case REMEMBER_ZOOM_LEVEL : { const { zoomLevel } = action . payload as RememberZoomLevelPayload ; return { ... state , zoomLevel } ; } case REMEMBER_THEME : { const { theme } = action . payload as RememberThemePayload ; return { ... state , theme } ; } case SET_AVAILABLE_THEMES : { const { availableThemes } = action . payload as SetAvailableThemesPayload ; return { ... state , availableThemes } ; } default : return state ; } }	O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $WindowStateSettings$ O $any$ O $WindowStateAction$ O $any$ O O O O O $WindowStateAction<WindowStatePayload>$ O $WindowStateActionType$ O O O O O O O $RememberBoundsPayload$ O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O O O O O O O O O O $number$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $number$ O O O O O O O O O $string$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $string$ O O O O O O O O O $complex$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $complex$ O O O O O O $any$ O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { applyMiddleware , createStore , combineReducers , Store } from 's' ; import { ipcRenderer } from 's' ; import sagaMiddlewareFactory from 's' ; import { Settings , ClientAwareSettings , FrameworkSettings } from 's' ; import { forwardToMain } from 's' ; import { applicationSagas } from 's' ; import { AzureAuthState , azureAuth , azureAuthSettings , bot , BotState , chat , clientAwareSettings , dialog , editor , explorer , framework , navBar , notification , presentation , progressIndicator , protocol , ProtocolState , resources , savedBotUrls , theme , update , users , windowState , ChatState , DialogState , EditorState , ExplorerState , NavBarState , NotificationState , PresentationState , ProgressIndicatorState , ResourcesState , ThemeState , UpdateState , } from 's' ; export interface RootState { azureAuth ? : AzureAuthState ; bot ? : BotState ; chat ? : ChatState ; clientAwareSettings ? : ClientAwareSettings ; dialog ? : DialogState ; editor ? : EditorState ; explorer ? : ExplorerState ; framework ? : FrameworkSettings ; navBar ? : NavBarState ; notification ? : NotificationState ; presentation ? : PresentationState ; progressIndicator ? : ProgressIndicatorState ; protocol ? : ProtocolState ; resources ? : ResourcesState ; settings ? : Settings ; theme ? : ThemeState ; update ? : UpdateState ; } const DEFAULT_STATE = { } ; function initStore ( ) < RootState > { const settingsReducer = combineReducers < Settings > ( { azure : azureAuthSettings , framework , savedBotUrls , windowState , users , } ) ; const sagaMiddleware = sagaMiddlewareFactory ( ) ; const _store < RootState > = createStore ( combineReducers ( { azureAuth , bot , chat , clientAwareSettings , dialog , editor , explorer , framework , navBar , notification , presentation , progressIndicator , protocol , resources , settings : settingsReducer , theme , update , } ) , DEFAULT_STATE , applyMiddleware ( forwardToMain , sagaMiddleware ) ) ; applicationSagas . forEach ( saga => sagaMiddleware . run ( saga ) ) ; ipcRenderer . on ( 's' , ( _ev , action ) => { action = { ... action , meta : { doNotForward : true } } ; _store . dispatch ( action ) ; } ) ; return _store ; } export const store = initStore ( ) ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $IterableIterator<any>)[]$ O O O O O O $any$ O $AzureAuthState$ O $any$ O $BotState$ O $any$ O O O $any$ O $DialogState$ O O O $ExplorerState$ O $any$ O $NavBarState$ O $NotificationState$ O $PresentationState$ O $ProgressIndicatorState$ O $ProtocolState$ O $any$ O $ResourcesState$ O $BotUrl[]$ O $ThemeState$ O $UpdateState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $AzureAuthState$ O O $any$ O $BotState$ O O $any$ O $ChatState$ O O $any$ O $any$ O O $any$ O $DialogState$ O O $any$ O $EditorState<any>$ O O $any$ O $ExplorerState$ O O $any$ O $any$ O O $any$ O $NavBarState$ O O $any$ O $NotificationState$ O O $any$ O $PresentationState$ O O $any$ O $ProgressIndicatorState$ O O $any$ O $ProtocolState$ O O $any$ O $ResourcesState$ O O $any$ O $any$ O O $any$ O $ThemeState$ O O $any$ O $UpdateState$ O O $any$ O O O ${}$ O O O O O $Store$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Store$ O $any$ O O $any$ O $any$ O O $AzureAuthState$ O $BotState$ O O O $any$ O $DialogState$ O O O $ExplorerState$ O $any$ O $NavBarState$ O $NotificationState$ O $PresentationState$ O $ProgressIndicatorState$ O $ProtocolState$ O $ResourcesState$ O $any$ O $any$ O $ThemeState$ O $UpdateState$ O O O O ${}$ O $any$ O $any$ O $any$ O O O $IterableIterator<any>)[]$ O $void$ O $IterableIterator<any>$ O $any$ O $any$ O $IterableIterator<any>$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O
import * as Constants from 's' ; import { store } from 's' ; import * as EditorActions from 's' ; import { Editor } from 's' ; export function hasNonGlobalTabs ( tabGroups ? : { [ editorKey ] : Editor } ) { tabGroups = tabGroups || store . getState ( ) . editor . editors ; let count = 0 ; for ( const key in tabGroups ) { if ( tabGroups [ key ] ) { count += Object . keys ( tabGroups [ key ] . documents ) . map ( documentId => tabGroups [ key ] . documents [ documentId ] ) . filter ( document => ! document . isGlobal ) . length ; } } return count ; } export function getTabGroupForDocument ( documentId , tabGroups ? : { [ editorKey ] : Editor } ) { tabGroups = tabGroups || store . getState ( ) . editor . editors ; for ( const key in tabGroups ) { if ( tabGroups [ key ] && tabGroups [ key ] . documents ) { if ( tabGroups [ key ] . documents [ documentId ] ) { return key ; } } } return undefined ; } export function getOtherTabGroup ( tabGroup ) { return tabGroup === Constants . EDITOR_KEY_PRIMARY ? Constants . EDITOR_KEY_SECONDARY : Constants . EDITOR_KEY_PRIMARY ; } export function showWelcomePage ( ) { store . dispatch ( EditorActions . open ( { contentType : Constants . CONTENT_TYPE_WELCOME_PAGE , documentId : Constants . DOCUMENT_ID_WELCOME_PAGE , isGlobal : true , } ) ) ; } export function showMarkdownPage ( markdown , label , onLine ) { store . dispatch ( EditorActions . open ( { contentType : Constants . CONTENT_TYPE_MARKDOWN , documentId : Constants . DOCUMENT_ID_MARKDOWN_PAGE , isGlobal : true , meta : { markdown , label , onLine } , } ) ) ; } export function tabGroupHasDocuments ( tabGroup ) { return ! ! Object . keys ( tabGroup . documents ) . length ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $number$ O $complex$ O O O O $string$ O O $any$ O O O $complex$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O O $number$ O $ObjectConstructor$ O $complex$ O $complex$ O $string$ O O $complex$ O O $U[]$ O $string$ O $complex$ O $string$ O O $complex$ O $string$ O O O $complex$ O $Document<any>$ O O $Document<any>$ O $boolean$ O O $number$ O O O O $number$ O O O O $string$ O $string$ O $complex$ O O O O $string$ O O $any$ O O O $complex$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O $complex$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O $string$ O O O O O $undefined$ O O O O $string$ O $string$ O O O $string$ O $any$ O O O $any$ O O O $any$ O O O O O O $void$ O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O $any$ O O O $true$ O O O O O O O O O O $void$ O $string$ O $string$ O $boolean$ O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O $any$ O O O $true$ O O O $complex$ O O $string$ O $string$ O $boolean$ O O O O O O O O O $boolean$ O $Editor$ O O O O O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O $number$ O O
import { deepCopySlow , SharedConstants } from 's' ; import { DirectLine } from 's' ; import { Activity } from 's' ; import { EmulatorMode } from 's' ; import { BotAction } from 's' ; import { EditorAction , EditorActions } from 's' ; import { getOtherTabGroup , tabGroupHasDocuments } from 's' ; export interface EditorState < M = any > { activeEditor ? : string ; draggingTab ? : boolean ; editors ? : { [ editorKey ] : Editor < M > } ; docsWithPendingChanges ? : string [ ] ; } export interface Editor < M = any > { activeDocumentId ? : string ; documents ? : { [ documentId ] : Document < M > } ; tabOrder ? : string [ ] ; recentTabs ? : string [ ] ; } export interface Document < M = any > { activities : Activity [ ] ; botId : string ; conversationId : string ; contentType : string ; directLine : DirectLine ; dirty ? : boolean ; documentId ? : string ; fileName ? : string ; filePath ? : string ; inMemory ? : boolean ; isGlobal ? : boolean ; meta ? : M ; mode : EmulatorMode ; ui ? : DocumentUI ; userId : string ; } export interface DocumentUI { horizontalSplitter : SplitterSize [ ] ; verticalSplitter : SplitterSize [ ] ; } export interface SplitterSize { absolute : boolean ; percentage : number ; } const DEFAULT_STATE = { activeEditor : SharedConstants . EDITOR_KEY_PRIMARY , draggingTab : false , editors : { [ SharedConstants . EDITOR_KEY_PRIMARY ] : getNewEditor ( ) , [ SharedConstants . EDITOR_KEY_SECONDARY ] : getNewEditor ( ) , } , docsWithPendingChanges : [ ] , } ; export const editor = ( state = DEFAULT_STATE , action : EditorAction | BotAction ) : EditorState => { Object . freeze ( state ) ; switch ( action . type ) { case EditorActions . appendTab : { const { srcEditorKey , destEditorKey } = action . payload ; if ( srcEditorKey === destEditorKey ) { let tabOrder = [ ... state . editors [ srcEditorKey ] . tabOrder ] ; tabOrder = [ ... tabOrder . filter ( docId => docId !== action . payload . documentId ) , action . payload . documentId ] ; const editorState = { ... state . editors [ srcEditorKey ] , tabOrder , } ; state = setEditorState ( srcEditorKey , editorState , state ) ; state = setDraggingTab ( false , state ) ; break ; } const docToAppend = state . editors [ srcEditorKey ] . documents [ action . payload . documentId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . documentId ) ; const destTabOrder = [ ... state . editors [ destEditorKey ] . tabOrder , action . payload . documentId ] ; const destRecentTabs = [ ... state . editors [ destEditorKey ] . recentTabs , action . payload . documentId ] ; const destDocs = { ... state . editors [ destEditorKey ] . documents } ; destDocs [ action . payload . documentId ] = docToAppend ; const destEditor = { ... state . editors [ destEditorKey ] , documents : destDocs , recentTabs : destRecentTabs , tabOrder : destTabOrder , } ; if ( ! tabGroupHasDocuments ( srcEditor ) && srcEditorKey === SharedConstants . EDITOR_KEY_PRIMARY ) { state = setNewPrimaryEditor ( destEditor , state ) ; } else { state = setActiveEditor ( ! tabGroupHasDocuments ( srcEditor ) ? destEditorKey : state . activeEditor , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; } state = setDraggingTab ( false , state ) ; break ; } case EditorActions . close : { const { editorKey } = action . payload ; const 0 = removeDocumentFromTabGroup ( state . editors [ editorKey ] , action . payload . documentId ) ; const newPrimaryEditorKey = getOtherTabGroup ( editorKey ) ; if ( ! tabGroupHasDocuments ( 0 ) && state . editors [ newPrimaryEditorKey ] ) { const tmp = deepCopySlow ( state . editors [ newPrimaryEditorKey ] ) ; state = setNewPrimaryEditor ( tmp , state ) ; } else { state = setEditorState ( editorKey , 0 , state ) ; } break ; } case EditorActions . closeAll : { if ( action . payload . includeGlobal ) { return DEFAULT_STATE ; } else { let newState = { ... state , } ; for ( const key in state . editors ) { if ( ! state . editors . hasOwnProperty ( key ) ) { continue ; } const tabGroup = state . editors [ key ] ; if ( tabGroup ) { let newTabOrder = [ ... tabGroup . tabOrder ] ; let newRecentTabs = [ ... tabGroup . recentTabs ] ; const newDocs = { } ; Object . keys ( tabGroup . documents ) . forEach ( documentId => { const document = tabGroup . documents [ documentId ] ; if ( document . isGlobal ) { newDocs [ documentId ] = document ; } else { newTabOrder = newTabOrder . filter ( documentIdArg => documentIdArg !== documentId ) ; newRecentTabs = newRecentTabs . filter ( documentIdArg => documentIdArg !== documentId ) ; } } ) ; const newTabGroup = { activeDocumentId : newRecentTabs [ 0 ] || null , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; newState = { ... newState , editors : { ... newState . editors , [ key ] : newTabGroup , } , } ; } } newState = setDocsWithPendingChanges ( [ ] , newState ) ; state = fixupTabGroups ( newState ) ; } break ; } case EditorActions . open : { const editorKey = state . activeEditor ; const otherTabGroup = getOtherTabGroup ( editorKey ) ; if ( tabGroupHasDocuments ( state . editors [ otherTabGroup ] ) && state . editors [ otherTabGroup ] . documents [ action . payload . documentId ] ) { const recentTabs = [ ... state . editors [ otherTabGroup ] . recentTabs ] . filter ( docId => docId !== action . payload . documentId ) ; recentTabs . unshift ( action . payload . documentId ) ; const tabGroupState = { ... state . editors [ otherTabGroup ] , activeDocumentId : action . payload . documentId , recentTabs , } ; state = setEditorState ( otherTabGroup , tabGroupState , state ) ; state = setActiveEditor ( otherTabGroup , state ) ; break ; } let newTabOrder ; if ( state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { newTabOrder = [ ... state . editors [ editorKey ] . tabOrder ] ; } else { const activeDocumentId = state . editors [ state . activeEditor ] . activeDocumentId ; const activeIndex = state . editors [ editorKey ] . tabOrder . indexOf ( activeDocumentId ) ; if ( activeIndex != null && activeIndex !== - 0 ) { state . editors [ editorKey ] . tabOrder . splice ( activeIndex + 0 , 0 , action . payload . documentId ) ; newTabOrder = [ ... state . editors [ editorKey ] . tabOrder ] ; } else { newTabOrder = [ ... state . editors [ editorKey ] . tabOrder , action . payload . documentId ] ; } } const newRecentTabs = [ ... state . editors [ editorKey ] . recentTabs ] . filter ( docId => docId !== action . payload . documentId ) ; newRecentTabs . unshift ( action . payload . documentId ) ; const newDocs = deepCopySlow ( state . editors [ editorKey ] . documents ) ; if ( ! newDocs [ action . payload . documentId ] ) { newDocs [ action . payload . documentId ] = { } ; } Object . assign ( newDocs [ action . payload . documentId ] , action . payload ) ; const editorState = { ... state . editors [ editorKey ] , activeDocumentId : action . payload . documentId , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; state = setEditorState ( editorKey , editorState , state ) ; state = setActiveEditor ( editorKey , state ) ; break ; } case EditorActions . updateDocument : { const { payload : updatedDocument } : { payload : Partial < Document > } = action ; const { editors } = state ; const editorKeys = Object . keys ( editors ) ; let i = editorKeys . length ; outer : while ( i -- ) { const documents = editors [ editorKeys [ i ] ] . documents ; const documentKeys = Object . keys ( documents ) ; let j = documentKeys . length ; while ( j -- ) { const document = documents [ documentKeys [ j ] ] ; if ( document . documentId === updatedDocument . documentId ) { documents [ documentKeys [ j ] ] = { ... document , ... updatedDocument } ; break outer ; } } } state = JSON . parse ( JSON . stringify ( state ) ) ; break ; } case EditorActions . setActiveEditor : { state = setActiveEditor ( action . payload . editorKey , state ) ; break ; } case EditorActions . setActiveTab : { SharedConstants . EditorKeys . forEach ( editorKey => { if ( state . editors [ editorKey ] && state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { const recentTabs = state . editors [ editorKey ] . recentTabs . filter ( tabId => tabId !== action . payload . documentId ) ; recentTabs . unshift ( action . payload . documentId ) ; const editorState = { ... state . editors [ editorKey ] , activeDocumentId : action . payload . documentId , recentTabs , } ; state = setEditorState ( editorKey , editorState , state ) ; state = setActiveEditor ( editorKey , state ) ; } } ) ; break ; } case EditorActions . setDirtyFlag : { SharedConstants . EditorKeys . forEach ( editorKey => { if ( state . editors [ editorKey ] && state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { const newDocs = deepCopySlow ( state . editors [ editorKey ] . documents ) ; const docToSet = newDocs [ action . payload . documentId ] ; docToSet . dirty = action . payload . dirty ; const editorState = { ... state . editors [ editorKey ] , documents : newDocs , } ; state = setEditorState ( editorKey , editorState , state ) ; } } ) ; break ; } case EditorActions . splitTab : { const { srcEditorKey } = action . payload ; const { destEditorKey } = action . payload ; const docToAppend = state . editors [ srcEditorKey ] . documents [ action . payload . documentId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . documentId ) ; const destEditor = state . editors [ destEditorKey ] ? deepCopySlow ( state . editors [ destEditorKey ] ) : getNewEditor ( ) ; const destTabOrder = [ ... destEditor . tabOrder , action . payload . documentId ] ; const destRecentTabs = [ ... destEditor . recentTabs ] ; destRecentTabs . unshift ( action . payload . documentId ) ; const destDocs = deepCopySlow ( destEditor . documents ) ; destDocs [ action . payload . documentId ] = docToAppend ; destEditor . activeDocumentId = action . payload . documentId ; destEditor . documents = destDocs ; destEditor . recentTabs = destRecentTabs ; destEditor . tabOrder = destTabOrder ; state = setActiveEditor ( destEditorKey , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; state = setDraggingTab ( false , state ) ; break ; } case EditorActions . swapTabs : { const { srcEditorKey } = action . payload ; const { destEditorKey } = action . payload ; if ( srcEditorKey === destEditorKey ) { const tabOrder = [ ... state . editors [ srcEditorKey ] . tabOrder ] ; const srcTabIndex = tabOrder . findIndex ( docId => docId === action . payload . srcTabId ) ; const 0 = tabOrder . findIndex ( docId => docId === action . payload . destTabId ) ; const destTab = tabOrder [ 0 ] ; tabOrder [ 0 ] = tabOrder [ srcTabIndex ] ; tabOrder [ srcTabIndex ] = destTab ; const editorState = { ... state . editors [ srcEditorKey ] , tabOrder , } ; state = setEditorState ( srcEditorKey , editorState , state ) ; break ; } const docToSwap = state . editors [ srcEditorKey ] . documents [ action . payload . srcTabId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . srcTabId ) ; const destEditor = deepCopySlow ( state . editors [ destEditorKey ] ) ; destEditor . documents [ action . payload . srcTabId ] = docToSwap ; const destRecentTabs = [ ... destEditor . recentTabs , action . payload . srcTabId ] ; destEditor . recentTabs = destRecentTabs ; const destTabIndex = destEditor . tabOrder . findIndex ( docId => docId === action . payload . destTabId ) ; const destTabOrder = [ ... destEditor . tabOrder . splice ( 0 , destTabIndex + 0 ) , action . payload . srcTabId , ... destEditor . tabOrder , ] ; destEditor . tabOrder = destTabOrder ; if ( ! tabGroupHasDocuments ( srcEditor ) && srcEditorKey === SharedConstants . EDITOR_KEY_PRIMARY ) { state = setNewPrimaryEditor ( destEditor , state ) ; } else { state = setActiveEditor ( ! tabGroupHasDocuments ( srcEditor ) ? destEditorKey : state . activeEditor , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; } break ; } case EditorActions . toggleDraggingTab : { state = setDraggingTab ( action . payload . draggingTab , state ) ; break ; } case EditorActions . addDocPendingChange : { const docsPendingChange = [ ... state . docsWithPendingChanges . filter ( d => d !== action . payload . documentId ) , action . payload . documentId , ] ; state = setDocsWithPendingChanges ( docsPendingChange , state ) ; break ; } case EditorActions . removeDocPendingChange : { const docsPendingChange = [ ... state . docsWithPendingChanges ] . filter ( d => d !== action . payload . documentId ) ; state = setDocsWithPendingChanges ( docsPendingChange , state ) ; break ; } case EditorActions . dropTabOnLeftOverlay : { const { tabId : tabToIsolate } = action . payload ; const primary = SharedConstants . EDITOR_KEY_PRIMARY ; const secondary = SharedConstants . EDITOR_KEY_SECONDARY ; const docToIsolate = state . editors [ primary ] . documents [ tabToIsolate ] ; const primaryTabs = [ tabToIsolate ] ; const primaryDocs = { [ tabToIsolate ] : docToIsolate } ; const secondaryTabOrder = state . editors [ primary ] . tabOrder . filter ( tabId => tabId !== tabToIsolate ) ; const secondaryRecentTabs = state . editors [ primary ] . recentTabs . filter ( tabId => tabId !== tabToIsolate ) ; const secondaryDocs = state . editors [ primary ] . documents ; delete secondaryDocs [ tabToIsolate ] ; const primaryEditor = getNewEditor ( ) ; primaryEditor . activeDocumentId = tabToIsolate ; primaryEditor . documents = primaryDocs ; primaryEditor . recentTabs = primaryTabs ; primaryEditor . tabOrder = primaryTabs ; const secondaryEditor = getNewEditor ( ) ; secondaryEditor . activeDocumentId = secondaryRecentTabs [ 0 ] || null ; secondaryEditor . recentTabs = secondaryRecentTabs ; secondaryEditor . tabOrder = secondaryTabOrder ; secondaryEditor . documents = secondaryDocs ; state = setEditorState ( primary , primaryEditor , state ) ; state = setEditorState ( secondary , secondaryEditor , state ) ; break ; } default : break ; } return state ; } ; function getNewEditor ( ) { return { activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } ; } export function removeDocumentFromTabGroup ( tabGroup , documentId ) { const newTabOrder = [ ... tabGroup . tabOrder ] . filter ( docId => docId !== documentId ) ; const newRecentTabs = [ ... tabGroup . recentTabs ] . filter ( docId => docId !== documentId ) ; const newDocs = { ... tabGroup . documents } ; delete newDocs [ documentId ] ; const newActiveDocumentId = newRecentTabs [ 0 ] || null ; const newTabGroup = Object . keys ( newDocs ) . length === 0 ? getNewEditor ( ) : { ... tabGroup , activeDocumentId : newActiveDocumentId , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; return newTabGroup ; } export function setEditorState ( editorKey , editorState , state ) { const newState = deepCopySlow ( state ) ; newState . editors [ editorKey ] = editorState ; return newState ; } export function setActiveEditor ( editorKey , state ) { const newState = deepCopySlow ( state ) ; newState . activeEditor = editorKey ; return newState ; } export function setNewPrimaryEditor ( newPrimaryEditor , state ) { const newState = deepCopySlow ( state ) ; newState . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] = getNewEditor ( ) ; newState . editors [ SharedConstants . EDITOR_KEY_PRIMARY ] = newPrimaryEditor ; newState . activeEditor = SharedConstants . EDITOR_KEY_PRIMARY ; return newState ; } export function setDraggingTab ( dragging , state ) { const newState = deepCopySlow ( state ) ; newState . draggingTab = dragging ; return newState ; } export function fixupTabGroups ( state ) { if ( ! tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_PRIMARY ] ) && tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] ) ) { state = setNewPrimaryEditor ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] , state ) ; } if ( state . activeEditor === SharedConstants . EDITOR_KEY_SECONDARY && ! tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] ) ) { state = setActiveEditor ( SharedConstants . EDITOR_KEY_PRIMARY , state ) ; } return state ; } export function setDocsWithPendingChanges ( docs : string [ ] , state ) { const newState = deepCopySlow ( state ) ; newState . docsWithPendingChanges = docs ; return newState ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O $boolean$ O O O O O O $any$ O $any$ O O O O $string$ O O O O $boolean$ O O O O $complex$ O O O O $string$ O O $any$ O $any$ O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O $string$ O O O O $complex$ O O O O $string$ O O $any$ O $any$ O O O $string[]$ O O O O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O $any[]$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $boolean$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $M$ O O $any$ O $any$ O $any$ O $DocumentUI$ O O $any$ O $string$ O O O O O O $any$ O $SplitterSize[]$ O $any$ O O O $SplitterSize[]$ O $any$ O O O O O O $any$ O $boolean$ O O O $number$ O O O O O $EditorState$ O O $any$ O $any$ O $any$ O $false$ O O O $complex$ O O O $any$ O $any$ O O $Editor<any>$ O O O O $any$ O $any$ O O $Editor<any>$ O O O O O $undefined[]$ O O O O O O O O O O O $EditorState$ O $EditorState<any>$ O O O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O O O O O O $complex$ O O O $any$ O $EditorActions.appendTab$ O O O O $string$ O $string$ O O $AppendTabAction$ O $complex$ O O O $string$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $string[]$ O O O $string[]$ O $complex$ O $string$ O $string$ O $AppendTabAction$ O $complex$ O $string$ O O $AppendTabAction$ O $complex$ O $string$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $AppendTabAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $AppendTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $AppendTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $AppendTabAction$ O $complex$ O $string$ O O O $complex$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O O $complex$ O $AppendTabAction$ O $complex$ O $string$ O O $Document<any>$ O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $complex$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O O O $boolean$ O $Editor<any>$ O O $string$ O $any$ O $any$ O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O O $boolean$ O $Editor<any>$ O O $string$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $any$ O $EditorActions.close$ O O O O $string$ O O $CloseEditorAction$ O $complex$ O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $CloseEditorAction$ O $complex$ O $string$ O O O $string$ O $string$ O $string$ O O O O O $boolean$ O $Editor<any>$ O O $EditorState<any>$ O $complex$ O $string$ O O O O $Editor$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.closeAll$ O O O O $CloseAllEditorAction$ O $complex$ O $boolean$ O O O $EditorState<any>$ O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O O $string$ O $EditorState<any>$ O $complex$ O O O O O $EditorState<any>$ O $complex$ O $boolean$ O $string$ O O O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O O O $Editor<any>$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O O ${}$ O O O O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O $void$ O $string$ O O O $Document<any>$ O $Editor<any>$ O $complex$ O $string$ O O O O $Document<any>$ O $boolean$ O O ${}$ O $string$ O O $Document<any>$ O O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O O O O O $Editor$ O O $string$ O $string[]$ O O O O O O ${}$ O ${}$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $complex$ O O O $EditorState<any>$ O $complex$ O O $string$ O O $Editor<any>$ O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.open$ O O O $string$ O $EditorState<any>$ O $string$ O O $string$ O $string$ O $string$ O O O O $boolean$ O $EditorState<any>$ O $complex$ O $string$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $complex$ O $string$ O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $string[]$ O $number$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O O O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O O O O $string$ O $EditorState<any>$ O $complex$ O $EditorState<any>$ O $string$ O O $string$ O O $number$ O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $number$ O $string$ O O O O $number$ O O O $number$ O O O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $complex$ O $number$ O O O O O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $complex$ O $string$ O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $string[]$ O $number$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O O O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O O O $ObjectConstructor$ O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $OpenEditorAction$ O $Partial<Document<any>>$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O $any$ O $any$ O $string[]$ O $string[]$ O $any$ O $any$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.updateDocument$ O O O O $Partial<Document<any>>$ O $Partial<Document<any>>$ O O O $Partial<Document<any>>$ O $any$ O $any$ O O O $UpdateDocumentAction$ O O O $complex$ O O $EditorState<any>$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $number$ O $string[]$ O $number$ O $any$ O O O $number$ O O O O $complex$ O $complex$ O $string[]$ O $number$ O O O $complex$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $number$ O $string[]$ O $number$ O O O $number$ O O O O $Document<any>$ O $complex$ O $string[]$ O $number$ O O O O O $Document<any>$ O $string$ O $Partial<Document<any>>$ O $string$ O O $complex$ O $string[]$ O $number$ O O O O O $Document<any>$ O O $Partial<Document<any>>$ O O O $any$ O O O O $EditorState<any>$ O $JSON$ O $any$ O $JSON$ O $complex$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.setActiveEditor$ O O $EditorState<any>$ O $EditorState<any>$ O $SetActiveEditorAction$ O $complex$ O $string$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.setActiveTab$ O O $any$ O $any$ O $any$ O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $SetActiveTabAction$ O $complex$ O $string$ O O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $SetActiveTabAction$ O $complex$ O $string$ O O $string[]$ O $number$ O $SetActiveTabAction$ O $complex$ O $string$ O O O $complex$ O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O $SetActiveTabAction$ O $complex$ O $string$ O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $complex$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $EditorState<any>$ O O O O O O O O O O $any$ O $EditorActions.setDirtyFlag$ O O $any$ O $any$ O $any$ O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $SetDirtyFlagAction$ O $complex$ O $string$ O O O O $any$ O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O $any$ O $any$ O $SetDirtyFlagAction$ O $complex$ O $string$ O O $any$ O $any$ O $SetDirtyFlagAction$ O $complex$ O $boolean$ O O $Editor$ O O O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $any$ O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O O O O $any$ O $EditorActions.splitTab$ O O O O $string$ O O $SplitTabAction$ O $complex$ O O O $string$ O O $SplitTabAction$ O $complex$ O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $SplitTabAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $SplitTabAction$ O $complex$ O $string$ O O O $Editor$ O $EditorState<any>$ O $complex$ O $string$ O O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $Editor<any>$ O O O O $string[]$ O O O $Editor<any>$ O $string[]$ O $SplitTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $string[]$ O $number$ O $SplitTabAction$ O $complex$ O $string$ O O O $any$ O $any$ O $Editor<any>$ O $complex$ O O $any$ O $SplitTabAction$ O $complex$ O $string$ O O $Document<any>$ O $Editor<any>$ O $string$ O $SplitTabAction$ O $complex$ O $string$ O $Editor<any>$ O $complex$ O $any$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $any$ O $EditorActions.swapTabs$ O O O O $string$ O O $SwapTabsAction$ O $complex$ O O O $string$ O O $SwapTabsAction$ O $complex$ O O O $string$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $number$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $number$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $string$ O $string[]$ O $number$ O O $string[]$ O $number$ O O $string[]$ O $number$ O O $string[]$ O $number$ O O $string$ O O $complex$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $complex$ O $EditorState<any>$ O O O O O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $SwapTabsAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $SwapTabsAction$ O $complex$ O $string$ O O O $Editor$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $Editor<any>$ O $complex$ O $SwapTabsAction$ O $complex$ O $string$ O O $Document<any>$ O O $string[]$ O O O $Editor<any>$ O $string[]$ O $SwapTabsAction$ O $complex$ O $string$ O O $Editor<any>$ O $string[]$ O $string[]$ O O $number$ O $Editor<any>$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O $complex$ O O O $number$ O O O O $SwapTabsAction$ O $complex$ O $string$ O O $Editor<any>$ O $string[]$ O O O $Editor<any>$ O $string[]$ O $string[]$ O O O O $boolean$ O $Editor<any>$ O O $string$ O $any$ O $any$ O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O O $boolean$ O $Editor<any>$ O O $string$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.toggleDraggingTab$ O O $EditorState<any>$ O $EditorState<any>$ O $ToggleDraggingTabAction$ O $complex$ O $boolean$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.addDocPendingChange$ O O O $string[]$ O O O $EditorState<any>$ O $string[]$ O $complex$ O $string$ O $string$ O $AddDocPendingChangeAction$ O $complex$ O $string$ O O $AddDocPendingChangeAction$ O $complex$ O $string$ O O O $EditorState<any>$ O $EditorState<any>$ O $string[]$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.removeDocPendingChange$ O O O $string[]$ O O O $EditorState<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $RemoveDocPendingChangeAction$ O $complex$ O $string$ O O $EditorState<any>$ O $EditorState<any>$ O $string[]$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.dropTabOnLeftOverlay$ O O O O $string$ O $string$ O O $DropTabOnLeftOverlayAction$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Document<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $string$ O O O $string[]$ O O $string$ O O O $complex$ O O O $string$ O O $Document<any>$ O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O O O $Editor<any>$ O $string$ O $string$ O $Editor<any>$ O $complex$ O $complex$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O O $Editor<any>$ O $Editor<any>$ O O O $Editor<any>$ O $string$ O $string[]$ O O O O O O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $complex$ O $complex$ O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O O O O O $EditorState<any>$ O O O O $Editor$ O O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O $Editor$ O $Editor$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $string$ O O O $complex$ O O O $Editor<any>$ O $complex$ O O O $complex$ O $string$ O O O $string$ O $string[]$ O O O O O O O $Editor$ O $ObjectConstructor$ O $complex$ O $complex$ O O $number$ O O O $Editor<any>$ O O O O O $Editor<any>$ O $string$ O $string$ O $complex$ O $complex$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O $Editor<any>$ O O O O $EditorState$ O $string$ O $Editor$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $string$ O O $Editor<any>$ O O $any$ O O O O $EditorState$ O $string$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $string$ O O $any$ O O O O $EditorState$ O $Editor$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $any$ O $any$ O O $Editor<any>$ O O O $any$ O $any$ O $any$ O $any$ O O $Editor<any>$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $EditorState$ O $boolean$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $boolean$ O O $any$ O O O O $EditorState$ O $EditorState$ O O O O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O $EditorState<any>$ O O O O O $EditorState<any>$ O $string$ O $any$ O $any$ O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $any$ O $EditorState<any>$ O O O O $EditorState<any>$ O O O O $EditorState$ O $string[]$ O O O O O $EditorState$ O O O $EditorState$ O $any$ O $EditorState<any>$ O O $EditorState<any>$ O $string[]$ O $string[]$ O O $EditorState<any>$ O O
import { Document } from 's' ; export enum EditorActions { appendTab = 's' , addDocPendingChange = 's' , removeDocPendingChange = 's' , close = 's' , closeAll = 's' , dropTabOnLeftOverlay = 's' , setDirtyFlag = 's' , open = 's' , setActiveTab = 's' , setActiveEditor = 's' , splitTab = 's' , swapTabs = 's' , toggleDraggingTab = 's' , updateDocument = 's' , } export interface AppendTabAction { type : EditorActions . appendTab ; payload : { srcEditorKey : string ; destEditorKey : string ; documentId : string ; } ; } export interface CloseEditorAction { type : EditorActions . close ; payload : { editorKey : string ; documentId : string ; } ; } export interface CloseAllEditorAction { type : EditorActions . closeAll ; payload : { includeGlobal : boolean ; } ; } export interface SetDirtyFlagAction { type : EditorActions . setDirtyFlag ; payload : { documentId : string ; dirty : boolean ; } ; } export interface OpenEditorAction { type : EditorActions . open ; payload : Partial < Document > ; } export interface UpdateDocumentAction { type : EditorActions . updateDocument ; payload : Partial < Document > ; } export interface SetActiveTabAction { type : EditorActions . setActiveTab ; payload : { documentId : string ; } ; } export interface SetActiveEditorAction { type : EditorActions . setActiveEditor ; payload : { editorKey : string ; } ; } export interface SplitTabAction { type : EditorActions . splitTab ; payload : { contentType : string ; documentId : string ; srcEditorKey : string ; destEditorKey : string ; } ; } export interface SwapTabsAction { type : EditorActions . swapTabs ; payload : { srcEditorKey : string ; destEditorKey : string ; srcTabId : string ; destTabId : string ; } ; } export interface ToggleDraggingTabAction { type : EditorActions . toggleDraggingTab ; payload : { draggingTab : boolean ; } ; } export interface AddDocPendingChangeAction { type : EditorActions . addDocPendingChange ; payload : { documentId : string ; } ; } export interface RemoveDocPendingChangeAction { type : EditorActions . removeDocPendingChange ; payload : { documentId : string ; } ; } export interface DropTabOnLeftOverlayAction { type : EditorActions . dropTabOnLeftOverlay ; payload : { tabId : string ; } ; } export type EditorAction = | AppendTabAction | CloseEditorAction | CloseAllEditorAction | SetDirtyFlagAction | OpenEditorAction | UpdateDocumentAction | SetActiveTabAction | SetActiveEditorAction | SplitTabAction | SwapTabsAction | ToggleDraggingTabAction | AddDocPendingChangeAction | RemoveDocPendingChangeAction | DropTabOnLeftOverlayAction ; export function appendTab ( srcEditorKey , destEditorKey , documentId ) { return { type : EditorActions . appendTab , payload : { srcEditorKey , destEditorKey , documentId , } , } ; } export function addDocPendingChange ( documentId ) { return { type : EditorActions . addDocPendingChange , payload : { documentId , } , } ; } export function removeDocPendingChange ( documentId ) { return { type : EditorActions . removeDocPendingChange , payload : { documentId , } , } ; } export function close ( editorKey , documentId ) { return { type : EditorActions . close , payload : { editorKey , documentId , } , } ; } export function closeNonGlobalTabs ( ) { return { type : EditorActions . closeAll , payload : { includeGlobal : false , } , } ; } export function setDirtyFlag ( documentId , dirty ) { return { type : EditorActions . setDirtyFlag , payload : { documentId , dirty , } , } ; } export function open ( document < Document > ) { return { type : EditorActions . open , payload : document , } ; } export function updateDocument ( documentId , updatedDocument < Document > ) { return { type : EditorActions . updateDocument , payload : { documentId , ... updatedDocument } , } ; } export function setActiveTab ( documentId ) { return { type : EditorActions . setActiveTab , payload : { documentId , } , } ; } export function setActiveEditor ( editorKey ) { return { type : EditorActions . setActiveEditor , payload : { editorKey , } , } ; } export function splitTab ( contentType , documentId , srcEditorKey , destEditorKey ) { return { type : EditorActions . splitTab , payload : { contentType , documentId , srcEditorKey , destEditorKey , } , } ; } export function swapTabs ( srcEditorKey , destEditorKey , srcTabId , destTabId ) { return { type : EditorActions . swapTabs , payload : { srcEditorKey , destEditorKey , srcTabId , destTabId , } , } ; } export function toggleDraggingTab ( draggingTab ) { return { type : EditorActions . toggleDraggingTab , payload : { draggingTab , } , } ; } export function dropTabOnLeftOverlay ( tabId ) { return { type : EditorActions . dropTabOnLeftOverlay , payload : { tabId , } , } ; }	O O $any$ O O O O O O $any$ O $EditorActions.appendTab$ O O O $EditorActions.addDocPendingChange$ O O O $EditorActions.removeDocPendingChange$ O O O $EditorActions.close$ O O O $EditorActions.closeAll$ O O O $EditorActions.dropTabOnLeftOverlay$ O O O $EditorActions.setDirtyFlag$ O O O $EditorActions.open$ O O O $EditorActions.setActiveTab$ O O O $EditorActions.setActiveEditor$ O O O $EditorActions.splitTab$ O O O $EditorActions.swapTabs$ O O O $EditorActions.toggleDraggingTab$ O O O $EditorActions.updateDocument$ O O O O O O $any$ O $EditorActions.appendTab$ O $any$ O $EditorActions.appendTab$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.close$ O $any$ O $EditorActions.close$ O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.closeAll$ O $any$ O $EditorActions.closeAll$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $EditorActions.setDirtyFlag$ O $any$ O $EditorActions.setDirtyFlag$ O $complex$ O O $string$ O O O $boolean$ O O O O O O O O $any$ O $EditorActions.open$ O $any$ O $EditorActions.open$ O $Partial<Document<any>>$ O $any$ O $any$ O O O O O $any$ O $EditorActions.updateDocument$ O $any$ O $EditorActions.updateDocument$ O $Partial<Document<any>>$ O $any$ O $any$ O O O O O $any$ O $EditorActions.setActiveTab$ O $any$ O $EditorActions.setActiveTab$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveEditor$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.splitTab$ O $any$ O $EditorActions.splitTab$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.swapTabs$ O $any$ O $EditorActions.swapTabs$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.toggleDraggingTab$ O $any$ O $EditorActions.toggleDraggingTab$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.addDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.removeDocPendingChange$ O $any$ O $EditorActions.removeDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $complex$ O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $AppendTabAction$ O $string$ O $string$ O $string$ O O O O $EditorActions.appendTab$ O $any$ O $EditorActions.appendTab$ O $complex$ O O $string$ O $string$ O $string$ O O O O O O O O $AddDocPendingChangeAction$ O $string$ O O O O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.addDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $RemoveDocPendingChangeAction$ O $string$ O O O O $EditorActions.removeDocPendingChange$ O $any$ O $EditorActions.removeDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $CloseEditorAction$ O $string$ O $string$ O O O O $EditorActions.close$ O $any$ O $EditorActions.close$ O $complex$ O O $string$ O $string$ O O O O O O O O $CloseAllEditorAction$ O O O O O $EditorActions.closeAll$ O $any$ O $EditorActions.closeAll$ O $complex$ O O $false$ O O O O O O O O O O $SetDirtyFlagAction$ O $string$ O $boolean$ O O O O $EditorActions.setDirtyFlag$ O $any$ O $EditorActions.setDirtyFlag$ O $complex$ O O $string$ O $boolean$ O O O O O O O O $OpenEditorAction$ O $Partial$ O $any$ O O O O O $EditorActions.open$ O $any$ O $EditorActions.open$ O $Partial<Document<any>>$ O $Partial<Document<any>>$ O O O O O O $UpdateDocumentAction$ O $string$ O $Partial$ O $any$ O O O O O $EditorActions.updateDocument$ O $any$ O $EditorActions.updateDocument$ O $complex$ O O $string$ O O $Partial<Document<any>>$ O O O O O O O $SetActiveTabAction$ O $string$ O O O O $EditorActions.setActiveTab$ O $any$ O $EditorActions.setActiveTab$ O $complex$ O O $string$ O O O O O O O O $SetActiveEditorAction$ O $string$ O O O O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveEditor$ O $complex$ O O $string$ O O O O O O O O $SplitTabAction$ O $string$ O $string$ O $string$ O $string$ O O O O $EditorActions.splitTab$ O $any$ O $EditorActions.splitTab$ O $complex$ O O $string$ O $string$ O $string$ O $string$ O O O O O O O O $SwapTabsAction$ O $string$ O $string$ O $string$ O $string$ O O O O $EditorActions.swapTabs$ O $any$ O $EditorActions.swapTabs$ O $complex$ O O $string$ O $string$ O $string$ O $string$ O O O O O O O O $ToggleDraggingTabAction$ O $boolean$ O O O O $EditorActions.toggleDraggingTab$ O $any$ O $EditorActions.toggleDraggingTab$ O $complex$ O O $boolean$ O O O O O O O O $DropTabOnLeftOverlayAction$ O $string$ O O O O $EditorActions.dropTabOnLeftOverlay$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $complex$ O O $string$ O O O O O O
import { FileInfo } from 's' ; export enum FileActions { setRoot = 's' , add = 's' , remove = 's' , clear = 's' , } export function addFile ( payload ) { return { type : FileActions . add , payload , } ; } export function clear ( ) { return { type : FileActions . clear , payload : { } , } ; } export function removeFile ( path ) { return { type : FileActions . remove , payload : { path } , } ; } export function setRoot ( path ) { return { type : FileActions . setRoot , payload : { path } , } ; }	O O $any$ O O O O O O $any$ O $FileActions.setRoot$ O O O $FileActions.add$ O O O $FileActions.remove$ O O O $FileActions.clear$ O O O O O O $complex$ O $FileInfo$ O O O O $FileActions$ O $any$ O $FileActions.add$ O $any$ O O O O O O $complex$ O O O O O $FileActions$ O $any$ O $FileActions.clear$ O ${}$ O O O O O O O O O $complex$ O $string$ O O O O $FileActions$ O $any$ O $FileActions.remove$ O $complex$ O O $string$ O O O O O O O $complex$ O $string$ O O O O $FileActions$ O $any$ O $FileActions.setRoot$ O $complex$ O O $string$ O O O O O
import { getBotDisplayName , newNotification , SharedConstants } from 's' ; import { BotConfigWithPath , mergeEndpoints } from 's' ; import { IEndpointService , ServiceTypes } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import * as Constants from 's' ; import * as BotActions from 's' ; import * as EditorActions from 's' ; import * as ExplorerActions from 's' ; import * as FileActions from 's' ; import * as NavBarActions from 's' ; import { beginAdd } from 's' ; import { getActiveBot } from 's' ; import { hasNonGlobalTabs } from 's' ; import { store } from 's' ; const { Bot , Electron , Telemetry } = SharedConstants . Commands ; export class ActiveBotHelper { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; static async confirmSwitchBot ( ) < any > { if ( hasNonGlobalTabs ( ) ) { return await this . commandService . remoteCall ( Electron . ShowMessageBox , true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : 's' , type : 's' , } ) ; } else { return true ; } } static confirmCloseBot ( ) < any > { const hasTabs = hasNonGlobalTabs ( ) ; if ( hasTabs ) { return this . commandService . remoteCall ( SharedConstants . Commands . Electron . ShowMessageBox , true , { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : 's' , cancelId : 0 , } ) ; } else { return Promise . resolve ( true ) ; } } static async setActiveBot ( bot ) < void > { try { const botDirectory = await this . commandService . remoteCall < string > ( SharedConstants . Commands . Bot . SetActive , bot ) ; store . dispatch ( BotActions . setActive ( bot ) ) ; store . dispatch ( FileActions . setRoot ( botDirectory ) ) ; await Promise . all ( [ this . commandService . remoteCall ( SharedConstants . Commands . Electron . UpdateFileMenu ) , this . commandService . remoteCall ( SharedConstants . Commands . Electron . SetTitleBar , getBotDisplayName ( bot ) ) , ] ) ; } catch ( e ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; throw new Error ( errMsg ) ; } } static async closeActiveBot ( ) < void > { try { await this . commandService . remoteCall ( Bot . Close ) ; store . dispatch ( BotActions . closeBot ( ) ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Electron . SetTitleBar , 's' ) ; } catch ( err ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; } } static async botAlreadyOpen ( ) < void > { return await this . commandService . remoteCall < void > ( Electron . ShowMessageBox , true , { buttons : [ 's' ] , cancelId : 0 , defaultId : 0 , message : "s" + 's' , type : 's' , } ) ; } static async confirmAndCreateBot ( botToCreate , secret ) < void > { const result = await this . confirmSwitchBot ( ) ; if ( result ) { store . dispatch ( EditorActions . closeNonGlobalTabs ( ) ) ; try { const bot = await this . commandService . remoteCall < BotConfigWithPath > ( SharedConstants . Commands . Bot . Create , botToCreate , secret ) ; await this . setActiveBot ( botToCreate ) ; const endpoint = bot . services . find ( service => service . type === ServiceTypes . Endpoint ) as IEndpointService ; if ( endpoint ) { this . commandService . call ( SharedConstants . Commands . Emulator . NewLiveChat , endpoint ) ; } store . dispatch ( NavBarActions . select ( Constants . NAVBAR_BOT_EXPLORER ) ) ; store . dispatch ( ExplorerActions . showExplorer ( true ) ) ; } catch ( err ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; throw new Error ( errMsg ) ; } } } static browseForBotFile ( ) < any > { return this . commandService . remoteCall ( Electron . ShowOpenDialog , { buttonLabel : 's' , filters : [ { extensions : [ 's' ] , name : 's' , } , ] , properties : [ 's' ] , title : 's' , } ) ; } static async confirmAndOpenBotFromFile ( filename ? ) < any > { try { if ( ! filename ) { filename = await this . browseForBotFile ( ) ; } if ( filename ) { const activeBot = getActiveBot ( ) ; if ( activeBot && activeBot . path === filename ) { await this . commandService . call ( SharedConstants . Commands . Bot . Switch , activeBot ) ; return ; } const result = this . confirmSwitchBot ( ) ; if ( result ) { store . dispatch ( EditorActions . closeNonGlobalTabs ( ) ) ; const bot = await this . commandService . remoteCall < BotConfigWithPath > ( SharedConstants . Commands . Bot . Open , filename ) ; if ( ! bot ) { return ; } const state = store . getState ( ) ; const currentUserId = state . clientAwareSettings . users . currentUserId || state . framework . userGUID ; await this . commandService . remoteCall ( SharedConstants . Commands . Emulator . SetCurrentUser , currentUserId ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . SetActive , bot ) ; await this . commandService . call ( SharedConstants . Commands . Bot . Load , bot ) ; const numOfServices = bot . services && bot . services . length ; this . commandService . remoteCall ( Telemetry . TrackEvent , `template` , { method : 's' , numOfServices , } ) . catch ( _e => void 0 ) ; } } } catch ( err ) { throw new Error ( `template` ) ; } } static async confirmAndSwitchBots ( bot : BotConfigWithPath | string ) < any > { const currentActiveBot = getActiveBot ( ) ; const botPath = typeof bot === 's' ? bot . path : bot ; if ( currentActiveBot && currentActiveBot . path === botPath ) { try { await this . commandService . call ( SharedConstants . Commands . Emulator . NewLiveChat , currentActiveBot . services [ 0 ] ) ; } catch ( e ) { throw new Error ( `template` ) ; } return ; } console . log ( `template` ) ; try { const result = await this . confirmSwitchBot ( ) ; if ( result ) { store . dispatch ( EditorActions . closeNonGlobalTabs ( ) ) ; let newActiveBot ; if ( typeof bot === 's' ) { try { newActiveBot = await this . commandService . remoteCall < BotConfigWithPath > ( SharedConstants . Commands . Bot . Open , bot ) ; } catch ( e ) { throw new Error ( `template` ) ; } } else { newActiveBot = bot ; } await this . setActiveBot ( newActiveBot ) ; let endpoint ; const overridesArePresent = newActiveBot . overrides && newActiveBot . overrides . endpoint ; if ( overridesArePresent && newActiveBot . overrides . endpoint . id ) { endpoint = newActiveBot . services . find ( service => service . type === ServiceTypes . Endpoint && service . id === newActiveBot . overrides . endpoint . id ) as IEndpointService ; } else { endpoint = newActiveBot . services . find ( service => service . type === ServiceTypes . Endpoint ) as IEndpointService ; } if ( endpoint && overridesArePresent ) { endpoint = mergeEndpoints ( endpoint , newActiveBot . overrides . endpoint ) ; } if ( endpoint ) { await this . commandService . call ( SharedConstants . Commands . Emulator . NewLiveChat , endpoint ) ; } store . dispatch ( NavBarActions . select ( Constants . NAVBAR_BOT_EXPLORER ) ) ; store . dispatch ( ExplorerActions . showExplorer ( true ) ) ; } } catch ( e ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; throw new Error ( errMsg ) ; } } static confirmAndCloseBot ( ) < any > { const activeBot = getActiveBot ( ) ; if ( ! activeBot ) { return Promise . resolve ( ) ; } console . log ( `template` ) ; return this . confirmCloseBot ( ) . then ( result => { if ( result ) { store . dispatch ( EditorActions . closeNonGlobalTabs ( ) ) ; this . closeActiveBot ( ) . catch ( err => new Error ( err ) ) ; } } ) . catch ( err => { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; throw new Error ( errMsg ) ; } ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O $number$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $Promise$ O O O O O O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O $Promise$ O O O O O O O $number$ O $number$ O O O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $Promise$ O $BotConfigWithPath$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O $ErrorConstructor$ O $string$ O O O O O O $Promise$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotAction<{}>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O $Promise$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string[]$ O O O O O $number$ O O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O $Promise$ O $BotConfigWithPath$ O $string$ O O O O O O $any$ O O O O $Promise<any>$ O O O O O $any$ O O $any$ O $any$ O $any$ O $CloseAllEditorAction$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $Promise<void>$ O $any$ O O O $IEndpointService$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $SelectNavBarAction$ O $any$ O O O O O $any$ O $any$ O $any$ O $ExplorerAction<ExplorerPayload>$ O O O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O $ErrorConstructor$ O $string$ O O O O O O $Promise$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $complex$ O O O $string[]$ O O O O O $string$ O O O O O O O $string[]$ O O O O O $string$ O O O O O O O O O $Promise$ O $string$ $string$ O O O O O O O O O O $string$ O O $string$ O O O O $Promise<any>$ O O O O O O $string$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O O O $Promise<any>$ O O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O $CloseAllEditorAction$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $Promise$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $Console$ O $void$ O O O O O O O $any$ O O O O $Promise<any>$ O O O O O $any$ O O $any$ O $any$ O $any$ O $CloseAllEditorAction$ O O O O O $BotConfigWithPath$ O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O O O O O $Promise<void>$ O $any$ O O O $IEndpointService$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $SelectNavBarAction$ O $any$ O O O O O $any$ O $any$ O $any$ O $ExplorerAction<ExplorerPayload>$ O O O O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O $ErrorConstructor$ O $string$ O O O O O $Promise$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O $PromiseConstructor$ O $complex$ O O O O $Console$ O $void$ O O O O O O O $Promise<any>$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $CloseAllEditorAction$ O O O O O O $Promise<void>$ O O O $complex$ O $any$ O O $ErrorConstructor$ O $any$ O O O O O O O $complex$ O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O $ErrorConstructor$ O $string$ O O O O O O O
import { getBotDisplayName , SharedConstants } from 's' ; import { BotConfigWithPath , Command , CommandServiceImpl , CommandServiceInstance } from 's' ; import { IFileService } from 's' ; import { newNotification } from 's' ; import * as BotActions from 's' ; import * as FileActions from 's' ; import { chatFilesUpdated , chatsDirectoryUpdated , transcriptDirectoryUpdated , transcriptsUpdated , } from 's' ; import { pathExistsInRecentBots } from 's' ; import { store } from 's' ; import { ActiveBotHelper } from 's' ; import { beginAdd } from 's' ; const Commands = SharedConstants . Commands ; export class BotCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Commands . Bot . Switch ) protected async switchBot ( bot : BotConfigWithPath | string ) { let numOfServices ; if ( typeof bot !== 's' ) { numOfServices = bot . services && bot . services . length ; } try { await this . commandService . remoteCall ( Commands . Telemetry . TrackEvent , 's' , { method : 's' , numOfServices , } ) ; return ActiveBotHelper . confirmAndSwitchBots ( bot ) ; } catch ( e ) { await beginAdd ( newNotification ( e ) ) ; } } @ Command ( Commands . Bot . Close ) protected async closeBot ( ) { try { await ActiveBotHelper . confirmAndCloseBot ( ) ; } catch ( e ) { await beginAdd ( newNotification ( e ) ) ; } } @ Command ( Commands . Bot . OpenBrowse ) protected async browseForBotFile ( ) { try { await ActiveBotHelper . confirmAndOpenBotFromFile ( ) ; } catch ( e ) { await beginAdd ( newNotification ( e ) ) ; } } @ Command ( Commands . Bot . Load ) protected loadBot ( bot ) < any > { if ( ! pathExistsInRecentBots ( bot . path ) ) { return ActiveBotHelper . confirmAndCreateBot ( bot , 's' ) ; } return ActiveBotHelper . confirmAndSwitchBots ( bot ) ; } @ Command ( Commands . Bot . SetActive ) protected async setActiveBot ( bot , botDirectory ) { store . dispatch ( BotActions . setActive ( bot ) ) ; store . dispatch ( FileActions . setRoot ( botDirectory ) ) ; await Promise . all ( [ this . commandService . remoteCall ( Commands . Electron . UpdateFileMenu ) , this . commandService . remoteCall ( Commands . Electron . SetTitleBar , getBotDisplayName ( bot ) ) , ] ) ; } @ Command ( Commands . Bot . TranscriptFilesUpdated ) protected transcriptFilesUpdated ( transcripts : IFileService [ ] ) { store . dispatch ( transcriptsUpdated ( transcripts ) ) ; } @ Command ( Commands . Bot . ChatFilesUpdated ) protected chatFilesUpdated ( chatFiles : IFileService [ ] ) { store . dispatch ( chatFilesUpdated ( chatFiles ) ) ; } @ Command ( Commands . Bot . TranscriptsPathUpdated ) protected transcriptsPathUpdated ( path ) { store . dispatch ( transcriptDirectoryUpdated ( path ) ) ; } @ Command ( Commands . Bot . ChatsPathUpdated ) protected chatsPathUpdated ( path ) { store . dispatch ( chatsDirectoryUpdated ( path ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<string>$ O $ResourcesAction<any[]>$ O O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BeginAddNotificationAction$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $Promise<any>$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O O O O O $any$ O $Promise<any>$ O $any$ O O O O O $any$ O O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O O O $any$ O $Promise<any>$ O O O O O O $any$ O O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O O O $any$ O $Promise<any>$ O O O O O O $any$ O O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $Promise$ O $BotConfigWithPath$ O O O O O O O O $boolean$ O $any$ O $any$ O O O O $any$ O $Promise<void>$ O $any$ O O O O O O $any$ O $Promise<any>$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O $BotConfigWithPath$ O $string$ O O $any$ O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $string$ O O O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any[]$ O $any$ O O O O $any$ O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any[]$ O $any$ O O O O $any$ O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $string$ O O $any$ O $any$ O $ResourcesAction<string>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $string$ O O $any$ O $any$ O $ResourcesAction<string>$ O $string$ O O O O O
import { SharedConstants } from 's' ; import { BotConfigWithPathImpl , CommandRegistry , CommandServiceImpl , CommandServiceInstance , } from 's' ; import { combineReducers , createStore } from 's' ; import * as BotActions from 's' ; import { bot } from 's' ; import { resources } from 's' ; import { ActiveBotHelper } from 's' ; import { BotCommands } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const mockBotInfo = { path : 's' , displayName : 's' , secret : 's' , } ; const mockBot = BotConfigWithPathImpl . fromJSON ( { path : 's' , name : 's' , description : 's' , padlock : 's' , services : [ { appId : 's' , id : 's' , type : 's' , appPassword : 's' , endpoint : 's' , name : 's' , } , ] , } as any ) ; const mockStore = createStore ( combineReducers ( { bot , resources } ) , { bot : { botFiles : [ mockBotInfo ] } , } ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; describe ( 's' , ( ) => { let commandService ; let registry ; beforeAll ( ( ) => { new BotCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; it ( 's' , async ( ) => { const remoteCallArgs = [ ] ; commandService . remoteCall = async ( ... args : any [ ] ) => { remoteCallArgs . push ( args ) ; return true as any ; } ; const spy = jest . spyOn ( ActiveBotHelper , 's' ) . mockResolvedValueOnce ( true ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . Switch ) ; await handler ( { } ) ; expect ( spy ) . toHaveBeenCalledWith ( { } ) ; expect ( remoteCallArgs [ 0 ] [ 0 ] ) . toBe ( SharedConstants . Commands . Telemetry . TrackEvent ) ; expect ( remoteCallArgs [ 0 ] [ 0 ] ) . toBe ( 's' ) ; expect ( remoteCallArgs [ 0 ] [ 0 ] ) . toEqual ( { method : 's' , numOfServices : undefined , } ) ; } ) ; it ( 's' , ( ) => { const spy = jest . spyOn ( ActiveBotHelper , 's' ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . Close ) ; handler ( ) ; expect ( spy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const createSpy = jest . spyOn ( ActiveBotHelper , 's' ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . Load ) ; handler ( { } ) ; expect ( createSpy ) . toHaveBeenCalledWith ( { } , 's' ) ; } ) ; it ( 's' , ( ) => { const switchSpy = jest . spyOn ( ActiveBotHelper , 's' ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . Load ) ; handler ( { path : 's' } ) ; expect ( switchSpy ) . toHaveBeenCalledWith ( { path : 's' } ) ; } ) ; it ( 's' , async ( ) => { const remoteCallArgs = [ ] ; commandService . remoteCall = async ( ... args : any [ ] ) => { remoteCallArgs . push ( args ) ; return true as any ; } ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . SetActive ) ; await handler ( mockBot , mockBotInfo . path ) ; const state = mockStore . getState ( ) ; expect ( state . bot . activeBot ) . toEqual ( mockBot ) ; expect ( remoteCallArgs [ 0 ] ) . toEqual ( [ 's' ] ) ; expect ( remoteCallArgs [ 0 ] ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const transcriptFilesUpdated = registry . getCommand ( SharedConstants . Commands . Bot . TranscriptFilesUpdated ) ; const transcriptPathUpdated = registry . getCommand ( SharedConstants . Commands . Bot . TranscriptsPathUpdated ) ; transcriptFilesUpdated ( [ { path : 's' } ] ) ; transcriptPathUpdated ( 's' ) ; const state = mockStore . getState ( ) ; expect ( state . resources . transcripts ) . toEqual ( [ { path : 's' } ] ) ; expect ( state . resources . transcriptsPath ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const chatFilesUpdated = registry . getCommand ( SharedConstants . Commands . Bot . ChatFilesUpdated ) ; const chatPathUpdated = registry . getCommand ( SharedConstants . Commands . Bot . ChatsPathUpdated ) ; chatFilesUpdated ( [ { path : 's' } ] ) ; chatPathUpdated ( 's' ) ; const state = mockStore . getState ( ) ; expect ( state . resources . chats ) . toEqual ( [ { path : 's' } ] ) ; expect ( state . resources . chatsPath ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $BotState$ O O O O O O $ResourcesState$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $BotState$ O $ResourcesState$ O O O O $complex$ O O $complex$ O O $complex$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $CommandRegistry$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O O $any[]$ O O O O O O O $any[]$ O $number$ O $any[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any[]$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O O O O $any$ O O O O $any$ O $any[]$ O O O O O O O O $any$ O O $string$ O O O $undefined$ O $undefined$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O O $any[]$ O O O O O O O $any[]$ O $number$ O $any[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O O O O O O $any$ O $any[]$ O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; const { Electron } = SharedConstants . Commands ; export class ElectronCommands { @ Command ( Electron . ToggleDevTools ) protected toggleDevTools ( ) { window . dispatchEvent ( new Event ( 's' ) ) ; } @ Command ( Electron . UpdateAvailable ) protected emulatorUpdateAvailable ( ... args : any [ ] ) { console . log ( 's' , ... args ) ; } @ Command ( Electron . UpdateNotAvailable ) protected emulatorUpdateNotAvailable ( ) { console . log ( 's' ) ; } @ Command ( Electron . ShowAboutDialog ) protected showAboutDialog ( ) { } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $void$ O O O $complex$ O $boolean)$ O O $complex$ O O O O O O O $any$ O $any$ O $any$ O O $void$ O O $any[]$ O O O O O O $Console$ O $void$ O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O $void$ O O O $Console$ O $void$ O O O O O O $any$ O $any$ O $any$ O O $void$ O O O O O
import { newNotification , SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance , isLocalHostUrl , uniqueId } from 's' ; import { IEndpointService } from 's' ; import { Activity } from 's' ; import { Command } from 's' ; import { EmulatorMode } from 's' ; import * as Constants from 's' ; import * as ChatActions from 's' ; import * as EditorActions from 's' ; import { beginAdd } from 's' ; import { getTabGroupForDocument } from 's' ; import { store } from 's' ; const { Emulator , Telemetry : { TrackEvent } , } = SharedConstants . Commands ; export class EmulatorCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Emulator . NewLiveChat ) protected newLiveChat ( endpoint , focusExistingChat = false , conversationId , mode = 's' ) { const state = store . getState ( ) ; let documentId ; if ( focusExistingChat && state . chat . chats ) { const { chats } = state . chat ; documentId = Object . keys ( chats ) . find ( docId => { const { [ docId ] : chat } = chats ; return chat . endpointUrl === endpoint . endpoint && ( ! conversationId || chat . conversationId === conversationId ) ; } ) ; } if ( ! documentId ) { documentId = uniqueId ( ) ; const { currentUserId } = state . clientAwareSettings . users ; const customUserId = state . framework . userGUID ; const action = ChatActions . newChat ( documentId , mode , { botId : 's' , endpointId : endpoint . id , endpointUrl : endpoint . endpoint , userId : customUserId || currentUserId , conversationId , } ) ; if ( mode === 's' ) { action . payload . ui . horizontalSplitter [ 0 ] . percentage = 0 ; action . payload . ui . verticalSplitter [ 0 ] . percentage = 0 ; } store . dispatch ( action ) ; } if ( ! isLocalHostUrl ( endpoint . endpoint ) ) { this . commandService . remoteCall ( TrackEvent , 's' ) . catch ( _e => void 0 ) ; } store . dispatch ( EditorActions . open ( { contentType : mode === 's' ? Constants . CONTENT_TYPE_DEBUG : Constants . CONTENT_TYPE_LIVE_CHAT , documentId , isGlobal : false , } ) ) ; return documentId ; } @ Command ( Emulator . OpenTranscript ) protected openTranscript ( filePath , fileName , additionalData ? ) { const tabGroup = getTabGroupForDocument ( filePath ) ; const { currentUserId } = store . getState ( ) . clientAwareSettings . users ; if ( ! tabGroup ) { store . dispatch ( ChatActions . newChat ( filePath , 's' , { ... additionalData , botId : 's' , userId : currentUserId , } ) ) ; } store . dispatch ( EditorActions . open ( { contentType : Constants . CONTENT_TYPE_TRANSCRIPT , documentId : filePath , fileName , filePath , isGlobal : false , } ) ) ; } @ Command ( Emulator . PromptToOpenTranscript ) protected async promptToOpenTranscript ( ) { const dialogOptions = { title : 's' , buttonLabel : 's' , properties : [ 's' ] , filters : [ { name : 's' , extensions : [ 's' ] , } , ] , } ; try { const { ShowOpenDialog } = SharedConstants . Commands . Electron ; const filename = await this . commandService . remoteCall ( ShowOpenDialog , dialogOptions ) ; if ( filename ) { await this . commandService . call ( Emulator . OpenTranscript , filename ) ; this . commandService . remoteCall ( TrackEvent , 's' , { method : 's' , } ) . catch ( _e => void 0 ) ; } } catch ( e ) { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; store . dispatch ( beginAdd ( notification ) ) ; } } @ Command ( Emulator . ReloadTranscript ) protected reloadTranscript ( filePath , fileName , additionalData ? ) { const tabGroup = getTabGroupForDocument ( filePath ) ; const { currentUserId } = store . getState ( ) . clientAwareSettings . users ; if ( tabGroup ) { store . dispatch ( EditorActions . close ( getTabGroupForDocument ( filePath ) , filePath ) ) ; store . dispatch ( ChatActions . closeDocument ( filePath ) ) ; } store . dispatch ( ChatActions . newChat ( filePath , 's' , { ... additionalData , botId : 's' , userId : currentUserId , } ) ) ; store . dispatch ( EditorActions . open ( { contentType : Constants . CONTENT_TYPE_TRANSCRIPT , documentId : filePath , filePath , fileName , isGlobal : false , } ) ) ; } @ Command ( Emulator . OpenChatFile ) protected async openChatFile ( filePath , reload ? ) { try { const { activities , fileName , } : { activities : Activity [ ] ; fileName : string ; } = await this . commandService . remoteCall < any > ( Emulator . OpenChatFile , filePath ) ; if ( reload ) { await this . commandService . call ( Emulator . ReloadTranscript , filePath , fileName , { activities , inMemory : true } ) ; } else { await this . commandService . call ( Emulator . OpenTranscript , filePath , fileName , { activities , inMemory : true } ) ; } } catch ( err ) { throw new Error ( `template` ) ; } } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $BeginAddNotificationAction$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O $IEndpointService$ O $boolean$ O O O $string$ O $EmulatorMode$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $string$ O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O $string$ O O O O O $string$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $string$ O O O O O O O O O $string$ O O $string$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $complex$ O $any$ O $complex$ O $string$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O $complex$ O $complex$ O $DocumentUI$ O $SplitterSize[]$ O O O O $number$ O O O $complex$ O $complex$ O $DocumentUI$ O $SplitterSize[]$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $string$ O $false$ O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O O $void$ O $string$ O $string$ O $object$ $object$ O O O $string$ O $string$ O $string$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O $any$ O $complex$ O $string$ O O O O O $object$ O $string$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O $string$ O $string$ O $string$ O $false$ O O O O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O $complex$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $complex$ O O O $string$ O O O $string[]$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O $string$ O $object$ $object$ O O O $string$ O $string$ O $string$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $CloseEditorAction$ O $string$ O $string$ O O $string$ O O O $any$ O $any$ O $any$ O $ChatAction<DocumentIdPayload>$ O $string$ O O O O $any$ O $any$ O $any$ O $complex$ O $string$ O O O O O $object$ O $string$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O $string$ O $string$ O $string$ O $false$ O O O O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $string$ O $boolean$ $boolean$ O O O O O O $any[]$ O $string$ O O O O $any[]$ O $any$ O O O $string$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O $any[]$ O $boolean$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O $any[]$ O $boolean$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O
import { newNotification , SharedConstants } from 's' ; import { combineReducers , createStore } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { clientAwareSettingsChanged } from 's' ; import { beginAdd } from 's' ; import { bot } from 's' ; import { chat } from 's' ; import { clientAwareSettings } from 's' ; import { editor } from 's' ; import { framework } from 's' ; import { RootState } from 's' ; import { setFrameworkSettings } from 's' ; import { EmulatorCommands } from 's' ; const mockEndpoint = { endpoint : 's' , } ; let mockStore ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let commandService ; let registry ; beforeAll ( ( ) => { new EmulatorCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockStore = createStore ( combineReducers ( { bot , chat , clientAwareSettings , editor , framework } ) ) ; mockStore . dispatch ( clientAwareSettingsChanged ( { users : { currentUserId : 's' } , cwd : 's' , locale : 's' , serverUrl : 's' , debugMode : 0 , appPath : 's' , savedBotUrls : [ ] , } ) ) ; } ) ; it ( 's' , ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Emulator . NewLiveChat ) ; const documentId = handler ( mockEndpoint , false ) ; const state = mockStore . getState ( ) ; const documentIds = Object . keys ( state . chat . chats ) ; const document = state . chat . chats [ documentId ] ; expect ( document . userId ) . toEqual ( 's' ) ; expect ( documentIds . length ) . toBe ( 0 ) ; expect ( state . editor . editors . primary . activeDocumentId ) . toBe ( documentId ) ; } ) ; it ( 's' , ( ) => { let state = mockStore . getState ( ) ; mockStore . dispatch ( setFrameworkSettings ( { ... state . framework , userGUID : 's' } ) ) ; const handler = registry . getCommand ( SharedConstants . Commands . Emulator . NewLiveChat ) ; const documentId = handler ( mockEndpoint , false ) ; state = mockStore . getState ( ) ; const document = state . chat . chats [ documentId ] ; expect ( document . userId ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Emulator . NewLiveChat ) ; const documentId = handler ( mockEndpoint , false ) ; const secondDocumentId = handler ( { endpoint : 's' , } ) ; expect ( mockStore . getState ( ) . editor . editors . primary . activeDocumentId ) . toBe ( secondDocumentId ) ; handler ( mockEndpoint , true ) ; expect ( mockStore . getState ( ) . editor . editors . primary . activeDocumentId ) . toBe ( documentId ) ; } ) ; it ( 's' , ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Emulator . OpenTranscript ) ; const filePath = 's' ; handler ( filePath , filePath ) ; const state = mockStore . getState ( ) ; expect ( state . chat . chats [ filePath ] ) . toBeTruthy ( ) ; expect ( state . editor . editors . primary . activeDocumentId ) . toBe ( filePath ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Emulator . PromptToOpenTranscript ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( 's' ) ; const callSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( null ) ; await handler ( ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( 's' , { buttonLabel : 's' , filters : [ { extensions : [ 's' ] , name : 's' } ] , properties : [ 's' ] , title : 's' , } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Telemetry . TrackEvent , 's' , { method : 's' , } ) ; expect ( callSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Emulator . PromptToOpenTranscript ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( 's' ) ; const callSpy = jest . spyOn ( commandService , 's' ) . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) ; const dispatchSpy = jest . spyOn ( mockStore , 's' ) ; const errMsg = `template` ; const notification = newNotification ( errMsg ) ; const action = beginAdd ( notification ) ; action . payload . notification . timestamp = jasmine . any ( Number ) as any ; action . payload . notification . id = jasmine . any ( String ) as any ; await handler ( ) ; expect ( remoteCallSpy ) . toHaveBeenCalled ( ) ; expect ( callSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( action ) ; jest . restoreAllMocks ( ) ; } ) ; it ( 's' , async ( ) => { const openTranscriptHandler = registry . getCommand ( SharedConstants . Commands . Emulator . OpenTranscript ) ; await openTranscriptHandler ( 's' ) ; let state = mockStore . getState ( ) ; expect ( state . chat . changeKey ) . toBe ( 0 ) ; const handler = registry . getCommand ( SharedConstants . Commands . Emulator . ReloadTranscript ) ; await handler ( 's' ) ; state = mockStore . getState ( ) ; expect ( state . chat . changeKey ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { const callSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const openChatFileHandler = registry . getCommand ( SharedConstants . Commands . Emulator . OpenChatFile ) ; await openChatFileHandler ( 's' , true ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . OpenChatFile , 's' ) ; expect ( callSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . ReloadTranscript , 's' , undefined , { activities : undefined , inMemory : true , } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $ClientAwareSettingsActions$ O O O O O O $BeginAddNotificationAction$ O O O O O O $BotState$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $FrameworkAction<any>$ O O O O O O $any$ O O O O O $complex$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $CommandRegistry$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $BotState$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $ClientAwareSettingsActions$ O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $undefined[]$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O O $RootState$ O $any$ O $any$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $RootState$ O $ChatState$ O $complex$ O O O $ChatDocument<any>$ O $RootState$ O $ChatState$ O $complex$ O $any$ O O $any$ O $ChatDocument<any>$ O $string$ O O $any$ O O O O $any$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $RootState$ O $any$ O $any$ O O O $any$ O $any$ O $FrameworkAction<any>$ O O O $RootState$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O $RootState$ O $any$ O $any$ O O O O $ChatDocument<any>$ O $RootState$ O $ChatState$ O $complex$ O $any$ O O $any$ O $ChatDocument<any>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $complex$ O O O $string[]$ O O O O O $string$ O O O O O $string[]$ O O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O $BeginAddNotificationAction$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O O $BeginAddNotificationAction$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O $BeginAddNotificationAction$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $undefined$ O O $undefined$ O $undefined$ O $boolean$ O O O O O O O O O O O O
import { isChatFile , isTranscriptFile , SharedConstants } from 's' ; import { Command } from 's' ; import * as EditorActions from 's' ; import * as FileActions from 's' ; import { store } from 's' ; const { File } = SharedConstants . Commands ; export class FileCommands { @ Command ( File . Add ) protected addFileToStore ( payload ) { store . dispatch ( FileActions . addFile ( payload ) ) ; } @ Command ( File . Remove ) protected removeFileFromStore ( path ) { store . dispatch ( FileActions . removeFile ( path ) ) ; } @ Command ( File . Clear ) protected clearFileStore ( ) { store . dispatch ( FileActions . clear ( ) ) ; } @ Command ( File . Changed ) protected fileChangedOnDisk ( filename ) { if ( isChatFile ( filename ) || isTranscriptFile ( filename ) ) { store . dispatch ( EditorActions . addDocPendingChange ( filename ) ) ; } } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $void$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O O O $any$ O $string$ O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $AddDocPendingChangeAction$ O $string$ O O O O O O
import { Notification , SharedConstants } from 's' ; import { Command } from 's' ; import * as NotificationActions from 's' ; import { store } from 's' ; import { getGlobal } from 's' ; const Commands = SharedConstants . Commands . Notifications ; export class NotificationCommands { @ Command ( Commands . Add ) protected addNotificationFromMain ( notification ) { if ( ! notification ) { notification = getGlobal ( SharedConstants . NOTIFICATION_FROM_MAIN ) ; } store . dispatch ( NotificationActions . beginAdd ( notification ) ) ; } @ Command ( Commands . Remove ) protected removeNotificationFromStore ( id ) { store . dispatch ( NotificationActions . beginRemove ( id ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $void$ O $Notification$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O $any$ O $any$ O $any$ O $BeginRemoveNotificationAction$ O $string$ O O O O O
import { ClientAwareSettings , SharedConstants } from 's' ; import { Command } from 's' ; import { clientAwareSettingsChanged } from 's' ; import { store } from 's' ; const { Settings } = SharedConstants . Commands ; export class SettingsCommands { @ Command ( Settings . ReceiveGlobalSettings ) protected async receiveGlobalSettings ( settings ) { store . dispatch ( clientAwareSettingsChanged ( settings ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $ClientAwareSettings$ O O $any$ O $any$ O $ClientAwareSettingsActions$ O $any$ O O O O O
import { newNotification , SharedConstants } from 's' ; import { Command , CommandServiceImpl , CommandServiceInstance , StartConversationParams } from 's' ; import { ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import * as Constants from 's' ; import { azureArmTokenDataChanged , beginAzureAuthWorkflow , invalidateArmToken , } from 's' ; import * as EditorActions from 's' ; import * as NavBarActions from 's' ; import { ProgressIndicatorPayload , updateProgressIndicator } from 's' ; import { switchTheme } from 's' ; import { showMarkdownPage , showWelcomePage } from 's' ; import { AzureAuthState } from 's' ; import { store } from 's' ; import { AzureLoginFailedDialogContainer , AzureLoginPromptDialogContainer , AzureLoginSuccessDialogContainer , BotCreationDialogContainer , DialogService , OpenBotDialogContainer , OpenUrlDialogContainer , PostMigrationDialogContainer , ProgressIndicatorContainer , SecretPromptDialogContainer , UpdateAvailableDialogContainer , UpdateUnavailableDialogContainer , DataCollectionDialogContainer , } from 's' ; import { openBotViaUrlAction } from 's' ; import { beginAdd } from 's' ; import { OpenBotDialogProps } from 's' ; const { UI , Telemetry } = SharedConstants . Commands ; export class UiCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( UI . ShowWelcomePage ) protected showWelcomePageDispatcher ( ) { return showWelcomePage ( ) ; } @ Command ( UI . ShowMarkdownPage ) protected async showMarkdownPage ( urlOrMarkdown , label , windowRef = window ) { let markdown = 's' ; let { onLine } = windowRef . navigator ; if ( ! onLine ) { return showMarkdownPage ( markdown , label , onLine ) ; } try { new URL ( urlOrMarkdown ) ; const bytes = await this . commandService . remoteCall < ArrayBuffer > ( SharedConstants . Commands . Electron . FetchRemote , urlOrMarkdown ) ; markdown = new TextDecoder ( ) . decode ( bytes ) ; } catch ( e ) { if ( typeof e === 's' && ( 's' + e ) . includes ( 's' ) ) { onLine = false ; } else { markdown = urlOrMarkdown ; } } return showMarkdownPage ( markdown , label , onLine ) ; } @ Command ( UI . ShowBotCreationDialog ) protected async showBotCreationPage ( ) { return await DialogService . showDialog ( BotCreationDialogContainer ) ; } @ Command ( UI . ShowOpenBotDialog ) protected async showOpenBotDialog ( isDebug = false ) < void > { return await DialogService . showDialog < ComponentClass , void > ( OpenBotDialogContainer , { isDebug , } as OpenBotDialogProps ) ; } @ Command ( UI . ShowSecretPromptDialog ) protected async showSecretPromptDialog ( ) { return await DialogService . showDialog ( SecretPromptDialogContainer ) ; } @ Command ( UI . SwitchNavBarTab ) protected switchNavBar ( tabName ) { store . dispatch ( NavBarActions . select ( tabName ) ) ; } @ Command ( UI . ShowAppSettings ) protected showAppSettings ( ) { const { CONTENT_TYPE_APP_SETTINGS , DOCUMENT_ID_APP_SETTINGS } = Constants ; store . dispatch ( EditorActions . open ( { contentType : CONTENT_TYPE_APP_SETTINGS , documentId : DOCUMENT_ID_APP_SETTINGS , isGlobal : true , meta : null , } ) ) ; } @ Command ( UI . SwitchTheme ) protected switchTheme ( themeName , themeHref ) { const linkTags = document . querySelectorAll < HTMLLinkElement > ( 's' ) ; const themeTag = document . getElementById ( 's' ) as HTMLLinkElement ; if ( themeTag ) { themeTag . href = themeHref ; } const themeComponents = Array . prototype . map . call ( linkTags , link => link . href ) ; store . dispatch ( switchTheme ( themeName , themeComponents ) ) ; this . commandService . remoteCall ( Telemetry . TrackEvent , 's' , { themeName , } ) . catch ( ) ; } @ Command ( UI . SignInToAzure ) protected signIntoAzure ( serviceType ) { return new Promise ( resolve => { store . dispatch ( beginAzureAuthWorkflow ( AzureLoginPromptDialogContainer , { serviceType } , AzureLoginSuccessDialogContainer , AzureLoginFailedDialogContainer , resolve ) ) ; } ) ; } @ Command ( UI . ArmTokenReceivedOnStartup ) protected armTokenReceivedOnStartup ( azureAuth ) { store . dispatch ( azureArmTokenDataChanged ( azureAuth . access_token ) ) ; } @ Command ( UI . InvalidateAzureArmToken ) protected invalidateAzureArmToken ( ) { store . dispatch ( invalidateArmToken ( ) ) ; } @ Command ( UI . ShowPostMigrationDialog ) protected showPostMigrationDialog ( ) { return DialogService . showDialog ( PostMigrationDialogContainer ) ; } @ Command ( UI . ShowProgressIndicator ) protected async showProgressIndicator ( props ? ) { try { return await DialogService . showDialog ( ProgressIndicatorContainer , props ) ; } catch ( e ) { beginAdd ( newNotification ( e ) ) ; } } @ Command ( UI . UpdateProgressIndicator ) protected updateProgressIndicator ( value ) { store . dispatch ( updateProgressIndicator ( value ) ) ; } @ Command ( UI . ShowUpdateAvailableDialog ) protected async showUpdateAvailableDialog ( version = 's' ) { try { return await DialogService . showDialog ( UpdateAvailableDialogContainer , { version , } ) ; } catch ( e ) { beginAdd ( newNotification ( e ) ) ; } } @ Command ( UI . ShowUpdateUnavailableDialog ) protected async showUpdateUnavailableDialog ( ) { try { return await DialogService . showDialog ( UpdateUnavailableDialogContainer ) ; } catch ( e ) { beginAdd ( newNotification ( e ) ) ; } } @ Command ( UI . ShowOpenUrlDialog ) protected async showOpenUrlDialog ( url ) { return await DialogService . showDialog ( OpenUrlDialogContainer , { url } ) ; } @ Command ( UI . OpenBotViaUrl ) protected openBotViaURL ( conversationParams ) { store . dispatch ( openBotViaUrlAction ( conversationParams ) ) ; } @ Command ( UI . ShowDataCollectionDialog ) protected showDataCollectionDialog ( ) { return DialogService . showDialog ( DataCollectionDialogContainer ) ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthAction<void>$ O O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O O O O O $ThemeAction<SwitchThemePayload>$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $DialogServiceImpl$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $BotAction<any>$ O O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $void$ O O O O $void$ O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $string$ O $string$ O $complex$ O $complex$ O O O $string$ O O O O O $boolean$ O O $complex$ O $Navigator$ O O O O $boolean$ O O O $void$ O $string$ O $string$ O $boolean$ O O O O O O $complex$ O $string$ O O O $any$ O O O O $any$ O $any$ O $ArrayBufferConstructor$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O O $complex$ O O O $string$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O $boolean$ O O O O O $boolean$ O O O O O O $string$ O $string$ O O O O $void$ O $string$ O $string$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise$ O $boolean$ O O O O O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O $any$ O O $boolean$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O $any$ O $any$ O $any$ O $SelectNavBarAction$ O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O O O $string$ O O O $true$ O O O $null$ O O O O O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O $string$ O O O $NodeListOf<HTMLLinkElement>$ O $Document$ O O O $complex$ O O O O O O $HTMLLinkElement$ O $Document$ O $HTMLElement$ O O O O $complex$ O O O $HTMLLinkElement$ O O $HTMLLinkElement$ O $string$ O $string$ O O O $any$ O $ArrayConstructor$ O $any[]$ O $U[]$ O $any$ O $NodeListOf<HTMLLinkElement>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $ThemeAction<SwitchThemePayload>$ O $string$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $Promise<unknown>$ O $ServiceTypes$ O O O O $PromiseConstructor$ O $void$ O O $any$ O $any$ O $AzureAuthAction<AzureAuthWorkflow>$ O $any$ O O $any$ O O $any$ O $any$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O O $void$ O $AzureAuthState$ O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O $AzureAuthState$ O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $any$ O $AzureAuthAction<void>$ O O O O O O $any$ O $any$ O $any$ O O $Promise<any>$ O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O $ProgressIndicatorPayload$ $ProgressIndicatorPayload$ O O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O $ProgressIndicatorPayload$ O O O O O $any$ O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $void$ O $ProgressIndicatorPayload$ O O $any$ O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorPayload$ O O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O $string$ O O O O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $string$ O O O O O O O $any$ O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O O O O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O O $any$ O O $BeginAddNotificationAction$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O $string$ O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O $StartConversationParams$ O O $any$ O $any$ O $BotAction<any>$ O $any$ O O O O O $any$ O $any$ O $any$ O O $Promise<any>$ O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; import { store } from 's' ; const Commands = SharedConstants . Commands . Misc ; export class MiscCommands { @ Command ( Commands . GetStoreState ) protected getStoreState ( ) { return store . getState ( ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O
import { BotCommands } from 's' ; import { ElectronCommands } from 's' ; import { EmulatorCommands } from 's' ; import { FileCommands } from 's' ; import { NotificationCommands } from 's' ; import { SettingsCommands } from 's' ; import { UiCommands } from 's' ; import { MiscCommands } from 's' ; export const commands = [ new BotCommands ( ) , new ElectronCommands ( ) , new EmulatorCommands ( ) , new FileCommands ( ) , new NotificationCommands ( ) , new SettingsCommands ( ) , new UiCommands ( ) , new MiscCommands ( ) , ] ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O
import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { SharedConstants } from 's' ; import { combineReducers , createStore } from 's' ; import { clientAwareSettings } from 's' ; import { store } from 's' ; import { clientAwareSettingsChanged } from 's' ; import { SettingsCommands } from 's' ; const mockStore = createStore ( combineReducers ( { clientAwareSettings } ) ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let commandService ; let registry ; beforeAll ( ( ) => { new SettingsCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; it ( 's' , ( ) => { const command = registry . getCommand ( SharedConstants . Commands . Settings . ReceiveGlobalSettings ) ; const dispatchSpy = jest . spyOn ( store , 's' ) ; command ( { } ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( clientAwareSettingsChanged ( { } as any ) ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $CommandRegistry$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $ClientAwareSettingsActions$ O O O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { CONTENT_TYPE_APP_SETTINGS , DOCUMENT_ID_APP_SETTINGS } from 's' ; import { AzureAuthAction , AzureAuthWorkflow , invalidateArmToken } from 's' ; import { EditorActions , OpenEditorAction } from 's' ; import { NavBarActions , SelectNavBarAction } from 's' ; import * as editorHelpers from 's' ; import { store } from 's' ; import { AzureLoginPromptDialogContainer , AzureLoginSuccessDialogContainer , BotCreationDialogContainer , DialogService , OpenBotDialogContainer , SecretPromptDialogContainer , } from 's' ; import { UiCommands } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const Commands = SharedConstants . Commands . UI ; describe ( 's' , ( ) => { let commandService ; let registry ; beforeAll ( ( ) => { new UiCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; it ( 's' , async ( ) => { const spy = jest . spyOn ( editorHelpers , 's' ) ; await registry . getCommand ( Commands . ShowWelcomePage ) ( ) ; expect ( spy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { const spy = jest . spyOn ( DialogService , 's' ) . mockResolvedValueOnce ( true ) ; const result = await registry . getCommand ( Commands . ShowBotCreationDialog ) ( ) ; expect ( spy ) . toHaveBeenCalledWith ( BotCreationDialogContainer ) ; expect ( result ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { const spy = jest . spyOn ( DialogService , 's' ) . mockResolvedValueOnce ( true ) ; const result = await registry . getCommand ( Commands . ShowSecretPromptDialog ) ( ) ; expect ( spy ) . toHaveBeenCalledWith ( SecretPromptDialogContainer ) ; expect ( result ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { const spy = jest . spyOn ( DialogService , 's' ) . mockResolvedValueOnce ( true ) ; const result = await registry . getCommand ( Commands . ShowOpenBotDialog ) ( ) ; expect ( spy ) . toHaveBeenCalledWith ( OpenBotDialogContainer , { isDebug : false } ) ; expect ( result ) . toBe ( true ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let arg = { } as SelectNavBarAction ; store . dispatch = action => ( ( arg as any ) = action ) ; registry . getCommand ( Commands . SwitchNavBarTab ) ( 's' ) ; expect ( arg . type ) . toBe ( NavBarActions . select ) ; expect ( arg . payload . selection ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let arg = { } as OpenEditorAction ; store . dispatch = action => ( ( arg as any ) = action ) ; registry . getCommand ( Commands . ShowAppSettings ) ( ) ; expect ( arg . type ) . toBe ( EditorActions . open ) ; expect ( arg . payload . contentType ) . toBe ( CONTENT_TYPE_APP_SETTINGS ) ; expect ( arg . payload . documentId ) . toBe ( DOCUMENT_ID_APP_SETTINGS ) ; expect ( arg . payload . isGlobal ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { let arg < AzureAuthWorkflow > = { } as AzureAuthAction < AzureAuthWorkflow > ; store . dispatch = action => ( ( arg as any ) = action ) ; registry . getCommand ( Commands . SignInToAzure ) ( ) ; expect ( arg . payload . loginSuccessDialog ) . toBe ( AzureLoginSuccessDialogContainer ) ; expect ( arg . payload . promptDialog ) . toBe ( AzureLoginPromptDialogContainer ) ; } ) ; it ( 's' , async ( ) => { let arg < void > = { } as AzureAuthAction < void > ; store . dispatch = action => ( ( arg as any ) = action ) ; registry . getCommand ( Commands . InvalidateAzureArmToken ) ( ) ; expect ( arg ) . toEqual ( invalidateArmToken ( ) ) ; } ) ; } ) ; it ( 's' , ( ) => { const remoteCallSpy = jest . spyOn ( commandService , 's' ) ; const link = document . createElement ( 's' ) ; link . id = 's' ; document . querySelector ( 's' ) . appendChild ( link ) ; registry . getCommand ( Commands . SwitchTheme ) ( 's' , 's' ) ; expect ( link . href ) . toBe ( 's' ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Telemetry . TrackEvent , 's' , { themeName : 's' , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const dispatchedActions = [ ] ; store . dispatch = action => { dispatchedActions . push ( action ) ; return action ; } ; await registry . getCommand ( Commands . ShowMarkdownPage ) ( 's' , 's' , { navigator : { onLine : false } } ) ; expect ( dispatchedActions . length ) . toBe ( 0 ) ; expect ( dispatchedActions [ 0 ] . payload . meta ) . toEqual ( { markdown : 's' , label : 's' , onLine : false , } ) ; } ) ; it ( 's' , async ( ) => { const dispatchedActions = [ ] ; store . dispatch = action => { dispatchedActions . push ( action ) ; return action ; } ; jest . spyOn ( commandService , 's' ) . mockRejectedValueOnce ( 's' ) ; await registry . getCommand ( Commands . ShowMarkdownPage ) ( 's' , 's' , { navigator : { onLine : true } } ) ; expect ( dispatchedActions . length ) . toBe ( 0 ) ; expect ( dispatchedActions [ 0 ] . payload . meta ) . toEqual ( { markdown : 's' , label : 's' , onLine : false , } ) ; } ) ; it ( 's' , async ( ) => { const dispatchedActions = [ ] ; store . dispatch = action => { dispatchedActions . push ( action ) ; return action ; } ; jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( true ) ; await registry . getCommand ( Commands . ShowMarkdownPage ) ( 's' , 's' , { navigator : { onLine : true } } ) ; expect ( dispatchedActions . length ) . toBe ( 0 ) ; expect ( dispatchedActions [ 0 ] . payload ) . toEqual ( { contentType : 's' , documentId : 's' , isGlobal : true , meta : { markdown : 's' , label : 's' , onLine : true , } , } ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $AzureAuthAction<void>$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $CommandServiceImpl$ O O $CommandRegistry$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $SelectNavBarAction$ O O O O $any$ O $any$ O $any$ O $any$ O O O $SelectNavBarAction$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $SelectNavBarAction$ O $NavBarActions$ O O $any$ O $any$ O $NavBarActions.select$ O O $any$ O $SelectNavBarAction$ O $complex$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $OpenEditorAction$ O O O O $any$ O $any$ O $any$ O $any$ O O O $OpenEditorAction$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $OpenEditorAction$ O $EditorActions.open$ O O $any$ O $any$ O $EditorActions.open$ O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $any$ O O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $any$ O O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O O $AzureAuthAction$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $AzureAuthAction<AzureAuthWorkflow>$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $any$ O O $any$ O $any$ O O $any$ O $AzureAuthAction<AzureAuthWorkflow>$ O $AzureAuthWorkflow$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $AzureAuthAction$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $AzureAuthAction<void>$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $AzureAuthAction<void>$ O O $any$ O $AzureAuthAction<void>$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $HTMLLinkElement$ O $Document$ O O O O O O $HTMLLinkElement$ O $string$ O O O $Document$ O O O O O O $T$ O $HTMLLinkElement$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $HTMLLinkElement$ O $string$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $boolean$ O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $boolean$ O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $boolean$ O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $boolean$ O O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { Command , ExtensionConfig , ExtensionInspector } from 's' ; export class Extension { public get unid ( ) : string { return this . _unid ; } public get config ( ) : ExtensionConfig { return this . _config ; } public constructor ( private _config , private _unid ) { } public inspectorForObject ( obj ) : GetInspectorResult | null { const inspectors = this . config . client . inspectors || [ ] ; const inspector = inspectors . find ( inspectorArg => InspectorAPI . canInspect ( inspectorArg , obj ) ) ; return inspector ? { extension : this , inspector , } : null ; } } export class InspectorAPI { public static canInspect ( inspector , obj ) { if ( ! obj ) { return false ; } if ( typeof obj !== 's' ) { return false ; } let criterias = inspector . criteria || [ ] ; if ( ! Array . isArray ( criterias ) ) { criterias = [ criterias ] ; } return criterias . some ( criteria => { const value = getValueFromPath ( obj , criteria . path ) ; if ( typeof value === 's' ) { return false ; } else { if ( ( criteria . value || 's' ) . startsWith ( 's' ) ) { const regex = new RegExp ( criteria . value ) ; return regex . test ( value ) ; } else { return criteria . value === value ; } } } ) ; } public static summaryText ( inspector , obj ) { let summaryTexts = inspector . summaryText || [ ] ; if ( ! Array . isArray ( summaryTexts ) ) { summaryTexts = [ summaryTexts ] ; } let text = 's' ; for ( let i = 0 ; i < summaryTexts . length ; ++ i ) { const value = getValueFromPath ( obj , summaryTexts [ i ] ) ; if ( value ) { text += value ; } } if ( text . length > 0 ) { text = text . substring ( 0 , 0 ) + 's' ; } return text ; } } export function getValueFromPath ( source : { [ prop ] : any } , path ) { const parts = path . split ( 's' ) ; let val = source ; for ( let i = 0 ; i < parts . length ; i ++ ) { const part = parts [ i ] ; if ( ! ( part in val ) ) { return undefined ; } val = val [ parts [ i ] ] ; } return val ; } export interface GetInspectorResult { extension : Extension ; inspector : ExtensionInspector ; } const { Connect , Disconnect } = SharedConstants . Commands . Extension ; class EmulatorExtensionManager { private extensions : { [ unid ] : Extension } = { } ; public addExtension ( config , unid ) { this . removeExtension ( unid ) ; this . extensions [ unid ] = new Extension ( config , unid ) ; } public removeExtension ( unid ) { if ( this . extensions [ unid ] ) { console . log ( `template` ) ; delete this . extensions [ unid ] ; } } public findExtension ( name ) { return this . getExtensions ( ) . find ( extension => extension . config . name === name ) ; } public getExtensions ( ) : Extension [ ] { return Object . keys ( this . extensions ) . map ( key => this . extensions [ key ] ) || [ ] ; } public inspectorForObject ( obj , defaultToJson ) : GetInspectorResult | null { let result = this . getExtensions ( ) . map ( extension => extension . inspectorForObject ( obj ) ) . filter ( resultArg => ! ! resultArg ) . shift ( ) ; if ( ! result && defaultToJson ) { const jsonExtension = this . findExtension ( 's' ) ; if ( jsonExtension ) { result = { extension : jsonExtension , inspector : jsonExtension . config . client . inspectors ? jsonExtension . config . client . inspectors [ 0 ] : null , } ; } } return result ; } @ Command ( Connect ) protected connectExtension ( config ) { this . addExtension ( config , config . location ) ; } @ Command ( Disconnect ) protected disconnectExtension ( location ) { this . removeExtension ( location ) ; } } export const ExtensionManager = new EmulatorExtensionManager ( ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $string$ O O O O O O O O $string$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O $ExtensionConfig$ O O $string$ O O O O $GetInspectorResult$ O $any$ O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O O O O $any$ O O $this$ O O O $any$ O O O O O O O O O $any$ O O O $boolean$ O $ExtensionInspector$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $RegExp$ O O $RegExpConstructor$ O $any$ O $any$ O O O $RegExp$ O $boolean$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $string$ O $ExtensionInspector$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any$ O O $any$ O O O O $string$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O O $number$ O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O $string$ O $any$ O O O O O $string$ O $number$ O O O O $string$ O $string$ O $string$ O O O O O O O O O O $string$ O O O O O $any$ O $complex$ O O O $string$ O O O O O $string$ O O O $string[]$ O $string$ O $complex$ O O O O O $complex$ O $complex$ O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O O O $string$ O $complex$ O O O O $undefined$ O O $complex$ O $complex$ O $string[]$ O $number$ O O O O O $complex$ O O O O $any$ O $Extension$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O $void$ O $ExtensionConfig$ O $string$ O O O O $void$ O $string$ O O O O $complex$ O $string$ O O O $any$ O $any$ O $string$ O O O O $void$ O $string$ O O O O O O $complex$ O $string$ O O O $Console$ O $void$ O O O O O O O $complex$ O $string$ O O O O O $Extension$ O $string$ O O O O O $Extension[]$ O O O $complex$ O $Extension$ O $Extension$ O $any$ O $any$ O $string$ O O O O $Extension[]$ O O O $any$ O O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O $string$ O O O $complex$ O $string$ O O O O O O O O $GetInspectorResult$ O $any$ O $boolean$ O O $any$ O O O O $GetInspectorResult$ O O O $Extension[]$ O O O $U[]$ O $Extension$ O $Extension$ O $GetInspectorResult$ O $any$ O O O $complex$ O $GetInspectorResult$ O O O $GetInspectorResult$ O O $GetInspectorResult$ O O O O O O $GetInspectorResult$ O $boolean$ O O O $Extension$ O O O $Extension$ O O O O O O $Extension$ O O $GetInspectorResult$ O O $Extension$ O $Extension$ O $any$ O $Extension$ O $any$ O $any$ O $any$ O $Extension$ O $any$ O $any$ O $any$ O O O O O O O O O O O $GetInspectorResult$ O O O $any$ O $any$ O O $void$ O $ExtensionConfig$ O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $void$ O $string$ O O O O $void$ O $string$ O O O O O O $EmulatorExtensionManager$ O O $any$ O O O
import * as URL from 's' ; import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance , uniqueId } from 's' ; const Electron = ( window as any ) . require ( 's' ) ; const { shell } = Electron ; export class HyperlinkHandler { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static navigate ( url = 's' ) { const { TrackEvent } = SharedConstants . Commands . Telemetry ; try { const parsed = URL . parse ( url ) || { protocol : 's' } ; if ( ( parsed . protocol || 's' ) . startsWith ( 's' ) ) { this . navigateEmulatedOAuthUrl ( url . substring ( 0 ) ) ; } else if ( parsed . protocol . startsWith ( 's' ) ) { this . navigateOAuthUrl ( url . substring ( 0 ) ) ; } else { this . commandService . remoteCall ( TrackEvent , 's' , { url } ) . catch ( _e => void 0 ) ; if ( url . startsWith ( 's' ) ) { const a = document . createElement ( 's' ) ; a . href = url ; a . download = 's' ; a . click ( ) ; } else { shell . openExternal ( url , { activate : true } ) ; } } } catch ( e ) { this . commandService . remoteCall ( TrackEvent , 's' , { url } ) . catch ( _e => void 0 ) ; shell . openExternal ( url , { activate : true } ) ; } } private static navigateEmulatedOAuthUrl ( oauthParam ) { const { Commands } = SharedConstants ; const parts = oauthParam . split ( 's' ) ; this . commandService . remoteCall ( Commands . OAuth . SendTokenResponse , parts [ 0 ] , parts [ 0 ] , 's' + uniqueId ( ) ) . catch ( ) ; } private static navigateOAuthUrl ( oauthParam ) { const { Commands } = SharedConstants ; const parts = oauthParam . split ( 's' ) ; this . commandService . remoteCall ( Commands . OAuth . CreateOAuthWindow , parts [ 0 ] , parts [ 0 ] ) . catch ( ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $complex$ O O O O $any$ O O O O O O $any$ O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $void$ O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $void$ O $string$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $void$ O $string$ O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O O O O O O O $string$ O $boolean$ O O O O O O $HTMLAnchorElement$ O $Document$ O O O O O O $HTMLAnchorElement$ O $string$ O $string$ O $HTMLAnchorElement$ O $string$ O O O $HTMLAnchorElement$ O $void$ O O O O O O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O O O $void$ O $string$ O O O O $any$ O O $any$ O O $string[]$ O $string$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string[]$ O O O O $string[]$ O O O O O O $any$ O O O O $any$ O O O O O O $void$ O $string$ O O O O $any$ O O $any$ O O $string[]$ O $string$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string[]$ O O O O $string[]$ O O O O O $any$ O O O O O
import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { HyperlinkHandler } from 's' ; let mockParse ; jest . mock ( 's' , ( ) => ( { get parse ( ) { return mockParse ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const mockUniqueId = 's' ; jest . mock ( 's' , ( ) => ( { uniqueId : ( ) => mockUniqueId , } ) ) ; let mockRemoteCallsMade ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; beforeEach ( ( ) => { mockParse = jest . fn ( url => { if ( url ) { const parts = url . split ( 's' ) ; return { protocol : parts [ 0 ] + 's' || 's' } ; } else { return 's' ; } } ) ; mockRemoteCallsMade = [ ] ; ( window as any ) . _openExternal . mockClear ( ) ; commandService . remoteCall = jest . fn ( ( commandName , ... args : any [ ] ) => { mockRemoteCallsMade . push ( { commandName , args } ) ; return Promise . resolve ( true ) ; } ) ; } ) ; it ( 's' , async ( ) => { const url = 's' ; await HyperlinkHandler . navigate ( url ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . OAuth . SendTokenResponse ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , 's' , 's' + mockUniqueId ] ) ; } ) ; it ( 's' , async ( ) => { const url = 's' ; await HyperlinkHandler . navigate ( url ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . OAuth . CreateOAuthWindow ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , async ( ) => { const url = 's' ; await HyperlinkHandler . navigate ( url ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Telemetry . TrackEvent ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , { url } ] ) ; expect ( ( window as any ) . _openExternal ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { const url = 's' ; await HyperlinkHandler . navigate ( url ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Telemetry . TrackEvent ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , { url } ] ) ; expect ( ( window as any ) . _openExternal ) . toHaveBeenCalled ( ) ; expect ( ( window as any ) . _openExternal ) . toHaveBeenCalledWith ( url , { activate : true } ) ; } ) ; it ( 's' , async ( ) => { mockParse = jest . fn ( ( ) => { throw new Error ( ) ; } ) ; const url = 's' ; await HyperlinkHandler . navigate ( url ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Telemetry . TrackEvent ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , { url } ] ) ; expect ( ( window as any ) . _openExternal ) . toHaveBeenCalled ( ) ; expect ( ( window as any ) . _openExternal ) . toHaveBeenCalledWith ( url , { activate : true } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O $complex$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O $any[]$ O O O O O O O $any$ O $any$ O O $string$ O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $string$ O O O O $any$ O O $complex$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $string$ O O O O $any$ O O $complex$ O O O O $any$ O O $any$ O O O $any$ O O $complex$ O O O O $any$ O O $any$ O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $string$ O O O O $any$ O O $complex$ O O O O $any$ O O $any$ O O O $any$ O O $complex$ O O O O $any$ O O $any$ O O O O $boolean$ O O O O O O O O O O O
export default function interceptError ( ) { ( process as NodeJS . EventEmitter ) . on ( 's' , _error => { } ) ; window . onerror = ( _message , _filename ? , _lineno ? , _colno ? , _error ? ) => { return true ; } ; }	O O O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O $complex$ O $OnErrorEventHandlerNonNull$ O O $string$ O $string$ $string$ O $number$ $number$ O $number$ $number$ O $Error$ $Error$ O O O O O O O O O
import { HyperlinkHandler } from 's' ; export default function interceptHyperlink ( ) { const interceptClickEvent = ( e ) => { let target = e . target ; while ( target ) { if ( target . href ) { e . preventDefault ( ) ; HyperlinkHandler . navigate ( target . href ) ; return ; } target = target . parentNode ; } } ; document . addEventListener ( 's' , interceptClickEvent ) ; window . open = ( url ) : any => { HyperlinkHandler . navigate ( url ) ; } ; }	O O $any$ O O O O O O O $void$ O O O O $void$ O O $Event$ O O O O $any$ O $Event$ O $EventTarget$ O O O $any$ O O O O $any$ O $any$ O O $Event$ O $void$ O O O $any$ O $void$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $Document$ O O O O O $void$ O O $complex$ O $Window)$ O O $string$ O O O O O $any$ O $void$ O $string$ O O O O O
import { store } from 's' ; export function documentIdForConversation ( conversationId ) { const state = store . getState ( ) ; for ( const key in state . chat . chats ) { if ( state . chat . chats [ key ] . conversationId === conversationId ) { return state . chat . chats [ key ] . documentId ; } } return undefined ; }	O O $any$ O O O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $undefined$ O O
import { SharedConstants } from 's' ; import { Command , LogEntry } from 's' ; import * as ChatActions from 's' ; import * as chatHelpers from 's' ; import { store } from 's' ; class LogService { public logToChat ( conversationId , entry ) { const documentId = chatHelpers . documentIdForConversation ( conversationId ) ; if ( documentId ) { this . logToDocument ( documentId , entry ) ; } } public logToDocument ( documentId , entry ) { store . dispatch ( ChatActions . appendToLog ( documentId , entry ) ) ; } @ Command ( SharedConstants . Commands . Emulator . AppendToLog ) protected appendToLog ( conversationId , entry ) { this . logToChat ( conversationId , entry ) ; } } export const logService = new LogService ( ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O $void$ O $string$ O $LogEntry$ O O O $string$ O $any$ O $string$ O $string$ O O O O $string$ O O O O $void$ O $string$ O $any$ O O O O O $void$ O $string$ O $LogEntry$ O O $any$ O $any$ O $any$ O $ChatAction<AppendLogPayload>$ O $string$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $LogEntry$ O O O O $void$ O $string$ O $any$ O O O O O O $LogService$ O O $any$ O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; export interface EmulatorSettings { url ? : string ; cwd ? : string ; readonly cwdAsBase : string ; } class EmulatorSettingsImpl implements EmulatorSettings { private _url : string ; private _cwd : string ; get url ( ) : string { if ( ! this . _url || ! this . _url . length ) { throw new Error ( 's' ) ; } return this . _url ; } set url ( value ) { this . _url = value ; } get cwd ( ) : string { if ( ! this . _cwd || ! this . _cwd . length ) { throw new Error ( 's' ) ; } return this . _cwd ; } set cwd ( value ) { this . _cwd = value ; } get cwdAsBase ( ) : string { let base = this . cwd || 's' ; if ( ! base . startsWith ( 's' ) ) { base = `template` ; } return base ; } } class EmulatorSettingsService { private _emulator : EmulatorSettingsImpl ; get emulator ( ) : EmulatorSettingsImpl { return this . _emulator ; } public init ( ) { return null ; } constructor ( ) { this . _emulator = new EmulatorSettingsImpl ( ) ; } @ Command ( SharedConstants . Commands . Settings . ReceiveGlobalSettings ) protected receiveGlobalSettings ( settings : { url : string ; cwd : string } ) { this . emulator . url = ( settings . url || 's' ) . replace ( 's' , 's' ) ; this . emulator . cwd = ( settings . cwd || 's' ) . replace ( "s" , 's' ) ; } } export const SettingsService = new EmulatorSettingsService ( ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O $string$ O O O O O $string$ O O O O O $any$ O $any$ O O $string$ O O O O $string$ O O O O $string$ O O O O O O O O O O $string$ O O O O $string$ O $number$ O O O O $ErrorConstructor$ O O O O O O O O $string$ O O O $string$ O $string$ O O O O $string$ O $string$ O O O $string$ O O O O O O O O O O $string$ O O O O $string$ O $number$ O O O O $ErrorConstructor$ O O O O O O O O $string$ O O O $string$ O $string$ O O O O $string$ O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O $string$ O $boolean$ O O O O O $string$ O O O O O $string$ O O O O $any$ O O $EmulatorSettingsImpl$ O $any$ O O $EmulatorSettingsImpl$ O O O $any$ O O O O $EmulatorSettingsImpl$ O O O $any$ O O O O O O O O O O O O O $EmulatorSettingsImpl$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $string$ O O O O O O O $EmulatorSettingsImpl$ O $string$ O O $complex$ O $string$ O O O O $complex$ O O O O O O O O $EmulatorSettingsImpl$ O $string$ O O $complex$ O $string$ O O O O $complex$ O O O O O O O O O O $EmulatorSettingsService$ O O $any$ O O O
const isLocalhost = Boolean ( window . location . hostname === 's' || window . location . hostname === 's' || window . location . hostname . match ( "s" ) ) ; export default function register ( ) { if ( process . env . NODE_ENV === 's' && 's' in navigator ) { const publicUrl = new URL ( process . env . PUBLIC_URL , window . location . toString ( ) ) ; if ( publicUrl . origin !== window . location . origin ) { return ; } window . addEventListener ( 's' , ( ) => { const swUrl = `template` ; if ( ! isLocalhost ) { registerValidSW ( swUrl ) ; } else { checkValidServiceWorker ( swUrl ) ; } } ) ; } } function registerValidSW ( swUrl ) { navigator . serviceWorker . register ( swUrl ) . then ( registration => { registration . onupdatefound = ( ) => { const installingWorker = registration . installing ; if ( installingWorker ) { installingWorker . onstatechange = ( ) => { if ( installingWorker . state === 's' ) { if ( navigator . serviceWorker . controller ) { console . log ( 's' ) ; } else { console . log ( 's' ) ; } } } ; } } ; } ) . catch ( error => { console . error ( 's' , error ) ; } ) ; } function checkValidServiceWorker ( swUrl ) { fetch ( swUrl ) . then ( response => { if ( response . status === 0 || response . headers . get ( 's' ) . indexOf ( 's' ) === - 0 ) { navigator . serviceWorker . ready . then ( registration => { registration . unregister ( ) . then ( ( ) => { window . location . reload ( ) ; } ) ; } ) ; } else { registerValidSW ( swUrl ) ; } } ) . catch ( ( ) => { console . log ( 's' ) ; } ) ; } export function unregister ( ) { if ( 's' in navigator ) { navigator . serviceWorker . ready . then ( registration => { registration . unregister ( ) ; } ) ; } }	O $boolean$ O $BooleanConstructor$ O $complex$ O $Location$ O $string$ O O O $complex$ O $Location$ O $string$ O O O $complex$ O $Location$ O $string$ O $complex$ O O O O O O O O $void$ O O O O O $any$ O $any$ O $any$ O O O O O $Navigator$ O O O $URL$ O O $complex$ O $any$ O $any$ O $any$ O $complex$ O $Location$ O $string$ O O O O O O $URL$ O $string$ O $complex$ O $Location$ O $string$ O O O O O $complex$ O O O O O O O O O O $string$ O O O O O O $boolean$ O O $void$ O $string$ O O O O O $void$ O $string$ O O O O O O O O O $void$ O $string$ O O $Navigator$ O $ServiceWorkerContainer$ O $Promise<ServiceWorkerRegistration>$ O $string$ O O O O $ServiceWorkerRegistration$ O O $ServiceWorkerRegistration$ O $any$ O O O O O O $ServiceWorker$ O $ServiceWorkerRegistration$ O $ServiceWorker$ O O O $ServiceWorker$ O O $ServiceWorker$ O $any$ O O O O O O O $ServiceWorker$ O $ServiceWorkerState$ O O O O O O $Navigator$ O $ServiceWorkerContainer$ O $ServiceWorker$ O O $Console$ O $void$ O O O O O O O $Console$ O $void$ O O O O O O O O O O O O O O $complex$ O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O $void$ O $string$ O O $complex$ O $string$ O O O O $Response$ O O O O $Response$ O $number$ O O O $Response$ O $Headers$ O $string$ O O O O $number$ O O O O O O O O $Navigator$ O $ServiceWorkerContainer$ O $Promise<ServiceWorkerRegistration>$ O O O $ServiceWorkerRegistration$ O O $ServiceWorkerRegistration$ O $Promise<boolean>$ O O O O O O O O O $complex$ O $Location$ O $complex$ O O O O O O O O O O O O $void$ O $string$ O O O O O O $complex$ O O O O O $Console$ O $void$ O O O O O O O O O O $void$ O O O O O O O $Navigator$ O O $Navigator$ O $ServiceWorkerContainer$ O $Promise<ServiceWorkerRegistration>$ O O O $ServiceWorkerRegistration$ O O $ServiceWorkerRegistration$ O $Promise<boolean>$ O O O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ;	O O O O O O O O O O O O
import * as azureAuthActions from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { expect ( azureAuthActions . azurePersistLoginChanged ( true ) ) . toEqual ( { type : azureAuthActions . AZURE_PERSIST_LOGIN_CHANGED , payload : true , } ) ; } ) ; test ( 's' , ( ) => { expect ( azureAuthActions . azureLoggedInUserChanged ( 's' ) ) . toEqual ( { type : azureAuthActions . AZURE_LOGGED_IN_USER_CHANGED , payload : 's' , } ) ; } ) ; } ) ;	O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<boolean>$ O O O O O $any$ O O $string$ O $any$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O $any$ O O $string$ O $any$ O O O $string$ O O O O O O O O O O O O
import { BotActionType , load , setActive , setDirectory , close , mockAndSetActive , botHashGenerated , browse , closeBot , openBotViaFilePathAction , openBotViaUrlAction , restartConversation , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const bots = [ { } , null , undefined , { } ] ; const action = load ( bots ) ; expect ( action . type ) . toBe ( BotActionType . load ) ; expect ( action . payload ) . toEqual ( { bots : [ { } , { } ] } ) ; } ) ; it ( 's' , ( ) => { const bot = { } ; const action = setActive ( bot ) ; expect ( action . type ) . toBe ( BotActionType . setActive ) ; expect ( action . payload ) . toEqual ( { bot : { } } ) ; } ) ; it ( 's' , ( ) => { const directory = 's' ; const action = setDirectory ( directory ) ; expect ( action . type ) . toBe ( BotActionType . setDirectory ) ; expect ( action . payload ) . toEqual ( { directory } ) ; } ) ; it ( 's' , ( ) => { const action = close ( ) ; expect ( action . type ) . toBe ( BotActionType . close ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const mock = { name : 's' , someMockProperty : true } ; const action = mockAndSetActive ( mock ) ; expect ( action . type ) . toBe ( BotActionType . setActive ) ; expect ( action . payload ) . toEqual ( { bot : { version : 's' , name : 's' , description : 's' , services : [ ] , padlock : 's' , someMockProperty : true , } , } ) ; } ) ; it ( 's' , ( ) => { const hash = 's' ; const action = botHashGenerated ( hash ) ; expect ( action . type ) . toBe ( BotActionType . hashGenerated ) ; expect ( action . payload ) . toEqual ( { hash } ) ; } ) ; it ( 's' , ( ) => { const action = browse ( ) ; expect ( action . type ) . toBe ( BotActionType . browse ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = closeBot ( ) ; expect ( action . type ) . toBe ( BotActionType . close ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = openBotViaFilePathAction ( 's' ) ; expect ( action . type ) . toBe ( BotActionType . openViaFilePath ) ; expect ( action . payload ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const action = openBotViaUrlAction ( { } ) ; expect ( action . type ) . toBe ( BotActionType . openViaUrl ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const documentId = 's' ; const action = restartConversation ( conversationId , documentId ) ; expect ( action . type ) . toBe ( BotActionType . restartConversation ) ; expect ( action . payload ) . toEqual ( { conversationId , documentId } ) ; } ) ; } ) ;	O O $any$ O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O $BotAction<SetDirectoryPayload>$ O $BotAction<{}>$ O $BotAction<any>$ O $BotAction<HashPayload>$ O $BotAction<{}>$ O $BotAction<{}>$ O $BotAction<string>$ O $BotAction<any>$ O $BotAction<RestartConversationPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O ${}[]$ O O O O O O O $undefined$ O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<LoadBotPayload>$ O ${}[]$ O O $any$ O $BotAction<LoadBotPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.load$ O O $any$ O $BotAction<LoadBotPayload>$ O $LoadBotPayload$ O O $any$ O O ${}[]$ O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O $any$ O $BotAction<SetActivePayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setActive$ O O $any$ O $BotAction<SetActivePayload>$ O $SetActivePayload$ O O $any$ O O ${}$ O O O O O O O O O $any$ O O O O O O O O O O O O O $BotAction<SetDirectoryPayload>$ O $BotAction<SetDirectoryPayload>$ O O O O $any$ O $BotAction<SetDirectoryPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setDirectory$ O O $any$ O $BotAction<SetDirectoryPayload>$ O $SetDirectoryPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.close$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $boolean$ O O O O O $BotAction<any>$ O $BotAction<any>$ O $any$ O O $any$ O $BotAction<any>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setActive$ O O $any$ O $BotAction<any>$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $boolean$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O $BotAction<HashPayload>$ O $BotAction<HashPayload>$ O O O O $any$ O $BotAction<HashPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.hashGenerated$ O O $any$ O $BotAction<HashPayload>$ O $HashPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.browse$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.close$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BotAction<string>$ O $BotAction<string>$ O O O O $any$ O $BotAction<string>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.openViaFilePath$ O O $any$ O $BotAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotAction<any>$ O $BotAction<any>$ O O O O O $any$ O $BotAction<any>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.openViaUrl$ O O $any$ O $BotAction<any>$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $BotAction<RestartConversationPayload>$ O $BotAction<RestartConversationPayload>$ O O O O O O $any$ O $BotAction<RestartConversationPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.restartConversation$ O O $any$ O $BotAction<RestartConversationPayload>$ O $RestartConversationPayload$ O O $any$ O O $string$ O $string$ O O O O O O O O O
import { ChatActions , inspectorChanged , addTranscript , clearTranscripts , removeTranscript , webSpeechFactoryUpdated , webChatStoreUpdated , updatePendingSpeechTokenRetrieval , newChat , closeDocument , closeConversation , newConversation , appendToLog , clearLog , setInspectorObjects , setHighlightedObjects , updateChat , showContextMenuForActivity , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const inspectorWebView = { } ; const action = inspectorChanged ( inspectorWebView ) ; expect ( action . type ) . toBe ( ChatActions . activeInspectorChanged ) ; expect ( action . payload ) . toEqual ( { inspectorWebView } ) ; } ) ; it ( 's' , ( ) => { const filename = 's' ; const action = addTranscript ( filename ) ; expect ( action . type ) . toBe ( ChatActions . addTranscript ) ; expect ( action . payload ) . toEqual ( { filename } ) ; } ) ; it ( 's' , ( ) => { const action = clearTranscripts ( ) ; expect ( action . type ) . toBe ( ChatActions . clearTranscripts ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const filename = 's' ; const action = removeTranscript ( filename ) ; expect ( action . type ) . toBe ( ChatActions . removeTranscript ) ; expect ( action . payload ) . toEqual ( { filename } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const factory = ( ) => null ; const action = webSpeechFactoryUpdated ( documentId , factory ) ; expect ( action . type ) . toBe ( ChatActions . webSpeechFactoryUpdated ) ; expect ( action . payload ) . toEqual ( { factory , documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const store = { } ; const action = webChatStoreUpdated ( documentId , store ) ; expect ( action . type ) . toBe ( ChatActions . webChatStoreUpdated ) ; expect ( action . payload ) . toEqual ( { documentId , store } ) ; } ) ; it ( 's' , ( ) => { const pending = true ; const action = updatePendingSpeechTokenRetrieval ( pending ) ; expect ( action . type ) . toBe ( ChatActions . updatePendingSpeechTokenRetrieval ) ; expect ( action . payload ) . toEqual ( { pending } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const mode = 's' ; const additionalData = { someOtherProperty : true } ; const action = newChat ( documentId , mode , additionalData ) ; expect ( action . type ) . toBe ( ChatActions . newChat ) ; expect ( action . payload ) . toEqual ( { mode , documentId , conversationId : null , directLine : null , log : { entries : [ ] , } , inspectorObjects : [ ] , ui : { horizontalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , verticalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , } , someOtherProperty : true , } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = closeDocument ( documentId ) ; expect ( action . type ) . toBe ( ChatActions . closeDocument ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = closeConversation ( documentId ) ; expect ( action . type ) . toBe ( ChatActions . closeConversation ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const options = { } ; const action = newConversation ( documentId , options ) ; expect ( action . type ) . toBe ( ChatActions . newConversation ) ; expect ( action . payload ) . toEqual ( { documentId , options } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const entry = { } ; const action = appendToLog ( documentId , entry ) ; expect ( action . type ) . toBe ( ChatActions . appendLog ) ; expect ( action . payload ) . toEqual ( { documentId , entry } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const resolver = ( ) => null ; const action = clearLog ( documentId , resolver ) ; expect ( action . type ) . toBe ( ChatActions . clearLog ) ; expect ( action . payload ) . toEqual ( { documentId , resolver } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; let objs = [ { } , { } ] ; let action = setInspectorObjects ( documentId , objs ) ; expect ( action . type ) . toBe ( ChatActions . setInspectorObjects ) ; expect ( action . payload ) . toEqual ( { documentId , objs } ) ; objs = { } ; action = setInspectorObjects ( documentId , objs ) ; expect ( action . payload ) . toEqual ( { documentId , objs : [ objs ] } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; let objs = [ { } , { } ] ; let action = setHighlightedObjects ( documentId , objs ) ; expect ( action . type ) . toBe ( ChatActions . setHighlightedObjects ) ; expect ( action . payload ) . toEqual ( { documentId , objs } ) ; objs = { } ; action = setHighlightedObjects ( documentId , objs ) ; expect ( action . payload ) . toEqual ( { documentId , objs : [ objs ] } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const updatedValues = { updatedValue : 0 } ; const action = updateChat ( documentId , updatedValues ) ; expect ( action . type ) . toBe ( ChatActions . updateChat ) ; expect ( action . payload ) . toEqual ( { documentId , updatedValues } ) ; } ) ; it ( 's' , ( ) => { const activity = { } ; const action = showContextMenuForActivity ( activity ) ; expect ( action . type ) . toBe ( ChatActions . showContextMenuForActivity ) ; expect ( action . payload ) . toEqual ( activity ) ; } ) ; } ) ;	O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $ChatAction<AddTranscriptPayload>$ O $ChatAction<{}>$ O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<WebSpeechFactoryPayload>$ O $ChatAction<WebChatStorePayload>$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $complex$ O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O $ChatAction<NewConversationPayload>$ O $ChatAction<AppendLogPayload>$ O $ChatAction<ClearLogPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<UpdateChatPayload>$ O $ChatAction<any>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $ChatAction<ActiveInspectorChangedPayload>$ O $ChatAction<ActiveInspectorChangedPayload>$ O $any$ O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.activeInspectorChanged$ O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $ActiveInspectorChangedPayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AddTranscriptPayload>$ O O O O $any$ O $ChatAction<AddTranscriptPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.addTranscript$ O O $any$ O $ChatAction<AddTranscriptPayload>$ O $AddTranscriptPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $ChatAction<{}>$ O $ChatAction<{}>$ O O O $any$ O $ChatAction<{}>$ O $any$ O O $any$ O $any$ O $ChatActions.clearTranscripts$ O O $any$ O $ChatAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O O O O $any$ O $ChatAction<RemoveTranscriptPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.removeTranscript$ O O $any$ O $ChatAction<RemoveTranscriptPayload>$ O $RemoveTranscriptPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $ChatAction<WebSpeechFactoryPayload>$ O $ChatAction<WebSpeechFactoryPayload>$ O O O $any$ O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.webSpeechFactoryUpdated$ O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $WebSpeechFactoryPayload$ O O $any$ O O $any$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O ${}$ O O O O O $ChatAction<WebChatStorePayload>$ O $ChatAction<WebChatStorePayload>$ O O O ${}$ O O $any$ O $ChatAction<WebChatStorePayload>$ O $any$ O O $any$ O $any$ O $ChatActions.webChatStoreUpdated$ O O $any$ O $ChatAction<WebChatStorePayload>$ O $WebChatStorePayload$ O O $any$ O O $string$ O ${}$ O O O O O O $any$ O O O O O O O O $true$ O O O O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $true$ O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $PendingSpeechTokenRetrievalPayload$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O O O $complex$ O $complex$ O O O O O $any$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $ChatActions.newChat$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O $string$ O $null$ O O O $null$ O O O $complex$ O O $undefined[]$ O O O O O O $undefined[]$ O O O O $complex$ O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $any$ O $ChatAction<DocumentIdPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.closeDocument$ O O $any$ O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $any$ O $ChatAction<DocumentIdPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.closeConversation$ O O $any$ O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O ${}$ O O O O O $ChatAction<NewConversationPayload>$ O $ChatAction<NewConversationPayload>$ O O O ${}$ O O $any$ O $ChatAction<NewConversationPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.newConversation$ O O $any$ O $ChatAction<NewConversationPayload>$ O $NewConversationPayload$ O O $any$ O O $string$ O ${}$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $ChatAction<AppendLogPayload>$ O $ChatAction<AppendLogPayload>$ O O O $any$ O O $any$ O $ChatAction<AppendLogPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.appendLog$ O O $any$ O $ChatAction<AppendLogPayload>$ O $AppendLogPayload$ O O $any$ O O $string$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $ChatAction<ClearLogPayload>$ O $ChatAction<ClearLogPayload>$ O O O $any$ O O $any$ O $ChatAction<ClearLogPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.clearLog$ O O $any$ O $ChatAction<ClearLogPayload>$ O $ClearLogPayload$ O O $any$ O O $string$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.setInspectorObjects$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $SetInspectorObjectsPayload$ O O $any$ O O $string$ O $any$ O O O $any$ O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $SetInspectorObjectsPayload$ O O $any$ O O $string$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.setHighlightedObjects$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $SetHighlightedObjectsPayload$ O O $any$ O O $string$ O $any$ O O O $any$ O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $SetHighlightedObjectsPayload$ O O $any$ O O $string$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O O $ChatAction<UpdateChatPayload>$ O $ChatAction<UpdateChatPayload>$ O O O $complex$ O O $any$ O $ChatAction<UpdateChatPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.updateChat$ O O $any$ O $ChatAction<UpdateChatPayload>$ O $UpdateChatPayload$ O O $any$ O O $string$ O $complex$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $ChatAction<any>$ O $ChatAction<any>$ O $any$ O O $any$ O $ChatAction<any>$ O $any$ O O $any$ O $any$ O $ChatActions.showContextMenuForActivity$ O O $any$ O $ChatAction<any>$ O $any$ O O $any$ O $any$ O O O O O O O O
import { clientAwareSettingsChanged , CLIENT_AWARE_SETTINGS_CHANGED } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const settings = { } ; const action = clientAwareSettingsChanged ( settings ) ; expect ( action . type ) . toBe ( CLIENT_AWARE_SETTINGS_CHANGED ) ; expect ( action . payload ) . toEqual ( settings ) ; } ) ; } ) ;	O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $ClientAwareSettingsActions$ O $ClientAwareSettingsActions$ O $any$ O O $any$ O $ClientAwareSettingsActions$ O O O O $any$ O O O O $any$ O $ClientAwareSettingsActions$ O $any$ O O $any$ O $any$ O O O O O O O O
import { executeCommand , EXECUTE_COMMAND } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const isRemote = true ; const commandName = 's' ; const resolver = ( ) => null ; const action = executeCommand ( isRemote , commandName , resolver ) ; expect ( action . type ) . toBe ( EXECUTE_COMMAND ) ; expect ( action . payload ) . toEqual ( { isRemote , commandName , resolver , args : [ ] } ) ; } ) ; } ) ;	O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $true$ O O O O O O O O O $any$ O O O O O O O $CommandAction<CommandActionPayload>$ O $CommandAction<CommandActionPayload>$ O $true$ O O O $any$ O O $any$ O $CommandAction<CommandActionPayload>$ O $any$ O O $any$ O O O O $any$ O $CommandAction<CommandActionPayload>$ O $CommandActionPayload$ O O $any$ O O $boolean$ O $string$ O $any$ O $undefined[]$ O O O O O O O O O O O O
import { OPEN_SERVICE_DEEP_LINK , OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , LAUNCH_EXTERNAL_LINK , OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , LAUNCH_CONNECTED_SERVICE_EDITOR , LAUNCH_CONNECTED_SERVICE_PICKER , launchConnectedServiceEditor , launchConnectedServicePicker , openServiceDeepLink , openContextMenuForConnectedService , openAddServiceContextMenu , launchExternalLink , openSortContextMenu , } from 's' ; import { CONNECTED_SERVICES_PANEL_ID } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const editorComponent = { } ; const connectedService = { } ; const action = launchConnectedServiceEditor ( editorComponent , connectedService ) ; expect ( action . type ) . toBe ( LAUNCH_CONNECTED_SERVICE_EDITOR ) ; expect ( action . payload ) . toEqual ( { editorComponent , connectedService } ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = launchConnectedServicePicker ( payload ) ; expect ( action . type ) . toBe ( LAUNCH_CONNECTED_SERVICE_PICKER ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const connectedService = { } ; const action = openServiceDeepLink ( connectedService ) ; expect ( action . type ) . toBe ( OPEN_SERVICE_DEEP_LINK ) ; expect ( action . payload ) . toEqual ( { connectedService } ) ; } ) ; it ( 's' , ( ) => { const editorComponent = { } ; const connectedService = { } ; const action = openContextMenuForConnectedService ( editorComponent , connectedService ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE ) ; expect ( action . payload ) . toEqual ( { editorComponent , connectedService } ) ; } ) ; it ( 's' , ( ) => { const payload = { resolver : jasmine . any ( Function ) } ; const action = openAddServiceContextMenu ( payload , jasmine . any ( Function ) as any ) ; expect ( action . type ) . toBe ( OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = launchExternalLink ( payload ) ; expect ( action . type ) . toBe ( LAUNCH_EXTERNAL_LINK ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = openSortContextMenu ( ) ; expect ( action . type ) . toBe ( OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { panelId : CONNECTED_SERVICES_PANEL_ID } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $FunctionConstructor$ O O O O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $any$ O $any$ O $any$ O $FunctionConstructor$ O O O O O $any$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $OpenAddServiceContextMenuPayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $string$ O O O O O O O O O O O
import { DialogActions , setShowing } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const action = setShowing ( ) ; expect ( action . type ) . toBe ( DialogActions . setShowing ) ; expect ( action . payload ) . toEqual ( { showing : false } ) ; } ) ; } ) ;	O O $any$ O $SetShowingDialogAction$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $SetShowingDialogAction$ O $SetShowingDialogAction$ O O O $any$ O $SetShowingDialogAction$ O $DialogActions$ O O $any$ O $any$ O $DialogActions.setShowing$ O O $any$ O $SetShowingDialogAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O O O O O O
import { IDispatchService } from 's' ; import { Action } from 's' ; export const OPEN_DISPATCH_DEEP_LINK = 's' ; export const OPEN_DISPATCH_EXPLORER_CONTEXT_MENU = 's' ; export interface DispatchServiceAction < T > extends Action { payload : T ; } export interface DispatchServicePayload { dispatchService ? : IDispatchService ; } export function openDispatchDeepLink ( dispatchService ) < DispatchServicePayload > { return { type : OPEN_DISPATCH_DEEP_LINK , payload : { dispatchService } , } ; } export function openDispatchExplorerContextMenu ( dispatchService ) < DispatchServicePayload > { return { type : OPEN_DISPATCH_EXPLORER_CONTEXT_MENU , payload : { dispatchService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $DispatchServiceAction$ O $IDispatchService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O O O $DispatchServiceAction$ O $IDispatchService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O
import { OPEN_DISPATCH_DEEP_LINK , OPEN_DISPATCH_EXPLORER_CONTEXT_MENU , openDispatchDeepLink , openDispatchExplorerContextMenu , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const dispatchService = { } ; const action = openDispatchDeepLink ( dispatchService ) ; expect ( action . type ) . toBe ( OPEN_DISPATCH_DEEP_LINK ) ; expect ( action . payload ) . toEqual ( { dispatchService } ) ; } ) ; it ( 's' , ( ) => { const dispatchService = { } ; const action = openDispatchExplorerContextMenu ( dispatchService ) ; expect ( action . type ) . toBe ( OPEN_DISPATCH_EXPLORER_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { dispatchService } ) ; } ) ; } ) ;	O O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O O O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServicePayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O O O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServicePayload$ O O $any$ O O $any$ O O O O O O O O O
import { EditorActions , appendTab , addDocPendingChange , removeDocPendingChange , close , closeNonGlobalTabs , setDirtyFlag , open , updateDocument , setActiveTab , setActiveEditor , splitTab , swapTabs , toggleDraggingTab , dropTabOnLeftOverlay , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const srcEditorKey = 's' ; const destEditorKey = 's' ; const documentId = 's' ; const action = appendTab ( srcEditorKey , destEditorKey , documentId ) ; expect ( action . type ) . toBe ( EditorActions . appendTab ) ; expect ( action . payload ) . toEqual ( { srcEditorKey , destEditorKey , documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = addDocPendingChange ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . addDocPendingChange ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = removeDocPendingChange ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . removeDocPendingChange ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const editorKey = 's' ; const documentId = 's' ; const action = close ( editorKey , documentId ) ; expect ( action . type ) . toBe ( EditorActions . close ) ; expect ( action . payload ) . toEqual ( { documentId , editorKey } ) ; } ) ; it ( 's' , ( ) => { const action = closeNonGlobalTabs ( ) ; expect ( action . type ) . toBe ( EditorActions . closeAll ) ; expect ( action . payload ) . toEqual ( { includeGlobal : false } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const dirty = true ; const action = setDirtyFlag ( documentId , dirty ) ; expect ( action . type ) . toBe ( EditorActions . setDirtyFlag ) ; expect ( action . payload ) . toEqual ( { documentId , dirty } ) ; } ) ; it ( 's' , ( ) => { const document = { } ; const action = open ( document ) ; expect ( action . type ) . toBe ( EditorActions . open ) ; expect ( action . payload ) . toEqual ( document ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const updatedDocument = { dirty : true , contentType : 's' } ; const action = updateDocument ( documentId , updatedDocument ) ; expect ( action . type ) . toBe ( EditorActions . updateDocument ) ; expect ( action . payload ) . toEqual ( { documentId , dirty : true , contentType : 's' } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = setActiveTab ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . setActiveTab ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const editorKey = 's' ; const action = setActiveEditor ( editorKey ) ; expect ( action . type ) . toBe ( EditorActions . setActiveEditor ) ; expect ( action . payload ) . toEqual ( { editorKey } ) ; } ) ; it ( 's' , ( ) => { const contentType = 's' ; const documentId = 's' ; const srcEditorKey = 's' ; const destEditorKey = 's' ; const action = splitTab ( contentType , documentId , srcEditorKey , destEditorKey ) ; expect ( action . type ) . toBe ( EditorActions . splitTab ) ; expect ( action . payload ) . toEqual ( { contentType , documentId , srcEditorKey , destEditorKey } ) ; } ) ; it ( 's' , ( ) => { const srcEditorKey = 's' ; const destEditorKey = 's' ; const srcTabId = 's' ; const destTabId = 's' ; const action = swapTabs ( srcEditorKey , destEditorKey , srcTabId , destTabId ) ; expect ( action . type ) . toBe ( EditorActions . swapTabs ) ; expect ( action . payload ) . toEqual ( { srcEditorKey , destEditorKey , srcTabId , destTabId } ) ; } ) ; it ( 's' , ( ) => { const draggingTab = true ; const action = toggleDraggingTab ( draggingTab ) ; expect ( action . type ) . toBe ( EditorActions . toggleDraggingTab ) ; expect ( action . payload ) . toEqual ( { draggingTab } ) ; } ) ; it ( 's' , ( ) => { const tabId = 's' ; const action = dropTabOnLeftOverlay ( tabId ) ; expect ( action . type ) . toBe ( EditorActions . dropTabOnLeftOverlay ) ; expect ( action . payload ) . toEqual ( { tabId } ) ; } ) ; } ) ;	O O $any$ O $AppendTabAction$ O $AddDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O $CloseEditorAction$ O $CloseAllEditorAction$ O $SetDirtyFlagAction$ O $OpenEditorAction$ O $UpdateDocumentAction$ O $SetActiveTabAction$ O $SetActiveEditorAction$ O $SplitTabAction$ O $SwapTabsAction$ O $ToggleDraggingTabAction$ O $DropTabOnLeftOverlayAction$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O $any$ O $AppendTabAction$ O $EditorActions.appendTab$ O O $any$ O $any$ O $EditorActions.appendTab$ O O $any$ O $AppendTabAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O $any$ O $AddDocPendingChangeAction$ O $EditorActions.addDocPendingChange$ O O $any$ O $any$ O $EditorActions.addDocPendingChange$ O O $any$ O $AddDocPendingChangeAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $RemoveDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O O O O $any$ O $RemoveDocPendingChangeAction$ O $EditorActions.removeDocPendingChange$ O O $any$ O $any$ O $EditorActions.removeDocPendingChange$ O O $any$ O $RemoveDocPendingChangeAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $CloseEditorAction$ O $CloseEditorAction$ O O O O O O $any$ O $CloseEditorAction$ O $EditorActions.close$ O O $any$ O $any$ O $EditorActions.close$ O O $any$ O $CloseEditorAction$ O $complex$ O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O $any$ O $CloseAllEditorAction$ O $EditorActions.closeAll$ O O $any$ O $any$ O $EditorActions.closeAll$ O O $any$ O $CloseAllEditorAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O O O $true$ O O O O $SetDirtyFlagAction$ O $SetDirtyFlagAction$ O O O $true$ O O $any$ O $SetDirtyFlagAction$ O $EditorActions.setDirtyFlag$ O O $any$ O $any$ O $EditorActions.setDirtyFlag$ O O $any$ O $SetDirtyFlagAction$ O $complex$ O O $any$ O O $string$ O $boolean$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $OpenEditorAction$ O $OpenEditorAction$ O $any$ O O $any$ O $OpenEditorAction$ O $EditorActions.open$ O O $any$ O $any$ O $EditorActions.open$ O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O O $boolean$ O O O $string$ O O O O O $UpdateDocumentAction$ O $UpdateDocumentAction$ O O O $any$ O O $any$ O $UpdateDocumentAction$ O $EditorActions.updateDocument$ O O $any$ O $any$ O $EditorActions.updateDocument$ O O $any$ O $UpdateDocumentAction$ O $Partial<Document<any>>$ O O $any$ O O $string$ O $boolean$ O O O $string$ O O O O O O O O $any$ O O O O O O O O O O O O O $SetActiveTabAction$ O $SetActiveTabAction$ O O O O $any$ O $SetActiveTabAction$ O $EditorActions.setActiveTab$ O O $any$ O $any$ O $EditorActions.setActiveTab$ O O $any$ O $SetActiveTabAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $SetActiveEditorAction$ O $SetActiveEditorAction$ O O O O $any$ O $SetActiveEditorAction$ O $EditorActions.setActiveEditor$ O O $any$ O $any$ O $EditorActions.setActiveEditor$ O O $any$ O $SetActiveEditorAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitTabAction$ O $SplitTabAction$ O O O O O O O O O O $any$ O $SplitTabAction$ O $EditorActions.splitTab$ O O $any$ O $any$ O $EditorActions.splitTab$ O O $any$ O $SplitTabAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O O O O O O O O O O $any$ O $SwapTabsAction$ O $EditorActions.swapTabs$ O O $any$ O $any$ O $EditorActions.swapTabs$ O O $any$ O $SwapTabsAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O $true$ O O O O $ToggleDraggingTabAction$ O $ToggleDraggingTabAction$ O $true$ O O $any$ O $ToggleDraggingTabAction$ O $EditorActions.toggleDraggingTab$ O O $any$ O $any$ O $EditorActions.toggleDraggingTab$ O O $any$ O $ToggleDraggingTabAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O $DropTabOnLeftOverlayAction$ O $DropTabOnLeftOverlayAction$ O O O O $any$ O $DropTabOnLeftOverlayAction$ O $EditorActions.dropTabOnLeftOverlay$ O O $any$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O O $any$ O $DropTabOnLeftOverlayAction$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { IEndpointService } from 's' ; import { Action } from 's' ; export const OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU = 's' ; export interface EndpointServiceAction < T > extends Action { payload : T ; } export interface EndpointServicePayload { endpointService ? : IEndpointService ; } export function openEndpointExplorerContextMenu ( endpointService ) < EndpointServicePayload > { return { type : OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU , payload : { endpointService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $EndpointServiceAction$ O $IEndpointService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O
import { openEndpointExplorerContextMenu , OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const endpointService = { } ; const action = openEndpointExplorerContextMenu ( endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { endpointService } ) ; } ) ; } ) ;	O O $EndpointServiceAction<EndpointServicePayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServicePayload$ O O $any$ O O $any$ O O O O O O O O O
import { OPEN_ENDPOINT_IN_EMULATOR , OPEN_ENDPOINT_CONTEXT_MENU , LAUNCH_ENDPOINT_EDITOR , launchEndpointEditor , openEndpointInEmulator , openEndpointExplorerContextMenu , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const endpointEditorComponent = { } ; const endpointService = { } ; const action = launchEndpointEditor ( endpointEditorComponent , endpointService ) ; expect ( action . type ) . toBe ( LAUNCH_ENDPOINT_EDITOR ) ; expect ( action . payload ) . toEqual ( { endpointEditorComponent , endpointService } ) ; } ) ; it ( 's' , ( ) => { const endpointService = { } ; const action = openEndpointInEmulator ( endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_IN_EMULATOR ) ; expect ( action . payload ) . toEqual ( { endpointService , focusExistingChatIfAvailable : false } ) ; } ) ; it ( 's' , ( ) => { const endpointEditorComponent = { } ; const endpointService = { } ; const action = openEndpointExplorerContextMenu ( endpointEditorComponent , endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { endpointEditorComponent , endpointService } ) ; } ) ; } ) ;	O O O O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointEditorPayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServicePayload$ O O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointEditorPayload$ O O $any$ O O $any$ O $any$ O O O O O O O O O
import { ExplorerActions , showExplorer , sortExplorerContents } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const show = true ; const action = showExplorer ( show ) ; expect ( action . type ) . toBe ( ExplorerActions . Show ) ; expect ( action . payload ) . toEqual ( { show } ) ; } ) ; it ( 's' , ( ) => { const panelId = 's' ; const sort = 's' ; const action = sortExplorerContents ( panelId , sort ) ; expect ( action . type ) . toBe ( ExplorerActions . Sort ) ; expect ( action . payload ) . toEqual ( { sortSelectionByPanelId : { [ panelId ] : sort } } ) ; } ) ; } ) ;	O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $true$ O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O $true$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O $any$ O $any$ O $ExplorerActions.Show$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O O O O O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O $any$ O $any$ O $ExplorerActions.Sort$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O O $any$ O O $complex$ O O O O O O O O O O O O O O O O O
import { addFile , clear , removeFile , setRoot , FileActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = { } ; const action = addFile ( payload ) ; expect ( action . type ) . toBe ( FileActions . add ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = clear ( ) ; expect ( action . type ) . toBe ( FileActions . clear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const path = 's' ; const action = removeFile ( path ) ; expect ( action . type ) . toBe ( FileActions . remove ) ; expect ( action . payload ) . toEqual ( { path } ) ; } ) ; it ( 's' , ( ) => { const path = 's' ; const action = setRoot ( path ) ; expect ( action . type ) . toBe ( FileActions . setRoot ) ; expect ( action . payload ) . toEqual ( { path } ) ; } ) ; } ) ;	O O $complex$ O $complex$ O $complex$ O $complex$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $complex$ O $complex$ O $any$ O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.add$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.clear$ O O $any$ O $complex$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.remove$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.setRoot$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { FrameworkActionType , pushClientAwareSettings , setFrameworkSettings } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const frameworkSettings = { autoUpdate : true , } ; expect ( setFrameworkSettings ( frameworkSettings ) ) . toEqual ( { type : FrameworkActionType . SET_FRAMEWORK , payload : frameworkSettings , } ) ; } ) ; test ( 's' , ( ) => { expect ( pushClientAwareSettings ( ) ) . toEqual ( { type : FrameworkActionType . PUSH_CLIENT_AWARE_SETTINGS , payload : undefined , } ) ; } ) ; } ) ;	O O $any$ O $FrameworkAction<undefined>$ O $FrameworkAction<any>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $any$ O $FrameworkAction<any>$ O $complex$ O O O $any$ O O $FrameworkActionType$ O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O $any$ O $FrameworkAction<undefined>$ O O O O $any$ O O $FrameworkActionType$ O $any$ O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $undefined$ O $undefined$ O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { select , NavBarActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const selection = 's' ; const action = select ( selection ) ; expect ( action . type ) . toBe ( NavBarActions . select ) ; expect ( action . payload ) . toEqual ( { selection } ) ; } ) ; } ) ;	O O $SelectNavBarAction$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $SelectNavBarAction$ O $SelectNavBarAction$ O O O O $any$ O $SelectNavBarAction$ O $NavBarActions$ O O $any$ O $any$ O $NavBarActions.select$ O O $any$ O $SelectNavBarAction$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { beginAdd , finishAdd , beginRemove , finishRemove , markAllAsRead , beginClear , finishClear , NotificationActions , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const notification = { } ; const action = beginAdd ( notification ) ; expect ( action . type ) . toBe ( NotificationActions . beginAdd ) ; expect ( action . payload ) . toEqual ( { notification , read : false } ) ; } ) ; it ( 's' , ( ) => { const notification = { } ; const action = finishAdd ( notification ) ; expect ( action . type ) . toBe ( NotificationActions . finishAdd ) ; expect ( action . payload ) . toEqual ( { notification } ) ; } ) ; it ( 's' , ( ) => { const id = 's' ; const action = beginRemove ( id ) ; expect ( action . type ) . toBe ( NotificationActions . beginRemove ) ; expect ( action . payload ) . toEqual ( { id } ) ; } ) ; it ( 's' , ( ) => { const id = 's' ; const action = finishRemove ( id ) ; expect ( action . type ) . toBe ( NotificationActions . finishRemove ) ; expect ( action . payload ) . toEqual ( { id } ) ; } ) ; it ( 's' , ( ) => { const action = markAllAsRead ( ) ; expect ( action . type ) . toBe ( NotificationActions . markAllAsRead ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = beginClear ( ) ; expect ( action . type ) . toBe ( NotificationActions . beginClear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = finishClear ( ) ; expect ( action . type ) . toBe ( NotificationActions . finishClear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; } ) ;	O O $BeginAddNotificationAction$ O $FinishAddNotificationAction$ O $BeginRemoveNotificationAction$ O $FinishRemoveNotificationAction$ O $MarkAllAsReadNotificationAction$ O $BeginClearNotificationAction$ O $FinishClearNotificationAction$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O $any$ O $BeginAddNotificationAction$ O $NotificationActions.beginAdd$ O O $any$ O $any$ O $NotificationActions.beginAdd$ O O $any$ O $BeginAddNotificationAction$ O $complex$ O O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $FinishAddNotificationAction$ O $FinishAddNotificationAction$ O $any$ O O $any$ O $FinishAddNotificationAction$ O $NotificationActions.finishAdd$ O O $any$ O $any$ O $NotificationActions.finishAdd$ O O $any$ O $FinishAddNotificationAction$ O $complex$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $BeginRemoveNotificationAction$ O $BeginRemoveNotificationAction$ O O O O $any$ O $BeginRemoveNotificationAction$ O $NotificationActions.beginRemove$ O O $any$ O $any$ O $NotificationActions.beginRemove$ O O $any$ O $BeginRemoveNotificationAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $FinishRemoveNotificationAction$ O $FinishRemoveNotificationAction$ O O O O $any$ O $FinishRemoveNotificationAction$ O $NotificationActions.finishRemove$ O O $any$ O $any$ O $NotificationActions.finishRemove$ O O $any$ O $FinishRemoveNotificationAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $MarkAllAsReadNotificationAction$ O $MarkAllAsReadNotificationAction$ O O O $any$ O $MarkAllAsReadNotificationAction$ O $NotificationActions.markAllAsRead$ O O $any$ O $any$ O $NotificationActions.markAllAsRead$ O O $any$ O $MarkAllAsReadNotificationAction$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BeginClearNotificationAction$ O $BeginClearNotificationAction$ O O O $any$ O $BeginClearNotificationAction$ O $NotificationActions.beginClear$ O O $any$ O $any$ O $NotificationActions.beginClear$ O O $any$ O $BeginClearNotificationAction$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $FinishClearNotificationAction$ O $FinishClearNotificationAction$ O O O $any$ O $FinishClearNotificationAction$ O $NotificationActions.finishClear$ O O $any$ O $any$ O $NotificationActions.finishClear$ O O $any$ O $FinishClearNotificationAction$ O ${}$ O O $any$ O O O O O O O O O O O
import { disable , enable , PresentationActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const action = enable ( ) ; expect ( action . type ) . toBe ( PresentationActions . enable ) ; } ) ; it ( 's' , ( ) => { const action = disable ( ) ; expect ( action . type ) . toBe ( PresentationActions . disable ) ; } ) ; } ) ;	O O $PresentationAction$ O $PresentationAction$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O $any$ O $PresentationAction$ O $PresentationActions$ O O $any$ O $any$ O $PresentationActions.enable$ O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O $any$ O $PresentationAction$ O $PresentationActions$ O O $any$ O $any$ O $PresentationActions.disable$ O O O O O O O O
import { CANCEL_CURRENT_PROCESS , UPDATE_PROGRESS_INDICATOR , cancelCurrentProcess , updateProgressIndicator , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = { label : 's' , progress : 0 } ; const action = updateProgressIndicator ( payload ) ; expect ( action . type ) . toBe ( UPDATE_PROGRESS_INDICATOR ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = cancelCurrentProcess ( ) ; expect ( action . type ) . toBe ( CANCEL_CURRENT_PROCESS ) ; expect ( action . payload ) . toBe ( undefined ) ; } ) ; } ) ;	O O O O O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $complex$ O O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O $any$ O O O O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorPayload$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<void>$ O O O $any$ O $ProgressIndicatorAction<void>$ O $any$ O O $any$ O O O O $any$ O $ProgressIndicatorAction<void>$ O $void$ O O $any$ O $undefined$ O O O O O O O O
import { setOpenUrl , SET_OPEN_URLS } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const openUrl = 's' ; const action = setOpenUrl ( openUrl ) ; expect ( action . type ) . toBe ( SET_OPEN_URLS ) ; expect ( action . payload ) . toEqual ( { openUrl } ) ; } ) ; } ) ;	O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O $any$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O $any$ O O O O $any$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolOpenUrlsPayload$ O O $any$ O O $string$ O O O O O O O O O
import { TRANSCRIPTS_UPDATED , TRANSCRIPTS_DIRECTORY_UPDATED , CHAT_FILES_UPDATED , CHATS_DIRECTORY_UPDATED , OPEN_CONTEXT_MENU_FOR_RESOURCE , EDIT_RESOURCE , RENAME_RESOURCE , OPEN_RESOURCE , OPEN_RESOURCE_SETTINGS , transcriptsUpdated , transcriptDirectoryUpdated , chatsDirectoryUpdated , chatFilesUpdated , openContextMenuForResource , editResource , renameResource , openResource , openResourcesSettings , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = [ { name : 's' , path : 's' } ] ; const action = transcriptsUpdated ( payload ) ; expect ( action . type ) . toBe ( TRANSCRIPTS_UPDATED ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const dir = 's' ; const action = transcriptDirectoryUpdated ( dir ) ; expect ( action . type ) . toBe ( TRANSCRIPTS_DIRECTORY_UPDATED ) ; expect ( action . payload ) . toBe ( dir ) ; } ) ; it ( 's' , ( ) => { const dir = 's' ; const action = chatsDirectoryUpdated ( dir ) ; expect ( action . type ) . toBe ( CHATS_DIRECTORY_UPDATED ) ; expect ( action . payload ) . toBe ( dir ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' , path : 's' } ] ; const action = chatFilesUpdated ( payload ) ; expect ( action . type ) . toBe ( CHAT_FILES_UPDATED ) ; expect ( action . payload ) . toBe ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = openContextMenuForResource ( payload ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_RESOURCE ) ; expect ( action . payload ) . toBe ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = editResource ( payload ) ; expect ( action . type ) . toBe ( EDIT_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = renameResource ( payload ) ; expect ( action . type ) . toBe ( RENAME_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = openResource ( payload ) ; expect ( action . type ) . toBe ( OPEN_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = openResourcesSettings ( payload ) ; expect ( action . type ) . toBe ( OPEN_RESOURCE_SETTINGS ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<string>$ O $ResourcesAction<any[]>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<ResourceSettingsPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $complex$ O O $any$ O $ResourcesAction<any[]>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O $any$ O $ResourcesAction<string>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O $any$ O $ResourcesAction<string>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $complex$ O O $any$ O $ResourcesAction<any[]>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ResourcesAction<ResourceSettingsPayload>$ O $ResourcesAction<ResourceSettingsPayload>$ O $any$ O O $any$ O $ResourcesAction<ResourceSettingsPayload>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<ResourceSettingsPayload>$ O $ResourceSettingsPayload$ O O $any$ O $any$ O O O O O O O O
import { addSavedBotUrl , ADD_SAVED_BOT_URL } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( addSavedBotUrl ( 's' ) ) . toEqual ( { type : ADD_SAVED_BOT_URL , payload : 's' , } ) ; } ) ; } ) ;	O O $SavedBotUrlsAction<string>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SavedBotUrlsAction<string>$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O
import { switchTheme , SWITCH_THEME } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const themeName = 's' ; const themeComponents = [ 's' ] ; const action = switchTheme ( themeName , themeComponents ) ; expect ( action . type ) . toBe ( SWITCH_THEME ) ; expect ( action . payload ) . toEqual ( { themeName , themeComponents } ) ; } ) ; } ) ;	O O $ThemeAction<SwitchThemePayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $string[]$ O O O O O O $ThemeAction<SwitchThemePayload>$ O $ThemeAction<SwitchThemePayload>$ O O O $string[]$ O O $any$ O $ThemeAction<SwitchThemePayload>$ O O O O $any$ O O O O $any$ O $ThemeAction<SwitchThemePayload>$ O $SwitchThemePayload$ O O $any$ O O $string$ O $string[]$ O O O O O O O O O
import { UpdateStatus } from 's' ; import { setUpdateStatus , SET_UPDATE_STATUS } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( setUpdateStatus ( UpdateStatus . Idle ) ) . toEqual ( { type : SET_UPDATE_STATUS , payload : UpdateStatus . Idle } ) ; } ) ; } ) ;	O O $any$ O O O O O O $UpdateAction<any>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $UpdateAction<any>$ O $any$ O $any$ O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O O O
import { User } from 's' ; import * as userActions from 's' ; describe ( 's' , ( ) => { const user = { id : 's' , name : 's' , } ; const users = [ user ] ; test ( 's' , ( ) => { expect ( userActions . addUsers ( users ) ) . toEqual ( { type : userActions . ADD_USERS , payload : { users } , } ) ; } ) ; test ( 's' , ( ) => { expect ( userActions . removeUsers ( users ) ) . toEqual ( { type : userActions . REMOVE_USERS , payload : { users } , } ) ; } ) ; test ( 's' , ( ) => { expect ( userActions . setCurrentUser ( user ) ) . toEqual ( { type : userActions . SET_CURRENT_USER , payload : { user } , } ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O $any$ O O O O O O O O $User$ O O $string$ O O O $string$ O O O O O O $any[]$ O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any[]$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any[]$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any[]$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any[]$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any$ O O O O O O O O O O O
import { openContextMenuForBot , OPEN_CONTEXT_MENU_FOR_BOT } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const bot = { } ; const action = openContextMenuForBot ( bot ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_BOT ) ; expect ( action . payload ) . toEqual ( bot ) ; } ) ; } ) ;	O O $WelcomePageAction<any>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $WelcomePageAction<any>$ O $WelcomePageAction<any>$ O $any$ O O $any$ O $WelcomePageAction<any>$ O $any$ O O $any$ O O O O $any$ O $WelcomePageAction<any>$ O $any$ O O $any$ O $any$ O O O O O O O O
import * as windowStateActions from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { expect ( windowStateActions . rememberTheme ( 's' ) ) . toEqual ( { type : windowStateActions . REMEMBER_THEME , payload : { theme : 's' , } , } ) ; } ) ; test ( 's' , ( ) => { const boundsState = { displayId : 0 , top : 0 , left : 0 , width : 0 , height : 0 , } ; expect ( windowStateActions . rememberBounds ( boundsState ) ) . toEqual ( { type : windowStateActions . REMEMBER_BOUNDS , payload : boundsState , } ) ; } ) ; test ( 's' , ( ) => { const zoomState = { zoomLevel : 0 } ; expect ( windowStateActions . rememberZoomLevel ( zoomState ) ) . toEqual ( { type : windowStateActions . REMEMBER_ZOOM_LEVEL , payload : zoomState , } ) ; } ) ; test ( 's' , ( ) => { const themes = [ { name : 's' , href : 's' } , { name : 's' , href : 's' } ] ; expect ( windowStateActions . setAvailableThemes ( themes ) ) . toEqual ( { type : windowStateActions . SET_AVAILABLE_THEMES , payload : { availableThemes : themes } , } ) ; } ) ; } ) ;	O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O O $string$ O $any$ O O O $complex$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O $WindowStateAction<RememberZoomLevelPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $WindowStateAction<SetAvailableThemesPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $complex$ O $complex$ O O O O O O O O O O O
import { getActiveBot , getBotInfoByPath , pathExistsInRecentBots } from 's' ; jest . mock ( 's' , ( ) => ( { store : { getState : ( ) => ( { bot : { activeBot : { name : 's' , description : 's' , padlock : 's' , services : [ ] , } , botFiles : [ { path : 's' , } , ] , } , } ) , } , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const activeBot = getActiveBot ( ) ; expect ( activeBot . name ) . toBe ( 's' ) ; expect ( activeBot . description ) . toBe ( 's' ) ; expect ( activeBot . padlock ) . toBe ( 's' ) ; expect ( activeBot . services ) . toEqual ( [ ] ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const result = getBotInfoByPath ( 's' ) ; expect ( result ) . toEqual ( { path : 's' } ) ; } ) ; it ( 's' , ( ) => { const result = getBotInfoByPath ( 's' ) ; expect ( result ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const botFound = pathExistsInRecentBots ( 's' ) ; expect ( botFound ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const botFound = pathExistsInRecentBots ( 's' ) ; expect ( botFound ) . toBe ( false ) ; } ) ; } ) ; jest . unmock ( 's' ) ; } ) ;	O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O $complex$ O O O $string$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O $boolean$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O $boolean$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O
import { documentIdForConversation } from 's' ; let mockState ; const mockGetState = jest . fn ( ( ) => mockState ) ; const mockStore = { getState : mockGetState , } ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockState = { } ; mockGetState . mockClear ( ) ; } ) ; test ( 's' , ( ) => { mockState = { chat : { chats : { 0 : { conversationId : 's' , documentId : 's' , } , } , } , } ; expect ( documentIdForConversation ( 's' ) ) . toBe ( 's' ) ; expect ( documentIdForConversation ( 's' ) ) . toBe ( undefined ) ; } ) ; } ) ;	O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O $any$ O $string$ O O O O O $any$ O O O O $any$ O $string$ O O O O O $any$ O $undefined$ O O O O O O O O
import { SharedConstants } from 's' ; import { open } from 's' ; import { getOtherTabGroup , getTabGroupForDocument , hasNonGlobalTabs , showWelcomePage , tabGroupHasDocuments , } from 's' ; let mockState ; const mockDispatch = jest . fn ( ( ) => null ) ; const mockGetState = jest . fn ( ( ) => mockState ) ; const mockStore = { getState : mockGetState , dispatch : mockDispatch , } ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockState = { } ; mockGetState . mockClear ( ) ; mockDispatch . mockClear ( ) ; } ) ; test ( 's' , ( ) => { mockState = { editor : { editors : { primary : { documents : { 0 : { } , 0 : { isGlobal : true , } , } , } , secondary : { documents : { } , } , } , } , } ; let result = ! ! hasNonGlobalTabs ( ) ; expect ( result ) . toBe ( true ) ; result = ! ! hasNonGlobalTabs ( mockState . editor . editors ) ; expect ( result ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { mockState = { editor : { editors : { primary : { documents : { 0 : { } , 0 : { isGlobal : true , } , } , } , secondary : { documents : { } , } , } , } , } ; let result = getTabGroupForDocument ( 's' ) ; expect ( result ) . toBe ( 's' ) ; result = getTabGroupForDocument ( 's' , mockState . editor . editors ) ; expect ( result ) . toBe ( undefined ) ; } ) ; test ( 's' , ( ) => { expect ( getOtherTabGroup ( SharedConstants . EDITOR_KEY_PRIMARY ) ) . toBe ( SharedConstants . EDITOR_KEY_SECONDARY ) ; expect ( getOtherTabGroup ( SharedConstants . EDITOR_KEY_SECONDARY ) ) . toBe ( SharedConstants . EDITOR_KEY_PRIMARY ) ; } ) ; test ( 's' , ( ) => { showWelcomePage ( ) ; expect ( mockDispatch ) . toHaveBeenCalledWith ( open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_WELCOME_PAGE , documentId : SharedConstants . DocumentIds . DOCUMENT_ID_WELCOME_PAGE , isGlobal : true , } ) ) ; } ) ; test ( 's' , ( ) => { expect ( tabGroupHasDocuments ( { documents : { 0 : { } } } ) ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O O O O O O $OpenEditorAction$ O O O O O O $string$ O $string$ O $number$ O $void$ O $boolean$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O ${}$ O O O O $complex$ O O $boolean$ O O O O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O $boolean$ O O O $number$ O O O $any$ O $boolean$ O O $any$ O O O O $boolean$ O O O $number$ O $any$ O $any$ O $any$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O ${}$ O O O O $complex$ O O $boolean$ O O O O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O $string$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $void$ O O O $any$ O $any$ O O $any$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $true$ O O O O O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O ${}$ O O O O O O O O $any$ O O O O O O O O O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
import { forwardToMain } from 's' ; const mockIpcRenderer = { sendSync : jest . fn ( ( ) => null ) , } ; jest . mock ( 's' , ( ) => ( { get ipcRenderer ( ) { return mockIpcRenderer ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockIpcRenderer . sendSync . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { } ; forwardToMain ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockIpcRenderer . sendSync ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { type : 's' , meta : { doNotForward : true } , } ; forwardToMain ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockIpcRenderer . sendSync ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { type : 's' , payload : { someProp : 0 } , } ; forwardToMain ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockIpcRenderer . sendSync ) . toHaveBeenCalledWith ( 's' , mockAction ) ; } ) ; } ) ;	O O $any$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $complex$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $complex$ O O $boolean$ O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $any$ O O $any$ O O O $any$ O O O O O O O O
import { azureArmTokenDataChanged , invalidateArmToken } from 's' ; import { azureAuth , AzureAuthState } from 's' ; describe ( 's' , ( ) => { let startingState ; beforeEach ( ( ) => { startingState = { access_token : null , persistLogin : false , } ; } ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : undefined } ; const endingState = azureAuth ( startingState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = azureArmTokenDataChanged ( 's' ) ; const state = azureAuth ( startingState , action ) ; expect ( state . access_token ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { const action = invalidateArmToken ( ) ; const state = azureAuth ( startingState , action ) ; expect ( state . access_token ) . toBe ( 's' ) ; } ) ; } ) ;	O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<void>$ O O O O O O $AzureAuthState$ O $any$ O O O O $any$ O O O O O O O O $AzureAuthState$ O $any$ O O O O O $AzureAuthState$ O O $null$ O O O $false$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $null$ O O O $undefined$ O $undefined$ O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $complex$ O O $any$ O $AzureAuthState$ O O $any$ O $AzureAuthState$ O O O O O $any$ O O O O O O O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<ArmTokenData>$ O O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction<ArmTokenData>$ O O $any$ O $AzureAuthState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $AzureAuthAction<void>$ O $AzureAuthAction<void>$ O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction<void>$ O O $any$ O $AzureAuthState$ O $string$ O O $any$ O O O O O O O O O O
import { combineReducers , createStore , Store } from 's' ; import { Settings } from 's' ; import { azureLoggedInUserChanged , azurePersistLoginChanged } from 's' ; import { azureAuthSettings } from 's' ; describe ( 's' , ( ) => { let store < Settings > ; beforeAll ( ( ) => { store = createStore ( combineReducers ( { azure : azureAuthSettings } ) ) ; } ) ; it ( 's' , ( ) => { expect ( JSON . stringify ( store . getState ( ) . azure ) ) . toBe ( JSON . stringify ( { } ) ) ; } ) ; it ( 's' , ( ) => { store . dispatch ( azurePersistLoginChanged ( true ) ) ; expect ( store . getState ( ) . azure . persistLogin ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; expect ( store . getState ( ) . azure . signedInUser ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<string>$ O $AzureAuthAction<boolean>$ O O O O O O $any$ O O O O $any$ O O O O O O O O $Store$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O O $any$ O O O $any$ O $JSON$ O $complex$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<boolean>$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { BotInfo } from 's' ; import { BotConfigWithPath } from 's' ; import { BotAction , load , setActive , setDirectory , close , mockAndSetActive } from 's' ; import { BotState , bot } from 's' ; describe ( 's' , ( ) => { let defaultState ; beforeEach ( ( ) => { defaultState = { activeBot : null , botFiles : [ ] , currentBotDirectory : null , } ; } ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... defaultState } ; const endingState = bot ( defaultState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const bots : BotInfo [ ] = [ { displayName : 's' , path : 's' , secret : null , } , { displayName : 's' , path : 's' , secret : 's' , } , { displayName : 's' , path : 's' , secret : null , } , null , ] ; const action = load ( bots ) ; const state = bot ( defaultState , action ) ; expect ( state . botFiles ) . not . toEqual ( bots ) ; expect ( state . botFiles . length ) . toBe ( 0 ) ; expect ( state . botFiles ) . toEqual ( [ { displayName : 's' , path : 's' , secret : null , } , { displayName : 's' , path : 's' , secret : 's' , } , { displayName : 's' , path : 's' , secret : null , } , ] ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const startingState = { ... defaultState , activeBot , } ; const action = close ( ) ; const state = bot ( startingState , action ) ; expect ( state . activeBot ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const action = setDirectory ( 's' ) ; const state = bot ( defaultState , action ) ; expect ( state . currentBotDirectory ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; expect ( defaultState . activeBot ) . toBe ( null ) ; const action = setActive ( activeBot ) ; const state = bot ( defaultState , action ) ; expect ( state . activeBot ) . toEqual ( activeBot ) ; expect ( state . activeBot . path ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , overrides : { endpoint : { endpoint : 's' , id : 's' , appId : 's' , appPassword : 's' , } , } , } ; const startingState = { ... defaultState , activeBot , } ; const newActiveBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const action = setActive ( newActiveBot ) ; const endingState = bot ( startingState , action ) ; expect ( endingState . activeBot . name ) . toBe ( 's' ) ; expect ( endingState . activeBot . overrides ) . toBeTruthy ( ) ; const endpointOverrides = endingState . activeBot . overrides . endpoint ; expect ( endpointOverrides . endpoint ) . toBe ( 's' ) ; expect ( endpointOverrides . id ) . toBe ( 's' ) ; expect ( endpointOverrides . appId ) . toBe ( 's' ) ; expect ( endpointOverrides . appPassword ) . toBe ( 's' ) ; } ) ; it ( "s" , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , overrides : { endpoint : { endpoint : 's' , id : 's' , appId : 's' , appPassword : 's' , } , } , } ; const startingState = { ... defaultState , activeBot , } ; const newActiveBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const action = setActive ( newActiveBot ) ; const endingState = bot ( startingState , action ) ; expect ( endingState . activeBot . name ) . toBe ( 's' ) ; expect ( endingState . activeBot . overrides ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const botMock = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ ] , } ; const action = mockAndSetActive ( botMock ) ; const state = bot ( defaultState , action ) ; expect ( state . activeBot ) . not . toBe ( null ) ; expect ( state . activeBot . name ) . toBe ( 's' ) ; expect ( state . activeBot . description ) . toBe ( 's' ) ; expect ( state . activeBot . path ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O $BotAction<SetDirectoryPayload>$ O $BotAction<{}>$ O $BotAction<any>$ O O O O O O $any$ O $BotState$ O O O O $any$ O O O O O O O O $BotState$ O $any$ O O O O O $BotState$ O O $null$ O O O $undefined[]$ O O O O $null$ O O O O O O O O $any$ O O O O O O O O $BotAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $BotState$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<any>$ O O $any$ O $BotState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any[]$ O $any$ O O O O O $string$ O O O $string$ O O O $null$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $null$ O O O O O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<LoadBotPayload>$ O O $any$ O $BotState$ O $any[]$ O O $any$ O $any$ O $any[]$ O O $any$ O $BotState$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $BotState$ O $any[]$ O O $any$ O O O $string$ O O O $string$ O O O $null$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $null$ O O O O O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<{}>$ O O $any$ O $BotState$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotAction<SetDirectoryPayload>$ O $BotAction<SetDirectoryPayload>$ O O O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetDirectoryPayload>$ O O $any$ O $BotState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O $any$ O $BotState$ O $any$ O O $any$ O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $undefined[]$ O O O O O O O $BotAction<any>$ O $BotAction<any>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<any>$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { LogEntry , LogItemType } from 's' ; import { addTranscript , appendToLog , ChatAction , clearLog , clearTranscripts , closeDocument , newChat , newConversation , removeTranscript , setInspectorObjects , updateChat , } from 's' ; import { closeNonGlobalTabs } from 's' ; import { chat , ChatState } from 's' ; describe ( 's' , ( ) => { const testChatId = 's' ; const DEFAULT_STATE = { changeKey : 0 , chats : { [ testChatId ] : { log : { entries : [ ] , } , } , } , transcripts : [ ] , } as any ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = chat ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = addTranscript ( 's' ) ; const state = chat ( DEFAULT_STATE , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . transcripts [ 0 ] ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , addTranscript ( 's' ) ) ; state = chat ( state , addTranscript ( 's' ) ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; const action = removeTranscript ( 's' ) ; state = chat ( state , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . transcripts ) . not . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , addTranscript ( 's' ) ) ; state = chat ( state , addTranscript ( 's' ) ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; const action = clearTranscripts ( ) ; state = chat ( state , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const newChatName = 's' ; const action = newChat ( newChatName , 's' ) ; const state = chat ( DEFAULT_STATE , action ) ; expect ( state . changeKey ) . toBe ( 0 ) ; expect ( state . chats [ newChatName ] ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , newChat ( testChatId , 's' ) ) ; const action = closeDocument ( testChatId ) ; state = chat ( DEFAULT_STATE , action ) ; expect ( state . chats [ testChatId ] ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const action = newConversation ( testChatId , { testing : true } ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { } , } , } ; const endingState = chat ( startingState , action ) ; const expectedDoc = { ... endingState . chats [ testChatId ] , testing : true , } ; expect ( endingState . chats [ testChatId ] ) . toEqual ( expectedDoc ) ; } ) ; it ( 's' , ( ) => { const logEntry = { timestamp : 0 , items : [ { type : LogItemType . Text , payload : { level : 0 , text : 's' , } , } , ] , } ; const action = appendToLog ( testChatId , logEntry ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { log : { entries : [ ] , } , } , } , } ; const endingState = chat ( startingState , action ) ; expect ( endingState . chats [ testChatId ] . log . entries [ 0 ] ) . toBeTruthy ( ) ; expect ( endingState . chats [ testChatId ] . log . entries [ 0 ] ) . toEqual ( logEntry ) ; } ) ; it ( 's' , ( ) => { const logEntry = { timestamp : 0 , items : [ { type : LogItemType . Text , payload : { level : 0 , text : 's' , } , } , ] , } ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { log : { entries : [ ] , } , } , } , } ; let state = chat ( startingState , appendToLog ( testChatId , logEntry ) ) ; expect ( state . chats [ testChatId ] . log . entries . length ) . toBeGreaterThan ( 0 ) ; const action = clearLog ( testChatId ) ; state = chat ( state , action ) ; expect ( state . chats [ testChatId ] . log . entries . length ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const action = setInspectorObjects ( testChatId , { testing : true } ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { } , } , } ; const endingState = chat ( startingState , action ) ; expect ( endingState . chats [ testChatId ] . inspectorObjects . length ) . toBeGreaterThan ( 0 ) ; expect ( endingState . chats [ testChatId ] . inspectorObjects [ 0 ] ) . toEqual ( { testing : true , } ) ; } ) ; it ( 's' , ( ) => { const tempChat = 's' ; const alteredState = { changeKey : 0 , chats : { [ tempChat ] : { testing : true , } , } , transcripts : [ 's' , 's' , 's' ] , } as any ; const action = closeNonGlobalTabs ( ) ; const state = chat ( alteredState , action ) ; expect ( state . changeKey ) . toBe ( 0 ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . chats [ tempChat ] ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , 0 : { id : 's' , userId : 's' , } , } , } ; const action = updateChat ( 's' , { id : 's' , userId : 's' , } ) ; const state = chat ( startingState , action ) ; expect ( state . chats . 0 . id ) . toBe ( 's' ) ; expect ( state . chats . 0 . userId ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AppendLogPayload>$ O $any$ O $ChatAction<ClearLogPayload>$ O $ChatAction<{}>$ O $ChatAction<DocumentIdPayload>$ O $complex$ O $ChatAction<NewConversationPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<UpdateChatPayload>$ O O O O O O O $CloseAllEditorAction$ O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O $ChatState$ O O $number$ O O O $complex$ O O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O $undefined[]$ O O O O O O O O $any$ O O O O O O O O $ChatAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $ChatState$ O O O $ChatState$ O O O $ChatState$ O $ChatAction<any>$ O O $any$ O $ChatState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<RemoveTranscriptPayload>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O $ChatAction<{}>$ O $ChatAction<{}>$ O O O $ChatState$ O O O $ChatState$ O $ChatAction<{}>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O O O O $ChatState$ O O O $ChatState$ O $complex$ O O $any$ O $ChatState$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $complex$ O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<DocumentIdPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $ChatAction<NewConversationPayload>$ O $ChatAction<NewConversationPayload>$ O O O O $boolean$ O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<NewConversationPayload>$ O O O O O O O $ChatState$ O $complex$ O O O O $boolean$ O O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $LogEntry$ O O $number$ O O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $string$ O O O O O O O O O O O O $ChatAction<AppendLogPayload>$ O $ChatAction<AppendLogPayload>$ O O O $any$ O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<AppendLogPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O O O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $LogEntry$ O O $number$ O O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $string$ O O O O O O O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<AppendLogPayload>$ O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O $number$ O O $any$ O O O O O $ChatAction<ClearLogPayload>$ O $ChatAction<ClearLogPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<ClearLogPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O O $boolean$ O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<SetInspectorObjectsPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $any[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O $any[]$ O O O O O $any$ O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O O O O O $ChatState$ O O $number$ O O O $complex$ O O O O O O O $boolean$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O O $ChatState$ O O O $ChatState$ O $CloseAllEditorAction$ O O $any$ O $ChatState$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $ChatState$ O O O O O $ChatState$ O $complex$ O $complex$ O O $string$ O O O $string$ O O O O O O O O O O $ChatAction<UpdateChatPayload>$ O $ChatAction<UpdateChatPayload>$ O O O O $string$ O O O $string$ O O O O O O O $ChatState$ O O O O O $ChatAction<UpdateChatPayload>$ O O $any$ O $ChatState$ O $complex$ O $any$ O $any$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O $any$ O $string$ O O $any$ O O O O O O O O O O
import { clientAwareSettingsChanged } from 's' ; import { clientAwareSettings } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( clientAwareSettings ( undefined , { type : 's' } as any ) ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const mockSettings = { someSetting : 0 } ; const action = clientAwareSettingsChanged ( mockSettings ) ; const state = clientAwareSettings ( { } as any , action ) ; expect ( state ) . toEqual ( mockSettings ) ; } ) ; } ) ;	O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $ClientAwareSettingsActions$ O $ClientAwareSettingsActions$ O $any$ O O O $any$ O $any$ O O O O O O $ClientAwareSettingsActions$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { DialogAction , setShowing } from 's' ; import { dialog , DialogState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { showing : false , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = dialog ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = setShowing ( true ) ; const state = dialog ( DEFAULT_STATE , action ) ; expect ( state . showing ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $SetShowingDialogAction$ O O O O O O $DialogState$ O $any$ O O O O $any$ O O O O O O O O $DialogState$ O O $false$ O O O O O $any$ O O O O O O O O $DialogAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $DialogState$ O O O $DialogState$ O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O O $any$ O $DialogState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $DialogAction$ O $SetShowingDialogAction$ O O O O O $DialogState$ O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O O $any$ O $DialogState$ O $boolean$ O O $any$ O O O O O O O O O O
import { deepCopySlow } from 's' ; import * as Constants from 's' ; import { addDocPendingChange , appendTab , close , closeNonGlobalTabs , dropTabOnLeftOverlay , EditorAction , open , removeDocPendingChange , setActiveEditor as setActiveEditorAction , setActiveTab , setDirtyFlag , splitTab , swapTabs , toggleDraggingTab , updateDocument , } from 's' ; import { editor , Editor , EditorState , fixupTabGroups , removeDocumentFromTabGroup , setActiveEditor , setDraggingTab , setEditorState , setNewPrimaryEditor , } from 's' ; let defaultState ; jest . mock ( 's' , ( ) => ( { AzureLoginPromptDialogContainer : function mock ( ) { return undefined ; } , AzureLoginSuccessDialogContainer : function mock ( ) { return undefined ; } , BotCreationDialog : function mock ( ) { return undefined ; } , DialogService : { showDialog : ( ) => Promise . resolve ( true ) } , SecretPromptDialog : function mock ( ) { return undefined ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( initializeDefaultState ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... defaultState } ; const endingState = editor ( defaultState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , draggingTab : true , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , tabOrder : [ 's' , 's' ] , } , } , } ; const srcEditorKey = Constants . EDITOR_KEY_PRIMARY ; const destEditorKey = Constants . EDITOR_KEY_PRIMARY ; const docIdToAppend = 's' ; const action = appendTab ( srcEditorKey , destEditorKey , docIdToAppend ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . tabOrder [ 0 ] ) . not . toBe ( docIdToAppend ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . tabOrder [ 0 ] ) . toBe ( docIdToAppend ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , tabOrder : [ 's' , 's' ] , recentTabs : [ 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = Constants . EDITOR_KEY_PRIMARY ; const destEditorKey = Constants . EDITOR_KEY_SECONDARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const srcEditor = endingState . editors [ srcEditorKey ] ; const destEditor = endingState . editors [ destEditorKey ] ; expect ( Object . keys ( destEditor . documents ) ) . toContain ( 's' ) ; expect ( destEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( destEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( Object . keys ( srcEditor . documents ) ) . not . toContain ( 's' ) ; expect ( srcEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( srcEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = Constants . EDITOR_KEY_SECONDARY ; const destEditorKey = Constants . EDITOR_KEY_PRIMARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = Constants . EDITOR_KEY_PRIMARY ; const destEditorKey = Constants . EDITOR_KEY_SECONDARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . tabOrder ) . toEqual ( [ ] ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const editorKey = Constants . EDITOR_KEY_PRIMARY ; const action = close ( editorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const modifiedEditor = endingState . editors [ editorKey ] ; expect ( Object . keys ( modifiedEditor . documents ) ) . not . toContain ( 's' ) ; expect ( modifiedEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( modifiedEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const editorKey = Constants . EDITOR_KEY_PRIMARY ; const action = close ( editorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( Object . keys ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . documents ) ) . not . toContain ( 's' ) ; } ) ; } ) ; it ( 's' , ( ) => { const action = toggleDraggingTab ( true ) ; const state = editor ( defaultState , action ) ; expect ( state . draggingTab ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , } ; const action = setActiveEditorAction ( Constants . EDITOR_KEY_PRIMARY ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = setActiveTab ( 's' ) ; const endingState = editor ( startingState , action ) ; const newActiveEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( newActiveEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( newActiveEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( "s" , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { dirty : false } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const dirtyDocId = 's' ; const action = setDirtyFlag ( dirtyDocId , true ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . documents [ dirtyDocId ] . dirty ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { isGlobal : true } , 0 : { isGlobal : false } , 0 : { isGlobal : false } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { isGlobal : false } , 0 : { isGlobal : true } , 0 : { isGlobal : true } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , } , docsWithPendingChanges : [ 's' , 's' ] , } ; const action = closeNonGlobalTabs ( ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( endingState . docsWithPendingChanges ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { documentId : 's' } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const docToUpdateId = 's' ; const action = updateDocument ( docToUpdateId , { isGlobal : true , dirty : true , } ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . documents [ docToUpdateId ] ) . toEqual ( { documentId : 's' , isGlobal : true , dirty : true , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : Constants . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_SECONDARY ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : Constants . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : Constants . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; } ) ; it ( "s" , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : Constants . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; } ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , draggingTab : true , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = splitTab ( Constants . CONTENT_TYPE_APP_SETTINGS , 's' , Constants . EDITOR_KEY_PRIMARY , Constants . EDITOR_KEY_SECONDARY ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( Object . keys ( primaryEditor . documents ) ) . not . toContain ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toContain ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , } , } ; const action = swapTabs ( Constants . EDITOR_KEY_PRIMARY , Constants . EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = swapTabs ( Constants . EDITOR_KEY_SECONDARY , Constants . EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_SECONDARY ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . not . toContain ( 's' ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = swapTabs ( Constants . EDITOR_KEY_SECONDARY , Constants . EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = swapTabs ( Constants . EDITOR_KEY_PRIMARY , Constants . EDITOR_KEY_SECONDARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( null ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , docsWithPendingChanges : [ 's' , 's' , 's' ] , } ; const 0 = addDocPendingChange ( 's' ) ; const 0 = editor ( startingState , 0 ) ; expect ( 0 . docsWithPendingChanges ) . toEqual ( [ 's' , 's' , 's' , 's' ] ) ; const 0 = addDocPendingChange ( 's' ) ; const 0 = editor ( 0 , 0 ) ; expect ( 0 . docsWithPendingChanges ) . toEqual ( [ 's' , 's' , 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , docsWithPendingChanges : [ 's' , 's' , 's' ] , } ; const action = removeDocPendingChange ( 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . docsWithPendingChanges ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( initializeDefaultState ) ; it ( 's' , ( ) => { let state = setDraggingTab ( true , defaultState ) ; expect ( state . draggingTab ) . toBe ( true ) ; state = setDraggingTab ( false , state ) ; expect ( state . draggingTab ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_SECONDARY ] : { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const newPrimaryEditor = { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const endingState = setNewPrimaryEditor ( newPrimaryEditor , startingState ) ; expect ( endingState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . activeDocumentId ) . toEqual ( 's' ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] . documents ) ) . toContain ( 's' ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . activeDocumentId ) . toBe ( null ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . documents ) . toEqual ( { } ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . recentTabs ) . toEqual ( [ ] ) ; expect ( endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] . tabOrder ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const newState = setActiveEditor ( 's' , defaultState ) ; expect ( newState ) . not . toBe ( defaultState ) ; expect ( newState . activeEditor ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const updatedEditor = { activeDocumentId : 's' , documents : { } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const newState = setEditorState ( Constants . EDITOR_KEY_PRIMARY , updatedEditor , defaultState ) ; expect ( newState ) . not . toBe ( defaultState ) ; expect ( newState . editors [ Constants . EDITOR_KEY_PRIMARY ] . activeDocumentId ) . toBe ( 's' ) ; expect ( newState . editors [ Constants . EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( newState . editors [ Constants . EDITOR_KEY_PRIMARY ] . recentTabs ) . toEqual ( [ 's' ] ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const docToRemove = 's' ; const tempEditor = { activeDocumentId : docToRemove , documents : { [ docToRemove ] : { } , 0 : { } , } , tabOrder : [ docToRemove , 's' ] , recentTabs : [ docToRemove , 's' ] , } ; const modifiedEditor = removeDocumentFromTabGroup ( tempEditor , docToRemove ) ; expect ( modifiedEditor ) . not . toBe ( tempEditor ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( modifiedEditor . recentTabs ) . not . toContain ( docToRemove ) ; expect ( modifiedEditor . tabOrder ) . not . toContain ( docToRemove ) ; expect ( Object . keys ( modifiedEditor . documents ) ) . not . toContain ( docToRemove ) ; } ) ; it ( 's' , ( ) => { const tempEditor = { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const modifiedEditor = removeDocumentFromTabGroup ( tempEditor , 's' ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( null ) ; expect ( modifiedEditor . documents ) . toEqual ( { } ) ; expect ( modifiedEditor . recentTabs ) . toEqual ( [ ] ) ; expect ( modifiedEditor . tabOrder ) . toEqual ( [ ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; const primaryEditor = endState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( endState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( null ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ ] ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; expect ( endState . activeEditor ) . toBe ( Constants . EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ Constants . EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ Constants . EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; expect ( endState ) . toEqual ( startingState ) ; } ) ; } ) ; test ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { [ Constants . EDITOR_KEY_PRIMARY ] : { activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { } , } , } ; const tabIdToDrop = 's' ; const action = dropTabOnLeftOverlay ( tabIdToDrop ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ Constants . EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ Constants . EDITOR_KEY_SECONDARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( tabIdToDrop ) ; expect ( primaryEditor . recentTabs ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs [ 0 ] ) . toBe ( tabIdToDrop ) ; expect ( primaryEditor . tabOrder ) . toHaveLength ( 0 ) ; expect ( primaryEditor . tabOrder [ 0 ] ) . toBe ( tabIdToDrop ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . documents [ tabIdToDrop ] ) . toBeTruthy ( ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ; function initializeDefaultState ( ) { const DEFAULT_STATE = { activeEditor : null , draggingTab : false , editors : { [ Constants . EDITOR_KEY_PRIMARY ] : { activeDocumentId : null , documents : { } , tabOrder : [ ] , recentTabs : [ ] , } , [ Constants . EDITOR_KEY_SECONDARY ] : { activeDocumentId : null , documents : { } , tabOrder : [ ] , recentTabs : [ ] , } , } , docsWithPendingChanges : [ ] , } ; defaultState = deepCopySlow ( DEFAULT_STATE ) ; }	O O $any$ O O O O O O O $any$ O O O O O $AddDocPendingChangeAction$ O $AppendTabAction$ O $CloseEditorAction$ O $CloseAllEditorAction$ O $DropTabOnLeftOverlayAction$ O $any$ O $OpenEditorAction$ O $RemoveDocPendingChangeAction$ O $SetActiveEditorAction$ O $SetActiveEditorAction$ O $SetActiveTabAction$ O $SetDirtyFlagAction$ O $SplitTabAction$ O $SwapTabsAction$ O $ToggleDraggingTabAction$ O $UpdateDocumentAction$ O O O O O O O O O $any$ O $any$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O O O O $EditorState$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O $undefined$ O O O $any$ O O $any$ O O O O $undefined$ O O O $any$ O O $any$ O O O O $undefined$ O O O $complex$ O O $Promise<boolean>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O O $any$ O O O O $undefined$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $EditorAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $EditorState<any>$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $EditorAction$ O O $any$ O $EditorState<any>$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $true$ O O O $complex$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O O O O $any$ O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O O O O $any$ O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O O O $any$ O O O O $CloseEditorAction$ O $CloseEditorAction$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O $any$ O O O O $CloseEditorAction$ O $CloseEditorAction$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O O O $complex$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $ToggleDraggingTabAction$ O $ToggleDraggingTabAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $ToggleDraggingTabAction$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O $SetActiveEditorAction$ O $SetActiveEditorAction$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetActiveEditorAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SetActiveTabAction$ O $SetActiveTabAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetActiveTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O $complex$ O O $false$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O $SetDirtyFlagAction$ O $SetDirtyFlagAction$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetDirtyFlagAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $complex$ O O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O $complex$ O O $true$ O O O O $complex$ O O $false$ O O O O $complex$ O O $false$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O $complex$ O O $false$ O O O O $complex$ O O $true$ O O O O $complex$ O O $true$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O O $string[]$ O O O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseAllEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O $complex$ O O $string$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O $UpdateDocumentAction$ O $UpdateDocumentAction$ O O O O $true$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $UpdateDocumentAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $complex$ O O O O O $any$ O O $string$ O O O $boolean$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $string$ O $any$ O O O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O $true$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SplitTabAction$ O $SplitTabAction$ O $any$ O O O O O $any$ O O O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SplitTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O O O $any$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O O O $any$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O O O $any$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O O O $any$ O O O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string[]$ O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AddDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AddDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string[]$ O O O O O O O O O O O O $RemoveDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $RemoveDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $Editor$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O O O $complex$ O O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $complex$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $Editor$ O O $string$ O O O ${}$ O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O O O $string[]$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $Editor$ O O $string$ O O O O O O O O O O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $Editor<any>$ O $Editor<any>$ O $Editor<any>$ O O O O $any$ O $Editor<any>$ O O $any$ O $any$ O $Editor<any>$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Editor$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $Editor<any>$ O $Editor<any>$ O $Editor<any>$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $complex$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $EditorState<any>$ O $complex$ O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O O O $EditorState<any>$ O $complex$ O $any$ O O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string$ O $any$ O O O O O O O $any$ O O O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $DropTabOnLeftOverlayAction$ O $DropTabOnLeftOverlayAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $DropTabOnLeftOverlayAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $complex$ O O O O O $any$ O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O O O O O O O O O $void$ O O O O $EditorState$ O O $null$ O O O $false$ O O O $complex$ O O O $any$ O O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $any$ O O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O $undefined[]$ O O O O O O $EditorState<any>$ O $any$ O $EditorState<any>$ O O O
import { ExplorerAction , showExplorer } from 's' ; import { explorer , ExplorerState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { showing : false , sortSelectionByPanelId : { } , } ; it ( 's' , ( ) => { const emptyAction < any > = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = explorer ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action < any > = showExplorer ( true ) ; const state = explorer ( DEFAULT_STATE , action ) ; expect ( state . showing ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $ExplorerAction<ExplorerPayload>$ O O O O O O $ExplorerState$ O $any$ O O O O $any$ O O O O O O O O $ExplorerState$ O O $false$ O O O ${}$ O O O O O O $any$ O O O O O O O O $ExplorerAction$ O O O O O $null$ O O O $null$ O O O O O $complex$ O O O $ExplorerState$ O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction<any>$ O O $any$ O $ExplorerState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ExplorerAction$ O O O O $ExplorerAction<ExplorerPayload>$ O O O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction<any>$ O O $any$ O $ExplorerState$ O $boolean$ O O $any$ O O O O O O O O O O
import { frameworkDefault } from 's' ; import { setFrameworkSettings } from 's' ; import { framework } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = framework ( undefined , { type : 's' } as any ) ; expect ( state ) . toEqual ( frameworkDefault ) ; } ) ; it ( 's' , ( ) => { const mockSettings = { someSetting : 0 } ; const action = setFrameworkSettings ( mockSettings ) ; const state = framework ( { } as any , action ) ; expect ( state ) . toEqual ( mockSettings ) ; } ) ; } ) ;	O O $any$ O O O O O O $FrameworkAction<any>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $FrameworkAction<any>$ O $FrameworkAction<any>$ O $any$ O O O $any$ O $any$ O O O O O O $FrameworkAction<any>$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { NavBarAction , select } from 's' ; import { navBar , NavBarState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { selection : null , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = navBar ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = select ( 's' ) ; const state = navBar ( DEFAULT_STATE , action ) ; expect ( state . selection ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $SelectNavBarAction$ O O O O O O $NavBarState$ O $any$ O O O O $any$ O O O O O O O O $NavBarState$ O O $null$ O O O O O $any$ O O O O O O O O $NavBarAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $NavBarState$ O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $SelectNavBarAction$ O O $any$ O $NavBarState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $NavBarAction$ O $SelectNavBarAction$ O O O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $SelectNavBarAction$ O O $any$ O $NavBarState$ O $string$ O O $any$ O O O O O O O O O O
import { newNotification } from 's' ; import { finishAdd , finishRemove , finishClear , NotificationAction } from 's' ; import notification , { NotificationState } from 's' ; describe ( 's' , ( ) => { let defaultState ; beforeEach ( ( ) => { defaultState = { allIds : [ ] , } ; } ) ; test ( 's' , ( ) => { const action = { type : null , payload : { } } ; const endingState = notification ( defaultState , action ) ; expect ( endingState ) . toEqual ( defaultState ) ; } ) ; test ( 's' , ( ) => { const 0 = newNotification ( 's' ) ; const action = finishAdd ( 0 ) ; let endingState = notification ( defaultState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === 0 . id ) ) . toBe ( true ) ; endingState = notification ( endingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === 0 . id ) ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const idToRemove = 's' ; const startingState = { allIds : [ idToRemove , 's' ] , } ; const action = finishRemove ( idToRemove ) ; let endingState = notification ( startingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === idToRemove ) ) . toBe ( false ) ; endingState = notification ( endingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === idToRemove ) ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const startingState = { allIds : [ 's' , 's' , 's' ] , } ; const action = finishClear ( ) ; const endingState = notification ( startingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $FinishAddNotificationAction$ O $FinishRemoveNotificationAction$ O $FinishClearNotificationAction$ O $any$ O O O O O $NotificationState$ O O $any$ O O O O $any$ O O O O O O O O $NotificationState$ O $any$ O O O O O $NotificationState$ O O $undefined[]$ O O O O O O O O O $any$ O O O O O O O O $NotificationAction$ O O $null$ O O O ${}$ O O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $complex$ O O $any$ O $NotificationState$ O O $any$ O $NotificationState$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $NotificationAction$ O $FinishAddNotificationAction$ O $any$ O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishAddNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O $any$ O O O $any$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishAddNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $NotificationState$ O O $string[]$ O O O O O O O O O O $NotificationAction$ O $FinishRemoveNotificationAction$ O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishRemoveNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O O O O O $any$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishRemoveNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $NotificationState$ O O $string[]$ O O O O O O O O O O O O $NotificationAction$ O $FinishClearNotificationAction$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishClearNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O O O O O O O
import { disable , enable , PresentationAction } from 's' ; import { presentation , PresentationState } from 's' ; jest . mock ( 's' , ( ) => ( { AzureLoginPromptDialogContainer : function mock ( ) { return undefined ; } , AzureLoginSuccessDialogContainer : function mock ( ) { return undefined ; } , BotCreationDialog : function mock ( ) { return undefined ; } , DialogService : { showDialog : ( ) => Promise . resolve ( true ) } , SecretPromptDialog : function mock ( ) { return undefined ; } , } ) ) ; describe ( 's' , ( ) => { const DEFAULT_STATE = { enabled : null , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = presentation ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = disable ( ) ; const state = presentation ( DEFAULT_STATE , action ) ; expect ( state . enabled ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const action = enable ( ) ; const state = presentation ( DEFAULT_STATE , action ) ; expect ( state . enabled ) . toBe ( true ) ; } ) ; } ) ;	O O $PresentationAction$ O $PresentationAction$ O $any$ O O O O O O $PresentationState$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O $undefined$ O O O $any$ O O $any$ O O O O $undefined$ O O O $any$ O O $any$ O O O O $undefined$ O O O $complex$ O O $Promise<boolean>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O O $any$ O O O O $undefined$ O O O O O O O $any$ O O O O O O O O $PresentationState$ O O $null$ O O O O O $any$ O O O O O O O O $PresentationAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $PresentationState$ O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O $boolean$ O O $any$ O O O O O O O O O O
import { cancelCurrentProcess , updateProgressIndicator } from 's' ; import { initialState , progressIndicator } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = progressIndicator ( undefined , { type : 's' } as any ) ; expect ( state ) . toEqual ( initialState ) ; } ) ; it ( 's' , ( ) => { const payload = { label : 's' , progress : 0 } ; const action = updateProgressIndicator ( payload ) ; const state = progressIndicator ( { } as any , action ) ; expect ( state ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const state = progressIndicator ( { } as any , cancelCurrentProcess ( ) as any ) ; expect ( state ) . toEqual ( { canceled : true } ) ; } ) ; } ) ;	O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $undefined$ O O $string$ O O O O O O O $any$ O $ProgressIndicatorState$ O O $any$ O $ProgressIndicatorState$ O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $number$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O $any$ O $ProgressIndicatorState$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O O O $ProgressIndicatorAction<void>$ O O O O O O $any$ O $ProgressIndicatorState$ O O $any$ O O $boolean$ O O O O O O O O O O O
import { setOpenUrl } from 's' ; import { protocol , ProtocolState } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( protocol ( undefined , { type : 's' } as any ) ) . toEqual ( { openUrls : [ ] } ) ; } ) ; it ( 's' , ( ) => { const initialState = { openUrls : [ 's' ] } ; const action = setOpenUrl ( 's' ) ; const state = protocol ( initialState , action ) ; expect ( state ) . toEqual ( { openUrls : [ 's' , 's' ] } ) ; } ) ; } ) ;	O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O $ProtocolState$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ProtocolState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $undefined[]$ O O O O O O O O O $any$ O O O O O O O O $ProtocolState$ O O $string[]$ O O O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O $ProtocolState$ O $ProtocolState$ O $ProtocolState$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O $any$ O $ProtocolState$ O O $any$ O O $string[]$ O O O O O O O O O O O O O O O
import { transcriptsUpdated , transcriptDirectoryUpdated , chatFilesUpdated , chatsDirectoryUpdated , editResource , } from 's' ; import { resources } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( resources ( undefined , { type : 's' } as any ) ) . toEqual ( { transcripts : [ ] , transcriptsPath : 's' , chats : [ ] , chatsPath : 's' , resourceToRename : null , } ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' } ] ; const action = transcriptsUpdated ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { transcripts : payload } ) ; } ) ; it ( 's' , ( ) => { const action = transcriptDirectoryUpdated ( 's' ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { transcriptsPath : 's' } ) ; } ) ; it ( 's' , ( ) => { const action = chatsDirectoryUpdated ( 's' ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { chatsPath : 's' } ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' } ] ; const action = chatFilesUpdated ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { chats : payload } ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' } ; const action = editResource ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { resourceToRename : payload } ) ; } ) ; } ) ;	O O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<any>$ O O O O O O O $ResourcesState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ResourcesState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $undefined[]$ O O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any[]>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<string>$ O O $any$ O $ResourcesState$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<string>$ O O $any$ O $ResourcesState$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any[]>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O O O O
import { ADD_SAVED_BOT_URL } from 's' ; import { savedBotUrls } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = savedBotUrls ( [ ] , { } as any ) ; expect ( state ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const action = { type : ADD_SAVED_BOT_URL , payload : 's' } ; const state = savedBotUrls ( [ ] , action ) ; expect ( state ) . toEqual ( [ { url : 's' , lastAccessed : expect . any ( String ) } ] ) ; } ) ; it ( 's' , ( ) => { const action = { type : ADD_SAVED_BOT_URL , payload : 's' } ; const state = savedBotUrls ( [ { url : 's' , lastAccessed : new Date ( 's' ) . toUTCString ( ) } ] , action ) ; expect ( state ) . toEqual ( [ { url : 's' , lastAccessed : expect . any ( String ) } , { url : 's' , lastAccessed : expect . any ( String ) } , ] ) ; } ) ; } ) ;	O O O O O O O O O $BotUrl[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $BotUrl[]$ O $BotUrl[]$ O O O O O O O O O O $any$ O $BotUrl[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $BotUrl[]$ O $BotUrl[]$ O O O O $any$ O O $any$ O $BotUrl[]$ O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $BotUrl[]$ O $BotUrl[]$ O O O $string$ O O O $string$ O O $DateConstructor$ O O O O $string$ O O O O O $any$ O O $any$ O $BotUrl[]$ O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O O O O O
import { switchTheme } from 's' ; import { theme } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( theme ( undefined , { type : 's' } as any ) ) . toEqual ( { themeName : null , themeComponents : [ ] , } ) ; } ) ; it ( 's' , ( ) => { const action = switchTheme ( 's' , [ 's' ] ) ; const state = theme ( { } as any , action ) ; expect ( state ) . toEqual ( { themeName : 's' , themeComponents : [ 's' ] , } ) ; } ) ; } ) ;	O O $ThemeAction<SwitchThemePayload>$ O O O O O O $ThemeState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ThemeState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $null$ O O O $undefined[]$ O O O O O O O O O O $any$ O O O O O O O O $ThemeAction<SwitchThemePayload>$ O $ThemeAction<SwitchThemePayload>$ O O O O O O O O O $ThemeState$ O $ThemeState$ O O O O O O $ThemeAction<SwitchThemePayload>$ O O $any$ O $ThemeState$ O O $any$ O O $string$ O O O $string[]$ O O O O O O O O O O O O O O
import { UpdateStatus } from 's' ; import { setUpdateStatus } from 's' ; import { update } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( update ( undefined , { type : undefined , payload : undefined } ) ) . toEqual ( { status : UpdateStatus . Idle } ) ; } ) ; it ( 's' , ( ) => { const state = { status : UpdateStatus . UpdateDownloading } ; const action = setUpdateStatus ( UpdateStatus . UpdateReadyToInstall ) ; expect ( update ( state , action ) ) . toEqual ( { status : UpdateStatus . UpdateReadyToInstall } ) ; } ) ; } ) ;	O O $any$ O O O O O O $UpdateAction<any>$ O O O O O O $UpdateState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $UpdateState$ O $undefined$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $UpdateAction<any>$ O $UpdateAction<any>$ O $any$ O $any$ O O $any$ O $UpdateState$ O $complex$ O $UpdateAction<any>$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O
import { addUsers , setCurrentUser } from 's' ; import { users } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( users ( undefined , { type : 's' } as any ) ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const user = { id : 's' } ; const action = setCurrentUser ( user ) ; const state = users ( { } as any , action ) ; expect ( state ) . toEqual ( { currentUserId : 's' , usersById : { 0 : user } } ) ; } ) ; it ( 's' , ( ) => { const initialState = { usersById : { 0 : { } , } , } ; const action = addUsers ( [ { name : 's' , id : 's' } , { name : 's' , id : 's' } , { name : 's' , id : 's' } ] ) ; const state = users ( initialState , action ) ; expect ( state ) . toEqual ( { usersById : { 0 : { } , 0 : { name : 's' , id : 's' , } , 0 : { name : 's' , id : 's' , } , } , } ) ; } ) ; } ) ;	O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O $any$ O O O $any$ O $any$ O O O O O O $UserAction<UserPayload>$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O ${}$ O O O O O O O O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $UserAction<UserPayload>$ O O $any$ O $any$ O O $any$ O O O O O ${}$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O O O
import { windowStateDefault } from 's' ; import { rememberBounds , rememberTheme , rememberZoomLevel , setAvailableThemes } from 's' ; import { windowState } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( windowState ( undefined , { type : 's' } as any ) ) . toEqual ( windowStateDefault ) ; } ) ; it ( 's' , ( ) => { const payload = { displayId : 0 , top : 0 , left : 0 , width : 0 , height : 0 } ; const action = rememberBounds ( payload ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = rememberZoomLevel ( { zoomLevel : 0 } ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( { zoomLevel : 0 } ) ; } ) ; it ( 's' , ( ) => { const action = rememberTheme ( 's' ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( { theme : 's' } ) ; } ) ; it ( 's' , ( ) => { const themes = [ { name : 's' , href : 's' } , { name : 's' , href : 's' } ] ; const action = setAvailableThemes ( themes ) ; const state = windowState ( { } as any , action ) ; expect ( state . availableThemes ) . toEqual ( themes ) ; } ) ; } ) ;	O O $any$ O O O O O O $WindowStateAction<RememberBoundsPayload>$ O $WindowStateAction<RememberThemePayload>$ O $WindowStateAction<RememberZoomLevelPayload>$ O $WindowStateAction<SetAvailableThemesPayload>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $WindowStateAction<RememberBoundsPayload>$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberBoundsPayload>$ O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $WindowStateAction<RememberZoomLevelPayload>$ O $WindowStateAction<RememberZoomLevelPayload>$ O O $number$ O O O O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberZoomLevelPayload>$ O O $any$ O $any$ O O $any$ O O $number$ O O O O O O O O $any$ O O O O O O O O $WindowStateAction<RememberThemePayload>$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberThemePayload>$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O $WindowStateAction<SetAvailableThemesPayload>$ O $WindowStateAction<SetAvailableThemesPayload>$ O $complex$ O O O $any$ O $any$ O O O O O O $WindowStateAction<SetAvailableThemesPayload>$ O O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O
import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { SharedConstants } from 's' ; import { ServiceTypes } from 's' ; import { store } from 's' ; import { azureArmTokenDataChanged , beginAzureAuthWorkflow } from 's' ; import { AzureLoginFailedDialogContainer , AzureLoginPromptDialogContainer , AzureLoginSuccessDialogContainer , DialogService , } from 's' ; import { azureAuthSagas } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { DialogService : { showDialog : ( ) => Promise . resolve ( true ) } , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; it ( 's' , ( ) => { store . dispatch ( azureArmTokenDataChanged ( 's' ) ) ; const it = azureAuthSagas ( ) . next ( ) . value . FORK . args [ 0 ] ( { payload : 's' , } ) ; let val ; let ct = 0 ; while ( true ) { const next = it . next ( val ) ; if ( next . done ) { break ; } val = next . value ; if ( 's' in val ) { val = val . SELECT . selector ( store . getState ( ) ) ; expect ( val . access_token ) . toBe ( 's' ) ; } ct ++ ; } expect ( ct ) . toBe ( 0 ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { store . dispatch ( azureArmTokenDataChanged ( 's' ) ) ; DialogService . showDialog = ( ) => Promise . resolve ( false ) ; const it = azureAuthSagas ( ) . next ( ) . value . FORK . args [ 0 ] ( beginAzureAuthWorkflow ( AzureLoginPromptDialogContainer , { serviceType : ServiceTypes . Luis } , AzureLoginSuccessDialogContainer , AzureLoginFailedDialogContainer ) ) ; let val = undefined ; let ct = 0 ; while ( true ) { const next = it . next ( val ) ; if ( next . done ) { break ; } val = next . value ; if ( 's' in val ) { val = val . SELECT . selector ( store . getState ( ) ) ; expect ( val . access_token ) . toBe ( 's' ) ; } else if ( val instanceof Promise ) { val = await val ; expect ( val ) . toBe ( false ) ; } ct ++ ; } expect ( ct ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { store . dispatch ( azureArmTokenDataChanged ( 's' ) ) ; DialogService . showDialog = ( ) => Promise . resolve ( 0 ) ; jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( false ) ; const it = azureAuthSagas ( ) . next ( ) . value . FORK . args [ 0 ] ( beginAzureAuthWorkflow ( AzureLoginPromptDialogContainer , { serviceType : ServiceTypes . Luis } , AzureLoginSuccessDialogContainer , AzureLoginFailedDialogContainer ) ) ; let val = undefined ; let ct = 0 ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; while ( true ) { const next = it . next ( val ) ; if ( next . done ) { break ; } val = next . value ; if ( 's' in val ) { val = val . SELECT . selector ( store . getState ( ) ) ; expect ( val . access_token ) . toBe ( 's' ) ; } else if ( val instanceof Promise ) { val = await val ; if ( ct === 0 ) { expect ( val ) . toBe ( 0 ) ; } } else if ( 's' in val ) { val = val . CALL . fn . call ( null , val . CALL . args ) ; if ( val [ Symbol . toStringTag ] === 's' ) { val = await val ; if ( ct === 0 ) { expect ( val ) . toBe ( false ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( [ SharedConstants . Commands . Azure . RetrieveArmToken ] ) ; } } } ct ++ ; } expect ( ct ) . toBe ( 0 ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Telemetry . TrackEvent , 's' ) ; } ) ; it ( 's' , async ( ) => { store . dispatch ( azureArmTokenDataChanged ( 's' ) ) ; DialogService . showDialog = ( ) => Promise . resolve ( 0 ) ; commandService . remoteCall = args => { switch ( args [ 0 ] ) { case SharedConstants . Commands . Azure . RetrieveArmToken : return Promise . resolve ( { access_token : 's' } ) ; case SharedConstants . Commands . Azure . PersistAzureLoginChanged : return Promise . resolve ( { persistLogin : true } ) ; default : return Promise . resolve ( false ) as any ; } } ; const it = azureAuthSagas ( ) . next ( ) . value . FORK . args [ 0 ] ( beginAzureAuthWorkflow ( AzureLoginPromptDialogContainer , { serviceType : ServiceTypes . Luis } , AzureLoginSuccessDialogContainer , AzureLoginFailedDialogContainer ) ) ; let val = undefined ; let ct = 0 ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) ; while ( true ) { const next = it . next ( val ) ; if ( next . done ) { break ; } val = next . value ; if ( 's' in val ) { val = val . SELECT . selector ( store . getState ( ) ) ; expect ( val . access_token ) . toBe ( 's' ) ; } else if ( val instanceof Promise ) { val = await val ; if ( ct === 0 ) { expect ( val ) . toBe ( 0 ) ; } } else if ( 's' in val ) { val = val . CALL . fn . call ( null , val . CALL . args ) ; if ( val [ Symbol . toStringTag ] === 's' ) { val = await val ; if ( ct === 0 ) { expect ( val . access_token ) . toBe ( 's' ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( [ SharedConstants . Commands . Azure . RetrieveArmToken ] ) ; } else if ( ct === 0 ) { expect ( val . persistLogin ) . toBe ( true ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( [ SharedConstants . Commands . Azure . PersistAzureLoginChanged , 0 ] ) ; } } } else if ( 's' in val ) { store . dispatch ( val . PUT . action ) ; } ct ++ ; } expect ( ct ) . toBe ( 0 ) ; expect ( store . getState ( ) . azureAuth . access_token ) . toBe ( 's' ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Telemetry . TrackEvent , 's' ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<AzureAuthWorkflow>$ O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O O O O $IterableIterator<any>$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $Promise<boolean>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O O $any$ O $IterableIterator<any>$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O $string$ O O O O O O O $any$ O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $number$ O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $IterableIterator<any>$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $AzureAuthAction<AzureAuthWorkflow>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $undefined$ O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $PromiseConstructor$ O O $any$ O O $Promise<any>$ O $any$ O $any$ O O $any$ O O O O O $number$ O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $IterableIterator<any>$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $AzureAuthAction<AzureAuthWorkflow>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $undefined$ O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $PromiseConstructor$ O O $any$ O O $Promise<any>$ O O O $number$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $SymbolConstructor$ O $symbol$ O O O O O $any$ O O $any$ O O O $number$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O $complex$ O O $true$ O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $IterableIterator<any>$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $AzureAuthAction<AzureAuthWorkflow>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $undefined$ O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $PromiseConstructor$ O O $any$ O O $Promise<any>$ O O O $number$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $SymbolConstructor$ O $symbol$ O O O O O $any$ O O $any$ O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O
import { newNotification , SharedConstants } from 's' ; import { BotConfigWithPath , ConversationService } from 's' ; import { call , put , takeEvery , takeLatest } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { ActiveBotHelper } from 's' ; import { BotAction , BotActionType , botHashGenerated , openBotViaFilePathAction , openBotViaUrlAction , restartConversation , } from 's' ; import { beginAdd } from 's' ; import { generateHash } from 's' ; import * as ChatActions from 's' ; import { botSagas , BotSagas } from 's' ; import { SharedSagas } from 's' ; jest . mock ( 's' , ( ) => ( { get store ( ) { return { } ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; ( global as any ) . fetch = ( function ( ) { const fetch = ( url , opts ) => { return { ok : true , json : async ( ) => ( { id : "s" } ) , text : async ( ) => 's' , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ( ) ; const mockSharedConstants = SharedConstants ; let mockRemoteCommandsCalled = [ ] ; let mockLocalCommandsCalled = [ ] ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . call = async ( commandName , ... args : any [ ] ) => { mockLocalCommandsCalled . push ( { commandName , args : args } ) ; switch ( commandName ) { case mockSharedConstants . Commands . Bot . OpenBrowse : return Promise . resolve ( true ) ; default : return Promise . resolve ( true ) as any ; } } ; commandService . remoteCall = async ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; return Promise . resolve ( true ) as any ; } ; } ) ; beforeEach ( ( ) => { mockRemoteCommandsCalled = [ ] ; mockLocalCommandsCalled = [ ] ; ConversationService . startConversation = jest . fn ( ) . mockResolvedValue ( true ) ; } ) ; it ( 's' , ( ) => { const gen = botSagas ( ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( BotActionType . browse , BotSagas . browseForBot ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( BotActionType . openViaUrl , BotSagas . openBotViaUrl ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( BotActionType . openViaFilePath , BotSagas . openBotViaFilePath ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( BotActionType . restartConversation , BotSagas . restartConversation ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( BotActionType . setActive , BotSagas . generateHashForActiveBot ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeLatest ( [ BotActionType . setActive , BotActionType . load , BotActionType . close ] , SharedSagas . refreshConversationMenu ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const botConfigPath = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , version : 's' , } ; const setActiveBotAction < any > = { type : BotActionType . setActive , payload : { bot : botConfigPath , } , } ; const gen = BotSagas . generateHashForActiveBot ( setActiveBotAction ) ; const generatedHash = gen . next ( ) . value ; expect ( generatedHash ) . toEqual ( call ( generateHash , botConfigPath ) ) ; const putGeneratedHash = gen . next ( generatedHash ) . value ; expect ( putGeneratedHash ) . toEqual ( put ( botHashGenerated ( generatedHash ) ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . browseForBot ( ) ; expect ( gen . next ( ) . value ) . toEqual ( call ( [ ActiveBotHelper , ActiveBotHelper . confirmAndOpenBotFromFile ] ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { const gen = BotSagas . restartConversation ( restartConversation ( 's' , 's' ) ) ; gen . next ( ) ; const response = gen . next ( 's' ) ; const json = await gen . next ( response . value ) . value ; expect ( json ) . toEqual ( { id : "s" } ) ; const documentSelector = gen . next ( json ) . value ; expect ( documentSelector ) . toEqual ( { 's' : true , SELECT : { args : [ ] , selector : jasmine . any ( Function ) , } , } ) ; const mockDirectLine = { end : jest . fn ( ) } ; const mockChatDocument = { directLine : mockDirectLine , } ; const clearLogPutter = gen . next ( mockChatDocument ) . value ; expect ( mockDirectLine . end ) . toHaveBeenCalled ( ) ; expect ( mockChatDocument . directLine ) . toBeNull ( ) ; expect ( clearLogPutter ) . toEqual ( put ( ChatActions . clearLog ( jasmine . any ( String ) as any , jasmine . any ( Function ) ) ) ) ; const promise = gen . next ( ) . value ; expect ( promise instanceof Promise ) . toBeTruthy ( ) ; const setInspectorObjectsPutter = gen . next ( ) . value ; expect ( setInspectorObjectsPutter ) . toEqual ( put ( ChatActions . setInspectorObjects ( jasmine . any ( String ) as any , [ ] ) ) ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; gen . next ( users ) ; const callToSaveUrl = gen . next ( { ok : true , json : async ( ) => null } ) ; expect ( callToSaveUrl . value ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Settings . SaveBotUrl , 's' ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; const callToSetCurrentUser = gen . next ( users ) . value ; expect ( callToSetCurrentUser ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Emulator . SetCurrentUser , 's' ) ) ; gen . next ( ) ; const callToSaveUrl = gen . next ( { ok : true , json : async ( ) => null } ) ; expect ( callToSaveUrl . value ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Settings . SaveBotUrl , 's' ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; gen . next ( users ) ; const errorNotification = beginAdd ( newNotification ( 's' ) ) ; ( errorNotification as any ) . payload . notification . timestamp = jasmine . any ( Number ) ; ( errorNotification as any ) . payload . notification . id = jasmine . any ( String ) ; expect ( gen . next ( { statusText : 's' , ok : false , } ) . value ) . toEqual ( put ( errorNotification ) ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , mode : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; gen . next ( users ) ; gen . next ( { ok : true , json : async ( ) => null } ) ; const callToPostActivity = gen . next ( { id : 's' } ) . value ; const activity = { type : 's' , text : 's' , } ; expect ( callToPostActivity ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Emulator . PostActivityToConversation , 's' , activity ) ) ; const callToRememberEndpoint = gen . next ( { statusCode : 0 } ) ; expect ( callToRememberEndpoint . value ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Settings . SaveBotUrl , 's' ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , mode : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; gen . next ( users ) ; gen . next ( { ok : true , json : async ( ) => null } ) ; gen . next ( { id : 's' } ) ; const errorNotification = beginAdd ( newNotification ( 's' ) ) ; ( errorNotification as any ) . payload . notification . timestamp = jasmine . any ( Number ) ; ( errorNotification as any ) . payload . notification . id = jasmine . any ( String ) ; expect ( gen . next ( { statusCode : 0 } ) . value ) . toEqual ( put ( errorNotification ) ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaUrl ( openBotViaUrlAction ( { appPassword : 's' , appId : 's' , endpoint : 's' , mode : 's' , } ) ) ; gen . next ( ) ; gen . next ( 's' ) ; gen . next ( 's' ) ; const users = { currentUserId : 's' , usersById : { 0 : { } } } ; gen . next ( users ) ; gen . next ( { ok : true , json : async ( ) => null } ) ; const startConversationResponse = gen . next ( { id : undefined } ) . value ; const errorNotification = beginAdd ( newNotification ( 's' ) ) ; ( errorNotification as any ) . payload . notification . timestamp = jasmine . any ( Number ) ; ( errorNotification as any ) . payload . notification . id = jasmine . any ( String ) ; expect ( startConversationResponse ) . toEqual ( put ( errorNotification ) ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaFilePath ( openBotViaFilePathAction ( 's' ) ) ; jest . spyOn ( ActiveBotHelper , 's' ) . mockResolvedValue ( true ) ; expect ( gen . next ( ) . value ) . toEqual ( call ( [ ActiveBotHelper , ActiveBotHelper . confirmAndOpenBotFromFile ] , 's' ) ) ; } ) ; it ( 's' , ( ) => { const gen = BotSagas . openBotViaFilePath ( openBotViaFilePathAction ( 's' ) ) ; const callOpenBot = gen . next ( ) . value ; expect ( callOpenBot ) . toEqual ( call ( [ ActiveBotHelper , ActiveBotHelper . confirmAndOpenBotFromFile ] , 's' ) ) ; const putNotification = gen . throw ( new Error ( 's' ) ) ; const errorNotification = beginAdd ( newNotification ( 's' ) ) ; ( errorNotification as any ) . payload . notification . timestamp = jasmine . any ( Number ) ; ( errorNotification as any ) . payload . notification . id = jasmine . any ( String ) ; expect ( putNotification . value ) . toEqual ( put ( errorNotification ) ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $BotAction<HashPayload>$ O $BotAction<string>$ O $BotAction<any>$ O $BotAction<RestartConversationPayload>$ O O O O O O O $BeginAddNotificationAction$ O O O O O O $Promise<string>$ O O O O O O O $any$ O O O O O $IterableIterator<any>$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O ${}$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O $complex$ O O $any$ O $any$ O O O O O $boolean$ O O O $complex$ O O O O O O O $string$ O O O O O $Promise<string>$ O O O O O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O O O O $any$ O $any$ O O $any[]$ O O O O O $any[]$ O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O $complex$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $any$ O O O O O $any[]$ O O O O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $BotActionType.browse$ O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $BotActionType.openViaUrl$ O $any$ O $complex$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $BotActionType.openViaFilePath$ O $any$ O $complex$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $BotActionType.restartConversation$ O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $BotActionType.setActive$ O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $BotActionType.setActive$ O $any$ O $BotActionType.load$ O $any$ O $BotActionType.close$ O O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $string$ O O O O O O $BotAction$ O O O O O $BotActionType.setActive$ O $any$ O $BotActionType.setActive$ O $complex$ O O $any$ O $any$ O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $BotAction<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $Promise<string>$ O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $BotAction<HashPayload>$ O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Promise<any>$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $BotAction<RestartConversationPayload>$ O O O O O O O $IterableIterator<any>$ O $complex$ O O O O $complex$ O $IterableIterator<any>$ O $complex$ O O O O O $any$ O O $IterableIterator<any>$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O $complex$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O $FunctionConstructor$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $complex$ O O $complex$ O $complex$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O $complex$ O O $any$ O $any$ O $complex$ O $any$ O O $any$ O O O $any$ O $complex$ O $complex$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $ChatAction<ClearLogPayload>$ O $any$ O $any$ O $StringConstructor$ O O O O $any$ O $any$ O $FunctionConstructor$ O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O $PromiseConstructor$ O O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O $complex$ O $complex$ O O O O O $complex$ O $complex$ O $complex$ O O $boolean$ O O O $Promise<any>$ O O O O O O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O O $any$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O $complex$ O O $boolean$ O O O $Promise<any>$ O O O O O O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O $complex$ O $complex$ O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $complex$ O $complex$ O O $string$ O O O $boolean$ O O O O O O $any$ O O $any$ O $any$ O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O $boolean$ O O O $Promise<any>$ O O O O O O O O O O $any$ O $complex$ O $complex$ O O $string$ O O O O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O O $complex$ O $complex$ O $complex$ O O $number$ O O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O $boolean$ O O O $Promise<any>$ O O O O O O O O O $complex$ O $complex$ O O $string$ O O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $complex$ O $complex$ O O $number$ O O O O O $any$ O O $any$ O $any$ O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<any>$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O O O O $string$ O O O O O O ${}$ O O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O O $boolean$ O O O $Promise<any>$ O O O O O O O O O O $any$ O $complex$ O $complex$ O O $undefined$ O $undefined$ O O O $any$ O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $any$ O O $any$ O $any$ O $BeginAddNotificationAction$ O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<string>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $complex$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $BotAction<string>$ O O O O O O $any$ O $complex$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Promise<any>$ O O O O O O O $complex$ O $complex$ O $complex$ O O $ErrorConstructor$ O O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $BeginAddNotificationAction$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $BeginAddNotificationAction$ O O O O O O O O O
import { applyMiddleware , combineReducers , createStore } from 's' ; import sagaMiddlewareFactory from 's' ; import { ActivityTypes } from 's' ; import * as Electron from 's' ; import { SharedConstants , ValueTypes } from 's' ; import { CommandServiceImpl , CommandServiceInstance , ConversationService } from 's' ; import { bot } from 's' ; import { chat } from 's' ; import { editor } from 's' ; import { presentation } from 's' ; import * as Constants from 's' ; import { closeConversation , newChat , showContextMenuForActivity } from 's' ; import { closeBot } from 's' ; import { clientAwareSettings } from 's' ; import { chatSagas } from 's' ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; let mockStore ; let mockStoreState ; jest . mock ( 's' , ( ) => ( { } ) ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => { return { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , clipboard : { writeText : ( textFromActivity ) => true } , } ; } ) ; jest . mock ( 's' , ( ) => { return { createCognitiveServicesSpeechServicesPonyfillFactory : ( ) => ( ) => 's' , } ; } ) ; const log = { entries : [ { items : [ { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { first : 's' , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { first : 's' , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { conversationType : 's' , id : 's' , } , from : { aadObjectId : 's' , id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { conversationState : { } , dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , userState : { } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , ] , } ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockStoreState = { bot : { activeBot : { services : [ { id : 's' , appId : 's' , appPassword : 's' } ] , } , } , chat : { chats : { 0 : { log , conversationId : 's' , documentId : 's' , endpointId : 's' , userId : 's' , } , } , } , editor : { activeEditor : Constants . EDITOR_KEY_PRIMARY , editors : { [ Constants . EDITOR_KEY_PRIMARY ] : { activeDocumentId : 's' , } , } , } , presentation : { enabled : true } , clientAwareSettings : { serverUrl : 's' } , } ; mockStore = createStore ( combineReducers ( { bot , chat , editor , presentation , clientAwareSettings , } ) , mockStoreState , applyMiddleware ( sagaMiddleWare ) ) ; sagaMiddleWare . run ( chatSagas ) ; } ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( { id : 's' } ) ; const clipboardSpy = jest . spyOn ( Electron . clipboard , 's' ) ; const activity = { valueType : ValueTypes . Activity , type : ActivityTypes . Trace , value : { type : ActivityTypes . Message , text : 's' } , } ; mockStore . dispatch ( showContextMenuForActivity ( activity ) ) ; await Promise . resolve ( true ) ; expect ( commandServiceSpy ) . toHaveBeenCalled ( ) ; expect ( clipboardSpy ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( { id : 's' } ) ; const clipboardSpy = jest . spyOn ( Electron . clipboard , 's' ) ; const activity = { valueType : 's' , type : ActivityTypes . Trace , value : { type : ActivityTypes . Message , text : 's' } , } ; await mockStore . dispatch ( showContextMenuForActivity ( activity ) ) ; await Promise . resolve ( true ) ; expect ( commandServiceSpy ) . toHaveBeenCalled ( ) ; expect ( clipboardSpy ) . toHaveBeenCalledWith ( JSON . stringify ( activity , null , 0 ) ) ; } ) ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; mockStore . dispatch ( closeConversation ( 's' ) ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . DeleteConversation , 's' ) ; await Promise . resolve ( ) ; expect ( mockStore . getState ( ) . chat . chats . 0 ) . toBeUndefined ( ) ; } ) ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( 's' ) ; mockStore . dispatch ( newChat ( 's' , 's' , { conversationId : 's' , endpointId : 's' , userId : 's' , } ) ) ; await Promise . resolve ( ) ; const state = mockStore . getState ( ) ; expect ( state . chat . chats . 0 ) . not . toBeUndefined ( ) ; expect ( state . chat . webSpeechFactories . 0 ) . not . toBeUndefined ( ) ; expect ( state . chat . webSpeechFactories . 0 ( ) ) . toBe ( 's' ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . GetSpeechToken , 's' , false ) ; } ) ; it ( 's' , async ( ) => { const mockEndpointResponse = { ok : true , json : async ( ) => ( { appId : 's' , appPassword : 's' } ) } ; const spy = jest . spyOn ( ConversationService , 's' ) . mockResolvedValueOnce ( mockEndpointResponse as any ) ; mockStore . dispatch ( closeBot ( ) ) ; mockStore . dispatch ( newChat ( 's' , 's' , { conversationId : 's' , endpointId : 's' , userId : 's' , } ) ) ; expect ( spy ) . toHaveBeenCalled ( ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $BotState$ O O O O O O O O O O O O O O O O O O O O $PresentationState$ O O O O O O O $any$ O O O O O $ChatAction<DocumentIdPayload>$ O $complex$ O $ChatAction<any>$ O O O O O O $BotAction<{}>$ O O O O O O $any$ O O O O O O $IterableIterator<any>$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O $complex$ O O $boolean$ O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O ${}$ O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $complex$ O O $string$ O $any$ O O O $complex$ O O O $any$ O O O O O $string$ O O O O O O O O O $complex$ O O $boolean$ O O O O $complex$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O $BotState$ O O O O O $PresentationState$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $ChatAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $ChatAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $JSON$ O $complex$ O $complex$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $ChatAction<DocumentIdPayload>$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $PromiseConstructor$ O $complex$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $complex$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $boolean$ O O O $complex$ O O O O O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O O $any$ O $any$ O $BotAction<{}>$ O O O O $any$ O $any$ O $complex$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { call , put , select , takeEvery , takeLatest } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { EditorActions , removeDocPendingChange } from 's' ; import { editorSagas , EditorSagas } from 's' ; import { SharedSagas , editorSelector } from 's' ; jest . mock ( 's' , ( ) => ( { get store ( ) { return { } ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; let mockRemoteCommandsCalled = [ ] ; let mockLocalCommandsCalled = [ ] ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . call = async ( commandName , ... args : any [ ] ) => { mockLocalCommandsCalled . push ( { commandName , args : args } ) ; return true as any ; } ; commandService . remoteCall = async ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; switch ( commandName ) { case SharedConstants . Commands . Electron . ShowMessageBox : return Promise . resolve ( false ) ; default : return Promise . resolve ( true ) as any ; } } ; } ) ; beforeEach ( ( ) => { mockRemoteCommandsCalled = [ ] ; mockLocalCommandsCalled = [ ] ; } ) ; it ( 's' , ( ) => { const gen = EditorSagas . checkActiveDocForPendingChanges ( ) ; const stateData = gen . next ( ) . value ; expect ( stateData ) . toEqual ( select ( editorSelector ) ) ; const mockActiveDocId = 's' ; const mockEditorState = { editors : { someEditor : { activeDocumentId : mockActiveDocId , } , } , activeEditor : 's' , docsWithPendingChanges : [ mockActiveDocId ] , } ; const innerGen = gen . next ( mockEditorState ) . value ; expect ( innerGen ) . toEqual ( call ( EditorSagas . promptUserToReloadDocument , mockActiveDocId ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const mockChatFileName = 's' ; const options = { buttons : [ 's' , 's' ] , title : 's' , message : 's' , } ; const gen = EditorSagas . promptUserToReloadDocument ( mockChatFileName ) ; gen . next ( ) ; const { ShowMessageBox } = SharedConstants . Commands . Electron ; expect ( mockRemoteCommandsCalled ) . toHaveLength ( 0 ) ; expect ( mockRemoteCommandsCalled [ 0 ] . commandName ) . toEqual ( ShowMessageBox ) ; expect ( mockRemoteCommandsCalled [ 0 ] . args [ 0 ] ) . toEqual ( options ) ; expect ( gen . next ( true ) . value ) . toEqual ( put ( removeDocPendingChange ( mockChatFileName ) ) ) ; gen . next ( ) ; const { OpenChatFile } = SharedConstants . Commands . Emulator ; expect ( mockLocalCommandsCalled ) . toHaveLength ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toEqual ( OpenChatFile ) ; expect ( mockLocalCommandsCalled [ 0 ] . args [ 0 ] ) . toBe ( mockChatFileName ) ; expect ( mockLocalCommandsCalled [ 0 ] . args [ 0 ] ) . toBe ( true ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const mockTranscriptFile = 's' ; const options = { buttons : [ 's' , 's' ] , title : 's' , message : 's' , } ; const gen = EditorSagas . promptUserToReloadDocument ( mockTranscriptFile ) ; gen . next ( ) ; const { ShowMessageBox } = SharedConstants . Commands . Electron ; expect ( mockRemoteCommandsCalled ) . toHaveLength ( 0 ) ; expect ( mockRemoteCommandsCalled [ 0 ] . commandName ) . toEqual ( ShowMessageBox ) ; expect ( mockRemoteCommandsCalled [ 0 ] . args [ 0 ] ) . toEqual ( options ) ; expect ( gen . next ( true ) . value ) . toEqual ( put ( removeDocPendingChange ( mockTranscriptFile ) ) ) ; gen . next ( ) ; const { ReloadTranscript } = SharedConstants . Commands . Emulator ; expect ( mockLocalCommandsCalled ) . toHaveLength ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toEqual ( ReloadTranscript ) ; expect ( mockLocalCommandsCalled [ 0 ] . args [ 0 ] ) . toBe ( mockTranscriptFile ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = editorSagas ( ) ; const checkActiveDocsYield = gen . next ( ) . value ; expect ( checkActiveDocsYield ) . toEqual ( takeEvery ( [ EditorActions . addDocPendingChange , EditorActions . setActiveEditor , EditorActions . setActiveTab , EditorActions . open , ] , EditorSagas . checkActiveDocForPendingChanges ) ) ; const refreshConversationMenuYield = gen . next ( ) . value ; expect ( refreshConversationMenuYield ) . toEqual ( takeLatest ( [ EditorActions . close , EditorActions . open , EditorActions . setActiveEditor , EditorActions . setActiveTab ] , SharedSagas . refreshConversationMenu ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $RemoveDocPendingChangeAction$ O O O O O O $IterableIterator<any>$ O $any$ O O O O O O $any$ O $EditorState<any>$ O O O O $any$ O $any$ O O O O O O O O O ${}$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any[]$ O O O O O $any[]$ O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O O O O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O $complex$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O $any$ O O O O O $any[]$ O O O O $any[]$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $EditorState<any>$ O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O $string$ O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O $IterableIterator<any>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O $any$ O $complex$ O O $any$ O $IterableIterator<any>$ O $complex$ O O O O $any$ O O $any$ O $any$ O $RemoveDocPendingChangeAction$ O O O O O O $IterableIterator<any>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O O O O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O $string$ O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O $IterableIterator<any>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O $any$ O $complex$ O O $any$ O $IterableIterator<any>$ O $complex$ O O O O $any$ O O $any$ O $any$ O $RemoveDocPendingChangeAction$ O O O O O O $IterableIterator<any>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveTab$ O $any$ O $EditorActions.open$ O O O $any$ O $IterableIterator<any>$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $EditorActions.close$ O $any$ O $EditorActions.open$ O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveTab$ O O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O O O O
import { applyMiddleware , combineReducers , createStore } from 's' ; import sagaMiddlewareFactory from 's' ; import { Component } from 's' ; import { SharedConstants } from 's' ; import { takeEvery , takeLatest } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { IEndpointService } from 's' ; import { bot } from 's' ; import { load , setActive } from 's' ; import { launchEndpointEditor , openEndpointExplorerContextMenu , LAUNCH_ENDPOINT_EDITOR , OPEN_ENDPOINT_CONTEXT_MENU , OPEN_ENDPOINT_IN_EMULATOR , EndpointServicePayload , EndpointServiceAction , } from 's' ; import { DialogService } from 's' ; import { OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU } from 's' ; import { executeCommand } from 's' ; import { EndpointSagas , endpointSagas , getConnectedAbs } from 's' ; jest . mock ( 's' , ( ) => ( { DialogService : { showDialog : ( ) => Promise . resolve ( true ) } , } ) ) ; const mockBot = JSON . parse ( `template` ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; let mockRemoteCommandsCalled = [ ] ; const endpointService = { appId : 's' , name : 's' , appPassword : 's' , endpoint : 's' , channelService : 's' , } ; const resolver = jest . fn ( ( ) => { } ) ; const endpointPayload = { endpointService , resolver , } ; const endpointServiceAction < EndpointServicePayload > = { type : OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU , payload : endpointPayload , } ; describe ( 's' , ( ) => { let commandService ; let sagaMiddleware ; let mockStore ; let mockComponentClass ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = async ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; return Promise . resolve ( true ) as any ; } ; } ) ; beforeEach ( ( ) => { sagaMiddleware = sagaMiddlewareFactory ( ) ; mockStore = createStore ( combineReducers ( { bot } ) , { } , applyMiddleware ( sagaMiddleware ) ) ; sagaMiddleware . run ( endpointSagas ) ; mockComponentClass = class extends Component < { } , { } > { } ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; mockRemoteCommandsCalled = [ ] ; mockStore . dispatch ( load ( [ mockBot ] ) ) ; mockStore . dispatch ( setActive ( mockBot ) ) ; } ) ; it ( 's' , ( ) => { const gen = endpointSagas ( ) ; expect ( gen . next ( ) . value ) . toEqual ( takeLatest ( LAUNCH_ENDPOINT_EDITOR , EndpointSagas . launchEndpointEditor ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( OPEN_ENDPOINT_CONTEXT_MENU , EndpointSagas . openEndpointContextMenu ) ) ; expect ( gen . next ( ) . value ) . toEqual ( takeEvery ( OPEN_ENDPOINT_IN_EMULATOR , EndpointSagas . openEndpointInEmulator ) ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const gen = EndpointSagas . launchEndpointEditor ( endpointServiceAction ) ; gen . next ( ) ; gen . next ( [ endpointService ] ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; expect ( resolver ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockRemoteCommandsCalled . length ) . toEqual ( 0 ) ; } ) ; it ( 's' , async ( ) => { const remoteCallSpy = jest . spyOn ( commandService , 's' ) ; const dialogServiceSpy = jest . spyOn ( DialogService , 's' ) . mockResolvedValue ( mockBot . services ) ; await mockStore . dispatch ( launchEndpointEditor ( mockComponentClass , mockBot . services [ 0 ] ) ) ; const { AddOrUpdateService } = SharedConstants . Commands . Bot ; expect ( dialogServiceSpy ) . toHaveBeenCalledWith ( mockComponentClass , { endpointService : mockBot . services [ 0 ] , } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( AddOrUpdateService , 's' , mockBot . services [ 0 ] ) ; } ) ; describe ( 's' , ( ) => { const menuItems = [ { label : 's' , id : 's' } , { label : 's' , id : 's' , enabled : jasmine . any ( Boolean ) } , { label : 's' , id : 's' } , { label : 's' , id : 's' } , ] ; const { DisplayContextMenu , ShowMessageBox } = SharedConstants . Commands . Electron ; const { NewLiveChat } = SharedConstants . Commands . Emulator ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( { id : 's' } ) ; const dialogServiceSpy = jest . spyOn ( DialogService , 's' ) . mockResolvedValue ( mockBot . services ) ; await mockStore . dispatch ( openEndpointExplorerContextMenu ( mockComponentClass , mockBot . services [ 0 ] ) ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( DisplayContextMenu , menuItems ) ; expect ( dialogServiceSpy ) . toHaveBeenCalledWith ( mockComponentClass , { endpointService : mockBot . services [ 0 ] , } ) ; commandServiceSpy . mockClear ( ) ; dialogServiceSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const commandServiceRemoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( { id : 's' } ) ; const commandServiceCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; await mockStore . dispatch ( openEndpointExplorerContextMenu ( mockComponentClass , mockBot . services [ 0 ] ) ) ; expect ( commandServiceRemoteCallSpy ) . toHaveBeenCalledWith ( DisplayContextMenu , menuItems ) ; expect ( commandServiceCallSpy ) . toHaveBeenCalledWith ( NewLiveChat , mockBot . services [ 0 ] , false ) ; commandServiceRemoteCallSpy . mockClear ( ) ; commandServiceCallSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const remoteCallArgs = [ ] ; commandService . remoteCall = async ( commandName , ... args ) => { remoteCallArgs . push ( { commandName , args : args } ) ; if ( commandName === DisplayContextMenu ) { return { id : 's' } ; } return true as any ; } ; const { RemoveService } = SharedConstants . Commands . Bot ; await mockStore . dispatch ( openEndpointExplorerContextMenu ( mockComponentClass , mockBot . services [ 0 ] ) ) ; await Promise . resolve ( ) ; expect ( remoteCallArgs [ 0 ] ) . toEqual ( { commandName : DisplayContextMenu , args : [ menuItems ] , } ) ; expect ( remoteCallArgs [ 0 ] ) . toEqual ( { commandName : ShowMessageBox , args : [ true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : 's' , type : 's' , } , ] , } ) ; expect ( remoteCallArgs [ 0 ] ) . toEqual ( { commandName : RemoveService , args : [ mockBot . services [ 0 ] . type , mockBot . services [ 0 ] . id ] , } ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $BotState$ O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O O O O O O O $any$ O $any$ O O O O O O O $DialogServiceImpl$ O O O O O O O O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $IterableIterator<any>$ O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $Promise<boolean>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $JSON$ O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any[]$ O O O O O $IEndpointService$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $EndpointServicePayload$ O O $any$ O $any$ O O O O $EndpointServiceAction$ O $any$ O O O $string$ O O O $EndpointServicePayload$ O $EndpointServicePayload$ O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $BotState$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any[]$ O O O O $any$ O $any$ O $BotAction<LoadBotPayload>$ O O $any$ O O O O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $EndpointServiceAction<EndpointServicePayload>$ O O $IterableIterator<any>$ O $complex$ O O O $IterableIterator<any>$ O $complex$ O O $any$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $BooleanConstructor$ O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $DialogServiceImpl$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O $any$ O O $any[]$ O O O $any[]$ O $number$ O O $any$ O $any[]$ O $any[]$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O $any$ O O O O O O O $PromiseConstructor$ O $complex$ O O O $any$ O $any[]$ O O O O O $any$ O O $any$ O $any$ O $complex$ O O $complex$ O O O O O $any$ O $any[]$ O O O O O $any$ O O $any$ O $any$ O $complex$ O O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O
import { newNotification , SharedConstants } from 's' ; import { applyMiddleware , combineReducers , createStore } from 's' ; import sagaMiddlewareFactory from 's' ; import { call , put , select , takeEvery } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { CONTENT_TYPE_APP_SETTINGS , DOCUMENT_ID_APP_SETTINGS } from 's' ; import * as EditorActions from 's' ; import { FrameworkActionType , saveFrameworkSettings as saveFrameworkSettingsAction , setFrameworkSettings , } from 's' ; import { beginAdd } from 's' ; import { editor } from 's' ; import { framework } from 's' ; import { activeDocumentSelector , frameworkSettingsSagas , FrameworkSettingsSagas } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; const mockStore = createStore ( combineReducers ( { framework , editor } ) , { } , applyMiddleware ( sagaMiddleWare ) ) ; sagaMiddleWare . run ( frameworkSettingsSagas ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; mockStore . dispatch ( EditorActions . open ( { contentType : CONTENT_TYPE_APP_SETTINGS , documentId : DOCUMENT_ID_APP_SETTINGS , isGlobal : true , meta : null , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; it ( 's' , ( ) => { const it = frameworkSettingsSagas ( ) ; expect ( it . next ( ) . value ) . toEqual ( takeEvery ( FrameworkActionType . SAVE_FRAMEWORK_SETTINGS , FrameworkSettingsSagas . saveFrameworkSettings ) ) ; } ) ; it ( 's' , async ( ) => { const it = FrameworkSettingsSagas . saveFrameworkSettings ( saveFrameworkSettingsAction ( { } ) ) ; const selector = it . next ( ) . value ; expect ( selector ) . toEqual ( select ( activeDocumentSelector ) ) ; const value = selector . SELECT . selector ( mockStore . getState ( ) ) ; expect ( it . next ( value ) . value ) . toEqual ( put ( EditorActions . setDirtyFlag ( value . documentId , false ) ) ) ; expect ( it . next ( ) . value ) . toEqual ( put ( setFrameworkSettings ( { } ) ) ) ; expect ( it . next ( ) . done ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const it = FrameworkSettingsSagas . saveFrameworkSettings ( saveFrameworkSettingsAction ( { } ) ) ; it . next ( ) ; const errMsg = `template` ; const notification = newNotification ( errMsg ) ; notification . timestamp = jasmine . any ( Number ) as any ; notification . id = jasmine . any ( String ) as any ; expect ( it . throw ( 's' ) . value ) . toEqual ( put ( beginAdd ( notification ) ) ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $FrameworkAction<any>$ O $FrameworkAction<any>$ O $FrameworkAction<any>$ O O O O O O O $BeginAddNotificationAction$ O O O O O O O O O O O O O $any$ O O O O O O $Document<any>$ O $IterableIterator<any>$ O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O O O $string$ O O O $true$ O O O $null$ O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O $IterableIterator<any>$ O O O O O O $any$ O O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $FrameworkAction<any>$ O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $Document<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $SetDirtyFlagAction$ O $any$ O $any$ O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $FrameworkAction<any>$ O O O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $FrameworkAction<any>$ O O O O O O $IterableIterator<any>$ O $complex$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $NumberConstructor$ O O O O $any$ O $any$ O $any$ O $any$ O $StringConstructor$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O O $any$ O O $any$ O $any$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O O
import { put } from 's' ; import { select } from 's' ; import * as Constants from 's' ; import { markAllAsRead } from 's' ; import { markNotificationsAsRead } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const gen = markNotificationsAsRead ( select ( Constants . NAVBAR_NOTIFICATIONS ) ) ; expect ( gen . next ( ) . value ) . toEqual ( put ( markAllAsRead ( ) ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $SelectNavBarAction$ O O O O O O O $any$ O O O O O $MarkAllAsReadNotificationAction$ O O O O O O $IterableIterator<any>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O $SelectNavBarAction$ O $any$ O O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $MarkAllAsReadNotificationAction$ O O O O O O O O O O O
import { newNotification , NotificationType } from 's' ; import { put } from 's' ; import { NotificationManager } from 's' ; import { beginAdd , finishAdd , finishClear , beginRemove , finishRemove } from 's' ; import { addNotification , clearNotifications , removeNotification , markAllAsRead } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const notification = newNotification ( 's' , NotificationType . Info ) ; const action = beginAdd ( notification , false ) ; const gen = addNotification ( action ) ; expect ( gen . next ( ) . value ) . toEqual ( put ( finishAdd ( notification ) ) ) ; } ) ; test ( 's' , ( ) => { const gen = clearNotifications ( ) ; expect ( gen . next ( ) . value ) . toEqual ( put ( finishClear ( ) ) ) ; } ) ; test ( 's' , ( ) => { const action = beginRemove ( 's' ) ; const gen = removeNotification ( action ) ; expect ( gen . next ( ) . value ) . toEqual ( put ( finishRemove ( 's' ) ) ) ; } ) ; test ( 's' , ( ) => { NotificationManager . clear ( ) ; const 0 = newNotification ( 's' , NotificationType . Info ) ; const 0 = newNotification ( 's' , NotificationType . Info ) ; expect ( 0 . read ) . toBe ( false ) ; expect ( 0 . read ) . toBe ( false ) ; NotificationManager . set ( 0 . id , 0 ) ; NotificationManager . set ( 0 . id , 0 ) ; markAllAsRead ( ) ; expect ( NotificationManager . get ( 0 . id ) . read ) . toBe ( true ) ; expect ( NotificationManager . get ( 0 . id ) . read ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $BeginAddNotificationAction$ O $FinishAddNotificationAction$ O $FinishClearNotificationAction$ O $BeginRemoveNotificationAction$ O $FinishRemoveNotificationAction$ O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O $IterableIterator<any>$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O $BeginAddNotificationAction$ O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $FinishAddNotificationAction$ O $any$ O O O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $FinishClearNotificationAction$ O O O O O O O O $any$ O O O O O O O O $BeginRemoveNotificationAction$ O $BeginRemoveNotificationAction$ O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O $BeginRemoveNotificationAction$ O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O $any$ O $any$ O $FinishRemoveNotificationAction$ O O O O O O O O O $any$ O O O O O O O $complex$ O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $complex$ O $complex$ O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O O O
import { applyMiddleware , combineReducers , createStore } from 's' ; import { BotConfigWithPathImpl , CommandServiceImpl , CommandServiceInstance } from 's' ; import { ServiceTypes } from 's' ; import sagaMiddlewareFactory from 's' ; import { SharedConstants } from 's' ; import { Component } from 's' ; import { openContextMenuForResource , openResource , openResourcesSettings , renameResource , } from 's' ; import { resources } from 's' ; import { resourceSagas } from 's' ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; const mockStore = createStore ( combineReducers ( { resources } ) , { } , applyMiddleware ( sagaMiddleWare ) ) ; sagaMiddleWare . run ( resourceSagas ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { DialogService : { showDialog : ( ) => Promise . resolve ( true ) , hideDialog : ( ) => Promise . resolve ( { path : 's' } ) , } , } ) ) ; const mockRemoteCommandsCalled = [ ] ; const mockLocalCommandsCalled = [ ] ; const mockSharedConstants = SharedConstants ; let mockContextMenuResponse ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = async ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; switch ( commandName ) { case mockSharedConstants . Commands . Electron . DisplayContextMenu : return mockContextMenuResponse ; case mockSharedConstants . Commands . Electron . ShowMessageBox : return 0 ; default : return true ; } } ; commandService . call = async ( commandName , ... args : any [ ] ) => { mockLocalCommandsCalled . push ( { commandName , args : args } ) ; return true as any ; } ; } ) ; beforeEach ( ( ) => { mockRemoteCommandsCalled . length = 0 ; mockLocalCommandsCalled . length = 0 ; } ) ; describe ( 's' , ( ) => { let mockResource ; beforeEach ( ( ) => { mockResource = BotConfigWithPathImpl . serviceFromJSON ( { type : ServiceTypes . File , path : 's' , name : 's' , } as any ) ; } ) ; it ( 's' , async ( ) => { mockContextMenuResponse = { id : 0 } ; await mockStore . dispatch ( openContextMenuForResource ( mockResource as any ) ) ; expect ( mockRemoteCommandsCalled . length ) . toBe ( 0 ) ; [ { commandName : 's' , args : [ [ { label : 's' , id : 0 , } , { label : 's' , id : 0 , } , { label : 's' , id : 0 , } , ] , ] , } , { commandName : 's' , args : [ 's' ] , } , ] . forEach ( ( command , index ) => expect ( mockRemoteCommandsCalled [ index ] ) . toEqual ( command ) ) ; } ) ; it ( 's' , async ( ) => { mockContextMenuResponse = { id : 0 } ; await mockStore . dispatch ( openContextMenuForResource ( mockResource as any ) ) ; const { resourceToRename } = ( mockStore . getState ( ) as any ) . resources ; expect ( resourceToRename ) . toEqual ( mockResource ) ; } ) ; it ( 's' , async ( ) => { mockContextMenuResponse = { id : 0 } ; await mockStore . dispatch ( openContextMenuForResource ( mockResource as any ) ) ; await Promise . resolve ( ) ; expect ( mockRemoteCommandsCalled . length ) . toBe ( 0 ) ; [ { commandName : 's' , args : [ [ { label : 's' , id : 0 } , { label : 's' , id : 0 } , { label : 's' , id : 0 , } , ] , ] , } , { commandName : 's' , args : [ true , { type : 's' , title : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : 's' , cancelId : 0 , } , ] , } , { commandName : 's' , args : [ 's' ] , } , ] . forEach ( ( command , index ) => expect ( mockRemoteCommandsCalled [ index ] ) . toEqual ( command ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { let mockResource ; beforeEach ( ( ) => { mockResource = BotConfigWithPathImpl . serviceFromJSON ( { type : ServiceTypes . File , path : 's' , name : 's' , } as any ) ; } ) ; it ( 's' , async ( ) => { mockResource . name = 's' ; await mockStore . dispatch ( renameResource ( mockResource ) ) ; expect ( mockRemoteCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockRemoteCommandsCalled [ 0 ] ) . toEqual ( { commandName : 's' , args : [ true , { type : 's' , title : 's' , buttons : [ 's' ] , defaultId : 0 , message : 's' , cancelId : 0 , } , ] , } ) ; } ) ; it ( 's' , async ( ) => { await mockStore . dispatch ( renameResource ( mockResource ) ) ; expect ( mockRemoteCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockRemoteCommandsCalled [ 0 ] ) . toEqual ( { args : [ { name : 's' , path : 's' , type : 's' , } , ] , commandName : 's' , } ) ; const { resourceToRename } = ( mockStore . getState ( ) as any ) . resources ; expect ( resourceToRename ) . toBeNull ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { let mockResource ; beforeEach ( ( ) => { mockResource = BotConfigWithPathImpl . serviceFromJSON ( { type : ServiceTypes . File , path : 's' , name : 's' , } as any ) ; } ) ; it ( 's' , async ( ) => { await mockStore . dispatch ( openResource ( mockResource as any ) ) ; expect ( mockLocalCommandsCalled ) . toEqual ( [ { commandName : 's' , args : [ 's' , true ] , } , ] ) ; expect ( mockRemoteCommandsCalled ) . toEqual ( [ { commandName : SharedConstants . Commands . Telemetry . TrackEvent , args : [ 's' ] , } , ] ) ; } ) ; it ( 's' , async ( ) => { mockResource . path = 's' ; mockResource . name = 's' ; await mockStore . dispatch ( openResource ( mockResource as any ) ) ; expect ( mockLocalCommandsCalled ) . toEqual ( [ { commandName : 's' , args : [ 's' , 's' ] , } , ] ) ; expect ( mockRemoteCommandsCalled ) . toEqual ( [ { commandName : SharedConstants . Commands . Telemetry . TrackEvent , args : [ 's' , { method : 's' } ] , } , ] ) ; } ) ; } ) ; it ( 's' , async ( ) => { const mockClass = class extends Component { } ; await mockStore . dispatch ( openResourcesSettings ( { dialog : mockClass } ) ) ; await Promise . resolve ( ) ; expect ( mockRemoteCommandsCalled ) . toEqual ( [ { commandName : 's' , args : [ undefined , true ] } ] ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<ResourceSettingsPayload>$ O $ResourcesAction<any>$ O O O O O O O $ResourcesState$ O O O O O O $IterableIterator<any>$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $ResourcesState$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $Promise<boolean>$ O O O O $PromiseConstructor$ O $complex$ O O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O O O O O O O $any[]$ O O O O O $any[]$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O O O O O O O O O $any$ O O O O O $any[]$ O $number$ O O O $any[]$ O $number$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O $string$ O O O $complex$ O O O O $string$ O O O $number$ O O O O O O $string$ O O O $number$ O O O O O O $string$ O O O $number$ O O O O O O O O O O O O $string$ O O O $string[]$ O O O O O O O O O $void$ O O $complex$ O $number$ O O $any$ O $any[]$ O $number$ O O O $any$ O $complex$ O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O $string$ O O O $complex$ O O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O $string$ O O O $number$ O O O O O O O O O O O O $string$ O O O $complex$ O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O O O $string$ O O O $string[]$ O O O O O O O O O O O O $complex$ O $number$ O O $any$ O $any[]$ O $number$ O O O $any$ O $complex$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O O $any$ O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $complex$ O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string[]$ O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $ResourcesAction<any>$ O $any$ O O O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $string[]$ O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O $string$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $ResourcesAction<ResourceSettingsPayload>$ O O $any$ O $any$ O O O O O $PromiseConstructor$ O $complex$ O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $boolean[]$ O O $undefined$ O O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { ConnectedServiceEditor } from 's' ; const mapDispatchToProps = ( dispatch : ( action ) => void ) => { return { cancel : ( ) => DialogService . hideDialog ( 0 ) , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , updateConnectedService => DialogService . hideDialog ( [ updatedLuisService ] ) , } ; } ; export const ConnectedServiceEditorContainer = connect ( null , mapDispatchToProps ) ( ConnectedServiceEditor ) as any ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O O O O O $complex$ O O $void$ O O $Action$ O O O O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $updatedLuisService$ O $DialogServiceImpl$ O $void$ O O $any$ O O O O O O O O O $any$ O $any$ O O O $complex$ O O $any$ O O O O
export { ConnectedServiceEditorContainer } from 's' ;	O O $any$ O O O O
import { ServiceCodes , SharedConstants } from 's' ; import { ServiceTypes } from 's' ; import { applyMiddleware , combineReducers , createStore } from 's' ; import sagaMiddlewareFactory from 's' ; import { call } from 's' ; import { CommandServiceInstance } from 's' ; import { CommandServiceImpl } from 's' ; import { AzureLoginFailedDialogContainer , AzureLoginSuccessDialogContainer , ConnectServicePromptDialogContainer , GetStartedWithCSDialogContainer , } from 's' ; import { DialogService } from 's' ; import { ConnectedServicePickerContainer } from 's' ; import { ConnectedServiceEditorContainer } from 's' ; import { azureArmTokenDataChanged } from 's' ; import { load , setActive } from 's' ; import { ConnectedServiceAction , ConnectedServicePayload , ConnectedServicePickerPayload , launchConnectedServicePicker , openAddServiceContextMenu , launchExternalLink , openContextMenuForConnectedService , openServiceDeepLink , } from 's' ; import { azureAuth } from 's' ; import { bot } from 's' ; import { ServicesExplorerSagas , servicesExplorerSagas } from 's' ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; const mockStore = createStore ( combineReducers ( { azureAuth , bot } ) , { } , applyMiddleware ( sagaMiddleWare ) ) ; sagaMiddleWare . run ( servicesExplorerSagas ) ; const mockArmToken = 's' ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { AzureAuthSaga : { getArmToken : function * ( ) { yield { access_token : mockArmToken } ; } , } , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = ( type ) => { switch ( type ) { case SharedConstants . Commands . ConnectedService . GetConnectedServicesByType : return { services : [ { id : 's' } ] , code : ServiceCodes . OK } ; default : return null as any ; } } ; } ) ; describe ( 's' , ( ) => { let launchConnectedServicePickerGen ; let payload ; beforeEach ( ( ) => { payload = { azureAuthWorkflowComponents : { loginFailedDialog : AzureLoginFailedDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , promptDialog : ConnectServicePromptDialogContainer , } , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , pickerComponent : ConnectedServicePickerContainer , } ; launchConnectedServicePickerGen = servicesExplorerSagas ( ) . next ( ) . value . FORK . args [ 0 ] ; mockStore . dispatch ( azureArmTokenDataChanged ( mockArmToken ) ) ; } ) ; it ( 's' , ( ) => { const token = launchConnectedServicePickerGen ( ) . next ( ) . value . SELECT . selector ( mockStore . getState ( ) ) ; expect ( token . access_token ) . toBe ( mockArmToken ) ; } ) ; it ( 's' , ( ) => { mockStore . dispatch ( azureArmTokenDataChanged ( 's' ) ) ; const it = launchConnectedServicePickerGen ( launchConnectedServicePicker ( payload ) ) ; let token = it . next ( ) . value . SELECT . selector ( mockStore . getState ( ) ) ; expect ( token . access_token ) . toBe ( 's' ) ; token = it . next ( ) . value ; expect ( token . access_token ) . toBe ( mockArmToken ) ; } ) ; it ( 's' , async ( ) => { const action = launchConnectedServicePicker ( payload ) ; const it = launchConnectedServicePickerGen ( action ) ; let token = it . next ( ) . value . SELECT . selector ( mockStore . getState ( ) ) ; token = it . next ( token ) . value . SELECT . selector ( mockStore . getState ( ) ) ; const result = await it . next ( token ) . value ; expect ( action . payload . authenticatedUser ) . toBe ( 's' ) ; expect ( result . services . length ) . toEqual ( 0 ) ; expect ( result . services [ 0 ] . id ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { DialogService . showDialog = ( ) => Promise . resolve ( [ { id : 's' } ] ) as any ; const action = launchConnectedServicePicker ( payload ) ; const it = launchConnectedServicePickerGen ( action ) ; let token = it . next ( ) . value . SELECT . selector ( mockStore . getState ( ) ) ; token = it . next ( token ) . value . SELECT . selector ( mockStore . getState ( ) ) ; const luisModels = await it . next ( token ) . value ; const newModels = await it . next ( luisModels ) . value ; expect ( newModels . length ) . toBe ( 0 ) ; expect ( newModels [ 0 ] . id ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const mockBot = JSON . parse ( `template` ) ; mockStore . dispatch ( load ( [ mockBot ] ) ) ; mockStore . dispatch ( setActive ( mockBot ) ) ; DialogService . showDialog = ( ) => Promise . resolve ( [ { id : 's' } ] ) as any ; const action = launchConnectedServicePicker ( payload ) ; const it = launchConnectedServicePickerGen ( action ) ; let token = it . next ( ) . value . SELECT . selector ( mockStore . getState ( ) ) ; token = it . next ( token ) . value . SELECT . selector ( mockStore . getState ( ) ) ; const luisModels = await it . next ( token ) . value ; const newModels = await it . next ( luisModels ) . value ; const botConfig = it . next ( newModels ) . value . SELECT . selector ( mockStore . getState ( ) ) ; let _type ; let _args ; commandService . remoteCall = function ( type , ... args : any [ ] ) { _type = type ; _args = args ; return Promise . resolve ( true ) ; } as any ; const result = await it . next ( botConfig ) . value ; expect ( result ) . toBeTruthy ( ) ; expect ( _type ) . toBe ( SharedConstants . Commands . Bot . Save ) ; expect ( _args [ 0 ] . services [ 0 ] . id ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { let contextMenuGen ; let action < ConnectedServicePayload > ; const mockService = JSON . parse ( `template` ) ; beforeEach ( ( ) => { const sagaIt = servicesExplorerSagas ( ) ; action = openContextMenuForConnectedService < ConnectedServiceAction < ConnectedServicePayload > > ( ConnectedServiceEditorContainer , mockService ) ; let i = 0 ; while ( i -- ) { contextMenuGen = sagaIt . next ( ) . value . FORK . args [ 0 ] ; } } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : 's' } as any ) ; const it = contextMenuGen ( action ) ; const result = await it . next ( ) . value ; expect ( result . id ) . toBe ( 's' ) ; window . open = jest . fn ( ) ; await it . next ( result ) . value ; expect ( window . open ) . toHaveBeenCalledWith ( `template` ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : 's' } as any ) ; const it = contextMenuGen ( action ) ; const result = await it . next ( ) . value ; expect ( result . id ) . toBe ( 's' ) ; DialogService . showDialog = ( ) => Promise . resolve ( mockService ) ; commandService . remoteCall = ( ) => Promise . resolve ( true ) as any ; const responseFromEditor = await it . next ( result ) . value ; expect ( responseFromEditor ) . toEqual ( mockService ) ; const responseFromMain = await it . next ( responseFromEditor ) ; expect ( responseFromMain ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : 's' } as any ) ; const it = contextMenuGen ( action ) ; let result = await it . next ( ) . value ; expect ( result . id ) . toBe ( 's' ) ; let _type ; let _args ; commandService . remoteCall = async ( type , ... args : any [ ] ) => { _type = type ; _args = args ; return true as any ; } ; result = await it . next ( result ) . value ; expect ( result ) . toBeTruthy ( ) ; expect ( _type ) . toBe ( SharedConstants . Commands . Electron . ShowMessageBox ) ; expect ( _args [ 0 ] ) . toEqual ( { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; result = await it . next ( result ) . value ; expect ( _type ) . toBe ( SharedConstants . Commands . Bot . RemoveService ) ; expect ( _args [ 0 ] ) . toBe ( ServiceTypes . Luis ) ; expect ( _args [ 0 ] ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : 's' } as any ) ; action . payload . connectedService = JSON . parse ( `template` ) ; const it = contextMenuGen ( action ) ; let result = await it . next ( ) . value ; expect ( result . id ) . toBe ( 's' ) ; let _type ; let _args ; commandService . remoteCall = async ( type , ... args : any [ ] ) => { _type = type ; _args = args ; return true as any ; } ; result = await it . next ( result ) . value ; expect ( result ) . toBeTruthy ( ) ; expect ( _type ) . toBe ( SharedConstants . Commands . Electron . ShowMessageBox ) ; expect ( _args [ 0 ] ) . toEqual ( { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; result = await it . next ( result ) . value ; expect ( _type ) . toBe ( SharedConstants . Commands . Bot . RemoveService ) ; expect ( _args [ 0 ] ) . toBe ( ServiceTypes . QnA ) ; expect ( _args [ 0 ] ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : 's' } as any ) ; action . payload . connectedService = JSON . parse ( `template` ) ; const it = contextMenuGen ( action ) ; let result = await it . next ( ) . value ; expect ( result . id ) . toBe ( 's' ) ; let _type ; let _args ; commandService . remoteCall = async ( type , ... args : any [ ] ) => { _type = type ; _args = args ; return true as any ; } ; result = await it . next ( result ) . value ; expect ( result ) . toBeTruthy ( ) ; expect ( _type ) . toBe ( SharedConstants . Commands . Electron . ShowMessageBox ) ; expect ( _args [ 0 ] ) . toEqual ( { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; result = await it . next ( result ) . value ; expect ( _type ) . toBe ( SharedConstants . Commands . Bot . RemoveService ) ; expect ( _args [ 0 ] ) . toBe ( ServiceTypes . Dispatch ) ; expect ( _args [ 0 ] ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { let action < ConnectedServicePayload > ; let sagaIt ; it ( 's' , async ( ) => { const payload = { azureAuthWorkflowComponents : { loginFailedDialog : AzureLoginFailedDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , promptDialog : ConnectServicePromptDialogContainer , } , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , pickerComponent : ConnectedServicePickerContainer , serviceType : ServiceTypes . Luis , } ; action = launchExternalLink ( payload as any ) ; sagaIt = ServicesExplorerSagas . launchExternalLink ; const it = sagaIt ( action ) ; const result = it . next ( ) . value ; expect ( result ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ) ; } ) ; it ( 's' , ( ) => { const payload = { azureAuthWorkflowComponents : { loginFailedDialog : AzureLoginFailedDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , promptDialog : ConnectServicePromptDialogContainer , } , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , pickerComponent : ConnectedServicePickerContainer , serviceType : ServiceTypes . Dispatch , } ; action = launchExternalLink ( payload as any ) ; sagaIt = ServicesExplorerSagas . launchExternalLink ; const it = sagaIt ( action ) ; const result = it . next ( ) . value ; expect ( result ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ) ; } ) ; it ( 's' , ( ) => { const payload = { azureAuthWorkflowComponents : { loginFailedDialog : AzureLoginFailedDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , promptDialog : ConnectServicePromptDialogContainer , } , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , pickerComponent : ConnectedServicePickerContainer , serviceType : ServiceTypes . QnA , } ; action = launchExternalLink ( payload as any ) ; sagaIt = ServicesExplorerSagas . launchExternalLink ; const it = sagaIt ( action ) ; const result = it . next ( ) . value ; expect ( result ) . toEqual ( call ( [ commandService , commandService . remoteCall ] , SharedConstants . Commands . Electron . OpenExternal , 's' ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { let action < ConnectedServicePickerPayload > ; let contextMenuGen ; beforeEach ( ( ) => { const sagaIt = servicesExplorerSagas ( ) ; const payload = { azureAuthWorkflowComponents : { loginFailedDialog : AzureLoginFailedDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , promptDialog : ConnectServicePromptDialogContainer , } , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , pickerComponent : ConnectedServicePickerContainer , } ; action = openAddServiceContextMenu ( payload ) ; let i = 0 ; while ( i -- ) { contextMenuGen = sagaIt . next ( ) . value . FORK . args [ 0 ] ; } } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async ( ) => ( { id : ServiceTypes . Luis } as any ) ; const it = contextMenuGen ( action ) ; let result = await it . next ( ) . value ; expect ( result . id ) . toBe ( ServiceTypes . Luis ) ; result = it . next ( result ) . value . SELECT . selector ( mockStore . getState ( ) ) ; expect ( result . access_token ) . toBe ( mockArmToken ) ; } ) ; } ) ; describe ( 's' , ( ) => { const mockModel = { type : ServiceTypes . Luis , appId : 's' , version : 's' , region : 's' , } ; let openConnectedServiceGen ; beforeEach ( ( ) => { const sagaIt = servicesExplorerSagas ( ) ; let i = 0 ; while ( i -- ) { openConnectedServiceGen = sagaIt . next ( ) . value . FORK . args [ 0 ] ; } } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; const link = `template` ; const action = openServiceDeepLink ( mockModel as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( link ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; mockModel . region = 's' ; const link = `template` ; const action = openServiceDeepLink ( mockModel as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( link ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; mockModel . region = 's' ; const link = `template` ; const action = openServiceDeepLink ( mockModel as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( link ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; const mock = { type : ServiceTypes . CosmosDB , collection : 's' , database : 's' , endpoint : 's' , id : 's' , name : 's' , resourceGroup : 's' , serviceName : 's' , subscriptionId : 's' , tenantId : 's' , } ; const action = openServiceDeepLink ( mock as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( 's' + 's' + 's' ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; const mock = { type : ServiceTypes . BlobStorage , id : 's' , name : 's' , resourceGroup : 's' , serviceName : 's' , subscriptionId : 's' , tenantId : 's' , } ; const action = openServiceDeepLink ( mock as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( 's' + 's' + 's' ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; const mock = { type : ServiceTypes . AppInsights , id : 's' , name : 's' , resourceGroup : 's' , serviceName : 's' , subscriptionId : 's' , tenantId : 's' , } ; const action = openServiceDeepLink ( mock as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( 's' + 's' + 's' ) ; } ) ; it ( 's' , ( ) => { window . open = jest . fn ( ) ; mockModel . type = ServiceTypes . QnA ; ( mockModel as any ) . kbId = 's' ; const action = openServiceDeepLink ( mockModel as any ) ; openConnectedServiceGen ( action ) . next ( ) ; expect ( window . open ) . toHaveBeenCalledWith ( 's' ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $DialogServiceImpl$ O O O O O O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<ArmTokenData>$ O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O O O O O O $any$ O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O $AzureAuthState$ O O O O O O $BotState$ O O O O O O $any$ O $IterableIterator<any>$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $AzureAuthState$ O $BotState$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O O O $string$ O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $ConnectedServicePickerPayload$ O $any$ O O O O O $ConnectedServicePickerPayload$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $IterableIterator<any>$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<ArmTokenData>$ O O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O $string$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O O O $string$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $JSON$ O $any$ O O O O $any$ O $any$ O $BotAction<LoadBotPayload>$ O O $any$ O O O O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O O O $string$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O $any$ O $string$ O $any$ O $any[]$ O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O $ConnectedServiceAction$ O $any$ O O O $any$ O $JSON$ O $any$ O O O O $any$ O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O O $any$ O $any$ O O O $number$ O O O O O $number$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $complex$ O $Window)$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $DialogServiceImpl$ O $Promise<R>$ O O O O $PromiseConstructor$ O $complex$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any$ O $string$ O $any$ O $any[]$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $any$ O $JSON$ O $any$ O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any$ O $string$ O $any$ O $any[]$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O $any$ O $JSON$ O $any$ O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any$ O $string$ O $any$ O $any[]$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $ConnectedServiceAction$ O $any$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O $ConnectedServiceAction$ O $any$ O O O $any$ O $any$ O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $complex$ O O O $number$ O O O O O $number$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O O O O $IterableIterator<any>$ O $IterableIterator<any>$ O O O O $number$ O O O O O $number$ O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O $complex$ O $string$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O $complex$ O $string$ O O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $complex$ O $Window)$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $any$ O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $complex$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O $any$ O O O $any$ O $complex$ O $Window)$ O O $any$ O O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { select } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { RootState } from 's' ; import { editorSelector , SharedSagas } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { const editorState = { activeEditor : 's' } ; let mockRemoteCommandsCalled = [ ] ; let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = async ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; return true as any ; } ; } ) ; beforeEach ( ( ) => { mockRemoteCommandsCalled = [ ] ; } ) ; it ( 's' , ( ) => { const state = { editor : editorState } ; expect ( editorSelector ( state ) ) . toEqual ( editorState ) ; } ) ; it ( 's' , ( ) => { const gen = SharedSagas . refreshConversationMenu ( ) ; const editorSelection = gen . next ( ) . value ; expect ( editorSelection ) . toEqual ( select ( editorSelector ) ) ; gen . next ( editorState ) ; expect ( mockRemoteCommandsCalled ) . toHaveLength ( 0 ) ; const refreshConversationCall = mockRemoteCommandsCalled [ 0 ] ; expect ( refreshConversationCall . commandName ) . toBe ( SharedConstants . Commands . Electron . UpdateConversationMenu ) ; expect ( refreshConversationCall . args ) . toHaveLength ( 0 ) ; expect ( refreshConversationCall . args [ 0 ] ) . toEqual ( editorState ) ; expect ( gen . next ( ) . done ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $EditorState<any>$ O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $any[]$ O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O O O O O O O O O $any$ O O O O O $any[]$ O O O O O O O $any$ O O O O O O O O $RootState$ O O $complex$ O $complex$ O O $any$ O $EditorState<any>$ O $RootState$ O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $EditorState<any>$ O O O $IterableIterator<any>$ O $complex$ O $complex$ O O $any$ O $any[]$ O O $any$ O O O O O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O O $any$ O $IterableIterator<any>$ O $complex$ O O O $boolean$ O O $any$ O O O O O O O O O O
import { SharedConstants } from 's' ; import sagaMiddlewareFactory from 's' ; import { applyMiddleware , combineReducers , createStore } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { openContextMenuForBot } from 's' ; import { bot } from 's' ; import notification from 's' ; import { notificationSagas } from 's' ; import { welcomePageSagas } from 's' ; const mockBot = { path : 's' , displayName : 's' , secret : 's' , } ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; const mockStore = createStore ( combineReducers ( { bot , notification } ) , { bot : { botFiles : [ mockBot ] } , } , applyMiddleware ( sagaMiddleWare ) ) ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; sagaMiddleWare . run ( welcomePageSagas ) ; sagaMiddleWare . run ( notificationSagas ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const remoteCalls = [ ] ; commandService . remoteCall = async function ( ... args : any [ ] ) { remoteCalls . push ( args ) ; switch ( args [ 0 ] ) { case SharedConstants . Commands . Electron . DisplayContextMenu : return { id : 0 } ; case SharedConstants . Commands . Electron . ShowSaveDialog : return 's' ; default : return null as any ; } } ; await mockStore . dispatch ( openContextMenuForBot ( mockBot ) ) ; await Promise . resolve ( true ) ; await Promise . resolve ( true ) ; expect ( remoteCalls [ 0 ] ) . toEqual ( [ 's' , [ { label : 's' , id : 0 , } , { label : 's' , id : 0 , } , { label : 's' , id : 0 , } , ] , ] ) ; expect ( remoteCalls [ 0 ] ) . toEqual ( [ 's' , { defaultPath : 's' , buttonLabel : 's' , nameFieldLabel : 's' , filters : [ { extensions : [ 's' ] , } , ] , } , ] ) ; expect ( remoteCalls [ 0 ] ) . toEqual ( [ 's' , { path : 's' , newPath : 's' , } , ] ) ; expect ( remoteCalls [ 0 ] ) . toEqual ( [ 's' , 's' , { path : 's' , displayName : 's' , secret : 's' , } , ] ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = async function ( ... args : any [ ] ) { switch ( args [ 0 ] ) { case SharedConstants . Commands . Electron . DisplayContextMenu : return { id : 0 } ; case SharedConstants . Commands . Electron . ShowSaveDialog : return 's' ; case SharedConstants . Commands . Electron . RenameFile : throw new Error ( 's' ) ; default : return null as any ; } } ; await mockStore . dispatch ( openContextMenuForBot ( mockBot ) ) ; await Promise . resolve ( true ) ; await Promise . resolve ( true ) ; const state = mockStore . getState ( ) ; expect ( state . notification . allIds . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { let openFileLocationArgs ; commandService . remoteCall = async function ( ... args : any [ ] ) { switch ( args [ 0 ] ) { case SharedConstants . Commands . Electron . DisplayContextMenu : return { id : 0 } ; case SharedConstants . Commands . Electron . OpenFileLocation : return ( openFileLocationArgs = args ) ; default : return null as any ; } } ; await mockStore . dispatch ( openContextMenuForBot ( mockBot ) ) ; await Promise . resolve ( true ) ; expect ( openFileLocationArgs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , async ( ) => { let removeBotFromListArgs = null ; commandService . remoteCall = async function ( ... args : any [ ] ) { switch ( args [ 0 ] ) { case SharedConstants . Commands . Electron . DisplayContextMenu : return { id : 0 } ; case SharedConstants . Commands . Bot . RemoveFromBotList : return ( removeBotFromListArgs = args ) ; default : return null as any ; } } ; await mockStore . dispatch ( openContextMenuForBot ( mockBot ) ) ; await Promise . resolve ( true ) ; expect ( removeBotFromListArgs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $WelcomePageAction<any>$ O O O O O O $BotState$ O O O O O $NotificationState$ O O O O O $IterableIterator<any>$ O O O O O O $IterableIterator<any>$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $BotState$ O $NotificationState$ O O O O $complex$ O O $complex$ O O $complex$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O O O $any[]$ O O O O O O $any[]$ O $number$ O $any[]$ O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $WelcomePageAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any[]$ O O O O O $any$ O O O O O O $string$ O O O $number$ O O O O O O $string$ O O O $number$ O O O O O O $string$ O O O $number$ O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string[]$ O O O O O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O O O O $string$ O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any[]$ O O O O O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O $any$ O $WelcomePageAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any[]$ O O O O O O O O O O O O O $any$ O $any$ O $WelcomePageAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $any[]$ O O O O O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any[]$ O O O O O O O O O O O O O $any$ O $any$ O $WelcomePageAction<any>$ O $complex$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O O
import { ariaAlertService } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { ariaAlertService . alert ( 's' ) ; const alertElement = document . querySelector ( 's' ) as HTMLSpanElement ; expect ( alertElement ) . toBeTruthy ( ) ; expect ( alertElement . innerText ) . toBe ( 's' ) ; ariaAlertService . alert ( 's' ) ; const alertElements = document . querySelectorAll ( 's' ) ; expect ( alertElements . length ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const preExistingAlerts = document . querySelectorAll ( 's' ) ; preExistingAlerts . forEach ( alert => alert . remove ( ) ) ; ariaAlertService . alert ( undefined ) ; const alertElement = document . querySelector ( 's' ) as HTMLSpanElement ; expect ( alertElement ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $AriaAlertService$ O O O O $any$ O O O O O O O $any$ O O O O O O O $AriaAlertService$ O $void$ O O O O O $HTMLSpanElement$ O $Document$ O O O O O O $complex$ O $any$ O $HTMLSpanElement$ O O $any$ O O O $any$ O $HTMLSpanElement$ O $string$ O O $any$ O O O O $AriaAlertService$ O $void$ O O O O O $NodeListOf<Element>$ O $Document$ O O O O O O $any$ O $NodeListOf<Element>$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $NodeListOf<Element>$ O $Document$ O O O O O O $NodeListOf<Element>$ O $void$ O $Element$ O $Element$ O $void$ O O O O $AriaAlertService$ O $void$ O $undefined$ O O O $HTMLSpanElement$ O $Document$ O O O O O O $complex$ O $any$ O $HTMLSpanElement$ O O $any$ O O O O O O O O O
import { FrameworkSettings , SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { DOCUMENT_ID_APP_SETTINGS } from 's' ; import * as EditorActions from 's' ; import { getTabGroupForDocument } from 's' ; import { RootState } from 's' ; import { debounce } from 's' ; import { saveFrameworkSettings } from 's' ; import { executeCommand } from 's' ; import { ariaAlertService } from 's' ; import { AppSettingsEditor , AppSettingsEditorProps } from 's' ; const mapStateToProps = ( state , ownProps ) => ( { ... ownProps , framework : state . framework , } ) ; const mapDispatchToProps = ( dispatch : ( action ) => void , ownProps ) => ( { createAriaAlert : ( msg ) => { ariaAlertService . alert ( msg ) ; } , discardChanges : ( ) => dispatch ( EditorActions . close ( getTabGroupForDocument ( ownProps . documentId ) , DOCUMENT_ID_APP_SETTINGS ) ) , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , openBrowseForNgrok : async ( ) => { const dialogOptions = { title : 's' , buttonLabel : 's' , properties : [ 's' ] , } ; return new Promise ( resolve => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . ShowOpenDialog , resolve , dialogOptions ) ) ; } ) ; } , saveFrameworkSettings : ( framework ) => dispatch ( saveFrameworkSettings ( framework ) ) , setDirtyFlag : debounce ( ( dirty ) => dispatch ( EditorActions . setDirtyFlag ( ownProps . documentId , dirty ) ) , 0 ) , } ) ; export const AppSettingsEditorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( AppSettingsEditor ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FrameworkAction<any>$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $AriaAlertService$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $AppSettingsEditorProps$ O O O O O $any$ O $any$ O $RootState$ O $any$ O O O O O $complex$ O O $void$ O O $Action$ O O O O $AppSettingsEditorProps$ O O O O $void$ O O $string$ O O O $AriaAlertService$ O $void$ O $string$ O O O O $void$ O O O O $void$ O $any$ O $CloseEditorAction$ O $string$ O $any$ O $any$ O O O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $Promise<unknown>$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O $PromiseConstructor$ O $void$ O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O $complex$ O O O O O O O O $void$ O O $FrameworkSettings$ O O $void$ O $FrameworkAction<any>$ O $any$ O O O $any$ O $any$ O O $boolean$ O O $void$ O $any$ O $SetDirtyFlagAction$ O $any$ O $any$ O $boolean$ O O O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O O
import { connect } from 's' ; import { Notification , SharedConstants , ValueTypesMask } from 's' ; import { RootState } from 's' ; import * as PresentationActions from 's' ; import * as ChatActions from 's' ; import { Document } from 's' ; import { updateDocument } from 's' ; import { beginAdd } from 's' ; import { executeCommand } from 's' ; import { restartConversation } from 's' ; import { Emulator , EmulatorProps } from 's' ; const mapStateToProps = ( state , { documentId , ... ownProps } : { documentId : string } ) => ( { activeDocumentId : state . editor . editors [ state . editor . activeEditor ] . activeDocumentId , conversationId : state . chat . chats [ documentId ] . conversationId , directLine : state . chat . chats [ documentId ] . directLine , document : state . chat . chats [ documentId ] , endpointId : state . chat . chats [ documentId ] . endpointId , framework : state . framework , presentationModeEnabled : state . presentation . enabled , url : state . clientAwareSettings . serverUrl , ... ownProps , } ) ; const mapDispatchToProps = ( dispatch ) : EmulatorProps => ( { enablePresentationMode => enable ? dispatch ( PresentationActions . enable ( ) ) : dispatch ( PresentationActions . disable ( ) ) , setInspectorObjects : ( documentId , objects ) => dispatch ( ChatActions . setInspectorObjects ( documentId , objects ) ) , clearLog : ( documentId ) => { return new Promise ( resolve => { dispatch ( ChatActions . clearLog ( documentId , resolve ) ) ; } ) ; } , restartDebugSession : ( conversationId , documentId ) => dispatch ( restartConversation ( conversationId , documentId ) ) , newConversation : ( documentId , options ) => dispatch ( ChatActions . newConversation ( documentId , options ) ) , updateChat : ( documentId , updatedValues ) => dispatch ( ChatActions . updateChat ( documentId , updatedValues ) ) , updateDocument : ( documentId , updatedValues < Document > ) => dispatch ( updateDocument ( documentId , updatedValues ) ) , createErrorNotification : ( notification ) => dispatch ( beginAdd ( notification ) ) , trackEvent : ( name , properties ? : { [ key ] : any } ) => dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , name , properties ) ) , exportItems : ( valueTypes , conversationId ) => dispatch ( executeCommand ( true , SharedConstants . Commands . Emulator . SaveTranscriptToFile , null , valueTypes , conversationId ) ) , } ) ; export const EmulatorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( Emulator ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $UpdateDocumentAction$ O O O O O O $BeginAddNotificationAction$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $BotAction<RestartConversationPayload>$ O O O O O O $any$ O $any$ O O O O O $complex$ O O $RootState$ O O $string$ O O ${}$ O O O $string$ O O O O O O O $string$ O $RootState$ O $EditorState<any>$ O $complex$ O $RootState$ O $EditorState<any>$ O $string$ O O $string$ O $string$ O $RootState$ O $ChatState$ O $complex$ O $string$ O O $string$ O $any$ O $RootState$ O $ChatState$ O $complex$ O $string$ O O $any$ O $ChatDocument<any>$ O $RootState$ O $ChatState$ O $complex$ O $string$ O O $string$ O $RootState$ O $ChatState$ O $complex$ O $string$ O O $string$ O $any$ O $RootState$ O $any$ O $boolean$ O $RootState$ O $PresentationState$ O $boolean$ O $any$ O $RootState$ O $any$ O $any$ O O ${}$ O O O O O $any$ O O $any$ O O $any$ O O O $enable$ O $any$ O $any$ O $any$ O $PresentationAction$ O O O O $any$ O $any$ O $PresentationAction$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $any$ O $any$ O O O $Promise<unknown>$ O O $string$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $any$ O $ChatAction<ClearLogPayload>$ O $string$ O $void$ O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $BotAction<RestartConversationPayload>$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $ChatAction<NewConversationPayload>$ O $any$ O $any$ O O O $any$ O O $string$ O $any$ O O $any$ O $any$ O $ChatAction<UpdateChatPayload>$ O $string$ O $any$ O O O $any$ O O $any$ O $Partial$ O $any$ O O O $any$ O $UpdateDocumentAction$ O $any$ O $Partial<Document<any>>$ O O O $any$ O O $Notification$ O O $any$ O $BeginAddNotificationAction$ O $any$ O O O $any$ O O $string$ O $complex$ O O O O $string$ O O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $complex$ O O O $any$ O O $ValueTypesMask$ O $string$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O O O O O O O $any$ O $any$ O $complex$ O $any$ O O $any$ O O
import { connect } from 's' ; import { SharedConstants } from 's' ; import { Activity } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { setHighlightedObjects , setInspectorObjects } from 's' ; import { ariaAlertService } from 's' ; import { Inspector } from 's' ; const mapStateToProps = ( state , ownProps ) => { const { bot , theme , clientAwareSettings } = state ; return { ... ownProps , appPath : clientAwareSettings . appPath , botHash : bot . activeBotDigest , activeBot : bot . activeBot , themeInfo : theme , } ; } ; const mapDispatchToProps = dispatch => { return { createAriaAlert : ( msg ) => { ariaAlertService . alert ( msg ) ; } , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , trackEvent : ( name , properties ? : { [ key ] : any } ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , name , properties ) ) ; } , setHighlightedObjects : ( documentId , objects : Activity [ ] ) => dispatch ( setHighlightedObjects ( documentId , objects ) ) , setInspectorObjects : ( documentId , inspectorObjects : Activity [ ] ) => dispatch ( setInspectorObjects ( documentId , inspectorObjects ) ) , } ; } ; export const InspectorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( Inspector ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O O O O $AriaAlertService$ O O O O O O $any$ O O O O O $any$ O O $RootState$ O $any$ O O O O O $BotState$ O $ThemeState$ O $any$ O O $RootState$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $BotState$ O $string$ O $any$ O $BotState$ O $any$ O $ThemeState$ O $ThemeState$ O O O O O O $complex$ O $any$ O O O O $void$ O O $string$ O O O $AriaAlertService$ O $void$ O $string$ O O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $void$ O O $string$ O $complex$ O O O O $string$ O O O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $complex$ O O O O O $any$ O O $string$ O $any[]$ O $any$ O O O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $string$ O $any[]$ O O O $any$ O O $string$ O $any[]$ O $any$ O O O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $string$ O $any[]$ O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
import { connect } from 's' ; import { User } from 's' ; import { Activity } from 's' ; import { SharedConstants } from 's' ; import { setHighlightedObjects , setInspectorObjects , showContextMenuForActivity , } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { Chat , ChatProps } from 's' ; const mapStateToProps = ( state , { document } ) : Partial < ChatProps > => { const currentUserId = document . userId || state . clientAwareSettings . users . currentUserId ; const { documentId } = document ; return { currentUser : state . clientAwareSettings . users . usersById [ currentUserId ] || ( { id : currentUserId , name : 's' } as User ) , locale : state . clientAwareSettings . locale || 's' , webSpeechPonyfillFactory : state . chat . webSpeechFactories [ documentId ] , pendingSpeechTokenRetrieval : state . chat . pendingSpeechTokenRetrieval , webchatStore : state . chat . webChatStores [ documentId ] , } ; } ; const mapDispatchToProps = ( dispatch , ownProps ) : Partial < ChatProps > => { return { setInspectorObject : ( documentId , activity < Activity > ) => { dispatch ( setHighlightedObjects ( documentId , [ ] ) ) ; dispatch ( setInspectorObjects ( documentId , activity ) ) ; } , showContextMenuForActivity : ( activity < Activity > ) => dispatch ( showContextMenuForActivity ( activity ) ) , showOpenUrlDialog : async ( url ) => { return new Promise ( resolve => { dispatch ( executeCommand ( false , SharedConstants . Commands . UI . ShowOpenUrlDialog , resolve , url ) ) ; } ) ; } , ... ownProps , } ; } ; export const ChatContainer = connect ( mapStateToProps , mapDispatchToProps ) ( Chat ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<any>$ O O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $RootState$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $RootState$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O O $any$ O O $any$ O $RootState$ O $any$ O $any$ O O O $any$ O $RootState$ O $ChatState$ O $complex$ O $any$ O O $boolean$ O $RootState$ O $ChatState$ O $boolean$ O $any$ O $RootState$ O $ChatState$ O $complex$ O $any$ O O O O O O O $any$ O O $any$ O $ChatProps$ O O $any$ O $any$ O O O O O $void$ O O $string$ O $Partial$ O $any$ O O O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $string$ O O O O O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $string$ O $any$ O O O O O $any$ O O $Partial$ O $any$ O O O $any$ O $ChatAction<any>$ O $any$ O O O $Promise<unknown>$ O O O $string$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export default { backgroundColor : 's' , accent : 's' , subtle : 's' , primaryFont : 's' , bubbleBackground : 's' , bubbleFromUserBackground : 's' , bubbleFromUserTextColor : 's' , bubbleTextColor : 's' , bubbleMinHeight : 0 , microphoneButtonColorOnDictate : 's' , sendBoxBackground : 's' , sendBoxButtonColor : 's' , sendBoxButtonColorOnFocus : 's' , sendBoxButtonColorOnHover : 's' , sendBoxTextColor : 's' , timestampColor : 's' , suggestedActionBackground : 's' , suggestedActionBorder : 's' , suggestedActionTextColor : 's' , transcriptOverlayButtonBackground : 's' , transcriptOverlayButtonBackgroundOnFocus : 's' , transcriptOverlayButtonBackgroundOnHover : 's' , transcriptOverlayButtonColor : 's' , transcriptOverlayButtonColorOnFocus : 's' , transcriptOverlayButtonColorOnHover : 's' , } ;	O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
export * from 's' ;	O O O O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { ServiceTypes } from 's' ; import * as ConnectedServiceActions from 's' ; import { AzureLoginFailedDialogContainer , AzureLoginSuccessDialogContainer , ConnectServicePromptDialogContainer , GetStartedWithCSDialogContainer , ProgressIndicatorContainer , } from 's' ; import { ConnectedServicePickerContainer } from 's' ; import { ConnectedServiceEditorContainer } from 's' ; import { setHighlightedObjects , setInspectorObjects } from 's' ; import { executeCommand } from 's' ; import { LogEntry as LogEntryComponent , LogEntryProps } from 's' ; function mapDispatchToProps ( dispatch ) < LogEntryProps > { return { launchLuisEditor : ( ) => { dispatch ( ConnectedServiceActions . launchConnectedServicePicker ( { azureAuthWorkflowComponents : { promptDialog : ConnectServicePromptDialogContainer , loginSuccessDialog : AzureLoginSuccessDialogContainer , loginFailedDialog : AzureLoginFailedDialogContainer , } , pickerComponent : ConnectedServicePickerContainer , getStartedDialog : GetStartedWithCSDialogContainer , editorComponent : ConnectedServiceEditorContainer , progressIndicatorComponent : ProgressIndicatorContainer , serviceType : ServiceTypes . Luis , } ) ) ; } , setInspectorObjects : ( documentId , obj ) => dispatch ( setInspectorObjects ( documentId , obj ) ) , setHighlightedObjects : ( documentId , obj ) => dispatch ( setHighlightedObjects ( documentId , obj ) ) , reconnectNgrok : ( ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Ngrok . Reconnect ) ) ; } , showAppSettings : ( ) => { const { UI } = SharedConstants . Commands ; return dispatch ( executeCommand ( false , UI . ShowAppSettings ) ) ; } , trackEvent : ( name , properties ? : { [ key ] : any } ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , name , properties ) ) ; } , } ; } export const LogEntry = connect ( null , mapDispatchToProps ) ( LogEntryComponent ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O $any$ O O O O O $Partial$ O $any$ O O $any$ O O O O $void$ O O O O O $any$ O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O $string$ O $any$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $string$ O $any$ O O O $any$ O O $string$ O $any$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $string$ O $any$ O O O $void$ O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O O O O O $void$ O O $string$ O $complex$ O O O O $string$ O O O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $complex$ O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { WelcomePage , WelcomePageProps } from 's' ; function mapStateToProps ( state , ownProps ) { return { ... ownProps , debugMode : state . clientAwareSettings . debugMode , accessToken : state . azureAuth . access_token , } ; } function mapDispatchToProps ( dispatch : ( action ) => void ) { const { Commands , Channels } = SharedConstants ; return { onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , onNewBotClick : ( ) => new Promise ( resolve => dispatch ( executeCommand ( false , Commands . UI . ShowBotCreationDialog , resolve ) ) ) , showOpenBotDialog : ( ) => new Promise ( resolve => dispatch ( executeCommand ( false , SharedConstants . Commands . UI . ShowOpenBotDialog , resolve ) ) ) , signInWithAzure : ( ) => new Promise ( resolve => dispatch ( executeCommand ( false , Commands . UI . SignInToAzure , resolve ) ) ) , signOutWithAzure : ( ) => { dispatch ( executeCommand ( true , Commands . Azure . SignUserOutOfAzure ) ) ; dispatch ( executeCommand ( false , Commands . UI . InvalidateAzureArmToken ) ) ; } , switchToBot : ( path ) => dispatch ( executeCommand ( false , Commands . Bot . Switch , null , path ) ) , openBotInspectorDocs : ( ) => dispatch ( executeCommand ( false , Commands . UI . ShowMarkdownPage , null , Channels . ReadmeUrl , Channels . HelpLabel ) ) , } ; } export const WelcomePageContainer = connect ( mapStateToProps , mapDispatchToProps ) ( WelcomePage ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $WelcomePageProps$ O $RootState$ O $WelcomePageProps$ O O O O O $any$ O $any$ O $RootState$ O $any$ O $any$ O $string$ O $RootState$ O $AzureAuthState$ O $string$ O O O O O $WelcomePageProps$ O $void$ O O $Action$ O O O O O O O $any$ O $any$ O O $any$ O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $void$ O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $void$ O O O O $void$ O O O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O O O O O $void$ O O $string$ O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $void$ O O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
import { BotInfo , SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { openContextMenuForBot } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { RecentBotsList , RecentBotsListProps } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) : RecentBotsListProps => { return { recentBots : state . bot . botFiles , ... ownProps , } ; } ; const mapDispatchToProps = ( dispatch : ( action ) => void ) : RecentBotsListProps => { return { onDeleteBotClick : ( path ) : void => dispatch ( executeCommand ( true , SharedConstants . Commands . Bot . RemoveFromBotList , null , path ) ) , showContextMenuForBot : ( bot ) : void => dispatch ( openContextMenuForBot ( bot ) ) , } ; } ; export const RecentBotsListContainer = connect ( mapStateToProps , mapDispatchToProps ) ( RecentBotsList ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $WelcomePageAction<any>$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $complex$ O O O $string$ O O O O O O $any$ O O O O $any[]$ O $RootState$ O $BotState$ O $any[]$ O O $complex$ O O O O O O $any$ O O $void$ O O $Action$ O O O O O $any$ O O O O $void$ O O $string$ O O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $void$ O O $BotInfo$ O O O O $void$ O $WelcomePageAction<any>$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { executeCommand } from 's' ; import { HowToBuildABot , HowToBuildABotProps } from 's' ; function mapDispatchToProps ( dispatch : ( action ) => void ) { return { onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } export const HowToBuildABotContainer = connect ( undefined , mapDispatchToProps ) ( HowToBuildABot ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $HowToBuildABotProps$ O $void$ O O $Action$ O O O O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O $any$ O $any$ O $undefined$ O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { BotConfigWithPath } from 's' ; import { IEndpointService , ServiceTypes } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import * as botHelpers from 's' ; import * as editorHelpers from 's' ; import { store } from 's' ; import { ActiveBotHelper } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; it ( 's' , async ( ) => { ( editorHelpers as any ) . hasNonGlobalTabs = jest . fn ( ) . mockReturnValueOnce ( true ) . mockReturnValueOnce ( false ) ; commandService . remoteCall = jest . fn ( ) . mockResolvedValue ( 's' ) ; const 0 = await ActiveBotHelper . confirmSwitchBot ( ) ; expect ( 0 ) . toBe ( 's' ) ; const 0 = await ActiveBotHelper . confirmSwitchBot ( ) ; expect ( 0 ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { ( editorHelpers as any ) . hasNonGlobalTabs = jest . fn ( ) . mockReturnValueOnce ( true ) . mockReturnValueOnce ( false ) ; commandService . remoteCall = jest . fn ( ) . mockResolvedValue ( 's' ) ; const 0 = await ActiveBotHelper . confirmCloseBot ( ) ; expect ( 0 ) . toBe ( 's' ) ; const 0 = await ActiveBotHelper . confirmCloseBot ( ) ; expect ( 0 ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { const 0 = jest . fn ( ) . mockResolvedValue ( true ) ; commandService . remoteCall = 0 ; ( store as any ) . dispatch = ( ) => null ; await ActiveBotHelper . closeActiveBot ( ) ; expect ( 0 ) . toHaveBeenCalledTimes ( 0 ) ; const 0 = jest . fn ( ) . mockRejectedValue ( 's' ) ; commandService . remoteCall = 0 ; expect ( ActiveBotHelper . closeActiveBot ( ) ) . rejects . toEqual ( new Error ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const mockRemoteCall = jest . fn ( ) . mockResolvedValue ( true ) ; commandService . remoteCall = mockRemoteCall ; await ActiveBotHelper . botAlreadyOpen ( ) ; expect ( mockRemoteCall ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { const mockRemoteCall = jest . fn ( ) . mockResolvedValue ( true ) ; commandService . remoteCall = mockRemoteCall ; await ActiveBotHelper . browseForBotFile ( ) ; expect ( mockRemoteCall ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { const backupConfirmCloseBot = ActiveBotHelper . confirmCloseBot ; const backupCloseActiveBot = ActiveBotHelper . closeActiveBot ; ( botHelpers as any ) . getActiveBot = jest . fn ( ) . mockReturnValueOnce ( null ) . mockReturnValue ( { } ) ; ActiveBotHelper . confirmCloseBot = jest . fn ( ) . mockResolvedValue ( { } ) ; ActiveBotHelper . closeActiveBot = jest . fn ( ) . mockResolvedValue ( null ) ; await ActiveBotHelper . confirmAndCloseBot ( ) ; expect ( ActiveBotHelper . confirmCloseBot ) . not . toBeCalled ( ) ; await ActiveBotHelper . confirmAndCloseBot ( ) ; expect ( ActiveBotHelper . confirmCloseBot ) . toHaveBeenCalled ( ) ; expect ( ActiveBotHelper . closeActiveBot ) . toHaveBeenCalled ( ) ; ActiveBotHelper . confirmCloseBot = jest . fn ( ) . mockRejectedValue ( 's' ) ; expect ( ActiveBotHelper . confirmAndCloseBot ( ) ) . rejects . toEqual ( new Error ( 's' ) ) ; ActiveBotHelper . confirmCloseBot = backupConfirmCloseBot ; ActiveBotHelper . closeActiveBot = backupCloseActiveBot ; } ) ; it ( 's' , async ( ) => { const bot = { name : 's' , description : 's' , path : 's' , padlock : null , services : [ ] , version : 's' , } ; const mockDispatch = jest . fn ( ( ... args : any [ ] ) => null ) ; ( store as any ) . dispatch = mockDispatch ; let mockRemoteCall = jest . fn ( ) . mockResolvedValue ( { } ) ; commandService . remoteCall = mockRemoteCall ; await ActiveBotHelper . setActiveBot ( bot ) ; expect ( mockDispatch ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockRemoteCall ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . SetActive , bot ) ; mockRemoteCall = jest . fn ( ) . mockRejectedValueOnce ( 's' ) ; commandService . remoteCall = mockRemoteCall ; expect ( ActiveBotHelper . setActiveBot ( bot ) ) . rejects . toEqual ( new Error ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const backupConfirmSwitchBot = ActiveBotHelper . confirmSwitchBot ; ActiveBotHelper . confirmSwitchBot = ( ) => new Promise ( ( resolve , reject ) => resolve ( true ) ) ; const backupSetActiveBot = ActiveBotHelper . setActiveBot ; ActiveBotHelper . setActiveBot = ( activeBot ) => new Promise ( ( resolve , reject ) => resolve ( ) ) ; const mockDispatch = jest . fn ( ) . mockReturnValue ( null ) ; ( store as any ) . dispatch = mockDispatch ; const endpoint = { appId : 's' , appPassword : 's' , type : ServiceTypes . Endpoint , endpoint : 's' , id : 's' , name : 's' , } ; const bot = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ endpoint ] , version : 's' , } ; let mockRemoteCall = jest . fn ( ) . mockResolvedValue ( bot ) ; const mockCall = jest . fn ( ) . mockResolvedValue ( null ) ; commandService . remoteCall = mockRemoteCall ; commandService . call = mockCall ; await ActiveBotHelper . confirmAndCreateBot ( bot , 's' ) ; expect ( mockDispatch ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . NewLiveChat , endpoint ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . Create , bot , 's' ) ; mockRemoteCall = jest . fn ( ) . mockRejectedValue ( 's' ) ; commandService . remoteCall = mockRemoteCall ; commandService . call = mockCall ; expect ( ActiveBotHelper . confirmAndCreateBot ( bot , 's' ) ) . rejects . toEqual ( new Error ( 's' ) ) ; ActiveBotHelper . confirmSwitchBot = backupConfirmSwitchBot ; ActiveBotHelper . setActiveBot = backupSetActiveBot ; } ) ; it ( 's' , async ( ) => { const backupGetState = store . getState ; store . getState = jest . fn ( ( ) => ( { clientAwareSettings : { users : { currentUserId : 's' } } } ) ) ; const backupBrowseForBotFile = ActiveBotHelper . browseForBotFile ; const backupBotAlreadyOpen = ActiveBotHelper . botAlreadyOpen ; const backupConfirmSwitchBot = ActiveBotHelper . confirmSwitchBot ; const bot = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ ] , version : 's' , } ; const mockDispatch = jest . fn ( ) . mockReturnValue ( null ) ; ( store as any ) . dispatch = mockDispatch ; ActiveBotHelper . browseForBotFile = ( ) => new Promise ( ( resolve , reject ) => resolve ( 's' ) ) ; ( botHelpers as any ) . getActiveBot = ( ) => bot ; ActiveBotHelper . botAlreadyOpen = ( ) => null ; await ActiveBotHelper . confirmAndOpenBotFromFile ( ) ; expect ( mockDispatch ) . not . toHaveBeenCalled ( ) ; ActiveBotHelper . browseForBotFile = ( ) => new Promise ( ( resolve , reject ) => resolve ( 's' ) ) ; ActiveBotHelper . confirmSwitchBot = ( ) => new Promise ( ( resolve , reject ) => resolve ( true ) ) ; const mockRemoteCall = jest . fn ( ) . mockResolvedValueOnce ( bot ) . mockResolvedValue ( null ) ; const mockCall = jest . fn ( ) . mockResolvedValue ( null ) ; commandService . remoteCall = mockRemoteCall ; commandService . call = mockCall ; await ActiveBotHelper . confirmAndOpenBotFromFile ( ) ; expect ( mockDispatch ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . Load , bot ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . SetCurrentUser , 's' ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . Open , 's' ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . SetActive , bot ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Telemetry . TrackEvent , 's' , { method : 's' , numOfServices : 0 , } ) ; ActiveBotHelper . browseForBotFile = backupBrowseForBotFile ; ActiveBotHelper . botAlreadyOpen = backupBotAlreadyOpen ; ActiveBotHelper . confirmSwitchBot = backupConfirmSwitchBot ; store . getState = backupGetState ; } ) ; it ( 's' , async ( ) => { const backupGetState = store . getState ; store . getState = jest . fn ( ( ) => ( { clientAwareSettings : { users : { currentUserId : 's' } } , framework : { userGUID : 's' } , } ) ) ; const backupBrowseForBotFile = ActiveBotHelper . browseForBotFile ; const backupBotAlreadyOpen = ActiveBotHelper . botAlreadyOpen ; const backupConfirmSwitchBot = ActiveBotHelper . confirmSwitchBot ; const bot = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ ] , version : 's' , } ; const mockDispatch = jest . fn ( ) . mockReturnValue ( null ) ; ( store as any ) . dispatch = mockDispatch ; ActiveBotHelper . browseForBotFile = ( ) => new Promise ( resolve => resolve ( 's' ) ) ; ActiveBotHelper . confirmSwitchBot = ( ) => new Promise ( resolve => resolve ( true ) ) ; const mockRemoteCall = jest . fn ( ) . mockResolvedValueOnce ( bot ) . mockResolvedValue ( null ) ; const mockCall = jest . fn ( ) . mockResolvedValue ( null ) ; commandService . remoteCall = mockRemoteCall ; commandService . call = mockCall ; await ActiveBotHelper . confirmAndOpenBotFromFile ( ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . SetCurrentUser , 's' ) ; ActiveBotHelper . browseForBotFile = backupBrowseForBotFile ; ActiveBotHelper . botAlreadyOpen = backupBotAlreadyOpen ; ActiveBotHelper . confirmSwitchBot = backupConfirmSwitchBot ; store . getState = backupGetState ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( ActiveBotHelper , 's' ) . mockRejectedValueOnce ( 's' ) ; try { await ActiveBotHelper . confirmAndOpenBotFromFile ( 's' ) ; expect ( false ) ; } catch ( e ) { expect ( e ) . not . toBeNull ( ) ; } } ) ; it ( 's' , async ( ) => { jest . spyOn ( commandService , 's' ) . mockRejectedValueOnce ( 's' ) ; jest . spyOn ( botHelpers , 's' ) . mockReturnValueOnce ( { path : 's' } ) ; try { await ActiveBotHelper . confirmAndSwitchBots ( 's' ) ; expect ( false ) ; } catch ( e ) { expect ( e ) . not . toBeNull ( ) ; } jest . resetAllMocks ( ) ; } ) ; it ( 's' , async ( ) => { const backupBotAlreadyOpen = ActiveBotHelper . botAlreadyOpen ; const backupConfirmSwitchBot = ActiveBotHelper . confirmSwitchBot ; const backupSetActiveBot = ActiveBotHelper . setActiveBot ; const endpoint = { appId : 's' , appPassword : 's' , type : ServiceTypes . Endpoint , endpoint : 's' , id : 's' , name : 's' , } ; const bot = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ endpoint ] , version : 's' , } ; const otherBot = { ... bot , path : 's' } ; const mockDispatch = jest . fn ( ( ) => null ) ; ( store as any ) . dispatch = mockDispatch ; ( botHelpers . getActiveBot as any ) = ( ) => bot ; ActiveBotHelper . botAlreadyOpen = ( ) => new Promise ( ( resolve , reject ) => resolve ( null ) ) ; await ActiveBotHelper . confirmAndSwitchBots ( bot ) ; ( botHelpers . getActiveBot as any ) = ( ) => otherBot ; const mockRemoteCall = jest . fn ( ) . mockResolvedValue ( bot ) ; const mockCall = jest . fn ( ) . mockResolvedValue ( null ) ; commandService . call = mockCall ; commandService . remoteCall = mockRemoteCall ; ActiveBotHelper . confirmSwitchBot = ( ) => new Promise ( ( resolve , reject ) => resolve ( true ) ) ; ActiveBotHelper . setActiveBot = ( arg ) => new Promise ( ( resolve , reject ) => resolve ( null ) ) ; await ActiveBotHelper . confirmAndSwitchBots ( bot ) ; expect ( mockCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . NewLiveChat , endpoint ) ; expect ( mockDispatch ) . toHaveBeenCalledTimes ( 0 ) ; mockDispatch . mockClear ( ) ; mockCall . mockClear ( ) ; await ActiveBotHelper . confirmAndSwitchBots ( 's' ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . Open , 's' ) ; mockCall . mockClear ( ) ; mockDispatch . mockClear ( ) ; bot . overrides = { endpoint : { endpoint : 's' , } , } ; await ActiveBotHelper . confirmAndSwitchBots ( bot ) ; expect ( mockCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . NewLiveChat , { ... endpoint , endpoint : 's' , } ) ; mockCall . mockClear ( ) ; const secondEndpoint = { ... endpoint , id : 's' , } ; bot . services . push ( secondEndpoint ) ; bot . overrides = { endpoint : { endpoint : 's' , id : 's' , } , } ; await ActiveBotHelper . confirmAndSwitchBots ( bot ) ; expect ( mockCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . NewLiveChat , { ... secondEndpoint , endpoint : 's' , } ) ; ActiveBotHelper . botAlreadyOpen = backupBotAlreadyOpen ; ActiveBotHelper . confirmSwitchBot = backupConfirmSwitchBot ; ActiveBotHelper . setActiveBot = backupSetActiveBot ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O $any$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O $any$ O $any$ O O $ErrorConstructor$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O $Promise<any>$ O O $Promise<void>$ O $any$ O $Promise<void>$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O $Promise<any>$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $Promise<any>$ O O O $any$ O $any$ O $Promise<any>$ O O $any$ O $any$ O O O O $any$ O $Promise<any>$ O O O $any$ O $any$ O $Promise<any>$ O O $any$ O O O $any$ O $any$ O $Promise<void>$ O O $any$ O O O $any$ O $Promise<any>$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $Promise<any>$ O O O O $any$ O $any$ O O $ErrorConstructor$ O O O O O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $Promise<void>$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O $any$ O O O $any$ O $any$ O O $ErrorConstructor$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O $Promise<any>$ O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $any$ O $Promise<void>$ O O $any$ O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O $IEndpointService$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $any[]$ O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $Promise<void>$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O O $ErrorConstructor$ O O O O O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O $Promise<any>$ O $any$ O $Promise<any>$ O O $Promise<void>$ O $any$ O $Promise<void>$ O O $Promise<any>$ O $any$ O $Promise<any>$ O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $Promise<void>$ O O O O O O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O O O O O $Promise<any>$ O $any$ O $Promise<any>$ O O $Promise<void>$ O $any$ O $Promise<void>$ O O $Promise<any>$ O $any$ O $Promise<any>$ O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O $void$ O $void$ O O O O O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O $void$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $Promise<any>$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O O O $any$ O $Promise<any>$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O O $Promise<any>$ O $any$ O $Promise<any>$ O O $Promise<void>$ O $any$ O $Promise<void>$ O O $IEndpointService$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $any[]$ O O $any$ O O $string$ O O O O O O $BotConfigWithPath$ O O O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $Promise<void>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $any$ O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O $any$ O $Promise<void>$ O O $any$ O O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $Promise<any>$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $complex$ O O $string$ O O O O O O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O O O O O $any$ O $any$ O O O O $IEndpointService$ O O O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O O O O O $any$ O $Promise<void>$ O $Promise<void>$ O $any$ O $Promise<any>$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O O O O
export default function memoize < T > ( fn : ( ... args : any [ ] ) => T ) { let lastArgs : any [ ] = [ ] ; let result : T ; return function ( ) : T { if ( lastArgs . length !== arguments . length || lastArgs . some ( ( arg , index ) => arg !== arguments [ index ] ) ) { result = fn . apply ( null , arguments ) ; lastArgs = [ ] . slice . call ( arguments ) ; } return result ; } ; }	O O O $T$ O $any$ O O $T$ O O O $any[]$ O O O O O O $any$ O O O $any[]$ O O O O O O O O O $T$ O $any$ O O O O O O $any$ O O O $any[]$ O $number$ O $IArguments$ O $number$ O $any[]$ O $boolean$ O O $any$ O $number$ O O $any$ O $IArguments$ O $number$ O O O O $T$ O $T$ O $any$ O O O $IArguments$ O O $any[]$ O O O O $undefined[]$ O $any$ O $IArguments$ O O O O $T$ O O O O
export * from 's' ;	O O O O O
import { connect } from 's' ; import { SharedConstants } from 's' ; import { RootState , rememberTheme } from 's' ; import { executeCommand } from 's' ; import { AppMenu , AppMenuProps } from 's' ; const { Commands : { Azure : { SignUserOutOfAzure } , Bot , Electron : { CheckForUpdates , QuitAndInstall } , UI : { InvalidateAzureArmToken , SignInToAzure } , } , } = SharedConstants ; function mapStateToProps ( state ) { const { activeEditor , editors } = state . editor ; const { activeDocumentId } = editors [ activeEditor ] ; const activeDocument = editors [ activeEditor ] . documents [ activeDocumentId ] || { contentType : undefined } ; return { activeBot : state . bot . activeBot , activeDocumentType : activeDocument . contentType , appUpdateStatus : state . update . status , availableThemes : state . settings . windowState . availableThemes , currentTheme : state . settings . windowState . theme , recentBots : state . bot . botFiles , signedInUser : state . settings . azure . signedInUser , } ; } function mapDispatchToProps ( dispatch ) { return { checkForUpdates : ( ) => { dispatch ( executeCommand ( true , CheckForUpdates , null ) ) ; } , invalidateAzureArmToken : ( ) => new Promise ( resolve => { dispatch ( executeCommand ( false , InvalidateAzureArmToken , resolve ) ) ; } ) , openBot : ( path ) => { dispatch ( executeCommand ( false , Bot . Switch , null , path ) ) ; } , signUserIn : ( ) => new Promise ( resolve => { dispatch ( executeCommand ( false , SignInToAzure , resolve ) ) ; } ) , signUserOut : ( ) => new Promise ( resolve => { dispatch ( executeCommand ( true , SignUserOutOfAzure , resolve ) ) ; } ) , switchTheme : ( themeName ) => { dispatch ( rememberTheme ( themeName ) ) ; } , quitAndInstall : ( ) => { dispatch ( executeCommand ( true , QuitAndInstall , null ) ) ; } , } ; } export const AppMenuContainer = connect ( mapStateToProps , mapDispatchToProps ) ( AppMenu ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $WindowStateAction<RememberThemePayload>$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O $AppMenuProps$ O $RootState$ O O O O $string$ O $complex$ O O $RootState$ O $EditorState<any>$ O O O $string$ O O $complex$ O $string$ O O O $complex$ O $complex$ O $string$ O O $complex$ O $string$ O O O $undefined$ O $undefined$ O O O O $any$ O $RootState$ O $BotState$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $RootState$ O $UpdateState$ O $any$ O $any$ O $RootState$ O $any$ O $any$ O $any$ O $any$ O $RootState$ O $any$ O $any$ O $any$ O $any[]$ O $RootState$ O $BotState$ O $any[]$ O $any$ O $RootState$ O $any$ O $any$ O $any$ O O O O O $AppMenuProps$ O $any$ O O O O $void$ O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $void$ O O O O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O O O $string$ O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $void$ O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $void$ O O O O O O $void$ O O $string$ O O O $any$ O $WindowStateAction<RememberThemePayload>$ O $string$ O O O O O $void$ O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { CommandServiceInstance , CommandServiceImpl } from 's' ; import { MenuItem } from 's' ; import { SharedConstants } from 's' ; import { remote } from 's' ; const { Channels : { HelpLabel , ReadmeUrl } , Commands : { Bot : { Close } , Electron : { OpenExternal , ShowMessageBox } , Emulator : { ClearState , GetServiceUrl , PromptToOpenTranscript , SendConversationUpdateUserAdded , SendBotContactAdded , SendBotContactRemoved , SendTyping , SendPing , SendDeleteUserData , } , UI : { ShowBotCreationDialog , ShowMarkdownPage , ShowOpenBotDialog , ShowWelcomePage } , } , } = SharedConstants ; const CtrlOrCmd = process . platform === 's' ? 's' : 's' ; export class AppMenuTemplate { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static get template ( ) : { [ key ] : MenuItem [ ] } { return { file : this . fileMenu , debug : this . debugMenu , edit : this . editMenu , view : this . viewMenu , conversation : this . conversationMenu , help : this . helpMenu , } ; } private static get fileMenu ( ) : MenuItem [ ] { return [ { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( ShowBotCreationDialog ) , subtext : `template` , } , { type : 's' } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( ShowOpenBotDialog ) , subtext : `template` , } , { label : 's' , type : 's' , items : [ ] , } , { type : 's' } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( PromptToOpenTranscript ) } , { type : 's' } , { label : 's' , disabled : true , onClick : ( ) => AppMenuTemplate . commandService . call ( Close ) } , { type : 's' } , { label : 's' } , { label : 's' , onClick : async ( ) => await AppMenuTemplate . commandService . remoteCall ( ClearState ) } , { type : 's' } , { label : 's' , type : 's' , items : [ ] , } , { type : 's' } , { label : 's' , onClick : async ( ) => { const url = await AppMenuTemplate . commandService . remoteCall ( GetServiceUrl ) ; remote . clipboard . writeText ( url ) ; } , } , { type : 's' } , { label : 's' , onClick : ( ) => remote . app . quit ( ) } , ] ; } private static get debugMenu ( ) : MenuItem [ ] { return [ { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( ShowOpenBotDialog , true ) } ] ; } private static get editMenu ( ) : MenuItem [ ] { return [ { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . undo ( ) , subtext : `template` } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . redo ( ) , subtext : `template` } , { type : 's' } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . cut ( ) , subtext : `template` } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . copy ( ) , subtext : `template` } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . paste ( ) , subtext : `template` } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . delete ( ) } , ] ; } private static get viewMenu ( ) : MenuItem [ ] { const maxZoomFactor = 0 ; const minZoomFactor = 0 ; return [ { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . setZoomLevel ( 0 ) , subtext : `template` } , { label : 's' , onClick : ( ) => { const webContents = remote . getCurrentWebContents ( ) ; webContents . getZoomFactor ( zoomFactor => { const newZoomFactor = zoomFactor + 0 ; if ( newZoomFactor >= maxZoomFactor ) { webContents . setZoomFactor ( maxZoomFactor ) ; } else { webContents . setZoomFactor ( newZoomFactor ) ; } } ) ; } , subtext : `template` , } , { label : 's' , onClick : ( ) => { const webContents = remote . getCurrentWebContents ( ) ; webContents . getZoomFactor ( zoomFactor => { const newZoomFactor = zoomFactor - 0 ; if ( newZoomFactor <= minZoomFactor ) { webContents . setZoomFactor ( minZoomFactor ) ; } else { webContents . setZoomFactor ( newZoomFactor ) ; } } ) ; } , subtext : `template` , } , { type : 's' } , { label : 's' , onClick : ( ) => { const currentWindow = remote . getCurrentWindow ( ) ; currentWindow . setFullScreen ( ! currentWindow . isFullScreen ( ) ) ; } , subtext : 's' , } , { label : 's' , onClick : ( ) => remote . getCurrentWebContents ( ) . toggleDevTools ( ) , subtext : `template` , } , ] ; } private static get conversationMenu ( ) : MenuItem [ ] { return [ { label : 's' , type : 's' , items : [ { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendConversationUpdateUserAdded ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendBotContactAdded ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendBotContactRemoved ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendTyping ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendPing ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( SendDeleteUserData ) , } , ] , } , ] ; } private static get helpMenu ( ) : MenuItem [ ] { const { openLink } = this ; const appName = remote . app . getName ( ) ; const appVersion = remote . app . getVersion ( ) ; return [ { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( ShowWelcomePage ) } , { type : 's' } , { label : 's' , onClick : openLink ( 's' ) } , { label : 's' , onClick : openLink ( 's' ) } , { label : 's' , onClick : openLink ( 's' ) } , { type : 's' } , { label : 's' , onClick : openLink ( 's' ) } , { type : 's' } , { label : 's' } , { type : 's' } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . call ( ShowMarkdownPage , ReadmeUrl , HelpLabel ) , } , { label : 's' , onClick : ( ) => AppMenuTemplate . commandService . remoteCall ( ShowMessageBox , null , { type : 's' , title : appName , message : appName + 's' + appVersion , buttons : [ 's' ] , } ) , } , ] ; } private static openLink = ( url ) => ( ) : void => { AppMenuTemplate . commandService . remoteCall ( OpenExternal , url ) ; } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $complex$ O O O O O $string$ O O $any$ O O O O O O $any[]$ O O O $any[]$ O $any[]$ O O O $any[]$ O $any[]$ O O O $any[]$ O $any[]$ O O O $any[]$ O $any[]$ O O O $any[]$ O $any[]$ O O O $any[]$ O O O O O O O $any[]$ O O O $any$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O O $boolean$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O O O O $string$ O O O $Promise<any>$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O $string$ O O O O O $string$ O O O $Promise<void>$ O O O O O O O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any[]$ O O O $any$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any[]$ O O O $any$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O $any[]$ O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $string$ O O O O O $string$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $string$ O O O O O O $string$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O $any$ O O O O O $number$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O O O O $string$ O O O O O O $string$ O O O O O $string$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $string$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O O O O O O O O $any[]$ O O O $any$ O O O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any[]$ O O O $any$ O O O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O O $void$ O $void$ O O O O O O $string$ O O O $void$ O $void$ O O O O O O $string$ O O O $void$ O $void$ O O O O O O $string$ O O O O O $string$ O O O $void$ O $void$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O $string$ O $any$ O O O $any$ O $string[]$ O O O O O O O O O O O O O O O $void$ O O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O
import { AppMenuTemplate } from 's' ; jest . mock ( 's' , ( ) => ( { remote : { app : { getName : ( ) => 's' , getVersion : ( ) => 's' , } , } , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const template = AppMenuTemplate . template ; expect ( Object . keys ( template ) ) . toEqual ( [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; expect ( template [ 's' ] ) . toHaveLength ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $any$ O O O O O O O O O O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O
import { connect } from 's' ; import { RootState } from 's' ; import { BotSettingsEditorContainer } from 's' ; import { DialogService } from 's' ; import BotExplorerBar from 's' ; const mapStateToProps = ( state ) => { return { openBotSettings : ( ) => DialogService . showDialog ( BotSettingsEditorContainer , { bot : state . bot . activeBot } ) . catch ( ) , } ; } ; export const BotExplorerBarContainer = connect ( mapStateToProps ) ( BotExplorerBar ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O $any$ O O O O $complex$ O O $RootState$ O O O O O $Promise<any>$ O O O O $DialogServiceImpl$ O $Promise<R>$ O $any$ O O $any$ O $RootState$ O $BotState$ O $any$ O O O $Promise<any>$ O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O O
import { SharedConstants } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { newNotification } from 's' ; import { RootState } from 's' ; import { ActiveBotHelper } from 's' ; import { executeCommand } from 's' ; import { beginAdd } from 's' ; import { BotNotOpenExplorer as BotNotOpenExplorerComp , BotNotOpenExplorerProps } from 's' ; const mapStateToProps = ( state ) : any => ( { hasChat : ! ! Object . keys ( state . chat . chats ) . length , } ) ; const mapDispatchToProps = ( dispatch : ( action ) => void ) : BotNotOpenExplorerProps => ( { openBotFile : async ( ) => { try { await ActiveBotHelper . confirmAndOpenBotFromFile ( ) ; } catch ( e ) { dispatch ( beginAdd ( newNotification ( `template` ) ) ) ; } } , showCreateNewBotDialog : ( ) => new Promise ( resolve => { dispatch ( executeCommand ( false , SharedConstants . Commands . UI . ShowBotCreationDialog , resolve ) ) ; } ) , } ) ; export const BotNotOpenExplorerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( BotNotOpenExplorerComp ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $BeginAddNotificationAction$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $RootState$ O O O O O O $boolean$ O O O $ObjectConstructor$ O $complex$ O $RootState$ O $ChatState$ O $complex$ O O $number$ O O O O O $any$ O O $void$ O O $Action$ O O O O O $any$ O O O $Promise<void>$ O O O O O O O O O $any$ O $Promise<any>$ O O O O O O $any$ O O $void$ O $BeginAddNotificationAction$ O $any$ O O O O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export * from 's' ;	O O O O O
import { SharedConstants } from 's' ; import { IBotService , IEndpointService , ServiceTypes } from 's' ; import { connect } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { EndpointEditor , EndpointEditorProps , UpdatedServicesPayload } from 's' ; const mapStateToProps = ( state , ownProps ) : EndpointEditorProps => { const { endpointService = { } as IEndpointService } = ownProps ; const { services = [ ] } = state . bot . activeBot ; let botService ; if ( endpointService . appId ) { botService = services . find ( service => service . type === ServiceTypes . Bot && ( service as IBotService ) . appId === endpointService . appId ) as IBotService ; } return { botService , ... ownProps , } ; } ; const mapDispatchToProps = dispatch => ( ) : Partial < EndpointEditorProps > => { return { updateEndpointService : ( updatedServices ) => DialogService . hideDialog ( updatedServices ) , cancel : ( ) => DialogService . hideDialog ( ) , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } ; export const EndpointEditorContainer = connect ( mapStateToProps , mapDispatchToProps ) ( EndpointEditor ) as any ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $RootState$ O $EndpointEditorProps$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O $any$ O O O O O $RootState$ O $BotState$ O $any$ O O $IBotService$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $void$ O O $UpdatedServicesPayload$ O O $DialogServiceImpl$ O $void$ O $any$ O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O
export { EndpointEditorContainer } from 's' ;	O O $any$ O O O O
import { IEndpointService , ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import { connect } from 's' ; import { launchEndpointEditor , openEndpointExplorerContextMenu , openEndpointInEmulator , } from 's' ; import { RootState } from 's' ; import { EndpointEditor } from 's' ; import { EndpointExplorer } from 's' ; const mapStateToProps = ( state , ... ownProps : any [ ] ) => { const { services } = state . bot . activeBot ; return { endpointServices : services . filter ( service => service . type === ServiceTypes . Endpoint ) , window , ... ownProps , } ; } ; const mapDispatchToProps = dispatch => { return { launchEndpointEditor : ( endpointEditor < EndpointEditor > , endpointService ) => new Promise ( resolve => { dispatch ( launchEndpointEditor ( endpointEditor , endpointService , resolve ) ) ; } ) , openEndpointInEmulator : ( endpointService ) => dispatch ( openEndpointInEmulator ( endpointService , true ) ) , openContextMenuForService : ( endpointService , endpointEditor < EndpointEditor > ) => dispatch ( openEndpointExplorerContextMenu ( endpointEditor , endpointService ) ) , } ; } ; export const EndpointExplorerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( EndpointExplorer as any ) as any ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O $RootState$ O O $any[]$ O O O O O O O O O $any$ O O $RootState$ O $BotState$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any[]$ O O O O O O $complex$ O $any$ O O O O $Promise<unknown>$ O O $ComponentClass$ O $any$ O O $IEndpointService$ O O O $PromiseConstructor$ O $void$ O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O $void$ O O O O O O $any$ O O $IEndpointService$ O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O O O O $any$ O O $IEndpointService$ O $ComponentClass$ O $any$ O O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $complex$ O O $any$ O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { IFileService } from 's' ; import { ComponentClass } from 's' ; import { connect } from 's' ; import { openContextMenuForResource , openResource , openResourcesSettings , renameResource , } from 's' ; import { RootState } from 's' ; import { ResourceExplorer , ResourceExplorerProps } from 's' ; const mapStateToProps = ( state , ownProps ) : ResourceExplorerProps => ( { fileToRename : state . resources . resourceToRename , ... ownProps , } ) ; const mapDispatchToProps = ( dispatch : ( ... args : any [ ] ) => void ) : ResourceExplorerProps => ( { openContextMenuForService : ( resource ) => dispatch ( openContextMenuForResource ( resource ) ) , renameResource => dispatch ( renameResource ( resource ) ) , openResource => dispatch ( openResource ( resource ) ) , openResourcesSettings : ( dialog < any > ) => dispatch ( openResourcesSettings ( { dialog } ) ) , window , } ) ; export const ResourceExplorerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( ResourceExplorer ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<ResourceSettingsPayload>$ O $ResourcesAction<any>$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $ResourceExplorerProps$ O O $any$ O O O $any$ O $RootState$ O $ResourcesState$ O $any$ O O $any$ O O O O O $any$ O O $void$ O O O $any[]$ O O O O O O O O O $any$ O O O $void$ O O $IFileService$ O O $void$ O $ResourcesAction<any>$ O $any$ O O O $resource$ O $void$ O $ResourcesAction<any>$ O $any$ O O O $resource$ O $void$ O $ResourcesAction<any>$ O $any$ O O O $void$ O O $ComponentClass$ O O O O O $void$ O $ResourcesAction<ResourceSettingsPayload>$ O O $any$ O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { connect } from 's' ; import { RootState } from 's' ; import { ResourcesBar , ResourcesBarProps } from 's' ; const mapStateToProps = ( state , ownProps ) : ResourcesBarProps => ( { chatFiles : state . resources . chats , chatsPath : state . resources . chatsPath , transcripts : state . resources . transcripts , transcriptsPath : state . resources . transcriptsPath , ... ownProps , } ) ; export const ResourcesBarContainer = connect ( mapStateToProps ) ( ResourcesBar ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $ResourcesBarProps$ O O $any$ O O O $any[]$ O $RootState$ O $ResourcesState$ O $any[]$ O $string$ O $RootState$ O $ResourcesState$ O $string$ O $any[]$ O $RootState$ O $ResourcesState$ O $any[]$ O $string$ O $RootState$ O $ResourcesState$ O $string$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O
import { SharedConstants } from 's' ; import { ServiceTypes } from 's' ; import { connect } from 's' ; import { Action } from 's' ; import { RootState } from 's' ; import { DialogService } from 's' ; import { executeCommand } from 's' ; import { ConnectedServicePicker } from 's' ; const mapStateToProps = ( state , ownProps : { [ propName ] : any } ) => { const { services } = state . bot . activeBot ; return { connectedServices : services . filter ( service => service . type !== ServiceTypes . Endpoint ) , ... ownProps , } ; } ; const mapDispatchToProps = ( dispatch : ( action ) => void ) => { return { launchServiceEditor : ( ) => DialogService . hideDialog ( 0 ) , connectServices => DialogService . hideDialog ( servicesToConnect ) , cancel : ( ) => DialogService . hideDialog ( 0 ) , onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , } ; } ; export const ConnectedServicePickerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( ConnectedServicePicker ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DialogServiceImpl$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O O O O O $complex$ O O $RootState$ O $complex$ O O O $string$ O O O O O O O O O $any$ O O $RootState$ O $BotState$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O O O O $complex$ O O $void$ O O $Action$ O O O O O O O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $servicesToConnect$ O $DialogServiceImpl$ O $void$ O $any$ O O $void$ O O O O $DialogServiceImpl$ O $void$ O O O O $void$ O O $string$ O O O $void$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O $any$ O $any$ O $complex$ O $complex$ O O $any$ O O
import { SharedConstants } from 's' ; import { IConnectedService , ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import { connect } from 's' ; import { ConnectedServicePickerPayload , openAddServiceContextMenu , openContextMenuForConnectedService , openServiceDeepLink , openSortContextMenu , } from 's' ; import { CONNECTED_SERVICES_PANEL_ID } from 's' ; import { executeCommand } from 's' ; import { RootState } from 's' ; import { ConnectedServiceEditor } from 's' ; import { ServicesExplorer , ServicesExplorerProps } from 's' ; const mapStateToProps = ( state ) : Partial < ServicesExplorerProps > => { const { services = [ ] } = state . bot . activeBot ; const { [ CONNECTED_SERVICES_PANEL_ID ] : sortCriteria } = state . explorer . sortSelectionByPanelId ; return { services : services . filter ( service => service . type === ServiceTypes . QnA || service . type === ServiceTypes . Dispatch || service . type === ServiceTypes . AppInsights || service . type === ServiceTypes . BlobStorage || service . type === ServiceTypes . CosmosDB || service . type === ServiceTypes . Generic || service . type === ServiceTypes . Luis ) , sortCriteria , window , } ; } ; const mapDispatchToProps = ( dispatch ) : Partial < ServicesExplorerProps > => { return { onAnchorClick : ( url ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Electron . OpenExternal , null , url ) ) ; } , openAddServiceContextMenu : ( payload ) => new Promise ( resolve => dispatch ( openAddServiceContextMenu ( payload , resolve ) ) ) , openServiceDeepLink : ( connectedService ) => dispatch ( openServiceDeepLink ( connectedService ) ) , openContextMenuForService : ( connectedService , editorComponent < ConnectedServiceEditor > ) => dispatch ( openContextMenuForConnectedService ( editorComponent , connectedService ) ) , openSortContextMenu : ( ) => dispatch ( openSortContextMenu ( ) ) , } ; } ; export const ServicesExplorerContainer = connect ( mapStateToProps , mapDispatchToProps ) ( ServicesExplorer ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O O $any$ O $any$ O O O O O $any$ O O O O O $RootState$ O $BotState$ O $any$ O O O O O O O $string$ O O $RootState$ O $ExplorerState$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O $complex$ O O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $void$ O O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $Promise<unknown>$ O O $ConnectedServicePickerPayload$ O O O $PromiseConstructor$ O $void$ O $any$ O $ConnectedServiceAction<OpenAddServiceContextMenuPayload>$ O $ConnectedServicePickerPayload$ O $void$ O O O O $any$ O O $IConnectedService$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O O $any$ O O $IConnectedService$ O $ComponentClass$ O $any$ O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { Notification , NotificationType , SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { remote } from 's' ; const maxZoomFactor = 0 ; const minZoomFactor = 0 ; class EventHandlers { @ CommandServiceInstance ( ) public static commandService : CommandServiceImpl ; public static async globalHandles ( event ) < any > { const ctrlOrCmdPressed = event . ctrlKey || event . metaKey ; const shiftPressed = event . shiftKey ; const key = event . key . toLowerCase ( ) ; const { Commands : { Electron : { ToggleDevTools } , UI : { ShowBotCreationDialog , ShowOpenBotDialog } , Notifications : { Add } , } , } = SharedConstants ; let awaitable < any > ; if ( ctrlOrCmdPressed && key === 's' ) { awaitable = EventHandlers . commandService . call ( ShowOpenBotDialog ) ; } if ( ctrlOrCmdPressed && key === 's' ) { awaitable = EventHandlers . commandService . call ( ShowBotCreationDialog ) ; } if ( ctrlOrCmdPressed && key === 's' ) { remote . getCurrentWebContents ( ) . setZoomLevel ( 0 ) ; } if ( ctrlOrCmdPressed && ( key === 's' || key === 's' ) ) { const webContents = remote . getCurrentWebContents ( ) ; webContents . getZoomFactor ( zoomFactor => { const newZoomFactor = zoomFactor + 0 ; if ( newZoomFactor >= maxZoomFactor ) { webContents . setZoomFactor ( maxZoomFactor ) ; } else { webContents . setZoomFactor ( newZoomFactor ) ; } } ) ; } if ( ctrlOrCmdPressed && ( key === 's' || key === 's' ) ) { const webContents = remote . getCurrentWebContents ( ) ; webContents . getZoomFactor ( zoomFactor => { const newZoomFactor = zoomFactor - 0 ; if ( newZoomFactor <= minZoomFactor ) { webContents . setZoomFactor ( minZoomFactor ) ; } else { webContents . setZoomFactor ( newZoomFactor ) ; } } ) ; } if ( key === 's' ) { const currentWindow = remote . getCurrentWindow ( ) ; currentWindow . setFullScreen ( ! currentWindow . isFullScreen ( ) ) ; } if ( ctrlOrCmdPressed && shiftPressed && key === 's' ) { awaitable = EventHandlers . commandService . remoteCall ( ToggleDevTools ) ; } if ( awaitable ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; try { await awaitable ; } catch ( e ) { await EventHandlers . commandService . call ( Add , { message : 's' + e , type : NotificationType . Error , } as Notification ) ; } } } } export const globalHandlers = EventHandlers . globalHandles ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $Promise$ O $KeyboardEvent$ O O O O O O $boolean$ O $KeyboardEvent$ O $boolean$ O $KeyboardEvent$ O $boolean$ O O $boolean$ O $KeyboardEvent$ O $boolean$ O O $string$ O $KeyboardEvent$ O $string$ O $string$ O O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O O $Promise$ O O O O O O $boolean$ O $string$ O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O $string$ O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O $string$ O O O O $any$ O $any$ O O O $any$ O O O O O O O $boolean$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O $any$ O O O O O $number$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $boolean$ O $boolean$ O $string$ O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O O $KeyboardEvent$ O $void$ O O O $KeyboardEvent$ O $void$ O O O O O O $Promise<any>$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $Promise<any>$ O $any$ O $Promise<any>$ O
import { connect } from 's' ; import { SharedConstants } from 's' ; import * as Constants from 's' ; import * as PresentationActions from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { showWelcomePage } from 's' ; import { globalHandlers } from 's' ; import { Main , MainProps } from 's' ; const mapStateToProps = ( state ) : MainProps => ( { presentationModeEnabled : state . presentation . enabled , primaryEditor : state . editor . editors [ Constants . EDITOR_KEY_PRIMARY ] , secondaryEditor : state . editor . editors [ Constants . EDITOR_KEY_SECONDARY ] , explorerIsVisible : state . explorer . showing , navBarSelection : state . navBar . selection , } ) ; const mapDispatchToProps = ( dispatch ) : MainProps => ( { exitPresentationMode : ( e ) => { if ( e . key === 's' ) { dispatch ( PresentationActions . disable ( ) ) ; } } , applicationMountComplete : async ( ) => { await new Promise ( resolve => { dispatch ( executeCommand ( true , SharedConstants . Commands . ClientInit . Loaded , resolve ) ) ; } ) ; showWelcomePage ( ) ; await new Promise ( resolve => { dispatch ( executeCommand ( true , SharedConstants . Commands . ClientInit . PostWelcomeScreen , resolve ) ) ; } ) ; window . addEventListener ( 's' , globalHandlers , true ) ; } , } ) ; export default connect ( mapStateToProps , mapDispatchToProps ) ( Main ) ;	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $void$ O O O O O O $Promise<any>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O O $any$ O O O $boolean$ O $RootState$ O $PresentationState$ O $boolean$ O $Editor<any>$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O O O O $Editor<any>$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O O O O $boolean$ O $RootState$ O $ExplorerState$ O $boolean$ O $string$ O $RootState$ O $NavBarState$ O $string$ O O O O O $any$ O O $any$ O O $any$ O O O $void$ O O $KeyboardEvent$ O O O O O $KeyboardEvent$ O $string$ O O O O $any$ O $any$ O $PresentationAction$ O O O O O O O $Promise<void>$ O O O O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O O $void$ O O O O O $PromiseConstructor$ O $void$ O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O O $complex$ O O O O O $Promise<any>$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O
import { connect } from 's' ; import { RootState } from 's' ; import { Documents , DocumentsProps } from 's' ; function mapStateToProps ( state , ownProps ) { const { editors } = state . editor ; return { ... ownProps , activeDocumentId : editors [ ownProps . owningEditor ] . activeDocumentId , documents : editors [ ownProps . owningEditor ] . documents , tabOrder : editors [ ownProps . owningEditor ] . tabOrder , } ; } export const DocumentsContainer = connect ( mapStateToProps , null ) ( Documents ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $DocumentsProps$ O $RootState$ O $DocumentsProps$ O O O O $complex$ O O $RootState$ O $EditorState<any>$ O O O O $any$ O $string$ O $complex$ O $any$ O $any$ O O $string$ O $complex$ O $complex$ O $any$ O $any$ O O $complex$ O $string[]$ O $complex$ O $any$ O $any$ O O $string[]$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O
export * from 's' ;	O O O O O
import { connect } from 's' ; import { RootState } from 's' ; import { MDIComponent } from 's' ; export interface MDIProps { owningEditor ? : string ; presentationModeEnabled ? : boolean ; } const mapStateToProps = ( state , ownProps ) : MDIProps => ( { ... ownProps , presentationModeEnabled : state . presentation . enabled , } ) ; export const MDI = connect ( mapStateToProps , null ) ( MDIComponent ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O $boolean$ O O O O O O $MDIProps$ O O $RootState$ O $MDIProps$ O O $any$ O O O O $MDIProps$ O $boolean$ O $RootState$ O $PresentationState$ O $boolean$ O O O O O O $any$ O $any$ O $MDIProps$ O O O O $any$ O O
import { connect } from 's' ; import { swapTabs , toggleDraggingTab } from 's' ; import { Tab , TabProps } from 's' ; const mapDispatchToProps = ( dispatch , ownProps ) : TabProps => ( { toggleDraggingTab : ( toggle ) => dispatch ( toggleDraggingTab ( toggle ) ) , swapTabs : ( editorKey , owningEditor , tabId ) => dispatch ( swapTabs ( editorKey , owningEditor , tabId , ownProps . documentId ) ) , } ) ; export const TabContainer = connect ( null , mapDispatchToProps ) ( Tab ) ;	O O $any$ O O O O O O $SwapTabsAction$ O $ToggleDraggingTabAction$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $TabProps$ O O $any$ O O O $any$ O O $boolean$ O O $any$ O $ToggleDraggingTabAction$ O $boolean$ O O O $any$ O O $string$ O $string$ O $string$ O O $any$ O $SwapTabsAction$ O $string$ O $string$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O
export * from 's' ;	O O O O O
import { connect } from 's' ; import { SharedConstants } from 's' ; import { closeConversation } from 's' ; import { appendTab , close , setActiveTab , splitTab } from 's' ; import { enable as enablePresentationMode } from 's' ; import { getTabGroupForDocument } from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { TabBar , TabBarProps } from 's' ; const mapStateToProps = ( state , ownProps ) : TabBarProps => ( { ... ownProps , activeBot : state . bot . activeBot , activeDocumentId : state . editor . editors [ ownProps . owningEditor ] . activeDocumentId , activeEditor : state . editor . activeEditor , chats : state . chat . chats , editors : state . editor . editors , documents : state . editor . editors [ ownProps . owningEditor ] . documents , tabOrder : state . editor . editors [ ownProps . owningEditor ] . tabOrder , } ) ; const mapDispatchToProps = ( dispatch ) : TabBarProps => ( { splitTab : ( contentType , documentId , srcEditorKey , destEditorKey ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , 's' ) ) ; dispatch ( splitTab ( contentType , documentId , srcEditorKey , destEditorKey ) ) ; } , appendTab : ( srcEditorKey , destEditorKey , tabId ) => dispatch ( appendTab ( srcEditorKey , destEditorKey , tabId ) ) , enablePresentationMode : async ( ) => { dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , 's' ) ) ; dispatch ( enablePresentationMode ( ) ) ; } , setActiveTab : ( documentId ) => dispatch ( setActiveTab ( documentId ) ) , closeTab : ( documentId ) => { dispatch ( close ( getTabGroupForDocument ( documentId ) , documentId ) ) ; dispatch ( closeConversation ( documentId ) ) ; } , } ) ; export const TabBarContainer = connect ( mapStateToProps , mapDispatchToProps ) ( TabBar ) ;	O O $any$ O O O O O O $any$ O O O O O O $ChatAction<DocumentIdPayload>$ O O O O O O $AppendTabAction$ O $CloseEditorAction$ O $SetActiveTabAction$ O $SplitTabAction$ O O O O O O $PresentationAction$ O $PresentationAction$ O O O O O O $string$ O O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O $TabBarProps$ O O $any$ O O O O $any$ O $any$ O $RootState$ O $BotState$ O $any$ O $string$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O $string$ O $string$ O $RootState$ O $EditorState<any>$ O $string$ O $complex$ O $RootState$ O $ChatState$ O $complex$ O $complex$ O $RootState$ O $EditorState<any>$ O $complex$ O $complex$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O $complex$ O $string[]$ O $RootState$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O $string[]$ O O O O O $any$ O O $any$ O O $any$ O O O $void$ O O $string$ O $string$ O $string$ O $string$ O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $SplitTabAction$ O $string$ O $string$ O $string$ O $string$ O O O O O $any$ O O $string$ O $string$ O $string$ O O $any$ O $AppendTabAction$ O $string$ O $string$ O $string$ O O O $Promise<void>$ O O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $PresentationAction$ O O O O O O $any$ O O $string$ O O $any$ O $SetActiveTabAction$ O $string$ O O O $void$ O O $string$ O O O $any$ O $CloseEditorAction$ O $string$ O $string$ O O $string$ O O O $any$ O $ChatAction<DocumentIdPayload>$ O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
export { MDI } from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O
import { connect } from 's' ; import { SharedConstants } from 's' ; import * as Constants from 's' ; import * as EditorActions from 's' ; import * as ExplorerActions from 's' ; import * as NavBarActions from 's' ; import { RootState } from 's' ; import { executeCommand } from 's' ; import { NavBarComponent , NavBarProps } from 's' ; const mapStateToProps = ( state ) : NavBarProps => ( { notifications : state . notification . allIds , botIsOpen : ! ! state . bot . activeBot , } ) ; const mapDispatchToProps = ( dispatch ) : NavBarProps => ( { showExplorer => dispatch ( ExplorerActions . showExplorer ( show ) ) , navBarSelectionChanged => dispatch ( NavBarActions . select ( newSelection ) ) , openEmulatorSettings : ( ) => { const { CONTENT_TYPE_APP_SETTINGS , DOCUMENT_ID_APP_SETTINGS } = Constants ; dispatch ( EditorActions . open ( { contentType : CONTENT_TYPE_APP_SETTINGS , documentId : DOCUMENT_ID_APP_SETTINGS , isGlobal : true , meta : null , } ) ) ; } , trackEvent : ( name , properties ? : { [ key ] : any } ) => dispatch ( executeCommand ( true , SharedConstants . Commands . Telemetry . TrackEvent , null , name , properties ) ) , } ) ; export const NavBar = connect ( mapStateToProps , mapDispatchToProps ) ( NavBarComponent ) ;	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O $any$ O O O O O $any$ O O $RootState$ O O $any$ O O O $string[]$ O $RootState$ O $NotificationState$ O $string[]$ O $boolean$ O O O $RootState$ O $BotState$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O $show$ O $any$ O $any$ O $ExplorerAction<ExplorerPayload>$ O $any$ O O O $newSelection$ O $any$ O $any$ O $SelectNavBarAction$ O $any$ O O O $void$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $string$ O O O $string$ O O O $true$ O O O $null$ O O O O O O O O O $any$ O O $string$ O $complex$ O O O O $string$ O O O O O O $any$ O $CommandAction<CommandActionPayload>$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
export * from 's' ;	O O O O O
import BFIcon from 's' ; export { BFIcon } ;	O $any$ O O O O O $any$ O O
import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { globalHandlers } from 's' ; const { Commands : { Electron : { ToggleDevTools } , Notifications , UI : { ShowBotCreationDialog , ShowOpenBotDialog } , } , } = SharedConstants ; let mockLocalCommandsCalled = [ ] ; let mockRemoteCommandsCalled = [ ] ; const mockCurrentWebContents = { setZoomLevel : jest . fn ( ) , getZoomFactor : jest . fn ( ) , setZoomFactor : jest . fn ( ) , } ; const mockCurrentWindow = { isFullScreen : ( ) => false , setFullScreen : jest . fn ( ) , } ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , remote : { getCurrentWebContents : ( ) => mockCurrentWebContents , getCurrentWindow : ( ) => mockCurrentWindow , } , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . call = ( commandName , ... args : any [ ] ) => { mockLocalCommandsCalled . push ( { commandName , args : args } ) ; return true as any ; } ; commandService . remoteCall = ( commandName , ... args : any [ ] ) => { mockRemoteCommandsCalled . push ( { commandName , args : args } ) ; return true as any ; } ; } ) ; beforeEach ( ( ) => { mockLocalCommandsCalled = [ ] ; mockRemoteCommandsCalled = [ ] ; } ) ; afterAll ( ( ) => { jest . restoreAllMocks ( ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { metaKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockLocalCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toBe ( ShowOpenBotDialog ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockLocalCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toBe ( ShowOpenBotDialog ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { metaKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockLocalCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toBe ( ShowBotCreationDialog ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockLocalCommandsCalled . length ) . toBe ( 0 ) ; expect ( mockLocalCommandsCalled [ 0 ] . commandName ) . toBe ( ShowBotCreationDialog ) ; } ) ; it ( "s" , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockLocalCommandsCalled . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; const spy = jest . spyOn ( commandService , 's' ) . mockRejectedValueOnce ( 's' ) ; await globalHandlers ( event ) ; expect ( spy ) . toHaveBeenLastCalledWith ( Notifications . Add , { message : 's' , type : 0 , } ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomLevel ) . toHaveBeenCalledWith ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , key : 's' } ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; mockCurrentWebContents . setZoomFactor . mockClear ( ) ; mockCurrentWebContents . getZoomFactor . mockImplementation ( callback => callback ( 0 ) ) ; await globalHandlers ( event ) ; expect ( mockCurrentWebContents . setZoomFactor ) . toHaveBeenCalledWith ( 0 ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockCurrentWindow . setFullScreen ) . toHaveBeenCalledWith ( ! mockCurrentWindow . isFullScreen ( ) ) ; } ) ; it ( 's' , async ( ) => { const event = new KeyboardEvent ( 's' , { ctrlKey : true , shiftKey : true , key : 's' } ) ; await globalHandlers ( event ) ; expect ( mockRemoteCommandsCalled ) . toHaveLength ( 0 ) ; expect ( mockRemoteCommandsCalled [ 0 ] . commandName ) . toBe ( ToggleDevTools ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $Promise<any>$ O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any[]$ O O O O O $any[]$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O O O O O O $any$ O $any$ O O $string$ O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O $any[]$ O $any[]$ O O O O O O O O O O O O O $any$ O O O O O $any[]$ O O O O $any[]$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $string$ O O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O $complex$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $complex$ O $any$ O O $any$ O O $complex$ O $boolean$ O O O O O O O $any$ O O O O O O O O O $KeyboardEvent$ O O $complex$ O O O O $true$ O O O $true$ O O O $string$ O O O O O O $Promise<any>$ O $KeyboardEvent$ O O $any$ O $any[]$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O O O O
import { expandFlatTree } from 's' ; test ( 's' , ( ) => { const actual = expandFlatTree ( [ 's' , 's' , 's' , 's' , 's' ] ) ; expect ( actual ) . toEqual ( { 's' : 's' , abc : { def : { 's' : 's' , } , ghi : { 's' : 's' , } , 's' : 's' , } , 's' : 's' , } ) ; } ) ;	O O ${}$ O O O O $any$ O O O O O O O O ${}$ O ${}$ O O O O O O O O O O O O O O $any$ O ${}$ O O $any$ O O O O O O $complex$ O O $complex$ O O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) ; const CopyWebpackPlugin = require ( 's' ) ; const UglifyJsPlugin = require ( 's' ) ; const webpack = require ( 's' ) ; const { DllPlugin , DllReferencePlugin , NamedModulesPlugin , DefinePlugin , WatchIgnorePlugin } = webpack ; const { npm_lifecycle_event = 's' } = process . env ; const manifestLocation = path . resolve ( 's' ) ; const use = [ { loader : 's' , } , ] ; const defaultConfig = { entry : { index : require . resolve ( 's' ) , } , target : 's' , stats : { warnings : false , } , module : { rules : [ { test : "s" , exclude : [ "s" ] , use : { loader : 's' , options : { ignore : [ 's' ] , } , } , } , { test : "s" , use : [ 's' , 's' , 's' ] , } , { test : "s" , use : [ { loader : 's' , options : { limit : 0 , } , } , ] , } , { test : "s" , use : [ 's' , { loader : 's' , options : { localIdentName : 's' , modules : true , sass : false , namedExport : true , camelCase : true , sourcemaps : true , banner : 's' , } , } , 's' , 's' , ] , } , ] , } , devtool : 's' , devServer : { hot : true , inline : true , port : 0 , historyApiFallback : false , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' ] , } , output : { path : path . resolve ( 's' ) , filename : 's' , publicPath : 's' , } , plugins : [ new NamedModulesPlugin ( ) , new CopyWebpackPlugin ( [ { from : 's' , to : 's' } , { from : 's' , to : 's' } , { from : 's' , to : 's' } , { from : 's' , to : 's' } , { from : 's' , to : 's' , } , { from : 's' , to : 's' } , { from : 's' , to : 's' } , { from : 's' , to : 's' } , ] ) , new DefinePlugin ( { DEV : JSON . stringify ( npm_lifecycle_event . includes ( 's' ) ) , } ) , new WatchIgnorePlugin ( [ 's' ] ) , ] , } ; const buildConfig = mode => { const config = { ... defaultConfig , plugins : [ ... defaultConfig . plugins , new DllReferencePlugin ( { manifest : require ( path . join ( manifestLocation , 's' ) ) , } ) , new DllReferencePlugin ( { manifest : require ( path . join ( manifestLocation , 's' ) ) , } ) , ] , } ; if ( mode === 's' ) { config . module . rules [ 0 ] . use = use ; } else { config . optimization = { minimizer : [ new UglifyJsPlugin ( { cache : true , cacheKeys ( defaultCacheKeys ) { delete defaultCacheKeys [ 's' ] ; return Object . assign ( { } , defaultCacheKeys , { 's' : require ( 's' ) . version } ) ; } , minify ( file , sourceMap ) { const uglifyJsOptions = { } ; if ( sourceMap ) { uglifyJsOptions . sourceMap = { content : sourceMap , } ; } return require ( 's' ) . minify ( file , uglifyJsOptions ) ; } , } ) , ] , } ; } return config ; } ; const sharedConfig = ( ) => ( { ... defaultConfig , entry : { shared : [ path . resolve ( 's' ) ] , } , output : { ... defaultConfig . output , library : 's' , } , node : { fs : 's' , } , plugins : [ ... defaultConfig . plugins , new DllPlugin ( { path : path . join ( manifestLocation , 's' ) , name : 's' , } ) , new DllReferencePlugin ( { manifest : require ( path . join ( manifestLocation , 's' ) ) , } ) , ] , } ) ; const vendorsConfig = ( ) => ( { ... defaultConfig , entry : { vendors : [ path . resolve ( 's' ) ] , } , output : { ... defaultConfig . output , library : 's' , } , plugins : [ ... defaultConfig . plugins , new DllPlugin ( { path : path . join ( manifestLocation , 's' ) , name : 's' , } ) , ] , } ) ; const buildClassification = npm_lifecycle_event . split ( 's' ) [ 0 ] ; module . exports = function ( env , argv ) { switch ( buildClassification ) { case 's' : return vendorsConfig ( ) ; case 's' : return sharedConfig ( ) ; default : return buildConfig ( argv . mode ) ; } } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $complex$ O O O $string$ O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $complex$ O O $boolean$ O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $RegExp[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O $RegExp$ O O O $string[]$ O O O O O O O O O O O O $RegExp$ O O O $complex$ O O O $string$ O O O $complex$ O O $number$ O O O O O O O O O O O O $RegExp$ O O O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any[]$ O O O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O $any$ O O $string$ O $JSON$ O $complex$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O O O $complex$ O $any$ O O O $complex$ O O O O O $any[]$ O O O O O $any[]$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O $complex$ O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O $complex$ O $any$ O O $any[]$ O O O $any$ O O $boolean$ O O O $any$ O $any$ O O O $any$ O O O O O $ObjectConstructor$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $complex$ O O O O O O $any$ O O $complex$ O $complex$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $complex$ O O O O O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O O O $complex$ O O $any[]$ O O $any$ O $any$ O O O O O O O $complex$ O O O O O $complex$ O $string$ O O O O O $complex$ O O $string$ O O O O O $any[]$ O O O O O $any[]$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $complex$ O O O O O O O O O $complex$ O O $any[]$ O O $any$ O $any$ O O O O O O O $complex$ O O O O O $complex$ O $string$ O O O O O $any[]$ O O O O O $any[]$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O O O $any$ O $any$ O O O O $any$ O O O O O O $complex$ O O O O O O O $complex$ O O O O O O $complex$ O $any$ O $any$ O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import { join } from 's' ; export const electronPath = process . platform === 's' ? join ( __dirname , 's' , 's' , 's' , 's' ) : join ( __dirname , 's' , 's' , 's' , 's' ) ; export const appPath = join ( __dirname , 's' , 's' , 's' , 's' ) ; export const chromeDriverLogPath = join ( __dirname , 's' ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O
import { join } from 's' ; import { Application } from 's' ; type ElectronDialogMethod = | 's' | 's' | 's' | 's' | 's' ; export function init ( app : Application & { args ? : string [ ] } ) { if ( app . args && app . args . length ) { app . args . unshift ( join ( __dirname , 's' ) ) ; app . args . unshift ( 's' ) ; } } export function setupMock ( app , options : { method : ElectronDialogMethod ; value : any } ) < any > { if ( app ) { return app . electron . ipcRenderer . sendSync ( 's' , options ) ; } }	O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O $void$ O $any$ O $any$ O O $string[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $Promise$ O $Application$ O $complex$ O O $ElectronDialogMethod$ O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O O
import { existsSync , unlinkSync } from 's' ; import { join } from 's' ; import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; import { init , setupMock } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; init ( app ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { const ctaLinks = await app . client . $$ ( 's' ) ; const createBotLink = ctaLinks [ 0 ] ; await app . client . elementIdClick ( createBotLink . ELEMENT ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . setValue ( 's' , 's' ) ; const tempPath = await app . electron . remote . app . getPath ( 's' ) ; const testBotPath = join ( tempPath , 's' ) ; await setupMock ( app , { method : 's' , value : testBotPath } ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; expect ( existsSync ( testBotPath ) ) . toBe ( true ) ; unlinkSync ( testBotPath ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $Promise<any>$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O
import { existsSync , unlinkSync } from 's' ; import { join } from 's' ; import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; import { init , setupMock } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; init ( app ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { const transcriptPath = join ( __dirname , 's' ) ; await setupMock ( app , { method : 's' , value : transcriptPath } ) ; await app . client . click ( 's' ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; await app . client . setValue ( 's' , "s" ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; expect ( existsSync ( transcriptPath ) ) . toBe ( true ) ; unlinkSync ( transcriptPath ) ; } ) ; it ( 's' , async ( ) => { const testBotDir = join ( __dirname , 's' , 's' , 's' , 's' , 's' ) ; await setupMock ( app , { method : 's' , value : [ testBotDir ] } ) ; await app . client . click ( 's' ) ; const botFilePath = join ( __dirname , 's' , 's' , 's' , 's' , 's' , 's' ) ; await app . client . setValue ( 's' , botFilePath ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; const disabled = await app . client . getAttribute ( 's' , 's' ) ; if ( disabled === 's' ) { await app . client . click ( 's' ) ; } else { await app . client . click ( 's' ) ; } await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; const msgBubbles = await app . client . $$ ( 's' ) ; expect ( msgBubbles . length ) . toBe ( 0 ) ; const 0 = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; expect ( 0 . value ) . toBe ( 's' ) ; const 0 = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; expect ( 0 . value ) . toBe ( 's' ) ; const 0 = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; expect ( 0 . value ) . toBe ( 's' ) ; const 0 = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; expect ( 0 . value ) . toBe ( 's' ) ; const 0 = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; expect ( 0 . value ) . toBe ( "s" ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $Promise<any>$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $Promise<any>$ O $any$ O O O O O O $any[]$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; await app . client . windowByIndex ( 0 ) ; let treeNodes = await app . client . $$ ( 's' ) ; expect ( treeNodes . length ) . toBeGreaterThan ( 0 ) ; await app . client . windowByIndex ( 0 ) ; const networkReqItems = await app . client . $$ ( 's' ) ; await app . client . elementIdClick ( networkReqItems [ 0 ] . ELEMENT ) ; await app . client . pause ( 0 ) ; await app . client . windowByIndex ( 0 ) ; treeNodes = await app . client . $$ ( 's' ) ; expect ( treeNodes . length ) . toBeGreaterThan ( 0 ) ; await app . client . windowByIndex ( 0 ) ; const networkResItems = await app . client . $$ ( 's' ) ; await app . client . elementIdClick ( networkResItems [ 0 ] . ELEMENT ) ; await app . client . pause ( 0 ) ; await app . client . windowByIndex ( 0 ) ; treeNodes = await app . client . $$ ( 's' ) ; expect ( treeNodes . length ) . toBeGreaterThan ( 0 ) ; } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; await app . client . windowByIndex ( 0 ) ; const treeNodes = await app . client . $$ ( 's' ) ; expect ( treeNodes . length ) . toBeGreaterThan ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
'js' const { dialog , ipcMain } = require ( 's' ) ; function mockDialogFunction ( options ) { if ( options . method && options . value ) { dialog [ options . method ] = function ( ) { return options . value ; } ; } else { throw new Error ( 's' ) ; } } ipcMain . on ( 's' , ( e , options ) => { mockDialogFunction ( options ) ; e . returnValue = true ; } ) ;	O O O $any$ O $any$ O O $any$ O O O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O O O O O
import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; import { init } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; init ( app ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { await app . client . waitForExist ( 's' ) ; await app . client . keys ( [ 's' , 's' ] ) ; await app . client . click ( 's' ) ; expect ( await app . client . hasFocus ( "s" ) ) . toBeTruthy ( ) ; await app . client . keys ( [ 's' , 's' , 's' ] ) ; expect ( await app . client . hasFocus ( 's' ) ) . toBeTruthy ( ) ; await app . client . keys ( [ 's' , 's' ] ) ; expect ( await app . client . hasFocus ( "s" ) ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O
import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { const count = await app . client . getWindowCount ( ) ; expect ( count ) . toBe ( 0 ) ; expect ( await app . browserWindow . getTitle ( ) ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { join } from 's' ; import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; describe ( 's' , ( ) => { let app ; const botFilePath = join ( __dirname , 's' , 's' , 's' , 's' , 's' , 's' ) ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; await app . client . setValue ( 's' , botFilePath ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; const welcomeMsgBubble = await app . client . $ ( 's' ) ; const welcomeMsgText = await app . client . elementIdText ( welcomeMsgBubble . value . ELEMENT ) ; expect ( welcomeMsgText . value ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; const checked = await app . client . getAttribute ( 's' , 's' ) ; if ( checked === 's' ) { await app . client . click ( 's' ) ; } const customUserId = 's' ; await app . client . setValue ( 's' , customUserId ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . setValue ( 's' , botFilePath ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; let msgBubbles = await app . client . $$ ( 's' ) ; let msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const initialUserId = msgBubble . value ; expect ( initialUserId ) . toBe ( customUserId ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; msgBubbles = await app . client . $$ ( 's' ) ; msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const userIdAfterRestartingWithSame = msgBubble . value ; expect ( userIdAfterRestartingWithSame ) . toBe ( initialUserId ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; msgBubbles = await app . client . $$ ( 's' ) ; msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const newUserId = msgBubble . value ; expect ( newUserId ) . not . toBe ( initialUserId ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Application$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O
import { Application } from 's' ; import { appPath , chromeDriverLogPath , electronPath } from 's' ; describe ( 's' , ( ) => { let app ; beforeEach ( async ( ) => { jest . setTimeout ( 0 ) ; app = new Application ( { path : electronPath , args : [ appPath ] , chromeDriverLogPath , } ) ; await app . start ( ) ; } ) ; afterEach ( async ( ) => { if ( app && app . isRunning ( ) ) { await app . stop ( ) ; } } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' ) ; const welcomeMsgBubble = await app . client . $ ( 's' ) ; const welcomeMsgText = await app . client . elementIdText ( welcomeMsgBubble . value . ELEMENT ) ; expect ( welcomeMsgText . value ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { await app . client . click ( 's' ) ; const checked = await app . client . getAttribute ( 's' , 's' ) ; if ( checked === 's' ) { await app . client . click ( 's' ) ; } const customUserId = 's' ; await app . client . setValue ( 's' , customUserId ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; let msgBubbles = await app . client . $$ ( 's' ) ; let msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const initialUserId = msgBubble . value ; expect ( initialUserId ) . toBe ( customUserId ) ; await app . client . click ( 's' ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; msgBubbles = await app . client . $$ ( 's' ) ; msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const userIdAfterRestartingWithSame = msgBubble . value ; expect ( userIdAfterRestartingWithSame ) . toBe ( initialUserId ) ; await app . client . click ( 's' ) ; await app . client . waitForExist ( 's' , 0 ) ; await app . client . setValue ( 's' , 's' ) ; await app . client . click ( 's' ) ; await app . client . pause ( 0 ) ; msgBubbles = await app . client . $$ ( 's' ) ; msgBubble = await app . client . elementIdText ( msgBubbles [ 0 ] . ELEMENT ) ; const newUserId = msgBubble . value ; expect ( newUserId ) . not . toBe ( initialUserId ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Application$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any[]$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O
'js' function hashFileAsync ( filename , algo = 's' , encoding = 's' ) { var builderUtil = require ( 's' ) ; return builderUtil . hashFile ( filename , algo , encoding ) ; } module . exports = { hashFileAsync } ;	O O $any$ O $any$ O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O $complex$ O $complex$ O O $any$ O O
'js' writeLatestYmlFile ( ) . catch ( e => console . error ( e ) ) ; async function writeLatestYmlFile ( ) { const common = require ( 's' ) ; const packageJson = require ( 's' ) ; const path = require ( 's' ) ; const { hashFileAsync } = common ; const version = process . env . EMU_VERSION || packageJson . version ; const releaseFileNameBase = `template` ; const releaseFileName = `template` ; const 0 = await hashFileAsync ( path . normalize ( `template` ) ) ; const releaseDate = new Date ( ) . toISOString ( ) ; performWrite ( releaseFileName , 's' , 0 , releaseDate , version ) ; } function performWrite ( releaseFilename , yamlFilename , fileHash , releaseDate , version ) { const fsp = require ( 's' ) ; const yaml = require ( 's' ) ; const path = require ( 's' ) ; const ymlInfo = { version , releaseDate , githubArtifactName : releaseFilename , path : releaseFilename , 0 : fileHash , } ; const ymlStr = yaml . safeDump ( ymlInfo ) ; fsp . writeFileSync ( path . normalize ( `template` ) , ymlStr ) ; }	O $Promise<void>$ O O O $complex$ O $any$ O $Console$ O $void$ O $any$ O O O O O $Promise<void>$ O O O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O $string$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O $DateConstructor$ O O O $string$ O O O $void$ O $string$ O O O $any$ O $string$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O
'js' writeLatestYmlFile ( ) . catch ( e => console . error ( e ) ) ; async function writeLatestYmlFile ( ) { const common = require ( 's' ) ; const packageJson = require ( 's' ) ; const path = require ( 's' ) ; const fsp = require ( 's' ) ; const yaml = require ( 's' ) ; const { hashFileAsync } = common ; const version = process . env . EMU_VERSION || packageJson . version ; const releaseFileName = `template` ; const 0 = await hashFileAsync ( path . normalize ( `template` ) ) ; const releaseDate = new Date ( ) . toISOString ( ) ; const ymlInfo = { version , releaseDate , githubArtifactName : releaseFileName , path : releaseFileName , 0 , } ; const ymlStr = yaml . safeDump ( ymlInfo ) ; fsp . writeFileSync ( path . normalize ( `template` ) , ymlStr ) ; }	O $Promise<void>$ O O O $complex$ O $any$ O $Console$ O $void$ O $any$ O O O O O $Promise<void>$ O O O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O $DateConstructor$ O O O $string$ O O O O O O O $any$ O $string$ O $string$ O $string$ O $string$ O $string$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O
'js' writeLatestYmlFile ( ) . catch ( e => console . error ( e ) ) ; async function writeLatestYmlFile ( ) { const common = require ( 's' ) ; const packageJson = require ( 's' ) ; const fsp = require ( 's' ) ; const yaml = require ( 's' ) ; const path = require ( 's' ) ; const { hashFileAsync } = common ; const version = process . env . EMU_VERSION || packageJson . version ; const releaseFilename = `template` ; const 0 = await hashFileAsync ( path . normalize ( `template` ) ) ; const 0 = await hashFileAsync ( path . normalize ( `template` ) , 's' , 's' ) ; const releaseDate = new Date ( ) . toISOString ( ) ; const ymlInfo = { version , releaseDate , githubArtifactName : releaseFilename , path : releaseFilename , 0 , 0 } ; const ymlStr = yaml . safeDump ( ymlInfo ) ; fsp . writeFileSync ( path . normalize ( `template` ) , ymlStr ) ; } ;	O $Promise<void>$ O O O $complex$ O $any$ O $Console$ O $void$ O $any$ O O O O O $Promise<void>$ O O O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O $string$ O O $DateConstructor$ O O O $string$ O O O O O O O $any$ O $string$ O $string$ O $string$ O $string$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O
export function getErrorText ( err ) { if ( err ) { if ( err . error ) { return err . error ; } else if ( err . message ) { return err . message ; } else { return err . toString ( ) ; } } return undefined ; }	O O $string$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $undefined$ O O
import { BotInfo } from 's' ; export const botListsAreDifferent = ( 0 : BotInfo [ ] , 0 : BotInfo [ ] ) : boolean => { if ( 0 . length !== 0 . length ) { return true ; } for ( let i = 0 ; i < 0 . length ; i ++ ) { const 0 = 0 [ i ] ; const 0 = 0 [ i ] ; if ( 0 . displayName !== 0 . displayName || 0 . path !== 0 . path || 0 . chatsPath !== 0 . chatsPath || 0 . transcriptsPath !== 0 . transcriptsPath ) { return true ; } } return false ; } ;	O O $any$ O O O O O O O O O $any[]$ O $any$ O O O $any[]$ O $any$ O O O O O O O O O $any[]$ O $number$ O $any[]$ O $number$ O O O O O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O O O O $any$ O $any[]$ O $number$ O O O $any$ O $any[]$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O
const remote : Electron . Remote = ( typeof window === 's' ? require ( 's' ) : ( window as any ) . require ( 's' ) ) . remote ; export function getGlobal ( attributeName , defaultValue ? ) { if ( global [ attributeName ] ) { return global [ attributeName ] ; } else if ( remote && remote . getGlobal ( attributeName ) ) { return remote . getGlobal ( attributeName ) ; } else { return defaultValue ; } } export function setGlobal ( attributeName , value ) { global [ attributeName ] = value ; } export function deleteGlobal ( attributeName ) { delete global [ attributeName ] ; }	O $any$ O $any$ O $any$ O O O $complex$ O O O $any$ O O O O O $complex$ O O O O $any$ O O O O O $any$ O O O $any$ O $string$ O $any$ $any$ O O O O $any$ O $string$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O $void$ O $string$ O $any$ O O $any$ O $string$ O O $any$ O O O O $void$ O $string$ O O O $any$ O $string$ O O O
import * as path from 's' ; import * as electron from 's' ; import * as mkdirp from 's' ; import * as globals from 's' ; const electronApp : Electron . App = electron . app ; const electronRemote : Electron . Remote = electron . remote ; export const ensureStoragePath = ( ) : string => { const commandLineArgs = globals . getGlobal ( 's' , { } ) ; const app = electronApp || electronRemote . app ; const storagePath = commandLineArgs . storagepath || path . join ( app . getPath ( 's' ) , 's' ) ; mkdirp . sync ( storagePath ) ; return storagePath ; } ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O
import { APIException , createErrorResponse , ErrorCodes } from 's' ; import * as HttpStatus from 's' ; export const exceptionToAPIException = ( exception ) : APIException => { if ( exception . error && exception . statusCode ) { return exception ; } return { error : createErrorResponse ( ErrorCodes . ServiceError , exception . message ) , statusCode : HttpStatus . BAD_REQUEST , } ; } ;	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O
import * as readTextFile from 's' ; export const readFileSync = ( path ) : string => { try { return readTextFile . readSync ( path ) ; } catch ( e ) { console . error ( `template` ) ; return 's' ; } } ;	O O O $any$ O O O O O $string$ O O $string$ O O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O O $Console$ O $void$ O O O O O O O O O O
import { join } from 's' ; import { BotInfo } from 's' ; import { ensureStoragePath } from 's' ; import { readFileSync } from 's' ; export const getBotsFromDisk = ( ) : BotInfo [ ] => { const botsJsonPath = join ( ensureStoragePath ( ) , 's' ) ; try { const botsJsonContents = readFileSync ( botsJsonPath ) ; const botsJson = botsJsonContents ? JSON . parse ( botsJsonContents ) : null ; if ( botsJson && botsJson . bots && Array . isArray ( botsJson . bots ) ) { return botsJson . bots . map ( bot => { delete bot . secret ; return bot ; } ) ; } else { return [ ] ; } } catch ( e ) { return [ ] ; } } ;	O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $string$ O O O O O O $any[]$ O O O O $any$ O O O O O $any$ O $any$ O $string$ O O O O O O O O O $string$ O $string$ O $any$ O O O $any$ O $string$ O $JSON$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $ArrayConstructor$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O
import { lstatSync , readdirSync } from 's' ; import { join } from 's' ; export const getDirectories = source => readdirSync ( source ) . map ( name => join ( source , name ) ) . filter ( ( sourceArg ) => lstatSync ( sourceArg ) . isDirectory ( ) ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O
import * as Fs from 's' ; export const getFilesInDir = ( path ) => { return Fs . readdirSync ( path , 's' ) ; } ;	O O O $any$ O O O O O $any$ O O $string$ O O O O $any$ O $any$ O $string$ O O O O O O
export const getSafeBotName = ( ) : string => 's' ;	O O $string$ O O O O O O O O
export const isDev = ( ) : boolean => { return process . defaultApp || "s" . test ( process . execPath ) ; } ;	O O $boolean$ O O O O O O O O $any$ O $any$ O O O $boolean$ O $any$ O $any$ O O O O
import { Activity } from 's' ; interface CustomActivityProperties { from : { role ? : string ; } ; recipient ? : { id ? : string ; role ? : string ; } ; } export type CustomActivity = Activity & CustomActivityProperties ; export function cleanupId ( activities : CustomActivity [ ] , botId = findIdWithRole ( activities , 's' ) , userId = findIdWithRole ( activities , 's' ) ) { const roleIdMap = { bot : botId , user : userId } ; activities = activities . map ( ( activity ) => { const { type } = activity ; if ( type === 's' || type === 's' || type === 's' || type === 's' ) { activity = { ... activity , from : { ... activity . from , id : roleIdMap [ activity . from . role ] || activity . from . id , } , recipient : { ... activity . recipient , id : roleIdMap [ activity . recipient . role ] || activity . recipient . id , } , } ; } return activity ; } ) ; return activities ; } export function findIdWithRole ( activities : CustomActivity [ ] , role ) { return activities . reduce ( ( id , { recipient } ) => { if ( id ) { return id ; } else if ( recipient && recipient . role === role ) { return recipient . id ; } else { return null ; } } , null ) ; } export const __TESTABLES = { findIdWithRole } ;	O O $any$ O O O O O $any$ O $complex$ O O $string$ O O O O O O $complex$ O O O $string$ O O O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any[]$ O $any$ O O O $string$ O $string$ O $any[]$ O O O O $string$ O $string$ O $any[]$ O O O O O O $complex$ O O $string$ O $string$ O $string$ O $string$ O O $any[]$ O $any[]$ O $U[]$ O O $any$ O O O O O $any$ O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any[]$ O O O O $string$ O $any[]$ O $any$ O O O $string$ O O O $any[]$ O $complex$ O O $string$ O O $any$ O O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O O O O O O O O O O O O O $complex$ O O $string$ O O
import * as path from 's' ; import { CustomActivity } from 's' ; const { fork } = require ( 's' ) ; const chatdown = require . resolve ( 's' ) ; export const parseActivitiesFromChatFile = async ( file ) : Promise < CustomActivity [ ] > => { let activities : CustomActivity [ ] = [ ] ; if ( path . extname ( file ) !== 's' ) { throw new Error ( 's' ) ; } try { activities = ( await new Promise ( ( resolve , reject ) => { const childProcess = fork ( chatdown , [ file ] , { cwd : path . dirname ( file ) , silent : true , } ) ; let str = 's' ; childProcess . stdout . on ( 's' , ( data ) => { str += data . toString ( ) ; } ) ; childProcess . stdout . on ( 's' , ( ) => { resolve ( JSON . parse ( str ) ) ; } ) ; childProcess . stdout . on ( 's' , err => { reject ( err ) ; } ) ; } ) ) as CustomActivity [ ] ; } catch ( err ) { throw new Error ( `template` ) ; } return activities ; } ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $Promise<any[]>$ O O O $string$ O O $PromiseConstructor$ O $any$ O O O O O O $any[]$ O $any$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O O $ErrorConstructor$ O O O O O O O $any[]$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O $string$ O O O $any$ O $any$ O $any$ O O O O $Uint8Array$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $void$ O $JSON$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any$ O O O O O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any[]$ O O O
export function isMac ( ) { return process . platform === 's' ; }	O O $boolean$ O O O O $any$ O $any$ O O O O
import * as fs from 's' ; import { ensureStoragePath } from 's' ; export const saveSettings = < T > ( filename , settings : T ) : void => { try { filename = `template` ; fs . writeFileSync ( filename , JSON . stringify ( settings , null , 0 ) , { encoding : 's' , } ) ; } catch ( e ) { console . error ( `template` , e ) ; } } ;	O O O $any$ O O O O O $string$ O O O O O O $void$ O O $any$ O O $string$ O $T$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $string$ O $JSON$ O $complex$ O $T$ O O O O O O O $string$ O O O O O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O
import { ErrorResponse } from 's' ; import * as Restify from 's' ; import { exceptionToAPIException } from 's' ; export const sendErrorResponse = ( req : Restify . Request , res : Restify . Response , next : Restify . Next , exception ) : ErrorResponse => { const apiException = exceptionToAPIException ( exception ) ; res . send ( apiException . statusCode , apiException . error ) ; res . end ( ) ; return apiException . error ; } ;	O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O
import { BrowserWindow , dialog , OpenDialogOptions } from 's' ; export const showOpenDialog = ( window , options ) : false | string => { const filePaths = dialog . showOpenDialog ( window , options ) ; return filePaths && filePaths [ 0 ] ; } ;	O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $BrowserWindow$ O $OpenDialogOptions$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O
import { BrowserWindow , dialog , SaveDialogOptions } from 's' ; export const showSaveDialog = ( window , options ) : string => { return dialog . showSaveDialog ( window , options ) ; } ;	O O $any$ O $any$ O $any$ O O O O O O $string$ O O $BrowserWindow$ O $SaveDialogOptions$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O
import * as fs from 's' ; import * as path from 's' ; import * as mkdirp from 's' ; export const writeFile = ( filePath , contents : object | string ) : void => { try { const contentsToWrite = typeof contents === 's' ? JSON . stringify ( contents , null , 0 ) : contents ; mkdirp . sync ( path . dirname ( filePath ) ) ; fs . writeFileSync ( filePath , contentsToWrite , { encoding : 's' } ) ; } catch ( e ) { console . error ( `template` , e ) ; } } ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $void$ O O $string$ O $complex$ O O O O O O O O O O O O $string$ O O $complex$ O O O $JSON$ O $complex$ O $object$ O O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O $string$ O O $string$ O O O O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O
import * as path from 's' ; import * as fse from 's' ; export function getThemes ( ) : { name : string ; href : string } [ ] { let files : string [ ] ; try { const index = require . resolve ( 's' ) ; const dir = path . join ( path . parse ( index ) . dir , 's' ) ; files = fse . readdirSync ( dir ) ; } catch { return [ ] ; } files = files . filter ( filePath => filePath . includes ( 's' ) ) . sort ( ) ; return files . map ( file => { const parsedPath = path . parse ( file ) ; const name = parsedPath . name . replace ( "s" , match => match . toUpperCase ( ) ) ; return { name , href : `template` , } ; } ) ; }	O O O $any$ O O O O O O $any$ O O O O O $complex$ O O O O $string$ O O O $string$ O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $string[]$ O $any$ O $any$ O $any$ O O O O O O O O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $boolean$ O O O O O $string[]$ O O O O $string[]$ O $U[]$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $string$ O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BrowserWindow } from 's' ; import * as jwt from 's' ; import 0 from 's' ; const getPem = require ( 's' ) ; const clientId = 's' ; const replyUrl = 's' ; const authorizationEndpoint = 's' ; declare interface Config { authorization_endpoint : string ; jwks_uri : string ; token_endpoint : string ; } declare interface AuthResponse { code : string ; access_token : string ; state : string ; session_state : string ; error ? : string ; } declare interface Jwks { keys : { 0 : string ; n : string ; e : string ; 0 : string [ ] } [ ] ; } export class AzureAuthWorkflowService { private static config : Config ; private static jwks : Jwks ; public static * retrieveAuthToken ( renew = false ) < any > { const authWindow = yield this . launchAuthWindow ( renew ) ; if ( ! renew ) { authWindow . show ( ) ; } const result = yield this . waitForAuthResult ( authWindow , replyUrl ) ; authWindow . close ( ) ; if ( result . error ) { return false ; } const valid = yield this . validateJWT ( result . access_token ) ; if ( ! valid ) { result . error = 's' ; } if ( result . error ) { return false ; } yield result ; } private static async waitForAuthResult ( browserWindow , redirectUri ) < AuthResponse > { const response = await new Promise < AuthResponse > ( resolve => { let interval ; const poller = ( ) => { let uri ; const result = { } as AuthResponse ; try { const { history = [ ] } : { history : string [ ] } = browserWindow . webContents as any ; uri = history [ history . length - 0 ] || 's' ; } catch ( e ) { clearInterval ( interval ) ; result . error = e . message ; resolve ( result ) ; } if ( ! ( uri || 's' ) . toLowerCase ( ) . startsWith ( redirectUri . toLowerCase ( ) ) ) { return ; } const idx = uri . indexOf ( 's' ) ; const values = uri . substring ( idx + 0 ) . split ( 's' ) ; const len = values . length ; for ( let i = 0 ; i < len ; i ++ ) { const [ key , value ] = values [ i ] . split ( "s" ) ; result [ key ] = value ; } clearInterval ( interval ) ; resolve ( result ) ; } ; browserWindow . addListener ( 's' , ( ) => resolve ( { error : 's' } as AuthResponse ) ) ; browserWindow . addListener ( 's' , poller ) ; interval = setInterval ( poller , 0 ) ; } ) ; if ( response . error ) { return response ; } const isValid = await this . validateJWT ( response . access_token ) ; if ( ! isValid ) { response . error = 's' ; } return response ; } private static async launchAuthWindow ( renew ) < BrowserWindow > { const browserWindow = new BrowserWindow ( { modal : true , show : false , frame : true , transparent : false , alwaysOnTop : true , width : 0 , height : 0 , webPreferences : { contextIsolation : true , nativeWindowOpen : true } , } ) ; browserWindow . setMenu ( null ) ; const state = 0 ( ) ; const requestId = 0 ( ) ; const nonce = 0 ( ) ; const bits = [ `template` , `template` , `template` , `template` , `template` , `template` , 's' , 's' , ] ; if ( renew ) { bits . push ( 's' ) ; } const url = bits . join ( 's' ) ; browserWindow . loadURL ( url ) ; return new Promise < BrowserWindow > ( resolve => { browserWindow . once ( 's' , ( ) => resolve ( browserWindow ) ) ; } ) ; } private static async getConfig ( ) < Config > { if ( this . config ) { return this . config ; } const configUrl = 's' ; const configResponse = await fetch ( configUrl ) ; this . config = await configResponse . json ( ) ; return this . config ; } private static async getJwks ( ) < Jwks > { if ( this . jwks ) { return this . jwks ; } const { jwks_uri } = await this . getConfig ( ) ; const jwksResponse = await fetch ( jwks_uri ) ; this . jwks = await jwksResponse . json ( ) ; return this . jwks ; } private static async validateJWT ( token ) < boolean > { const [ header ] = token . split ( 's' ) ; const headers : { alg : string ; kid : string ; 0 : string } = JSON . parse ( Buffer . from ( header , 's' ) . toString ( ) ) ; try { const jwks = await this . getJwks ( ) ; const jwk = jwks . keys . find ( key => key . 0 === headers . 0 ) ; jwt . verify ( token , getPem ( jwk . n , jwk . e ) ) ; return true ; } catch ( e ) { return false ; } } }	O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O O O $any$ O O O $Config$ O $any$ O O O $Jwks$ O $any$ O O O O $IterableIterator$ O $boolean$ O O O O O O O O $undefined$ O O O O $Promise<any>$ O $boolean$ O O O O O $boolean$ O O $undefined$ O $any$ O O O O O $undefined$ O O O O $Promise<AuthResponse>$ O $undefined$ O O O O $undefined$ O $any$ O O O O O $undefined$ O $any$ O O O O O O O $undefined$ O O O O $Promise<boolean>$ O $undefined$ O $any$ O O O O O $undefined$ O O $undefined$ O $any$ O O O O O O $undefined$ O $any$ O O O O O O O $undefined$ O O O O O $Promise$ O $BrowserWindow$ O $string$ O O $any$ O O O $AuthResponse$ O O O $PromiseConstructor$ O $any$ O O $void$ O O O $any$ O O $void$ O O O O O O $string$ O O $AuthResponse$ O O O O $any$ O O O O O $string[]$ O O O O O O $string[]$ O O O O O O $any$ O $any$ O O O $string$ O $string[]$ O $string[]$ O $number$ O O O O O O O O O $any$ O O $void$ O $any$ O O $AuthResponse$ O $string$ O $any$ O $any$ O $void$ O $AuthResponse$ O O O O O O O $string$ O O O O $string$ O O O $boolean$ O $string$ O $string$ O O O O O O O O O $number$ O $string$ O $number$ O O O O O $string[]$ O $string$ O $string$ O $number$ O O O O $complex$ O O O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O O $string$ O $string$ O O $string[]$ O $number$ O O $complex$ O O O O $AuthResponse$ O $string$ O O $string$ O O $void$ O $any$ O O $void$ O $AuthResponse$ O O O O $any$ O $any$ O O O O O O $void$ O O $string$ O O O O $any$ O O O $any$ O $any$ O O O $void$ O O $any$ O $number$ O $void$ O O O O O O O O O $AuthResponse$ O $string$ O O O $AuthResponse$ O O O $boolean$ O O O O $Promise<boolean>$ O $AuthResponse$ O $string$ O O O O O $boolean$ O O $AuthResponse$ O $string$ O O O O O $AuthResponse$ O O O O O $Promise$ O $boolean$ O O $any$ O O O $any$ O O $any$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $number$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $string[]$ O $number$ O O O O O O $string$ O $string[]$ O $string$ O O O O $any$ O $any$ O $string$ O O O O $PromiseConstructor$ O $any$ O O $void$ O O $any$ O $any$ O O O O O O $void$ O $any$ O O O O O O O O O O $Promise$ O O O $any$ O O O O O O $Config$ O O O O O $Config$ O O O O O O O O $Response$ O O $complex$ O O O O O O $Config$ O O $Response$ O $Promise<any>$ O O O O O O $Config$ O O O O O $Promise$ O O O $any$ O O O O O O $Jwks$ O O O O O $Jwks$ O O O O $string$ O O O O O $Promise<Config>$ O O O O $Response$ O O $complex$ O $string$ O O O O $Jwks$ O O $Response$ O $Promise<any>$ O O O O O O $Jwks$ O O O O O $Promise$ O $string$ O O O O O O O $string$ O O $string$ O $complex$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O O $JSON$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O O O O $Jwks$ O O O O $Promise<Jwks>$ O O O O O O $Jwks$ O O O O O O O O O $string$ O O O $string$ O O $any$ O $any$ O $string$ O $any$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O
import { Action } from 's' ; export const AZURE_ARM_TOKEN_DATA_CHANGED = 's' ; export const AZURE_BEGIN_AUTH_WORKFLOW = 's' ; export const AZURE_INVALIDATE_ARM_TOKEN = 's' ; export const AZURE_LOGGED_IN_USER_CHANGED = 's' ; export const AZURE_PERSIST_LOGIN_CHANGED = 's' ; export interface AzureAuthAction < T > extends Action { payload : T ; } export interface ArmTokenData { access_token : string ; } export interface AzureAuthWorkflow { promptDialog : any ; promptDialogProps : { [ propName ] : any } ; loginSuccessDialog : any ; loginFailedDialog : any ; resolver ? : Function ; } export function beginAzureAuthWorkflow ( promptDialog , promptDialogProps : { [ propName ] : any } , loginSuccessDialog , loginFailedDialog , resolver ) < AzureAuthWorkflow > { return { type : AZURE_BEGIN_AUTH_WORKFLOW , payload : { promptDialog , promptDialogProps , loginSuccessDialog , loginFailedDialog , resolver , } , } ; } export function azureArmTokenDataChanged ( armToken ) < ArmTokenData > { return { type : AZURE_ARM_TOKEN_DATA_CHANGED , payload : { access_token : armToken } , } ; } export function invalidateArmToken ( ) < { } > { return { type : AZURE_INVALIDATE_ARM_TOKEN , payload : { } , } ; } export function azurePersistLoginChanged ( persistLogin ) < boolean > { return { type : AZURE_PERSIST_LOGIN_CHANGED , payload : persistLogin , } ; } export function azureLoggedInUserChanged ( signedInUser ) < string > { return { type : AZURE_LOGGED_IN_USER_CHANGED , payload : signedInUser , } ; }	O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O $any$ O O O $any$ O O O $Function$ O O $FunctionConstructor$ O O O O $AzureAuthAction$ O $any$ O $complex$ O O O $string$ O O O O O $any$ O $any$ O $Function$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $complex$ O $any$ O $any$ O $Function$ O O O O O O O O $AzureAuthAction$ O $string$ O O $any$ O O O O $string$ O O O $complex$ O O $string$ O $string$ O O O O O O O $AzureAuthAction$ O O O O O O O O O $string$ O O O ${}$ O O O O O O O O O $AzureAuthAction$ O $boolean$ O O O O O O O $string$ O O O $boolean$ O $boolean$ O O O O O O $AzureAuthAction$ O $string$ O O O O O O O $string$ O O O $string$ O $string$ O O O O
import { SharedConstants } from 's' ; import { Command , CommandServiceImpl , CommandServiceInstance } from 's' ; import { AzureAuthWorkflowService } from 's' ; import { azureLoggedInUserChanged , azurePersistLoginChanged } from 's' ; import { getSettings , store } from 's' ; const { session } = require ( 's' ) ; const { Azure } = SharedConstants . Commands ; export class AzureCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Azure . RetrieveArmToken ) protected async retrieveArmToken ( renew = false ) { const workflow = AzureAuthWorkflowService . retrieveAuthToken ( renew ) ; let result = undefined ; while ( true ) { const next = workflow . next ( result ) ; if ( next . done ) { break ; } try { result = await next . value ; } catch { break ; } } if ( result && ! result . error ) { const [ , payload ] = ( result . access_token as string ) . split ( 's' ) ; const pjson = JSON . parse ( Buffer . from ( payload , 's' ) . toString ( ) ) ; store . dispatch ( azureLoggedInUserChanged ( pjson . upn || pjson . unique_name || pjson . name || pjson . email ) ) ; await this . commandService . call ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; result . persistLogin = getSettings ( ) . azure . persistLogin ; } return result ; } @ Command ( Azure . SignUserOutOfAzure ) protected async signUserOutOfAzure ( prompt = true ) { await new Promise ( resolve => session . defaultSession . clearStorageData ( { } , resolve ) ) ; store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; try { await this . commandService . call ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; } catch { } if ( prompt ) { try { await this . commandService . call ( SharedConstants . Commands . Electron . ShowMessageBox , false , { message : 's' , title : 's' , } ) ; } catch { } } return true ; } @ Command ( Azure . PersistAzureLoginChanged ) protected persistAzureLoginChanged ( persistLogin ) { store . dispatch ( azurePersistLoginChanged ( persistLogin ) ) ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<string>$ O $AzureAuthAction<boolean>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $Promise<any>$ O $boolean$ O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O $boolean$ O O O $any$ O $undefined$ O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O O O O O O $any$ O O $complex$ O $any$ O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O $string$ O O O $any$ O $any$ O O O O $complex$ O O O O O $any$ O $JSON$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O $any$ O $any$ O $AzureAuthAction<string>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $Promise<boolean>$ O $boolean$ O O O O O O $PromiseConstructor$ O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O O $any$ O $any$ O $AzureAuthAction<boolean>$ O $any$ O O O O O
import { BotInfo , newBot } from 's' ; import { BotConfigWithPath , StartConversationParams , User } from 's' ; import { Action } from 's' ; export enum BotActionType { close = 's' , browse = 's' , hashGenerated = 's' , load = 's' , open = 's' , openViaUrl = 's' , openViaFilePath = 's' , restartConversation = 's' , setActive = 's' , setDirectory = 's' , } export interface BotAction < T = any > extends Action { type : BotActionType ; payload : T ; } export interface LoadBotPayload { bots : BotInfo [ ] ; } export interface SetActivePayload { bot : BotConfigWithPath ; } export interface SetDirectoryPayload { directory : string ; } export interface BotConfigWithPathPayload { bot : BotConfigWithPath ; } export interface BotInfosPayload { bots : BotInfo [ ] ; } export interface HashPayload { hash : string ; } export interface RestartConversationPayload { conversationId : string ; documentId : string ; user ? : User ; } export function load ( bots : BotInfo [ ] ) < LoadBotPayload > { bots = bots . filter ( bot => ! ! bot ) ; return { type : BotActionType . load , payload : { bots , } , } ; } export function setActive ( bot ) < SetActivePayload > { return { type : BotActionType . setActive , payload : { bot , } , } ; } export function setDirectory ( directory ) < SetDirectoryPayload > { return { type : BotActionType . setDirectory , payload : { directory , } , } ; } export function close ( ) < { } > { return { type : BotActionType . close , payload : { } , } ; } export function mockAndSetActive ( mock ? ) { const bot = newBot ( { version : 's' , name : 's' , description : 's' , services : [ ] , padlock : 's' , } , mock ) ; return setActive ( bot ) ; } export function botHashGenerated ( hash ) < HashPayload > { return { type : BotActionType . hashGenerated , payload : { hash } , } ; } export function browse ( ) < { } > { return { type : BotActionType . browse , payload : { } , } ; } export function closeBot ( ) < { } > { return { type : BotActionType . close , payload : { } , } ; } export function openBotViaFilePathAction ( path ) < string > { return { type : BotActionType . openViaFilePath , payload : path , } ; } export function openBotViaUrlAction ( startConversationParams < StartConversationParams > ) < Partial < StartConversationParams > > { return { type : BotActionType . openViaUrl , payload : startConversationParams , } ; } export function restartConversation ( conversationId , documentId ) < RestartConversationPayload > { return { type : BotActionType . restartConversation , payload : { conversationId , documentId } , } ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $BotActionType.close$ O O O $BotActionType.browse$ O O O $BotActionType.hashGenerated$ O O O $BotActionType.load$ O O O $BotActionType.open$ O O O $BotActionType.openViaUrl$ O O O $BotActionType.openViaFilePath$ O O O $BotActionType.restartConversation$ O O O $BotActionType.setActive$ O O O $BotActionType.setDirectory$ O O O O O O $any$ O $any$ O O O O $any$ O $BotActionType$ O $any$ O $T$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $any$ O O $any$ O O O O $BotAction$ O $any[]$ O $any$ O O O O $any$ O O $any[]$ O $any[]$ O $complex$ O $any$ O O O $any$ O O O O $BotActionType.load$ O $any$ O $BotActionType.load$ O $complex$ O O $any[]$ O O O O O O O O $BotAction$ O $BotConfigWithPath$ O O $any$ O O O O $BotActionType.setActive$ O $any$ O $BotActionType.setActive$ O $complex$ O O $any$ O O O O O O O O $BotAction$ O $string$ O O $any$ O O O O $BotActionType.setDirectory$ O $any$ O $BotActionType.setDirectory$ O $complex$ O O $string$ O O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.close$ O $any$ O $BotActionType.close$ O ${}$ O O O O O O O O O $BotAction$ O $any$ $BotConfigWithPath$ O O O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O $any$ O O O $BotAction<SetActivePayload>$ O $any$ O O O O O $BotAction$ O $string$ O O $any$ O O O O $BotActionType.hashGenerated$ O $any$ O $BotActionType.hashGenerated$ O $complex$ O O $string$ O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.browse$ O $any$ O $BotActionType.browse$ O ${}$ O O O O O O O O O $BotAction$ O O O O O O O O O $BotActionType.close$ O $any$ O $BotActionType.close$ O ${}$ O O O O O O O O O $BotAction$ O $string$ O O O O O O O $BotActionType.openViaFilePath$ O $any$ O $BotActionType.openViaFilePath$ O $string$ O $string$ O O O O O O $BotAction$ O $Partial$ O $any$ O O O $any$ O $any$ O O O O O $BotActionType.openViaUrl$ O $any$ O $BotActionType.openViaUrl$ O $any$ O $any$ O O O O O O $BotAction$ O $string$ O $string$ O O $any$ O O O O $BotActionType.restartConversation$ O $any$ O $BotActionType.restartConversation$ O $complex$ O O $string$ O $string$ O O O O O
import { getPassword , setPassword } from 's' ; export class CredentialManager { private static readonly serviceName = 's' ; public static getPassword ( key ) < string > { return getPassword ( this . serviceName , key ) ; } public static setPassword ( key , password ) < void > { return setPassword ( this . serviceName , key , password ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O $Promise$ O $string$ O O O O O O $any$ O O O O O $string$ O O O O O $Promise$ O $string$ O $string$ O O O O O O $any$ O O O O O $string$ O $string$ O O O O
import * as path from 's' ; import * as electron from 's' ; import { Conversation } from 's' ; import { BotInfo , getBotDisplayName , SharedConstants } from 's' ; import { BotConfigWithPath , BotConfigWithPathImpl } from 's' ; import { BotConfiguration } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import * as BotActions from 's' ; import { store } from 's' ; import { CredentialManager } from 's' ; export class BotHelpers { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; static async loadBotWithRetry ( botPath , secret ? ) < BotConfigWithPath > { try { let bot = await BotConfiguration . load ( botPath , secret ) ; bot = BotHelpers . cloneBot ( bot ) ; bot . path = botPath ; if ( ! BotHelpers . pathExistsInRecentBots ( botPath ) ) { const botInfo = { path : botPath , displayName : getBotDisplayName ( bot ) , } ; BotHelpers . patchBotsJson ( botPath , botInfo ) ; } if ( secret ) { const storedSecret = await CredentialManager . getPassword ( botPath ) ; if ( ! storedSecret || secret !== storedSecret ) { await CredentialManager . setPassword ( botPath , secret ) ; } } return bot ; } catch ( e ) { if ( e instanceof Error && e . message . includes ( 's' ) ) { secret = await CredentialManager . getPassword ( botPath ) ; if ( secret ) { return await this . loadBotWithRetry ( botPath , secret ) ; } else { return await BotHelpers . promptForSecretAndRetry ( botPath ) ; } } else { throw e ; } } } static getActiveBot ( ) { return store . getState ( ) . bot . activeBot ; } static getBotInfoByPath ( path ) { return store . getState ( ) . bot . botFiles . find ( bot => bot && bot . path === path ) ; } static pathExistsInRecentBots ( path ) { return store . getState ( ) . bot . botFiles . some ( bot => bot && bot . path === path ) ; } static async promptForSecretAndRetry ( botPath ) < BotConfigWithPath > { const { Commands } = SharedConstants ; const newSecret = await this . commandService . remoteCall < string > ( Commands . UI . ShowSecretPromptDialog ) ; if ( newSecret === null ) { return null ; } return BotHelpers . loadBotWithRetry ( botPath , newSecret ) ; } public static toSavableBot ( bot , secret ? ) { if ( ! bot ) { throw new Error ( `template` ) ; } const newBot = BotConfiguration . fromJSON ( bot ) ; ( newBot as any ) . internal . location = bot . path ; if ( secret ) { newBot . validateSecret ( secret ) ; } return newBot ; } public static cloneBot ( bot ) { if ( ! bot ) { return null ; } return BotConfigWithPathImpl . fromJSON ( bot ) ; } public static patchBotsJson ( botPath , bot ) : BotInfo [ ] { const state = store . getState ( ) ; const bots = [ ... state . bot . botFiles ] ; const botIndex = bots . findIndex ( 0 => 0 . path === botPath ) ; if ( botIndex > - 0 ) { bots [ botIndex ] = { ... bots [ botIndex ] , ... bot } ; } else { bots . unshift ( bot ) ; } store . dispatch ( BotActions . load ( bots ) ) ; return bots ; } public static async saveBot ( bot , secret ? ) < void > { secret = secret || ( await CredentialManager . getPassword ( bot . path ) ) ; const savableBot = BotHelpers . toSavableBot ( bot , secret ) ; if ( secret ) { savableBot . validateSecret ( secret ) ; } return savableBot . save ( secret ) . catch ( ) ; } public static async removeBotFromList ( botPath ) < void > { const state = store . getState ( ) ; const bots = [ ... state . bot . botFiles ] . filter ( bot => bot . path !== botPath ) ; store . dispatch ( BotActions . load ( bots ) ) ; } public static getTranscriptsPath ( activeBot , conversation ) { if ( ! activeBot || conversation . mode === 's' ) { return path . join ( electron . app . getPath ( 's' ) , 's' ) ; } const dirName = path . dirname ( activeBot . path ) ; return path . join ( dirName , 's' ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O O O O O $BotConfigWithPath$ O O $any$ O $any$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O O O $any$ O $boolean$ O $string$ O O O O $BotInfo$ O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any[]$ O $string$ O $any$ O O O O O $string$ O O O $string$ O O $any$ O $Promise<string>$ O $string$ O O O O O $string$ O $string$ O $string$ O O O $any$ O $Promise<void>$ O $string$ O $string$ O O O O O $any$ O O O O $any$ O O O O $any$ O $ErrorConstructor$ O $Error$ O $string$ O $boolean$ O O O O O $string$ O O $any$ O $Promise<string>$ O $string$ O O O O $string$ O O O O O O $Promise<any>$ O $string$ O $string$ O O O O O O O $any$ O $Promise<any>$ O $string$ O O O O O O O $any$ O O O O O $BotConfigWithPath$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $BotInfo$ O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $boolean$ O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $Promise$ O $string$ O O $any$ O O O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $Promise<any>$ O $string$ O $any$ O O O O O $BotConfiguration$ O $BotConfigWithPath$ O $string$ $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $string$ O O O O $any$ O O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any[]$ O $string$ O $BotInfo$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O $any$ O $any$ O O O $number$ O $any[]$ O $number$ O $any$ O $any$ O $any$ O $string$ O O O O $number$ O O O O O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O $any$ O O O O O $any[]$ O $number$ O $any$ O O O $any$ O $any$ O $any$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O O $any[]$ O O O O O $Promise$ O $BotConfigWithPath$ O $string$ $string$ O O O O O $string$ O $string$ O O O $any$ O $Promise<string>$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $string$ O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O O O O O O O $Promise$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O O O O $string$ O $BotConfigWithPath$ O $Conversation$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O
import * as fs from 's' ; import * as chokidar from 's' ; import { FSWatcher , WatchOptions } from 's' ; export abstract class FileWatcher implements FileWatcher { protected abstract onFileAdd : ( file , fstats ? : fs . Stats ) => void ; protected abstract onFileRemove : ( file , fstats ? : fs . Stats ) => void ; protected abstract onFileChange : ( file , fstats ? : fs . Stats ) => void ; protected abstract get options ( ) : WatchOptions ; protected watcher : FSWatcher ; private paths : string | string [ ] ; public async watch ( paths : string | string [ ] ) < true > { if ( this . paths === paths && this . isWatching ) { return true ; } if ( this . watcher ) { this . watcher . close ( ) ; } this . watcher = chokidar . watch ( paths ) . on ( 's' , this . onFileAdd ) . on ( 's' , this . onFileAdd ) . on ( 's' , this . onFileRemove ) . on ( 's' , this . onFileRemove ) . on ( 's' , this . onFileChange ) ; return true ; } public unwatch ( ) { if ( ! this . watcher ) { return ; } this . watcher . close ( ) ; this . watcher = null ; } public get isWatching ( ) : boolean { return ! ! this . watcher ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $complex$ O O O O O O O O O $Promise$ O $complex$ O O O O O O O O O O O O O O O $complex$ O $complex$ O O O $boolean$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O O O O O $void$ O O $any$ O O O O O $void$ O O $any$ O O O O O $void$ O O $any$ O O O O O $void$ O O $any$ O O O O O $void$ O O O O O O O $void$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $boolean$ O O O O O O O O O O $any$ O O O
import * as path from 's' ; import { SharedConstants } from 's' ; import { WatchOptions } from 's' ; import { existsSync , readFileSync , Stats } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import * as BotActions from 's' ; import { store } from 's' ; import { BotHelpers } from 's' ; import { FileWatcher } from 's' ; function findGitIgnore ( directory ) { const filePath = path . resolve ( directory , 's' ) ; const found = existsSync ( filePath ) ; if ( found ) { return filePath ; } return null ; } function readGitIgnore ( filePath ) : string [ ] { if ( ! filePath ) { return [ ] ; } const text = readFileSync ( filePath , 's' ) ; return text . split ( "s" ) . map ( x => x . trim ( ) ) . filter ( x => x && ! ( x || 's' ) . startsWith ( 's' ) ) ; } export class BotProjectFileWatcher extends FileWatcher { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private botFilePath : string ; protected onFileAdd = ( file , fstats ? ) : void => { } ; protected onFileRemove = ( file , fstats ? ) : void => { } ; protected onFileChange = async ( file , fstats ? ) : Promise < any > => { if ( file !== this . botFilePath || ! BotHelpers . getActiveBot ( ) ) { return ; } const bot = await BotHelpers . loadBotWithRetry ( this . botFilePath ) ; if ( ! bot ) { throw new Error ( 's' ) ; } const botDir = path . dirname ( this . botFilePath ) ; store . dispatch ( BotActions . setActive ( bot ) ) ; return Promise . all ( [ this . commandService . remoteCall ( SharedConstants . Commands . Bot . SetActive , bot , botDir ) , this . commandService . call ( SharedConstants . Commands . Bot . RestartEndpointService ) , ] ) ; } ; public async watch ( botFilePath ) < true > { this . botFilePath = botFilePath ; await this . commandService . remoteCall ( SharedConstants . Commands . File . Clear ) ; if ( botFilePath ) { return super . watch ( botFilePath ) ; } return true ; } public get options ( ) : WatchOptions { const botProjectDir = path . dirname ( this . botFilePath ) ; const gitIgnoreFile = findGitIgnore ( botProjectDir ) ; const ignoreGlobs = readGitIgnore ( gitIgnoreFile ) ; return { ignored : ignoreGlobs , followSymlinks : false , } ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $string[]$ O $string$ O O O O O O O O O $string$ O O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $string$ O O O O $void$ O O $string$ O $any$ $Stats$ O O O O O O O O $void$ O O $string$ O $any$ $Stats$ O O O O O O O O $Promise<any>$ O O O $string$ O $any$ $Stats$ O O $PromiseConstructor$ O O O O O O O $string$ O O O $string$ O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $Promise<any>$ O O O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise$ O $string$ O O O O O O O $string$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $Promise<true>$ O $string$ O O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O $string$ O $any$ O O O $string[]$ O $string[]$ O $string$ O O O O $string[]$ O $string[]$ O $boolean$ O O O O O O O
import * as fs from 's' ; import * as path from 's' ; import { SharedConstants } from 's' ; import { isChatFile } from 's' ; import { IFileService , ServiceTypes } from 's' ; import { WatchOptions } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { FileWatcher } from 's' ; export class ChatWatcher extends FileWatcher { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private chatFiles : { [ path ] : boolean } = { } ; private notificationPending : NodeJS . Timer ; public get options ( ) : WatchOptions { return { followSymlinks : false , } ; } public async watch ( paths : string | string [ ] ) < true > { this . chatFiles = { } ; this . invalidateChatFiles ( ) ; return super . watch ( paths ) ; } protected onFileAdd = ( file , fstats ? : fs . Stats ) : void => { if ( ! isChatFile ( file ) ) { return ; } this . chatFiles [ file ] = true ; this . invalidateChatFiles ( ) ; } ; protected onFileRemove = ( file , fstats ? : fs . Stats ) : void => { if ( ! isChatFile ( file ) ) { return ; } delete this . chatFiles [ file ] ; this . invalidateChatFiles ( ) ; } ; protected onFileChange = ( file , fstats ? : fs . Stats ) : void => { this . commandService . remoteCall ( SharedConstants . Commands . File . Changed , file ) . catch ( ) ; } ; private invalidateChatFiles ( ) { clearTimeout ( this . notificationPending ) ; this . notificationPending = setTimeout ( this . validateChatFiles , 0 ) ; } private validateChatFiles = ( ) => { const chatFiles : IFileService [ ] = Object . keys ( this . chatFiles ) . map ( key => { const { name , ext } = path . parse ( key ) ; return { name : `template` , type : ServiceTypes . File , id : key , path : key , } ; } ) ; this . commandService . remoteCall ( SharedConstants . Commands . Bot . ChatFilesUpdated , chatFiles ) . catch ( ) ; this . notificationPending = null ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $complex$ O O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $boolean$ O O O O O O O O $Promise$ O $complex$ O O O O O O O O O O O O O $complex$ O O O O O O $void$ O O O O O O $Promise<true>$ O $complex$ O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O O O O $complex$ O $string$ O O O O O O $void$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O O O O O $complex$ O $string$ O O O O $void$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O $void$ O O O $void$ O O O $any$ O O O O $any$ O $number$ O O O $void$ O O O O O O $void$ O O O O O O $any[]$ O $any$ O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O $string$ O O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O O $any$ O O O O O O
import * as fs from 's' ; import * as path from 's' ; import { SharedConstants } from 's' ; import { isTranscriptFile } from 's' ; import { IFileService , ServiceTypes } from 's' ; import { WatchOptions } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { FileWatcher } from 's' ; export class TranscriptsWatcher extends FileWatcher { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private transcriptFiles : { [ path ] : boolean } = { } ; private notificationPending : NodeJS . Timer ; public get options ( ) : WatchOptions { return { followSymlinks : false , } ; } public async watch ( paths : string | string [ ] ) < true > { this . transcriptFiles = { } ; this . invalidateTranscriptFiles ( ) ; return super . watch ( paths ) ; } protected onFileAdd = ( file , fstats ? : fs . Stats ) : void => { if ( ! isTranscriptFile ( file ) ) { return ; } this . transcriptFiles [ file ] = true ; this . invalidateTranscriptFiles ( ) ; } ; protected onFileRemove = ( file , fstats ? : fs . Stats ) : void => { if ( ! isTranscriptFile ( file ) ) { return ; } delete this . transcriptFiles [ file ] ; this . invalidateTranscriptFiles ( ) ; } ; protected onFileChange = ( file , fstats ? : fs . Stats ) : void => { this . commandService . remoteCall ( SharedConstants . Commands . File . Changed , file ) . catch ( ) ; } ; private invalidateTranscriptFiles ( ) { clearTimeout ( this . notificationPending ) ; this . notificationPending = setTimeout ( this . validateChatFiles , 0 ) ; } private validateChatFiles = ( ) => { const transcriptFiles : IFileService [ ] = Object . keys ( this . transcriptFiles ) . map ( key => { const { name , ext } = path . parse ( key ) ; return { name : `template` , type : ServiceTypes . File , id : key , path : key , } ; } ) ; this . commandService . remoteCall ( SharedConstants . Commands . Bot . TranscriptFilesUpdated , transcriptFiles ) . catch ( ) ; this . notificationPending = null ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $complex$ O O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $boolean$ O O O O O O O O $Promise$ O $complex$ O O O O O O O O O O O O O $complex$ O O O O O O $void$ O O O O O O $Promise<true>$ O $complex$ O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O O O O $complex$ O $string$ O O O O O O $void$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O O O O O $complex$ O $string$ O O O O $void$ O O O O O O $void$ O O $string$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O $void$ O O O $void$ O O O $any$ O O O O $any$ O $number$ O O O $void$ O O O O O O $void$ O O O O O O $any[]$ O $any$ O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O $string$ O O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O O $any$ O O O O O O
import { BotProjectFileWatcher } from 's' ; import { ChatWatcher } from 's' ; import { TranscriptsWatcher } from 's' ; export const botProjectFileWatcher = new BotProjectFileWatcher ( ) ; export const chatWatcher = new ChatWatcher ( ) ; export const transcriptsWatcher = new TranscriptsWatcher ( ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BotProjectFileWatcher$ O O $any$ O O O O O $ChatWatcher$ O O $any$ O O O O O $TranscriptsWatcher$ O O $any$ O O O
import * as path from 's' ; import { BotInfo , getBotDisplayName , SharedConstants } from 's' ; import { BotConfigWithPath , Command , CommandServiceImpl , CommandServiceInstance , mergeEndpoints , uniqueId , } from 's' ; import { BotConfigurationBase } from 's' ; import { IConnectedService , IEndpointService , ServiceTypes } from 's' ; import { dialog } from 's' ; import * as BotActions from 's' ; import { setActive } from 's' ; import { store } from 's' ; import { BotHelpers } from 's' ; import { Emulator } from 's' ; import { TelemetryService } from 's' ; import { isMac } from 's' ; import { botProjectFileWatcher , chatWatcher , transcriptsWatcher } from 's' ; import { CredentialManager } from 's' ; const { Bot } = SharedConstants . Commands ; export class BotCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Bot . Create ) protected async createBot ( bot , secret ) < BotConfigWithPath > { const dirName = path . dirname ( bot . path ) ; const botsJsonEntry = { path : bot . path , displayName : getBotDisplayName ( bot ) , transcriptsPath : path . join ( dirName , 's' ) , chatsPath : path . join ( dirName , 's' ) , } ; BotHelpers . patchBotsJson ( bot . path , botsJsonEntry ) ; try { await BotHelpers . saveBot ( bot , secret ) ; if ( secret ) { await CredentialManager . setPassword ( bot . path , secret ) ; } } catch ( e ) { console . error ( `template` ) ; throw e ; } const telemetryInfo = { path : bot . path , hasSecret : ! ! secret } ; TelemetryService . trackEvent ( 's' , telemetryInfo ) ; return bot ; } @ Command ( Bot . Save ) protected async saveBot ( bot ) { await BotHelpers . saveBot ( bot ) ; } @ Command ( Bot . Open ) protected async openBot ( botPath , secret ? ) < BotConfigWithPath > { const botInfo = BotHelpers . pathExistsInRecentBots ( botPath ) ? BotHelpers . getBotInfoByPath ( botPath ) : null ; if ( botInfo ) { const dirName = path . dirname ( botPath ) ; let syncWithClient ; if ( ! botInfo . transcriptsPath ) { botInfo . transcriptsPath = path . join ( dirName , 's' ) ; syncWithClient = true ; } if ( ! botInfo . chatsPath ) { botInfo . chatsPath = path . join ( dirName , 's' ) ; syncWithClient = true ; } if ( syncWithClient ) { BotHelpers . patchBotsJson ( botPath , botInfo ) ; } } let bot ; try { bot = await BotHelpers . loadBotWithRetry ( botPath , secret ) ; } catch ( e ) { await dialog . showErrorBox ( 's' , e . message ) ; } if ( ! bot ) { throw new Error ( 's' ) ; } return bot ; } @ Command ( Bot . SetActive ) protected async setActiveBot ( bot ) < string > { await botProjectFileWatcher . watch ( bot . path ) ; const botDirectory = path . dirname ( bot . path ) ; store . dispatch ( BotActions . setActive ( bot ) ) ; store . dispatch ( BotActions . setDirectory ( botDirectory ) ) ; const botInfo = BotHelpers . getBotInfoByPath ( bot . path ) || { } ; const dirName = path . dirname ( bot . path ) ; const { chatsPath = path . join ( dirName , 's' ) , transcriptsPath = path . join ( dirName , 's' ) , } = botInfo ; const botFilePath = path . parse ( botInfo . path || 's' ) . dir ; const relativeChatsPath = path . relative ( botFilePath , chatsPath ) ; const relativeTranscriptsPath = path . relative ( botFilePath , transcriptsPath ) ; const displayedChatsPath = relativeChatsPath . includes ( 's' ) ? chatsPath : relativeChatsPath ; const displayedTranscriptsPath = relativeTranscriptsPath . includes ( 's' ) ? transcriptsPath : relativeTranscriptsPath ; const sep = isMac ( ) ? path . posix . sep : ( path . posix as any ) . 0 . sep ; await Promise . all ( [ chatWatcher . watch ( chatsPath ) , transcriptsWatcher . watch ( transcriptsPath ) , this . commandService . remoteCall ( Bot . ChatsPathUpdated , `template` ) , this . commandService . remoteCall ( Bot . TranscriptsPathUpdated , `template` ) , this . commandService . call ( Bot . RestartEndpointService ) , ] ) ; return botDirectory ; } @ Command ( Bot . RestartEndpointService ) protected async restartEndpointService ( ) { const bot = BotHelpers . getActiveBot ( ) ; Emulator . getInstance ( ) . framework . server . botEmulator . facilities . endpoints . reset ( ) ; const overridesArePresent = bot . overrides && bot . overrides . endpoint ; let appliedOverrides = false ; bot . services . filter ( s => s . type === ServiceTypes . Endpoint ) . forEach ( service => { let endpoint = service as IEndpointService ; if ( overridesArePresent && ! appliedOverrides ) { if ( ! bot . overrides . endpoint . id ) { endpoint = mergeEndpoints ( endpoint , bot . overrides . endpoint ) ; appliedOverrides = true ; } else if ( bot . overrides . endpoint . id === service . id ) { endpoint = mergeEndpoints ( endpoint , bot . overrides . endpoint ) ; appliedOverrides = true ; } } Emulator . getInstance ( ) . framework . server . botEmulator . facilities . endpoints . push ( endpoint . id , { botId : endpoint . id , botUrl : endpoint . endpoint , msaAppId : endpoint . appId , msaPassword : endpoint . appPassword , channelService : ( endpoint as any ) . channelService , } ) ; } ) ; } @ Command ( Bot . Close ) protected closeBot ( ) { botProjectFileWatcher . unwatch ( ) ; store . dispatch ( BotActions . close ( ) ) ; } @ Command ( Bot . AddOrUpdateService ) protected async addOrUpdateService ( serviceType , service ) { if ( ! service . id || ! service . id . length ) { service . id = uniqueId ( ) ; } const activeBot = BotHelpers . getActiveBot ( ) ; const botInfo = activeBot && BotHelpers . getBotInfoByPath ( activeBot . path ) ; if ( botInfo ) { const secret = await CredentialManager . getPassword ( activeBot . path ) ; const botConfig = BotHelpers . toSavableBot ( activeBot , secret ) ; const index = botConfig . services . findIndex ( s => s . id === service . id && s . type === service . type ) ; const existing = botConfig . services [ index ] ; if ( existing ) { botConfig . services [ index ] = BotConfigurationBase . serviceFromJSON ( { ... existing , ... service , } ) ; } else { if ( service . type !== serviceType ) { throw new Error ( 's' ) ; } botConfig . connectService ( service ) ; TelemetryService . trackEvent ( 's' , { type : service . type } ) ; } try { await BotHelpers . saveBot ( botConfig ) ; store . dispatch ( setActive ( botConfig ) ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . SetActive , botConfig , botConfig . getPath ( ) ) ; } catch ( e ) { console . error ( `template` ) ; throw e ; } } } @ Command ( Bot . RemoveService ) protected async removeService ( serviceType , serviceOrId ) { const activeBot = BotHelpers . getActiveBot ( ) ; const botInfo = activeBot && BotHelpers . getBotInfoByPath ( activeBot . path ) ; if ( botInfo ) { const secret = await CredentialManager . getPassword ( activeBot . path ) ; const botConfig = BotHelpers . toSavableBot ( activeBot , secret ) ; const id = typeof serviceOrId === 's' ? serviceOrId : serviceOrId . id ; botConfig . disconnectService ( id ) ; try { await BotHelpers . saveBot ( botConfig ) ; store . dispatch ( setActive ( botConfig ) ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . SetActive , botConfig , botConfig . getPath ( ) ) ; } catch ( e ) { console . error ( `template` ) ; throw e ; } } } @ Command ( Bot . PatchBotList ) protected async patchBotList ( botPath , botInfo ) < boolean > { BotHelpers . patchBotsJson ( botPath , botInfo ) ; const dirName = path . dirname ( botInfo . path ) ; const { chatsPath = path . join ( dirName , 's' ) , transcriptsPath = path . join ( dirName , 's' ) , } = botInfo ; await Promise . all ( [ chatWatcher . watch ( chatsPath ) , transcriptsWatcher . watch ( transcriptsPath ) ] ) ; return true ; } @ Command ( Bot . RemoveFromBotList ) protected async removeFromBotList ( botPath ) < void > { const { ShowMessageBox } = SharedConstants . Commands . Electron ; const result = await this . commandService . call ( ShowMessageBox , true , { type : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , message : `template` , cancelId : 0 , } ) ; if ( result ) { await BotHelpers . removeBotFromList ( botPath ) . catch ( ) ; } } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $BotAction<SetActivePayload>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $BotProjectFileWatcher$ O $ChatWatcher$ O $TranscriptsWatcher$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $Promise$ O $BotConfigWithPath$ O $string$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $BotInfo$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O $any$ O $string$ O O O O $string$ O O O $any$ O $Promise<void>$ O $any$ O $any$ O $string$ O O O O O O $any$ O O $Console$ O $void$ O O O O O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $boolean$ O O O $string$ O O $any$ O $void$ O O O $complex$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $BotConfigWithPath$ O O O $any$ O $Promise<void>$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O O O $any$ O $any$ O $boolean$ O $string$ O O $any$ O $any$ O $string$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O $boolean$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O $boolean$ O O $any$ O $any[]$ O $string$ O $any$ O O O O O $BotConfigWithPath$ O O O $any$ O O $any$ O $Promise<any>$ O $string$ O $string$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $Promise$ O $BotConfigWithPath$ O O O O O O $BotProjectFileWatcher$ O $Promise<true>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O $any$ O $any$ O $any$ O $BotAction<SetDirectoryPayload>$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $PromiseConstructor$ O O O O $ChatWatcher$ O $Promise<true>$ O $any$ O O $TranscriptsWatcher$ O $Promise<true>$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $void$ O O O $BotProjectFileWatcher$ O $void$ O O O $any$ O $any$ O $any$ O $BotAction<{}>$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $ServiceTypes$ O $IConnectedService$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O $any$ O $Promise<string>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O $any$ O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $Promise<void>$ O $any$ O O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O $Console$ O $void$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $ServiceTypes$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O $any$ O $Promise<string>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $any$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O $any$ O O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O $Console$ O $void$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $Promise$ O $string$ O $BotInfo$ O O O O O $any$ O $any[]$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $PromiseConstructor$ O O O O $ChatWatcher$ O $Promise<true>$ O $any$ O O $TranscriptsWatcher$ O $Promise<true>$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $Promise$ O $string$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $string[]$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O O O O O $any$ O O O $any$ O $Promise<void>$ O $string$ O O $complex$ O O O O O O
export const Protocol = 's' ;	O O O O O O
import * as path from 's' ; import { SharedConstants } from 's' ; import { CommandServiceImpl , ExtensionConfig } from 's' ; import { CommandServiceInstance } from 's' ; import { getDirectories , readFileSync } from 's' ; export interface Extension { readonly config : ExtensionConfig ; } export interface ExtensionManager { findExtension ( name ) : Extension ; addExtension ( extension , configPath ) ; loadExtensions ( ) ; unloadExtensions ( ) ; } class ExtManagerImpl implements ExtensionManager { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private extensions : Map < Extension , string > = new Map < Extension , string > ( ) ; public findExtension ( name ) { for ( const kvPair of this . extensions ) { if ( kvPair [ 0 ] . config . name === name ) { return kvPair [ 0 ] ; } } return undefined ; } public loadExtensions ( ) { let folders = [ ] ; try { const folder = this . unpackedFolder ( path . resolve ( path . join ( __dirname , 's' , 's' ) ) ) ; folders = getDirectories ( folder ) ; } catch { } folders . forEach ( folder => { try { this . spawnExtension ( folder ) ; } catch ( ex ) { console . log ( `template` , ex ) ; } } ) ; } public unloadExtensions ( ) { for ( const kvPair of this . extensions ) { this . unloadExtension ( kvPair [ 0 ] ) ; } } public unloadExtension ( extension ) { if ( extension ) { console . log ( `template` ) ; this . commandService . remoteCall ( SharedConstants . Commands . Extension . Disconnect , extension . config . location ) ; this . extensions . delete ( extension ) ; } } public addExtension ( extension , configPath ) { configPath = configPath . replace ( "s" , 's' ) ; this . unloadExtension ( extension ) ; this . extensions . set ( extension , configPath ) ; console . log ( `template` ) ; extension . config . client = extension . config . client || { } ; extension . config . node = extension . config . node || { } ; extension . config . client . basePath = ( extension . config . client . basePath || 's' ) . replace ( "s" , 's' ) ; const inspectors = extension . config . client . inspectors || [ ] ; inspectors . forEach ( inspector => { inspector . src = ( inspector . src || 's' ) . replace ( "s" , 's' ) ; } ) ; inspectors . forEach ( inspector => { let folder = path . resolve ( configPath ) . replace ( "s" , 's' ) ; if ( folder [ 0 ] !== 's' ) { folder = `template` ; } inspector . src = `template` + inspector . src ; inspector . preloadPath = 's' + path . resolve ( path . join ( __dirname , 's' , 's' , 's' ) ) ; } ) ; this . commandService . remoteCall ( SharedConstants . Commands . Extension . Connect , extension . config ) ; } private isPacked ( ) { return "s" . test ( __dirname ) ; } private unpackedFolder ( filename ) { if ( path . isAbsolute ( filename ) && this . isPacked ( ) ) { return filename . replace ( 's' , 's' ) ; } else { return filename ; } } private spawnExtension ( folder ) { try { let config = JSON . parse ( readFileSync ( `template` ) ) ; if ( ! config . location ) { return ; } if ( ! path . isAbsolute ( config . location ) ) { folder = this . unpackedFolder ( path . join ( __dirname , config . location ) ) ; } else { folder = this . unpackedFolder ( path . resolve ( config . location ) ) ; } try { Object . assign ( config , JSON . parse ( readFileSync ( `template` ) ) ) ; } catch ( ex ) { config = null ; } if ( config && config . name ) { const extension = { config } as Extension ; this . addExtension ( extension , folder ) ; } } catch ( err ) { console . log ( 's' , folder , err ) ; } } } export const ExtensionManagerImpl = new ExtManagerImpl ( ) ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $Extension$ O $string$ O O $any$ O $any$ O $Extension$ O $string$ O O $any$ O O O $any$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $complex$ O $MapConstructor$ O $any$ O O O O O $MapConstructor$ O $any$ O O O O O O O $Extension$ O $string$ O O O O O $complex$ O O O $complex$ O O O O $complex$ O O O O $any$ O $any$ O $string$ O O O $complex$ O O O O O O O $undefined$ O O O $void$ O O O O $any[]$ O O O O O O O $string$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any[]$ O $any$ O $string$ O O O O O O $any[]$ O $void$ O $any$ O O O O O O $void$ O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O O $void$ O O O O O O $complex$ O O O $complex$ O O O O $void$ O $complex$ O O O O O O O O $void$ O $Extension$ O O O O $Extension$ O O $Console$ O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Extension$ O $any$ O $any$ O O O O $complex$ O $boolean$ O $Extension$ O O O O O $void$ O $Extension$ O $string$ O O $string$ O $string$ O $complex$ O O O O O O O O $void$ O $Extension$ O O O O $complex$ O $complex$ O $Extension$ O $string$ O O $Console$ O $void$ O O O O $Extension$ O $any$ O $any$ O $Extension$ O $any$ O $any$ O O O O $Extension$ O $any$ O $any$ O $Extension$ O $any$ O $any$ O O O O $Extension$ O $any$ O $any$ O $any$ O O $Extension$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $Extension$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Extension$ O $any$ O O O O $boolean$ O O O O O O $boolean$ O $any$ O O O O $string$ O $string$ O O O O $any$ O $any$ O $string$ O O O O $boolean$ O O O O O $string$ O $complex$ O O O O O O O O O O $string$ O O O O $void$ O $string$ O O O O O $any$ O $JSON$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ObjectConstructor$ O O O $any$ O $JSON$ O $any$ O $string$ O O O O O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $Extension$ O O $any$ O O $any$ O O O $void$ O $Extension$ O $string$ O O O O O O $any$ O O $Console$ O $void$ O O O $string$ O $any$ O O O O O O O $ExtManagerImpl$ O O $any$ O O O
import * as Path from 's' ; import { BotInfo , SharedConstants } from 's' ; import { BotConfiguration } from 's' ; import { app } from 's' ; import * as Fs from 's' ; import { sync as mkdirp } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import * as BotActions from 's' ; import { store } from 's' ; import { BotHelpers } from 's' ; import { ensureStoragePath , getFilesInDir , writeFile } from 's' ; export class Migrator { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; private static readonly _migrationMarkerName = 's' ; public static async startup ( ) < void > { if ( ! ( await this . migrationHasBeenPerformed ( ) ) ) { const migrationResult = await this . migrateBots ( ) ; if ( migrationResult ) { this . leaveMigrationMarker ( ) ; } } } public static async migrateBots ( ) < boolean > { let botFilesDirectory = app . getPath ( 's' ) . replace ( Path . join ( 's' , 's' ) , Path . join ( 's' , 's' ) ) ; botFilesDirectory = Path . join ( botFilesDirectory , 's' ) ; if ( ! ( await Fs . pathExists ( botFilesDirectory ) ) ) { return false ; } const botFiles = ( getFilesInDir ( botFilesDirectory ) || [ ] ) as string [ ] ; if ( botFiles . length ) { const recentBotsList : BotInfo [ ] = [ ] ; for ( let i = 0 ; i < botFiles . length ; i ++ ) { const botFile = botFiles [ i ] ; try { const oldPath = Path . join ( botFilesDirectory , botFile ) ; const newPathBase = Path . join ( ensureStoragePath ( ) , 's' ) ; if ( ! ( await Fs . pathExists ( newPathBase ) ) ) { mkdirp ( newPathBase ) ; } const newPath = Path . join ( newPathBase , botFile ) ; const botWithOldPath = await BotConfiguration . load ( oldPath ) ; const bot = BotHelpers . cloneBot ( botWithOldPath ) ; bot . path = newPath ; await BotHelpers . saveBot ( bot ) ; const botInfo = { path : newPath , displayName : bot . name , } ; recentBotsList . unshift ( botInfo ) ; } catch ( err ) { throw new Error ( `template` ) ; } } store . dispatch ( BotActions . load ( recentBotsList ) ) ; const { ShowPostMigrationDialog } = SharedConstants . Commands . UI ; await Migrator . commandService . remoteCall ( ShowPostMigrationDialog ) . catch ( ) ; return true ; } return false ; } private static leaveMigrationMarker ( ) { writeFile ( Path . join ( ensureStoragePath ( ) , this . _migrationMarkerName ) , 's' ) ; } private static async migrationHasBeenPerformed ( ) < boolean > { return Fs . pathExists ( Path . join ( ensureStoragePath ( ) , this . _migrationMarkerName ) ) ; } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O $any$ O $void$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O $Promise<boolean>$ O O O O O O $boolean$ O O O O $Promise<boolean>$ O O O O O $boolean$ O O O O $void$ O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $string[]$ O O $any$ O $any$ O O O O O O O O O O O O $string[]$ O $number$ O O O $any[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $Promise<void>$ O $any$ O O O $BotInfo$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O $any$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O $void$ O O O $void$ O $any$ O $any$ O $string$ O O O O O O O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O O
import { Notification , SharedConstants } from 's' ; import { CommandServiceImpl } from 's' ; import { deleteGlobal , setGlobal } from 's' ; export async function sendNotificationToClient ( notification , commandService ? ) < void > { setGlobal ( SharedConstants . NOTIFICATION_FROM_MAIN , notification ) ; await commandService . remoteCall ( SharedConstants . Commands . Notifications . Add ) ; deleteGlobal ( SharedConstants . NOTIFICATION_FROM_MAIN ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O O O O $Promise$ O $Notification$ O $any$ $CommandServiceImpl$ O O O O O $void$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O O O
import * as Path from 's' ; import { FrameworkSettings , newNotification , SharedConstants } from 's' ; import got from 's' ; import { IEndpointService } from 's' ; import { applyBotConfigOverrides , BotConfigOverrides , BotConfigWithPath , CommandServiceImpl , CommandServiceInstance , StartConversationParams , } from 's' ; import { Protocol } from 's' ; import { Emulator } from 's' ; import { getSettings } from 's' ; import { sendNotificationToClient } from 's' ; import { TelemetryService } from 's' ; enum ProtocolDomains { livechat , transcript , bot , inspector , } export enum ProtocolLiveChatActions { open , } export enum ProtocolTranscriptActions { open , } export enum ProtocolBotActions { open , } export interface Protocol { domain ? : string ; action ? : string ; args ? : string ; parsedArgs ? : { [ key ] : string } | any ; } export interface ProtocolHandler { parseProtocolUrl : ( url ) => Protocol ; dispatchProtocolAction : ( protocol ) => void ; performLiveChatAction : ( protocol ) => void ; performTranscriptAction : ( protocol ) => void ; performBotAction : ( protocol ) => void ; } class ProtocolHandlerImpl implements ProtocolHandler { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; public parseProtocolUrl ( url ) { const parsedUrl = new URL ( url ) ; if ( ! Protocol . startsWith ( parsedUrl . protocol ) ) { throw new Error ( `template` ) ; } const domainAndAction = ( parsedUrl . hostname || 's' ) . toLowerCase ( ) . split ( 's' ) ; const [ domain = 's' , action = 's' ] = domainAndAction ; const parsedArgs = { } ; parsedUrl . searchParams . forEach ( ( value , key ) => ( parsedArgs [ key ] = value ) ) ; return { domain , action , args : ( parsedUrl . search || 's' ) . replace ( "s" , 's' ) , parsedArgs , } ; } public dispatchProtocolAction ( protocol ) { switch ( ProtocolDomains [ protocol . domain ] ) { case ProtocolDomains . bot : this . performBotAction ( protocol ) ; break ; case ProtocolDomains . livechat : this . performLiveChatAction ( protocol ) ; break ; case ProtocolDomains . transcript : this . performTranscriptAction ( protocol ) ; break ; case ProtocolDomains . inspector : this . performInspectorAction ( protocol ) ; break ; default : break ; } } public parseProtocolUrlAndDispatch ( url ) { this . dispatchProtocolAction ( this . parseProtocolUrl ( url ) ) ; } public performLiveChatAction ( protocol ) { const { botUrl : endpoint , msaAppId : appId , msaAppPassword : appPassword , cloud : channelService , } = protocol . parsedArgs ; this . commandService . remoteCall ( SharedConstants . Commands . UI . OpenBotViaUrl , { endpoint , appId , appPassword , mode : 's' , channelService , } as StartConversationParams ) ; } public performTranscriptAction ( protocol ) { this . openTranscript ( protocol ) ; } public performBotAction ( protocol ) { this . openBot ( protocol ) ; } public performInspectorAction ( protocol ) { const { botUrl : endpoint , msaAppId : appId , msaAppPassword : appPassword , cloud : channelService , } = protocol . parsedArgs ; this . commandService . remoteCall ( SharedConstants . Commands . UI . OpenBotViaUrl , { endpoint , appId , appPassword , mode : 's' , channelService , } as StartConversationParams ) ; } public openTranscript ( protocol ) { const { url } = protocol . parsedArgs ; const options = { url } ; return got ( options ) . then ( res => { if ( "s" . test ( res . statusCode ) ) { if ( res . body ) { try { const transcriptString = res . body ; const conversationActivities = JSON . parse ( transcriptString ) ; if ( ! Array . isArray ( conversationActivities ) ) { throw new Error ( 's' ) ; } const { name , ext } = Path . parse ( url ) ; const fileName = `template` ; this . commandService . remoteCall ( SharedConstants . Commands . Emulator . OpenTranscript , 's' , { activities : conversationActivities , inMemory : true , fileName , } ) ; } catch ( e ) { throw new Error ( `template` ) ; } } } else { if ( res . statusCode === 0 ) { const stat = res . body || res . statusText || 's' ; throw new Error ( `template` ) ; } if ( res . statusCode === 0 ) { throw new Error ( `template` ) ; } } } ) . catch ( err => { const errMsg = `template` ; const notification = newNotification ( errMsg ) ; sendNotificationToClient ( notification , this . commandService ) ; } ) ; } public async openBot ( protocol ) < void > { const { path , secret } : { path : string ; secret : string } = protocol . parsedArgs ; const endpointOverrides < IEndpointService > = parseEndpointOverrides ( protocol . parsedArgs ) ; const overrides = endpointOverrides ? { endpoint : endpointOverrides } : null ; let bot ; try { bot = ( await this . commandService . call ( SharedConstants . Commands . Bot . Open , path , secret ) ) as BotConfigWithPath ; if ( ! bot ) { throw new Error ( `template` ) ; } } catch ( e ) { throw new Error ( `template` ) ; } if ( overrides ) { bot = applyBotConfigOverrides ( bot , overrides ) ; } const appSettings = getSettings ( ) . framework ; if ( appSettings . ngrokPath ) { const ngrok = Emulator . getInstance ( ) . ngrok ; let ngrokSpawnStatus = ngrok . getSpawnStatus ( ) ; if ( ! ngrokSpawnStatus . triedToSpawn ) { await ngrok . recycle ( ) ; } ngrokSpawnStatus = ngrok . getSpawnStatus ( ) ; if ( ngrokSpawnStatus . triedToSpawn && ngrokSpawnStatus . err ) { throw new Error ( `template` ) ; } if ( ngrok . running ) { try { await this . commandService . call ( SharedConstants . Commands . Bot . SetActive , bot ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . Load , bot ) ; } catch ( e ) { throw new Error ( `template` ) ; } } else { ngrok . ngrokEmitter . once ( 's' , async ( ... args : any [ ] ) : Promise < void > => { try { await this . commandService . call ( SharedConstants . Commands . Bot . SetActive , bot ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . Load , bot ) ; } catch ( e ) { throw new Error ( `template` + `template` ) ; } } ) ; } } else { try { await this . commandService . call ( SharedConstants . Commands . Bot . SetActive , bot ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Bot . Load , bot ) ; } catch ( e ) { throw new Error ( `template` ) ; } } const numOfServices = bot . services && bot . services . length ; TelemetryService . trackEvent ( 's' , { method : 's' , numOfServices , } ) ; } } export const ProtocolHandler = new ProtocolHandlerImpl ( ) ; export function parseEndpointOverrides ( parsedArgs : { [ key ] : string } ) < IEndpointService > { if ( ! parsedArgs || ! Object . keys ( parsedArgs ) . length ) { return null ; } const endpointOverrides < IEndpointService > = { } ; const { appId = null , appPassword = null , endpoint = null , id = null } = parsedArgs ; if ( appId ) { endpointOverrides . appId = appId ; } if ( appPassword ) { endpointOverrides . appPassword = appPassword ; } if ( endpoint ) { endpointOverrides . endpoint = endpoint ; } if ( id ) { endpointOverrides . id = id ; } if ( ! Object . keys ( endpointOverrides ) . length ) { return null ; } return endpointOverrides ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O $any$ O $ProtocolDomains.livechat$ O $ProtocolDomains.transcript$ O $ProtocolDomains.bot$ O $ProtocolDomains.inspector$ O O O O $any$ O $ProtocolLiveChatActions.open$ O O O O $any$ O $ProtocolTranscriptActions.open$ O O O O $any$ O $ProtocolBotActions.open$ O O O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O O O O $string$ O O O O O O O O O O $ProtocolHandlerImpl$ O $Protocol$ O O $string$ O O $any$ O $void$ O O $Protocol$ O O O O $void$ O O $Protocol$ O O O O $void$ O O $Protocol$ O O O O $void$ O O $Protocol$ O O O O O O $any$ O $ProtocolHandlerImpl$ O O $any$ O O O $any$ O $any$ O O $Protocol$ O $string$ O O O $URL$ O O $complex$ O $string$ O O O O O $any$ O $boolean$ O $URL$ O $string$ O O O O O $ErrorConstructor$ O O O O O O $string[]$ O O $URL$ O $string$ O O O O $string$ O O O $complex$ O O O O O O $string$ O O O $string$ O O O O $string[]$ O O ${}$ O O O O $URL$ O $URLSearchParams$ O $void$ O O $string$ O $string$ O O O ${}$ O $string$ O O $string$ O O O O O $string$ O $string$ O $string$ O O $URL$ O $string$ O O O O $complex$ O O O O O O ${}$ O O O O O $void$ O $Protocol$ O O O O $any$ O $Protocol$ O $string$ O O O O $any$ O $ProtocolDomains.bot$ O O O $void$ O $Protocol$ O O O O O $any$ O $ProtocolDomains.livechat$ O O O $void$ O $Protocol$ O O O O O $any$ O $ProtocolDomains.transcript$ O O O $void$ O $Protocol$ O O O O O $any$ O $ProtocolDomains.inspector$ O O O $void$ O $Protocol$ O O O O O O O O O O O $void$ O $string$ O O O O $void$ O O O $Protocol$ O $string$ O O O O O $void$ O $Protocol$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Protocol$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O O O O $void$ O $Protocol$ O O O O $void$ O $Protocol$ O O O O $void$ O $Protocol$ O O O O $Promise<void>$ O $Protocol$ O O O O $void$ O $Protocol$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Protocol$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O O O O $void$ O $Protocol$ O O O O $any$ O O $Protocol$ O $any$ O O $complex$ O O $any$ O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O $boolean$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $JSON$ O $any$ O $any$ O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $any[]$ O $boolean$ O O O $string$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O $Promise$ O $Protocol$ O O O O O O O $string$ O $string$ O O O $string$ O O O $string$ O O O O $Protocol$ O $any$ O O $Partial$ O $any$ O O $any$ O $Protocol$ O $any$ O O O $BotConfigOverrides$ O $any$ O O $any$ O $any$ O O O O O $BotConfigWithPath$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $FrameworkSettings$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $NgrokService$ O $any$ O $Emulator$ O O O $NgrokService$ O O $complex$ O $NgrokService$ O $complex$ O O O O O O $complex$ O $boolean$ O O O $NgrokService$ O $Promise<void>$ O O O O $complex$ O $NgrokService$ O $complex$ O O O O O $complex$ O $boolean$ O $complex$ O $any$ O O O O $ErrorConstructor$ O O O O O O O $NgrokService$ O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $NgrokService$ O $any$ O $any$ O O O O O O $any[]$ O O O O O O $PromiseConstructor$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O O O O $string$ O O O $any$ O O O O O O O O $ProtocolHandlerImpl$ O O $any$ O O O O O $Partial$ O $complex$ O O O $string$ O O O O O O $any$ O O O O O $complex$ O O $ObjectConstructor$ O $complex$ O $complex$ O O $number$ O O O O O O O $Partial$ O $any$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O O $string$ O O $any$ O $any$ O $string$ O O O O $string$ O O $any$ O $any$ O $string$ O O O O $string$ O O $any$ O $any$ O $string$ O O O O $string$ O O $any$ O $any$ O $string$ O O O O O $ObjectConstructor$ O $complex$ O $any$ O O $number$ O O O O O O O $any$ O O
import * as path from 's' ; import { SharedConstants } from 's' ; import { CommandServiceImpl } from 's' ; import { TelemetryService } from 's' ; import { readFileSync } from 's' ; export async function openFileFromCommandLine ( fileToBeOpened , commandService ) < void > { const { Bot , Emulator } = SharedConstants . Commands ; if ( path . extname ( fileToBeOpened ) === 's' ) { try { const bot = await commandService . call ( Bot . Open , fileToBeOpened ) ; await commandService . call ( Bot . SetActive , bot ) ; await commandService . remoteCall ( Bot . Load , bot ) ; } catch ( e ) { throw new Error ( `template` ) ; } } else if ( path . extname ( fileToBeOpened ) === 's' ) { const transcript = readFileSync ( fileToBeOpened ) ; const conversationActivities = JSON . parse ( transcript ) ; if ( ! Array . isArray ( conversationActivities ) ) { throw new Error ( 's' ) ; } const transcriptName = path . basename ( fileToBeOpened ) ; await commandService . remoteCall ( Emulator . OpenTranscript , fileToBeOpened , transcriptName , { activities : conversationActivities , inMemory : true , } ) ; TelemetryService . trackEvent ( 's' , { method : 's' } ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O O $Promise$ O $string$ O $CommandServiceImpl$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $any$ O $any$ O $string$ O O O O O O $string$ O $string$ O $string$ O O O $any$ O $JSON$ O $any$ O $string$ O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any[]$ O $any[]$ O $boolean$ O O O O O O $any$ O $void$ O O O O $string$ O O O O O O O
import { FrameworkSettings } from 's' ; import { Action } from 's' ; export enum FrameworkActionType { SET_FRAMEWORK = 's' , PUSH_CLIENT_AWARE_SETTINGS = 's' , SAVE_FRAMEWORK_SETTINGS = 's' , } export interface FrameworkAction < P > extends Action { type : FrameworkActionType ; payload : P ; } export function setFrameworkSettings ( frameworkSettings ) < FrameworkSettings > { return { type : FrameworkActionType . SET_FRAMEWORK , payload : frameworkSettings , } ; } export function pushClientAwareSettings ( ) < void > { return { type : FrameworkActionType . PUSH_CLIENT_AWARE_SETTINGS , payload : undefined , } ; } export function saveFrameworkSettings ( payload ) < FrameworkSettings > { return { type : FrameworkActionType . SAVE_FRAMEWORK_SETTINGS , payload , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O O O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O O O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O O O O O O $any$ O $any$ O O $any$ O $FrameworkActionType$ O $any$ O $P$ O $any$ O O O O $FrameworkAction$ O $FrameworkSettings$ O O $any$ O O O O $FrameworkActionType.SET_FRAMEWORK$ O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O $any$ O $any$ O O O O O O $FrameworkAction$ O O O O O O O O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $any$ O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $undefined$ O $undefined$ O O O O O O $FrameworkAction$ O $FrameworkSettings$ O O $any$ O O O O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O $FrameworkActionType.SAVE_FRAMEWORK_SETTINGS$ O $any$ O O O O
import { WindowStateSettings } from 's' ; import { Action } from 's' ; export const REMEMBER_THEME = 's' ; export const REMEMBER_BOUNDS = 's' ; export const REMEMBER_ZOOM_LEVEL = 's' ; export const SET_AVAILABLE_THEMES = 's' ; export interface WindowStateAction < P > extends Action { type : WindowStateActionType ; payload ? : P ; } export declare type WindowStateActionType = | 's' | 's' | 's' | 's' | 's' ; export declare type WindowStatePayload = | RememberZoomLevelPayload | RememberBoundsPayload | RememberThemePayload | SetAvailableThemesPayload ; export interface RememberThemePayload { theme ? : string ; } export interface RememberBoundsPayload { displayId ? : number ; top ? : number ; left ? : number ; width ? : number ; height ? : number ; } export interface RememberZoomLevelPayload { zoomLevel ? : number ; } export interface SetAvailableThemesPayload { availableThemes ? : { name : string ; href : string } [ ] ; } export function rememberTheme ( theme ) < RememberThemePayload > { return { type : REMEMBER_THEME , payload : { theme , } , } ; } export function rememberBounds ( state ) < RememberBoundsPayload > { return { type : REMEMBER_BOUNDS , payload : state , } ; } export function rememberZoomLevel ( state ) < RememberZoomLevelPayload > { return { type : REMEMBER_ZOOM_LEVEL , payload : state , } ; } export function setAvailableThemes ( themes : { name : string ; href : string } [ ] ) < SetAvailableThemesPayload > { return { type : SET_AVAILABLE_THEMES , payload : { availableThemes : themes , } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $WindowStateActionType$ O $any$ O $P$ O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O O O O O O $any$ O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O O O O $any$ O $number$ O O O O O O O $any$ O $complex$ O O O $string$ O O O $string$ O O O O O O O O O $WindowStateAction$ O $string$ O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O $WindowStateAction$ O $WindowStateSettings$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $WindowStateAction$ O $WindowStateSettings$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $WindowStateAction$ O $complex$ O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O $complex$ O O O O O O
import { dialog } from 's' ; import { SharedConstants } from 's' ; import { Command , CommandServiceImpl , CommandServiceInstance } from 's' ; import * as BotActions from 's' ; import { Protocol } from 's' ; import { ExtensionManagerImpl } from 's' ; import { Migrator } from 's' ; import { ProtocolHandler } from 's' ; import { dispatch , getSettings , store } from 's' ; import { getBotsFromDisk , getThemes } from 's' ; import { openFileFromCommandLine } from 's' ; import { pushClientAwareSettings , setFrameworkSettings } from 's' ; import { AppMenuBuilder } from 's' ; import { setAvailableThemes , rememberTheme } from 's' ; const Commands = SharedConstants . Commands ; export class ClientInitCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Commands . ClientInit . Loaded ) protected async clientLoaded ( ) { const bots = getBotsFromDisk ( ) ; if ( bots . length ) { dispatch ( BotActions . load ( bots ) ) ; } else { await Migrator . startup ( ) ; } await this . commandService . call ( Commands . Electron . SetTitleBar ) ; await this . commandService . call ( Commands . Electron . SetFullscreen , false ) ; const { framework , windowState } = store . getState ( ) . settings ; dispatch ( rememberTheme ( windowState . theme ) ) ; dispatch ( setAvailableThemes ( getThemes ( ) ) ) ; dispatch ( setFrameworkSettings ( framework ) ) ; dispatch ( pushClientAwareSettings ( ) ) ; ExtensionManagerImpl . unloadExtensions ( ) ; ExtensionManagerImpl . loadExtensions ( ) ; } @ Command ( Commands . ClientInit . PostWelcomeScreen ) protected async postWelcomeScreen ( ) < void > { await this . commandService . call ( Commands . Electron . UpdateFileMenu ) ; const { framework = { } } = getSettings ( ) ; if ( ! framework . hasBeenShownDataCollectionModal ) { const collectUsageData = await this . commandService . remoteCall < boolean > ( Commands . UI . ShowDataCollectionDialog ) ; const updatedSettings = { ... framework , collectUsageData , hasBeenShownDataCollectionModal : true , } ; dispatch ( setFrameworkSettings ( updatedSettings ) ) ; } const args = process . argv . length ? process . argv . slice ( 0 ) : [ ] ; if ( args . some ( arg => arg . includes ( Protocol ) ) ) { const protocolArg = args . find ( arg => arg . includes ( Protocol ) ) ; ProtocolHandler . parseProtocolUrlAndDispatch ( protocolArg ) ; } const fileToBeOpened = args . find ( arg => "s" . test ( arg ) ) ; if ( fileToBeOpened ) { await openFileFromCommandLine ( fileToBeOpened , this . commandService ) ; } try { await AppMenuBuilder . initAppMenu ( ) ; } catch ( err ) { dialog . showErrorBox ( 's' , `template` ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O O O $ExtManagerImpl$ O O O O O O $any$ O O O O O O $ProtocolHandlerImpl$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any[]$ O $complex$ O O O O O O $Promise<void>$ O O O O O O $FrameworkAction<void>$ O $FrameworkAction<any>$ O O O O O O $any$ O O O O O O $WindowStateAction<SetAvailableThemesPayload>$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O $any[]$ O $any[]$ O O O O O $any[]$ O $number$ O O $any$ O $any$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O O O O O $any$ O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $WindowStateAction<RememberThemePayload>$ O $any$ O $any$ O O O $any$ O $WindowStateAction<SetAvailableThemesPayload>$ O $complex$ O O O O O $any$ O $FrameworkAction<any>$ O $any$ O O O $any$ O $FrameworkAction<void>$ O O O O $ExtManagerImpl$ O $void$ O O O $ExtManagerImpl$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O $any$ O $FrameworkAction<any>$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $any$ O O O O O $any$ O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O $any$ O $Promise<void>$ O O O O O O $any$ O O $any$ O $any$ O O O O O O O O O
export interface Subscription { authorizationSource : string ; displayName : string ; id : string ; state : string ; subscriptionId : string ; subscriptionPolicies : SubscriptionPolicy [ ] ; tenantId : string ; } export interface SubscriptionPolicy { locationPlacement : string ; quotaId : string ; spendingLimit : string ; } export interface AzureResource { etag ? : string ; id : string ; name : string ; tags ? : string ; type : string ; kind : string ; location ? : string ; properties : { [ prop ] : any } ; sku ? : SKU ; subscriptionId ? : string ; tenantId ? : string ; } export interface SKU { name : string ; tier ? : string ; } export enum Provider { ApplicationInsights = 's' , BotService = 's' , CognitiveServices = 's' , CosmosDB = 's' , Storage = 's' , } export enum AccountIdentifier { ApplicationInsights = 's' , CognitiveService = 's' , CosmosDb = 's' , BotServices = 's' , StorageAccounts = 's' , } const baseUrl = 's' ; export class AzureManagementApiService { public static getRequestInit ( armToken ) { return { headers : { Authorization : `template` , Accept : 's' , 's' : new Date ( ) . toUTCString ( ) , } , } ; } public static async getSubscriptions ( armToken ) < Subscription [ ] > { const url = `template` ; const subscriptionsResponse = await fetch ( url , AzureManagementApiService . getRequestInit ( armToken ) ) ; if ( ! subscriptionsResponse . ok ) { return null ; } const { value = [ ] } : { value : Subscription [ ] } = await subscriptionsResponse . json ( ) ; return value . length ? value : null ; } public static async getAzureResource ( armToken , subs : Subscription [ ] , provider , identifier , kind = 's' ) < AzureResource [ ] > { const url = `template` ; const req = AzureManagementApiService . getRequestInit ( armToken ) ; const calls = subs . map ( subscription => fetch ( url . replace ( 's' , subscription . id ) , req ) ) ; const accountsResponses : Response [ ] = await Promise . all ( calls ) ; const accounts : AzureResource [ ] = [ ] ; let i = accountsResponses . length ; while ( i -- ) { const { [ i ] : accountResponse } = accountsResponses ; const { [ i ] : subscription } = subs ; if ( accountResponse . ok ) { const accountResponseJson : { value : AzureResource [ ] ; } = await accountResponse . json ( ) ; const filteredValues = kind ? accountResponseJson . value . filter ( account => ( account . kind || 's' ) . includes ( kind ) ) : accountResponseJson . value ; filteredValues . forEach ( resource => { resource . tenantId = subscription . tenantId ; resource . subscriptionId = subscription . subscriptionId ; } ) ; accounts . push ( ... filteredValues ) ; } } return accounts . length ? accounts : null ; } public static async getKeysForAccounts ( armToken , accounts : AzureResource [ ] , apiVersion , responseProperty ) < string [ ] > { const keys : any [ ] = [ ] ; const req = AzureManagementApiService . getRequestInit ( armToken ) ; const url = `template` ; req . method = 's' ; const calls = accounts . map ( account => fetch ( url . replace ( 's' , account . id ) , req ) ) ; const keyResponses : Response [ ] = await Promise . all ( calls ) ; let i = keyResponses . length ; while ( i -- ) { const keyResponse = keyResponses [ i ] ; if ( keyResponse . ok ) { const keyResponseJson = await keyResponse . json ( ) ; const key = keyResponseJson [ responseProperty ] ; if ( key && 's' + key ) { keys [ i ] = key ; } } } return keys . length ? keys : null ; } }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $SubscriptionPolicy[]$ O $any$ O O O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O O $string$ O O O O O $SKU$ O O $any$ O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O $string$ O O O O O O O $any$ O $Provider.ApplicationInsights$ O O O $Provider.BotService$ O O O $Provider.CognitiveServices$ O O O $Provider.CosmosDB$ O O O $Provider.Storage$ O O O O O O $any$ O $AccountIdentifier.ApplicationInsights$ O O O $AccountIdentifier.CognitiveService$ O O O $AccountIdentifier.CosmosDb$ O O O $AccountIdentifier.BotServices$ O O O $AccountIdentifier.StorageAccounts$ O O O O O O O O O O O $any$ O O O $RequestInit$ O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $DateConstructor$ O O O $string$ O O O O O O O O O O O $Promise$ O $string$ O O $any$ O O O O O $string$ O O O O $Response$ O O $complex$ O $string$ O $any$ O $RequestInit$ O $string$ O O O O O O $Response$ O $boolean$ O O O O O O O O $Subscription[]$ O O O O O O $Subscription[]$ O $any$ O O O O O $Response$ O $Promise<any>$ O O O O $Subscription[]$ O $number$ O $Subscription[]$ O O O O O O O $Promise$ O $string$ O $Subscription[]$ O $any$ O O O $Provider$ O $AccountIdentifier$ O $string$ O O O O $any$ O O O O O $string$ O O O O $RequestInit$ O $any$ O $RequestInit$ O $string$ O O O $Promise<Response>[]$ O $Subscription[]$ O $U[]$ O $Subscription$ O $complex$ O $string$ O $complex$ O O O $Subscription$ O $string$ O O $RequestInit$ O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O O $AzureResource[]$ O $any$ O O O O O O O $number$ O $Response[]$ O $number$ O O O $number$ O O O O O O $number$ O O $Response$ O O $Response[]$ O O O O $number$ O O $Subscription$ O O $Subscription[]$ O O O $Response$ O $boolean$ O O O $complex$ O O $AzureResource[]$ O $any$ O O O O O O $Response$ O $Promise<any>$ O O O O $AzureResource[]$ O $string$ O $complex$ O $AzureResource[]$ O $complex$ O $AzureResource$ O O $AzureResource$ O $string$ O O O O $boolean$ O $string$ O O O $complex$ O $AzureResource[]$ O $AzureResource[]$ O $void$ O $AzureResource$ O O $AzureResource$ O $string$ O $Subscription$ O $string$ O $AzureResource$ O $string$ O $Subscription$ O $string$ O O O O $AzureResource[]$ O $number$ O O $AzureResource[]$ O O O O O $AzureResource[]$ O $number$ O $AzureResource[]$ O O O O O O O $Promise$ O $string$ O $AzureResource[]$ O $any$ O O O $string$ O $string$ O O O O O O O O $any[]$ O O O O O O O O O $RequestInit$ O $any$ O $RequestInit$ O $string$ O O O $string$ O O O $RequestInit$ O $string$ O O O O $Promise<Response>[]$ O $AzureResource[]$ O $U[]$ O $AzureResource$ O $complex$ O $string$ O $complex$ O O O $AzureResource$ O $string$ O O $RequestInit$ O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O O $number$ O $Response[]$ O $number$ O O O $number$ O O O O $Response$ O $Response[]$ O $number$ O O O O $Response$ O $boolean$ O O O $any$ O O $Response$ O $Promise<any>$ O O O O $any$ O $any$ O $string$ O O O O $any$ O O O $any$ O O $any[]$ O $number$ O O $any$ O O O O O $any[]$ O $number$ O $any[]$ O O O O O
import * as crypto from 's' ; import { ServiceCodes } from 's' ; import { CosmosDbService } from 's' ; import { AccountIdentifier , AzureManagementApiService , AzureResource , Provider } from 's' ; export class CosmosDbApiService { public static * getCosmosDbServices ( armToken ) < any > { const payload = { services : [ ] , code : ServiceCodes . OK } ; yield { label : 's' , progress : 0 } ; const subs = yield AzureManagementApiService . getSubscriptions ( armToken ) ; if ( ! subs ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const databaseAccounts : AzureResource [ ] = yield AzureManagementApiService . getAzureResource ( armToken , subs , Provider . CosmosDB , AccountIdentifier . CosmosDb ) ; if ( ! databaseAccounts ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const keys : string [ ] = yield AzureManagementApiService . getKeysForAccounts ( armToken , databaseAccounts , 's' , 's' ) ; if ( ! keys ) { payload . code = ServiceCodes . Error ; return payload ; } yield { label : 's' , progress : 0 } ; const cosmosDbRequests = databaseAccounts . map ( ( account , index ) => { const req = AzureManagementApiService . getRequestInit ( armToken ) ; req . headers [ 's' ] = 's' ; ( req . headers as any ) . Authorization = getAuthorizationTokenUsingMasterKey ( keys [ index ] ) ; return fetch ( `template` , req ) ; } ) ; const cosmosDbResponses : Response [ ] = yield Promise . all ( cosmosDbRequests ) ; const cosmosDbs = [ ] ; let i = cosmosDbResponses . length ; while ( i -- ) { const response = cosmosDbResponses [ i ] ; if ( ! response . ok ) { continue ; } const responseJson = yield response . json ( ) ; if ( responseJson . Databases || [ ] . length ) { responseJson . Databases . forEach ( db => cosmosDbs . push ( { db , account : databaseAccounts [ i ] } ) ) ; } } yield { label : 's' , progress : 0 } ; const collectionRequests = cosmosDbs . map ( info => { const { db , account } = info ; const { id , name , properties , subscriptionId } = account as AzureResource ; const req = AzureManagementApiService . getRequestInit ( armToken ) ; const resourceGroup = id . split ( 's' ) [ 0 ] ; const params = [ `template` , `template` , 's' , `template` , `template` , `template` , ] ; const proxyUrl = `template` ; return fetch ( proxyUrl , req ) ; } ) ; const collectionResponses = yield Promise . all ( collectionRequests ) ; i = collectionResponses . length ; while ( i -- ) { const collectionResponse = collectionResponses [ i ] ; if ( ! collectionResponse . ok ) { continue ; } const { db , account } = cosmosDbs [ i ] ; const collectionResponseJson = yield collectionResponse . json ( ) ; ( collectionResponseJson . DocumentCollections || [ ] ) . forEach ( collection => { payload . services . push ( buildServiceModel ( account , db , collection ) ) ; } ) ; } return payload ; } } function buildServiceModel ( account , cosmosDb , collection : { id : string ; _self : string } ) { const service = new CosmosDbService ( ) ; service . database = cosmosDb . id ; service . collection = collection . id ; service . endpoint = account . properties . documentEndpoint ; service . serviceName = account . name ; service . name = collection . id ; service . resourceGroup = account . id . split ( 's' ) [ 0 ] ; service . subscriptionId = account . subscriptionId ; service . tenantId = account . tenantId ; service . id = collection . _self ; return service ; } function getAuthorizationTokenUsingMasterKey ( masterKey = 's' , resourceId = 's' ) { const key = Buffer . from ( masterKey , 's' ) ; const text = 's' + 's' + resourceId + 's' + new Date ( ) . toUTCString ( ) . toLowerCase ( ) + 's' + 's' + 's' ; const body = Buffer . from ( text ) ; const signature = crypto . createHmac ( 's' , key ) . update ( body ) . digest ( 's' ) ; return encodeURIComponent ( 's' + signature ) ; }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $IterableIterator$ O $string$ O O O O O O $complex$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O $undefined$ O O $any$ O $Promise<Subscription[]>$ O $string$ O O O O O $undefined$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $AzureResource[]$ O $any$ O O O O $any$ O $Promise<AzureResource[]>$ O $string$ O $undefined$ O $any$ O $Provider.CosmosDB$ O $any$ O $AccountIdentifier.CosmosDb$ O O O O O $AzureResource[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $string[]$ O O O O O O $any$ O $Promise<string[]>$ O $string$ O $AzureResource[]$ O O O O O O O O O $string[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $Promise<Response>[]$ O $AzureResource[]$ O $U[]$ O O $AzureResource$ O $number$ O O O O $RequestInit$ O $any$ O $RequestInit$ O $string$ O O $RequestInit$ O $HeadersInit$ O O O O O O O $RequestInit$ O $HeadersInit$ O O O O $any$ O $string$ O $string[]$ O $number$ O O O O $complex$ O O O $RequestInit$ O O O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O O $any[]$ O O O O O $number$ O $Response[]$ O $number$ O O O $number$ O O O O $Response$ O $Response[]$ O $number$ O O O O O $Response$ O $boolean$ O O O O O O $undefined$ O O $Response$ O $Promise<any>$ O O O O O $undefined$ O $any$ O O O O $number$ O O $undefined$ O $any$ O $any$ O $any$ O $any[]$ O $number$ O O $any$ O $AzureResource$ O $AzureResource[]$ O $number$ O O O O O O O O O $string$ O O O $number$ O O O O O $Promise<Response>[]$ O $any[]$ O $U[]$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $string$ O $string$ O $complex$ O $string$ O O $any$ O $any$ O O $RequestInit$ O $any$ O $RequestInit$ O $string$ O O O $string$ O $string$ O $complex$ O O O O O O O O $string[]$ O O O O O O O O O O O O O O O O O $string$ O O O O $complex$ O $string$ O $RequestInit$ O O O O O O $undefined$ O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O $number$ O $undefined$ O $any$ O O O $number$ O O O O $Response$ O $undefined$ O $number$ O O O O O $Response$ O $boolean$ O O O O O O O $any$ O $any$ O O $any[]$ O $number$ O O O $undefined$ O O $Response$ O $Promise<any>$ O O O O $undefined$ O $any$ O O O O O $any$ O $any$ O O $complex$ O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O O O $CosmosDbService$ O $AzureResource$ O $AzureResource$ O $complex$ O O $string$ O O O $string$ O O O O O O $any$ O O $any$ O O O $any$ O $any$ O $AzureResource$ O $string$ O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O $AzureResource$ O $complex$ O $any$ O $any$ O $any$ O $AzureResource$ O $string$ O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O $AzureResource$ O $string$ O $complex$ O O O O O O O $any$ O $any$ O $AzureResource$ O $string$ O $any$ O $any$ O $AzureResource$ O $string$ O $any$ O $any$ O $complex$ O $string$ O O $any$ O O O $string$ O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O $string$ O O O O O $string$ O O O O $DateConstructor$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O O O $string$ O O O $any$ O O O
import { LuisModel , LuisRegion , ServiceCodes } from 's' ; import { ILuisService , ServiceTypes } from 's' ; export class LuisApi { public static * getServices ( armToken ) < any > { const payload = { services : [ ] , code : ServiceCodes . OK } ; const req = { headers : { Authorization : `template` } , } ; let authoringKeys : string [ ] ; try { yield { label : 's' , progress : 0 } ; const urls = [ 's' , 's' , 's' , ] ; const requests = urls . map ( url => fetch ( url , req ) ) ; const authoringKeyResponses : Response [ ] = yield Promise . all ( requests ) ; authoringKeys = yield Promise . all ( authoringKeyResponses . map ( async response => await response . json ( ) ) ) ; } catch ( e ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const luisApiPromises : Promise < LuisModel [ ] | { error : any } > [ ] = [ ] ; const regions : LuisRegion [ ] = [ 's' , 's' , 's' ] ; let i = regions . length ; while ( i -- ) { if ( typeof authoringKeys [ i ] === 's' ) { continue ; } luisApiPromises . push ( LuisApi . getApplicationsForRegion ( regions [ i ] , authoringKeys [ i ] ) ) ; } const results = yield Promise . all ( luisApiPromises ) ; const luisModels = results . filter ( result => ! ( 's' in result ) ) . reduce ( ( agg : LuisModel [ ] , models ) => ( agg . push ( ... ( models as LuisModel [ ] ) ) , agg ) , [ ] ) as LuisModel [ ] ; payload . services = luisModels . map ( ( luisModel ) : ILuisService => { const authoringKey = authoringKeys [ regions . indexOf ( luisModel . region ) ] ; return { authoringKey , appId : luisModel . id , id : luisModel . id , name : luisModel . name , subscriptionKey : authoringKey , type : luisModel . activeVersion === 's' ? ServiceTypes . Dispatch : ServiceTypes . Luis , version : luisModel . activeVersion , region : luisModel . region , getEndpoint : ( ) => luisModel . region , } ; } ) as ILuisService [ ] ; return payload ; } public static async getApplicationsForRegion ( region , key ) < LuisModel [ ] | { error : any } > { const url = `template` ; const headers = { 's' : 's' , 's' : key , } ; const response = await fetch ( url , { headers , method : 's' , } as any ) ; if ( ! response . ok ) { const error = await response . json ( ) ; return { error } ; } const luisModels = ( await response . json ( ) ) as LuisModel [ ] ; if ( luisModels instanceof Array ) { return luisModels . map ( luisModel => ( ( luisModel . region = region ) , luisModel ) ) ; } return luisModels ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $IterableIterator$ O $string$ O O O O O O $complex$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O O O $RequestInit$ O O $complex$ O O $string$ O O O O O O O $string[]$ O O O O O O O O O $string$ O O O $number$ O O O O O $string[]$ O O O O O O O O O O O $Promise<Response>[]$ O $string[]$ O $U[]$ O $string$ O $complex$ O $string$ O $RequestInit$ O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O $string[]$ O O $PromiseConstructor$ O O O $Response[]$ O $U[]$ O O $Response$ O O $Response$ O $Promise<any>$ O O O O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $complex$ O $PromiseConstructor$ O $any$ O O O O $any$ O O O O O O O O O O O $any[]$ O $any$ O O O O O O O O O O O O $number$ O $any[]$ O $number$ O O O $number$ O O O O O O $string[]$ O $number$ O O O O O O O O $complex$ O $number$ O $any$ O $complex$ O $any[]$ O $number$ O O $string[]$ O $number$ O O O O O O $undefined$ O O $PromiseConstructor$ O O O $complex$ O O O $any[]$ O $undefined$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any[]$ O $any$ O O O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O O O $any[]$ O O O O O O $any$ O O O $complex$ O $any[]$ O $any[]$ O $U[]$ O O $LuisModel$ O O $any$ O O O $string$ O $string[]$ O $any[]$ O $number$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $complex$ O O O O O $Promise$ O $LuisRegion$ O $string$ O O $any$ O O O O $any$ O O O O O O $string$ O O O O $complex$ O O O O O O O O $string$ O O O O $Response$ O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O O O $Response$ O $boolean$ O O O $any$ O O $Response$ O $Promise<any>$ O O O O O $any$ O O O O $any[]$ O O O $Response$ O $Promise<any>$ O O O O $any$ O O O O O $any[]$ O $ArrayConstructor$ O O O $any[]$ O $U[]$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $never$ O O O
import { ServiceCodes } from 's' ; import { QnaMakerService } from 's' ; import { AccountIdentifier , AzureManagementApiService , AzureResource , Provider , Subscription , } from 's' ; export interface KnowledgeBase { hostName : string ; id : string ; lastAccessedTimestamp : string ; lastChangedTimestamp : string ; lastPublishedTimestamp : string ; name : string ; sources : string [ ] ; urls : string [ ] ; userId : string ; } export class QnaApiService { public static * getKnowledgeBases ( armToken ) < any > { const payload = { services : [ ] , code : ServiceCodes . OK } ; yield { label : 's' , progress : 0 } ; const subs : Subscription [ ] = yield AzureManagementApiService . getSubscriptions ( armToken ) ; if ( ! subs ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const accounts : AzureResource [ ] = yield AzureManagementApiService . getAzureResource ( armToken , subs , Provider . CognitiveServices , AccountIdentifier . CognitiveService , 's' ) ; if ( ! accounts ) { payload . code = ServiceCodes . Error ; return payload ; } yield { label : 's' , progress : 0 } ; const subscriptionKeys : string [ ] = yield AzureManagementApiService . getKeysForAccounts ( armToken , accounts , 's' , 's' ) ; if ( ! subscriptionKeys ) { payload . code = ServiceCodes . Error ; return payload ; } yield { label : 's' , progress : 0 } ; const endpointKeyUrl = 's' ; const kbUrl = 's' ; const calls = subscriptionKeys . map ( key => { const qnaReq = { headers : { 's' : key , 's' : 's' , } , } ; return Promise . all < Response > ( [ fetch ( endpointKeyUrl , qnaReq ) , fetch ( kbUrl , qnaReq ) ] ) ; } ) ; const kbResponses : [ Response , Response ] [ ] = yield Promise . all < Response [ ] > ( calls ) ; let i = kbResponses . length ; while ( i -- ) { const [ endpointKeyResponse , kbResponse ] = kbResponses [ i ] ; if ( ! endpointKeyResponse . ok || ! kbResponse . ok ) { continue ; } const { primaryEndpointKey , } : { primaryEndpointKey : string ; } = yield endpointKeyResponse . json ( ) ; const { knowledgebases , } : { knowledgebases : KnowledgeBase [ ] ; } = yield kbResponse . json ( ) ; const subscriptionKey = subscriptionKeys [ i ] ; const qnas = knowledgebases . map ( kb => knowledgeBaseToQnaService ( kb , subscriptionKey , primaryEndpointKey ) ) ; payload . services . push ( ... qnas ) ; } return payload ; } } function knowledgeBaseToQnaService ( kb , subscriptionKey , endpointKey ) { return new QnaMakerService ( { id : kb . id , kbId : kb . id , name : kb . name , subscriptionKey , endpointKey , hostname : kb . hostName || 's' , } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O $string$ O O O O O O $any$ O O O O $IterableIterator$ O $string$ O O O O O O $complex$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O $Subscription[]$ O $any$ O O O O $any$ O $Promise<Subscription[]>$ O $string$ O O O O O $Subscription[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $AzureResource[]$ O $any$ O O O O $any$ O $Promise<AzureResource[]>$ O $string$ O $Subscription[]$ O $any$ O $Provider.CognitiveServices$ O $any$ O $AccountIdentifier.CognitiveService$ O O O O O O O $AzureResource[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $string[]$ O O O O O O $any$ O $Promise<string[]>$ O $string$ O $AzureResource[]$ O O O O O O O O O $string[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O O O O O O O O O O O $Promise<Response[]>[]$ O $string[]$ O $U[]$ O $string$ O O O $RequestInit$ O O $complex$ O O O O $string$ O O O O O O O O O O $PromiseConstructor$ O O O $complex$ O O O $complex$ O O O $RequestInit$ O O $complex$ O O O $RequestInit$ O O O O O O O O $complex$ O O $complex$ O $complex$ O O O O O $PromiseConstructor$ O O O $complex$ O O O O $Promise<Response[]>[]$ O O O $number$ O $complex$ O $number$ O O O $number$ O O O O O $Response$ O $Response$ O O $complex$ O $number$ O O O O O $Response$ O $boolean$ O O $Response$ O $boolean$ O O O O O O O $string$ O O O O $string$ O O O O O O $Response$ O $Promise<any>$ O O O O O $KnowledgeBase[]$ O O O O $KnowledgeBase[]$ O $any$ O O O O O O $Response$ O $Promise<any>$ O O O O $string$ O $string[]$ O $number$ O O O $any[]$ O $KnowledgeBase[]$ O $U[]$ O $KnowledgeBase$ O $any$ O $KnowledgeBase$ O $string$ O $string$ O O O $complex$ O $any[]$ O $number$ O O $any[]$ O O O O $complex$ O O O O $QnaMakerService$ O $KnowledgeBase$ O $string$ O $string$ O O O O $any$ O O $string$ O $KnowledgeBase$ O $string$ O $string$ O $KnowledgeBase$ O $string$ O $string$ O $KnowledgeBase$ O $string$ O $string$ O $string$ O $string$ O $KnowledgeBase$ O $string$ O O O O O O O
import { ServiceCodes } from 's' ; import { BlobStorageService } from 's' ; import { AccountIdentifier , AzureManagementApiService , AzureResource , Provider } from 's' ; interface KeyEntry { keyName : string ; value : string ; permission : string ; } function buildServiceModel ( key , account , container ) { const { tenantId , subscriptionId , name : serviceName } = account ; const { id , name } = container ; return new BlobStorageService ( { id , tenantId , subscriptionId , name , connectionString : `template` + 's' , resourceGroup : id . split ( 's' ) [ 0 ] , serviceName , container : name , } ) ; } export class StorageAccountApiService { public static * getBlobStorageServices ( armToken ) < any > { const payload = { services : [ ] , code : ServiceCodes . OK } ; yield { label : 's' , progress : 0 } ; const subs = yield AzureManagementApiService . getSubscriptions ( armToken ) ; if ( ! subs ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const accounts : AzureResource [ ] = yield AzureManagementApiService . getAzureResource ( armToken , subs , Provider . Storage , AccountIdentifier . StorageAccounts ) ; if ( ! accounts ) { payload . code = ServiceCodes . AccountNotFound ; return payload ; } yield { label : 's' , progress : 0 } ; const req = AzureManagementApiService . getRequestInit ( armToken ) ; const url = 's' ; const requests = accounts . map ( account => fetch ( url . replace ( 's' , account . id ) , req ) ) ; const blobContainerResponses : Response [ ] = yield Promise . all ( requests ) ; const blobContainerInfos : { account : AzureResource ; containers : AzureResource [ ] ; } [ ] = [ ] ; let i = blobContainerResponses . length ; while ( i -- ) { const blobContainerResponse = blobContainerResponses [ i ] ; if ( ! blobContainerResponse . ok ) { continue ; } const blobContainerJson : { value : any [ ] ; } = yield blobContainerResponse . json ( ) ; if ( blobContainerJson . value . length ) { blobContainerInfos . push ( { account : accounts [ i ] , containers : blobContainerJson . value , } ) ; } } yield { label : 's' , progress : 0 } ; const keys : KeyEntry [ ] [ ] = yield AzureManagementApiService . getKeysForAccounts ( armToken , blobContainerInfos . map ( info => info . account ) , 's' , 's' ) ; i = keys . length ; while ( i -- ) { const keysEntry = keys [ i ] ; if ( ! keysEntry ) { continue ; } const firstKey = keysEntry [ 0 ] ; const { account , containers } = blobContainerInfos [ i ] ; const blobStorageServices = containers . map ( container => buildServiceModel ( firstKey , account , container ) ) ; payload . services . push ( ... blobStorageServices ) ; } return payload ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O $BlobStorageService$ O $KeyEntry$ O $AzureResource$ O $AzureResource$ O O O O $string$ O $string$ O $string$ O $string$ O O $AzureResource$ O O O $string$ O $string$ O O $AzureResource$ O O O $any$ O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O $string$ O $string$ O $complex$ O O O O O O O $string$ O $string$ O $string$ O O O O O O O $any$ O O O O $IterableIterator$ O $string$ O O O O O O $complex$ O O $undefined[]$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O $undefined$ O O $any$ O $Promise<Subscription[]>$ O $string$ O O O O O $undefined$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $AzureResource[]$ O $any$ O O O O $any$ O $Promise<AzureResource[]>$ O $string$ O $undefined$ O $any$ O $Provider.Storage$ O $any$ O $AccountIdentifier.StorageAccounts$ O O O O O $AzureResource[]$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O $string$ O O O $number$ O O O O O $RequestInit$ O $any$ O $RequestInit$ O $string$ O O O O O O O O $Promise<Response>[]$ O $AzureResource[]$ O $U[]$ O $AzureResource$ O $complex$ O O O $complex$ O O O $AzureResource$ O $string$ O O $RequestInit$ O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O O $complex$ O O $AzureResource$ O $any$ O $AzureResource[]$ O $any$ O O O O O O O O O O O $number$ O $Response[]$ O $number$ O O O $number$ O O O O $Response$ O $Response[]$ O $number$ O O O O O $Response$ O $boolean$ O O O O O O $complex$ O O $any[]$ O O O O O O O O $Response$ O $Promise<any>$ O O O O O $complex$ O $any[]$ O $number$ O O $complex$ O $number$ O O $AzureResource$ O $AzureResource[]$ O $number$ O O $any[]$ O $complex$ O $any[]$ O O O O O O O O $string$ O O O $number$ O O O O O $KeyEntry[][]$ O $any$ O O O O O O $any$ O $Promise<string[]>$ O $string$ O $complex$ O $U[]$ O $complex$ O $complex$ O $AzureResource$ O O O O O O O $number$ O $KeyEntry[][]$ O $number$ O O O $number$ O O O O $KeyEntry[]$ O $KeyEntry[][]$ O $number$ O O O O O $KeyEntry[]$ O O O O O O $KeyEntry$ O $KeyEntry[]$ O O O O O O $AzureResource$ O $AzureResource[]$ O O $complex$ O $number$ O O O $any[]$ O $AzureResource[]$ O $U[]$ O $AzureResource$ O $any$ O $KeyEntry$ O $AzureResource$ O $AzureResource$ O O O $complex$ O $any[]$ O $number$ O O $any[]$ O O O O $complex$ O O O
import { SharedConstants } from 's' ; import { Command , CommandServiceImpl , CommandServiceInstance } from 's' ; import { IConnectedService , ServiceTypes } from 's' ; import { CosmosDbApiService } from 's' ; import { LuisApi } from 's' ; import { QnaApiService } from 's' ; import { StorageAccountApiService } from 's' ; const { ConnectedService , UI } = SharedConstants . Commands ; export class ConnectedServiceCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( ConnectedService . GetConnectedServicesByType ) protected async getConnectedServicesByType ( armToken , serviceType ) < { services : IConnectedService [ ] } > { let it ; switch ( serviceType ) { case ServiceTypes . Luis : case ServiceTypes . Dispatch : it = LuisApi . getServices ( armToken ) ; break ; case ServiceTypes . QnA : it = QnaApiService . getKnowledgeBases ( armToken ) ; break ; case ServiceTypes . BlobStorage : it = StorageAccountApiService . getBlobStorageServices ( armToken ) ; break ; case ServiceTypes . CosmosDB : it = CosmosDbApiService . getCosmosDbServices ( armToken ) ; break ; default : throw new TypeError ( `template` ) ; } let result : { services : IConnectedService [ ] } ; while ( true ) { const next = it . next ( result ) ; if ( next . done ) { result = next . value ; break ; } try { result = await next . value ; if ( typeof result === 's' && 's' in result && 's' in result ) { await this . commandService . remoteCall ( UI . UpdateProgressIndicator , result ) ; } } catch ( e ) { break ; } } result . services = result . services . filter ( service => service . type === serviceType ) ; return result ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $Promise$ O $string$ O $ServiceTypes$ O O O $any[]$ O $any$ O O O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $IterableIterator<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $IterableIterator<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $IterableIterator<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $IterableIterator<any>$ O $string$ O O O O O O O O $TypeErrorConstructor$ O O O O O O $complex$ O O $any[]$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O O $complex$ O O $any$ O $any$ O O O O $complex$ O O O O O $complex$ O O O $never$ O O O O O $any$ O $any$ O $any$ O $any$ O $never$ O O O O O O $any$ O O O O O O $complex$ O $any[]$ O $complex$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O
import { Menu , MenuItem , MenuItemConstructorOptions } from 's' ; export class ContextMenuService { private static currentMenu : Menu ; public static showMenuAndWaitForInput ( options : Partial < MenuItemConstructorOptions > [ ] = [ ] ) < MenuItem > { if ( ContextMenuService . currentMenu ) { ContextMenuService . currentMenu . closePopup ( ) ; } return new Promise ( resolve => { const clickHandler = menuItem => { ContextMenuService . currentMenu = null ; resolve ( menuItem ) ; } ; const template = options . map ( option => { option . click = clickHandler ; return option ; } ) ; const menu = ( ContextMenuService . currentMenu = Menu . buildFromTemplate ( template ) ) ; menu . popup ( { } ) ; } ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O $Promise$ O $any[]$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $void$ O O O $void$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O O O O O $any[]$ O $any[]$ O $U[]$ O $any$ O O $any$ O $any$ O $void$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O $any$ O $any$ O O O O O O O O O O
import * as path from 's' ; import * as fs from 's' ; import * as Electron from 's' ; import { app , dialog , Menu , MessageBoxOptions } from 's' ; import { SharedConstants } from 's' ; import { Command } from 's' ; import { AppMenuBuilder } from 's' ; import { store } from 's' ; import { emulatorApplication } from 's' ; import { ContextMenuService } from 's' ; import { TelemetryService } from 's' ; import { showOpenDialog , showSaveDialog } from 's' ; import { AppUpdater } from 's' ; const { shell } = Electron ; const Commands = SharedConstants . Commands . Electron ; export class ElectronCommands { @ Command ( Commands . ShowMessageBox ) protected showMessageBox ( modal , options ) { options = { message : 's' , title : app . getName ( ) , ... options , } ; const args = modal ? [ emulatorApplication . mainWindow . browserWindow , options ] : [ options ] ; return dialog . showMessageBox . apply ( dialog , args ) ; } @ Command ( Commands . ShowOpenDialog ) protected showOpenDialog ( dialogOptions : Electron . OpenDialogOptions = { } ) : false | string { return showOpenDialog ( emulatorApplication . mainWindow . browserWindow , dialogOptions ) ; } @ Command ( Commands . ShowSaveDialog ) protected showSaveDialogWithOptions ( dialogOptions : Electron . SaveDialogOptions = { } ) { return showSaveDialog ( emulatorApplication . mainWindow . browserWindow , dialogOptions ) ; } @ Command ( Commands . UpdateFileMenu ) protected async updateFileMenu ( ) < void > { AppMenuBuilder . refreshFileMenu ( ) ; const state = store . getState ( ) ; const recentBots = state . bot && state . bot . botFiles ? state . bot . botFiles : [ ] ; AppMenuBuilder . updateRecentBotsList ( recentBots ) ; } @ Command ( Commands . UpdateConversationMenu ) protected async updateConversationMenu ( clientEditorState ) < void > { const sendActivityMenuItems = AppMenuBuilder . sendActivityMenuItems ; let enabled = false ; const { editors = { } , activeEditor = 's' } = clientEditorState ; const { activeDocumentId = 's' } = editors [ activeEditor ] || { } ; if ( activeDocumentId && editors [ activeEditor ] && editors [ activeEditor ] . documents ) { const activeDocument = editors [ activeEditor ] . documents [ activeDocumentId ] ; const { contentType = 's' } = activeDocument ; enabled = contentType && contentType === SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT ; } sendActivityMenuItems . forEach ( item => { item . enabled = enabled ; } ) ; } @ Command ( Commands . SetFullscreen ) protected async setFullScreen ( fullscreen ) < void > { emulatorApplication . mainWindow . browserWindow . setFullScreen ( fullscreen ) ; if ( fullscreen ) { Menu . setApplicationMenu ( null ) ; } else { await AppMenuBuilder . initAppMenu ( ) ; } } @ Command ( Commands . SetTitleBar ) protected setTitleBar ( text ) { if ( text && text . length ) { emulatorApplication . mainWindow . browserWindow . setTitle ( app . getName ( ) + 's' + text ) ; } else { emulatorApplication . mainWindow . browserWindow . setTitle ( app . getName ( ) ) ; } } @ Command ( Commands . DisplayContextMenu ) protected displayContextMenu ( ... args ) { return ContextMenuService . showMenuAndWaitForInput ( ... args ) ; } @ Command ( Commands . FetchRemote ) protected async fetchRemote ( url , requestInit ) { const response : { buffer ? : ( ) => Promise < ArrayBuffer > ; arrayBuffer ? : ( ) => Promise < ArrayBuffer > ; ok : boolean ; } = await fetch ( url , requestInit ) ; let buffer ; if ( response . ok ) { try { buffer = await response . arrayBuffer ( ) ; return new 0 ( buffer ) ; } catch { } try { buffer = await response . buffer ( ) ; return new 0 ( buffer ) ; } catch { } } return null ; } @ Command ( Commands . OpenExternal ) protected openExternal ( url ) { TelemetryService . trackEvent ( 's' , { url } ) ; shell . openExternal ( url , { activate : true } ) ; } @ Command ( Commands . OpenFileLocation ) protected openFileLocation ( filePath ) { const parts = path . parse ( filePath ) ; return shell . openItem ( path . resolve ( parts . dir ) ) ; } @ Command ( Commands . UnlinkFile ) protected unlinkFile ( filePath ) { return shell . moveItemToTrash ( path . resolve ( filePath ) ) ; } @ Command ( Commands . RenameFile ) protected async renameFile ( info : { path : string ; newPath : string ; name : string } ) { const { path : existingPath , newPath } = info ; let { name } = info ; const exists = await fs . pathExists ( existingPath ) ; if ( ! exists ) { throw new ReferenceError ( `template` ) ; } const parts = path . parse ( newPath || existingPath ) ; if ( ! name ) { name = parts . base ; } const nameHasExt = path . extname ( name ) ; let fullPath = `template` ; if ( ! nameHasExt ) { fullPath += parts . ext ; } return fs . rename ( existingPath , fullPath ) ; } @ Command ( Commands . ToggleDevTools ) protected toggleDevTools ( ) { emulatorApplication . mainBrowserWindow . webContents . toggleDevTools ( ) ; } @ Command ( Commands . QuitAndInstall ) protected quitAndInstall ( ) { AppUpdater . quitAndInstall ( ) ; } @ Command ( Commands . CheckForUpdates ) protected checkForUpdates ( userInitiated = true ) { AppUpdater . checkForUpdates ( userInitiated ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O $string$ O O O O O O $EmulatorUpdater$ O O O O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $boolean$ O $MessageBoxOptions$ O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any[]$ O $boolean$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O O O O O O O O O $complex$ O $EmulatorApplication$ O $Window$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $any$ O $any$ O $any$ O O O O O O $string$ O $EmulatorApplication$ O $Window$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise$ O O O O O O $any$ O $void$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Promise$ O $any$ O O O O O O $any[]$ O $any$ O $any[]$ O O $boolean$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $void$ O $any$ O O $any$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $Promise$ O $boolean$ O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $boolean$ O O O O $boolean$ O O $any$ O $any$ O O O O O O O O $any$ O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O O O $string$ O $string$ O $number$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $Promise<any>$ O O $any[]$ O O O $any$ O $Promise<any>$ O O $any[]$ O O O O $any$ O $any$ O $any$ O O O O O $string$ O $RequestInit$ O O O $complex$ O O $Promise<ArrayBuffer>$ O O O O O $PromiseConstructor$ O $ArrayBufferConstructor$ O O $Promise<ArrayBuffer>$ O O O O O $PromiseConstructor$ O $ArrayBufferConstructor$ O O $boolean$ O O O O O O $complex$ O $string$ O $RequestInit$ O O O $ArrayBuffer$ O O O $complex$ O $boolean$ O O O O $ArrayBuffer$ O O $complex$ O $Promise<ArrayBuffer>$ O O O O O O O $ArrayBuffer$ O O O O O O O O $ArrayBuffer$ O O $complex$ O $Promise<ArrayBuffer>$ O O O O O O O $ArrayBuffer$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O $any$ O $void$ O O O O $string$ O O O $any$ O $any$ O $string$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O $Promise<any>$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O $string$ O $string$ O O $complex$ O O O $string$ O O $complex$ O O $any$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O $ReferenceErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O $string$ O O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O O $string$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O $string$ O O O O $any$ O $any$ O $any$ O O $void$ O O O $EmulatorApplication$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $void$ O O O $EmulatorUpdater$ O $void$ O O O O O $any$ O $any$ O $any$ O O $void$ O $boolean$ O O O O $EmulatorUpdater$ O $Promise<void>$ O $boolean$ O O O O
import { User } from 's' ; import { Action } from 's' ; export const SET_CURRENT_USER = 's' ; export const ADD_USERS = 's' ; export const REMOVE_USERS = 's' ; export interface UserAction < P > extends Action { type : UserActionType ; payload : P ; } export interface UserPayload { user ? : User ; users ? : User [ ] ; } export declare type UserActionType = 's' | 's' | 's' ; export function addUsers ( users : User [ ] ) < UserPayload > { return { type : ADD_USERS , payload : { users } , } ; } export function removeUsers ( users : User [ ] ) < UserPayload > { return { type : REMOVE_USERS , payload : { users } , } ; } export function setCurrentUser ( user ) < UserPayload > { return { type : SET_CURRENT_USER , payload : { user } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $UserActionType$ O $any$ O $P$ O $any$ O O O O $any$ O $any$ O O $any$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O $UserAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O O O $complex$ O O $any[]$ O O O O O O O $UserAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O O O $complex$ O O $any[]$ O O O O O O O $UserAction$ O $User$ O O $any$ O O O O O O O O $complex$ O O $any$ O O O O O
import { store } from 's' ; export function getCurrentConversationId ( ) { const state = store . getState ( ) ; if ( ! state . editor ) { return 's' ; } const { editors , activeEditor } = state . editor ; const { activeDocumentId } = editors [ activeEditor ] ; return state . chat . chats [ activeDocumentId ] . conversationId ; }	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O
import { Emulator } from 's' ; export function getLocalhostServiceUrl ( ) { return Emulator . getInstance ( ) . framework . serverUrl . replace ( 's' , 's' ) ; }	O O $any$ O O O O O O $string$ O O O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $string$ O $complex$ O O O O O O O
import * as path from 's' ; import { newBot , newEndpoint , SharedConstants } from 's' ; import { Conversation , Users } from 's' ; import { BotConfigWithPath , Command , CommandServiceImpl , CommandServiceInstance , ConversationService , } from 's' ; import * as fs from 's' ; import { sync as mkdirpSync } from 's' ; import { session } from 's' ; import * as BotActions from 's' ; import { BotHelpers } from 's' ; import { Emulator } from 's' ; import { emulatorApplication } from 's' ; import { dispatch , store , getSettings } from 's' ; import { parseActivitiesFromChatFile , readFileSync , showSaveDialog , writeFile } from 's' ; import { cleanupId as cleanupActivityChannelAccountId , CustomActivity } from 's' ; import { botProjectFileWatcher } from 's' ; import { TelemetryService } from 's' ; import { setCurrentUser } from 's' ; import { pushClientAwareSettings } from 's' ; import { ProtocolHandler } from 's' ; import { CredentialManager } from 's' ; import { getCurrentConversationId } from 's' ; import { getLocalhostServiceUrl } from 's' ; const Commands = SharedConstants . Commands . Emulator ; export class EmulatorCommands { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; @ Command ( Commands . SaveTranscriptToFile ) protected async saveTranscriptToFile ( valueTypes , conversationId ) < void > { const activeBot = BotHelpers . getActiveBot ( ) ; const conversation = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . conversationById ( conversationId ) ; if ( ! conversation ) { throw new Error ( `template` ) ; } let botInfo = activeBot ? BotHelpers . getBotInfoByPath ( activeBot . path ) : { } ; const filename = showSaveDialog ( emulatorApplication . mainWindow . browserWindow , { filters : [ { name : 's' , extensions : [ 's' ] , } , ] , defaultPath : BotHelpers . getTranscriptsPath ( activeBot , conversation ) , showsTagField : false , title : 's' , buttonLabel : 's' , } ) ; if ( filename && filename . length ) { mkdirpSync ( path . dirname ( filename ) ) ; const transcripts = await conversation . getTranscript ( valueTypes ) ; writeFile ( filename , transcripts ) ; TelemetryService . trackEvent ( 's' ) ; } if ( ! activeBot ) { return ; } const { currentBotDirectory } = store . getState ( ) . bot ; if ( ! currentBotDirectory && filename && filename . length ) { const secret = await CredentialManager . getPassword ( activeBot . path ) ; const saveableBot = BotHelpers . toSavableBot ( activeBot , secret ) ; const botDirectory = path . dirname ( filename ) ; const botPath = path . join ( botDirectory , `template` ) ; botInfo = { ... botInfo , path : botPath } ; await saveableBot . save ( botPath ) ; BotHelpers . patchBotsJson ( botPath , botInfo ) ; await botProjectFileWatcher . watch ( botPath ) ; store . dispatch ( BotActions . setDirectory ( botDirectory ) ) ; } } @ Command ( Commands . FeedTranscriptFromDisk ) protected async fedTranscriptFromDisk ( conversationId , botId , userId , filePath ) { const transcriptPath = path . resolve ( filePath ) ; const stat = await fs . stat ( transcriptPath ) ; if ( ! stat || ! stat . isFile ( ) ) { throw new Error ( `template` ) ; } const activities = JSON . parse ( readFileSync ( transcriptPath ) ) ; await this . commandService . call ( Commands . FeedTranscriptFromMemory , conversationId , botId , userId , activities ) ; const { name , ext } = path . parse ( transcriptPath ) ; const fileName = `template` ; return { fileName , filePath , } ; } @ Command ( Commands . FeedTranscriptFromMemory ) protected feedTranscriptFromMemory ( conversationId , botId , userId , activities : CustomActivity [ ] ) { const activeBot = BotHelpers . getActiveBot ( ) ; if ( ! activeBot ) { throw new Error ( 's' ) ; } const convo = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . conversationById ( conversationId ) ; if ( ! convo ) { throw new Error ( `template` ) ; } activities = cleanupActivityChannelAccountId ( activities , botId , userId ) ; convo . feedActivities ( activities ) ; } @ Command ( Commands . GetSpeechToken ) protected getSpeechToken ( endpointId , refresh ) { const endpoint = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . endpoints . get ( endpointId ) ; return endpoint && endpoint . getSpeechToken ( refresh ) ; } @ Command ( Commands . NewTranscript ) protected newTranscript ( conversationId ) { let bot = BotHelpers . getActiveBot ( ) ; if ( ! bot ) { bot = newBot ( ) ; bot . services . push ( newEndpoint ( ) ) ; dispatch ( BotActions . mockAndSetActive ( bot ) ) ; } const emulator = Emulator . getInstance ( ) ; return emulator . framework . server . botEmulator . facilities . conversations . newConversation ( emulator . framework . server . botEmulator , null , { id : getSettings ( ) . users . currentUserId , name : 's' } , conversationId ) ; } @ Command ( Commands . OpenChatFile ) protected async openChatFile ( filePath ) < { activities : CustomActivity [ ] ; fileName : string } > { try { const activities = await parseActivitiesFromChatFile ( filePath ) ; const { name , ext } = path . parse ( filePath ) ; const fileName = `template` ; return { activities , fileName } ; } catch ( err ) { throw new Error ( `template` ) ; } } @ Command ( Commands . SetCurrentUser ) protected async setCurrentUser ( userId ) { const { facilities } = Emulator . getInstance ( ) . framework . server . botEmulator ; const { users } = facilities ; const user = { id : userId , name : 's' } ; users . currentUserId = userId ; users . users [ userId ] = user ; facilities . users = users ; dispatch ( setCurrentUser ( user ) ) ; dispatch ( pushClientAwareSettings ( ) ) ; } @ Command ( Commands . DeleteConversation ) protected deleteConversation ( conversationId ) { return Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . deleteConversation ( conversationId ) ; } @ Command ( Commands . PostActivityToConversation ) protected postActivityToConversation ( conversationId , activity , toUser ) { const conversation = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . conversationById ( conversationId ) ; if ( toUser ) { return conversation . postActivityToUser ( activity , false ) ; } else { return conversation . postActivityToBot ( activity , false ) ; } } @ Command ( Commands . StartEmulator ) protected async startEmulator ( forceRestart = false ) { const emulator = Emulator . getInstance ( ) ; const port = emulator . framework . serverPort || null ; if ( ! forceRestart && emulator . framework . serverPort === port ) { return ; } await emulator . startup ( port ) ; const { users : userSettings , framework } = getSettings ( ) ; const users = new Users ( ) ; users . currentUserId = userSettings . currentUserId ; users . users = userSettings . usersById ; const { facilities } = emulator . framework . server . botEmulator ; facilities . locale = framework . locale ; facilities . users = users ; } @ Command ( Commands . OpenProtocolUrls ) protected async openProtocolUrls ( ) { const { protocol : { openUrls } , } = store . getState ( ) ; if ( openUrls . length ) { await Promise . all ( openUrls . map ( url => ProtocolHandler . parseProtocolUrlAndDispatch ( url ) ) ) ; } openUrls . length = 0 ; } @ Command ( Commands . ClearState ) protected async clearState ( ) { const { signedInUser } = getSettings ( ) . azure ; const signedInMessage = signedInUser ? 's' : 's' ; const bClearState = await this . commandService . call ( SharedConstants . Commands . Electron . ShowMessageBox , true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : signedInMessage , type : 's' , } ) ; if ( bClearState === 0 ) { await this . commandService . call ( SharedConstants . Commands . Electron . ShowMessageBox , false , { message : 's' , title : 's' , } ) ; await new Promise ( resolve => session . defaultSession . clearStorageData ( { } , resolve ) ) ; } return true ; } @ Command ( Commands . SendConversationUpdateUserAdded ) protected async sendConversationUpdateUserAdded ( ) { ConversationService . addUser ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . SendBotContactAdded ) protected async sendBotContactAdded ( ) { ConversationService . botContactAdded ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . SendBotContactRemoved ) protected async sendBotContactRemoved ( ) { ConversationService . botContactRemoved ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . SendTyping ) protected async sendTyping ( ) { ConversationService . typing ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . SendPing ) protected async sendPing ( ) { ConversationService . ping ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . SendDeleteUserData ) protected async sendDeleteUserData ( ) { ConversationService . deleteUserData ( getLocalhostServiceUrl ( ) , getCurrentConversationId ( ) ) ; TelemetryService . trackEvent ( 's' ) ; } @ Command ( Commands . GetServiceUrl ) protected async getServiceUrl ( ) { return Emulator . getInstance ( ) . ngrok . getServiceUrl ( 's' ) ; } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O O $any$ O $any$ O $any$ O O O O O O $Promise<any[]>$ O $string$ O $string$ O $void$ O O O O O O $any[]$ O $any[]$ O $any$ O O O O O O $BotProjectFileWatcher$ O O O O O O $any$ O O O O O O $UserAction<UserPayload>$ O O O O O O $FrameworkAction<void>$ O O O O O O $ProtocolHandlerImpl$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $Promise$ O $number$ O $string$ O O O O O O $BotConfigWithPath$ O $any$ O $any$ O O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O $EmulatorApplication$ O $Window$ O $any$ O O $complex$ O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O $any$ O $string$ O $any$ O $any$ O O $boolean$ O O O $string$ O O O $string$ O O O O O O O O $string$ O $string$ O $number$ O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O $any$ O $any$ O $number$ O O $void$ O $string$ O $any$ O O $any$ O $void$ O O O O O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O $string$ O $string$ O $number$ O O O $string$ O O $any$ O $Promise<string>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O $any$ O $any$ O O O $BotProjectFileWatcher$ O $Promise<true>$ O $any$ O O $any$ O $any$ O $any$ O $BotAction<SetDirectoryPayload>$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $complex$ O $string$ O $string$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O $any$ O $JSON$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O $string$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O O O $string$ O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O $string$ O $string$ O $any[]$ O $any$ O O O O O $BotConfigWithPath$ O $any$ O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any[]$ O $any[]$ O $any[]$ O $string$ O $string$ O O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O $boolean$ O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O O $Conversation$ O $string$ O O O $BotConfigWithPath$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $BotAction<any>$ O $any$ O O O O O $Emulator$ O $any$ O $Emulator$ O O O O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O $string$ O O O O $any$ O $any$ O $any$ O O O $Promise$ O $string$ O O O $any[]$ O $any$ O O O $string$ O O O O O O O O $any[]$ O O $Promise<any[]>$ O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O $string$ O O O $string$ O O O O O $any[]$ O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $string$ O O O O $any$ O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O O O $any$ O O $any$ O O $complex$ O O $string$ O $string$ O $string$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O $UserAction<UserPayload>$ O $complex$ O O O $any$ O $FrameworkAction<void>$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $boolean$ O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $boolean$ O O O O O $Emulator$ O $any$ O $Emulator$ O O O O $number$ O $Emulator$ O $BotFrameworkService$ O $number$ O O O O O O $boolean$ O $Emulator$ O $BotFrameworkService$ O $number$ O $number$ O O O O O O $Emulator$ O $Promise<void>$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $Promise<boolean>$ O O O O O $any$ O O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O O O O $PromiseConstructor$ O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<string>$ O O O O $any$ O $Emulator$ O O O $NgrokService$ O $Promise<string>$ O O O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; import { readFileSync , writeFile } from 's' ; const sanitize = require ( 's' ) ; const Commands = SharedConstants . Commands . File ; export class FileCommands { @ Command ( Commands . Read ) protected readFile ( path ) { try { return readFileSync ( path ) ; } catch ( e ) { console . error ( `template` , e ) ; throw e ; } } @ Command ( Commands . Write ) protected writeFile ( path , contents : object | string ) { try { writeFile ( path , contents ) ; } catch ( e ) { console . error ( `template` , e ) ; throw e ; } } @ Command ( Commands . SanitizeString ) protected sanitizeString ( path ) { return sanitize ( path ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $string$ O $void$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O $string$ O $string$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $void$ O $string$ O $complex$ O O O O O O O O $void$ O $string$ O $complex$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $any$ O $string$ O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; import { Emulator } from 's' ; const Commands = SharedConstants . Commands . Ngrok ; export class NgrokCommands { @ Command ( Commands . Reconnect ) protected async reconnectToNgrok ( ) < any > { const emulator = Emulator . getInstance ( ) ; try { await emulator . ngrok . recycle ( ) ; emulator . ngrok . broadcastNgrokReconnected ( ) ; } catch ( e ) { throw new Error ( `template` ) ; } } @ Command ( Commands . KillProcess ) protected killNgrokProcess ( ) { Emulator . getInstance ( ) . ngrok . kill ( ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $Promise$ O O O O O O O $Emulator$ O $any$ O $Emulator$ O O O O O O $Emulator$ O $NgrokService$ O $Promise<void>$ O O O $Emulator$ O $NgrokService$ O $void$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $Emulator$ O O O $NgrokService$ O $void$ O O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; import { Emulator } from 's' ; import { emulatorApplication } from 's' ; const Commands = SharedConstants . Commands . OAuth ; export class OauthCommands { @ Command ( Commands . SendTokenResponse ) protected async sendTokenResponse ( connectionName , conversationId , token ) { const convo = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . conversationById ( conversationId ) ; if ( ! convo ) { throw new Error ( `template` ) ; } await convo . sendTokenResponse ( connectionName , token , false ) ; } @ Command ( Commands . CreateOAuthWindow ) protected async createOauthWindow ( url , conversationId ) { const convo = Emulator . getInstance ( ) . framework . server . botEmulator . facilities . conversations . conversationById ( conversationId ) ; emulatorApplication . windowManager . createOAuthWindow ( url , convo . codeVerifier ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $string$ O $string$ O $string$ O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<void>$ O $string$ O $string$ O O O $any$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $EmulatorApplication$ O $WindowManager$ O $void$ O $string$ O $any$ O $any$ O O O O
export const ADD_SAVED_BOT_URL = 's' ; export type SavedBotUrlsActionType = 's' ; export interface SavedBotUrlsAction < P > { type : SavedBotUrlsActionType ; payload : P ; } export type SavedBotUrlsActionPayload = string ; export function addSavedBotUrl ( url ) < string > { return { type : ADD_SAVED_BOT_URL , payload : url , } ; }	O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $P$ O $any$ O O O O $any$ O O O O O $SavedBotUrlsAction$ O $string$ O O O O O O O O O O O $string$ O $string$ O O O O
import { SharedConstants } from 's' ; import { Command } from 's' ; import { addSavedBotUrl } from 's' ; import { dispatch } from 's' ; const Commands = SharedConstants . Commands . Settings ; export class SettingsCommands { @ Command ( Commands . SaveBotUrl ) protected saveBotUrl ( url ) { if ( ! url ) { return ; } dispatch ( addSavedBotUrl ( url ) ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $SavedBotUrlsAction<string>$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $void$ O $string$ O O O O O $string$ O O O O O $any$ O $SavedBotUrlsAction<string>$ O $string$ O O O O O
import { Command } from 's' ; import { SharedConstants } from 's' ; import { TelemetryService } from 's' ; const Commands = SharedConstants . Commands . Telemetry ; export class TelemetryCommands { @ Command ( Commands . TrackEvent ) protected trackEvent ( name , properties ? : { [ key ] : any } ) { TelemetryService . trackEvent ( name , properties ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $string$ O $complex$ O O O O $string$ O O O O O O $any$ O $void$ O $string$ O $complex$ O O O O
import { AzureCommands } from 's' ; import { BotCommands } from 's' ; import { ClientInitCommands } from 's' ; import { ConnectedServiceCommands } from 's' ; import { ElectronCommands } from 's' ; import { EmulatorCommands } from 's' ; import { FileCommands } from 's' ; import { NgrokCommands } from 's' ; import { OauthCommands } from 's' ; import { SettingsCommands } from 's' ; import { TelemetryCommands } from 's' ; export const commands = [ new AzureCommands ( ) , new BotCommands ( ) , new ClientInitCommands ( ) , new ConnectedServiceCommands ( ) , new ElectronCommands ( ) , new EmulatorCommands ( ) , new FileCommands ( ) , new NgrokCommands ( ) , new OauthCommands ( ) , new SettingsCommands ( ) , new TelemetryCommands ( ) , ] ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O
import { CommandLineArgs } from 's' ; import commandLineArgs from 's' ; import * as globals from 's' ; const optionDefinitions = [ { name : 's' , alias : 's' , type : String } ] ; export function parseArgs ( ) { const parsedCommandLineArgs = commandLineArgs ( optionDefinitions , { partial : true } ) ; globals . setGlobal ( 's' , parsedCommandLineArgs ) ; }	O O $any$ O O O O O $any$ O O O O O O $any$ O O O O $complex$ O O O $string$ O O O $string$ O O O $StringConstructor$ O $StringConstructor$ O O O O O $void$ O O O O $CommandLineArgs$ O $any$ O $complex$ O O $boolean$ O O O O O $any$ O $void$ O O O $any$ O O O
const nodeFetch = require ( 's' ) ; declare function fetch ( input , init ? ) < Response > ; ( global as any ) . fetch = function ( ... args : any [ ] ) { const [ urlOrRequest , requestInit = { } ] = args ; const allowLocalhost = 's' ; if ( ! process . env . HTTPS_PROXY && urlOrRequest . includes ( allowLocalhost ) ) { const https = require ( 's' ) ; const httpsAgent = new https . Agent ( { rejectUnauthorized : false } ) ; requestInit . agent = httpsAgent ; return nodeFetch ( urlOrRequest , requestInit ) ; } const url = typeof urlOrRequest === 's' ? urlOrRequest : urlOrRequest . url ; if ( ! process . env . HTTPS_PROXY || ( process . env . NO_PROXY && url . includes ( process . env . NO_PROXY ) ) ) { return nodeFetch ( ... args ) ; } const HttpsProxyAgent = require ( 's' ) ; const agent = new HttpsProxyAgent ( process . env . HTTPS_PROXY ) ; if ( typeof urlOrRequest === 's' ) { requestInit . agent = agent ; } else { urlOrRequest . agent = agent ; } return nodeFetch ( urlOrRequest , requestInit ) ; } ;	O $any$ O $any$ O O O O O O $Promise$ O $RequestInfo$ O $RequestInit$ $RequestInit$ O O $complex$ O O O $any$ O O O O $any$ O O O O $any[]$ O O O O O O O O $any$ O $any$ O O O O O $any[]$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O O $any$ O O O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O $boolean$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any[]$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O
import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance , logEntry , LogItem , LogService as ILogService , } from 's' ; export class LogService implements ILogService { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; public logToChat ( conversationId , ... items : LogItem [ ] ) { this . commandService . remoteCall ( SharedConstants . Commands . Emulator . AppendToLog , conversationId , logEntry ( ... items ) ) . catch ( ) ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $void$ O $string$ O O $any[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any[]$ O O O $any$ O O O O O
import { LogService as ILogService } from 's' ; import { BrowserWindow , WebContents } from 's' ; import { LogService } from 's' ; export class Window { public readonly logService : ILogService ; get browserWindow ( ) : BrowserWindow { return this . _browserWindow ; } get webContents ( ) : WebContents { return this . _browserWindow . webContents ; } constructor ( private _browserWindow ) { this . logService = new LogService ( ) ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $BrowserWindow$ O O O O $any$ O O $any$ O O O O O
import * as path from 's' ; import * as URL from 's' ; import * as Electron from 's' ; import { rememberZoomLevel } from 's' ; import { dispatch , getSettings } from 's' ; export class WindowManager { private mainWindow : Electron . BrowserWindow ; private windows : Electron . BrowserWindow [ ] ; constructor ( ) { this . windows = [ ] ; Electron . ipcMain . on ( 's' , ( event , args ) => { this . createCheckoutWindow ( args . payload , args . settings , args . serviceUrl ) ; } ) ; Electron . ipcMain . on ( 's' , ( event , args ) => { const state = event . sender . checkoutState ; event . returnValue = state ; } ) ; } public addMainWindow ( window : Electron . BrowserWindow ) { this . mainWindow = window ; } public hasMainWindow ( ) { return this . mainWindow !== undefined ; } public getMainWindow ( ) : Electron . BrowserWindow { return this . mainWindow ; } public add ( window : Electron . BrowserWindow ) { this . windows . push ( window ) ; } public remove ( window : Electron . BrowserWindow ) { const idx = this . windows . indexOf ( window ) ; if ( idx !== - 0 ) { this . windows . splice ( idx , 0 ) ; } } public zoomIn ( ) { let zoomLevel = getSettings ( ) . windowState . zoomLevel ; zoomLevel = Math . min ( zoomLevel + 0 , 0 ) ; this . zoomTo ( zoomLevel ) ; } public zoomOut ( ) { let zoomLevel = getSettings ( ) . windowState . zoomLevel ; zoomLevel = Math . max ( zoomLevel - 0 , - 0 ) ; this . zoomTo ( zoomLevel ) ; } public zoomTo ( zoomLevel ) { this . mainWindow . webContents . setZoomLevel ( zoomLevel ) ; this . windows . forEach ( win => win . webContents . setZoomLevel ( zoomLevel ) ) ; dispatch ( rememberZoomLevel ( { zoomLevel } ) ) ; } public createCheckoutWindow ( payload , settings , serviceUrl ) { let page = URL . format ( { protocol : 's' , slashes : true , pathname : path . join ( __dirname , 's' ) , } ) ; page += 's' + payload ; const checkoutWindow = new Electron . BrowserWindow ( { width : 0 , height : 0 , title : 's' , } ) ; this . add ( checkoutWindow ) ; ( checkoutWindow . webContents as any ) . checkoutState = { settings , serviceUrl , } ; checkoutWindow . on ( 's' , ( ) => { this . remove ( checkoutWindow ) ; } ) ; checkoutWindow . loadURL ( page ) ; checkoutWindow . webContents . setZoomLevel ( getSettings ( ) . windowState . zoomLevel ) ; } public createOAuthWindow ( url , codeVerifier ) { const win = new Electron . BrowserWindow ( { width : 0 , height : 0 , title : 's' , webPreferences : { nodeIntegration : false , } , } ) ; this . add ( win ) ; const webContents = win . webContents ; webContents . setZoomLevel ( getSettings ( ) . windowState . zoomLevel ) ; win . on ( 's' , ( ) => { this . remove ( win ) ; } ) ; const ses = webContents . session ; ses . webRequest . onBeforeRequest ( ( details , callback ) => { const 0 = details . url . toLowerCase ( ) ; if ( 0 . indexOf ( 's' ) !== - 0 && 0 . indexOf ( 's' ) === - 0 ) { if ( getSettings ( ) . framework . useCodeValidation ) { codeVerifier = 's' ; } const newUrl = details . url + 's' + codeVerifier ; callback ( { redirectURL : newUrl } ) ; } else { callback ( { } ) ; } } ) ; win . loadURL ( url ) ; } public closeAll ( ) { const openWindows = [ ] ; this . windows . forEach ( win => openWindows . push ( win ) ) ; openWindows . forEach ( win => win . close ( ) ) ; this . windows = [ ] ; this . mainWindow = undefined ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $WindowStateAction<RememberZoomLevelPayload>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $undefined$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O $any[]$ O $number$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O $number$ O O O $any[]$ O $number$ O $any$ O O O O $number$ O O O O O O O $any[]$ O $complex$ O $number$ O O O O O O O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $Math$ O $number$ O $any$ O O O O O O O O $void$ O $any$ O O O O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $Math$ O $number$ O $any$ O O O O O O O O O $void$ O $any$ O O O O $void$ O $number$ O O O O $any$ O $any$ O $any$ O $number$ O O O O $any[]$ O $void$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O $any$ O $WindowStateAction<RememberZoomLevelPayload>$ O O $number$ O O O O O O $void$ O $string$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $string$ O O $any$ O O $any$ O $any$ O O $number$ O O O $number$ O O O $string$ O O O O O O O O $void$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O O O $any$ O $any$ O O O O O O O O O $void$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $string$ O $string$ O O O $any$ O O $any$ O $any$ O O $number$ O O O $number$ O O O $string$ O O O $complex$ O O $boolean$ O O O O O O O O O O $void$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $void$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O $string$ O O O O O $string$ O $any$ O $any$ O O O $string$ O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $string$ O O O O $void$ O O O O $any[]$ O O O O O O $any[]$ O $void$ O $any$ O $any[]$ O $number$ O $any$ O O O $any[]$ O $void$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O O O O O O $any$ O $undefined$ O O O
import { Action } from 's' ; export const SET_OPEN_URLS = 's' ; export interface ProtocolAction < P > extends Action { type : ProtocolActionType ; payload : P ; } export interface ProtocolOpenUrlsPayload { openUrl ? : string ; } export declare type ProtocolActionType = 's' ; export function setOpenUrl ( openUrl ) < ProtocolOpenUrlsPayload > { return { type : SET_OPEN_URLS , payload : { openUrl } , } ; }	O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $P$ O $any$ O O O O $any$ O $string$ O O O O O O O O $any$ O O O O O $ProtocolAction$ O $string$ O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O
import 's' ; import * as path from 's' ; import * as url from 's' ; import { newNotification , Notification , PersistentSettings , SharedConstants } from 's' ; import { app , BrowserWindow , Rectangle , screen , systemPreferences } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { AppUpdater } from 's' ; import * as commandLine from 's' ; import { Protocol } from 's' ; import { Emulator } from 's' ; import 's' ; import { Window } from 's' ; import { azureLoggedInUserChanged } from 's' ; import { rememberBounds } from 's' ; import { dispatch , getSettings , store } from 's' ; import { TelemetryService } from 's' ; import { botListsAreDifferent , ensureStoragePath , isMac , saveSettings , writeFile } from 's' ; import { openFileFromCommandLine } from 's' ; import { sendNotificationToClient } from 's' ; import { WindowManager } from 's' ; import { ProtocolHandler } from 's' ; import { setOpenUrl } from 's' ; const beginStartupTime = Date . now ( ) ; ( process as NodeJS . EventEmitter ) . on ( 's' , ( error ) => { console . error ( error ) ; } ) ; if ( app ) { app . setName ( 's' ) ; } let protocolUsed = false ; commandLine . parseArgs ( ) ; function windowIsOffScreen ( windowBounds ) { const nearestDisplay = screen . getDisplayMatching ( windowBounds ) . workArea ; return ( windowBounds . x > nearestDisplay . x + nearestDisplay . width || windowBounds . x + windowBounds . width < nearestDisplay . x || windowBounds . y > nearestDisplay . y + nearestDisplay . height || windowBounds . y + windowBounds . height < nearestDisplay . y ) ; } class SplashScreen { private static splashWindow : BrowserWindow ; public static show ( mainBrowserWindow ) { if ( this . splashWindow ) { return ; } this . splashWindow = new BrowserWindow ( { show : false , width : 0 , height : 0 , center : true , frame : false , } ) ; const splashPage = process . env . ELECTRON_TARGET_URL ? `template` : url . format ( { protocol : 's' , slashes : true , pathname : require . resolve ( 's' ) , } ) ; this . splashWindow . loadURL ( splashPage ) ; this . splashWindow . once ( 's' , ( ) => { if ( ! mainBrowserWindow . isVisible ( ) ) { this . splashWindow . show ( ) ; } else { this . hide ( ) ; } } ) ; } public static hide ( ) { if ( ! this . splashWindow ) { return ; } this . splashWindow . destroy ( ) ; this . splashWindow = null ; } } class EmulatorApplication { @ CommandServiceInstance ( ) public commandService : CommandServiceImpl ; public mainBrowserWindow : BrowserWindow ; public mainWindow : Window ; public windowManager = new WindowManager ( ) ; private botsRef = store . getState ( ) . bot . botFiles ; private fileToOpen : string ; constructor ( ) { this . initializeNgrokListeners ( ) ; this . initializeAppListeners ( ) ; this . initializeSystemPreferencesListeners ( ) ; store . subscribe ( this . storeSubscriptionHandler ) ; } private initializeBrowserWindowListeners ( ) { this . mainBrowserWindow . once ( 's' , this . onBrowserWindowClose ) ; this . mainBrowserWindow . once ( 's' , this . onBrowserWindowReadyToShow ) ; this . mainBrowserWindow . on ( 's' , this . onBrowserWindowRestore ) ; this . mainBrowserWindow . on ( 's' , this . onBrowserWindowClosed ) ; this . mainBrowserWindow . on ( 's' , this . rememberCurrentBounds ) ; this . mainBrowserWindow . on ( 's' , this . rememberCurrentBounds ) ; } private initializeNgrokListeners ( ) { Emulator . getInstance ( ) . ngrok . ngrokEmitter . on ( 's' , this . onNgrokSessionExpired ) ; } private initializeSystemPreferencesListeners ( ) { systemPreferences . on ( 's' , this . onInvertedColorSchemeChanged ) ; } private initializeAppListeners ( ) { app . on ( 's' , this . onAppReady ) ; app . on ( 's' , this . onAppActivate ) ; app . on ( 's' , this . onAppWillFinishLaunching ) ; app . on ( 's' , this . onAppOpenFile ) ; } private onBrowserWindowClose = async ( event ) => { const { azure } = getSettings ( ) ; if ( azure . signedInUser && ! azure . persistLogin ) { event . preventDefault ( ) ; await this . commandService . call ( SharedConstants . Commands . Azure . SignUserOutOfAzure , false ) ; } saveSettings < PersistentSettings > ( 's' , getSettings ( ) ) ; app . quit ( ) ; } ; private onBrowserWindowReadyToShow = async ( ) => { this . onInvertedColorSchemeChanged ( ) ; const { zoomLevel } = getSettings ( ) . windowState ; this . mainWindow . webContents . setZoomLevel ( zoomLevel ) ; SplashScreen . hide ( ) ; this . mainBrowserWindow . show ( ) ; await AppUpdater . startup ( ) ; await this . renewArmToken ( ) ; if ( this . fileToOpen ) { await openFileFromCommandLine ( this . fileToOpen , this . commandService ) ; this . fileToOpen = null ; } const endStartupTime = Date . now ( ) ; const startupTime = ( endStartupTime - beginStartupTime ) / 0 ; const launchedByProtocol = process . argv . some ( arg => arg . includes ( Protocol ) ) || protocolUsed ; TelemetryService . trackEvent ( 's' , { method : launchedByProtocol ? 's' : 's' , startupTime , } ) ; } ; private onBrowserWindowRestore = ( ) => { if ( windowIsOffScreen ( this . mainWindow . browserWindow . getBounds ( ) ) ) { const currentBounds = this . mainWindow . browserWindow . getBounds ( ) ; let display = screen . getAllDisplays ( ) . find ( displayArg => displayArg . id === getSettings ( ) . windowState . displayId ) ; display = display || screen . getDisplayMatching ( currentBounds ) ; this . mainWindow . browserWindow . setPosition ( display . workArea . x , display . workArea . y ) ; const bounds = { displayId : display . id , width : currentBounds . width , height : currentBounds . height , left : display . workArea . x , top : display . workArea . y , } ; dispatch ( rememberBounds ( bounds ) ) ; } } ; private onBrowserWindowClosed = ( ) => { this . windowManager . closeAll ( ) ; this . mainWindow = null ; } ; private rememberCurrentBounds = ( ) => { const currentBounds = this . mainWindow . browserWindow . getBounds ( ) ; const bounds = { displayId : screen . getDisplayMatching ( currentBounds ) . id , width : currentBounds . width , height : currentBounds . height , left : currentBounds . x , top : currentBounds . y , } ; dispatch ( rememberBounds ( bounds ) ) ; } ; private onNgrokSessionExpired = async ( ) => { const ngrokNotification = newNotification ( 's' ) ; ngrokNotification . addButton ( 's' , ( ) => { const { Commands } = SharedConstants ; this . commandService . remoteCall ( Commands . Notifications . Remove , ngrokNotification . id ) ; } ) ; ngrokNotification . addButton ( 's' , async ( ) => { try { const { Commands } = SharedConstants ; await this . commandService . call ( Commands . Ngrok . Reconnect ) ; this . commandService . remoteCall ( Commands . Notifications . Remove , ngrokNotification . id ) ; } catch ( e ) { await sendNotificationToClient ( newNotification ( e ) , this . commandService ) ; } } ) ; await sendNotificationToClient ( ngrokNotification , this . commandService ) ; Emulator . getInstance ( ) . ngrok . broadcastNgrokExpired ( ) ; } ; private onInvertedColorSchemeChanged = ( ) => { const { theme , availableThemes } = getSettings ( ) . windowState ; const themeInfo = availableThemes . find ( availableTheme => availableTheme . name === theme ) ; const isHighContrast = systemPreferences . isInvertedColorScheme ( ) ; const themeName = isHighContrast ? 's' : themeInfo . name ; const themeComponents = isHighContrast ? path . join ( 's' , 's' , 's' ) : themeInfo . href ; this . commandService . remoteCall ( SharedConstants . Commands . UI . SwitchTheme , themeName , themeComponents ) ; } ; private onAppReady = ( ) => { if ( this . mainBrowserWindow ) { return ; } this . mainBrowserWindow = new BrowserWindow ( { show : false , backgroundColor : 's' , width : 0 , height : 0 } ) ; this . initializeBrowserWindowListeners ( ) ; this . mainWindow = new Window ( this . mainBrowserWindow ) ; if ( process . env . NODE_ENV !== 's' ) { SplashScreen . show ( this . mainBrowserWindow ) ; } const page = process . env . ELECTRON_TARGET_URL || url . format ( { protocol : 's' , slashes : true , pathname : require . resolve ( 's' ) , } ) ; if ( "s" . test ( page ) ) { console . warn ( `template` ) ; } this . mainBrowserWindow . loadURL ( page ) ; this . mainBrowserWindow . setTitle ( app . getName ( ) ) ; } ; private onAppActivate = ( ) => { this . onAppReady ( ) ; } ; private onAppWillFinishLaunching = ( ) => { app . on ( 's' , this . onAppOpenUrl ) ; } ; private onAppOpenUrl = ( event , url ) : void => { event . preventDefault ( ) ; if ( isMac ( ) ) { protocolUsed = true ; if ( this . mainWindow && this . mainWindow . webContents ) { ProtocolHandler . parseProtocolUrlAndDispatch ( url ) ; } else { store . dispatch ( setOpenUrl ( url ) ) ; } } } ; private onAppOpenFile = async ( event , file ) => { if ( ! this . mainWindow || ! this . commandService ) { this . fileToOpen = file ; } else { await openFileFromCommandLine ( file , this . commandService ) ; } } ; private storeSubscriptionHandler = ( ) => { const state = store . getState ( ) ; const bots = state . bot . botFiles . filter ( botFile => ! ! botFile ) ; if ( botListsAreDifferent ( this . botsRef , bots ) ) { const botsJson = { bots } ; const botsJsonPath = path . join ( ensureStoragePath ( ) , 's' ) ; try { writeFile ( botsJsonPath , botsJson ) ; this . botsRef = bots ; } catch ( e ) { console . error ( 's' , e ) ; } } } ; private async renewArmToken ( ) { const { persistLogin , signedInUser } = getSettings ( ) . azure ; if ( persistLogin && signedInUser ) { const result = await this . commandService . registry . getCommand ( SharedConstants . Commands . Azure . RetrieveArmToken ) ( true ) ; if ( result && 's' in result ) { await this . commandService . remoteCall ( SharedConstants . Commands . UI . ArmTokenReceivedOnStartup , result ) ; } else if ( ! result ) { store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; await this . commandService . call ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; } } } } export const emulatorApplication = new EmulatorApplication ( ) ;	O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $EmulatorUpdater$ O O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O $AzureAuthAction<string>$ O O O O O O $WindowStateAction<RememberBoundsPayload>$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $string$ O $boolean$ O $void$ O $void$ O O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $ProtocolHandlerImpl$ O O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O $number$ O $DateConstructor$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $Error$ O O O $Console$ O $void$ O $Error$ O O O O O O O $any$ O O $any$ O $any$ O O O O O O $boolean$ O O O $any$ O $void$ O O O O $boolean$ O $Rectangle$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $void$ O $BrowserWindow$ O O O O O O $any$ O O O O O O O $any$ O O $any$ O O $boolean$ O O O $number$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $Window$ O $any$ O O $WindowManager$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O O O O O O O $void$ O O O O O $void$ O O O O O $void$ O O O $any$ O $any$ O O O $void$ O O O O $void$ O O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O O $void$ O O O O $any$ O $any$ O O O O O $void$ O O O O $any$ O $any$ O O O O O $void$ O O O O $any$ O $any$ O O O O O $void$ O O O O $void$ O O O $any$ O $Emulator$ O O O $NgrokService$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O O O O $void$ O O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $void$ O O $any$ O $any$ O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O $Event$ O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O $Event$ O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O O $void$ O O O O O $any$ O O $any$ O O O $any$ O O O $Window$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O O O O $any$ O $any$ O O O O $EmulatorUpdater$ O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O O O $string$ O O O $Promise<void>$ O O O $string$ O O O $any$ O O O O $string$ O O O O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O O $number$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O $any$ O $void$ O O O O $string$ O $any$ O O O O O $number$ O O O O O O O $void$ O O O O O O O $boolean$ O O O $Window$ O $any$ O $any$ O O O O O O $any$ O O O $Window$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Window$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O O O O O $void$ O O O O O O O $WindowManager$ O $void$ O O O O O $Window$ O O O O O O $void$ O O O O O O $any$ O O O $Window$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O O O O $Promise<void>$ O O O O O O O $Notification$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O O O O O O $Promise<void>$ O $any$ O O O $any$ O O $any$ O $Emulator$ O O O $NgrokService$ O $void$ O O O O O O $void$ O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O O O O O O O O O $any$ O O O O O O O $any$ O O $any$ O O $boolean$ O O O $string$ O O O $number$ O O O $number$ O O O O O O O $void$ O O O O O $Window$ O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O $boolean$ O $any$ O O O $Console$ O $void$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $void$ O O O O O $void$ O O $any$ O $string$ O O O O O $any$ O $any$ O O O O O $boolean$ O O O O $boolean$ O O O O O O O $Window$ O O O $Window$ O $any$ O O $ProtocolHandlerImpl$ O $void$ O $string$ O O O O O $any$ O $any$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $string$ O O O O O O O O $Promise<void>$ O O O $Event$ O $string$ O O O O O O O O $Window$ O O O O $any$ O O O O $string$ O $string$ O O O O O $Promise<void>$ O $string$ O O O $any$ O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O $complex$ O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $void$ O $any$ O $complex$ O O O O $any$ O $any$ O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O O $Promise<void>$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $EmulatorApplication$ O O $any$ O O O
import { SharedConstants } from 's' ; import { BotEmulator , Conversation , ConversationSet } from 's' ; import { LogLevel , networkRequestItem , networkResponseItem , textItem } from 's' ; import { IEndpointService } from 's' ; import { createServer , Request , Response , Route , Server } from 's' ; import CORS from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { Emulator } from 's' ; import { emulatorApplication } from 's' ; interface ConversationAwareRequest extends Request { conversation ? : { conversationId ? : string } ; params ? : { conversationId ? : string } ; } export class RestServer { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private readonly router : Server ; private _botEmulator : BotEmulator ; public get botEmulator ( ) : BotEmulator { if ( ! this . _botEmulator ) { this . _botEmulator = new BotEmulator ( botUrl => Emulator . getInstance ( ) . ngrok . getServiceUrl ( botUrl ) , ( ) => Emulator . getInstance ( ) . ngrok . getServiceUrlForOAuth ( ) , ( ) => Emulator . getInstance ( ) . ngrok . shutDownOAuthNgrokInstance ( ) , { fetch , loggerOrLogService : emulatorApplication . mainWindow . logService , } ) ; this . _botEmulator . facilities . conversations . on ( 's' , this . onNewConversation ) ; } return this . _botEmulator ; } constructor ( ) { const cors = CORS ( { origins : [ 's' ] , allowHeaders : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] , exposeHeaders : [ ] , } ) ; const router = createServer ( { name : 's' , } ) ; router . on ( 's' , this . onRouterAfter ) ; router . pre ( cors . preflight ) ; router . use ( cors . actual ) ; this . router = router ; } public listen ( port ? ) < { url : string ; port : number } > { return new Promise ( ( resolve , reject ) => { this . router . once ( 's' , err => reject ( err ) ) ; this . router . listen ( port , ( ) => { this . botEmulator . mount ( this . router as any ) ; resolve ( { url : this . router . url , port : this . router . address ( ) . port } ) ; } ) ; } ) ; } public close ( ) { return new Promise ( resolve => { if ( this . router ) { this . router . close ( ( ) => resolve ( ) ) ; } else { resolve ( ) ; } } ) ; } private onRouterAfter = async ( req , res , route ) => { const conversationId = getConversationId ( req as ConversationAwareRequest ) ; if ( ! shouldPostToChat ( conversationId , req . method , route , req as any ) ) { return ; } const facility = ( req as any ) . facility || 's' ; const routeName = ( req as any ) . routeName || 's' ; let level = LogLevel . Debug ; if ( ! "s" . test ( res . statusCode . toString ( ) ) ) { level = LogLevel . Error ; } let responseHeaders ; try { responseHeaders = res . headers ( ) ; } catch ( e ) { responseHeaders = undefined ; } emulatorApplication . mainWindow . logService . logToChat ( conversationId , networkRequestItem ( facility , ( req as any ) . _body , req . headers , req . method , req . url ) , networkResponseItem ( ( res as any ) . _data , responseHeaders , res . statusCode , res . statusMessage , req . url ) , textItem ( level , `template` ) ) ; } ; private onNewConversation = async ( conversation = { } as Conversation ) => { const { conversationId = 's' } = conversation ; if ( ! conversationId || conversationId . includes ( 's' ) ) { return ; } const { botEndpoint : { id , botUrl } , mode , } = conversation ; await this . commandService . remoteCall ( SharedConstants . Commands . Emulator . NewLiveChat , { id , endpoint : botUrl , } as IEndpointService , hasLiveChat ( conversationId , this . botEmulator . facilities . conversations ) , conversationId , mode ) ; await Emulator . getInstance ( ) . report ( conversationId , botUrl ) ; } ; } function shouldPostToChat ( conversationId , method , route , req : { body : { } ; conversation : Conversation } ) { const isDLine = method === 's' && route . spec . path === 's' ; const isNotTranscript = ! ! conversationId && ! conversationId . includes ( 's' ) ; const { conversation } = req ; return ! isDLine && isNotTranscript && conversation && conversation . mode !== 's' ; } function getConversationId ( req ) { return req . conversation ? req . conversation . conversationId : req . params . conversationId ; } function hasLiveChat ( conversationId , conversationSet ) { if ( conversationId . endsWith ( 's' ) ) { return ! ! conversationSet . conversationById ( conversationId ) ; } return ! ! conversationSet . conversationById ( conversationId + 's' ) ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O $any$ O $any$ O $complex$ O O O $string$ O O O O O $complex$ O O O $string$ O O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $Emulator$ O O O $NgrokService$ O $Promise<string>$ O $any$ O O O O O $any$ O $Emulator$ O O O $NgrokService$ O $Promise<string>$ O O O O O O $any$ O $Emulator$ O O O $NgrokService$ O $void$ O O O O $complex$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O O $undefined[]$ O O O O O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $Promise$ O $number$ $number$ O O O $string$ O O O $number$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O O $any$ O $any$ O O O $any$ O $void$ O $any$ O O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O $any$ O O O O $void$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O $void$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $void$ O O O O O O O $void$ O O O O O O O O O $Promise<void>$ O O O $Request$ O $Response$ O $Route$ O O O O $string$ O $string$ O $any$ O $any$ O O O O O $boolean$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $undefined$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O $Conversation$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $Emulator$ O O O $Promise<void>$ O $any$ O $any$ O O O O O O $boolean$ O $string$ O $string$ O $Route$ O $complex$ O O ${}$ O O O O $any$ O $any$ O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O $string$ O O $string$ O $boolean$ O O O O O O $any$ O O $complex$ O O O $boolean$ O $boolean$ O $any$ O $any$ O $any$ O O O O O $string$ O $ConversationAwareRequest$ O O O $ConversationAwareRequest$ O $complex$ O $ConversationAwareRequest$ O $complex$ O $string$ O $ConversationAwareRequest$ O $complex$ O $string$ O O O $boolean$ O $string$ O $ConversationSet$ O O O O $string$ O $boolean$ O O O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O O O
import { LogLevel , textItem } from 's' ; import { newNotification , SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { emulatorApplication } from 's' ; import { RestServer } from 's' ; export class BotFrameworkService { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; public server : RestServer ; private _serverUrl : string ; private _serverPort : number ; public get serverUrl ( ) { return this . _serverUrl ; } public get serverPort ( ) { return this . _serverPort ; } public async recycle ( port ) { if ( this . server ) { await this . server . close ( ) ; } this . server = new RestServer ( ) ; try { const { url , port : serverChosenPort } = await this . server . listen ( port ) ; this . _serverUrl = url ; this . _serverPort = serverChosenPort ; } catch ( e ) { if ( e . code === 's' ) { const notification = newNotification ( `template` ) ; await this . commandService . remoteCall ( SharedConstants . Commands . Notifications . Add , notification ) ; } } } public report ( conversationId ) { const serverUrl = this . serverUrl . replace ( 's' , 's' ) ; emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , `template` ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $EmulatorApplication$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O $RestServer$ O $any$ O O $string$ O O O O $number$ O O O O O $string$ O O O O O O $string$ O O O O $number$ O O O O O O $number$ O O O O $Promise<void>$ O $number$ O O O O O O $RestServer$ O O O O O $RestServer$ O $Promise<unknown>$ O O O O O O $RestServer$ O O $any$ O O O O O O O $string$ O $number$ O $number$ O O O O O $RestServer$ O $complex$ O $number$ O O O O $string$ O $string$ O O O $number$ O $number$ O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O $string$ O O O $string$ O O O $string$ O $complex$ O O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O O
import { ChildProcess , spawn } from 's' ; import { EventEmitter } from 's' ; import { platform } from 's' ; import * as path from 's' ; import { existsSync } from 's' ; import { clearTimeout , setTimeout } from 's' ; import { uniqueId } from 's' ; export interface NgrokOptions { addr : number ; name : string ; path : string ; port : number ; proto : 's' | 's' | 's' | 's' ; region : 's' | 's' | 's' | 's' ; inspect : boolean ; host_header ? : string ; bind_tls ? : boolean | 's' ; subdomain ? : string ; hostname ? : string ; crt ? : string ; key ? : string ; client_cas ? : string ; remote_addr ? : string ; } const defaultOptions < NgrokOptions > = { addr : 0 , name : uniqueId ( ) , proto : 's' , region : 's' , inspect : true , } ; const bin = 's' + ( platform ( ) === 's' ? 's' : 's' ) ; const addrRegExp = "s" ; export const intervals = { retry : 0 , expirationPoll : 0 * 0 * 0 , expirationTime : 0 * 0 * 0 * 0 } ; export class NgrokInstance { public ngrokEmitter = new EventEmitter ( ) . on ( 's' , this . kill ) ; private pendingConnection : Promise < { url ; inspectUrl } > ; private ngrokProcess : ChildProcess ; private tunnels = { } ; private inspectUrl = 's' ; private ngrokStartTime : number ; private ngrokExpirationTimer : NodeJS . Timer ; public running ( ) { return this . ngrokProcess && ! ! this . ngrokProcess . pid ; } public async connect ( opts < NgrokOptions > ) < { url ; inspectUrl } > { const options = { ... defaultOptions , ... opts } as NgrokOptions ; if ( this . pendingConnection ) { return this . pendingConnection ; } await this . getNgrokInspectUrl ( options ) ; return this . runTunnel ( options ) ; } public async disconnect ( url ? ) { const tunnelsToDisconnect = url ? [ this . tunnels [ url ] ] : Object . keys ( this . tunnels ) ; const requests = tunnelsToDisconnect . map ( tunnel => fetch ( tunnel , { method : 's' } ) ) ; const responses : Response [ ] = await Promise . all ( requests ) ; responses . forEach ( response => { if ( ! response . ok || response . status === 0 ) { return ; } delete this . tunnels [ response . url ] ; this . ngrokEmitter . emit ( 's' , response . url ) ; } ) ; } public kill ( ) { if ( ! this . ngrokProcess ) { return ; } this . ngrokProcess . stdout . pause ( ) ; this . ngrokProcess . stderr . pause ( ) ; this . ngrokProcess . kill ( ) ; this . ngrokProcess = null ; this . tunnels = { } ; this . cleanUpNgrokExpirationTimer ( ) ; } private async getNgrokInspectUrl ( opts ) < { inspectUrl : string } > { if ( this . running ( ) ) { return { inspectUrl : this . inspectUrl } ; } this . ngrokProcess = this . spawnNgrok ( opts ) ; this . inspectUrl = await new Promise < string > ( ( resolve , reject ) => { const timeout = setTimeout ( ( ) => { const message = 's' ; this . ngrokEmitter . emit ( 's' , message ) ; reject ( message ) ; } , 0 ) ; const onNgrokData = ( data ) => { const addr = data . toString ( ) . match ( addrRegExp ) ; if ( ! addr ) { return ; } clearTimeout ( timeout ) ; this . ngrokProcess . stdout . removeListener ( 's' , onNgrokData ) ; resolve ( `template` ) ; } ; this . ngrokProcess . stdout . on ( 's' , onNgrokData ) ; process . on ( 's' , this . kill ) ; } ) ; return { inspectUrl : this . inspectUrl } ; } private checkForNgrokExpiration ( ) { const currentTime = Date . now ( ) ; const timeElapsed = currentTime - this . ngrokStartTime ; if ( timeElapsed >= intervals . expirationTime ) { this . cleanUpNgrokExpirationTimer ( ) ; this . ngrokEmitter . emit ( 's' ) ; } else { this . ngrokExpirationTimer = setTimeout ( this . checkForNgrokExpiration . bind ( this ) , intervals . expirationPoll ) ; } } private cleanUpNgrokExpirationTimer ( ) { this . ngrokStartTime = null ; clearTimeout ( this . ngrokExpirationTimer ) ; } private async runTunnel ( opts ) < { url ; inspectUrl } > { let retries = 0 ; const url = `template` ; const body = JSON . stringify ( opts ) ; while ( true ) { const resp = await fetch ( url , { method : 's' , body , headers : { 's' : 's' , } , } ) ; if ( ! resp . ok ) { const error = await resp . text ( ) ; await new Promise ( resolve => setTimeout ( resolve , ~ ~ intervals . retry ) ) ; if ( ! retries ) { throw new Error ( error ) ; } retries -- ; continue ; } const result = await resp . json ( ) ; const { public_url : publicUrl , uri , msg } = result ; if ( ! publicUrl ) { throw Object . assign ( new Error ( msg || 's' ) , result ) ; } this . tunnels [ publicUrl ] = uri ; if ( opts . proto === 's' && opts . bind_tls ) { this . tunnels [ publicUrl . replace ( 's' , 's' ) ] = uri + 's' ; } this . ngrokStartTime = Date . now ( ) ; this . ngrokExpirationTimer = setTimeout ( this . checkForNgrokExpiration . bind ( this ) , intervals . expirationPoll ) ; this . ngrokEmitter . emit ( 's' , publicUrl , this . inspectUrl ) ; this . pendingConnection = null ; return { url : publicUrl , inspectUrl : this . inspectUrl } ; } } private spawnNgrok ( opts ) { const filename = `template` ; const folder = opts . path ? path . dirname ( opts . path ) : path . join ( __dirname , 's' ) ; const args = [ 's' , 's' , 's' , `template` ] ; const ngrokPath = path . join ( folder , filename ) ; if ( ! existsSync ( ngrokPath ) ) { throw new Error ( `template` + `template` + `template` ) ; } const ngrok = spawn ( ngrokPath , args , { cwd : folder } ) ; ngrok . on ( 's' , e => this . ngrokEmitter . emit ( 's' , e ) ) ; ngrok . on ( 's' , ( ) => { this . tunnels = { } ; this . cleanUpNgrokExpirationTimer ( ) ; this . ngrokEmitter . emit ( 's' ) ; } ) ; ngrok . on ( 's' , ( ) => { this . cleanUpNgrokExpirationTimer ( ) ; this . ngrokEmitter . emit ( 's' ) ; } ) ; ngrok . stderr . on ( 's' , ( data ) => this . ngrokEmitter . emit ( 's' , data . toString ( ) ) ) ; return ngrok ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $number$ O O O $string$ O O O $string$ O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O $string$ O O O O $complex$ O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O $Partial$ O $any$ O O O $number$ O O O $any$ O $any$ O O O O O O O O O O O $true$ O O O O O O $string$ O O O O $any$ O O O O O O O O O O O $RegExp$ O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O $number$ O O O O O O O O O O O O $any$ O O $any$ O O $any$ O O O $any$ O O O O O $void$ O O O $complex$ O $PromiseConstructor$ O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O $string$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O $Promise$ O $Partial$ O $any$ O O O O $any$ O $any$ O O O O $NgrokOptions$ O O O $Partial<NgrokOptions>$ O O $Partial<NgrokOptions>$ O O $any$ O O O O O $complex$ O O O O O $complex$ O O O O O $complex$ O $NgrokOptions$ O O O O O $complex$ O $NgrokOptions$ O O O O O $Promise<void>$ O $string$ $string$ O O O $any[]$ O $string$ O O O O ${}$ O $string$ O O O $ObjectConstructor$ O $complex$ O O O ${}$ O O O $Promise<Response>[]$ O $any[]$ O $U[]$ O $any$ O $complex$ O $any$ O O $string$ O O O O O O O $Response[]$ O $complex$ O O O O $PromiseConstructor$ O O O $Promise<Response>[]$ O O $Response[]$ O $void$ O $Response$ O O O O O $Response$ O $boolean$ O $Response$ O $number$ O O O O O O O O O O ${}$ O $Response$ O $string$ O O O O $any$ O $any$ O O O $Response$ O $string$ O O O O O O O $void$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O ${}$ O O O O O O $void$ O O O O O O $Promise$ O $NgrokOptions$ O O O $string$ O O O O O O O O O $boolean$ O O O O O O $string$ O O O $string$ O O O O O $any$ O O O $any$ O $NgrokOptions$ O O O O $string$ O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O O O O O $void$ O O $Buffer$ O O O O $any$ O $any$ O $any$ O O O $any$ O $RegExp$ O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $void$ O O $void$ O O O O O O O O $any$ O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O O O $void$ O O O O O O O $string$ O O O $string$ O O O O $void$ O O O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O O O $number$ O O O $number$ O $complex$ O $number$ O O O O $void$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $void$ O $any$ O O O O $complex$ O $number$ O O O O O $void$ O O O O O $number$ O O O $any$ O O O $any$ O O O O O $Promise$ O $NgrokOptions$ O O O $any$ O $any$ O O O O $number$ O O O O $string$ O O O O $string$ O $JSON$ O $complex$ O $NgrokOptions$ O O O O O O O O $Response$ O O $complex$ O $string$ O O $string$ O O O $string$ O $complex$ O O O O O O O O O O O O O O $Response$ O $boolean$ O O O $string$ O O $Response$ O $Promise<string>$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O $complex$ O $number$ O O O O O O $number$ O O O O $ErrorConstructor$ O $string$ O O O $number$ O O O O O O $any$ O O $Response$ O $Promise<any>$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O $ObjectConstructor$ O O O O $ErrorConstructor$ O $any$ O O O O $any$ O O O O O ${}$ O $any$ O O $any$ O O O $NgrokOptions$ O O O O O $NgrokOptions$ O $complex$ O O O O ${}$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O $any$ O $any$ O O O $void$ O $any$ O O O O $complex$ O $number$ O O O O $any$ O $any$ O O O $any$ O O O $string$ O O O O $complex$ O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O $ChildProcess$ O $NgrokOptions$ O O O $string$ O O O O $any$ O $NgrokOptions$ O $string$ O $any$ O $any$ O $NgrokOptions$ O $string$ O O $any$ O $any$ O $any$ O O O O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O $any$ O $string[]$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O O O O O O ${}$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O
import { EventEmitter } from 's' ; import { FrameworkSettings } from 's' ; import { appSettingsItem , exceptionItem , externalLinkItem , isLocalHostUrl , LogItem , LogLevel , ngrokExpirationItem , textItem , } from 's' ; import { Emulator } from 's' ; import { emulatorApplication } from 's' ; import { NgrokInstance } from 's' ; import { getSettings } from 's' ; let ngrokServiceInstance ; export class NgrokService { private ngrok = new NgrokInstance ( ) ; private ngrokPath : string ; private serviceUrl : string ; private inspectUrl : string ; private spawnErr : any ; private localhost = 's' ; private triedToSpawn : boolean ; private pendingRecycle : Promise < void > ; private oauthNgrokInstance : NgrokInstance ; constructor ( ) { return ngrokServiceInstance || ( ngrokServiceInstance = this ) ; } public async getServiceUrl ( botUrl ) < string > { if ( this . pendingRecycle ) { await this . pendingRecycle ; } if ( this . ngrok . running ( ) ) { return this . serviceUrl ; } const { bypassNgrokLocalhost , runNgrokAtStartup } = getSettings ( ) . framework ; const local = ! botUrl || isLocalHostUrl ( botUrl ) ; if ( runNgrokAtStartup || ! local || ( local && ! bypassNgrokLocalhost ) ) { if ( ! this . ngrok . running ( ) ) { await this . startup ( ) ; } return this . serviceUrl ; } return `template` ; } public async getServiceUrlForOAuth ( ) < string > { if ( this . pendingRecycle ) { await this . pendingRecycle ; } if ( this . ngrok . running ( ) ) { return this . serviceUrl ; } this . oauthNgrokInstance = new NgrokInstance ( ) ; const port = Emulator . getInstance ( ) . framework . serverPort ; const ngrokPath = getSettings ( ) . framework . ngrokPath ; const inspectUrl = new Promise < string > ( async ( resolve , reject ) => { try { const { url } = await this . oauthNgrokInstance . connect ( { addr : port , path : ngrokPath , } ) ; resolve ( url ) ; } catch ( e ) { reject ( new Error ( `template` ) ) ; } } ) ; return inspectUrl ; } public shutDownOAuthNgrokInstance ( ) { if ( this . oauthNgrokInstance ) { this . oauthNgrokInstance . kill ( ) ; } } public getSpawnStatus = ( ) : { triedToSpawn : boolean ; err : any } => ( { triedToSpawn : this . triedToSpawn , err : this . spawnErr , } ) ; public async updateNgrokFromSettings ( framework ) { this . cacheSettings ( ) ; if ( this . ngrokPath !== framework . ngrokPath && this . ngrok . running ( ) ) { return this . recycle ( ) ; } } public recycle ( ) < void > { if ( this . pendingRecycle ) { return this . pendingRecycle ; } this . ngrok . kill ( ) ; const port = Emulator . getInstance ( ) . framework . serverPort ; this . ngrokPath = getSettings ( ) . framework . ngrokPath ; this . serviceUrl = `template` ; this . inspectUrl = null ; this . spawnErr = null ; this . triedToSpawn = false ; if ( this . ngrokPath && this . ngrokPath . length ) { return ( this . pendingRecycle = new Promise ( async resolve => { try { this . triedToSpawn = true ; const { inspectUrl , url } = await this . ngrok . connect ( { addr : port , path : this . ngrokPath , } ) ; this . serviceUrl = url ; this . inspectUrl = inspectUrl ; } catch ( err ) { this . spawnErr = err ; console . error ( 's' , err ) ; } this . pendingRecycle = null ; resolve ( ) ; } ) ) ; } return Promise . resolve ( ) ; } public kill ( ) { if ( this . ngrok ) { this . ngrok . kill ( ) ; } } public get ngrokEmitter ( ) : EventEmitter { return this . ngrok . ngrokEmitter || undefined ; } public get running ( ) : boolean { return this . ngrok . running ( ) || false ; } public broadcastNgrokExpired ( ) { this . broadcast ( ngrokExpirationItem ( 's' ) ) ; } public broadcastNgrokReconnected ( ) { const bypassNgrokLocalhost = getSettings ( ) . framework . bypassNgrokLocalhost ; const { broadcast } = this ; broadcast ( textItem ( LogLevel . Debug , 's' ) ) ; broadcast ( textItem ( LogLevel . Debug , `template` ) ) ; broadcast ( textItem ( LogLevel . Debug , 's' ) , externalLinkItem ( this . inspectUrl , this . inspectUrl ) ) ; if ( bypassNgrokLocalhost ) { broadcast ( textItem ( LogLevel . Debug , 's' ) ) ; } else { broadcast ( textItem ( LogLevel . Debug , 's' ) ) ; } } public broadcast ( ... logItems : LogItem [ ] ) { const { conversations } = Emulator . getInstance ( ) . framework . server . botEmulator . facilities ; const conversationIds : string [ ] = conversations . getConversationIds ( ) ; conversationIds . forEach ( id => { emulatorApplication . mainWindow . logService . logToChat ( id , ... logItems ) ; } ) ; } public async report ( conversationId , botUrl ) < void > { await this . getServiceUrl ( botUrl ) ; if ( this . spawnErr ) { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Error , 's' ) , exceptionItem ( this . spawnErr ) ) ; } else if ( ! this . ngrokPath ) { this . reportNotConfigured ( conversationId ) ; } else if ( this . ngrok . running ( ) ) { this . reportRunning ( conversationId ) ; } else { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , 's' ) ) ; } } private async startup ( ) { this . cacheSettings ( ) ; await this . recycle ( ) ; } private reportNotConfigured ( conversationId ) { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , 's' ) ) ; emulatorApplication . mainWindow . logService . logToChat ( conversationId , externalLinkItem ( 's' , 's' ) ) ; emulatorApplication . mainWindow . logService . logToChat ( conversationId , appSettingsItem ( 's' ) ) ; } private reportRunning ( conversationId ) { const bypassNgrokLocalhost = getSettings ( ) . framework . bypassNgrokLocalhost ; emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , `template` ) ) ; emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , 's' ) , externalLinkItem ( this . inspectUrl , this . inspectUrl ) ) ; if ( bypassNgrokLocalhost ) { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , 's' ) ) ; } else { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Debug , 's' ) ) ; } } private cacheSettings ( ) { const framework = getSettings ( ) . framework ; const localhost = framework . localhost || 's' ; const parts = localhost . split ( 's' ) ; let hostname = localhost ; if ( parts . length > 0 ) { hostname = parts [ 0 ] . trim ( ) ; } if ( parts . length > 0 ) { } this . localhost = hostname ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O O $any$ O O O O O O $any$ O O O O O $NgrokService$ O O O $any$ O O $NgrokInstance$ O O $any$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O O O O $string$ O O O O $boolean$ O O O O $Promise<void>$ O $PromiseConstructor$ O O O O O $NgrokInstance$ O $any$ O O O O O O $NgrokService$ O O $NgrokService$ O O O O O O O $Promise$ O $string$ O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O O $NgrokInstance$ O $boolean$ O O O O O O O $string$ O O O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O O $string$ O $any$ O $string$ O O O O $any$ O O $any$ O O $any$ O O $any$ O O O O O O O O $NgrokInstance$ O $boolean$ O O O O O O O $Promise<void>$ O O O O O O O $string$ O O O O O O O O $Promise$ O O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O O $NgrokInstance$ O $boolean$ O O O O O O O $string$ O O O O $NgrokInstance$ O O $any$ O O O O $number$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $number$ O O $any$ O $any$ O O O $any$ O $any$ O O $Promise<string>$ O O $PromiseConstructor$ O O O O O O $void$ O $void$ O O O O O O O $any$ O O O O O $NgrokInstance$ O $complex$ O O $number$ O $number$ O $any$ O $any$ O O O O $void$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O O $Promise<string>$ O O O $void$ O O O O O O O $NgrokInstance$ O O O O $NgrokInstance$ O $void$ O O O O O O $complex$ O O O O O $boolean$ O O O $any$ O O O O O O $boolean$ O O O $boolean$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O $FrameworkSettings$ O O O O $void$ O O O O O O O $string$ O $any$ O $any$ O O O $NgrokInstance$ O $boolean$ O O O O O O O $Promise<void>$ O O O O O O $Promise$ O O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O $NgrokInstance$ O $void$ O O O O $number$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O $number$ O O O $string$ O $any$ O O O $any$ O $any$ O O O $string$ O O O O O $string$ O O O O O $any$ O O O O O $boolean$ O O O O O O O $string$ O O O $string$ O $number$ O O O O O O $Promise<void>$ O O $PromiseConstructor$ O O $void$ O O O O O O $boolean$ O O O O O $any$ O $any$ O O O O O $NgrokInstance$ O $complex$ O O $number$ O $number$ O $string$ O O O $string$ O O O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $Console$ O $void$ O O O $any$ O O O O O $Promise<void>$ O O O $void$ O O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O $void$ O O O O O O O $NgrokInstance$ O O O O $NgrokInstance$ O $void$ O O O O O O O $any$ O O O $any$ O O O O $NgrokInstance$ O $any$ O $undefined$ O O O O $boolean$ O O O O O O O O $NgrokInstance$ O $boolean$ O O O O O O O $void$ O O O O O $void$ O $any$ O O O O O O O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O $any$ O O $void$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O O $any[]$ O $any$ O O O O O O $any$ O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O O $string[]$ O O O O O $any$ O $any$ O O O $string[]$ O $void$ O $string$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O O $any[]$ O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O $Promise<string>$ O $string$ O O O O O O $any$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O O O O $string$ O O O O $void$ O $string$ O O O O O O O O $NgrokInstance$ O $boolean$ O O O O O O $void$ O $string$ O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O O O $void$ O O O O O O $Promise<void>$ O O O O O $void$ O $string$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $void$ O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O $any$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $string$ O $any$ O O O
import { BotFrameworkService } from 's' ; import { NgrokService } from 's' ; let emulator ; class SingletonEnforcer { } export class Emulator { public ngrok = new NgrokService ( ) ; public framework = new BotFrameworkService ( ) ; private constructor ( enforcer ) { if ( ! ( enforcer instanceof SingletonEnforcer ) ) { throw new Error ( 's' ) ; } } public static getInstance ( ) { return emulator || ( emulator = new Emulator ( new SingletonEnforcer ( ) ) ) ; } public async startup ( port ) { await this . framework . recycle ( port ) ; } public async report ( conversationId , botUrl ) < void > { this . framework . report ( conversationId ) ; await this . ngrok . report ( conversationId , botUrl ) ; } }	O O $any$ O O O O O O $any$ O O O O O $Emulator$ O O $any$ O O O O $any$ O O $NgrokService$ O O $any$ O O O O $BotFrameworkService$ O O $any$ O O O O O O $SingletonEnforcer$ O O O O O O $SingletonEnforcer$ O $any$ O O O O O $ErrorConstructor$ O O O O O O O O $Emulator$ O O O O $Emulator$ O O $Emulator$ O O $any$ O O $any$ O O O O O O O O $Promise<void>$ O $any$ O O O O O $BotFrameworkService$ O $Promise<void>$ O $any$ O O O O O $Promise$ O $string$ O $string$ O O O O O O O $BotFrameworkService$ O $void$ O $string$ O O O O O $NgrokService$ O $Promise<void>$ O $string$ O $string$ O O O O
import { ClientAwareSettings , FrameworkSettings , SharedConstants } from 's' ; import { call , ForkEffect , select , takeEvery } from 's' ; import { app } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { Emulator } from 's' ; import { FrameworkAction , FrameworkActionType } from 's' ; import { REMEMBER_THEME } from 's' ; import { ADD_SAVED_BOT_URL } from 's' ; import { RootState } from 's' ; const getAvailableThemes = ( state ) => state . settings . windowState . availableThemes ; const getCurrentTheme = ( state ) => state . settings . windowState . theme ; const getState = ( state ) => state . settings ; export class SettingsSagas { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static * rememberThemeSaga ( ) < any > { const availableThemes = yield select ( getAvailableThemes ) ; const theme = yield select ( getCurrentTheme ) ; const themeInfo = availableThemes . find ( availableTheme => availableTheme . name === theme ) ; const { commandService } = SettingsSagas ; const { SwitchTheme } = SharedConstants . Commands . UI ; yield call ( [ commandService , commandService . remoteCall ] , SwitchTheme , themeInfo . name , themeInfo . href ) ; } public static * setFramework ( action < FrameworkSettings > ) < any > { const emulator = Emulator . getInstance ( ) ; yield emulator . ngrok . updateNgrokFromSettings ( action . payload ) ; emulator . framework . server . botEmulator . facilities . locale = action . payload . locale ; yield * SettingsSagas . pushClientAwareSettings ( ) ; } public static * pushClientAwareSettings ( ) { yield call ( [ SettingsSagas . commandService , SettingsSagas . commandService . call ] , SharedConstants . Commands . Emulator . StartEmulator , false ) ; const settingsState = yield select ( getState ) ; yield call ( [ SettingsSagas . commandService , SettingsSagas . commandService . remoteCall ] , SharedConstants . Commands . Settings . ReceiveGlobalSettings , { appPath : app . getAppPath ( ) , serverUrl : ( Emulator . getInstance ( ) . framework . serverUrl || 's' ) . replace ( 's' , 's' ) , cwd : ( process . cwd ( ) || 's' ) . replace ( "s" , 's' ) , users : settingsState . users , locale : settingsState . framework . locale , savedBotUrls : settingsState . savedBotUrls , } as ClientAwareSettings ) ; yield call ( [ SettingsSagas . commandService , SettingsSagas . commandService . call ] , SharedConstants . Commands . Emulator . OpenProtocolUrls ) ; } } const { PUSH_CLIENT_AWARE_SETTINGS , SET_FRAMEWORK } = FrameworkActionType ; export function * settingsSagas ( ) < ForkEffect > { yield takeEvery ( REMEMBER_THEME , SettingsSagas . rememberThemeSaga ) ; yield takeEvery ( SET_FRAMEWORK , SettingsSagas . setFramework ) ; yield takeEvery ( PUSH_CLIENT_AWARE_SETTINGS , SettingsSagas . pushClientAwareSettings ) ; yield takeEvery ( ADD_SAVED_BOT_URL , SettingsSagas . pushClientAwareSettings ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O $any$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O $any$ O $any$ O O $any$ O O $RootState$ O O $RootState$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $IterableIterator$ O O O O O O O $undefined$ O O $any$ O $any$ O O O $undefined$ O O $any$ O $any$ O O O $any$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $IterableIterator$ O $FrameworkAction$ O $any$ O O O O O O O $Emulator$ O $any$ O $Emulator$ O O O O $Emulator$ O $NgrokService$ O $Promise<void>$ O $FrameworkAction<any>$ O $any$ O O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O $FrameworkAction<any>$ O $any$ O $any$ O O O $any$ O $complex$ O O O O O O O $complex$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $Emulator$ O O O $BotFrameworkService$ O $string$ O O O O $complex$ O O O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $FrameworkActionType.SET_FRAMEWORK$ O O $any$ O O O O $IterableIterator$ O O O $any$ O O O $any$ O O O $any$ O $IterableIterator<any>$ O O O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O $any$ O $IterableIterator<any>$ O O O $any$ O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $any$ O $complex$ O O O $any$ O O O $any$ O $complex$ O O O
export * from 's' ;	O O O O O
import { Middleware } from 's' ; import { emulatorApplication } from 's' ; export const forwardToRenderer = _store => next => action => { if ( ! action . type ) { return next ( action ) ; } if ( ( action as any ) . meta && ( action as any ) . meta . doNotForward ) { return next ( action ) ; } emulatorApplication . mainBrowserWindow . webContents . send ( 's' , action ) ; return next ( action ) ; } ;	O O $any$ O O O O O O $EmulatorApplication$ O O O O O O $Middleware$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $EmulatorApplication$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O
import { ArmTokenData , AZURE_ARM_TOKEN_DATA_CHANGED , AZURE_BEGIN_AUTH_WORKFLOW , AZURE_INVALIDATE_ARM_TOKEN , AzureAuthAction , } from 's' ; export interface AzureAuthState { access_token : string ; persistLogin : boolean ; } const initialState = { access_token : null , persistLogin : false , } ; export function azureAuth ( state = initialState , action < ArmTokenData | void > ) { const { payload = { } , type = 's' } = action || { } ; const { access_token } = ( payload || { } ) as ArmTokenData ; switch ( type ) { case AZURE_BEGIN_AUTH_WORKFLOW : case AZURE_INVALIDATE_ARM_TOKEN : return { ... state , access_token : 's' } ; case AZURE_ARM_TOKEN_DATA_CHANGED : return { ... state , access_token } ; default : return state ; } }	O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O $boolean$ O O O O O $AzureAuthState$ O O $null$ O O O $false$ O O O O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction$ O $any$ O O O O O O O ${}$ O O O O $any$ O O O O $complex$ O O O O O O $string$ O O O ${}$ O O O O O $any$ O O O $any$ O O O O O O O O O O O $AzureAuthState$ O $string$ O O O O O O O O O O $AzureAuthState$ O $string$ O O O O O $AzureAuthState$ O O O
import { AzureSettings } from 's' ; import { AZURE_LOGGED_IN_USER_CHANGED , AZURE_PERSIST_LOGIN_CHANGED , AzureAuthAction , } from 's' ; export function azureAuthSettings ( state = { } , action < string | boolean > ) { switch ( action . type ) { case AZURE_PERSIST_LOGIN_CHANGED : return { ... state , persistLogin : action . payload as boolean } ; case AZURE_LOGGED_IN_USER_CHANGED : return { ... state , signedInUser : action . payload as string } ; default : return state ; } }	O O $any$ O O O O O O O O O O $any$ O O O O O O O $AzureSettings$ O $AzureSettings$ O O O O $AzureAuthAction$ O O O O O O O O O $complex$ O $any$ O O O O O O O O $any$ O $boolean$ O $complex$ O $complex$ O O O O O O O O O O $any$ O $string$ O $complex$ O $complex$ O O O O O O O $any$ O O O
import { BotInfo } from 's' ; import { applyBotConfigOverrides , BotConfigWithPath , botsAreTheSame } from 's' ; import { BotAction , BotActionType } from 's' ; export interface BotState { activeBot : BotConfigWithPath ; activeBotDigest : string ; botFiles : BotInfo [ ] ; currentBotDirectory : string ; } const DEFAULT_STATE = { activeBot : null , activeBotDigest : null , botFiles : [ ] , currentBotDirectory : 's' , } ; export const bot = ( state = DEFAULT_STATE , action ) : BotState => { switch ( action . type ) { case BotActionType . hashGenerated : return { ... state , activeBotDigest : action . payload . hash } ; case BotActionType . load : { state = setBotFilesState ( action . payload . bots , state ) ; break ; } case BotActionType . setActive : { const mostRecentBot = state . botFiles . find ( 0 => 0 && 0 . path === action . payload . bot . path ) ; const recentBots = state . botFiles . filter ( 0 => 0 && 0 . path !== action . payload . bot . path ) ; if ( mostRecentBot ) { recentBots . unshift ( mostRecentBot ) ; } let newActiveBot = action . payload . bot ; if ( botsAreTheSame ( state . activeBot , newActiveBot ) ) { newActiveBot = applyBotConfigOverrides ( newActiveBot , state . activeBot . overrides ) ; } state = setBotFilesState ( recentBots , state ) ; state = setActiveBot ( newActiveBot , state ) ; break ; } case BotActionType . setDirectory : { state = setCurrentBotDirectory ( action . payload . directory , state ) ; break ; } case BotActionType . close : { state = setActiveBot ( null , state ) ; break ; } default : break ; } return state ; } ; function setActiveBot ( 0 , state ) { return { ... state , get activeBot ( ) { return JSON . parse ( JSON . stringify ( 0 ) ) ; } , } ; } function setBotFilesState ( botFilesState : BotInfo [ ] , state ) { const newState = { ... state } ; newState . botFiles = botFilesState ; return newState ; } function setCurrentBotDirectory ( botDirectory , state ) { const newState = { ... state } ; newState . currentBotDirectory = botDirectory ; return newState ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O $any[]$ O $any$ O O O $string$ O O O O O $BotState$ O O $null$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O O $BotState$ O O $BotState$ O $BotState$ O $BotAction$ O O $any$ O O O O $BotAction<any>$ O $BotActionType$ O O O $any$ O $BotActionType.hashGenerated$ O O O O $BotState$ O $any$ O $BotAction<any>$ O $any$ O $any$ O O O $any$ O $BotActionType.load$ O O $BotState$ O $BotState$ O $BotAction<any>$ O $any$ O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.setActive$ O O O $any$ O $BotState$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O $any$ O $any$ O O O $any[]$ O $BotState$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $BotAction<any>$ O $any$ O $any$ O $any$ O O O O $any$ O O $any[]$ O $number$ O $any$ O O O O $any$ O $BotAction<any>$ O $any$ O $any$ O O O $any$ O $BotState$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $BotState$ O $any$ O $any$ O O O $BotState$ O $BotState$ O $any[]$ O $BotState$ O O $BotState$ O O O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.setDirectory$ O O $BotState$ O $BotState$ O $BotAction<any>$ O $any$ O $any$ O $BotState$ O O O O O O $any$ O $BotActionType.close$ O O $BotState$ O O O O O $BotState$ O O O O O O O O O O O $BotState$ O O O O $BotState$ O $BotConfigWithPath$ O $BotState$ O O O O O $BotState$ O O $any$ O O O O $JSON$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O O O O O $BotState$ O $any[]$ O $any$ O O O $BotState$ O O O $complex$ O O O $BotState$ O O $complex$ O $any[]$ O $any[]$ O O $complex$ O O O $BotState$ O $string$ O $BotState$ O O O $complex$ O O O $BotState$ O O $complex$ O $string$ O $string$ O O $complex$ O O
import { LogEntry } from 's' ; import { Action } from 's' ; import { Activity } from 's' ; import { EmulatorMode } from 's' ; import { ChatDocument } from 's' ; export enum ChatActions { activeInspectorChanged = 's' , newChat = 's' , openChat = 's' , closeConversation = 's' , closeDocument = 's' , newConversation = 's' , appendLog = 's' , clearLog = 's' , setInspectorObjects = 's' , setHighlightedObjects = 's' , addTranscript = 's' , clearTranscripts = 's' , removeTranscript = 's' , updateChat = 's' , showContextMenuForActivity = 's' , webSpeechFactoryUpdated = 's' , webChatStoreUpdated = 's' , updatePendingSpeechTokenRetrieval = 's' , } export interface ActiveInspectorChangedPayload { inspectorWebView : HTMLWebViewElement ; } export interface WebSpeechFactoryPayload { documentId : string ; factory : ( ) => any ; } export interface WebChatStorePayload { documentId : string ; store : any ; } export interface PendingSpeechTokenRetrievalPayload { pending : boolean ; } export interface DocumentIdPayload { documentId : string ; } export interface NewConversationPayload { documentId : string ; options : any ; } export interface AppendLogPayload { documentId : string ; entry : LogEntry ; } export interface ClearLogPayload { documentId : string ; resolver ? : Function ; } export interface SetInspectorObjectsPayload { documentId : string ; objs : any ; } export interface SetHighlightedObjectsPayload { documentId : string ; objs : Activity [ ] ; } export interface AddTranscriptPayload extends RemoveTranscriptPayload { } export interface RemoveTranscriptPayload { filename : string ; } export interface UpdateChatPayload { documentId : string ; updatedValues : any ; } export interface ChatAction < T = any > extends Action { payload : T ; } export function inspectorChanged ( inspectorWebView ) < ActiveInspectorChangedPayload > { return { type : ChatActions . activeInspectorChanged , payload : { inspectorWebView } , } ; } export function addTranscript ( filename ) < AddTranscriptPayload > { return { type : ChatActions . addTranscript , payload : { filename , } , } ; } export function clearTranscripts ( ) < { } > { return { type : ChatActions . clearTranscripts , payload : { } , } ; } export function removeTranscript ( filename ) < RemoveTranscriptPayload > { return { type : ChatActions . removeTranscript , payload : { filename , } , } ; } export function webSpeechFactoryUpdated ( documentId , factory : ( ) => any ) < WebSpeechFactoryPayload > { return { type : ChatActions . webSpeechFactoryUpdated , payload : { documentId , factory } , } ; } export function webChatStoreUpdated ( documentId , store ) < WebChatStorePayload > { return { type : ChatActions . webChatStoreUpdated , payload : { documentId , store } , } ; } export function updatePendingSpeechTokenRetrieval ( pending ) < PendingSpeechTokenRetrievalPayload > { return { type : ChatActions . updatePendingSpeechTokenRetrieval , payload : { pending } , } ; } export function newChat ( documentId , mode , additionalData ? < ChatDocument > ) < Partial < ChatDocument & ClearLogPayload > > { return { type : ChatActions . newChat , payload : { mode , documentId , conversationId : null , directLine : null , log : { entries : [ ] , } , inspectorObjects : [ ] , ui : { horizontalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , verticalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , } , ... additionalData , } , } ; } export function closeDocument ( documentId ) < DocumentIdPayload > { return { type : ChatActions . closeDocument , payload : { documentId , } , } ; } export function closeConversation ( documentId ) < DocumentIdPayload > { return { type : ChatActions . closeConversation , payload : { documentId , } , } ; } export function newConversation ( documentId , options ) < NewConversationPayload > { return { type : ChatActions . newConversation , payload : { documentId , options , } , } ; } export function appendToLog ( documentId , entry ) < AppendLogPayload > { return { type : ChatActions . appendLog , payload : { documentId , entry , } , } ; } export function clearLog ( documentId , resolver ? ) < ClearLogPayload > { return { type : ChatActions . clearLog , payload : { documentId , resolver , } , } ; } export function setInspectorObjects ( documentId , objs ) < SetInspectorObjectsPayload > { objs = Array . isArray ( objs ) ? objs : [ objs ] ; return { type : ChatActions . setInspectorObjects , payload : { documentId , objs , } , } ; } export function setHighlightedObjects ( documentId , objs : Activity | Activity [ ] ) < SetHighlightedObjectsPayload > { objs = Array . isArray ( objs ) ? objs : [ objs ] ; return { type : ChatActions . setHighlightedObjects , payload : { documentId , objs , } , } ; } export function updateChat ( documentId , updatedValues ) < UpdateChatPayload > { return { type : ChatActions . updateChat , payload : { documentId , updatedValues , } , } ; } export function showContextMenuForActivity ( activity < Activity > ) < Partial < Activity > > { return { type : ChatActions . showContextMenuForActivity , payload : activity , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $ChatActions.activeInspectorChanged$ O O O $ChatActions.newChat$ O O O $ChatActions.openChat$ O O O $ChatActions.closeConversation$ O O O $ChatActions.closeDocument$ O O O $ChatActions.newConversation$ O O O $ChatActions.appendLog$ O O O $ChatActions.clearLog$ O O O $ChatActions.setInspectorObjects$ O O O $ChatActions.setHighlightedObjects$ O O O $ChatActions.addTranscript$ O O O $ChatActions.clearTranscripts$ O O O $ChatActions.removeTranscript$ O O O $ChatActions.updateChat$ O O O $ChatActions.showContextMenuForActivity$ O O O $ChatActions.webSpeechFactoryUpdated$ O O O $ChatActions.webChatStoreUpdated$ O O O $ChatActions.updatePendingSpeechTokenRetrieval$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O $any$ O O O O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O O O O $any$ O $string$ O O O $Function$ O O $FunctionConstructor$ O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $string$ O O O $any[]$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $T$ O $any$ O O O O $ChatAction$ O $HTMLWebViewElement$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.activeInspectorChanged$ O $complex$ O O $any$ O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.addTranscript$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O O O O O O O O O $ChatActions$ O $any$ O $ChatActions.clearTranscripts$ O ${}$ O O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.removeTranscript$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O O O O O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.webSpeechFactoryUpdated$ O $complex$ O O $string$ O $any$ O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.webChatStoreUpdated$ O $complex$ O O $string$ O $any$ O O O O O O O $ChatAction$ O $boolean$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O $complex$ O O $boolean$ O O O O O O O $ChatAction$ O $string$ O $EmulatorMode$ O $Partial<ChatDocument<any>>$ $Partial$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $ChatActions$ O $any$ O $ChatActions.newChat$ O O O O $any$ O $string$ O $null$ O O O $null$ O O O $complex$ O O $undefined[]$ O O O O O O $undefined[]$ O O O O $complex$ O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O O O O $Partial<ChatDocument<any>>$ O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.closeDocument$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.closeConversation$ O $complex$ O O $string$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.newConversation$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $LogEntry$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.appendLog$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $Function$ $Function$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.clearLog$ O $complex$ O O $string$ O $Function$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.setInspectorObjects$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.setHighlightedObjects$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $string$ O $any$ O O $any$ O O O O $ChatActions$ O $any$ O $ChatActions.updateChat$ O $complex$ O O $string$ O $any$ O O O O O O O O $ChatAction$ O $Partial$ O $any$ O O O $any$ O $any$ O O O O O $ChatActions$ O $any$ O $ChatActions.showContextMenuForActivity$ O $any$ O $any$ O O O O
import { SharedConstants } from 's' ; import * as EditorActions from 's' ; import { Editor } from 's' ; import { store } from 's' ; export function hasNonGlobalTabs ( tabGroups ? : { [ editorKey ] : Editor } ) { tabGroups = tabGroups || store . getState ( ) . editor . editors ; let count = 0 ; for ( const key in tabGroups ) { if ( tabGroups [ key ] ) { count += Object . keys ( tabGroups [ key ] . documents ) . map ( documentId => tabGroups [ key ] . documents [ documentId ] ) . filter ( document => ! document . isGlobal ) . length ; } } return count ; } export function getTabGroupForDocument ( documentId , tabGroups ? : { [ editorKey ] : Editor } ) { tabGroups = tabGroups || store . getState ( ) . editor . editors ; for ( const key in tabGroups ) { if ( tabGroups [ key ] && tabGroups [ key ] . documents ) { if ( tabGroups [ key ] . documents [ documentId ] ) { return key ; } } } return undefined ; } export function getOtherTabGroup ( tabGroup ) { return tabGroup === SharedConstants . EDITOR_KEY_PRIMARY ? SharedConstants . EDITOR_KEY_SECONDARY : SharedConstants . EDITOR_KEY_PRIMARY ; } export function showWelcomePage ( ) { store . dispatch ( EditorActions . open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_WELCOME_PAGE , documentId : SharedConstants . DocumentIds . DOCUMENT_ID_WELCOME_PAGE , isGlobal : true , } ) ) ; } export function showMarkdownPage ( markdown , label , onLine ) { store . dispatch ( EditorActions . open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_MARKDOWN , documentId : SharedConstants . DocumentIds . DOCUMENT_ID_MARKDOWN_PAGE , isGlobal : true , meta : { markdown , label , onLine } , } ) ) ; } export function tabGroupHasDocuments ( tabGroup ) { return ! ! Object . keys ( tabGroup . documents ) . length ; }	O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $number$ O $complex$ O O O O $string$ O O $any$ O O O $complex$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O O $number$ O $ObjectConstructor$ O $complex$ O $complex$ O $string$ O O $complex$ O O $U[]$ O $string$ O $complex$ O $string$ O O $complex$ O $string$ O O O $complex$ O $Document<any>$ O O $Document<any>$ O $boolean$ O O $number$ O O O O $number$ O O O O $string$ O $string$ O $complex$ O O O O $string$ O O $any$ O O O $complex$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O $complex$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O $string$ O O O O O $undefined$ O O O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $true$ O O O O O O O O O O $void$ O $string$ O $string$ O $boolean$ O O $any$ O $any$ O $any$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $true$ O O O $complex$ O O $string$ O $string$ O $boolean$ O O O O O O O O O $boolean$ O $Editor$ O O O O O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O $number$ O O
import { deepCopySlow , SharedConstants } from 's' ; import { DirectLine } from 's' ; import { Activity } from 's' ; import { EmulatorMode } from 's' ; import { BotAction } from 's' ; import { EditorAction , EditorActions } from 's' ; import { getOtherTabGroup , tabGroupHasDocuments } from 's' ; export interface EditorState < M = any > { activeEditor ? : string ; draggingTab ? : boolean ; editors ? : { [ editorKey ] : Editor < M > } ; docsWithPendingChanges ? : string [ ] ; } export interface Editor < M = any > { activeDocumentId ? : string ; documents ? : { [ documentId ] : Document < M > } ; tabOrder ? : string [ ] ; recentTabs ? : string [ ] ; } export interface Document < M = any > { activities : Activity [ ] ; botId : string ; conversationId : string ; contentType : string ; directLine : DirectLine ; dirty ? : boolean ; documentId ? : string ; fileName ? : string ; filePath ? : string ; inMemory ? : boolean ; isGlobal ? : boolean ; meta ? : M ; mode : EmulatorMode ; ui ? : DocumentUI ; userId : string ; } export interface DocumentUI { horizontalSplitter : SplitterSize [ ] ; verticalSplitter : SplitterSize [ ] ; } export interface SplitterSize { absolute : boolean ; percentage : number ; } const DEFAULT_STATE = { activeEditor : SharedConstants . EDITOR_KEY_PRIMARY , draggingTab : false , editors : { [ SharedConstants . EDITOR_KEY_PRIMARY ] : getNewEditor ( ) , [ SharedConstants . EDITOR_KEY_SECONDARY ] : getNewEditor ( ) , } , docsWithPendingChanges : [ ] , } ; export const editor = ( state = DEFAULT_STATE , action : EditorAction | BotAction ) : EditorState => { Object . freeze ( state ) ; switch ( action . type ) { case EditorActions . appendTab : { const { srcEditorKey , destEditorKey } = action . payload ; if ( srcEditorKey === destEditorKey ) { let tabOrder = [ ... state . editors [ srcEditorKey ] . tabOrder ] ; tabOrder = [ ... tabOrder . filter ( docId => docId !== action . payload . documentId ) , action . payload . documentId ] ; const editorState = { ... state . editors [ srcEditorKey ] , tabOrder , } ; state = setEditorState ( srcEditorKey , editorState , state ) ; state = setDraggingTab ( false , state ) ; break ; } const docToAppend = state . editors [ srcEditorKey ] . documents [ action . payload . documentId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . documentId ) ; const destTabOrder = [ ... state . editors [ destEditorKey ] . tabOrder , action . payload . documentId ] ; const destRecentTabs = [ ... state . editors [ destEditorKey ] . recentTabs , action . payload . documentId ] ; const destDocs = { ... state . editors [ destEditorKey ] . documents } ; destDocs [ action . payload . documentId ] = docToAppend ; const destEditor = { ... state . editors [ destEditorKey ] , documents : destDocs , recentTabs : destRecentTabs , tabOrder : destTabOrder , } ; if ( ! tabGroupHasDocuments ( srcEditor ) && srcEditorKey === SharedConstants . EDITOR_KEY_PRIMARY ) { state = setNewPrimaryEditor ( destEditor , state ) ; } else { state = setActiveEditor ( ! tabGroupHasDocuments ( srcEditor ) ? destEditorKey : state . activeEditor , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; } state = setDraggingTab ( false , state ) ; break ; } case EditorActions . close : { const { editorKey } = action . payload ; const 0 = removeDocumentFromTabGroup ( state . editors [ editorKey ] , action . payload . documentId ) ; const newPrimaryEditorKey = getOtherTabGroup ( editorKey ) ; if ( ! tabGroupHasDocuments ( 0 ) && state . editors [ newPrimaryEditorKey ] ) { const tmp = deepCopySlow ( state . editors [ newPrimaryEditorKey ] ) ; state = setNewPrimaryEditor ( tmp , state ) ; } else { state = setEditorState ( editorKey , 0 , state ) ; } break ; } case EditorActions . closeAll : { if ( action . payload . includeGlobal ) { return DEFAULT_STATE ; } else { let newState = { ... state , } ; for ( const key in state . editors ) { if ( ! state . editors . hasOwnProperty ( key ) ) { continue ; } const tabGroup = state . editors [ key ] ; if ( tabGroup ) { let newTabOrder = [ ... tabGroup . tabOrder ] ; let newRecentTabs = [ ... tabGroup . recentTabs ] ; const newDocs = { } ; Object . keys ( tabGroup . documents ) . forEach ( documentId => { const document = tabGroup . documents [ documentId ] ; if ( document . isGlobal ) { newDocs [ documentId ] = document ; } else { newTabOrder = newTabOrder . filter ( documentIdArg => documentIdArg !== documentId ) ; newRecentTabs = newRecentTabs . filter ( documentIdArg => documentIdArg !== documentId ) ; } } ) ; const newTabGroup = { activeDocumentId : newRecentTabs [ 0 ] || null , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; newState = { ... newState , editors : { ... newState . editors , [ key ] : newTabGroup , } , } ; } } newState = setDocsWithPendingChanges ( [ ] , newState ) ; state = fixupTabGroups ( newState ) ; } break ; } case EditorActions . open : { const editorKey = state . activeEditor ; const otherTabGroup = getOtherTabGroup ( editorKey ) ; if ( tabGroupHasDocuments ( state . editors [ otherTabGroup ] ) && state . editors [ otherTabGroup ] . documents [ action . payload . documentId ] ) { const recentTabs = [ ... state . editors [ otherTabGroup ] . recentTabs ] . filter ( docId => docId !== action . payload . documentId ) ; recentTabs . unshift ( action . payload . documentId ) ; const tabGroupState = { ... state . editors [ otherTabGroup ] , activeDocumentId : action . payload . documentId , recentTabs , } ; state = setEditorState ( otherTabGroup , tabGroupState , state ) ; state = setActiveEditor ( otherTabGroup , state ) ; break ; } let newTabOrder ; if ( state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { newTabOrder = [ ... state . editors [ editorKey ] . tabOrder ] ; } else { const activeDocumentId = state . editors [ state . activeEditor ] . activeDocumentId ; const activeIndex = state . editors [ editorKey ] . tabOrder . indexOf ( activeDocumentId ) ; if ( activeIndex != null && activeIndex !== - 0 ) { state . editors [ editorKey ] . tabOrder . splice ( activeIndex + 0 , 0 , action . payload . documentId ) ; newTabOrder = [ ... state . editors [ editorKey ] . tabOrder ] ; } else { newTabOrder = [ ... state . editors [ editorKey ] . tabOrder , action . payload . documentId ] ; } } const newRecentTabs = [ ... state . editors [ editorKey ] . recentTabs ] . filter ( docId => docId !== action . payload . documentId ) ; newRecentTabs . unshift ( action . payload . documentId ) ; const newDocs = deepCopySlow ( state . editors [ editorKey ] . documents ) ; if ( ! newDocs [ action . payload . documentId ] ) { newDocs [ action . payload . documentId ] = { } ; } Object . assign ( newDocs [ action . payload . documentId ] , action . payload ) ; const editorState = { ... state . editors [ editorKey ] , activeDocumentId : action . payload . documentId , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; state = setEditorState ( editorKey , editorState , state ) ; state = setActiveEditor ( editorKey , state ) ; break ; } case EditorActions . updateDocument : { const { payload : updatedDocument } : { payload : Partial < Document > } = action ; const { editors } = state ; const editorKeys = Object . keys ( editors ) ; let i = editorKeys . length ; outer : while ( i -- ) { const documents = editors [ editorKeys [ i ] ] . documents ; const documentKeys = Object . keys ( documents ) ; let j = documentKeys . length ; while ( j -- ) { const document = documents [ documentKeys [ j ] ] ; if ( document . documentId === updatedDocument . documentId ) { documents [ documentKeys [ j ] ] = { ... document , ... updatedDocument } ; break outer ; } } } state = JSON . parse ( JSON . stringify ( state ) ) ; break ; } case EditorActions . setActiveEditor : { state = setActiveEditor ( action . payload . editorKey , state ) ; break ; } case EditorActions . setActiveTab : { SharedConstants . EditorKeys . forEach ( editorKey => { if ( state . editors [ editorKey ] && state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { const recentTabs = state . editors [ editorKey ] . recentTabs . filter ( tabId => tabId !== action . payload . documentId ) ; recentTabs . unshift ( action . payload . documentId ) ; const editorState = { ... state . editors [ editorKey ] , activeDocumentId : action . payload . documentId , recentTabs , } ; state = setEditorState ( editorKey , editorState , state ) ; state = setActiveEditor ( editorKey , state ) ; } } ) ; break ; } case EditorActions . setDirtyFlag : { SharedConstants . EditorKeys . forEach ( editorKey => { if ( state . editors [ editorKey ] && state . editors [ editorKey ] . documents [ action . payload . documentId ] ) { const newDocs = deepCopySlow ( state . editors [ editorKey ] . documents ) ; const docToSet = newDocs [ action . payload . documentId ] ; docToSet . dirty = action . payload . dirty ; const editorState = { ... state . editors [ editorKey ] , documents : newDocs , } ; state = setEditorState ( editorKey , editorState , state ) ; } } ) ; break ; } case EditorActions . splitTab : { const { srcEditorKey } = action . payload ; const { destEditorKey } = action . payload ; const docToAppend = state . editors [ srcEditorKey ] . documents [ action . payload . documentId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . documentId ) ; const destEditor = state . editors [ destEditorKey ] ? deepCopySlow ( state . editors [ destEditorKey ] ) : getNewEditor ( ) ; const destTabOrder = [ ... destEditor . tabOrder , action . payload . documentId ] ; const destRecentTabs = [ ... destEditor . recentTabs ] ; destRecentTabs . unshift ( action . payload . documentId ) ; const destDocs = deepCopySlow ( destEditor . documents ) ; destDocs [ action . payload . documentId ] = docToAppend ; destEditor . activeDocumentId = action . payload . documentId ; destEditor . documents = destDocs ; destEditor . recentTabs = destRecentTabs ; destEditor . tabOrder = destTabOrder ; state = setActiveEditor ( destEditorKey , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; state = setDraggingTab ( false , state ) ; break ; } case EditorActions . swapTabs : { const { srcEditorKey } = action . payload ; const { destEditorKey } = action . payload ; if ( srcEditorKey === destEditorKey ) { const tabOrder = [ ... state . editors [ srcEditorKey ] . tabOrder ] ; const srcTabIndex = tabOrder . findIndex ( docId => docId === action . payload . srcTabId ) ; const 0 = tabOrder . findIndex ( docId => docId === action . payload . destTabId ) ; const destTab = tabOrder [ 0 ] ; tabOrder [ 0 ] = tabOrder [ srcTabIndex ] ; tabOrder [ srcTabIndex ] = destTab ; const editorState = { ... state . editors [ srcEditorKey ] , tabOrder , } ; state = setEditorState ( srcEditorKey , editorState , state ) ; break ; } const docToSwap = state . editors [ srcEditorKey ] . documents [ action . payload . srcTabId ] ; const srcEditor = removeDocumentFromTabGroup ( state . editors [ srcEditorKey ] , action . payload . srcTabId ) ; const destEditor = deepCopySlow ( state . editors [ destEditorKey ] ) ; destEditor . documents [ action . payload . srcTabId ] = docToSwap ; const destRecentTabs = [ ... destEditor . recentTabs , action . payload . srcTabId ] ; destEditor . recentTabs = destRecentTabs ; const destTabIndex = destEditor . tabOrder . findIndex ( docId => docId === action . payload . destTabId ) ; const destTabOrder = [ ... destEditor . tabOrder . splice ( 0 , destTabIndex + 0 ) , action . payload . srcTabId , ... destEditor . tabOrder , ] ; destEditor . tabOrder = destTabOrder ; if ( ! tabGroupHasDocuments ( srcEditor ) && srcEditorKey === SharedConstants . EDITOR_KEY_PRIMARY ) { state = setNewPrimaryEditor ( destEditor , state ) ; } else { state = setActiveEditor ( ! tabGroupHasDocuments ( srcEditor ) ? destEditorKey : state . activeEditor , state ) ; state = setEditorState ( srcEditorKey , srcEditor , state ) ; state = setEditorState ( destEditorKey , destEditor , state ) ; } break ; } case EditorActions . toggleDraggingTab : { state = setDraggingTab ( action . payload . draggingTab , state ) ; break ; } case EditorActions . addDocPendingChange : { const docsPendingChange = [ ... state . docsWithPendingChanges . filter ( d => d !== action . payload . documentId ) , action . payload . documentId , ] ; state = setDocsWithPendingChanges ( docsPendingChange , state ) ; break ; } case EditorActions . removeDocPendingChange : { const docsPendingChange = [ ... state . docsWithPendingChanges ] . filter ( d => d !== action . payload . documentId ) ; state = setDocsWithPendingChanges ( docsPendingChange , state ) ; break ; } case EditorActions . dropTabOnLeftOverlay : { const { tabId : tabToIsolate } = action . payload ; const primary = SharedConstants . EDITOR_KEY_PRIMARY ; const secondary = SharedConstants . EDITOR_KEY_SECONDARY ; const docToIsolate = state . editors [ primary ] . documents [ tabToIsolate ] ; const primaryTabs = [ tabToIsolate ] ; const primaryDocs = { [ tabToIsolate ] : docToIsolate } ; const secondaryTabOrder = state . editors [ primary ] . tabOrder . filter ( tabId => tabId !== tabToIsolate ) ; const secondaryRecentTabs = state . editors [ primary ] . recentTabs . filter ( tabId => tabId !== tabToIsolate ) ; const secondaryDocs = state . editors [ primary ] . documents ; delete secondaryDocs [ tabToIsolate ] ; const primaryEditor = getNewEditor ( ) ; primaryEditor . activeDocumentId = tabToIsolate ; primaryEditor . documents = primaryDocs ; primaryEditor . recentTabs = primaryTabs ; primaryEditor . tabOrder = primaryTabs ; const secondaryEditor = getNewEditor ( ) ; secondaryEditor . activeDocumentId = secondaryRecentTabs [ 0 ] || null ; secondaryEditor . recentTabs = secondaryRecentTabs ; secondaryEditor . tabOrder = secondaryTabOrder ; secondaryEditor . documents = secondaryDocs ; state = setEditorState ( primary , primaryEditor , state ) ; state = setEditorState ( secondary , secondaryEditor , state ) ; break ; } default : break ; } return state ; } ; function getNewEditor ( ) { return { activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } ; } export function removeDocumentFromTabGroup ( tabGroup , documentId ) { const newTabOrder = [ ... tabGroup . tabOrder ] . filter ( docId => docId !== documentId ) ; const newRecentTabs = [ ... tabGroup . recentTabs ] . filter ( docId => docId !== documentId ) ; const newDocs = { ... tabGroup . documents } ; delete newDocs [ documentId ] ; const newActiveDocumentId = newRecentTabs [ 0 ] || null ; const newTabGroup = Object . keys ( newDocs ) . length === 0 ? getNewEditor ( ) : { ... tabGroup , activeDocumentId : newActiveDocumentId , documents : newDocs , recentTabs : newRecentTabs , tabOrder : newTabOrder , } ; return newTabGroup ; } export function setEditorState ( editorKey , editorState , state ) { const newState = deepCopySlow ( state ) ; newState . editors [ editorKey ] = editorState ; return newState ; } export function setActiveEditor ( editorKey , state ) { const newState = deepCopySlow ( state ) ; newState . activeEditor = editorKey ; return newState ; } export function setNewPrimaryEditor ( newPrimaryEditor , state ) { const newState = deepCopySlow ( state ) ; newState . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] = getNewEditor ( ) ; newState . editors [ SharedConstants . EDITOR_KEY_PRIMARY ] = newPrimaryEditor ; newState . activeEditor = SharedConstants . EDITOR_KEY_PRIMARY ; return newState ; } export function setDraggingTab ( dragging , state ) { const newState = deepCopySlow ( state ) ; newState . draggingTab = dragging ; return newState ; } export function fixupTabGroups ( state ) { if ( ! tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_PRIMARY ] ) && tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] ) ) { state = setNewPrimaryEditor ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] , state ) ; } if ( state . activeEditor === SharedConstants . EDITOR_KEY_SECONDARY && ! tabGroupHasDocuments ( state . editors [ SharedConstants . EDITOR_KEY_SECONDARY ] ) ) { state = setActiveEditor ( SharedConstants . EDITOR_KEY_PRIMARY , state ) ; } return state ; } export function setDocsWithPendingChanges ( docs : string [ ] , state ) { const newState = deepCopySlow ( state ) ; newState . docsWithPendingChanges = docs ; return newState ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O $boolean$ O O O O O O $any$ O $any$ O O O O $string$ O O O O $boolean$ O O O O $complex$ O O O O $string$ O O $any$ O $any$ O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O $string$ O O O O $complex$ O O O O $string$ O O $any$ O $any$ O O O $string[]$ O O O O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O $any[]$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $boolean$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $M$ O O $any$ O $any$ O $any$ O $DocumentUI$ O O $any$ O $string$ O O O O O O $any$ O $SplitterSize[]$ O $any$ O O O $SplitterSize[]$ O $any$ O O O O O O $any$ O $boolean$ O O O $number$ O O O O O $EditorState$ O O $any$ O $any$ O $any$ O $false$ O O O $complex$ O O O $any$ O $any$ O O $Editor<any>$ O O O O $any$ O $any$ O O $Editor<any>$ O O O O O $undefined[]$ O O O O O O O O O O O $EditorState$ O $EditorState<any>$ O O O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O O O O O O $complex$ O O O $any$ O $EditorActions.appendTab$ O O O O $string$ O $string$ O O $AppendTabAction$ O $complex$ O O O $string$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $string[]$ O O O $string[]$ O $complex$ O $string$ O $string$ O $AppendTabAction$ O $complex$ O $string$ O O $AppendTabAction$ O $complex$ O $string$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $AppendTabAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $AppendTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $AppendTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $AppendTabAction$ O $complex$ O $string$ O O O $complex$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O O $complex$ O $AppendTabAction$ O $complex$ O $string$ O O $Document<any>$ O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $complex$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O O O $boolean$ O $Editor<any>$ O O $string$ O $any$ O $any$ O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O O $boolean$ O $Editor<any>$ O O $string$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $any$ O $EditorActions.close$ O O O O $string$ O O $CloseEditorAction$ O $complex$ O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $CloseEditorAction$ O $complex$ O $string$ O O O $string$ O $string$ O $string$ O O O O O $boolean$ O $Editor<any>$ O O $EditorState<any>$ O $complex$ O $string$ O O O O $Editor$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.closeAll$ O O O O $CloseAllEditorAction$ O $complex$ O $boolean$ O O O $EditorState<any>$ O O O O O $EditorState$ O O O $EditorState<any>$ O O O O O O $string$ O $EditorState<any>$ O $complex$ O O O O O $EditorState<any>$ O $complex$ O $boolean$ O $string$ O O O O O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O O O $Editor<any>$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O O ${}$ O O O O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O $void$ O $string$ O O O $Document<any>$ O $Editor<any>$ O $complex$ O $string$ O O O O $Document<any>$ O $boolean$ O O ${}$ O $string$ O O $Document<any>$ O O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O O O O O $Editor$ O O $string$ O $string[]$ O O O O O O ${}$ O ${}$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $complex$ O O O $EditorState<any>$ O $complex$ O O $string$ O O $Editor<any>$ O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.open$ O O O $string$ O $EditorState<any>$ O $string$ O O $string$ O $string$ O $string$ O O O O $boolean$ O $EditorState<any>$ O $complex$ O $string$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $complex$ O $string$ O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $string[]$ O $number$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O O O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O O O O $string$ O $EditorState<any>$ O $complex$ O $EditorState<any>$ O $string$ O O $string$ O O $number$ O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $number$ O $string$ O O O O $number$ O O O $number$ O O O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $complex$ O $number$ O O O O O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O O O $any$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O $complex$ O $string$ O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $string[]$ O $number$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O O O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O O O O O $ObjectConstructor$ O O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O O $OpenEditorAction$ O $Partial<Document<any>>$ O O O $Editor$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string$ O $OpenEditorAction$ O $Partial<Document<any>>$ O $string$ O $any$ O $any$ O $string[]$ O $string[]$ O $any$ O $any$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.updateDocument$ O O O O $Partial<Document<any>>$ O $Partial<Document<any>>$ O O O $Partial<Document<any>>$ O $any$ O $any$ O O O $UpdateDocumentAction$ O O O $complex$ O O $EditorState<any>$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $number$ O $string[]$ O $number$ O $any$ O O O $number$ O O O O $complex$ O $complex$ O $string[]$ O $number$ O O O $complex$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $number$ O $string[]$ O $number$ O O O $number$ O O O O $Document<any>$ O $complex$ O $string[]$ O $number$ O O O O O $Document<any>$ O $string$ O $Partial<Document<any>>$ O $string$ O O $complex$ O $string[]$ O $number$ O O O O O $Document<any>$ O O $Partial<Document<any>>$ O O O $any$ O O O O $EditorState<any>$ O $JSON$ O $any$ O $JSON$ O $complex$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.setActiveEditor$ O O $EditorState<any>$ O $EditorState<any>$ O $SetActiveEditorAction$ O $complex$ O $string$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.setActiveTab$ O O $any$ O $any$ O $any$ O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $SetActiveTabAction$ O $complex$ O $string$ O O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $SetActiveTabAction$ O $complex$ O $string$ O O $string[]$ O $number$ O $SetActiveTabAction$ O $complex$ O $string$ O O O $complex$ O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O $SetActiveTabAction$ O $complex$ O $string$ O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $complex$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $EditorState<any>$ O O O O O O O O O O $any$ O $EditorActions.setDirtyFlag$ O O $any$ O $any$ O $any$ O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $SetDirtyFlagAction$ O $complex$ O $string$ O O O O $any$ O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O $any$ O $any$ O $SetDirtyFlagAction$ O $complex$ O $string$ O O $any$ O $any$ O $SetDirtyFlagAction$ O $complex$ O $boolean$ O O $Editor$ O O O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $any$ O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O O O O $any$ O $EditorActions.splitTab$ O O O O $string$ O O $SplitTabAction$ O $complex$ O O O $string$ O O $SplitTabAction$ O $complex$ O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $SplitTabAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $SplitTabAction$ O $complex$ O $string$ O O O $Editor$ O $EditorState<any>$ O $complex$ O $string$ O O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $Editor<any>$ O O O O $string[]$ O O O $Editor<any>$ O $string[]$ O $SplitTabAction$ O $complex$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $string[]$ O $number$ O $SplitTabAction$ O $complex$ O $string$ O O O $any$ O $any$ O $Editor<any>$ O $complex$ O O $any$ O $SplitTabAction$ O $complex$ O $string$ O O $Document<any>$ O $Editor<any>$ O $string$ O $SplitTabAction$ O $complex$ O $string$ O $Editor<any>$ O $complex$ O $any$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O $EditorState<any>$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O O O O O $any$ O $EditorActions.swapTabs$ O O O O $string$ O O $SwapTabsAction$ O $complex$ O O O $string$ O O $SwapTabsAction$ O $complex$ O O O $string$ O $string$ O O O $string[]$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $number$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $number$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $string$ O $string[]$ O $number$ O O $string[]$ O $number$ O O $string[]$ O $number$ O O $string[]$ O $number$ O O $string$ O O $complex$ O O O $EditorState<any>$ O $complex$ O $string$ O O $string[]$ O O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $complex$ O $EditorState<any>$ O O O O O O $Document<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $complex$ O $SwapTabsAction$ O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O $EditorState<any>$ O $complex$ O $string$ O O $SwapTabsAction$ O $complex$ O $string$ O O O $Editor$ O $any$ O $EditorState<any>$ O $complex$ O $string$ O O O $Editor<any>$ O $complex$ O $SwapTabsAction$ O $complex$ O $string$ O O $Document<any>$ O O $string[]$ O O O $Editor<any>$ O $string[]$ O $SwapTabsAction$ O $complex$ O $string$ O O $Editor<any>$ O $string[]$ O $string[]$ O O $number$ O $Editor<any>$ O $string[]$ O $number$ O $string$ O $string$ O $SwapTabsAction$ O $complex$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O $complex$ O O O $number$ O O O O $SwapTabsAction$ O $complex$ O $string$ O O $Editor<any>$ O $string[]$ O O O $Editor<any>$ O $string[]$ O $string[]$ O O O O $boolean$ O $Editor<any>$ O O $string$ O $any$ O $any$ O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O O O O $EditorState<any>$ O $EditorState<any>$ O O $boolean$ O $Editor<any>$ O O $string$ O $EditorState<any>$ O $string$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $string$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O $any$ O $EditorActions.toggleDraggingTab$ O O $EditorState<any>$ O $EditorState<any>$ O $ToggleDraggingTabAction$ O $complex$ O $boolean$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.addDocPendingChange$ O O O $string[]$ O O O $EditorState<any>$ O $string[]$ O $complex$ O $string$ O $string$ O $AddDocPendingChangeAction$ O $complex$ O $string$ O O $AddDocPendingChangeAction$ O $complex$ O $string$ O O O $EditorState<any>$ O $EditorState<any>$ O $string[]$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.removeDocPendingChange$ O O O $string[]$ O O O $EditorState<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $RemoveDocPendingChangeAction$ O $complex$ O $string$ O O $EditorState<any>$ O $EditorState<any>$ O $string[]$ O $EditorState<any>$ O O O O O O $any$ O $EditorActions.dropTabOnLeftOverlay$ O O O O $string$ O $string$ O O $DropTabOnLeftOverlayAction$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Document<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O $string$ O O O $string[]$ O O $string$ O O O $complex$ O O O $string$ O O $Document<any>$ O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O $string[]$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O $complex$ O $string$ O O O $Editor<any>$ O $Editor<any>$ O O O $Editor<any>$ O $string$ O $string$ O $Editor<any>$ O $complex$ O $complex$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O O $Editor<any>$ O $Editor<any>$ O O O $Editor<any>$ O $string$ O $string[]$ O O O O O O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $string[]$ O $string[]$ O $Editor<any>$ O $complex$ O $complex$ O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O O O O O O O O O O $EditorState<any>$ O O O O $Editor$ O O O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O $Editor$ O $Editor$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $string$ O O O $string[]$ O O O $Editor<any>$ O $string[]$ O O $complex$ O $string$ O $string$ O $string$ O O O $complex$ O O O $Editor<any>$ O $complex$ O O O $complex$ O $string$ O O O $string$ O $string[]$ O O O O O O O $Editor$ O $ObjectConstructor$ O $complex$ O $complex$ O O $number$ O O O $Editor<any>$ O O O O O $Editor<any>$ O $string$ O $string$ O $complex$ O $complex$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O $Editor<any>$ O O O O $EditorState$ O $string$ O $Editor$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $string$ O O $Editor<any>$ O O $any$ O O O O $EditorState$ O $string$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $string$ O O $any$ O O O O $EditorState$ O $Editor$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $any$ O $any$ O O $Editor<any>$ O O O $any$ O $any$ O $any$ O $any$ O O $Editor<any>$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $EditorState$ O $boolean$ O $EditorState$ O O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $any$ O $boolean$ O O $any$ O O O O $EditorState$ O $EditorState$ O O O O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O $EditorState<any>$ O O O O O $EditorState<any>$ O $string$ O $any$ O $any$ O O $boolean$ O $EditorState<any>$ O $complex$ O $any$ O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $any$ O $EditorState<any>$ O O O O $EditorState<any>$ O O O O $EditorState$ O $string[]$ O O O O O $EditorState$ O O O $EditorState$ O $any$ O $EditorState<any>$ O O $EditorState<any>$ O $string[]$ O $string[]$ O O $EditorState<any>$ O O
import { Document } from 's' ; export enum EditorActions { appendTab = 's' , addDocPendingChange = 's' , removeDocPendingChange = 's' , close = 's' , closeAll = 's' , dropTabOnLeftOverlay = 's' , setDirtyFlag = 's' , open = 's' , setActiveTab = 's' , setActiveEditor = 's' , splitTab = 's' , swapTabs = 's' , toggleDraggingTab = 's' , updateDocument = 's' , } export interface AppendTabAction { type : EditorActions . appendTab ; payload : { srcEditorKey : string ; destEditorKey : string ; documentId : string ; } ; } export interface CloseEditorAction { type : EditorActions . close ; payload : { editorKey : string ; documentId : string ; } ; } export interface CloseAllEditorAction { type : EditorActions . closeAll ; payload : { includeGlobal : boolean ; } ; } export interface SetDirtyFlagAction { type : EditorActions . setDirtyFlag ; payload : { documentId : string ; dirty : boolean ; } ; } export interface OpenEditorAction { type : EditorActions . open ; payload : Partial < Document > ; } export interface UpdateDocumentAction { type : EditorActions . updateDocument ; payload : Partial < Document > ; } export interface SetActiveTabAction { type : EditorActions . setActiveTab ; payload : { documentId : string ; } ; } export interface SetActiveEditorAction { type : EditorActions . setActiveEditor ; payload : { editorKey : string ; } ; } export interface SplitTabAction { type : EditorActions . splitTab ; payload : { contentType : string ; documentId : string ; srcEditorKey : string ; destEditorKey : string ; } ; } export interface SwapTabsAction { type : EditorActions . swapTabs ; payload : { srcEditorKey : string ; destEditorKey : string ; srcTabId : string ; destTabId : string ; } ; } export interface ToggleDraggingTabAction { type : EditorActions . toggleDraggingTab ; payload : { draggingTab : boolean ; } ; } export interface AddDocPendingChangeAction { type : EditorActions . addDocPendingChange ; payload : { documentId : string ; } ; } export interface RemoveDocPendingChangeAction { type : EditorActions . removeDocPendingChange ; payload : { documentId : string ; } ; } export interface DropTabOnLeftOverlayAction { type : EditorActions . dropTabOnLeftOverlay ; payload : { tabId : string ; } ; } export type EditorAction = | AppendTabAction | CloseEditorAction | CloseAllEditorAction | SetDirtyFlagAction | OpenEditorAction | UpdateDocumentAction | SetActiveTabAction | SetActiveEditorAction | SplitTabAction | SwapTabsAction | ToggleDraggingTabAction | AddDocPendingChangeAction | RemoveDocPendingChangeAction | DropTabOnLeftOverlayAction ; export function appendTab ( srcEditorKey , destEditorKey , documentId ) { return { type : EditorActions . appendTab , payload : { srcEditorKey , destEditorKey , documentId , } , } ; } export function addDocPendingChange ( documentId ) { return { type : EditorActions . addDocPendingChange , payload : { documentId , } , } ; } export function removeDocPendingChange ( documentId ) { return { type : EditorActions . removeDocPendingChange , payload : { documentId , } , } ; } export function close ( editorKey , documentId ) { return { type : EditorActions . close , payload : { editorKey , documentId , } , } ; } export function closeNonGlobalTabs ( ) { return { type : EditorActions . closeAll , payload : { includeGlobal : false , } , } ; } export function setDirtyFlag ( documentId , dirty ) { return { type : EditorActions . setDirtyFlag , payload : { documentId , dirty , } , } ; } export function open ( document < Document > ) { return { type : EditorActions . open , payload : document , } ; } export function updateDocument ( documentId , updatedDocument < Document > ) { return { type : EditorActions . updateDocument , payload : { documentId , ... updatedDocument } , } ; } export function setActiveTab ( documentId ) { return { type : EditorActions . setActiveTab , payload : { documentId , } , } ; } export function setActiveEditor ( editorKey ) { return { type : EditorActions . setActiveEditor , payload : { editorKey , } , } ; } export function splitTab ( contentType , documentId , srcEditorKey , destEditorKey ) { return { type : EditorActions . splitTab , payload : { contentType , documentId , srcEditorKey , destEditorKey , } , } ; } export function swapTabs ( srcEditorKey , destEditorKey , srcTabId , destTabId ) { return { type : EditorActions . swapTabs , payload : { srcEditorKey , destEditorKey , srcTabId , destTabId , } , } ; } export function toggleDraggingTab ( draggingTab ) { return { type : EditorActions . toggleDraggingTab , payload : { draggingTab , } , } ; } export function dropTabOnLeftOverlay ( tabId ) { return { type : EditorActions . dropTabOnLeftOverlay , payload : { tabId , } , } ; }	O O $any$ O O O O O O $any$ O $EditorActions.appendTab$ O O O $EditorActions.addDocPendingChange$ O O O $EditorActions.removeDocPendingChange$ O O O $EditorActions.close$ O O O $EditorActions.closeAll$ O O O $EditorActions.dropTabOnLeftOverlay$ O O O $EditorActions.setDirtyFlag$ O O O $EditorActions.open$ O O O $EditorActions.setActiveTab$ O O O $EditorActions.setActiveEditor$ O O O $EditorActions.splitTab$ O O O $EditorActions.swapTabs$ O O O $EditorActions.toggleDraggingTab$ O O O $EditorActions.updateDocument$ O O O O O O $any$ O $EditorActions.appendTab$ O $any$ O $EditorActions.appendTab$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.close$ O $any$ O $EditorActions.close$ O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.closeAll$ O $any$ O $EditorActions.closeAll$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $EditorActions.setDirtyFlag$ O $any$ O $EditorActions.setDirtyFlag$ O $complex$ O O $string$ O O O $boolean$ O O O O O O O O $any$ O $EditorActions.open$ O $any$ O $EditorActions.open$ O $Partial<Document<any>>$ O $any$ O $any$ O O O O O $any$ O $EditorActions.updateDocument$ O $any$ O $EditorActions.updateDocument$ O $Partial<Document<any>>$ O $any$ O $any$ O O O O O $any$ O $EditorActions.setActiveTab$ O $any$ O $EditorActions.setActiveTab$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveEditor$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.splitTab$ O $any$ O $EditorActions.splitTab$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.swapTabs$ O $any$ O $EditorActions.swapTabs$ O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $EditorActions.toggleDraggingTab$ O $any$ O $EditorActions.toggleDraggingTab$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.addDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.removeDocPendingChange$ O $any$ O $EditorActions.removeDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $complex$ O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $AppendTabAction$ O $string$ O $string$ O $string$ O O O O $EditorActions.appendTab$ O $any$ O $EditorActions.appendTab$ O $complex$ O O $string$ O $string$ O $string$ O O O O O O O O $AddDocPendingChangeAction$ O $string$ O O O O $EditorActions.addDocPendingChange$ O $any$ O $EditorActions.addDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $RemoveDocPendingChangeAction$ O $string$ O O O O $EditorActions.removeDocPendingChange$ O $any$ O $EditorActions.removeDocPendingChange$ O $complex$ O O $string$ O O O O O O O O $CloseEditorAction$ O $string$ O $string$ O O O O $EditorActions.close$ O $any$ O $EditorActions.close$ O $complex$ O O $string$ O $string$ O O O O O O O O $CloseAllEditorAction$ O O O O O $EditorActions.closeAll$ O $any$ O $EditorActions.closeAll$ O $complex$ O O $false$ O O O O O O O O O O $SetDirtyFlagAction$ O $string$ O $boolean$ O O O O $EditorActions.setDirtyFlag$ O $any$ O $EditorActions.setDirtyFlag$ O $complex$ O O $string$ O $boolean$ O O O O O O O O $OpenEditorAction$ O $Partial$ O $any$ O O O O O $EditorActions.open$ O $any$ O $EditorActions.open$ O $Partial<Document<any>>$ O $Partial<Document<any>>$ O O O O O O $UpdateDocumentAction$ O $string$ O $Partial$ O $any$ O O O O O $EditorActions.updateDocument$ O $any$ O $EditorActions.updateDocument$ O $complex$ O O $string$ O O $Partial<Document<any>>$ O O O O O O O $SetActiveTabAction$ O $string$ O O O O $EditorActions.setActiveTab$ O $any$ O $EditorActions.setActiveTab$ O $complex$ O O $string$ O O O O O O O O $SetActiveEditorAction$ O $string$ O O O O $EditorActions.setActiveEditor$ O $any$ O $EditorActions.setActiveEditor$ O $complex$ O O $string$ O O O O O O O O $SplitTabAction$ O $string$ O $string$ O $string$ O $string$ O O O O $EditorActions.splitTab$ O $any$ O $EditorActions.splitTab$ O $complex$ O O $string$ O $string$ O $string$ O $string$ O O O O O O O O $SwapTabsAction$ O $string$ O $string$ O $string$ O $string$ O O O O $EditorActions.swapTabs$ O $any$ O $EditorActions.swapTabs$ O $complex$ O O $string$ O $string$ O $string$ O $string$ O O O O O O O O $ToggleDraggingTabAction$ O $boolean$ O O O O $EditorActions.toggleDraggingTab$ O $any$ O $EditorActions.toggleDraggingTab$ O $complex$ O O $boolean$ O O O O O O O O $DropTabOnLeftOverlayAction$ O $string$ O O O O $EditorActions.dropTabOnLeftOverlay$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O $complex$ O O $string$ O O O O O O
import { LogEntry } from 's' ; import { Activity } from 's' ; import { ChatAction , ChatActions , PendingSpeechTokenRetrievalPayload , WebChatStorePayload , WebSpeechFactoryPayload , } from 's' ; import { EditorAction , EditorActions } from 's' ; import { Document , DocumentUI } from 's' ; export interface ChatState { changeKey ? : number ; chats ? : { [ chatId ] : ChatDocument } ; webSpeechFactories ? : { [ documentId ] : ( ) => any } ; webChatStores : { [ documentId ] : any } ; transcripts ? : string [ ] ; pendingSpeechTokenRetrieval : boolean ; } export interface ChatDocument < I = any > extends Document { endpointId : string ; endpointUrl : string ; highlightedObjects : Activity [ ] ; inspectorObjects : I [ ] ; log : ChatLog ; ui : DocumentUI ; } export interface ChatLog { entries : LogEntry [ ] ; } const DEFAULT_STATE = { changeKey : 0 , chats : { } , transcripts : [ ] , webSpeechFactories : { } , webChatStores : { } , pendingSpeechTokenRetrieval : false , } ; export function chat ( state = DEFAULT_STATE , action : ChatAction | EditorAction ) { switch ( action . type ) { case ChatActions . addTranscript : { const { payload } = action ; const transcriptsCopy = [ ... state . transcripts ] ; const transcripts = transcriptsCopy . filter ( xs => xs !== payload . filename ) ; transcripts . push ( payload . filename ) ; state = setTranscriptsState ( transcripts , state ) ; break ; } case ChatActions . clearTranscripts : { state = setTranscriptsState ( [ ] , state ) ; break ; } case ChatActions . removeTranscript : { const { payload } = action ; const transcriptsCopy = [ ... state . transcripts ] ; const transcripts = transcriptsCopy . filter ( xs => xs !== payload . filename ) ; state = setTranscriptsState ( transcripts , state ) ; break ; } case ChatActions . newChat : { const { payload } = action ; state = { ... state , changeKey : state . changeKey + 0 , chats : { ... state . chats , [ payload . documentId ] : { ... payload } , } , } ; break ; } case ChatActions . webSpeechFactoryUpdated : { const { documentId , factory } = action . payload as WebSpeechFactoryPayload ; const { webSpeechFactories } = state ; state = { ... state , webSpeechFactories : { ... webSpeechFactories , [ documentId ] : factory } , } ; } break ; case ChatActions . webChatStoreUpdated : { const { documentId , store } = action . payload as WebChatStorePayload ; const { webChatStores } = state ; state = { ... state , webChatStores : { ... webChatStores , [ documentId ] : store } , } ; } break ; case ChatActions . updatePendingSpeechTokenRetrieval : state = { ... state , pendingSpeechTokenRetrieval : ( action . payload as PendingSpeechTokenRetrievalPayload ) . pending , } ; break ; case ChatActions . closeDocument : { const { documentId } = action . payload ; if ( documentId in state . chats ) { const copy = { ... state } ; copy . changeKey += 0 ; delete copy . chats [ documentId ] ; state = { ... copy } ; } break ; } case ChatActions . newConversation : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , ... payload . options , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . appendLog : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , log : { ... document . log , entries : [ ... document . log . entries , payload . entry ] , } , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . clearLog : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , log : { entries : [ ] , } , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case ChatActions . setHighlightedObjects : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , highlightedObjects : payload . objs , } ; } state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; case ChatActions . setInspectorObjects : { const { payload } = action ; let document = state . chats [ payload . documentId ] ; if ( document ) { document = { ... document , inspectorObjects : payload . objs , } ; } state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; break ; } case ChatActions . updateChat : { const { payload } = action ; const { documentId = 's' , updatedValues = { } } = payload ; let document = state . chats [ documentId ] ; if ( document ) { document = { ... document , ... updatedValues , } ; state = { ... state , chats : { ... state . chats , [ payload . documentId ] : { ... document , } , } , } ; } break ; } case EditorActions . closeAll : { return DEFAULT_STATE ; } default : break ; } return state ; } function setTranscriptsState ( transcripts : string [ ] , state ) { const newState = { ... state } ; newState . transcripts = transcripts ; newState . changeKey = state . changeKey + 0 ; return newState ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $number$ O O O O $complex$ O O O O $string$ O O $any$ O O $complex$ O O O O $string$ O O O O O O O O $complex$ O O O $string$ O O O O O $string[]$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $any[]$ O $any$ O O O $I[]$ O $any$ O O O $ChatLog$ O $any$ O $DocumentUI$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O $ChatState$ O O $number$ O O O ${}$ O O O O $undefined[]$ O O O O ${}$ O O O O ${}$ O O O O $false$ O O O O O O O $ChatState$ O $ChatState$ O $ChatState$ O O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $ChatActions.addTranscript$ O O O O $any$ O O O O O $string[]$ O O O $ChatState$ O $string[]$ O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $any$ O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O $ChatState$ O $ChatState$ O $string[]$ O $ChatState$ O O O O O O $any$ O $ChatActions.clearTranscripts$ O O $ChatState$ O $ChatState$ O O O O $ChatState$ O O O O O O $any$ O $ChatActions.removeTranscript$ O O O O $any$ O O O O O $string[]$ O O O $ChatState$ O $string[]$ O O O $string[]$ O $string[]$ O $complex$ O $string$ O $string$ O $any$ O $any$ O O $ChatState$ O $ChatState$ O $string[]$ O $ChatState$ O O O O O O $any$ O $ChatActions.newChat$ O O O O $any$ O O O O $ChatState$ O O O $ChatState$ O $number$ O $ChatState$ O $number$ O O O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O $ChatActions.webSpeechFactoryUpdated$ O O O O $string$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O $ChatState$ O $ChatState$ O O O $ChatState$ O $complex$ O O O $complex$ O O $string$ O O $any$ O O O O O O O O $any$ O $ChatActions.webChatStoreUpdated$ O O O O $string$ O $any$ O O O O $any$ O $any$ O O O $complex$ O O $ChatState$ O $ChatState$ O O O $ChatState$ O $complex$ O O O $complex$ O O $string$ O O $any$ O O O O O O O O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O $ChatState$ O O O $ChatState$ O $boolean$ O O O O $any$ O $any$ O O $boolean$ O O O O O O $any$ O $ChatActions.closeDocument$ O O O O $any$ O O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O $complex$ O O O $ChatState$ O O $complex$ O $number$ O O O O $complex$ O $complex$ O $any$ O O $ChatState$ O O O $complex$ O O O O O O O $any$ O $ChatActions.newConversation$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O O $any$ O $any$ O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.appendLog$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $complex$ O O O $ChatDocument<any>$ O $ChatLog$ O $any[]$ O O O $ChatDocument<any>$ O $ChatLog$ O $any[]$ O $any$ O $any$ O O O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.clearLog$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $complex$ O O $undefined[]$ O O O O O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $ChatActions.setHighlightedObjects$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $any$ O $any$ O $any$ O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O $any$ O $ChatActions.setInspectorObjects$ O O O O $any$ O O O O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O $any$ O $any$ O $any$ O O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O $any$ O $ChatActions.updateChat$ O O O O $any$ O O O O O O $any$ O O O $any$ O O O O O $any$ O O $ChatDocument<any>$ O $ChatState$ O $complex$ O $any$ O O O O $ChatDocument<any>$ O O $ChatDocument<any>$ O O O $ChatDocument<any>$ O O $any$ O O O $ChatState$ O O O $ChatState$ O ${}$ O O O $ChatState$ O $complex$ O O $any$ O $any$ O O O O $ChatDocument<any>$ O O O O O O O O O O O O $any$ O $EditorActions.closeAll$ O O O $ChatState$ O O O O O O O O $ChatState$ O O O $ChatState$ O $string[]$ O O O O O $ChatState$ O O O $complex$ O O O $ChatState$ O O $complex$ O $string[]$ O $string[]$ O $complex$ O $number$ O $ChatState$ O $number$ O O O O $complex$ O O
import { ClientAwareSettings } from 's' ; import { Action } from 's' ; export const CLIENT_AWARE_SETTINGS_CHANGED = 's' ; export declare type ClientAwareSettingsActionsType = 's' ; export interface ClientAwareSettingsActions extends Action { type : ClientAwareSettingsActionsType ; payload : ClientAwareSettings ; } export function clientAwareSettingsChanged ( settings ) { return { type : CLIENT_AWARE_SETTINGS_CHANGED , payload : settings , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $ClientAwareSettingsActions$ O $ClientAwareSettings$ O O O O O O O O $any$ O $any$ O O O O
import { ClientAwareSettings } from 's' ; import { CLIENT_AWARE_SETTINGS_CHANGED , ClientAwareSettingsActions } from 's' ; export function clientAwareSettings ( state = { } as any , action ) { if ( action . type === CLIENT_AWARE_SETTINGS_CHANGED ) { return { ... state , ... action . payload } ; } return state ; }	O O $any$ O O O O O O O O $any$ O O O O O O $ClientAwareSettings$ O $ClientAwareSettings$ O O O O O O $ClientAwareSettingsActions$ O O O O $ClientAwareSettingsActions$ O O O O O O O O O $any$ O O $ClientAwareSettingsActions$ O $any$ O O O O $any$ O O
export enum DialogActions { setShowing = 's' , } export interface SetShowingDialogAction { type : DialogActions . setShowing ; payload : { showing : boolean ; } ; } export type DialogAction = SetShowingDialogAction ; export function setShowing ( showing = false ) { return { type : DialogActions . setShowing , payload : { showing , } , } ; }	O O $any$ O $DialogActions.setShowing$ O O O O O O $any$ O $DialogActions$ O $any$ O $DialogActions.setShowing$ O $complex$ O O $boolean$ O O O O O O O O $any$ O $any$ O O O $SetShowingDialogAction$ O $boolean$ O O O O O O $DialogActions.setShowing$ O $any$ O $DialogActions.setShowing$ O $complex$ O O $boolean$ O O O O O O
import { DialogAction , DialogActions } from 's' ; export interface DialogState { showing : boolean ; } const DEFAULT_STATE = { showing : false , } ; export function dialog ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case DialogActions . setShowing : { state = setShowing ( action . payload . showing , state ) ; break ; } default : break ; } return state ; } export function setShowing ( showing , _state ) { return { showing } ; }	O O $any$ O $any$ O O O O O O $any$ O $boolean$ O O O O O $DialogState$ O O $false$ O O O O O O O $DialogState$ O $DialogState$ O $DialogState$ O $DialogAction$ O O O O $SetShowingDialogAction$ O $DialogActions$ O O O $any$ O $DialogActions.setShowing$ O O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O $complex$ O $boolean$ O $DialogState$ O O O O O O O O O O O $DialogState$ O O O O $DialogState$ O $boolean$ O $DialogState$ O O O O $boolean$ O O O
import { Action } from 's' ; import { SortCriteria } from 's' ; export const CONNECTED_SERVICES_PANEL_ID = 's' ; export enum ExplorerActions { Show = 's' , Sort = 's' , } export interface ExplorerAction < T > extends Action { type : ExplorerActions ; payload : T ; } export interface ExplorerPayload { show ? : boolean ; sortSelectionByPanelId ? : { [ panelId ] : SortCriteria } ; } export function showExplorer ( show ) < ExplorerPayload > { return { type : ExplorerActions . Show , payload : { show } , } ; } export function sortExplorerContents ( panelId , sort ) < ExplorerPayload > { return { type : ExplorerActions . Sort , payload : { sortSelectionByPanelId : { [ panelId ] : sort } } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $ExplorerActions.Show$ O O O $ExplorerActions.Sort$ O O O O O O $any$ O $any$ O O $any$ O $ExplorerActions$ O $any$ O $T$ O $any$ O O O O $any$ O $boolean$ O O O O $complex$ O O O O $string$ O O $any$ O O O O O $ExplorerAction$ O $boolean$ O O $any$ O O O O $ExplorerActions.Show$ O $any$ O $ExplorerActions.Show$ O $complex$ O O $boolean$ O O O O O O O $ExplorerAction$ O $string$ O $SortCriteria$ O O $any$ O O O O $ExplorerActions.Sort$ O $any$ O $ExplorerActions.Sort$ O $complex$ O O $complex$ O O O $string$ O O $string$ O O O O O O
import { CONNECTED_SERVICES_PANEL_ID , ExplorerAction , ExplorerActions , ExplorerPayload , } from 's' ; export interface ExplorerState { showing : boolean ; sortSelectionByPanelId : { [ panelId ] : SortCriteria } ; } export declare type SortCriteria = string ; const DEFAULT_STATE = { showing : true , sortSelectionByPanelId : { [ CONNECTED_SERVICES_PANEL_ID ] : 's' } , } ; export function explorer ( state = DEFAULT_STATE , action < ExplorerPayload > ) { switch ( action . type ) { case ExplorerActions . Show : state = { ... state , showing : action . payload . show } ; break ; case ExplorerActions . Sort : { const sortSelectionByPanelId = { ... state . sortSelectionByPanelId , ... action . payload . sortSelectionByPanelId , } ; state = { ... state , sortSelectionByPanelId } ; break ; } default : break ; } return state ; }	O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $boolean$ O O O $complex$ O O O $string$ O O $any$ O O O O O O $any$ O O O O $ExplorerState$ O O $true$ O O O $complex$ O O O O O O O O O O O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction$ O $any$ O O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O O $any$ O $ExplorerActions.Show$ O $ExplorerState$ O O O $ExplorerState$ O $boolean$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O $boolean$ O O O O O $any$ O $ExplorerActions.Sort$ O O O $complex$ O O O $ExplorerState$ O $complex$ O O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O $complex$ O O O $ExplorerState$ O O O $ExplorerState$ O $complex$ O O O O O O O O O O O $ExplorerState$ O O
import { frameworkDefault , FrameworkSettings } from 's' ; import { FrameworkAction , FrameworkActionType } from 's' ; export function framework ( state = frameworkDefault , action < FrameworkSettings > ) { switch ( action . type ) { case FrameworkActionType . SET_FRAMEWORK : return { ... state , ... action . payload } ; default : return state ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $FrameworkSettings$ O $any$ O $FrameworkAction$ O $any$ O O O O O $FrameworkAction<any>$ O $FrameworkActionType$ O O O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O O O O $any$ O O $FrameworkAction<any>$ O $any$ O O O O O $any$ O O O
export enum NavBarActions { select = 's' , } export interface SelectNavBarAction { type : NavBarActions . select ; payload : { selection : string ; } ; } export type NavBarAction = SelectNavBarAction ; export function select ( selection ) { return { type : NavBarActions . select , payload : { selection , } , } ; }	O O $any$ O $NavBarActions.select$ O O O O O O $any$ O $NavBarActions$ O $any$ O $NavBarActions.select$ O $complex$ O O $string$ O O O O O O O O $any$ O $any$ O O O $SelectNavBarAction$ O $string$ O O O O $NavBarActions.select$ O $any$ O $NavBarActions.select$ O $complex$ O O $string$ O O O O O O
import { SharedConstants } from 's' ; import { NavBarAction , NavBarActions } from 's' ; export interface NavBarState { selection : string ; } const DEFAULT_STATE = { selection : SharedConstants . NavBarItems . NAVBAR_BOT_EXPLORER , } ; export function navBar ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case NavBarActions . select : { state = { ... state , selection : action . payload . selection , } ; break ; } default : break ; } return state ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O O O $NavBarState$ O O $any$ O $any$ O $any$ O $any$ O O O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $NavBarAction$ O O O O $SelectNavBarAction$ O $NavBarActions$ O O O $any$ O $NavBarActions.select$ O O $NavBarState$ O O O $NavBarState$ O $string$ O $SelectNavBarAction$ O $complex$ O $string$ O O O O O O O O O O O O $NavBarState$ O O
import { Notification } from 's' ; export enum NotificationActions { beginAdd = 's' , finishAdd = 's' , beginRemove = 's' , finishRemove = 's' , markAllAsRead = 's' , beginClear = 's' , finishClear = 's' , } export type NotificationAction = | BeginAddNotificationAction | FinishAddNotificationAction | BeginRemoveNotificationAction | FinishRemoveNotificationAction | MarkAllAsReadNotificationAction | BeginClearNotificationAction | FinishClearNotificationAction ; export interface BeginAddNotificationAction { type : NotificationActions . beginAdd ; payload : { notification : Notification ; read : boolean ; } ; } export interface FinishAddNotificationAction { type : NotificationActions . finishAdd ; payload : { notification : Notification ; } ; } export interface BeginRemoveNotificationAction { type : NotificationActions . beginRemove ; payload : { id : string ; } ; } export interface FinishRemoveNotificationAction { type : NotificationActions . finishRemove ; payload : { id : string ; } ; } export interface MarkAllAsReadNotificationAction { type : NotificationActions . markAllAsRead ; payload : { } ; } export interface BeginClearNotificationAction { type : NotificationActions . beginClear ; payload : { } ; } export interface FinishClearNotificationAction { type : NotificationActions . finishClear ; payload : { } ; } export function beginAdd ( notification , read = false ) { return { type : NotificationActions . beginAdd , payload : { notification , read , } , } ; } export function finishAdd ( notification ) { return { type : NotificationActions . finishAdd , payload : { notification , } , } ; } export function beginRemove ( id ) { return { type : NotificationActions . beginRemove , payload : { id , } , } ; } export function finishRemove ( id ) { return { type : NotificationActions . finishRemove , payload : { id , } , } ; } export function markAllAsRead ( ) { return { type : NotificationActions . markAllAsRead , payload : { } , } ; } export function beginClear ( ) { return { type : NotificationActions . beginClear , payload : { } , } ; } export function finishClear ( ) { return { type : NotificationActions . finishClear , payload : { } , } ; }	O O $any$ O O O O O O $any$ O $NotificationActions.beginAdd$ O O O $NotificationActions.finishAdd$ O O O $NotificationActions.beginRemove$ O O O $NotificationActions.finishRemove$ O O O $NotificationActions.markAllAsRead$ O O O $NotificationActions.beginClear$ O O O $NotificationActions.finishClear$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $NotificationActions.beginAdd$ O $any$ O $NotificationActions.beginAdd$ O $complex$ O O $any$ O $any$ O $boolean$ O O O O O O O O $any$ O $NotificationActions.finishAdd$ O $any$ O $NotificationActions.finishAdd$ O $complex$ O O $any$ O $any$ O O O O O O $any$ O $NotificationActions.beginRemove$ O $any$ O $NotificationActions.beginRemove$ O $complex$ O O $string$ O O O O O O O O $any$ O $NotificationActions.finishRemove$ O $any$ O $NotificationActions.finishRemove$ O $complex$ O O $string$ O O O O O O O O $any$ O $NotificationActions.markAllAsRead$ O $any$ O $NotificationActions.markAllAsRead$ O ${}$ O O O O O O O $any$ O $NotificationActions.beginClear$ O $any$ O $NotificationActions.beginClear$ O ${}$ O O O O O O O $any$ O $NotificationActions.finishClear$ O $any$ O $NotificationActions.finishClear$ O ${}$ O O O O O O O $BeginAddNotificationAction$ O $Notification$ O $boolean$ O O O O O O $NotificationActions.beginAdd$ O $any$ O $NotificationActions.beginAdd$ O $complex$ O O $any$ O $boolean$ O O O O O O O O $FinishAddNotificationAction$ O $Notification$ O O O O $NotificationActions.finishAdd$ O $any$ O $NotificationActions.finishAdd$ O $complex$ O O $any$ O O O O O O O O $BeginRemoveNotificationAction$ O $string$ O O O O $NotificationActions.beginRemove$ O $any$ O $NotificationActions.beginRemove$ O $complex$ O O $string$ O O O O O O O O $FinishRemoveNotificationAction$ O $string$ O O O O $NotificationActions.finishRemove$ O $any$ O $NotificationActions.finishRemove$ O $complex$ O O $string$ O O O O O O O O $MarkAllAsReadNotificationAction$ O O O O O $NotificationActions.markAllAsRead$ O $any$ O $NotificationActions.markAllAsRead$ O ${}$ O O O O O O O O O $BeginClearNotificationAction$ O O O O O $NotificationActions.beginClear$ O $any$ O $NotificationActions.beginClear$ O ${}$ O O O O O O O O O $FinishClearNotificationAction$ O O O O O $NotificationActions.finishClear$ O $any$ O $NotificationActions.finishClear$ O ${}$ O O O O O O O
import { NotificationAction , NotificationActions } from 's' ; export interface NotificationState { allIds : string [ ] ; } const DEFAULT_STATE = { allIds : [ ] , } ; export function notification ( state = DEFAULT_STATE , action ) { switch ( action . type ) { case NotificationActions . finishAdd : { const { id : idToAdd } = action . payload . notification ; let allIds ; if ( ! state . allIds . some ( id => id === idToAdd ) ) { allIds = [ ... state . allIds , idToAdd ] ; } else { allIds = state . allIds ; } state = { allIds , } ; break ; } case NotificationActions . finishRemove : { const { id : idToRemove } = action . payload ; const allIds = state . allIds . filter ( id => id !== idToRemove ) ; state = { allIds , } ; break ; } case NotificationActions . finishClear : { state = { allIds : [ ] , } ; break ; } default : break ; } return state ; } export default notification ;	O O $any$ O $any$ O O O O O O $any$ O $string[]$ O O O O O O O $NotificationState$ O O $undefined[]$ O O O O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $NotificationAction$ O O O O $NotificationAction$ O $NotificationActions$ O O O $any$ O $NotificationActions.finishAdd$ O O O O $any$ O $any$ O O $FinishAddNotificationAction$ O $complex$ O $any$ O O $any$ O O O O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O O O $any$ O O O $NotificationState$ O $string[]$ O $any$ O O O O O $any$ O $NotificationState$ O $string[]$ O O $NotificationState$ O O $any$ O O O O O O O $any$ O $NotificationActions.finishRemove$ O O O O $string$ O $string$ O O $FinishRemoveNotificationAction$ O $complex$ O O $string[]$ O $NotificationState$ O $string[]$ O $complex$ O $string$ O $string$ O $string$ O O $NotificationState$ O O $string[]$ O O O O O O O $any$ O $NotificationActions.finishClear$ O O $NotificationState$ O O $undefined[]$ O O O O O O O O O O O O O O O $NotificationState$ O O O O $NotificationState$ O
import { Action } from 's' ; export enum PresentationActions { disable = 's' , enable = 's' , } export interface PresentationAction extends Action { type : PresentationActions ; } export function enable ( ) { return { type : PresentationActions . enable , } ; } export function disable ( ) { return { type : PresentationActions . disable , } ; }	O O $any$ O O O O O O $any$ O $PresentationActions.disable$ O O O $PresentationActions.enable$ O O O O O O $any$ O $any$ O $PresentationActions$ O $any$ O O O O $PresentationAction$ O O O O O $PresentationActions.enable$ O $any$ O $PresentationActions.enable$ O O O O O O $PresentationAction$ O O O O O $PresentationActions.disable$ O $any$ O $PresentationActions.disable$ O O O O
import { PresentationAction , PresentationActions } from 's' ; export interface PresentationState { enabled : boolean ; } const DEFAULT_STATE = { enabled : false , } ; export const presentation = ( state = DEFAULT_STATE , action ) : PresentationState => { switch ( action . type ) { case PresentationActions . disable : state = setEnabled ( false , state ) ; break ; case PresentationActions . enable : state = setEnabled ( true , state ) ; break ; default : break ; } return state ; } ; function setEnabled ( enabled , state ) { const newState = { ... state } ; newState . enabled = enabled ; return newState ; }	O O $any$ O $any$ O O O O O O $any$ O $boolean$ O O O O O $PresentationState$ O O $false$ O O O O O O O $PresentationState$ O O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O O O O $PresentationAction$ O $PresentationActions$ O O O $any$ O $PresentationActions.disable$ O $PresentationState$ O $PresentationState$ O O O $PresentationState$ O O O O O $any$ O $PresentationActions.enable$ O $PresentationState$ O $PresentationState$ O O O $PresentationState$ O O O O O O O O O O $PresentationState$ O O O O $PresentationState$ O $boolean$ O $PresentationState$ O O O $complex$ O O O $PresentationState$ O O $complex$ O $boolean$ O $boolean$ O O $complex$ O O
import { Action } from 's' ; export const UPDATE_PROGRESS_INDICATOR = 's' ; export const CANCEL_CURRENT_PROCESS = 's' ; export interface ProgressIndicatorAction < T > extends Action { payload : T ; } export interface ProgressIndicatorPayload { label : string ; progress : number ; } export function updateProgressIndicator ( { label , progress , } ) < ProgressIndicatorPayload > { return { type : UPDATE_PROGRESS_INDICATOR , payload : { label , progress } , } ; } export function cancelCurrentProcess ( ) < void > { return { type : CANCEL_CURRENT_PROCESS , payload : void 0 , } ; }	O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O $number$ O O O O O O $ProgressIndicatorAction$ O O $string$ O $number$ O $ProgressIndicatorPayload$ O O $any$ O O O O $string$ O O O $complex$ O O $string$ O $number$ O O O O O O O $ProgressIndicatorAction$ O O O O O O O O $string$ O O O $undefined$ O O O O O O O
import { CANCEL_CURRENT_PROCESS , ProgressIndicatorAction , ProgressIndicatorPayload , UPDATE_PROGRESS_INDICATOR , } from 's' ; export interface ProgressIndicatorState { progress : number ; label : string ; canceled : boolean ; } export const initialState = { progress : 0 , label : 's' , canceled : false , } ; export function progressIndicator ( state = initialState , action < ProgressIndicatorPayload > ) { switch ( action . type ) { case UPDATE_PROGRESS_INDICATOR : { const { label , progress } = action . payload ; return { ... state , label , progress } ; } case CANCEL_CURRENT_PROCESS : return { ... state , canceled : true } ; default : return state ; } }	O O O O $any$ O $any$ O O O O O O O O O $any$ O $number$ O O O $string$ O O O $boolean$ O O O O O O $ProgressIndicatorState$ O O $number$ O O O $string$ O O O $false$ O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $ProgressIndicatorAction$ O $any$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O O O O O O O $string$ O $number$ O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorPayload$ O O O O $ProgressIndicatorState$ O $string$ O $number$ O O O O O O O O O $ProgressIndicatorState$ O $true$ O O O O O O O $ProgressIndicatorState$ O O O
import { ProtocolAction , ProtocolOpenUrlsPayload , SET_OPEN_URLS } from 's' ; export interface ProtocolState { openUrls ? : string [ ] ; } const DEFAULT_STATE = { openUrls : [ ] , } ; export function protocol ( state = DEFAULT_STATE , action < ProtocolOpenUrlsPayload > ) { switch ( action . type ) { case SET_OPEN_URLS : { const { openUrls } = state ; return { openUrls : [ ... openUrls , action . payload . openUrl ] } ; } default : return state ; } }	O O $any$ O $any$ O O O O O O O O $any$ O $string[]$ O O O O O O O O $ProtocolState$ O O $undefined[]$ O O O O O O O O $ProtocolState$ O $ProtocolState$ O $ProtocolState$ O $ProtocolAction$ O $any$ O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O O O O O $string[]$ O O $ProtocolState$ O O O $string[]$ O O O $string[]$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolOpenUrlsPayload$ O $string$ O O O O O O O $ProtocolState$ O O O
import { IFileService } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; export const TRANSCRIPTS_UPDATED = 's' ; export const TRANSCRIPTS_DIRECTORY_UPDATED = 's' ; export const CHAT_FILES_UPDATED = 's' ; export const CHATS_DIRECTORY_UPDATED = 's' ; export const OPEN_CONTEXT_MENU_FOR_RESOURCE = 's' ; export const EDIT_RESOURCE = 's' ; export const RENAME_RESOURCE = 's' ; export const OPEN_RESOURCE = 's' ; export const OPEN_RESOURCE_SETTINGS = 's' ; export interface ResourcesAction < T > extends Action { payload : T ; } export function transcriptsUpdated ( payload : IFileService [ ] ) < IFileService [ ] > { return { type : TRANSCRIPTS_UPDATED , payload , } ; } export function transcriptDirectoryUpdated ( payload ) < string > { return { type : TRANSCRIPTS_DIRECTORY_UPDATED , payload , } ; } export function chatsDirectoryUpdated ( payload ) < string > { return { type : CHATS_DIRECTORY_UPDATED , payload , } ; } export function chatFilesUpdated ( payload : IFileService [ ] ) < IFileService [ ] > { return { type : CHAT_FILES_UPDATED , payload , } ; } export function openContextMenuForResource ( payload ) < IFileService > { return { type : OPEN_CONTEXT_MENU_FOR_RESOURCE , payload , } ; } export function editResource ( payload ) < IFileService > { return { type : EDIT_RESOURCE , payload , } ; } export function renameResource ( payload ) < IFileService > { return { type : RENAME_RESOURCE , payload , } ; } export function openResource ( payload ) < IFileService > { return { type : OPEN_RESOURCE , payload , } ; } declare interface ResourceSettingsPayload { dialog : ComponentClass < any > ; } export function openResourcesSettings ( payload ) < ResourceSettingsPayload > { return { type : OPEN_RESOURCE_SETTINGS , payload , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $ResourcesAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O $string$ O O O $any[]$ O O O O O O $ResourcesAction$ O $string$ O O O O O O O $string$ O O O $string$ O O O O O O $ResourcesAction$ O $string$ O O O O O O O $string$ O O O $string$ O O O O O O $ResourcesAction$ O $any[]$ O $any$ O O O O $any$ O O O O O O $string$ O O O $any[]$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $ResourcesAction$ O $IFileService$ O O $any$ O O O O $string$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $ResourcesAction$ O $ResourceSettingsPayload$ O O $any$ O O O O $string$ O O O $ResourceSettingsPayload$ O O O O
import { IFileService } from 's' ; import { CHAT_FILES_UPDATED , CHATS_DIRECTORY_UPDATED , EDIT_RESOURCE , ResourcesAction , TRANSCRIPTS_DIRECTORY_UPDATED , TRANSCRIPTS_UPDATED , } from 's' ; export interface ResourcesState { transcripts : IFileService [ ] ; transcriptsPath : string ; chats : IFileService [ ] ; chatsPath : string ; resourceToRename : IFileService ; } const initialState = { transcripts : [ ] , transcriptsPath : 's' , chats : [ ] , chatsPath : 's' , resourceToRename : null , } ; declare type ResourceActionType = ResourcesAction < IFileService | IFileService [ ] | string > ; export function resources ( state = initialState , action ) { switch ( action . type ) { case TRANSCRIPTS_UPDATED : return { ... state , transcripts : action . payload as IFileService [ ] } ; case TRANSCRIPTS_DIRECTORY_UPDATED : return { ... state , transcriptsPath : action . payload as string } ; case CHAT_FILES_UPDATED : return { ... state , chats : action . payload as IFileService [ ] } ; case CHATS_DIRECTORY_UPDATED : return { ... state , chatsPath : action . payload as string } ; case EDIT_RESOURCE : return { ... state , resourceToRename : action . payload as IFileService } ; default : return state ; } }	O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any[]$ O $any$ O O O $string$ O O O $any[]$ O $any$ O O O $string$ O O O $any$ O $any$ O O O $ResourcesState$ O O $undefined[]$ O O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $ResourcesState$ O $ResourcesState$ O $ResourcesState$ O $ResourceActionType$ O O O O $ResourcesAction<any>$ O $any$ O O O O O O O O $ResourcesState$ O $any[]$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O O O O O O $ResourcesState$ O $string$ O $ResourcesAction<any>$ O $any$ O O O O O O O O O O $ResourcesState$ O $any[]$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O O O O O O $ResourcesState$ O $string$ O $ResourcesAction<any>$ O $any$ O O O O O O O O O O $ResourcesState$ O $any$ O $ResourcesAction<any>$ O $any$ O $any$ O O O O O $ResourcesState$ O O O
import { ADD_SAVED_BOT_URL , SavedBotUrlsAction , SavedBotUrlsActionPayload } from 's' ; interface BotUrl { url : string ; lastAccessed : string ; } export function savedBotUrls ( state : BotUrl [ ] = [ ] , action < SavedBotUrlsActionPayload > ) : BotUrl [ ] { switch ( action . type ) { case ADD_SAVED_BOT_URL : { const foundAtIndex = state . findIndex ( element => element . url === action . payload ) ; if ( foundAtIndex === - 0 ) { state . push ( { url : action . payload , lastAccessed : new Date ( ) . toUTCString ( ) } ) ; } else { state [ foundAtIndex ] . lastAccessed = new Date ( ) . toUTCString ( ) ; } if ( state . length > 0 ) { state . sort ( ( prev , curr ) => { return new Date ( curr . lastAccessed ) > new Date ( prev . lastAccessed ) ? 0 : - 0 ; } ) ; } break ; } default : break ; } return state ; }	O O O O $any$ O $any$ O O O O O $any$ O $string$ O O O $string$ O O O O O O $BotUrl[]$ O $BotUrl[]$ O $any$ O O O O O O $SavedBotUrlsAction$ O $any$ O O O $any$ O O O O O $SavedBotUrlsAction<string>$ O O O O O O O O O $number$ O $BotUrl[]$ O $number$ O $BotUrl$ O $BotUrl$ O $string$ O $SavedBotUrlsAction<string>$ O $string$ O O O O $number$ O O O O O $BotUrl[]$ O $number$ O O $string$ O $SavedBotUrlsAction<string>$ O $string$ O $string$ O O $DateConstructor$ O O O $string$ O O O O O O O O $BotUrl[]$ O $number$ O O $string$ O O $DateConstructor$ O O O $string$ O O O O O O $BotUrl[]$ O $number$ O O O O $BotUrl[]$ O $BotUrl[]$ O O $BotUrl$ O $BotUrl$ O O O O O $DateConstructor$ O $BotUrl$ O $string$ O O O $DateConstructor$ O $BotUrl$ O $string$ O O O O O O O O O O O O O O O O O O O O $BotUrl[]$ O O
export const SWITCH_THEME = 's' ; export declare type ThemeType = 's' ; export interface ThemeAction < T > { type : ThemeType ; payload : T ; } export interface SwitchThemePayload { themeName : string ; themeComponents : string [ ] ; } export function switchTheme ( themeName , themeComponents : string [ ] ) < SwitchThemePayload > { return { type : SWITCH_THEME , payload : { themeName , themeComponents } , } ; }	O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $T$ O $any$ O O O O $any$ O $string$ O O O $string[]$ O O O O O O O O $ThemeAction$ O $string$ O $string[]$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O $string[]$ O O O O O
import { SWITCH_THEME , SwitchThemePayload , ThemeAction } from 's' ; export interface ThemeState { themeName : string ; themeComponents : string [ ] ; } const initialState = { themeName : null , themeComponents : [ ] , } ; export function theme ( state = initialState , action < SwitchThemePayload > ) { switch ( action . type ) { case SWITCH_THEME : return { ... state , ... action . payload } ; default : return state ; } }	O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O $string[]$ O O O O O O O $ThemeState$ O O $null$ O O O $undefined[]$ O O O O O O O O $ThemeState$ O $ThemeState$ O $ThemeState$ O $ThemeAction$ O $any$ O O O O O $ThemeAction<SwitchThemePayload>$ O O O O O O O O O O $ThemeState$ O O $ThemeAction<SwitchThemePayload>$ O $SwitchThemePayload$ O O O O O $ThemeState$ O O O
import { UpdateStatus } from 's' ; export const SET_UPDATE_STATUS = 's' ; export type UpdateActionType = 's' ; export interface UpdateAction < P > { type : UpdateActionType ; payload : P ; } export type UpdateActionPayload = UpdateStatus ; export function setUpdateStatus ( status ) < UpdateStatus > { return { type : SET_UPDATE_STATUS , payload : status , } ; }	O O $any$ O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $P$ O $any$ O O O O $any$ O $any$ O O O $UpdateAction$ O $UpdateStatus$ O O $any$ O O O O O O O O $any$ O $any$ O O O O
import { UpdateStatus } from 's' ; import { UpdateAction , UpdateActionPayload , SET_UPDATE_STATUS } from 's' ; const DEFAULT_STATE = { status : UpdateStatus . Idle , } ; export interface UpdateState { status : UpdateStatus ; } export function update ( state = DEFAULT_STATE , action < UpdateActionPayload > ) { switch ( action . type ) { case SET_UPDATE_STATUS : return { ... state , status : action . payload } ; default : return state ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $UpdateState$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $UpdateState$ O $UpdateState$ O $UpdateState$ O $UpdateAction$ O $any$ O O O O O $UpdateAction<any>$ O O O O O O O O O O $UpdateState$ O $any$ O $UpdateAction<any>$ O $any$ O O O O O $UpdateState$ O O O
import { UserSettings } from 's' ; import { ADD_USERS , SET_CURRENT_USER , UserAction , UserPayload } from 's' ; export function users ( state = { } , action < UserPayload > ) { switch ( action . type ) { case SET_CURRENT_USER : { const usersById = { ... state . usersById } ; const { user } = action . payload ; usersById [ user . id ] = user ; return { currentUserId : user . id , usersById } ; } case ADD_USERS : { const newUsersById = { ... state . usersById } ; for ( const i in action . payload . users ) { const user = action . payload . users [ i ] ; if ( newUsersById . hasOwnProperty ( user . id ) ) { continue ; } newUsersById [ user . id ] = user ; } return { ... state , usersById : newUsersById } ; } default : return state ; } }	O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $UserSettings$ O O O O $UserAction$ O $any$ O O O O O $UserAction<UserPayload>$ O $UserActionType$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $UserAction<UserPayload>$ O $UserPayload$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $string$ O $UserAction<UserPayload>$ O $UserPayload$ O $any[]$ O O O $any$ O $UserAction<UserPayload>$ O $UserPayload$ O $any[]$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O
import { windowStateDefault , WindowStateSettings } from 's' ; import { REMEMBER_BOUNDS , REMEMBER_THEME , REMEMBER_ZOOM_LEVEL , SET_AVAILABLE_THEMES , RememberBoundsPayload , RememberThemePayload , RememberZoomLevelPayload , WindowStateAction , WindowStatePayload , SetAvailableThemesPayload , } from 's' ; export function windowState ( state = windowStateDefault , action < WindowStatePayload > ) { switch ( action . type ) { case REMEMBER_BOUNDS : { const bounds = action . payload as RememberBoundsPayload ; return { ... state , displayId : bounds . displayId , top : bounds . top , left : bounds . left , width : bounds . width , height : bounds . height , } ; } case REMEMBER_ZOOM_LEVEL : { const { zoomLevel } = action . payload as RememberZoomLevelPayload ; return { ... state , zoomLevel } ; } case REMEMBER_THEME : { const { theme } = action . payload as RememberThemePayload ; return { ... state , theme } ; } case SET_AVAILABLE_THEMES : { const { availableThemes } = action . payload as SetAvailableThemesPayload ; return { ... state , availableThemes } ; } default : return state ; } }	O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $WindowStateSettings$ O $any$ O $WindowStateAction$ O $any$ O O O O O $WindowStateAction<WindowStatePayload>$ O $WindowStateActionType$ O O O O O O O $RememberBoundsPayload$ O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O $number$ O $RememberBoundsPayload$ O $number$ O O O O O O O O O O $number$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $number$ O O O O O O O O O $string$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $string$ O O O O O O O O O $complex$ O O $WindowStateAction<WindowStatePayload>$ O $WindowStatePayload$ O $any$ O O O O $any$ O $complex$ O O O O O O $any$ O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action , applyMiddleware , createStore , combineReducers , Store } from 's' ; import { ipcMain } from 's' ; import { settingsDefault , Settings , SettingsImpl , ClientAwareSettings , FrameworkSettings , } from 's' ; import sagaMiddlewareFactory from 's' ; import { loadSettings , getThemes } from 's' ; import { settingsSagas } from 's' ; import { forwardToRenderer } from 's' ; import { AzureAuthState , azureAuth , azureAuthSettings , bot , BotState , chat , clientAwareSettings , dialog , editor , explorer , framework , navBar , notification , presentation , progressIndicator , protocol , ProtocolState , resources , savedBotUrls , theme , update , users , windowState , ChatState , DialogState , EditorState , ExplorerState , NavBarState , NotificationState , PresentationState , ProgressIndicatorState , ResourcesState , ThemeState , UpdateState , } from 's' ; export interface RootState { azureAuth ? : AzureAuthState ; bot ? : BotState ; chat ? : ChatState ; clientAwareSettings ? : ClientAwareSettings ; dialog ? : DialogState ; editor ? : EditorState ; explorer ? : ExplorerState ; framework ? : FrameworkSettings ; navBar ? : NavBarState ; notification ? : NotificationState ; presentation ? : PresentationState ; progressIndicator ? : ProgressIndicatorState ; protocol ? : ProtocolState ; resources ? : ResourcesState ; settings ? : Settings ; theme ? : ThemeState ; update ? : UpdateState ; } export const DEFAULT_STATE = { settings : { } , } ; function initStore ( ) < RootState > { const loadedSettings = loadSettings ( 's' , settingsDefault ) ; loadedSettings . windowState . availableThemes = getThemes ( ) ; DEFAULT_STATE . settings = loadedSettings ; const settingsReducer = combineReducers < Settings > ( { azure : azureAuthSettings , framework , savedBotUrls , windowState , users , } ) ; const sagaMiddleware = sagaMiddlewareFactory ( ) ; const _store < RootState > = createStore ( combineReducers ( { azureAuth , bot , chat , clientAwareSettings , dialog , editor , explorer , framework , navBar , notification , presentation , progressIndicator , protocol , resources , settings : settingsReducer , theme , update , } ) , DEFAULT_STATE , applyMiddleware ( forwardToRenderer , sagaMiddleware ) ) ; sagaMiddleware . run ( settingsSagas ) ; ipcMain . on ( 's' , ( ev , action ) => { action = { ... action , meta : { doNotForward : true } } ; _store . dispatch ( action ) ; ev . returnValue = true ; } ) ; return _store ; } export const store = initStore ( ) ; export const dispatch = < T extends Action > ( action : T ) => store . dispatch < T > ( action ) ; export const getSettings = ( ) => { return new SettingsImpl ( store . getState ( ) . settings ) ; } ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $complex$ O O O O O O $IterableIterator<any>$ O O O O O O $any$ O O O O O O $any$ O $AzureAuthState$ O $any$ O $BotState$ O $any$ O O O $any$ O $DialogState$ O O O $ExplorerState$ O $any$ O $NavBarState$ O $NotificationState$ O $PresentationState$ O $ProgressIndicatorState$ O $ProtocolState$ O $any$ O $ResourcesState$ O $BotUrl[]$ O $ThemeState$ O $UpdateState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $AzureAuthState$ O O $any$ O $BotState$ O O $any$ O $ChatState$ O O $any$ O $any$ O O $any$ O $DialogState$ O O $any$ O $EditorState<any>$ O O $any$ O $ExplorerState$ O O $any$ O $any$ O O $any$ O $NavBarState$ O O $any$ O $NotificationState$ O O $any$ O $PresentationState$ O O $any$ O $ProgressIndicatorState$ O O $any$ O $ProtocolState$ O O $any$ O $ResourcesState$ O O $any$ O $any$ O O $any$ O $ThemeState$ O O $any$ O $UpdateState$ O O $any$ O O O O $complex$ O O ${}$ O O O O O O O $Store$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O $complex$ O ${}$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Store$ O $any$ O O $any$ O $any$ O O $AzureAuthState$ O $BotState$ O O O $any$ O $DialogState$ O O O $ExplorerState$ O $any$ O $NavBarState$ O $NotificationState$ O $PresentationState$ O $ProgressIndicatorState$ O $ProtocolState$ O $ResourcesState$ O $any$ O $any$ O $ThemeState$ O $UpdateState$ O O O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $T$ O $any$ O O $any$ O $any$ O $any$ O O $T$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O
import * as AppInsights from 's' ; import { SettingsImpl } from 's' ; import { getSettings } from 's' ; const INSTRUMENTATION_KEY = 's' ; export class TelemetryService { private static _client : AppInsights . TelemetryClient ; private static _hasStarted : boolean = false ; public static trackEvent ( name , properties ? : { [ key ] : any } ) { if ( ! this . enabled || ! name || ( global as any ) . __JEST_ENV__ ) { return ; } if ( ! this . _client ) { this . startup ( ) ; } try { this . _client . trackEvent ( { name , properties } ) ; } catch ( e ) { } } private static get enabled ( ) : boolean { const settings = getSettings ( ) || ( { } as SettingsImpl ) ; const { framework = { } } = settings ; return framework . collectUsageData ; } private static startup ( ) { if ( ! this . _hasStarted ) { AppInsights . setup ( INSTRUMENTATION_KEY ) . setAutoCollectConsole ( false ) . setAutoCollectDependencies ( false ) . setAutoCollectExceptions ( false ) . setAutoCollectPerformance ( false ) . setAutoCollectRequests ( false ) . setAutoDependencyCorrelation ( false ) ; AppInsights . defaultClient . context . tags [ AppInsights . defaultClient . context . keys . cloudRoleInstance ] = 's' ; AppInsights . start ( ) ; this . _client = AppInsights . defaultClient ; this . _hasStarted = true ; } } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O O $void$ O $string$ O $complex$ O O O O $string$ O O O O O O O O O O O $boolean$ O O $string$ O O $any$ O O O O $any$ O O O O O O O O O O $any$ O O O O $void$ O O O O O O O O $any$ O $any$ O O $string$ O $complex$ O O O O O O $any$ O O O O O O O $boolean$ O O O O O O $SettingsImpl$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O O $void$ O O O O O O O O $boolean$ O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { ProgressInfo } from 's' ; import { autoUpdater as electronUpdater , UpdateInfo } from 's' ; import { SharedConstants } from 's' ; import { app } from 's' ; import { newNotification , UpdateStatus } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { TelemetryService } from 's' ; import { getSettings , store } from 's' ; import { AppMenuBuilder } from 's' ; import { sendNotificationToClient } from 's' ; import { setFrameworkSettings } from 's' ; import { setUpdateStatus } from 's' ; class EmulatorUpdater extends EventEmitter { @ CommandServiceInstance ( ) private commandService : CommandServiceImpl ; private _userInitiated : boolean ; private _autoDownload : boolean ; private _updaterStatus : UpdateStatus = UpdateStatus . Idle ; private _allowPrerelease : boolean ; private _updateDownloaded : boolean ; private _downloadProgress : number ; private _installAfterDownload : boolean ; public get userInitiated ( ) : boolean { return this . _userInitiated ; } public get status ( ) : UpdateStatus { return this . _status ; } public get downloadProgress ( ) : number { return this . _downloadProgress ; } public get updateDownloaded ( ) : boolean { return this . _updateDownloaded ; } public get autoDownload ( ) : boolean { return this . _autoDownload ; } public set autoDownload ( value ) { electronUpdater . autoDownload = value ; this . _autoDownload = value ; } public get allowPrerelease ( ) : boolean { return this . _allowPrerelease ; } public set allowPrerelease ( value ) { electronUpdater . allowPrerelease = value ; this . _allowPrerelease = value ; } public get repo ( ) : string { if ( this . allowPrerelease ) { return 's' ; } return 's' ; } public async startup ( ) { const settings = getSettings ( ) . framework ; this . allowPrerelease = ! ! settings . usePrereleases ; this . autoDownload = ! ! settings . autoUpdate ; electronUpdater . allowDowngrade = true ; electronUpdater . autoInstallOnAppQuit = true ; electronUpdater . logger = null ; electronUpdater . on ( 's' , this . onUpdateAvailable ) ; electronUpdater . on ( 's' , this . onUpdateNotAvailable ) ; electronUpdater . on ( 's' , this . onError ) ; electronUpdater . on ( 's' , this . onDownloadProgress ) ; electronUpdater . on ( 's' , this . onUpdateDownloaded ) ; await this . checkForUpdates ( false ) ; } public async checkForUpdates ( userInitiated ) < void > { const settings = getSettings ( ) . framework ; this . allowPrerelease = ! ! settings . usePrereleases ; this . autoDownload = ! ! settings . autoUpdate ; this . _userInitiated = userInitiated ; electronUpdater . setFeedURL ( { repo : this . repo , owner : 's' , provider : 's' , } ) ; try { await electronUpdater . checkForUpdates ( ) ; TelemetryService . trackEvent ( 's' , { auto : ! userInitiated , prerelease : this . allowPrerelease , } ) ; } catch ( e ) { throw new Error ( `template` ) ; } } public async downloadUpdate ( installAfterDownload ) < void > { this . _installAfterDownload = installAfterDownload ; try { await electronUpdater . downloadUpdate ( ) ; } catch ( e ) { throw new Error ( `template` ) ; } } public quitAndInstall ( ) { try { electronUpdater . quitAndInstall ( false , true ) ; } catch ( e ) { throw new Error ( `template` ) ; } } private onUpdateAvailable = async ( updateInfo ) => { if ( ! this . autoDownload ) { this . _status = UpdateStatus . Idle ; try { AppMenuBuilder . refreshAppUpdateMenu ( ) ; const { ShowUpdateAvailableDialog , ShowProgressIndicator , UpdateProgressIndicator , } = SharedConstants . Commands . UI ; const result = await this . commandService . remoteCall < number > ( ShowUpdateAvailableDialog , updateInfo . version ) ; switch ( result ) { case 0 : { await this . commandService . remoteCall ( UpdateProgressIndicator , { label : 's' , progress : 0 , } ) ; this . commandService . remoteCall ( ShowProgressIndicator ) ; await this . downloadUpdate ( false ) ; return ; } case 0 : { await this . commandService . remoteCall ( UpdateProgressIndicator , { label : 's' , progress : 0 , } ) ; this . commandService . remoteCall ( ShowProgressIndicator ) ; await this . downloadUpdate ( true ) ; return ; } case 0 : { let settings = getSettings ( ) . framework ; settings = { ... settings , autoUpdate : true , } ; store . dispatch ( setFrameworkSettings ( settings ) ) ; await this . commandService . remoteCall ( UpdateProgressIndicator , { label : 's' , progress : 0 , } ) ; this . commandService . remoteCall ( ShowProgressIndicator ) ; await this . downloadUpdate ( true ) ; return ; } default : { return ; } } } catch ( e ) { console . error ( `template` ) ; } } else { this . downloadUpdate ( false ) . catch ( e => this . emit ( 's' , e , e . toString ( ) ) ) ; } } ; private onUpdateNotAvailable = async ( ) => { this . _status = UpdateStatus . Idle ; try { AppMenuBuilder . refreshAppUpdateMenu ( ) ; const { userInitiated , updateDownloaded } = this ; if ( userInitiated && ! updateDownloaded ) { const { ShowUpdateUnavailableDialog } = SharedConstants . Commands . UI ; await this . commandService . remoteCall ( ShowUpdateUnavailableDialog ) ; } } catch ( e ) { console . error ( `template` ) ; } } ; private onError = async ( err , message = 's' ) => { this . _status = UpdateStatus . Idle ; AppMenuBuilder . refreshAppUpdateMenu ( ) ; if ( message . includes ( 's' ) ) { this . emit ( 's' ) ; return ; } if ( this . userInitiated ) { await this . commandService . call ( SharedConstants . Commands . Electron . ShowMessageBox , true , { title : app . getName ( ) , message : `template` , } ) ; } } ; private onDownloadProgress = async ( progress ) => { this . _status = UpdateStatus . UpdateDownloading ; this . _downloadProgress = progress . percent ; try { AppMenuBuilder . refreshAppUpdateMenu ( ) ; const { UpdateProgressIndicator } = SharedConstants . Commands . UI ; const progressPayload = { label : 's' , progress : progress . percent } ; await this . commandService . remoteCall ( UpdateProgressIndicator , progressPayload ) ; } catch ( e ) { console . error ( `template` ) ; } } ; private onUpdateDownloaded = async ( updateInfo ) => { TelemetryService . trackEvent ( 's' , { version : updateInfo . version , installAfterDownload : this . _installAfterDownload , } ) ; if ( this . _installAfterDownload ) { this . quitAndInstall ( ) ; return ; } else { this . _status = UpdateStatus . UpdateReadyToInstall ; this . _updateDownloaded = true ; try { AppMenuBuilder . refreshAppUpdateMenu ( ) ; const { UpdateProgressIndicator } = SharedConstants . Commands . UI ; const progressPayload = { label : 's' , progress : 0 } ; await this . commandService . remoteCall ( UpdateProgressIndicator , progressPayload ) ; const notification = newNotification ( `template` ) ; notification . addButton ( 's' , ( ) => { const { Commands } = SharedConstants ; this . commandService . remoteCall ( Commands . Notifications . Remove , notification . id ) ; } ) ; notification . addButton ( 's' , async ( ) => { try { this . quitAndInstall ( ) ; } catch ( e ) { await sendNotificationToClient ( newNotification ( e ) , this . commandService ) ; } } ) ; await sendNotificationToClient ( notification , this . commandService ) ; } catch ( e ) { console . error ( `template` ) ; } } } ; private get _status ( ) : UpdateStatus { return this . _updaterStatus ; } private set _status ( status ) { this . _updaterStatus = status ; store . dispatch ( setUpdateStatus ( status ) ) ; } } export const AppUpdater = new EmulatorUpdater ( ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $FrameworkAction<any>$ O O O O O O $UpdateAction<any>$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O $boolean$ O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $any$ O O O $any$ O O O O $any$ O O O O $number$ O O O O O O O O $number$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O $boolean$ O O $any$ O $any$ O $boolean$ O O O $boolean$ O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O $boolean$ O O $any$ O $any$ O $boolean$ O O O $boolean$ O $boolean$ O O O O $string$ O O O O O O O O O $boolean$ O O O O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O $any$ O O O $boolean$ O O O $any$ O $any$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O O O $Promise$ O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O O O $boolean$ O O O $any$ O $any$ O O O $boolean$ O O O $any$ O $any$ O O O $boolean$ O $boolean$ O $any$ O $any$ O O $string$ O O O $string$ O $string$ O O O $string$ O O O O O O O O O $any$ O $any$ O O O $any$ O $void$ O O O O $boolean$ O O $boolean$ O $boolean$ O O O $boolean$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $Promise$ O $boolean$ O O O O O O O $boolean$ O $boolean$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $Promise<void>$ O O O $UpdateInfo$ O O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $boolean$ O O O O O $any$ O $any$ O $FrameworkAction<any>$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O O O O O O O O O $any$ O O $Console$ O $void$ O O O O O O O O O O $Promise<void>$ O O O O $complex$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $void$ O O O O O $boolean$ O $boolean$ O O O O O O $boolean$ O O $boolean$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $Console$ O $void$ O O O O O O O O $Promise<void>$ O O O $Error$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $void$ O O O O O $string$ O $boolean$ O O O O O O O $any$ O O O O O O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O $Promise<void>$ O O O $ProgressInfo$ O O O O O $any$ O $any$ O $any$ O O O $number$ O $any$ O $any$ O O O $any$ O $void$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O O O $any$ O O $Console$ O $void$ O O O O O O O O $Promise<void>$ O O O $UpdateInfo$ O O O $any$ O $void$ O O O O $any$ O $any$ O $any$ O $boolean$ O O O $boolean$ O O O O O O O O $boolean$ O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O $any$ O $void$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $number$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $void$ O O O O O O $any$ O O O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O $any$ O O $Console$ O $void$ O O O O O O O O O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $UpdateStatus$ O O O O $any$ O $any$ O $any$ O $any$ O $UpdateAction<any>$ O $any$ O O O O O O O $EmulatorUpdater$ O O $any$ O O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
import { BotInfo , SharedConstants , UpdateStatus } from 's' ; import { CommandServiceImpl , CommandServiceInstance , ConversationService } from 's' ; import { app , clipboard , Menu , MenuItem , MenuItemConstructorOptions , shell } from 's' ; import { AppUpdater } from 's' ; import { BotHelpers } from 's' ; import { Emulator } from 's' ; import { rememberTheme } from 's' ; import { TelemetryService } from 's' ; import { isMac } from 's' ; import { store } from 's' ; import { getLocalhostServiceUrl } from 's' ; import { getCurrentConversationId } from 's' ; declare type MenuOpts = MenuItemConstructorOptions ; export class AppMenuBuilder { @ CommandServiceInstance ( ) private static commandService : CommandServiceImpl ; public static get sendActivityMenuItems ( ) : MenuItem [ ] { const menu = Menu . getApplicationMenu ( ) ; if ( menu ) { const sendActivityMenu = menu . getMenuItemById ( 's' ) as any ; const { submenu = { items : [ ] } } = sendActivityMenu || { } ; return submenu . items ; } return [ ] ; } public static get recentBotsMenuItems ( ) : MenuItem [ ] { const menu = Menu . getApplicationMenu ( ) ; if ( menu ) { const recentBotsMenu = menu . getMenuItemById ( 's' ) as any ; const { submenu = { items : [ ] } } = recentBotsMenu || { } ; return submenu . items ; } return [ ] ; } public static async initAppMenu ( ) < void > { if ( process . platform === 's' ) { Menu . setApplicationMenu ( null ) ; return ; } const template : MenuOpts [ ] = [ await this . initFileMenu ( ) , this . initDebugMenu ( ) , await this . initEditMenu ( ) , await this . initViewMenu ( ) , await this . initConversationMenu ( ) , await this . initHelpMenu ( ) , ] ; if ( isMac ( ) ) { template . unshift ( await this . initAppMenuMac ( ) ) ; template . splice ( 0 , 0 , { label : 's' , submenu : await this . initWindowMenuMac ( ) , } ) ; } const menu = Menu . buildFromTemplate ( template ) ; Menu . setApplicationMenu ( menu ) ; } public static refreshFileMenu ( ) { const menu = Menu . getApplicationMenu ( ) ; if ( menu ) { const fileMenu = ( menu . getMenuItemById ( 's' ) as any ) || { } ; if ( fileMenu . submenu ) { const recentBotsMenuItems = this . recentBotsMenuItems ; const recentBotsMenu = new Menu ( ) ; recentBotsMenuItems . forEach ( item => { recentBotsMenu . append ( item ) ; } ) ; const fileMenuContent = Menu . buildFromTemplate ( this . getUpdatedFileMenuContent ( recentBotsMenu ) ) ; fileMenu . submenu . clear ( ) ; fileMenuContent . items . forEach ( item => { fileMenu . submenu . append ( item ) ; } ) ; } } } public static updateRecentBotsList ( updatedBots : BotInfo [ ] = [ ] ) { const menu = Menu . getApplicationMenu ( ) ; if ( menu ) { const recentBotsMenu = menu . getMenuItemById ( 's' ) as any ; if ( recentBotsMenu && recentBotsMenu . submenu && recentBotsMenu . submenu . items ) { const recentBots = this . getRecentBotsList ( updatedBots ) ; recentBotsMenu . submenu . clear ( ) ; recentBots . forEach ( bot => recentBotsMenu . submenu . append ( bot ) ) ; recentBotsMenu . enabled = ! ! updatedBots . length ; } } } public static refreshAppUpdateMenu ( ) { const menu = Menu . getApplicationMenu ( ) ; if ( menu ) { const { status } = AppUpdater ; const { Idle , UpdateAvailable , UpdateDownloading , UpdateReadyToInstall } = UpdateStatus ; const updateRestartItem = menu . getMenuItemById ( 's' ) ; if ( updateRestartItem ) { updateRestartItem . visible = status === UpdateReadyToInstall ; } const updateCheckItem = menu . getMenuItemById ( 's' ) ; if ( updateCheckItem ) { updateCheckItem . visible = status === Idle || status === UpdateAvailable ; } const updateDownloadingItem = menu . getMenuItemById ( 's' ) ; if ( updateDownloadingItem ) { updateDownloadingItem . visible = status === UpdateDownloading ; } } } private static getRecentBotsList ( bots : BotInfo [ ] = [ ] ) : MenuItem [ ] { return bots . filter ( Boolean ) . slice ( 0 , 0 ) . map ( bot => new MenuItem ( { label : bot . displayName , click : ( ) => { AppMenuBuilder . commandService . remoteCall ( SharedConstants . Commands . Bot . Switch , bot . path ) . catch ( err => console . error ( 's' , err ) ) ; } , } ) ) ; } private static getUpdatedFileMenuContent ( recentBotsMenu = new Menu ( ) ) : MenuOpts [ ] { const { Azure , UI , Bot , Emulator : EmulatorCommands } = SharedConstants . Commands ; const subMenu : MenuOpts [ ] = [ { label : 's' , click : ( ) => { AppMenuBuilder . commandService . remoteCall ( UI . ShowBotCreationDialog ) ; } , } , { type : 's' } , { label : 's' , click : ( ) => { AppMenuBuilder . commandService . remoteCall ( UI . ShowOpenBotDialog ) ; } , } , { id : 's' , label : 's' , enabled : ! ! recentBotsMenu . items . length , submenu : recentBotsMenu , } , { type : 's' } , { label : 's' , click : ( ) => { AppMenuBuilder . commandService . remoteCall ( EmulatorCommands . PromptToOpenTranscript ) . catch ( err => { console . error ( 's' , err ) ; } ) ; } , } , { type : 's' } , ] ; const activeBot = BotHelpers . getActiveBot ( ) ; subMenu . push ( { label : 's' , click : async ( ) => { await AppMenuBuilder . commandService . remoteCall ( Bot . Close ) ; await AppMenuBuilder . commandService . call ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; } , enabled : activeBot !== null , } ) ; const settingsState = store . getState ( ) . settings ; const { signedInUser } = settingsState . azure ; const azureMenuItemLabel = signedInUser ? `template` : 's' ; subMenu . push ( { type : 's' } ) ; subMenu . push ( { label : azureMenuItemLabel , click : async ( ) => { if ( signedInUser ) { await AppMenuBuilder . commandService . call ( Azure . SignUserOutOfAzure ) ; await AppMenuBuilder . commandService . remoteCall ( UI . InvalidateAzureArmToken ) ; } else { await AppMenuBuilder . commandService . remoteCall ( UI . SignInToAzure ) ; } } , } ) ; subMenu . push ( { label : 's' , click : async ( ) => { await AppMenuBuilder . commandService . call ( SharedConstants . Commands . Emulator . ClearState ) ; } , } ) ; const { availableThemes , theme } = settingsState . windowState ; subMenu . push . apply ( subMenu , [ { type : 's' } , { label : 's' , submenu : availableThemes . map ( t => ( { label : t . name , type : isMac ( ) ? 's' : 's' , checked : theme === t . name , click : async ( ) => { store . dispatch ( rememberTheme ( t . name ) ) ; await AppMenuBuilder . commandService . call ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; } , } ) ) , } , ] ) ; subMenu . push ( { type : 's' } ) ; subMenu . push ( { label : 's' , click : async ( ) => { const url = await Emulator . getInstance ( ) . ngrok . getServiceUrl ( 's' ) ; clipboard . writeText ( url ) ; } , } ) ; subMenu . push ( { type : 's' } ) ; subMenu . push ( { role : 's' } ) ; return subMenu ; } private static async initConversationMenu ( ) < MenuOpts > { const getState = ( ) => AppMenuBuilder . commandService . remoteCall < any > ( SharedConstants . Commands . Misc . GetStoreState ) ; const getActiveDocumentContentType = async ( ) => { const state = await getState ( ) ; if ( ! state . editor ) { return ; } const { editors , activeEditor } = state . editor ; const { activeDocumentId } = editors [ activeEditor ] ; const activeDocument = editors [ activeEditor ] . documents [ activeDocumentId ] ; if ( activeDocument ) { return activeDocument . contentType ; } } ; const createClickHandler = ( serviceFunction , callback ? ) => async ( ) => { const conversationId = getCurrentConversationId ( ) ; serviceFunction ( getLocalhostServiceUrl ( ) , conversationId ) ; if ( callback ) { callback ( ) ; } } ; const enabled = ( await getActiveDocumentContentType ( ) ) === SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT ; return { id : 's' , label : 's' , submenu : [ { id : 's' , label : 's' , submenu : [ { label : 's' , click : createClickHandler ( ConversationService . addUser , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , { label : 's' , click : createClickHandler ( ConversationService . botContactAdded , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , { label : 's' , click : createClickHandler ( ConversationService . botContactRemoved , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , { label : 's' , click : createClickHandler ( ConversationService . typing , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , { label : 's' , click : createClickHandler ( ConversationService . ping , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , { label : 's' , click : createClickHandler ( ConversationService . deleteUserData , ( ) => TelemetryService . trackEvent ( 's' ) ) , enabled , } , ] , } , ] , } ; } private static async initAppMenuMac ( ) < MenuOpts > { return { label : app . getName ( ) , submenu : [ { role : 's' } , { type : 's' } , { role : 's' , submenu : [ ] } , { type : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , ] , } ; } private static async initEditMenu ( ) < MenuOpts > { return { label : 's' , submenu : [ { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , ] . filter ( item => item ) as any [ ] , } ; } private static initFileMenu ( ) { return { id : 's' , label : 's' , submenu : this . getUpdatedFileMenuContent ( ) , } ; } public static async initViewMenu ( ) < MenuOpts > { return { label : 's' , id : 's' , submenu : [ { role : 's' , label : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , { role : 's' } , ] , } ; } private static async initWindowMenuMac ( ) < MenuOpts [ ] > { return [ { role : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } ] ; } private static async initHelpMenu ( ) < MenuOpts > { const appName = app . getName ( ) ; const version = app . getVersion ( ) ; const { Commands , Channels } = SharedConstants ; return { role : 's' , submenu : [ { label : 's' , click : ( ) => AppMenuBuilder . commandService . remoteCall ( Commands . UI . ShowWelcomePage ) , } , { type : 's' } , { label : 's' , click : ( ) => shell . openExternal ( 's' , { activate : true } ) , } , { label : 's' , click : ( ) => shell . openExternal ( 's' , { activate : true , } ) , } , { label : 's' , click : ( ) => shell . openExternal ( 's' , { activate : true , } ) , } , { type : 's' } , { label : 's' , click : ( ) => shell . openExternal ( 's' , { activate : true , } ) , } , { type : 's' } , { id : 's' , label : 's' , click : ( ) => AppUpdater . quitAndInstall ( ) , enabled : true , visible : AppUpdater . status === UpdateStatus . UpdateReadyToInstall , } , { id : 's' , label : `template` , enabled : false , visible : AppUpdater . status === UpdateStatus . UpdateDownloading , } , { id : 's' , label : 's' , click : ( ) => AppUpdater . checkForUpdates ( true ) , enabled : true , visible : AppUpdater . status === UpdateStatus . Idle || AppUpdater . status === UpdateStatus . UpdateAvailable , } , { type : 's' } , { label : Channels . HelpLabel , click : ( ) => AppMenuBuilder . commandService . remoteCall ( Commands . UI . ShowMarkdownPage , Channels . ReadmeUrl , Channels . HelpLabel ) , } , { label : 's' , click : ( ) => this . commandService . call ( SharedConstants . Commands . Electron . ShowMessageBox , true , { type : 's' , title : appName , message : appName + 's' + version , buttons : [ 's' ] , } ) , } , ] , } ; } private static initDebugMenu ( ) { const { UI } = SharedConstants . Commands ; return { label : 's' , id : 's' , submenu : [ { label : 's' , click : ( ) => { AppMenuBuilder . commandService . remoteCall ( UI . ShowOpenBotDialog , true ) ; } , } , ] , } ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $EmulatorUpdater$ O O O O O O $any$ O O O O O O $any$ O O O O O O $WindowStateAction<RememberThemePayload>$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any[]$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $undefined[]$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any[]$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $undefined[]$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $Promise$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any[]$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O O O O O O $boolean$ O O O O $any[]$ O $number$ O O O O $Promise<any>$ O O O O $any[]$ O $complex$ O O O O O O $string$ O O O $any[]$ O O O O $Promise<any[]>$ O O O O O O O O $any$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O $any[]$ O O O $any[]$ O O $any$ O O $any$ O O O $any[]$ O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O $any[]$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O O O $any[]$ O $any[]$ O O $any$ O $any$ O $any$ O O O $any[]$ O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any[]$ O $number$ O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $EmulatorUpdater$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O $any[]$ O $any$ O O O O O O O $any$ O O O O $any[]$ O $complex$ O $BooleanConstructor$ O O $any[]$ O O O O O O $U[]$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $Console$ O $void$ O O O $any$ O O O O O O O O O O O O $any[]$ O $Menu$ O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any[]$ O $any$ O O O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O $string$ O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O O $string$ O $any$ O O O O O $any[]$ O $number$ O O $string$ O O O O O $any[]$ O $number$ O O $string$ O $string$ O $Promise<void>$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any[]$ O $number$ O O $string$ O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any[]$ O $number$ O $any$ O $any[]$ O O O $string$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $boolean$ O O O O O O O $boolean$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O O O $any$ O $any$ O $WindowStateAction<RememberThemePayload>$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any[]$ O $number$ O O $string$ O O O O O $any[]$ O $number$ O O $string$ O O O $Promise<void>$ O O O O O O O $string$ O O $any$ O $Emulator$ O O O $NgrokService$ O $Promise<string>$ O O O O $any$ O $any$ O $string$ O O O O O O O $any[]$ O $number$ O O $string$ O O O O O $any[]$ O $number$ O O $string$ O O O O O O $any[]$ O O O O O $Promise$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise<any>$ O O O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $Promise<void>$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $string$ O O O $any$ O O O O $any$ O O $any$ O O O O O O O $boolean$ O O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O $string$ O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $void$ O O O O O $boolean$ O O O O O O O O O O O O O O O $Promise$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $undefined[]$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $Promise$ O O O $any$ O O O O $string$ O O O $any[]$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $complex$ O $complex$ O $complex$ O O O O O O O O O O O $MenuOpts$ O O O O O $string$ O O O $string$ O O O $any[]$ O O O $any[]$ O O O O O O O O O $Promise$ O O O $any$ O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $Promise$ O O O $any$ O O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O $Promise$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O $string$ O O O $complex$ O O O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O O O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O O O O O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O O O O O O O O O $string$ O O O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O $boolean$ O O O O O O O O O $string$ O O O O O $string$ O O O $string$ O O O $void$ O O O O $EmulatorUpdater$ O $void$ O O O $boolean$ O O O $boolean$ O $EmulatorUpdater$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O $EmulatorUpdater$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $Promise<void>$ O O O O $EmulatorUpdater$ O $Promise<void>$ O O O O $boolean$ O O O $boolean$ O $EmulatorUpdater$ O $any$ O $any$ O $any$ O $EmulatorUpdater$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O $string$ O $any$ O O O $any$ O $string[]$ O O O O O O O O O O O O O O O O O $MenuOpts$ O O O O O $any$ O O $any$ O $any$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O
import { join } from 's' ; import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { AppMenuBuilder } from 's' ; jest . mock ( 's' , ( ) => ( { store : { getState : ( ) => ( { bot : { botFiles : [ ] , } , settings : { azure : { signedInUser : 's' } , windowState : { availableThemes : [ { name : 's' } , { name : 's' } , { name : 's' } ] , theme : 's' , } , } , } ) , subscribe : ( ) => null , } , } ) ) ; let mockBuildFromTemplate ; let mockGetApplicationMenu ; let mockSetApplicationMenu ; const mockMenuClassAppend = jest . fn ( ( ) => null ) ; jest . mock ( 's' , ( ) => ( { app : { getName : ( ) => 's' , setName : ( ) => void 0 , getVersion : ( ) => 's' , on : ( ) => void 0 , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , Menu : class { append = mockMenuClassAppend ; items : any [ ] = [ ] ; static get buildFromTemplate ( ) { return mockBuildFromTemplate ; } static get getApplicationMenu ( ) { return mockGetApplicationMenu ; } static get setApplicationMenu ( ) { return mockSetApplicationMenu ; } } , MenuItem : class { label : string ; click : ( ) => any ; constructor ( options ) { this . label = options . label ; this . click = options . click ; } } , systemPreferences : { isInvertedColorScheme : jest . fn ( ( ) => true ) , on : jest . fn ( ( ) => null ) , } , } ) ) ; const mockUpdateStatus = { Idle : 0 , UpdateAvailable : 0 , UpdateDownloading : 0 , UpdateReadyToInstall : 0 , } ; const mockAppUpdater = { status : mockUpdateStatus . Idle , } ; jest . mock ( 's' , ( ) => ( { get AppUpdater ( ) { return mockAppUpdater ; } , get UpdateStatus ( ) { return mockUpdateStatus ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => ( { ngrok : { broadcastNgrokExpired : ( ) => null , ngrokEmitter : { on : ( ) => null , } , } , } ) , } , } ) ) ; describe ( 's' , ( ) => { const mockSendActivityMenu = { submenu : { items : [ { label : 's' } , { label : 's' } , { label : 's' } ] , } , } ; const mockRecentBotsMenuClear = jest . fn ( ( ) => null ) ; let mockAppendedBots ; const mockRecentBotsMenuAppend = jest . fn ( botItem => mockAppendedBots . push ( botItem ) ) ; const mockRecentBotsMenu = { enabled : false , submenu : { append : mockRecentBotsMenuAppend , clear : mockRecentBotsMenuClear , items : [ { label : 's' } , { label : 's' } , { label : 's' } ] , } , } ; const mockAutoUpdateRestartMenuItem = { visible : false } ; const mockAutoUpdateCheckMenuItem = { visible : false } ; const mockAutoUpdateDownloadingMenuItem = { visible : false } ; let appendedFileMenuItems ; const mockFileMenuAppend = jest . fn ( fileMenuItem => appendedFileMenuItems . push ( fileMenuItem ) ) ; const mockFileMenuClear = jest . fn ( ( ) => null ) ; const mockFileMenu = { submenu : { append : mockFileMenuAppend , clear : mockFileMenuClear , } , } ; let mockGetMenuItemById ; let processPlatformBackup ; let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; beforeEach ( ( ) => { processPlatformBackup = process . platform ; mockAppendedBots = [ ] ; appendedFileMenuItems = [ ] ; mockGetMenuItemById = jest . fn ( ( id ) => { switch ( id ) { case 's' : return mockSendActivityMenu ; case 's' : return mockRecentBotsMenu ; case 's' : return mockAutoUpdateRestartMenuItem ; case 's' : return mockAutoUpdateCheckMenuItem ; case 's' : return mockAutoUpdateDownloadingMenuItem ; case 's' : return mockFileMenu ; default : return null ; } } ) ; mockBuildFromTemplate = jest . fn ( ( ) => null ) ; mockGetApplicationMenu = jest . fn ( ( ) => ( { getMenuItemById : mockGetMenuItemById , } ) ) ; mockSetApplicationMenu = jest . fn ( ( ) => null ) ; } ) ; afterEach ( ( ) => { Object . defineProperty ( process , 's' , { value : processPlatformBackup , } ) ; } ) ; it ( 's' , ( ) => { expect ( AppMenuBuilder . sendActivityMenuItems ) . toEqual ( mockSendActivityMenu . submenu . items ) ; expect ( mockGetMenuItemById ) . toHaveBeenCalledWith ( 's' ) ; mockGetApplicationMenu = jest . fn ( ( ) => null ) ; expect ( AppMenuBuilder . sendActivityMenuItems ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { expect ( AppMenuBuilder . recentBotsMenuItems ) . toEqual ( mockRecentBotsMenu . submenu . items ) ; expect ( mockGetMenuItemById ) . toHaveBeenCalledWith ( 's' ) ; mockGetApplicationMenu = jest . fn ( ( ) => null ) ; expect ( AppMenuBuilder . recentBotsMenuItems ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { mockAppUpdater . status = mockUpdateStatus . Idle ; AppMenuBuilder . refreshAppUpdateMenu ( ) ; expect ( mockAutoUpdateRestartMenuItem . visible ) . toBe ( false ) ; expect ( mockAutoUpdateCheckMenuItem . visible ) . toBe ( true ) ; expect ( mockAutoUpdateDownloadingMenuItem . visible ) . toBe ( false ) ; mockAppUpdater . status = mockUpdateStatus . UpdateAvailable ; AppMenuBuilder . refreshAppUpdateMenu ( ) ; expect ( mockAutoUpdateRestartMenuItem . visible ) . toBe ( false ) ; expect ( mockAutoUpdateCheckMenuItem . visible ) . toBe ( true ) ; expect ( mockAutoUpdateDownloadingMenuItem . visible ) . toBe ( false ) ; mockAppUpdater . status = mockUpdateStatus . UpdateReadyToInstall ; AppMenuBuilder . refreshAppUpdateMenu ( ) ; expect ( mockAutoUpdateRestartMenuItem . visible ) . toBe ( true ) ; expect ( mockAutoUpdateCheckMenuItem . visible ) . toBe ( false ) ; expect ( mockAutoUpdateDownloadingMenuItem . visible ) . toBe ( false ) ; mockAppUpdater . status = mockUpdateStatus . UpdateDownloading ; AppMenuBuilder . refreshAppUpdateMenu ( ) ; expect ( mockAutoUpdateRestartMenuItem . visible ) . toBe ( false ) ; expect ( mockAutoUpdateCheckMenuItem . visible ) . toBe ( false ) ; expect ( mockAutoUpdateDownloadingMenuItem . visible ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const mockRemoteCall = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( true ) ; const mockBotPath = join ( 's' , 's' , 's' ) ; const mockRecentBots = [ { displayName : 's' , path : mockBotPath } , { displayName : 's' } , { displayName : 's' } , ] ; AppMenuBuilder . updateRecentBotsList ( mockRecentBots ) ; expect ( mockRecentBotsMenuClear ) . toHaveBeenCalled ( ) ; expect ( mockRecentBotsMenuAppend ) . toHaveBeenCalledTimes ( mockRecentBots . length ) ; expect ( mockAppendedBots . some ( bot => bot . label === 's' ) ) . toBe ( true ) ; expect ( mockAppendedBots . some ( bot => bot . label === 's' ) ) . toBe ( true ) ; expect ( mockAppendedBots . some ( bot => bot . label === 's' ) ) . toBe ( true ) ; const botWithPath = mockAppendedBots . find ( bot => bot . label === 's' ) ; botWithPath . click ( ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . Switch , mockBotPath ) ; expect ( mockRecentBotsMenu . enabled ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const mockFileItems = [ 's' , 's' , 's' ] ; mockBuildFromTemplate = jest . fn ( ( ) => ( { items : mockFileItems , } ) ) ; AppMenuBuilder . refreshFileMenu ( ) ; expect ( mockMenuClassAppend ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockMenuClassAppend ) . toHaveBeenCalledWith ( mockRecentBotsMenu . submenu . items [ 0 ] ) ; expect ( mockMenuClassAppend ) . toHaveBeenCalledWith ( mockRecentBotsMenu . submenu . items [ 0 ] ) ; expect ( mockMenuClassAppend ) . toHaveBeenCalledWith ( mockRecentBotsMenu . submenu . items [ 0 ] ) ; expect ( mockBuildFromTemplate ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockFileMenuClear ) . toHaveBeenCalled ( ) ; expect ( mockFileMenuAppend ) . toHaveBeenCalledTimes ( mockFileItems . length ) ; expect ( mockFileMenuAppend ) . toHaveBeenCalledWith ( mockFileItems [ 0 ] ) ; expect ( mockFileMenuAppend ) . toHaveBeenCalledWith ( mockFileItems [ 0 ] ) ; expect ( mockFileMenuAppend ) . toHaveBeenCalledWith ( mockFileItems [ 0 ] ) ; } ) ; it ( 's' , async ( ) => { Object . defineProperty ( process , 's' , { value : 's' } ) ; const result = await AppMenuBuilder . initAppMenu ( ) ; expect ( result ) . toBe ( undefined ) ; expect ( mockSetApplicationMenu ) . toHaveBeenCalledWith ( null ) ; } ) ; it ( 's' , async ( ) => { let appMenuTemplate ; mockBuildFromTemplate = jest . fn ( template => { appMenuTemplate = template ; return 's' ; } ) ; const mockState = { chat : { chats : { someDocId : { conversationId : 's' , } , } , } , editor : { activeEditor : 's' , editors : { primary : { activeDocumentId : 's' , documents : { someDocId : { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT , } , } , } , } , } , } ; const mockRemoteCall = jest . fn ( commandName => { if ( commandName === SharedConstants . Commands . Misc . GetStoreState ) { return Promise . resolve ( mockState ) ; } else { return Promise . resolve ( { } ) ; } } ) ; jest . spyOn ( commandService , 's' ) . mockImplementation ( mockRemoteCall ) ; Object . defineProperty ( process , 's' , { value : 's' } ) ; await AppMenuBuilder . initAppMenu ( ) ; expect ( appMenuTemplate ) . toHaveLength ( 0 ) ; const fileMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( fileMenuTemplate ) . toHaveLength ( 0 ) ; const azureSignInItem = fileMenuTemplate [ 0 ] ; expect ( azureSignInItem . label ) . toBe ( 's' ) ; const themeMenu = fileMenuTemplate [ 0 ] ; expect ( themeMenu . label ) . toBe ( 's' ) ; expect ( themeMenu . submenu ) . toHaveLength ( 0 ) ; expect ( themeMenu . submenu [ 0 ] . type ) . toBe ( 's' ) ; expect ( themeMenu . submenu [ 0 ] . label ) . toBe ( 's' ) ; expect ( themeMenu . submenu [ 0 ] . checked ) . toBe ( true ) ; const debugMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( debugMenuTemplate ) . toHaveLength ( 0 ) ; const editMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( editMenuTemplate ) . toHaveLength ( 0 ) ; const viewMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( viewMenuTemplate ) . toHaveLength ( 0 ) ; const convoMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( convoMenuTemplate ) . toHaveLength ( 0 ) ; const sendActivityMenu = convoMenuTemplate [ 0 ] . submenu ; expect ( sendActivityMenu ) . toHaveLength ( 0 ) ; const helpMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( helpMenuTemplate ) . toHaveLength ( 0 ) ; expect ( mockSetApplicationMenu ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { let appMenuTemplate ; mockBuildFromTemplate = jest . fn ( template => { appMenuTemplate = template ; return 's' ; } ) ; const mockState = { chat : { chats : { someDocId : { conversationId : 's' , } , } , } , editor : { activeEditor : 's' , editors : { primary : { activeDocumentId : 's' , documents : { someDocId : { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT , } , } , } , } , } , } ; const mockRemoteCall = jest . fn ( commandName => { if ( commandName === SharedConstants . Commands . Misc . GetStoreState ) { return Promise . resolve ( mockState ) ; } else { return Promise . resolve ( { } ) ; } } ) ; jest . spyOn ( commandService , 's' ) . mockImplementation ( mockRemoteCall ) ; Object . defineProperty ( process , 's' , { value : 's' } ) ; await AppMenuBuilder . initAppMenu ( ) ; expect ( appMenuTemplate ) . toHaveLength ( 0 ) ; const macAppMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( macAppMenuTemplate ) . toHaveLength ( 0 ) ; const windowMenuTemplate = appMenuTemplate [ 0 ] . submenu ; expect ( windowMenuTemplate ) . toHaveLength ( 0 ) ; const fileMenuTemplate = appMenuTemplate [ 0 ] . submenu ; const themeMenu = fileMenuTemplate [ 0 ] ; expect ( themeMenu . submenu [ 0 ] . type ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O $complex$ O O $complex$ O O $string$ O O O O $complex$ O O $complex$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O $any$ O O O O O O O $string$ O O O O O O $any$ O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O $any[]$ O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $string$ O O O $any$ O O O O O O O O $any$ O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $complex$ O O $number$ O $complex$ O $number$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $any$ O O O O O O $complex$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O O $boolean$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $boolean$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O $complex$ O O O O O $complex$ O O O O O $complex$ O O O O O $complex$ O O O O O $complex$ O O O O O $complex$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O $ObjectConstructor$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any[]$ O O $any$ O $complex$ O $complex$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any[]$ O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any[]$ O O $any$ O $complex$ O $complex$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any[]$ O O $any$ O O O O O O O O $any$ O O O O O O O $complex$ O $number$ O $complex$ O $number$ O $any$ O $void$ O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $complex$ O $number$ O $complex$ O $number$ O $any$ O $void$ O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $complex$ O $number$ O $complex$ O $number$ O $any$ O $void$ O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $complex$ O $number$ O $complex$ O $number$ O $any$ O $void$ O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O $any$ O $complex$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O O O $string$ O O O O O O $any$ O $void$ O $complex$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $complex$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $string[]$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string[]$ O $string[]$ O O O O O $any$ O $void$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O O O O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O O O O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $string[]$ O $number$ O O $any$ O $any$ O O $any$ O $string[]$ O O O O O $any$ O $any$ O O $any$ O $string[]$ O O O O O $any$ O $any$ O O $any$ O $string[]$ O O O O O O O O $any$ O O O O O O O O $ObjectConstructor$ O $any$ O $any$ O O O O $string$ O O O O O O $void$ O O $any$ O $Promise<void>$ O O O $any$ O $void$ O O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O $complex$ O $complex$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $ObjectConstructor$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O $complex$ O $complex$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $ObjectConstructor$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O
import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { SharedConstants , UpdateStatus } from 's' ; import { AppUpdater } from 's' ; import { TelemetryService } from 's' ; import { AppMenuBuilder } from 's' ; import { setFrameworkSettings , setUpdateStatus } from 's' ; let mockAutoUpdater = { quitAndInstall : null , downloadUpdate : null , checkForUpdates : null , setFeedURL : null , } ; const defaultSettings = { autoUpdate : false , usePrereleases : false , } ; let mockSettings ; jest . mock ( 's' , ( ) => ( { get autoUpdater ( ) { return mockAutoUpdater ; } , UpdateInfo : typeof { } , } ) ) ; const mockDispatch = jest . fn ( ( ) => null ) ; jest . mock ( 's' , ( ) => ( { getSettings : ( ) => ( { get framework ( ) { return mockSettings ; } , } ) , store : { getState : ( ) => ( { bot : { botFiles : [ ] , } , get framework ( ) { return mockSettings ; } , } ) , get dispatch ( ) { return mockDispatch ; } , subscribe : ( ) => null , } , } ) ) ; jest . mock ( 's' , ( ) => ( { TelemetryService : { trackEvent : ( ) => null , } , } ) ) ; jest . mock ( 's' , ( ) => ( { app : { on : ( ) => void 0 , setName : ( ) => void 0 , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , systemPreferences : { isInvertedColorScheme : jest . fn ( ( ) => true ) , on : jest . fn ( ( ) => null ) , } , } ) ) ; const mockSendNotification = jest . fn ( ) . mockResolvedValue ( undefined ) ; jest . mock ( 's' , ( ) => ( { get sendNotificationToClient ( ) { return mockSendNotification ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => ( { ngrok : { ngrokEmitter : { on : ( ) => null , } , } , } ) , } , } ) ) ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; beforeEach ( ( ) => { mockAutoUpdater = { } ; mockSettings = { ... defaultSettings } ; mockTrackEvent = jest . fn ( ( ) => Promise . resolve ( ) ) ; TelemetryService . trackEvent = mockTrackEvent ; mockDispatch . mockClear ( ) ; mockSendNotification . mockClear ( ) ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; it ( 's' , ( ) => { const tmp = ( AppUpdater as any ) . _userInitiated ; ( AppUpdater as any ) . _userInitiated = true ; expect ( AppUpdater . userInitiated ) . toBe ( true ) ; ( AppUpdater as any ) . _userInitiated = tmp ; } ) ; it ( 's' , ( ) => { const tmp = ( AppUpdater as any ) . _status ; ( AppUpdater as any ) . _status = true ; expect ( AppUpdater . status ) . toBe ( true ) ; ( AppUpdater as any ) . _status = tmp ; } ) ; it ( 's' , ( ) => { const tmp = ( AppUpdater as any ) . _downloadProgress ; ( AppUpdater as any ) . _downloadProgress = true ; expect ( AppUpdater . downloadProgress ) . toBe ( true ) ; ( AppUpdater as any ) . _downloadProgress = tmp ; } ) ; it ( 's' , ( ) => { const tmp = ( AppUpdater as any ) . _updateDownloaded ; ( AppUpdater as any ) . _updateDownloaded = true ; expect ( AppUpdater . updateDownloaded ) . toBe ( true ) ; ( AppUpdater as any ) . _updateDownloaded = tmp ; } ) ; it ( 's' , ( ) => { AppUpdater . allowPrerelease = true ; expect ( AppUpdater . repo ) . toBe ( 's' ) ; AppUpdater . allowPrerelease = false ; expect ( AppUpdater . repo ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { mockAutoUpdater . autoDownload = false ; AppUpdater . autoDownload = true ; expect ( mockAutoUpdater . autoDownload ) . toBe ( true ) ; expect ( AppUpdater . autoDownload ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { mockAutoUpdater . allowPrerelease = false ; AppUpdater . allowPrerelease = true ; expect ( mockAutoUpdater . allowPrerelease ) . toBe ( true ) ; expect ( AppUpdater . allowPrerelease ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { mockSettings . usePrereleases = false ; mockSettings . autoUpdate = true ; const mockOn = jest . fn ( ( _eventName , _handler : ( ) => any ) => null ) ; const mockSetFeedURL = jest . fn ( ( _options ) => null ) ; mockAutoUpdater . on = mockOn ; mockAutoUpdater . setFeedURL = mockSetFeedURL ; const tmp = AppUpdater . checkForUpdates ; const mockCheckForUpdates = jest . fn ( _ => Promise . resolve ( true ) ) ; AppUpdater . checkForUpdates = mockCheckForUpdates ; await AppUpdater . startup ( ) ; expect ( AppUpdater . autoDownload ) . toBe ( true ) ; expect ( AppUpdater . allowPrerelease ) . toBe ( false ) ; expect ( mockAutoUpdater . autoInstallOnAppQuit ) . toBe ( true ) ; expect ( mockAutoUpdater . logger ) . toBe ( null ) ; expect ( mockOn ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockCheckForUpdates ) . toHaveBeenCalledWith ( false ) ; AppUpdater . checkForUpdates = tmp ; } ) ; it ( 's' , async ( ) => { const mockSetFeedURL = jest . fn ( ( _options ) => null ) ; const mockCheckForUpdates = jest . fn ( ( ) => Promise . resolve ( ) ) ; mockAutoUpdater . setFeedURL = mockSetFeedURL ; mockAutoUpdater . checkForUpdates = mockCheckForUpdates ; await AppUpdater . checkForUpdates ( true ) ; expect ( AppUpdater . userInitiated ) . toBe ( true ) ; expect ( mockSetFeedURL ) . toHaveBeenCalledWith ( { repo : 's' , owner : 's' , provider : 's' , } ) ; expect ( mockCheckForUpdates ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { auto : ! AppUpdater . userInitiated , prerelease : false , } ) ; } ) ; it ( 's' , async ( ) => { mockSettings . usePrereleases = true ; const mockSetFeedURL = jest . fn ( ( _options ) => null ) ; const mockCheckForUpdates = jest . fn ( ( ) => Promise . resolve ( ) ) ; mockAutoUpdater . setFeedURL = mockSetFeedURL ; mockAutoUpdater . checkForUpdates = mockCheckForUpdates ; await AppUpdater . checkForUpdates ( false ) ; expect ( mockSetFeedURL ) . toHaveBeenCalledWith ( { repo : 's' , owner : 's' , provider : 's' , } ) ; expect ( mockCheckForUpdates ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { auto : ! AppUpdater . userInitiated , prerelease : true , } ) ; } ) ; it ( 's' , async ( ) => { const mockCheckForUpdates = jest . fn ( ( ) => Promise . reject ( 's' ) ) ; mockAutoUpdater . checkForUpdates = mockCheckForUpdates ; mockAutoUpdater . setFeedURL = ( ) => null ; await expect ( AppUpdater . checkForUpdates ( false ) ) . rejects . toThrowError ( 's' ) ; } ) ; it ( 's' , async ( ) => { const mockDownloadUpdate = jest . fn ( ( ) => Promise . resolve ( true ) ) ; mockAutoUpdater . downloadUpdate = mockDownloadUpdate ; await AppUpdater . downloadUpdate ( false ) ; expect ( mockDownloadUpdate ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { mockAutoUpdater . downloadUpdate = ( ) => Promise . reject ( 's' ) ; await expect ( AppUpdater . downloadUpdate ( false ) ) . rejects . toThrowError ( 's' ) ; } ) ; it ( 's' , ( ) => { const mockQuitAndInstall = jest . fn ( ( isSilent , forceRunAfter ) => null ) ; mockAutoUpdater . quitAndInstall = mockQuitAndInstall ; AppUpdater . quitAndInstall ( ) ; expect ( mockQuitAndInstall ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockQuitAndInstall ) . toHaveBeenCalledWith ( false , true ) ; } ) ; it ( 's' , ( ) => { mockAutoUpdater . quitAndInstall = ( ) => { throw 's' ; } ; expect ( ( ) => AppUpdater . quitAndInstall ( ) ) . toThrow ( 's' ) ; } ) ; it ( 's' , async ( ) => { const downloadUpdateSpy = jest . spyOn ( AppUpdater , 's' ) . mockResolvedValueOnce ( undefined ) ; jest . spyOn ( AppMenuBuilder , 's' ) . mockReturnValueOnce ( undefined ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( 0 ) . mockResolvedValueOnce ( undefined ) . mockResolvedValueOnce ( undefined ) ; AppUpdater . autoDownload = false ; await ( AppUpdater as any ) . onUpdateAvailable ( { version : 's' } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( downloadUpdateSpy ) . toHaveBeenCalledWith ( false ) ; remoteCallSpy . mockClear ( ) ; downloadUpdateSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const downloadUpdateSpy = jest . spyOn ( AppUpdater , 's' ) . mockResolvedValueOnce ( undefined ) ; jest . spyOn ( AppMenuBuilder , 's' ) . mockReturnValueOnce ( undefined ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( 0 ) . mockResolvedValueOnce ( undefined ) . mockResolvedValueOnce ( undefined ) ; AppUpdater . autoDownload = false ; await ( AppUpdater as any ) . onUpdateAvailable ( { version : 's' } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( downloadUpdateSpy ) . toHaveBeenCalledWith ( true ) ; remoteCallSpy . mockClear ( ) ; downloadUpdateSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const downloadUpdateSpy = jest . spyOn ( AppUpdater , 's' ) . mockResolvedValueOnce ( undefined ) ; jest . spyOn ( AppMenuBuilder , 's' ) . mockReturnValueOnce ( undefined ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( 0 ) . mockResolvedValueOnce ( undefined ) . mockResolvedValueOnce ( undefined ) ; AppUpdater . autoDownload = false ; await ( AppUpdater as any ) . onUpdateAvailable ( { version : 's' } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( downloadUpdateSpy ) . toHaveBeenCalledWith ( true ) ; expect ( mockDispatch ) . toHaveBeenCalledWith ( setFrameworkSettings ( { ... mockSettings , autoUpdate : true } ) ) ; remoteCallSpy . mockClear ( ) ; downloadUpdateSpy . mockClear ( ) ; mockDispatch . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( AppMenuBuilder , 's' ) . mockReturnValueOnce ( undefined ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( undefined ) ; AppUpdater . autoDownload = false ; await ( AppUpdater as any ) . onUpdateAvailable ( { version : 's' } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledTimes ( 0 ) ; remoteCallSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const downloadUpdateSpy = jest . spyOn ( AppUpdater , 's' ) . mockResolvedValueOnce ( undefined ) ; AppUpdater . autoDownload = true ; await ( AppUpdater as any ) . onUpdateAvailable ( { version : 's' } ) ; expect ( downloadUpdateSpy ) . toHaveBeenCalledWith ( false ) ; downloadUpdateSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const quitAndInstall = jest . spyOn ( AppUpdater , 's' ) . mockReturnValue ( undefined ) ; ( AppUpdater as any ) . _installAfterDownload = true ; await ( AppUpdater as any ) . onUpdateDownloaded ( { version : 's' } ) ; expect ( quitAndInstall ) . toHaveBeenCalled ( ) ; quitAndInstall . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( undefined ) ; jest . spyOn ( AppMenuBuilder , 's' ) . mockReturnValueOnce ( undefined ) ; ( AppUpdater as any ) . _installAfterDownload = false ; await ( AppUpdater as any ) . onUpdateDownloaded ( { version : 's' } ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . UI . UpdateProgressIndicator , { label : 's' , progress : 0 , } ) ; expect ( mockSendNotification ) . toHaveBeenCalled ( ) ; remoteCallSpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { ( AppUpdater as any ) . _updaterStatus = UpdateStatus . Idle ; expect ( ( AppUpdater as any ) . _status ) . toBe ( UpdateStatus . Idle ) ; ( AppUpdater as any ) . _status = UpdateStatus . UpdateAvailable ; expect ( ( AppUpdater as any ) . _updaterStatus ) . toBe ( UpdateStatus . UpdateAvailable ) ; expect ( mockDispatch ) . toHaveBeenCalledWith ( setUpdateStatus ( UpdateStatus . UpdateAvailable ) ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $EmulatorUpdater$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FrameworkAction<any>$ O $UpdateAction<any>$ O O O O O $any$ O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O O $any$ O O O O $any$ O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O O $any$ O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $undefined$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $complex$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $void$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O O $any$ O $EmulatorUpdater$ O $boolean$ O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O O $any$ O $EmulatorUpdater$ O $any$ O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O O $any$ O $EmulatorUpdater$ O $number$ O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $EmulatorUpdater$ O O O O $any$ O O O $any$ O $EmulatorUpdater$ O $boolean$ O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $EmulatorUpdater$ O $boolean$ O O O $any$ O $EmulatorUpdater$ O $string$ O O $any$ O O O O $EmulatorUpdater$ O $boolean$ O O O $any$ O $EmulatorUpdater$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $EmulatorUpdater$ O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $EmulatorUpdater$ O $true$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $EmulatorUpdater$ O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $EmulatorUpdater$ O $true$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $Promise<void>$ O $EmulatorUpdater$ O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O $PromiseConstructor$ O $complex$ O O O O O $EmulatorUpdater$ O $Promise<void>$ O $any$ O O $EmulatorUpdater$ O $Promise<void>$ O O O $any$ O $EmulatorUpdater$ O $boolean$ O O $any$ O O O O $any$ O $EmulatorUpdater$ O $boolean$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $EmulatorUpdater$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $EmulatorUpdater$ O $Promise<void>$ O O O O $any$ O $EmulatorUpdater$ O $boolean$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $boolean$ O O $EmulatorUpdater$ O $boolean$ O $boolean$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $EmulatorUpdater$ O $Promise<void>$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $boolean$ O O $EmulatorUpdater$ O $boolean$ O $boolean$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $EmulatorUpdater$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O $any$ O O $EmulatorUpdater$ O $Promise<void>$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $EmulatorUpdater$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O $void$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $EmulatorUpdater$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $undefined$ O O $any$ O $undefined$ O O $EmulatorUpdater$ O $boolean$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $undefined$ O O $any$ O $undefined$ O O $EmulatorUpdater$ O $boolean$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $undefined$ O O $any$ O $undefined$ O O $EmulatorUpdater$ O $boolean$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $FrameworkAction<any>$ O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $EmulatorUpdater$ O $boolean$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O $undefined$ O O $EmulatorUpdater$ O $boolean$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O $undefined$ O O O $EmulatorUpdater$ O O O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $EmulatorUpdater$ O O O O $any$ O O O O O $EmulatorUpdater$ O O O O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $EmulatorUpdater$ O O O O $any$ O $any$ O $any$ O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $EmulatorUpdater$ O O O O $any$ O $any$ O $any$ O $any$ O O $EmulatorUpdater$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $UpdateAction<any>$ O $any$ O $any$ O O O O O O O O O
import { normalize } from 's' ; import { BotConfigWithPath , BotConfigWithPathImpl , CommandServiceImpl , CommandServiceInstance , } from 's' ; import { BotConfiguration } from 's' ; import { CredentialManager } from 's' ; import { BotHelpers } from 's' ; import { load } from 's' ; jest . mock ( 's' , ( ) => ( { app : { getPath : ( ) => 's' , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const mockDispatch = jest . fn ( _action => null ) ; jest . mock ( 's' , ( ) => ( { store : { getState : ( ) => ( { bot : { activeBot : { name : 's' , description : 's' , padlock : 's' , path : 's' , services : [ ] , } , botFiles : [ { path : 's' , displayName : 's' , secret : 's' } , { path : 's' , displayName : 's' , secret : 's' } , { path : 's' , displayName : 's' , secret : 's' } , { path : 's' , displayName : 's' , secret : 's' } , ] , } , } ) , dispatch => mockDispatch ( action ) , } , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; beforeEach ( ( ) => { mockDispatch . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const activeBot = BotHelpers . getActiveBot ( ) ; expect ( activeBot ) . toEqual ( { name : 's' , description : 's' , padlock : 's' , path : 's' , services : [ ] , } ) ; } ) ; it ( 's' , ( ) => { const info = BotHelpers . getBotInfoByPath ( 's' ) ; expect ( info ) . toEqual ( { path : 's' , displayName : 's' , secret : 's' } ) ; } ) ; it ( 's' , ( ) => { const pathExists = BotHelpers . pathExistsInRecentBots ( 's' ) ; expect ( pathExists ) . toBe ( true ) ; } ) ; it ( `template` , async ( ) => { await BotHelpers . removeBotFromList ( 's' ) ; const newBotsList = [ { path : 's' , displayName : 's' , secret : 's' } , { path : 's' , displayName : 's' , secret : 's' } , { path : 's' , displayName : 's' , secret : 's' } , ] ; expect ( mockDispatch ) . toHaveBeenCalledWith ( load ( newBotsList ) ) ; } ) ; it ( 's' , ( ) => { const 0 = null ; expect ( BotHelpers . cloneBot ( 0 ) ) . toBe ( null ) ; const 0 = BotConfigWithPathImpl . fromJSON ( { version : 's' , name : 's' , description : 's' , padlock : 's' , services : [ ] , path : 's' , overrides : null , } ) ; expect ( BotHelpers . cloneBot ( 0 ) ) . toEqual ( 0 ) ; } ) ; it ( 's' , ( ) => { const 0 = null ; expect ( ( ) => BotHelpers . toSavableBot ( 0 ) ) . toThrowError ( 's' ) ; const 0 = BotConfigWithPathImpl . fromJSON ( { version : 's' , name : 's' , description : 's' , services : [ ] , path : 's' , overrides : null , } ) ; const secret = 's' ; const savableBot = BotHelpers . toSavableBot ( 0 , secret ) ; const expectedBot = new BotConfiguration ( ) ; expectedBot . name = 's' ; expectedBot . description = 's' ; expectedBot . services = [ ] ; expect ( savableBot . name ) . toEqual ( expectedBot . name ) ; expect ( savableBot . description ) . toEqual ( expectedBot . description ) ; expect ( savableBot . services ) . toEqual ( expectedBot . services ) ; expect ( savableBot . padlock ) . not . toEqual ( secret ) ; } ) ; it ( 's' , async ( ) => { commandService . remoteCall = jest . fn ( ) . mockImplementationOnce ( ( ) => Promise . resolve ( null ) ) . mockImplementation ( ( ) => Promise . resolve ( 's' ) ) ; expect ( await BotHelpers . promptForSecretAndRetry ( 's' ) ) . toBe ( null ) ; try { await BotHelpers . promptForSecretAndRetry ( 's' ) ; } catch ( e ) { expect ( e . code ) . toBe ( 's' ) ; } } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const mockSave = jest . fn ( ) . mockResolvedValueOnce ( true ) ; const mockValidateSecret = jest . fn ( ( ) => null ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValueOnce ( { save : mockSave , validateSecret : mockValidateSecret } ) ; const result = await BotHelpers . saveBot ( { path : 's' } as any , 's' ) ; expect ( result ) . toBe ( true ) ; expect ( mockValidateSecret ) . toHaveBeenCalledWith ( 's' ) ; expect ( mockSave ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const mockSave = jest . fn ( ) . mockResolvedValueOnce ( true ) ; const mockValidateSecret = jest . fn ( ( ) => null ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValueOnce ( { save : mockSave , validateSecret : mockValidateSecret } ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( 's' ) ; const result = await BotHelpers . saveBot ( { path : 's' } as any , undefined ) ; expect ( result ) . toBe ( true ) ; expect ( mockValidateSecret ) . toHaveBeenCalledWith ( 's' ) ; expect ( mockSave ) . toHaveBeenCalledWith ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const botConfigLoadSpy = jest . spyOn ( BotConfiguration , 's' ) . mockResolvedValueOnce ( { path : 's' , name : 's' } ) ; const getPasswordSpy = jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( 's' ) ; const setPasswordSpy = jest . spyOn ( CredentialManager , 's' ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValueOnce ( false ) ; const patchBotsSpy = jest . spyOn ( BotHelpers , 's' ) . mockResolvedValueOnce ( true ) ; const result = await BotHelpers . loadBotWithRetry ( 's' , 's' ) ; expect ( botConfigLoadSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( patchBotsSpy ) . toHaveBeenCalledWith ( 's' , { path : 's' , displayName : 's' } ) ; expect ( getPasswordSpy ) . toHaveBeenCalledWith ( 's' ) ; expect ( setPasswordSpy ) . not . toHaveBeenCalled ( ) ; expect ( result ) . toEqual ( { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ ] , version : 's' , } ) ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( BotConfiguration , 's' ) . mockResolvedValueOnce ( { path : 's' , name : 's' } ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( undefined ) ; const setPasswordSpy = jest . spyOn ( CredentialManager , 's' ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValueOnce ( false ) ; jest . spyOn ( BotHelpers , 's' ) . mockResolvedValueOnce ( true ) ; const result = await BotHelpers . loadBotWithRetry ( 's' , 's' ) ; expect ( setPasswordSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( result ) . toEqual ( { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ ] , version : 's' , } ) ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( BotConfiguration , 's' ) . mockResolvedValueOnce ( { path : 's' , name : 's' } ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( 's' ) ; const setPasswordSpy = jest . spyOn ( CredentialManager , 's' ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValueOnce ( false ) ; jest . spyOn ( BotHelpers , 's' ) . mockResolvedValueOnce ( true ) ; const result = await BotHelpers . loadBotWithRetry ( 's' , 's' ) ; expect ( setPasswordSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( result ) . toEqual ( { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ ] , version : 's' , } ) ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( BotConfiguration , 's' ) . mockRejectedValueOnce ( new Error ( 's' ) ) . mockResolvedValueOnce ( { path : 's' } ) ; const loadBotWithRetrySpy = jest . spyOn ( BotHelpers , 's' ) ; jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( true ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValue ( 's' ) ; const result = await BotHelpers . loadBotWithRetry ( 's' , 's' ) ; expect ( result ) . toEqual ( { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ ] , version : 's' , } ) ; expect ( loadBotWithRetrySpy ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( BotConfiguration , 's' ) . mockRejectedValueOnce ( new Error ( 's' ) ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValue ( undefined ) ; const promptForSecretSpy = jest . spyOn ( BotHelpers , 's' ) . mockResolvedValueOnce ( null ) ; const result = await BotHelpers . loadBotWithRetry ( 's' , undefined ) ; expect ( result ) . toBe ( null ) ; expect ( promptForSecretSpy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { try { jest . spyOn ( BotConfiguration , 's' ) . mockRejectedValue ( new Error ( 's' ) ) ; await BotHelpers . loadBotWithRetry ( 's' , undefined ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const result = BotHelpers . getTranscriptsPath ( { path : 's' } as any , { mode : 's' } as any ) ; expect ( result ) . toBe ( normalize ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const result = BotHelpers . getTranscriptsPath ( { path : 's' } as any , { mode : 's' } as any ) ; expect ( result ) . toBe ( normalize ( 's' ) ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BotAction<LoadBotPayload>$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $action$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O O $boolean$ O $any$ O $boolean$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $Promise<void>$ O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $BotAction<LoadBotPayload>$ O $complex$ O O O O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $BotConfigWithPath$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $BotConfigWithPath$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O O O $any$ O O O O O O O $any$ O $Promise<any>$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $any$ O $Promise<void>$ O O $string$ O O O O O O O O O $any$ O $void$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O O $any$ O $Promise<void>$ O O $string$ O O O O O O $undefined$ O O $any$ O $void$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $ErrorConstructor$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $Promise<any>$ O O O $undefined$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $ErrorConstructor$ O O O O O O $any$ O $Promise<any>$ O O O $undefined$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O $any$ O $string$ O O $string$ O O O O O O O $string$ O O O O O O O $any$ O $string$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $string$ O $any$ O $string$ O O $string$ O O O O O O O $string$ O O O O O O O $any$ O $string$ O O $any$ O $any$ O O O O O O O O O O O O O O
import { SharedConstants } from 's' ; import { combineReducers , createStore } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { AzureAuthWorkflowService } from 's' ; import { azureLoggedInUserChanged } from 's' ; import { azureAuthSettings } from 's' ; import { AzureCommands } from 's' ; import { ElectronCommands } from 's' ; const mockStore = createStore ( combineReducers ( { azure : azureAuthSettings } ) ) ; const mockArmToken = 's' ; jest . mock ( 's' , ( ) => ( { AzureAuthWorkflowService : { retrieveAuthToken : function * ( ) { yield { access_token : mockArmToken } ; } , enterSignOutWorkflow : function * ( ) { yield true ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { } ) ) ; jest . mock ( 's' , ( ) => ( { store : { dispatch => mockStore . dispatch ( action ) , getState : ( ) => mockStore . getState ( ) , } , getStore : ( ) => mockStore , getSettings : ( ) => mockStore . getState ( ) , } ) ) ; jest . mock ( 's' , ( ) => ( { emulator : { framework : { serverUrl : 's' , } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { Menu : { getApplicationMenu : ( ) => ( { getMenuItemById : ( file ) => ( { } ) } ) , } , app : { getPath : ( ) => 's' , } , remote : { app : { getPath : ( ) => 's' , } , } , session : { defaultSession : { clearStorageData : ( options , cb ) => cb ( true ) , } , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let registry ; let commandService ; beforeAll ( ( ) => { new AzureCommands ( ) ; new ElectronCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; describe ( `template` , ( ) => { it ( 's' , async ( ) => { const result = await registry . getCommand ( SharedConstants . Commands . Azure . RetrieveArmToken ) ( ) ; expect ( result . access_token ) . toBe ( mockArmToken ) ; expect ( ( mockStore . getState ( ) as any ) . azure . signedInUser ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { AzureAuthWorkflowService . retrieveAuthToken = function * ( ) { yield false ; } as any ; const result = await registry . getCommand ( SharedConstants . Commands . Azure . RetrieveArmToken ) ( ) ; expect ( result ) . toBe ( false ) ; } ) ; } ) ; describe ( `template` , ( ) => { it ( 's' , async ( ) => { mockStore . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; expect ( ( mockStore . getState ( ) as any ) . azure . signedInUser ) . toBe ( 's' ) ; const result = await registry . getCommand ( SharedConstants . Commands . Azure . SignUserOutOfAzure ) ( ) ; expect ( result ) . toBe ( true ) ; expect ( ( mockStore . getState ( ) as any ) . azure . signedInUser ) . toBe ( 's' ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<string>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O O O $string$ O O O O O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $action$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O ${}$ O O $string$ O O O O O O O O O O O $complex$ O O $string$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O O $complex$ O O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $IterableIterator<any>$ O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O
import * as path from 's' ; import { SharedConstants } from 's' ; import { BotConfigWithPathImpl , CommandRegistry , CommandServiceImpl , CommandServiceInstance , } from 's' ; import { BotConfiguration } from 's' ; import { ServiceTypes } from 's' ; import { combineReducers , createStore } from 's' ; import * as BotActions from 's' ; import { setActive } from 's' ; import { bot } from 's' ; import { RootState , store } from 's' ; import { BotHelpers } from 's' ; import { Emulator } from 's' ; import { botProjectFileWatcher , chatWatcher , transcriptsWatcher } from 's' ; import { TelemetryService } from 's' ; import { CredentialManager } from 's' ; import { BotCommands } from 's' ; const mockBotConfig = BotConfiguration ; let mockStore ; ( store as any ) . getStore = function ( ) { return mockStore || ( mockStore = createStore ( combineReducers ( { bot } ) ) ) ; } ; const mockBot = BotConfigWithPathImpl . fromJSON ( { path : path . normalize ( 's' ) , name : 's' , description : 's' , padlock : 's' , services : [ { appId : 's' , id : 's' , type : 's' , appPassword : 's' , endpoint : 's' , name : 's' , } , ] , } as any ) ; jest . mock ( 's' , ( ) => ( { BotHelpers : { saveBot : async ( ) => void 0 , toSavableBot : ( ) => mockBotConfig . fromJSON ( mockBot ) , patchBotsJson : async ( ) => true , pathExistsInRecentBots : ( ) => true , getBotInfoByPath : ( ) => ( { secret : 's' } ) , loadBotWithRetry : ( ) => mockBot , getActiveBot : ( ) => mockBot , removeBotFromList : async ( ) => true , } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; const mockEmulator = { framework : { server : { botEmulator : { facilities : { endpoints : { reset : ( ) => null , push : ( ) => null , } , } , } , } , } , } ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => mockEmulator , } , } ) ) ; jest . mock ( 's' , ( ) => ( { mainWindow : { commandService : { call : async ( ) => true , remoteCall : async ( ) => true , } , } , emulatorApplication : { mainBrowserWindow : { webContents : { send : ( ) => null , } , } , } , } ) ) ; const mockOn = { on : ( ) => mockOn , close : ( ) => void 0 } ; jest . mock ( 's' , ( ) => ( { watch : ( ) => ( { on : ( ) => mockOn , } ) , } ) ) ; const { Bot } = SharedConstants . Commands ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let registry ; let commandService ; beforeAll ( ( ) => { new BotCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = ( ) => Promise . resolve ( true ) as any ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockTrackEvent = jest . fn ( ( ) => Promise . resolve ( ) ) ; TelemetryService . trackEvent = mockTrackEvent ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; it ( 's' , async ( ) => { const botToSave = BotConfigWithPathImpl . fromJSON ( mockBot as any ) ; const patchBotInfoSpy = jest . spyOn ( BotHelpers , 's' ) ; const saveBotSpy = jest . spyOn ( BotHelpers , 's' ) ; const setPasswordSpy = jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( null ) ; const mockBotInfo = { path : path . normalize ( botToSave . path ) , displayName : 's' , chatsPath : path . normalize ( 's' ) , transcriptsPath : path . normalize ( 's' ) , } ; const command = registry . getCommand ( Bot . Create ) ; const result = await command ( botToSave , 's' ) ; expect ( patchBotInfoSpy ) . toHaveBeenCalledWith ( botToSave . path , mockBotInfo ) ; expect ( saveBotSpy ) . toHaveBeenCalledWith ( botToSave , 's' ) ; expect ( result ) . toEqual ( botToSave ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { path : mockBotInfo . path , hasSecret : true , } ) ; expect ( setPasswordSpy ) . toHaveBeenCalledWith ( mockBotInfo . path , 's' ) ; } ) ; it ( 's' , async ( ) => { const mockBotInfo = { secret : 's' , transcriptsPath : 's' , chatsPath : 's' , } ; const patchBotsJsonSpy = jest . spyOn ( BotHelpers , 's' ) ; const pathExistsInRecentBotsSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( true ) ; const getBotInfoByPathSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( mockBotInfo ) ; const loadBotWithRetrySpy = jest . spyOn ( BotHelpers , 's' ) . mockResolvedValue ( mockBot ) ; const command = registry . getCommand ( Bot . Open ) ; const botPath = path . normalize ( 's' ) ; const result = await command ( botPath , 's' ) ; expect ( pathExistsInRecentBotsSpy ) . toHaveBeenCalledWith ( botPath ) ; expect ( getBotInfoByPathSpy ) . toHaveBeenCalledWith ( botPath ) ; expect ( loadBotWithRetrySpy ) . toHaveBeenCalledWith ( botPath , 's' ) ; expect ( patchBotsJsonSpy ) . toHaveBeenCalledWith ( botPath , { secret : 's' , transcriptsPath : path . normalize ( 's' ) , chatsPath : path . normalize ( 's' ) , } ) ; expect ( result ) . toEqual ( mockBot ) ; expect ( mockBotInfo . transcriptsPath ) . toBe ( path . normalize ( 's' ) ) ; expect ( mockBotInfo . chatsPath ) . toBe ( path . normalize ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const botProjectFileWatcherSpy = jest . spyOn ( botProjectFileWatcher , 's' ) ; const commandServiceSpy = jest . spyOn ( commandService , 's' ) ; const command = registry . getCommand ( Bot . SetActive ) ; const result = await command ( mockBot ) ; expect ( botProjectFileWatcherSpy ) . toHaveBeenCalledWith ( mockBot . path ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( Bot . RestartEndpointService ) ; const state = store . getState ( ) ; expect ( state . bot . activeBot ) . toEqual ( mockBot ) ; expect ( state . bot . currentBotDirectory ) . toBe ( 's' ) ; expect ( result ) . toEqual ( 's' ) ; } ) ; it ( 's' , async ( ) => { const emulator = Emulator . getInstance ( ) ; store . dispatch ( setActive ( mockBot ) ) ; const resetSpy = jest . spyOn ( emulator . framework . server . botEmulator . facilities . endpoints , 's' ) ; const pushSpy = jest . spyOn ( emulator . framework . server . botEmulator . facilities . endpoints , 's' ) ; const command = registry . getCommand ( Bot . RestartEndpointService ) ; const result = await command ( ) ; expect ( resetSpy ) . toHaveBeenCalled ( ) ; expect ( pushSpy ) . toHaveBeenCalled ( ) ; expect ( result ) . toBeUndefined ( ) ; } ) ; it ( 's' , async ( ) => { const serviceToSave = mockBot . services [ 0 ] ; serviceToSave . name = 's' ; serviceToSave . id = 's' ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) ; const command = registry . getCommand ( Bot . AddOrUpdateService ) ; await command ( serviceToSave . type , serviceToSave ) ; const savedBot = mockBotConfig . fromJSON ( store . getState ( ) . bot . activeBot ) ; expect ( savedBot . services [ 0 ] ) . toEqual ( serviceToSave ) ; expect ( serviceToSave . id ) . not . toEqual ( 's' ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . SetActive , savedBot , savedBot . getPath ( ) ) ; } ) ; it ( 's' , async ( ) => { const serviceToUpdate = mockBot . services [ 0 ] ; jest . spyOn ( store , 's' ) . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) ; const handler = registry . getCommand ( Bot . AddOrUpdateService ) ; let threw = false ; try { await handler ( serviceToUpdate . type , serviceToUpdate ) ; } catch ( e ) { threw = true ; } jest . restoreAllMocks ( ) ; expect ( threw ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { const serviceToSave = JSON . parse ( JSON . stringify ( mockBot . services [ 0 ] ) ) ; serviceToSave . id = null ; serviceToSave . type = ServiceTypes . AppInsights ; const handler = registry . getCommand ( Bot . AddOrUpdateService ) ; let threw = false ; try { await handler ( ServiceTypes . Luis , serviceToSave ) ; } catch ( e ) { threw = true ; expect ( e . message ) . toEqual ( 's' ) ; } expect ( threw ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { const serviceToRemove = mockBot . services [ 0 ] ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) ; const handler = registry . getCommand ( Bot . RemoveService ) ; await handler ( serviceToRemove . type , serviceToRemove . id ) ; const savedBot = mockBotConfig . fromJSON ( store . getState ( ) . bot . activeBot ) ; expect ( savedBot . services . length ) . toBe ( 0 ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Bot . SetActive , savedBot , savedBot . getPath ( ) ) ; } ) ; it ( 's' , async ( ) => { const serviceToRemove = mockBot . services [ 0 ] ; jest . spyOn ( store , 's' ) . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) ; const handler = registry . getCommand ( Bot . RemoveService ) ; let threw = false ; try { await handler ( serviceToRemove . type , serviceToRemove . id ) ; } catch ( e ) { threw = true ; } jest . restoreAllMocks ( ) ; expect ( threw ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { const mockBotInfo = { path : path . normalize ( 's' ) , displayName : 's' , secret : 's' , } ; const transcriptWatchSpy = jest . spyOn ( transcriptsWatcher , 's' ) ; const chatWatcherSpy = jest . spyOn ( chatWatcher , 's' ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . PatchBotList ) ; await handler ( mockBotInfo . path , mockBotInfo ) ; expect ( transcriptWatchSpy ) . toHaveBeenCalledWith ( path . normalize ( 's' ) ) ; expect ( chatWatcherSpy ) . toHaveBeenCalledWith ( path . normalize ( 's' ) ) ; } ) ; it ( 's' , async ( ) => { const callSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const handler = registry . getCommand ( SharedConstants . Commands . Bot . RemoveFromBotList ) ; const removeBotFromListSpy = jest . spyOn ( BotHelpers , 's' ) . mockResolvedValue ( true ) ; await handler ( 's' ) ; expect ( callSpy ) . toHaveBeenCalledWith ( 's' , true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : 's' , type : 's' , } ) ; expect ( removeBotFromListSpy ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Bot . Close ) ; const dispatchSpy = jest . spyOn ( store , 's' ) ; await handler ( ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( BotActions . close ( ) ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $BotAction<SetActivePayload>$ O O O O O O $BotState$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BotProjectFileWatcher$ O $ChatWatcher$ O $TranscriptsWatcher$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $BotState$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $Promise<any>$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $Promise<boolean>$ O O O O O O O $boolean$ O O O O O O $complex$ O O O O O O $string$ O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $Promise<boolean>$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $Promise<boolean>$ O O O O O O O $Promise<boolean>$ O O O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $any$ O O O O O O O O O O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $complex$ O O O O $complex$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $void$ O $any$ O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $complex$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O O $any$ O $complex$ O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $BotProjectFileWatcher$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $RootState$ O $any$ O $any$ O O O $any$ O $RootState$ O $BotState$ O $any$ O O $any$ O $any$ O O $any$ O $RootState$ O $BotState$ O $string$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Emulator$ O $any$ O $Emulator$ O O O $any$ O $any$ O $BotAction<SetActivePayload>$ O $any$ O O O O $any$ O $any$ O $any$ O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $Emulator$ O $BotFrameworkService$ O $RestServer$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O O $any$ O $any$ O O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O O $any$ O $any$ O O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $TranscriptsWatcher$ O O O O O $any$ O $any$ O $any$ O $ChatWatcher$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $complex$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $BotAction<{}>$ O O O O O O O O O O
import { SettingsImpl , SharedConstants } from 's' ; import { BotConfigWithPathImpl , CommandRegistry , CommandServiceImpl , CommandServiceInstance , } from 's' ; import { combineReducers , createStore } from 's' ; import { bot } from 's' ; import * as store from 's' ; import { azureAuthSettings , framework , savedBotUrls , windowState , users } from 's' ; import { ClientInitCommands } from 's' ; const mockSettingsStore = createStore ( combineReducers ( { settings : combineReducers ( { azure : azureAuthSettings , framework , savedBotUrls , windowState , users , } ) , } ) ) ; const mockSettingsImpl = SettingsImpl ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockSettingsStore ; } , getSettings : ( ) => new mockSettingsImpl ( mockSettingsStore . getState ( ) . settings ) , dispatch => mockSettingsStore . dispatch ( action ) , } ) ) ; jest . mock ( 's' , ( ) => ( { AppMenuBuilder : { } , } ) ) ; jest . mock ( 's' , ( ) => ( { emulator : { framework : { serverUrl : 's' , locale : 's' , server : { botEmulator : { facilities : { endpoints : { reset : ( ) => null , push : ( ) => null , } , } , } , } , } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { getGlobal : ( ) => ( { storagepath : 's' } ) , setGlobal : ( ) => void 0 , } ) ) ; jest . mock ( 's' , ( ) => ( { app : { getPath : ( ) => 's' , } , dialog : { showErrorBox : ( ) => void 0 , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { sync : ( ) => void 0 , } ) ) ; const mockReadFileSyncResponses = [ `template` , 's' ] ; jest . mock ( 's' , ( ) => ( { readFileSync => { if ( file . includes ( 's' ) ) { return 's' ; } if ( file . includes ( 's' ) ) { return `template` ; } return mockReadFileSyncResponses . shift ( ) ; } , } ) ) ; let mockStore ; ( store as any ) . getStore = function ( ) { return mockStore || ( mockStore = createStore ( combineReducers ( { bot } ) ) ) ; } ; describe ( 's' , ( ) => { let registry ; let commandService ; beforeAll ( ( ) => { new ClientInitCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; it ( 's' , async ( ) => { const command = registry . getCommand ( SharedConstants . Commands . ClientInit . Loaded ) ; const localCommandArgs = [ ] ; ( commandService as any ) . call = ( ... args ) => { localCommandArgs . push ( args ) ; } ; await command ( ) ; expect ( localCommandArgs ) . toEqual ( [ [ 's' ] , [ 's' , false ] ] ) ; } ) ; it ( 's' , async ( ) => { const mockBot = BotConfigWithPathImpl . fromJSON ( { path : 's' , name : 's' , description : 's' , padlock : 's' , services : [ { appId : 's' , id : 's' , type : 's' , appPassword : 's' , endpoint : 's' , name : 's' , } , ] , } as any ) ; process . argv . push ( 's' ) ; process . argv . push ( 's' ) ; const dispatchSpy = jest . spyOn ( mockSettingsStore , 's' ) ; const remoteCommandArgs = [ ] ; const localCommandArgs = [ ] ; ( commandService as any ) . remoteCall = ( ... args ) => { remoteCommandArgs . push ( args ) ; } ; ( commandService as any ) . call = ( ... args : any [ ] ) => { localCommandArgs . push ( args ) ; if ( args [ 0 ] === SharedConstants . Commands . Bot . Open ) { return mockBot ; } return null ; } ; const command = registry . getCommand ( SharedConstants . Commands . ClientInit . PostWelcomeScreen ) ; await command ( ) ; expect ( localCommandArgs ) . toEqual ( [ [ 's' ] , [ 's' , 's' , undefined ] , [ 's' , { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ { appId : 's' , appPassword : 's' , endpoint : 's' , id : 's' , name : 's' , type : 's' , } , ] , version : 's' , } , ] , ] ) ; expect ( remoteCommandArgs ) . toEqual ( [ [ SharedConstants . Commands . UI . ShowDataCollectionDialog ] , [ 's' , 's' , 's' , { activities : [ ] , inMemory : true , } , ] , [ 's' , { description : 's' , name : 's' , overrides : null , padlock : 's' , path : 's' , services : [ { appId : 's' , appPassword : 's' , endpoint : 's' , id : 's' , name : 's' , type : 's' , } , ] , version : 's' , } , ] , ] ) ; expect ( dispatchSpy ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $BotState$ O O O O O O O $any$ O O O O O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $action$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $string$ O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O $complex$ O O $any$ O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O O O O $string[]$ O O O O O O O $any$ O $any$ O O O O O O O O $file$ O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O $string[]$ O $string$ O O O O O O O O O O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $BotState$ O O O O O O O $any$ O O O O O O O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O O O O O $any$ O O O O $any$ O O O $any[]$ O O O $any[]$ O $number$ O $any[]$ O O O O O $any$ O O O $any$ O $any[]$ O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O O O O $any$ O O O O $any$ O O O $any[]$ O O O $any[]$ O $number$ O $any[]$ O O O O O $any$ O O O O $any$ O O O $any[]$ O O O O O O O $any[]$ O $number$ O $any[]$ O O O O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any[]$ O O $any$ O O O O O O O O O O O $undefined$ O O O O O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O O O $any$ O $any[]$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $undefined[]$ O O O O $boolean$ O O O O O O O O O O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O
import { SharedConstants } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { ServiceTypes } from 's' ; import { ConnectedServiceCommands } from 's' ; const mockServiceTypes = ServiceTypes ; jest . mock ( 's' , ( ) => ( { LuisApi : { getServices : function * ( ) { yield { label : 's' , progress : 0 } ; return { services : [ { type : mockServiceTypes . Luis } ] } ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { QnaApiService : { getKnowledgeBases : function * ( ) { yield { label : 's' , progress : 0 } ; return { services : [ { type : mockServiceTypes . QnA } ] } ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { StorageAccountApiService : { getBlobStorageServices : function * ( ) { yield { label : 's' , progress : 0 } ; return { services : [ { type : mockServiceTypes . BlobStorage } ] } ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { mainWindow : { commandService : { call : async ( ) => true , remoteCall : async ( ) => true , } , browserWindow : { } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { getGlobal : ( ) => ( { storagepath : 's' } ) , setGlobal : ( ) => void 0 , } ) ) ; jest . mock ( 's' , ( ) => ( { app : { getPath : ( ) => 's' , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let registry ; let commandService ; beforeAll ( ( ) => { new ConnectedServiceCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = ( ) => Promise . resolve ( true ) as any ; registry = commandService . registry ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . ConnectedService . GetConnectedServicesByType ) ; const result = await handler ( 's' , mockServiceTypes . Luis ) ; expect ( result . services [ 0 ] . type ) . toBe ( mockServiceTypes . Luis ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . ConnectedService . GetConnectedServicesByType ) ; const result = await handler ( 's' , mockServiceTypes . QnA ) ; expect ( result . services [ 0 ] . type ) . toBe ( mockServiceTypes . QnA ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . ConnectedService . GetConnectedServicesByType ) ; const result = await handler ( 's' , mockServiceTypes . BlobStorage ) ; expect ( result . services [ 0 ] . type ) . toBe ( mockServiceTypes . BlobStorage ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . ConnectedService . GetConnectedServicesByType ) ; let error ; try { await handler ( 's' , mockServiceTypes . File ) ; } catch ( e ) { error = e ; } expect ( error . message ) . toBe ( `template` ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O O O $string$ O O O $number$ O O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O O O $string$ O O O $number$ O O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O O O $string$ O O O $number$ O O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $Promise<boolean>$ O O O O O O O $Promise<boolean>$ O O O O O O O O O ${}$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $string$ O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import 's' ; import { SharedConstants } from 's' ; import * as Electron from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { load } from 's' ; import { store } from 's' ; import { emulatorApplication } from 's' ; import { TelemetryService } from 's' ; import { AppUpdater } from 's' ; import { ElectronCommands } from 's' ; let renameArgs ; jest . mock ( 's' , ( ) => ( { stat : async ( ) => ( { isFile : ( ) => true } ) , statSync : ( ) => ( { isFile : ( ) => false } ) , pathExists : async ( path = 's' ) => ! path . includes ( 's' ) , rename : async ( ... args : any [ ] ) => ( renameArgs = args ) , } ) ) ; let mockOpenExternal ; jest . mock ( 's' , ( ) => ( { app : { getName : ( ) => 's' , setName : ( name ) => void 0 , getVersion : ( ) => 's' , } , Menu : { setApplicationMenu => void 0 , buildFromTemplate : ( ) => void 0 , } , dialog : { showMessageBox : ( mainBrowserWindow , p : { buttons : string [ ] ; type : string ; title : string ; message : string } ) => void 0 , showOpenDialog : ( ) => void 0 , showSaveDialog : ( ) => void 0 , } , shell : { get openExternal ( ) { return mockOpenExternal ; } , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const mockToggleDevTools = jest . fn ( ( ) => null ) ; jest . mock ( 's' , ( ) => ( { emulatorApplication : { mainWindow : { browserWindow : { setFullScreen : ( ) => void 0 , setTitle : ( _name = 's' ) => void 0 , } , } , mainBrowserWindow : { webContents : { send : ( ) => null , toggleDevTools : ( ) => mockToggleDevTools ( ) , } , } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { sync : ( ) => ( { } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; let mockRefreshFileMenu ; let mockUpdateRecentBotsList ; let mockInitAppMenu ; let mockSendActivityMenuItems ; let mockUpdateDebugModeViewMenuItem ; jest . mock ( 's' , ( ) => ( { get AppMenuBuilder ( ) { return class { static sendActivityMenuItems = mockSendActivityMenuItems ; static get initAppMenu ( ) { return mockInitAppMenu ; } static get refreshFileMenu ( ) { return mockRefreshFileMenu ; } static get updateRecentBotsList ( ) { return mockUpdateRecentBotsList ; } static get updateDebugModeViewMenuItem ( ) { return mockUpdateDebugModeViewMenuItem ; } } ; } , } ) ) ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let registry ; let commandService ; beforeAll ( ( ) => { new ElectronCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockTrackEvent = jest . fn ( ( ) => Promise . resolve ( ) ) ; TelemetryService . trackEvent = mockTrackEvent ; mockToggleDevTools . mockClear ( ) ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . ShowMessageBox ) ; const showMessageBoxSpy = jest . spyOn ( Electron . dialog , 's' ) ; await handler ( true , { } ) ; expect ( showMessageBoxSpy ) . toHaveBeenCalledWith ( emulatorApplication . mainWindow . browserWindow , { message : 's' , title : 's' , } ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . ShowOpenDialog ) ; const showOpenDialogSpy = jest . spyOn ( Electron . dialog , 's' ) ; await handler ( { } ) ; expect ( showOpenDialogSpy ) . toHaveBeenCalledWith ( emulatorApplication . mainWindow . browserWindow , { } ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . ShowSaveDialog ) ; const showSaveDialogSpy = jest . spyOn ( Electron . dialog , 's' ) ; await handler ( { } ) ; expect ( showSaveDialogSpy ) . toHaveBeenCalledWith ( emulatorApplication . mainWindow . browserWindow , { } ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . UpdateFileMenu ) ; const mockBotInfo = { path : 's' , displayName : 's' , secret : 's' , } ; store . dispatch ( load ( [ mockBotInfo ] ) ) ; mockRefreshFileMenu = jest . fn ( ( ) => null ) ; mockUpdateRecentBotsList = jest . fn ( ( ) => null ) ; await handler ( ) ; expect ( mockRefreshFileMenu ) . toHaveBeenCalled ( ) ; expect ( mockUpdateRecentBotsList ) . toHaveBeenCalledWith ( [ mockBotInfo ] ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . UpdateConversationMenu ) ; const mockEditorState = { activeEditor : 's' , editors : { primary : { activeDocumentId : 's' , documents : { someLiveChatDoc : { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_LIVE_CHAT , } , } , } , } , } ; mockSendActivityMenuItems = [ { label : 's' , enabled : false } , { label : 's' , enabled : false } , { label : 's' , enabled : false } , ] ; await handler ( mockEditorState ) ; expect ( mockSendActivityMenuItems . some ( item => ! item . enabled ) ) . toBe ( false ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . SetFullscreen ) ; const fullScreenSpy = jest . spyOn ( emulatorApplication . mainWindow . browserWindow , 's' ) ; const setApplicationMenuSpy = jest . spyOn ( Electron . Menu , 's' ) ; await handler ( true ) ; expect ( fullScreenSpy ) . toHaveBeenCalledWith ( true ) ; expect ( setApplicationMenuSpy ) . toHaveBeenCalledWith ( null ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . SetFullscreen ) ; const fullScreenSpy = jest . spyOn ( emulatorApplication . mainWindow . browserWindow , 's' ) ; mockInitAppMenu = jest . fn ( ( ) => null ) ; await handler ( false ) ; expect ( fullScreenSpy ) . toHaveBeenCalledWith ( false ) ; expect ( mockInitAppMenu ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . SetTitleBar ) ; let setTitleSpy = jest . spyOn ( emulatorApplication . mainWindow . browserWindow , 's' ) ; await handler ( ) ; expect ( setTitleSpy ) . toHaveBeenCalledWith ( Electron . app . getName ( ) ) ; setTitleSpy = jest . spyOn ( emulatorApplication . mainWindow . browserWindow , 's' ) ; await handler ( 's' ) ; expect ( setTitleSpy ) . toHaveBeenCalledWith ( `template` ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . RenameFile ) ; await handler ( { path : 's' , newPath : 's' } ) ; expect ( renameArgs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Electron . RenameFile ) ; let threw = false ; try { await handler ( { path : 's' , newPath : 's' } ) ; } catch ( error ) { expect ( error . message ) . toBe ( `template` ) ; threw = true ; } expect ( threw ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { mockOpenExternal = jest . fn ( ( ) => null ) ; const handler = registry . getCommand ( SharedConstants . Commands . Electron . OpenExternal ) ; const url = 's' ; await handler ( url ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { url } ) ; expect ( mockOpenExternal ) . toHaveBeenCalledWith ( url , { activate : true } ) ; } ) ; it ( 's' , ( ) => { registry . getCommand ( SharedConstants . Commands . Electron . ToggleDevTools ) ( ) ; expect ( mockToggleDevTools ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const quitAndInstallSpy = jest . spyOn ( AppUpdater , 's' ) . mockReturnValue ( ) ; registry . getCommand ( SharedConstants . Commands . Electron . QuitAndInstall ) ( ) ; expect ( quitAndInstallSpy ) . toHaveBeenCalled ( ) ; quitAndInstallSpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const checkForUpdatesSpy = jest . spyOn ( AppUpdater , 's' ) . mockReturnValue ( null ) ; registry . getCommand ( SharedConstants . Commands . Electron . CheckForUpdates ) ( ) ; expect ( checkForUpdatesSpy ) . toHaveBeenCalledWith ( true ) ; checkForUpdatesSpy . mockClear ( ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $BotAction<LoadBotPayload>$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O O $any$ O O O O O O $EmulatorUpdater$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O O O O O O $boolean$ O O O O O O O O $complex$ O O O O O O $boolean$ O O O O O O O O $Promise<boolean>$ O O O $string$ O O O O O $string$ O $boolean$ O O O O $Promise<any[]>$ O O O O $any[]$ O O O O O O O $any$ O $any[]$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O $any$ O O $string$ O O O O O $string$ O O O O O O O O $complex$ O O $_a$ O O O O $any$ O O O O O O O O O $complex$ O O $any$ O O $any$ O $complex$ O O $string[]$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O O $any$ O O O O $any$ O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $any$ O O O O O O O $any$ O O $string$ O O O O O O O O O O O $complex$ O O $complex$ O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $BotAction<LoadBotPayload>$ O O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $complex$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O $string$ O O O $boolean$ O O O O O $string$ O O O $boolean$ O O O O O $string$ O O O $boolean$ O O O O O O O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O O $string$ O O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $boolean$ O O O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $any$ O $any$ O O $any$ O O O O $boolean$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $EmulatorUpdater$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O O O O
import 's' ; import { normalize as mockNormalize } from 's' ; import { combineReducers , createStore } from 's' ; import { BotConfigWithPathImpl , CommandRegistry , CommandServiceImpl , CommandServiceInstance , ConversationService , } from 's' ; import { BotConfiguration } from 's' ; import { newBot , newEndpoint , SharedConstants , ValueTypesMask } from 's' ; import { Conversation } from 's' ; import { store } from 's' ; import * as utils from 's' ; import { BotHelpers } from 's' ; import { bot } from 's' ; import * as BotActions from 's' ; import { TelemetryService } from 's' ; import { setCurrentUser } from 's' ; import { pushClientAwareSettings } from 's' ; import { azureLoggedInUserChanged } from 's' ; import { CredentialManager } from 's' ; import { EmulatorCommands } from 's' ; const mockBotConfig = BotConfiguration ; const mockConversationConstructor = Conversation ; let mockStore ; ( store as any ) . getStore = function ( ) { return mockStore || ( mockStore = createStore ( combineReducers ( { bot } ) ) ) ; } ; jest . mock ( 's' , ( ) => ( { getCurrentConversationId : ( ) => 's' , } ) ) ; jest . mock ( 's' , ( ) => ( { getLocalhostServiceUrl : ( ) => 's' , } ) ) ; jest . mock ( 's' , ( ) => ( { app : { getAppPath : ( ) => 's' } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; const mockOn = { on : ( ) => mockOn } ; jest . mock ( 's' , ( ) => ( { watch : ( ) => ( { on : ( ) => mockOn , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { stat : async ( ) => ( { isFile : ( ) => true } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { sync : ( ) => ( { } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { BotHelpers : { saveBot : async ( ) => void 0 , toSavableBot : ( ) => mockBotConfig . fromJSON ( mockBot ) , patchBotsJson : async ( ) => true , pathExistsInRecentBots : ( ) => true , getBotInfoByPath : ( ) => ( { secret : 's' } ) , loadBotWithRetry : ( ) => mockBot , getActiveBot : ( ) => mockBot , getTranscriptsPath : ( ) => mockNormalize ( 's' ) , } , } ) ) ; jest . mock ( 's' , ( ) => ( { parseActivitiesFromChatFile : ( ) => [ ] , showSaveDialog : async ( ) => 's' , writeFile : async ( ) => true , loadSettings : ( ) => ( { windowState : { } } ) , getThemes : async ( ) => [ ] , readFileSync : ( ) => JSON . stringify ( ( mockConversation as any ) . transcript ) , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; let mockUsers ; const mockEmulator = { startup : ( ) => ( { } ) , framework : { server : { botEmulator : { facilities : { logger : { logActivity : ( ) => true , logMessage : ( ) => true , } , conversations : { conversationById : ( ) => mockConversation , newConversation : ( ... args : any [ ] ) => new mockConversationConstructor ( args [ 0 ] , args [ 0 ] , args [ 0 ] , args [ 0 ] , 's' ) , deleteConversation : ( ) => true , } , endpoints : { reset : ( ) => null , push : ( ) => null , } , get users ( ) { return mockUsers ; } , set users ( users ) { mockUsers = users ; } , } , getServiceUrl : ( ) => 's' , } , } , } , ngrok : { getServiceUrl : ( ) => 's' , } , } ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => mockEmulator , } , } ) ) ; let mockCallsMade = [ ] ; jest . mock ( 's' , ( ) => ( { emulatorApplication : { mainWindow : { commandService : { call : async ( commandName , ... args ) => { mockCallsMade . push ( { commandName , args } ) ; return Promise . resolve ( true ) ; } , remoteCall : async ( ) => true , } , browserWindow : { } , } , mainBrowserWindow : { webContents : { send : ( ) => null , } , } , } , } ) ) ; const mockBot = BotConfigWithPathImpl . fromJSON ( { path : 's' , name : 's' , description : 's' , padlock : 's' , services : [ { appId : 's' , id : 's' , type : 's' , appPassword : 's' , endpoint : 's' , name : 's' , } , ] , } as any ) ; const mockInfo = { path : mockNormalize ( 's' ) , displayName : 's' , transcriptsPath : mockNormalize ( 's' ) , chatsPath : mockNormalize ( 's' ) , } ; const mockConversation = mockEmulator . framework . server . botEmulator . facilities . conversations . newConversation ( mockEmulator . framework . server . botEmulator , null , { id : 's' , name : 's' } , 's' ) ; ( mockConversation as any ) . transcript = [ { type : 's' , activity : { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , serviceUrl : 's' , } , } , { type : 's' , activity : { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , serviceUrl : 's' , } , } , { type : 's' , activity : { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , } , { type : 's' , activity : { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , } , { type : 's' , activity : { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , attachments : [ { contentType : 's' , content : { type : 's' , horizontalAlignment : 's' , separator : true , height : 's' , body : [ { type : 's' , horizontalAlignment : 's' , spacing : 's' , height : 's' , columns : [ { type : 's' , spacing : 's' , items : [ { type : 's' , size : 's' , weight : 's' , text : 's' , } , { type : 's' , size : 's' , text : "s" , wrap : true , } , ] , } , { type : 's' , spacing : 's' , items : [ { type : 's' , horizontalAlignment : 's' , url : 's' , size : 's' , } , ] , width : 's' , } , ] , } , ] , actions : [ { type : 's' , title : 's' , data : { intent : 's' , } , } , { type : 's' , title : 's' , data : { intent : 's' , } , } , ] , $schema : 's' , version : 's' , } , } , ] , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , } , ] ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let registry ; let commandService ; beforeAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; new EmulatorCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockUsers = { users : { } } ; mockTrackEvent = jest . fn ( ( ) => Promise . resolve ( ) ) ; TelemetryService . trackEvent = mockTrackEvent ; mockCallsMade = [ ] ; } ) ; it ( 's' , async ( ) => { const getActiveBotSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( mockBot ) ; const conversationByIdSpy = jest . spyOn ( mockEmulator . framework . server . botEmulator . facilities . conversations , 's' ) . mockReturnValue ( mockConversation ) ; const showSaveDialogSpy = jest . spyOn ( ( utils as any ) . default , 's' ) . mockReturnValue ( 's' ) ; const getBotInfoByPathSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( mockInfo ) ; const toSavableBotSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( { save : async ( ) => ( { } ) } ) ; const patchBotJsonSpy = jest . spyOn ( BotHelpers , 's' ) . mockResolvedValue ( true ) ; const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( true ) ; jest . spyOn ( CredentialManager , 's' ) . mockResolvedValueOnce ( undefined ) ; const command = registry . getCommand ( SharedConstants . Commands . Emulator . SaveTranscriptToFile ) ; await command ( ValueTypesMask . Activity , 's' ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( 's' ) ; expect ( getActiveBotSpy ) . toHaveBeenCalled ( ) ; expect ( conversationByIdSpy ) . toHaveBeenCalledWith ( 's' ) ; expect ( showSaveDialogSpy ) . toHaveBeenCalledWith ( { } , { filters : [ { name : 's' , extensions : [ 's' ] , } , ] , defaultPath : mockNormalize ( 's' ) , showsTagField : false , title : 's' , buttonLabel : 's' , } ) ; const newPath = mockNormalize ( 's' ) ; expect ( getBotInfoByPathSpy ) . toHaveBeenCalledWith ( 's' ) ; expect ( toSavableBotSpy ) . toHaveBeenCalledWith ( mockBot , undefined ) ; expect ( patchBotJsonSpy ) . toHaveBeenCalledWith ( newPath , Object . assign ( { } , mockInfo , { path : newPath } ) ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) ; const command = registry . getCommand ( SharedConstants . Commands . Emulator . FeedTranscriptFromDisk ) ; const result = await command ( 's' , 's' , 's' , 's' ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . FeedTranscriptFromMemory , 's' , 's' , 's' , ( mockConversation as any ) . transcript ) ; expect ( result ) . toEqual ( { fileName : 's' , filePath : 's' , } ) ; } ) ; it ( 's' , async ( ) => { const feedActivitiesSpy = jest . spyOn ( mockConversation , 's' ) ; const activities = await mockConversation . getTranscript ( ) ; const id = 's' ; registry . getCommand ( SharedConstants . Commands . Emulator . FeedTranscriptFromMemory ) ( 's' , id , 's' , activities ) ; expect ( feedActivitiesSpy ) . toHaveBeenCalledWith ( activities ) ; } ) ; it ( 's' , async ( ) => { const getActiveBotSpy = jest . spyOn ( BotHelpers , 's' ) . mockReturnValue ( null ) ; const dispatchSpy = jest . spyOn ( store , 's' ) ; const command = registry . getCommand ( SharedConstants . Commands . Emulator . NewTranscript ) ; const conversation = await command ( 's' ) ; const newbot = newBot ( ) ; newbot . services . push ( newEndpoint ( ) ) ; ( newbot . services [ 0 ] as any ) . id = jasmine . any ( String ) ; expect ( getActiveBotSpy ) . toHaveBeenCalled ( ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( BotActions . mockAndSetActive ( newbot ) ) ; expect ( conversation ) . not . toBeNull ( ) ; } ) ; it ( 's' , async ( ) => { const dispatchSpy = jest . spyOn ( store , 's' ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SetCurrentUser ) ( 's' ) ; expect ( mockUsers . currentUserId ) . toBe ( 's' ) ; expect ( mockUsers . users . 0 ) . toEqual ( { id : 's' , name : 's' , } ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( setCurrentUser ( { id : 's' , name : 's' } ) ) ; expect ( dispatchSpy ) . toHaveBeenCalledWith ( pushClientAwareSettings ( ) ) ; } ) ; it ( 's' , ( ) => { const deleteSpy = jest . spyOn ( mockEmulator . framework . server . botEmulator . facilities . conversations , 's' ) ; registry . getCommand ( SharedConstants . Commands . Emulator . DeleteConversation ) ( 's' ) ; expect ( deleteSpy ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const result = await registry . getCommand ( SharedConstants . Commands . Emulator . OpenChatFile ) ( 's' ) ; expect ( result ) . toEqual ( { activities : [ ] , fileName : 's' } ) ; } ) ; it ( 's' , async ( ) => { mockConversation . botEndpoint = { fetchWithAuth : async ( ) => ( { status : 0 , } ) , } as any ; const postActivitySpy = jest . spyOn ( mockConversation , 's' ) ; const activity = { type : 's' , text : 's' , id : 's' } ; const result = await registry . getCommand ( SharedConstants . Commands . Emulator . PostActivityToConversation ) ( mockConversation . conversationId , activity , false ) ; expect ( result . activityId ) . toBe ( 's' ) ; expect ( result . statusCode ) . toBe ( 0 ) ; expect ( postActivitySpy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockConversation . botEndpoint = { fetchWithAuth : async ( ) => ( { status : 0 , } ) , } as any ; const postActivitySpy = jest . spyOn ( mockConversation , 's' ) ; const activity = { type : 's' , text : 's' , id : 's' , from : { } } ; const result = await registry . getCommand ( SharedConstants . Commands . Emulator . PostActivityToConversation ) ( mockConversation . conversationId , activity , true ) ; expect ( result . id ) . toBe ( 's' ) ; expect ( postActivitySpy ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; const signedInUser = store . getState ( ) . settings . azure . signedInUser ; const signedInMessage = signedInUser ? 's' : 's' ; expect ( signedInMessage ) . toBe ( 's' ) ; const callSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const result = await registry . getCommand ( SharedConstants . Commands . Emulator . ClearState ) ( ) ; expect ( result ) . toBe ( true ) ; expect ( callSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Electron . ShowMessageBox , true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : signedInMessage , type : 's' , } ) ; } ) ; it ( 's' , async ( ) => { store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; const signedInUser = store . getState ( ) . settings . azure . signedInUser ; const signedInMessage = signedInUser ? 's' : 's' ; expect ( signedInMessage ) . toBe ( 's' ) ; const callSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const result = await registry . getCommand ( SharedConstants . Commands . Emulator . ClearState ) ( ) ; expect ( result ) . toBe ( true ) ; expect ( callSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . Electron . ShowMessageBox , true , { buttons : [ 's' , 's' ] , cancelId : 0 , defaultId : 0 , message : signedInMessage , type : 's' , } ) ; } ) ; it ( 's' , async ( ) => { const addUserSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendConversationUpdateUserAdded ) ( ) ; expect ( addUserSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const addBotContactSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendBotContactAdded ) ( ) ; expect ( addBotContactSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const removeBotContactSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendBotContactRemoved ) ( ) ; expect ( removeBotContactSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const typingSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendTyping ) ( ) ; expect ( typingSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const pingSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendPing ) ( ) ; expect ( pingSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const deleteUserDataSpy = jest . spyOn ( ConversationService , 's' ) . mockImplementationOnce ( ( ) => null ) ; await registry . getCommand ( SharedConstants . Commands . Emulator . SendDeleteUserData ) ( ) ; expect ( deleteUserDataSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' ) ; } ) ; it ( 's' , async ( ) => { const url = await registry . getCommand ( SharedConstants . Commands . Emulator . GetServiceUrl ) ( ) ; expect ( url ) . toBe ( 's' ) ; } ) ; } ) ;	O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $BotState$ O O O O O O O $any$ O O O O O $any$ O O O O O O $UserAction<UserPayload>$ O O O O O O $FrameworkAction<void>$ O O O O O O $AzureAuthAction<string>$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $BotState$ O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $complex$ O O O O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $Promise<any>$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $Promise<boolean>$ O O O O O O O $boolean$ O O O O O O $complex$ O O O O O O $string$ O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $any[]$ O O O O O O O $Promise<string>$ O O O O O O O $Promise<boolean>$ O O O O O O O $complex$ O O O O O O ${}$ O O O O O O $Promise<any[]>$ O O O O O O O O $string$ O O O O $JSON$ O $complex$ O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O O $any$ O O $complex$ O O ${}$ O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O $boolean$ O O O O O O O O $complex$ O O $any$ O O O O $any$ O $any$ O O O $any[]$ O O O O O O O $any$ O $any[]$ O O O O $any[]$ O O O O $any[]$ O O O O $any[]$ O O O O O O O $boolean$ O O O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $Promise<boolean>$ O O O $any$ O O $any[]$ O O O $any[]$ O $number$ O O $any$ O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $Promise<boolean>$ O O O O O O O O O ${}$ O O O O O O $complex$ O O $complex$ O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O $any$ O $void$ O $void$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O ${}$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $void$ O $any$ O $any[]$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $Promise<{}>$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $complex$ O O O $string$ O O O $string[]$ O O O O O O O O O $any$ O $any$ O O O O $boolean$ O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O $any$ O $ObjectConstructor$ O O O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $BotAction<any>$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $UserAction<UserPayload>$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $FrameworkAction<void>$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O O O O O O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O O O O O O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O ${}$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { SharedConstants } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { addSavedBotUrl } from 's' ; import { SettingsCommands } from 's' ; let mockDispatch ; jest . mock ( 's' , ( ) => ( { get dispatch ( ) { return mockDispatch ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { const { Commands : { Settings } , } = SharedConstants ; let registry ; let commandService ; beforeAll ( ( ) => { new SettingsCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockDispatch = jest . fn ( ( ) => null ) ; } ) ; it ( 's' , ( ) => { const handler = registry . getCommand ( Settings . SaveBotUrl ) ; handler ( 's' ) ; expect ( mockDispatch ) . toHaveBeenCalledWith ( addSavedBotUrl ( 's' ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $SavedBotUrlsAction<string>$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O O O O $any$ O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $SavedBotUrlsAction<string>$ O O O O O O O O O O O
import { SharedConstants } from 's' ; import { CommandRegistry , CommandServiceImpl , CommandServiceInstance } from 's' ; import { TelemetryService } from 's' ; import { TelemetryCommands } from 's' ; jest . mock ( 's' , ( ) => ( { getSettings : ( ) => ( { framework : { } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let registry ; let commandService ; beforeAll ( ( ) => { new TelemetryCommands ( ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; registry = commandService . registry ; } ) ; beforeEach ( ( ) => { mockTrackEvent = jest . fn ( ( ) => Promise . resolve ( ) ) ; TelemetryService . trackEvent = mockTrackEvent ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; it ( 's' , async ( ) => { const handler = registry . getCommand ( SharedConstants . Commands . Telemetry . TrackEvent ) ; await handler ( 's' , { some : 's' } ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { some : 's' } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O ${}$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandRegistry$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $void$ O $any$ O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O O O O O O
import keytar from 's' ; import { CredentialManager } from 's' ; describe ( 's' , ( ) => { const getPasswordSpy = jest . spyOn ( keytar , 's' ) ; const setPasswordSpy = jest . spyOn ( keytar , 's' ) ; beforeEach ( ( ) => { getPasswordSpy . mockClear ( ) ; setPasswordSpy . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { getPasswordSpy . mockResolvedValueOnce ( 's' ) ; const pw = await CredentialManager . getPassword ( 's' ) ; expect ( pw ) . toBe ( 's' ) ; expect ( getPasswordSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; } ) ; it ( 's' , async ( ) => { setPasswordSpy . mockResolvedValueOnce ( true ) ; const result = await CredentialManager . setPassword ( 's' , 's' ) ; expect ( result ) . toBe ( true ) ; expect ( setPasswordSpy ) . toHaveBeenCalledWith ( 's' , 's' , 's' ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $string$ O O $any$ O $Promise<string>$ O O O O $any$ O $string$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $void$ O O $any$ O $Promise<void>$ O O O O O O $any$ O $void$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O
'js' const { ipcRenderer , remote } = require ( 's' ) ; ipcRenderer . on ( 's' , ( sender , obj ) => { window . host . dispatch ( 's' , obj ) ; } ) ; ipcRenderer . on ( 's' , ( sender , bot ) => { window . host . bot = bot ; window . host . dispatch ( 's' , bot ) ; } ) ; ipcRenderer . on ( 's' , ( sender , conversationId , logEntries ) => { window . host . dispatch ( 's' , conversationId , logEntries ) ; } ) ; ipcRenderer . on ( 's' , ( sender , highlightedObjects ) => { window . host . dispatch ( 's' , highlightedObjects ) ; } ) ; ipcRenderer . on ( 's' , ( ) => { remote . getCurrentWebContents ( ) . toggleDevTools ( ) ; } ) ; ipcRenderer . on ( 's' , ( sender , id , currentState ) => { window . host . dispatch ( 's' , id , currentState ) ; } ) ; ipcRenderer . on ( 's' , ( sender , ... args ) => { window . host . dispatch ( 's' , ... args ) ; } ) ; window . host = { bot : { } , handlers : new Proxy ( { } , { get ( target , p ) { if ( ! ( p in target ) ) { target [ p ] = [ ] ; } return target [ p ] ; } , } ) , logger : { error : function ( message ) { ipcRenderer . sendToHost ( 's' , message ) ; } , log : function ( message ) { ipcRenderer . sendToHost ( 's' , message ) ; } , logLuisEditorDeepLink : function ( message ) { ipcRenderer . sendToHost ( 's' , message ) ; } , } , on : function ( event , handler ) { if ( handler && Array . isArray ( this . handlers [ event ] ) && ! this . handlers [ event ] . includes ( handler ) ) { this . handlers [ event ] . push ( handler ) ; } return ( ) => { this . handlers [ event ] = this . handlers [ event ] . filter ( item => item !== handler ) ; } ; } , createAriaAlert : function ( msg ) { ipcRenderer . sendToHost ( 's' , msg ) ; } , enableAccessory : function ( id , enabled ) { if ( typeof id === 's' ) { ipcRenderer . sendToHost ( 's' , id , ! ! enabled ) ; } } , setAccessoryState : function ( id , state ) { if ( typeof id === 's' && typeof state === 's' ) { ipcRenderer . sendToHost ( 's' , id , state ) ; } } , setInspectorTitle : function ( title ) { if ( typeof title === 's' ) { ipcRenderer . sendToHost ( 's' , title ) ; } } , trackEvent : function ( name , properties ) { ipcRenderer . sendToHost ( 's' , name , properties ) ; } , setHighlightedObjects ( documentId , objects ) { ipcRenderer . sendToHost ( 's' , documentId , objects ) ; } , setInspectorObjects ( documentId , objects ) { ipcRenderer . sendToHost ( 's' , documentId , objects ) ; } , dispatch : function ( event , ... args ) { this . handlers [ event ] . forEach ( handler => handler ( ... args ) ) ; } , } ;	O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any[]$ O O O $complex$ O $any$ O $any$ O O O O $any[]$ O O O O O $complex$ O $any$ O O ${}$ O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O ${}$ O $complex$ O O O O O O $complex$ O ${}$ O O O ${}$ O $complex$ O O O O O O O ${}$ O $complex$ O O O O O O O $complex$ O O $void$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $ArrayConstructor$ O $complex$ O O O ${}$ O $any$ O O O O O O ${}$ O $any$ O O $any$ O $any$ O O O O O ${}$ O $any$ O O $any$ O $any$ O O O O O O O O O O ${}$ O $any$ O O O O ${}$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O $any$ O O O O O $void$ O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $string$ O $string$ O O O O O $void$ O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O O $void$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O O $any$ O O $any[]$ O O O O ${}$ O $any$ O O $any$ O $any$ O $any$ O O $any[]$ O O O O O O O
import 's' ; let mockFetchArgs : { input : RequestInfo ; init ? : any } ; jest . mock ( 's' , ( ) => { return async ( input , init ) => { mockFetchArgs = { input , init } ; return { ok : true , json : async ( ) => ( { } ) , text : async ( ) => 's' , } ; } ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { process . env . HTTPS_PROXY = 's' ; await fetch ( 's' ) ; expect ( mockFetchArgs . init . agent ) . not . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { process . env . HTTPS_PROXY = 's' ; process . env . NO_PROXY = 's' ; fetch ( 's' ) . catch ( ) ; expect ( mockFetchArgs . init ) . toBeUndefined ( ) ; } ) ; it ( 's' , ( ) => { delete process . env . HTTPS_PROXY ; delete process . env . NO_PROXY ; fetch ( 's' ) . catch ( ) ; expect ( mockFetchArgs . init ) . toBeUndefined ( ) ; } ) ; it ( 's' , async ( ) => { await fetch ( 's' ) ; expect ( mockFetchArgs . init . agent ) . not . toBeUndefined ( ) ; } ) ; it ( 's' , async ( ) => { await fetch ( 's' ) ; expect ( mockFetchArgs . init ) . toBeUndefined ( ) ; } ) ; } ) ;	O O O O $complex$ O O $RequestInfo$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O O O O $boolean$ O O O $Promise<{}>$ O O O O O O O O O O $Promise<string>$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $complex$ O O O O $complex$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O O $complex$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $complex$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $complex$ O O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O O O
import * as path from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { SharedConstants } from 's' ; import { systemPreferences } from 's' ; import { emulatorApplication } from 's' ; jest . mock ( 's' , ( ) => ( { app : { on : ( ) => void 0 , setName : ( ) => void 0 , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , systemPreferences : { isInvertedColorScheme : jest . fn ( ( ) => true ) , on : jest . fn ( ( ) => null ) , onInvertedColorSchemeChanged : jest . fn ( ( ) => true ) , } , } ) ) ; describe ( 's' , ( ) => { let commandService ; let emulatorAppSpy ; beforeEach ( ( ) => { emulatorAppSpy = jest . spyOn ( emulatorApplication as any , 's' ) ; const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; afterEach ( ( ) => { emulatorAppSpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const onSpy = jest . spyOn ( systemPreferences , 's' ) ; ( emulatorApplication as any ) . initializeSystemPreferencesListeners ( ) ; expect ( onSpy ) . toHaveBeenCalledWith ( 's' , jasmine . any ( Function ) ) ; onSpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) ; ( emulatorApplication as any ) . onInvertedColorSchemeChanged ( ) ; expect ( commandServiceSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . UI . SwitchTheme , 's' , path . join ( 's' , 's' , 's' ) ) ; commandServiceSpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) ; ( systemPreferences . isInvertedColorScheme as any ) . mockImplementationOnce ( ( ) => false ) ; ( emulatorApplication as any ) . onInvertedColorSchemeChanged ( ) ; expect ( commandServiceSpy ) . toBeCalledTimes ( 0 ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . UI . SwitchTheme , 's' , 's' ) ; commandServiceSpy . mockClear ( ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O O $any$ O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $EmulatorApplication$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $FunctionConstructor$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $EmulatorApplication$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $EmulatorApplication$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O
import * as Path from 's' ; import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { Migrator } from 's' ; interface MockCall { name : string ; args ? : any [ ] ; } let mockAppDataPath = Path . join ( 's' , 's' , 's' ) ; jest . mock ( 's' , ( ) => ( { app : { getPath : ( ) => mockAppDataPath , setName : ( ) => null , } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; let mockWillCallMkdirp ; let mockCalls : MockCall [ ] = [ ] ; let mockFailExists ; jest . mock ( 's' , ( ) => ( { pathExists : ( path ) => { mockCalls . push ( { name : 's' , args : [ path ] } ) ; if ( path . startsWith ( 's' ) && ! mockWillCallMkdirp ) { mockWillCallMkdirp = true ; return Promise . resolve ( false ) ; } if ( path . startsWith ( 's' ) || mockFailExists ) { return Promise . resolve ( false ) ; } return Promise . resolve ( true ) ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { getFilesInDir : ( ) => [ 's' , 's' , 's' ] , } ) ) ; jest . mock ( 's' , ( ) => ( { writeFile : ( path ) => { mockCalls . push ( { name : 's' , args : [ path ] } ) ; } , } ) ) ; let mockBotCounter ; jest . mock ( 's' , ( ) => ( { BotConfiguration : { load : ( path ) => { mockCalls . push ( { name : 's' , args : [ path ] } ) ; const bot = { name : `template` , } ; mockBotCounter ++ ; return bot ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { BotHelpers : { cloneBot => bot , saveBot => { mockCalls . push ( { name : 's' , args : [ bot ] } ) ; return Promise . resolve ( true ) ; } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; jest . mock ( 's' , ( ) => ( { sync => { mockCalls . push ( { name : 's' , args : [ path ] } ) ; } , } ) ) ; jest . mock ( 's' , ( ) => ( { store : { dispatch : ( ) => null , getState : ( ) => ( { bot : { botFiles : [ ] , } , } ) , } , } ) ) ; describe ( 's' , ( ) => { let tempLeaveMigrationMarker ; let tempMigrateBots ; let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . remoteCall = ( ... args : any [ ] ) => { mockCalls . push ( { name : 's' , args } ) ; return Promise . resolve ( true ) as any ; } ; commandService . call = ( ... args : any [ ] ) => { mockCalls . push ( { name : 's' , args } ) ; return Promise . resolve ( true ) as any ; } ; } ) ; beforeEach ( ( ) => { tempLeaveMigrationMarker = ( Migrator as any ) . leaveMigrationMarker ; tempMigrateBots = Migrator . migrateBots ; mockCalls = [ ] ; mockAppDataPath = Path . join ( 's' , 's' , 's' ) ; mockWillCallMkdirp = false ; mockBotCounter = 0 ; mockFailExists = false ; } ) ; afterEach ( ( ) => { ( Migrator as any ) . leaveMigrationMarker = tempLeaveMigrationMarker ; Migrator . migrateBots = tempMigrateBots ; } ) ; test ( 's' , async ( ) => { const mockMigrateBots = jest . fn ( ) . mockResolvedValueOnce ( false ) . mockResolvedValueOnce ( true ) ; Migrator . migrateBots = mockMigrateBots ; mockFailExists = true ; await Migrator . startup ( ) ; expect ( mockCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === Path . join ( 's' , 's' ) ) ) . not . toBe ( true ) ; await Migrator . startup ( ) ; expect ( mockCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === Path . join ( 's' , 's' ) ) ) . toBe ( true ) ; } ) ; test ( 's' , async ( ) => { mockAppDataPath = Path . join ( 's' , 's' , 's' ) ; const result = await Migrator . migrateBots ( ) ; expect ( result ) . toBe ( false ) ; expect ( mockCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === Path . join ( 's' , 's' , 's' , 's' ) ) ) . toBe ( true ) ; } ) ; test ( 's' , async ( ) => { const result = await Migrator . migrateBots ( ) ; expect ( mockCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === Path . join ( 's' , 's' ) ) ) . toBe ( true ) ; const 0 = Path . join ( 's' , 's' , 's' , 's' ) ; const mockLoadCalls = mockCalls . filter ( _call => _call . name === 's' ) ; expect ( mockLoadCalls ) . toHaveLength ( 0 ) ; expect ( mockLoadCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === Path . join ( 0 , 's' ) ) ) . toBe ( true ) ; const 0 = Path . join ( 's' , 's' ) ; const mockSaveCalls = mockCalls . filter ( _call => _call . name === 's' ) ; expect ( mockSaveCalls ) . toHaveLength ( 0 ) ; expect ( mockSaveCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] . path === Path . join ( 0 , 's' ) ) ) . toBe ( true ) ; const { ShowPostMigrationDialog } = SharedConstants . Commands . UI ; expect ( mockCalls . some ( _call => _call . name === 's' && _call . args [ 0 ] === ShowPostMigrationDialog ) ) . toBe ( true ) ; expect ( result ) . toBe ( true ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $string$ O O O $any[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O O $any$ O O $MockCall[]$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Promise<boolean>$ O O $string$ O O O $MockCall[]$ O $number$ O O $string$ O O O $string[]$ O O $string$ O O O O O O $string$ O $boolean$ O O O O O $any$ O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $string$ O $boolean$ O O O O $any$ O O O $PromiseConstructor$ O $complex$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $string[]$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $void$ O O $string$ O O O $MockCall[]$ O $number$ O O $string$ O O O $string[]$ O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $MockCall[]$ O $number$ O O $string$ O O O $string[]$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $any$ O O O $complex$ O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $bot$ O $any$ O $bot$ O O $MockCall[]$ O $number$ O O $string$ O O O $any[]$ O O $any$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $path$ O O $MockCall[]$ O $number$ O O $string$ O O O $any[]$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $any$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any[]$ O O O O O O O $MockCall[]$ O $number$ O O $string$ O O O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O $any[]$ O O O O O O O $MockCall[]$ O $number$ O O $string$ O O O $any[]$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O $any$ O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $Promise<boolean>$ O $MockCall[]$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $Promise<boolean>$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $Promise<boolean>$ O $any$ O $any$ O O O O $any$ O $Promise<void>$ O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O $any$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $boolean$ O O $any$ O $Promise<boolean>$ O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $MockCall[]$ O $MockCall[]$ O $complex$ O $MockCall$ O $MockCall$ O $string$ O O O O $any$ O $MockCall[]$ O O $any$ O O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $MockCall[]$ O $MockCall[]$ O $complex$ O $MockCall$ O $MockCall$ O $string$ O O O O $any$ O $MockCall[]$ O O $any$ O O O O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $MockCall[]$ O $boolean$ O $MockCall$ O $MockCall$ O $string$ O O O $MockCall$ O $any[]$ O O O O $any$ O O O $any$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O O
import { join } from 's' ; import 's' ; import { intervals , NgrokInstance } from 's' ; const mockSpawn = { on : ( ) => { } , stdin : { on : ( type , cb ) => void 0 } , stdout : { pause : ( ) => void 0 , on : ( type , cb ) => { if ( type === 's' ) { setTimeout ( ( ) => cb ( 's' ) ) ; } } , removeListener : ( ) => void 0 , } , stderr : { on : ( type , cb ) => void 0 , pause : ( ) => void 0 } , kill : ( ) => void 0 , } ; jest . mock ( 's' , ( ) => ( { spawn : ( ) => mockSpawn , } ) ) ; let mockOk = 0 ; jest . mock ( 's' , ( ) => { const mockJson = { name : 's' , uri : 's' , proto : 's' , } ; Object . defineProperty ( mockJson , 's' , { value : 's' , } ) ; return async ( input , init ) => { return { ok : ++ mockOk > 0 , json : async ( ) => mockJson , text : async ( ) => 's' , } ; } ; } ) ; const mockExistsSync = jest . fn ( ( ) => true ) ; jest . mock ( 's' , ( ) => ( { existsSync : ( ) => mockExistsSync ( ) , } ) ) ; describe ( 's' , ( ) => { const ngrok = new NgrokInstance ( ) ; afterEach ( ( ) => { ngrok . kill ( ) ; } ) ; it ( 's' , async ( ) => { const result = await ngrok . connect ( { addr : 0 , path : 's' , name : 's' , proto : 's' , } ) ; expect ( result ) . toEqual ( { inspectUrl : 's' , url : 's' , } ) ; } ) ; it ( 's' , async ( ) => { mockOk = - 0 ; await ngrok . connect ( { addr : 0 , path : 's' , name : 's' , proto : 's' , } ) ; expect ( mockOk ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { mockOk = 0 ; intervals . retry = 0 ; intervals . expirationPoll = 0 ; intervals . expirationTime = - 0 ; let emitted = false ; ngrok . ngrokEmitter . on ( 's' , ( ) => { emitted = true ; } ) ; await ngrok . connect ( { addr : 0 , path : 's' , name : 's' , proto : 's' , } ) ; await new Promise ( resolve => { setTimeout ( resolve , 0 ) ; } ) ; expect ( emitted ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { let disconnected = false ; ngrok . ngrokEmitter . on ( 's' , url => { disconnected = true ; } ) ; await ngrok . connect ( { addr : 0 , path : 's' , name : 's' , proto : 's' , } ) ; await ngrok . disconnect ( ) ; expect ( disconnected ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { mockOk = - 0 ; let threw = false ; intervals . retry = 0 ; try { await ngrok . connect ( { addr : 0 , path : 's' , name : 's' , proto : 's' , } ) ; } catch ( e ) { threw = e ; } expect ( threw . toString ( ) ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { mockExistsSync . mockReturnValueOnce ( false ) ; const path = join ( 's' , 's' ) ; let thrown ; try { await ngrok . connect ( { addr : 0 , path , name : 's' , proto : 's' , } ) ; } catch ( e ) { thrown = e ; } expect ( thrown . toString ( ) ) . toBe ( `template` ) ; } ) ; } ) ;	O O $any$ O O O O O O O O O $complex$ O $any$ O O O O O $complex$ O O $void$ O O O O O O O $complex$ O O $any$ O O $any$ O $any$ O O O O O O $complex$ O O $any$ O O O O O O O $void$ O O $any$ O $any$ O O O O O $any$ O O O O $number$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $complex$ O O O O O O $number$ O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $ObjectConstructor$ O $any$ O $complex$ O O O O $string$ O O O O O O O O O $any$ O $any$ O O O O O $boolean$ O O $number$ O O O $complex$ O O O O O $complex$ O $Promise<string>$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $NgrokInstance$ O O $any$ O O O $any$ O O O O O $NgrokInstance$ O $void$ O O O O O O $any$ O O O O O O O O O $complex$ O O $NgrokInstance$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $complex$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $number$ O O O O O $NgrokInstance$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O O O $complex$ O $number$ O O O $complex$ O $number$ O O O $complex$ O $number$ O O O O O $boolean$ O O O $NgrokInstance$ O $any$ O $any$ O O O O O O O $boolean$ O O O O O O O $NgrokInstance$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O O $PromiseConstructor$ O $void$ O O $number$ O $void$ O O O O O O O $any$ O $false$ O O $any$ O O O O O O O $any$ O O O O O O O O O $boolean$ O O O $NgrokInstance$ O $any$ O $any$ O O O $any$ O O $boolean$ O O O O O O O $NgrokInstance$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O $NgrokInstance$ O $Promise<void>$ O O O $any$ O $false$ O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O O O O O $boolean$ O O O $complex$ O $number$ O O O O O O $NgrokInstance$ O $complex$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O O O $any$ O O $boolean$ O $any$ O O $any$ O $boolean$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $NgrokInstance$ O $complex$ O O $number$ O O O $any$ O $string$ O O O O O O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { SettingsImpl } from 's' ; import { combineReducers , createStore } from 's' ; import { bot } from 's' ; import { Emulator } from 's' ; import { NgrokService } from 's' ; import { setFrameworkSettings } from 's' ; import { azureAuthSettings , framework , savedBotUrls , windowState , users } from 's' ; import { store } from 's' ; const mockEmulator = { framework : { serverUrl : 's' , locale : 's' , bypassNgrokLocalhost : true , serverPort : 0 , ngrokPath : 's' , server : { botEmulator : { facilities : { conversations : { getConversationIds : ( ) => [ 's' , 's' ] , } , endpoints : { reset : ( ) => null , push : ( ) => null , } , } , } , } , } , } ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => mockEmulator , } , } ) ) ; let mockSettingsStore ; const mockCreateStore = ( ) => createStore ( combineReducers ( { azure : azureAuthSettings , framework , savedBotUrls , windowState , users , } ) ) ; const mockSettingsImpl = SettingsImpl ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockSettingsStore || ( mockSettingsStore = mockCreateStore ( ) ) ; } , getSettings : function ( ) { return new mockSettingsImpl ( mockSettingsStore . getState ( ) ) ; } , get dispatch ( ) { return mockSettingsStore . dispatch ; } , } ) ) ; const mockCallsToLog = [ ] ; jest . mock ( 's' , ( ) => ( { emulatorApplication : { mainWindow : { logService : { logToChat : ( ... args : any [ ] ) => { mockCallsToLog . push ( { name : 's' , args } ) ; } , } , } , } , } ) ) ; const mockRunning = jest . fn ( ( ) => false ) ; const mockConnect = jest . fn ( ) . mockResolvedValue ( { url : 's' , inspectUrl : 's' } ) ; jest . mock ( 's' , ( ) => { return { NgrokInstance : jest . fn ( ) . mockImplementation ( ( ) => { return { running : ( ) => mockRunning ( ) , connect : mockConnect , kill : ( ) => true , } ; } ) , } ; } ) ; describe ( 's' , ( ) => { const ngrokService = new NgrokService ( ) ; beforeEach ( ( ) => { store . dispatch ( setFrameworkSettings ( Emulator . getInstance ( ) . framework as any ) ) ; mockCallsToLog . length = 0 ; mockRunning . mockClear ( ) ; mockConnect . mockClear ( ) ; } ) ; it ( 's' , ( ) => { expect ( ngrokService ) . toBe ( new NgrokService ( ) ) ; } ) ; it ( 's' , async ( ) => { const serviceUrl = await ngrokService . getServiceUrl ( 's' ) ; expect ( serviceUrl ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const serviceUrl = await ngrokService . getServiceUrl ( 's' ) ; expect ( serviceUrl ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { await ngrokService . getServiceUrl ( 's' ) ; ngrokService . broadcastNgrokReconnected ( ) ; expect ( mockCallsToLog . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { await ngrokService . getServiceUrl ( 's' ) ; await ngrokService . report ( 's' , 's' ) ; expect ( mockCallsToLog . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { ( ngrokService as any ) . ngrokPath = 's' ; await ngrokService . report ( 's' , 's' ) ; expect ( mockCallsToLog . length ) . toBe ( 0 ) ; expect ( mockCallsToLog [ 0 ] . args [ 0 ] . payload . text ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { ( ngrokService as any ) . serviceUrl = 's' ; ( ngrokService as any ) . pendingRecycle = new Promise ( resolve => resolve ( ) ) ; mockRunning . mockReturnValueOnce ( true ) ; const serviceUrl = await ngrokService . getServiceUrlForOAuth ( ) ; expect ( serviceUrl ) . toBe ( 's' ) ; ( ngrokService as any ) . serviceUrl = undefined ; ( ngrokService as any ) . pendingRecycle = null ; } ) ; it ( 's' , async ( ) => { mockRunning . mockReturnValueOnce ( false ) ; mockConnect . mockResolvedValueOnce ( { url : 's' } ) ; const serviceUrl = await ngrokService . getServiceUrlForOAuth ( ) ; expect ( serviceUrl ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { mockRunning . mockReturnValueOnce ( false ) ; mockConnect . mockRejectedValueOnce ( new Error ( 's' ) ) ; try { await ngrokService . getServiceUrlForOAuth ( ) ; expect ( false ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( `template` ) ) ; } } ) ; it ( 's' , ( ) => { const mockKill = jest . fn ( ( ) => null ) ; ( ngrokService as any ) . oauthNgrokInstance = { kill : mockKill } ; ngrokService . shutDownOAuthNgrokInstance ( ) ; expect ( mockKill ) . toHaveBeenCalled ( ) ; ( ngrokService as any ) . oauthNgrokInstance = undefined ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $BotState$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FrameworkAction<any>$ O O O O O O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O $any$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O $number$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $string[]$ O O O O O O O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any[]$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $void$ O O O $any[]$ O O O O O O O $any[]$ O $number$ O O $string$ O O O $any[]$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O O O O O $any$ O O O O O O O O $NgrokService$ O O $any$ O O O $any$ O O O O O $any$ O $any$ O $FrameworkAction<any>$ O $any$ O $Emulator$ O O O $BotFrameworkService$ O O O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $NgrokService$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O O $NgrokService$ O $Promise<string>$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O O $NgrokService$ O $Promise<string>$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $NgrokService$ O $Promise<string>$ O O O O $NgrokService$ O $void$ O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $NgrokService$ O $Promise<string>$ O O O O O $NgrokService$ O $Promise<void>$ O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $NgrokService$ O O O O $any$ O O O O $NgrokService$ O $Promise<void>$ O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $NgrokService$ O O O O $any$ O O O O $NgrokService$ O O O O $any$ O O $PromiseConstructor$ O $void$ O $void$ O O O O $any$ O $any$ O O O O O $string$ O O $NgrokService$ O $Promise<string>$ O O O $any$ O $string$ O O $any$ O O O O O $NgrokService$ O O O O $any$ O $undefined$ O O $NgrokService$ O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $string$ O O O O O O $string$ O O $NgrokService$ O $Promise<string>$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $ErrorConstructor$ O O O O O O O O $NgrokService$ O $Promise<string>$ O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $NgrokService$ O O O O $any$ O O $any$ O $any$ O O $NgrokService$ O $void$ O O O $any$ O $any$ O O $any$ O O O O $NgrokService$ O O O O $any$ O $undefined$ O O O O O O O
import got from 's' ; const getPem = require ( 's' ) ; export class OpenIdMetadata { private url : string ; private lastUpdated = 0 ; private keys : Key [ ] ; constructor ( url ) { this . url = url ; } public getKey ( keyId , cb : ( key ) => void ) { const now = new Date ( ) . getTime ( ) ; if ( this . lastUpdated < now - 0 * 0 * 0 * 0 * 0 ) { this . refreshCache ( err => { if ( err ) { } const key = this . findKey ( keyId ) ; cb ( key ) ; } ) ; } else { const key = this . findKey ( keyId ) ; cb ( key ) ; } } private refreshCache ( cb : ( err ) => void ) { const options = { method : 's' , url : this . url , json : true , strictSSL : false , useElectronNet : true , } ; got ( options ) . then ( resp => { if ( resp . statusCode >= 0 || ! resp . body ) { throw new Error ( 's' + resp . statusCode ) ; } const openIdConfig = resp . body as OpenIdConfig ; const 0 = { method : 's' , url : openIdConfig . jwks_uri , json : true , strictSSL : false , useElectronNet : true , } ; got ( 0 ) . then ( ( 0 ) => { if ( 0 . statusCode >= 0 || ! 0 . body ) { throw new Error ( 's' + 0 . statusCode ) ; } this . lastUpdated = new Date ( ) . getTime ( ) ; this . keys = 0 . body . keys as Key [ ] ; cb ( null ) ; } ) . catch ( err => { cb ( err ) ; } ) ; } ) . catch ( err => { cb ( err ) ; } ) ; } private findKey ( keyId ) { if ( ! this . keys ) { return null ; } for ( let i = 0 ; i < this . keys . length ; i ++ ) { if ( this . keys [ i ] . kid === keyId ) { const key = this . keys [ i ] ; if ( ! key . n || ! key . e ) { return null ; } const modulus = Buffer . from ( key . n ) . toString ( 's' ) ; const exponent = key . e ; return getPem ( modulus , exponent ) ; } } return null ; } } interface OpenIdConfig { issuer : string ; authorization_endpoint : string ; jwks_uri : string ; id_token_signing_alg_values_supported : string [ ] ; token_endpoint_auth_methods_supported : string [ ] ; } interface Key { kty : string ; use : string ; kid : string ; 0 : string ; n : string ; e : string ; 0 : string [ ] ; }	O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $string$ O O O O $number$ O O O O $Key[]$ O $any$ O O O O O $string$ O O O O $string$ O $string$ O O O $void$ O $string$ O $void$ O O $string$ O O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O $void$ O $Error$ O O O O $Error$ O O O O $string$ O O O $string$ O $string$ O O $void$ O $string$ O O O O O O O O O $string$ O O O $string$ O $string$ O O $void$ O $string$ O O O O O $void$ O $void$ O O $Error$ O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O $any$ O $any$ O O O O $OpenIdConfig$ O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O $OpenIdConfig$ O $string$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O $complex$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O $any$ O $any$ O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O $Key[]$ O $any$ O $any$ O $any$ O $any$ O O O $void$ O O O O O O O $any$ O $any$ O O $void$ O $any$ O O O O O O O O $any$ O $any$ O O $void$ O $any$ O O O O O O O $string$ O $string$ O O O O O O O $Key[]$ O O O O O O O O O $number$ O O O $number$ O O O $Key[]$ O $number$ O $number$ O O O O O O O $Key[]$ O $number$ O O $string$ O $string$ O O O $Key$ O O O $Key[]$ O $number$ O O O O O $Key$ O $string$ O O $Key$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $Key$ O $string$ O O $any$ O O O O O $string$ O $Key$ O $string$ O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O
import { SharedConstants } from 's' ; import { CommandServiceImpl , CommandServiceInstance , logEntry , LogLevel , textItem } from 's' ; import { LogService } from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; it ( 's' , ( ) => { Date . now = ( ) => 0 ; const mockRemoteCall = jest . spyOn ( commandService , 's' ) . mockResolvedValueOnce ( true ) ; const logService = new LogService ( ) ; const 0 = textItem ( LogLevel . Debug , 's' ) ; const 0 = textItem ( LogLevel . Info , 's' ) ; logService . logToChat ( 's' , 0 , 0 ) ; expect ( mockRemoteCall ) . toHaveBeenCalledWith ( SharedConstants . Commands . Emulator . AppendToLog , 's' , logEntry ( 0 , 0 ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $DateConstructor$ O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $LogService$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $LogService$ O $void$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O
import 's' ; import { SharedConstants } from 's' ; import { applyBotConfigOverrides } from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { parseEndpointOverrides , Protocol , ProtocolHandler } from 's' ; import { TelemetryService } from 's' ; let mockCallsMade , mockRemoteCallsMade ; let mockOpenedBot ; const mockSharedConstants = SharedConstants ; jest . mock ( 's' , ( ) => ( { mainWindow : { commandService : { call : ( commandName , ... args ) => { mockCallsMade . push ( { commandName , args } ) ; if ( commandName === mockSharedConstants . Commands . Bot . Open ) { return Promise . resolve ( mockOpenedBot ) ; } return null ; } , remoteCall : ( commandName , ... args ) => { mockRemoteCallsMade . push ( { commandName , args } ) ; } , } , } , } ) ) ; jest . mock ( 's' , ( ) => ( { getGlobal : ( ) => ( { } ) , setGlobal : ( ) => null , } ) ) ; let mockNgrokPath ; jest . mock ( 's' , ( ) => ( { getSettings : ( ) => ( { framework : { ngrokPath : mockNgrokPath , } , } ) , } ) ) ; let mockGetSpawnStatus = jest . fn ( ( ) => ( { triedToSpawn : true } ) ) ; let mockRunningStatus ; const mockRecycle = jest . fn ( ( ) => null ) ; const mockEmulator = { framework : { serverUrl : 's' } , ngrok : { getSpawnStatus : ( ) => mockGetSpawnStatus ( ) , ngrokEmitter : { once : ( _eventName , cb ) => cb ( ) , } , recycle : ( ) => mockRecycle ( ) , running : ( ) => mockRunningStatus , } , } ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => mockEmulator , } , } ) ) ; let mockSendNotificationToClient ; jest . mock ( 's' , ( ) => ( { sendNotificationToClient : ( ) => mockSendNotificationToClient ( ) , } ) ) ; let mockGotReturnValue ; jest . mock ( 's' , ( ) => { return jest . fn ( ( ) => Promise . resolve ( mockGotReturnValue ) ) ; } ) ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; commandService . call = ( commandName , ... args ) => { mockCallsMade . push ( { commandName , args } ) ; if ( commandName === mockSharedConstants . Commands . Bot . Open ) { return Promise . resolve ( mockOpenedBot ) ; } return null ; } ; commandService . remoteCall = ( commandName , ... args ) => { return Promise . resolve ( mockRemoteCallsMade . push ( { commandName , args } ) ) ; } ; } ) ; beforeEach ( ( ) => { mockTrackEvent = jest . fn ( ( ) => null ) ; TelemetryService . trackEvent = mockTrackEvent ; mockCallsMade = [ ] ; mockRemoteCallsMade = [ ] ; mockOpenedBot = { name : 's' , description : 's' , path : 's' , services : [ { appId : 's' , appPassword : 's' , endpoint : 's' , } , ] , } ; mockRunningStatus = true ; mockNgrokPath = 's' ; mockSendNotificationToClient = jest . fn ( ( ) => null ) ; mockGotReturnValue = { statusCode : 0 , body : 's' , } ; mockRecycle . mockClear ( ) ; mockGetSpawnStatus . mockClear ( ) ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const info = ProtocolHandler . parseProtocolUrl ( 's' ) ; expect ( info . domain ) . toBe ( 's' ) ; expect ( info . action ) . toBe ( 's' ) ; expect ( info . args ) . toEqual ( 's' ) ; expect ( info . parsedArgs ) . toEqual ( { path : 's' } ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => ProtocolHandler . parseProtocolUrl ( 's' ) ) . toThrow ( ) ; } ) ; } ) ; it ( 's' , ( ) => { const tmpParseProtocolUrl = ProtocolHandler . parseProtocolUrl ; const tmpDispatchProtocolAction = ProtocolHandler . dispatchProtocolAction ; const mockParseProtocolUrl = jest . fn ( ( ) => ( { } ) ) ; const mockDispatchProtocolAction = jest . fn ( ( ) => null ) ; ProtocolHandler . parseProtocolUrl = mockParseProtocolUrl ; ProtocolHandler . dispatchProtocolAction = mockDispatchProtocolAction ; ProtocolHandler . parseProtocolUrlAndDispatch ( 's' ) ; expect ( mockParseProtocolUrl ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockDispatchProtocolAction ) . toHaveBeenCalledTimes ( 0 ) ; ProtocolHandler . parseProtocolUrl = tmpParseProtocolUrl ; ProtocolHandler . dispatchProtocolAction = tmpDispatchProtocolAction ; } ) ; describe ( 's' , ( ) => { let tmpPerformBotAction ; let tmpPerformLiveChatAction ; let tmpPerformTranscriptAction ; let tmpPerformInspectorAction ; beforeEach ( ( ) => { tmpPerformBotAction = ProtocolHandler . performBotAction ; tmpPerformLiveChatAction = ProtocolHandler . performLiveChatAction ; tmpPerformTranscriptAction = ProtocolHandler . performTranscriptAction ; tmpPerformInspectorAction = ProtocolHandler . performInspectorAction ; } ) ; afterEach ( ( ) => { ProtocolHandler . performBotAction = tmpPerformBotAction ; ProtocolHandler . performLiveChatAction = tmpPerformLiveChatAction ; ProtocolHandler . performTranscriptAction = tmpPerformTranscriptAction ; ProtocolHandler . performInspectorAction = tmpPerformInspectorAction ; } ) ; it ( "s" , ( ) => { const mockPerformBotAction = jest . fn ( ( ) => null ) ; ProtocolHandler . performBotAction = mockPerformBotAction ; const mockPerformLiveChatAction = jest . fn ( ( ) => null ) ; ProtocolHandler . performLiveChatAction = mockPerformLiveChatAction ; const mockPerformTranscriptAction = jest . fn ( ( ) => null ) ; ProtocolHandler . performTranscriptAction = mockPerformTranscriptAction ; ProtocolHandler . dispatchProtocolAction ( { domain : 's' } ) ; expect ( mockPerformBotAction ) . not . toHaveBeenCalled ( ) ; expect ( mockPerformLiveChatAction ) . not . toHaveBeenCalled ( ) ; expect ( mockPerformTranscriptAction ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const mockPerformBotAction = jest . fn ( ( ) => null ) ; ProtocolHandler . performBotAction = mockPerformBotAction ; ProtocolHandler . dispatchProtocolAction ( { domain : 's' } ) ; expect ( mockPerformBotAction ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , ( ) => { const spy = jest . spyOn ( ProtocolHandler , 's' ) ; ProtocolHandler . parseProtocolUrlAndDispatch ( 's' ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . UI . OpenBotViaUrl ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ { endpoint : 's' , appId : 's' , appPassword : 's' , mode : 's' , } , ] ) ; expect ( spy ) . toHaveBeenCalledWith ( { action : 's' , args : 's' , domain : 's' , parsedArgs : { botUrl : 's' , msaAppId : 's' , msaAppPassword : 's' , } , } ) ; } ) ; it ( 's' , ( ) => { const spy = jest . spyOn ( ProtocolHandler , 's' ) ; ProtocolHandler . parseProtocolUrlAndDispatch ( 's' ) ; expect ( spy ) . toHaveBeenCalledWith ( { action : 's' , args : 's' , domain : 's' , parsedArgs : { url : 's' } , } ) ; } ) ; it ( 's' , ( ) => { const spy = jest . spyOn ( ProtocolHandler , 's' ) ; ProtocolHandler . parseProtocolUrlAndDispatch ( 's' ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . UI . OpenBotViaUrl ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ { appId : 's' , appPassword : 's' , channelService : 's' , endpoint : 's' , mode : 's' , } , ] ) ; expect ( spy ) . toHaveBeenCalledWith ( { action : 's' , args : 's' , domain : 's' , parsedArgs : { botUrl : 's' , cloud : 's' , msaAppId : 's' , msaAppPassword : 's' , } , } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const result = parseEndpointOverrides ( null ) ; expect ( result ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const result = parseEndpointOverrides ( { } ) ; expect ( result ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const parsedArgs = { appId : 's' , appPassword : 's' , endpoint : 's' , someOtherArg : 's' , } ; const overrides = parseEndpointOverrides ( parsedArgs ) ; expect ( Object . keys ( overrides ) . length ) . toBe ( 0 ) ; expect ( overrides . appId ) . toBe ( 's' ) ; expect ( overrides . appPassword ) . toBe ( 's' ) ; expect ( overrides . endpoint ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const parsedArgs = { notAnOverride : 's' , notAnOverrideEither : 's' , } ; const overrides = parseEndpointOverrides ( parsedArgs ) ; expect ( overrides ) . toBe ( null ) ; } ) ; } ) ; it ( 's' , async ( ) => { const protocol = { parsedArgs : { id : 's' , path : 's' , secret : 's' , } , } ; const overrides = { endpoint : parseEndpointOverrides ( protocol . parsedArgs ) } ; const overriddenBot = applyBotConfigOverrides ( mockOpenedBot , overrides ) ; mockGetSpawnStatus = jest . fn ( ( ) => ( { triedToSpawn : false } ) ) ; await ProtocolHandler . openBot ( protocol ) ; expect ( mockRecycle ) . toHaveBeenCalled ( ) ; expect ( mockCallsMade ) . toHaveLength ( 0 ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Open ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ 's' , 's' ] ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . SetActive ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Load ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { method : 's' , numOfServices : 0 , } ) ; } ) ; it ( 's' , async ( ) => { mockRunningStatus = false ; const protocol = { parsedArgs : { id : 's' , path : 's' , secret : 's' , } , } ; const overrides = { endpoint : parseEndpointOverrides ( protocol . parsedArgs ) } ; const overriddenBot = applyBotConfigOverrides ( mockOpenedBot , overrides ) ; await ProtocolHandler . openBot ( protocol ) ; expect ( mockCallsMade ) . toHaveLength ( 0 ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Open ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ 's' , 's' ] ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . SetActive ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Load ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { method : 's' , numOfServices : 0 , } ) ; } ) ; it ( 's' , async ( ) => { mockNgrokPath = undefined ; const protocol = { parsedArgs : { id : 's' , path : 's' , secret : 's' , } , } ; const overrides = { endpoint : parseEndpointOverrides ( protocol . parsedArgs ) } ; const overriddenBot = applyBotConfigOverrides ( mockOpenedBot , overrides ) ; await ProtocolHandler . openBot ( protocol ) ; expect ( mockCallsMade ) . toHaveLength ( 0 ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Open ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ 's' , 's' ] ) ; expect ( mockCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . SetActive ) ; expect ( mockCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Bot . Load ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ overriddenBot ] ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { method : 's' , numOfServices : 0 , } ) ; } ) ; it ( 's' , async ( ) => { try { const protocol = { parsedArgs : { id : 's' , path : 's' , secret : 's' , } , } ; mockGetSpawnStatus = jest . fn ( ( ) => ( { triedToSpawn : true , err : 's' } ) ) ; await ProtocolHandler . openBot ( protocol ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { try { const protocol = { parsedArgs : { botUrl : 's' , msaAppId : 's' , msaPassword : 's' , } , } ; mockGetSpawnStatus = jest . fn ( ( ) => ( { triedToSpawn : true , err : 's' } ) ) ; await ProtocolHandler . openBot ( protocol ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const protocol = { parsedArgs : { url : 's' } , } ; await ProtocolHandler . openTranscript ( protocol ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockRemoteCallsMade [ 0 ] . commandName ) . toBe ( SharedConstants . Commands . Emulator . OpenTranscript ) ; expect ( mockRemoteCallsMade [ 0 ] . args ) . toEqual ( [ 's' , { activities : [ 's' , 's' , 's' ] , inMemory : true , fileName : 's' , } , ] ) ; } ) ; it ( 's' , async ( ) => { const protocol = { parsedArgs : { url : 's' } , } ; mockGotReturnValue = { statusCode : 0 } ; await ProtocolHandler . openTranscript ( protocol ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockSendNotificationToClient ) . toHaveBeenCalledTimes ( 0 ) ; mockGotReturnValue = { statusCode : 0 } ; await ProtocolHandler . openTranscript ( protocol ) ; expect ( mockRemoteCallsMade ) . toHaveLength ( 0 ) ; expect ( mockSendNotificationToClient ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $ProtocolHandlerImpl$ O O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $Promise<any>$ O O $any$ O O $any[]$ O O O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O $complex$ O $any$ O O O O O O O O $void$ O O $any$ O O $any[]$ O O O $any$ O $any$ O O $any$ O $any[]$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $complex$ O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O $complex$ O O $any$ O O O O $any$ O O O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $any$ O $void$ O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any[]$ O O O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O $complex$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O $any[]$ O O O O $PromiseConstructor$ O $complex$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $void$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Protocol$ O $ProtocolHandlerImpl$ O $Protocol$ O O O O $any$ O $Protocol$ O $string$ O O $any$ O O O O $any$ O $Protocol$ O $string$ O O $any$ O O O O $any$ O $Protocol$ O $string$ O O $any$ O O O O $any$ O $Protocol$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O $ProtocolHandlerImpl$ O $Protocol$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $Protocol$ O $ProtocolHandlerImpl$ O $Protocol$ O O $void$ O $ProtocolHandlerImpl$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $ProtocolHandlerImpl$ O $Protocol$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $ProtocolHandlerImpl$ O $Protocol$ O $Protocol$ O $ProtocolHandlerImpl$ O $void$ O $void$ O O O O $any$ O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O O O O $any$ O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $ProtocolHandlerImpl$ O $void$ O $any$ O $ProtocolHandlerImpl$ O $void$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $ProtocolHandlerImpl$ O O O O $ProtocolHandlerImpl$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $ProtocolHandlerImpl$ O O O O $ProtocolHandlerImpl$ O $void$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $ProtocolHandlerImpl$ O O O O $ProtocolHandlerImpl$ O $void$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $complex$ O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O O $number$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O $any$ O $any$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O $ProtocolHandlerImpl$ O $Promise<void>$ O $complex$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O $any$ O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O $any$ O $any$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O $complex$ O O O $ProtocolHandlerImpl$ O $Promise<void>$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O $any$ O $undefined$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O $any$ O $any$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O $complex$ O O O $ProtocolHandlerImpl$ O $Promise<void>$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $string$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O $string$ O O O O O O O $ProtocolHandlerImpl$ O $Promise<void>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O $string$ O O O O O O O $ProtocolHandlerImpl$ O $Promise<void>$ O $complex$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O $ProtocolHandlerImpl$ O $void$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $string[]$ O O O O O O O O O $boolean$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O $any$ O O $number$ O O O O O $ProtocolHandlerImpl$ O $void$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O $number$ O O O O O $ProtocolHandlerImpl$ O $void$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { Emulator } from 's' ; import 's' ; import { emulatorApplication } from 's' ; import { RestServer } from 's' ; jest . mock ( 's' , ( ) => ( { emulatorApplication : { mainWindow : { logService : { logToChat : ( ) => void 0 , } , } , } , } ) ) ; const mockEmulator = { report ( ) { return null ; } , } ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => { return mockEmulator ; } , } , } ) ) ; describe ( 's' , ( ) => { let commandService ; let restServer ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; restServer = new RestServer ( ) ; } ) ; it ( 's' , ( ) => { const logSpy = jest . spyOn ( emulatorApplication . mainWindow . logService , 's' ) ; const mockReq = { method : 's' , conversation : { conversationId : 's' , } , params : { } , _body : { } , headers : { } , url : 's' , statusCode : 0 , statusMessage : 's' , } ; const mockRes = { statusCode : 0 , } ; const mockRoute = { spec : { path : 's' } , } ; ( restServer as any ) . onRouterAfter ( mockReq , mockRes , mockRoute ) ; expect ( logSpy ) . toHaveBeenCalledWith ( 's' , { payload : { body : { } , facility : 's' , headers : { } , method : 's' , url : 's' , } , type : 's' , } , { payload : { body : undefined , headers : undefined , srcUrl : 's' , statusCode : 0 , statusMessage : undefined , } , type : 's' , } , { payload : { level : 0 , text : 's' } , type : 's' } ) ; } ) ; it ( 's' , async ( ) => { const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const reportSpy = jest . spyOn ( Emulator . getInstance ( ) , 's' ) ; const mockConversation = { conversationId : 's' , botEndpoint : { id : 's' , url : 's' } , mode : 's' , } ; await ( restServer as any ) . onNewConversation ( mockConversation ) ; expect ( remoteCallSpy ) . toHaveBeenCalledWith ( 's' , { endpoint : undefined , id : 's' , } , false , 's' , 's' ) ; expect ( reportSpy ) . toHaveBeenCalledWith ( 's' , undefined ) ; remoteCallSpy . mockReset ( ) ; reportSpy . mockReset ( ) ; } ) ; it ( 's' , async ( ) => { const remoteCallSpy = jest . spyOn ( commandService , 's' ) . mockResolvedValue ( true ) ; const reportSpy = jest . spyOn ( Emulator . getInstance ( ) , 's' ) ; const mockConversation = { conversationId : 's' , botEndpoint : { id : 's' , url : 's' } , } ; await ( restServer as any ) . onNewConversation ( mockConversation ) ; expect ( remoteCallSpy ) . not . toHaveBeenCalled ( ) ; expect ( reportSpy ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { const result = await restServer . listen ( ) ; expect ( result ) . toEqual ( { url : jasmine . any ( String ) , port : jasmine . any ( Number ) , } ) ; } ) ; it ( 's' , async ( ) => { const result = await restServer . close ( ) ; expect ( result ) . toBeUndefined ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $EmulatorApplication$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $any$ O O O O O O O O O O O O O O O O O O $complex$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $EmulatorApplication$ O $Window$ O $any$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O $string$ O O O $number$ O O O $string$ O O O O O O $complex$ O O $number$ O O O O O O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O O O O $any$ O $complex$ O $complex$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $complex$ O O ${}$ O O O O $string$ O O O ${}$ O O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $string$ O O O $number$ O O O $undefined$ O $undefined$ O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $Emulator$ O O O O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $string$ O O O O O O O $any$ O O O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O O O $undefined$ O $undefined$ O $string$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $undefined$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $Emulator$ O O O O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O O O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $any$ O $any$ O $NumberConstructor$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O
import { BrowserWindow } from 's' ; import 's' ; import { AzureAuthWorkflowService } from 's' ; const mockEvent = Event ; const mockArmToken = 's' + 's' + 's' ; jest . mock ( 's' , ( ) => ( { verify : ( ) => true , } ) ) ; let mockResponses ; jest . mock ( 's' , ( ) => { const fetch = ( url , opts ) => { return { ok : true , json : async ( ) => mockResponses . pop ( ) , text : async ( ) => 's' , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ; jest . mock ( 's' , ( ) => ( ) => ( { } ) ) ; jest . mock ( 's' , ( ) => ( { BrowserWindow : class MockBrowserWindow { public static reporters = [ ] ; public listeners = [ ] as any ; public webContents = { history : [ 's' , `template` ] , } ; private static report ( ... args : any [ ] ) { this . reporters . forEach ( r => r ( args ) ) ; } constructor ( ... args : any [ ] ) { MockBrowserWindow . report ( 's' , ... args ) ; } setMenu ( ) { } addListener ( type , handler : ( ) => void ) { this . listeners . push ( { type , handler } ) ; MockBrowserWindow . report ( 's' , type , handler ) ; if ( type === 's' ) { [ [ 's' ] , [ `template` ] ] . forEach ( ( url , index ) => { const evt = new mockEvent ( 's' ) ; ( evt as any ) . sender = { history : [ `template` ] , } ; setTimeout ( ( ) => { this . listeners . forEach ( l => l . type === evt . type && l . handler ( evt ) ) ; } , 0 * index ) ; } ) ; } } once ( type , handler : ( ) => void ) { this . listeners . push ( { type , handler } ) ; MockBrowserWindow . report ( 's' , type , handler ) ; } dispatch ( event ) { this . listeners . forEach ( l => l . type === event . type && l . handler ( event ) ) ; MockBrowserWindow . report ( 's' , event ) ; } show ( ) { MockBrowserWindow . report ( 's' ) ; } close ( ) { MockBrowserWindow . report ( 's' ) ; } loadURL ( url ) { MockBrowserWindow . report ( 's' , url ) ; const evt = new mockEvent ( 's' ) ; setTimeout ( ( ) => { this . listeners . forEach ( l => l . type === evt . type && l . handler ( evt ) ) ; } ) ; } } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockResponses = [ { access_token : mockArmToken } , { jwks_uri : 's' , keys : { find : ( ) => ( { } ) } } , { authorization_endpoint : 's' , jwks_uri : 's' , token_endpoint : 's' , } , ] ; ( BrowserWindow as any ) . reporters = [ ] ; } ) ; it ( 's' , async ( ) => { const reportedValues = [ ] ; const reporter = v => reportedValues . push ( v ) ; ( BrowserWindow as any ) . reporters . push ( reporter ) ; const it = AzureAuthWorkflowService . retrieveAuthToken ( false ) ; let value = undefined ; let ct = 0 ; while ( true ) { const next = it . next ( value ) ; if ( next . done ) { break ; } value = await next . value ; if ( ! ct ) { expect ( value instanceof BrowserWindow ) . toBe ( true ) ; expect ( reportedValues . length ) . toBe ( 0 ) ; const [ , uri ] = reportedValues [ 0 ] ; const idx = uri . indexOf ( 's' ) ; const parts = uri . substring ( idx ) . split ( 's' ) ; [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] . forEach ( ( part , index ) => { expect ( parts [ index ] . includes ( part ) ) ; } ) ; reportedValues . length = 0 ; } if ( ct === 0 ) { expect ( value . access_token ) . toBe ( mockArmToken ) ; expect ( reportedValues . length ) . toBe ( 0 ) ; } if ( ct === 0 ) { expect ( value ) . toBe ( true ) ; } if ( ct === 0 ) { expect ( value . arm_token ) . toBe ( mockArmToken ) ; } ct ++ ; } expect ( ct ) . toBe ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O O O O $any$ O O O O O $complex$ O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $boolean$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O O O O O $boolean$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<string>$ O O O O O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O $any[]$ O O O O O $any$ O O O O O O O $complex$ O O $string[]$ O O O O O O O O O O O $void$ O O $any[]$ O O O O O O O O $any[]$ O $void$ O $any$ O $any$ O $any[]$ O O O O O O O $any[]$ O O O O O O $any$ O $void$ O O O O $any[]$ O O O $void$ O O O O $void$ O $string$ O $void$ O O O O O O O O O $any$ O $any$ O O $string$ O $void$ O O O $any$ O $void$ O O O $string$ O $void$ O O O O $string$ O O O O O O O O O O O O O O $void$ O O $string[]$ O $number$ O O O O $Event$ O O $complex$ O O O O O $Event$ O O O O $any$ O O $string[]$ O O O O O O O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Event$ O $string$ O $any$ O $any$ O $Event$ O O O O O O O $number$ O O O O O O O $void$ O $string$ O $void$ O O O O O O O O O $any$ O $any$ O O $string$ O $void$ O O O $any$ O $void$ O O O $string$ O $void$ O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $void$ O O O $any$ O O O $void$ O O O $any$ O $void$ O O O O O $void$ O O O $any$ O $void$ O O O O O $void$ O $string$ O O $any$ O $void$ O O O $string$ O O O $Event$ O O $complex$ O O O O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Event$ O $string$ O $any$ O $any$ O $Event$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O $string$ O $string$ O O O $string$ O O O $complex$ O O ${}$ O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any[]$ O O O O O $number$ O $any$ O $any[]$ O $number$ O $any$ O O O $any$ O O O O $any$ O $any$ O $number$ O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O $undefined$ O O $number$ O O O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O O O O $any$ O O $complex$ O $any$ O O O O $number$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $string$ O $number$ O O O $any$ O $any$ O $number$ O O $any$ O $string$ O O O O O O $any[]$ O $number$ O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O $number$ O O O $any$ O $number$ O O $any$ O O O O O O O O O O
import { MenuItemConstructorOptions } from 's' ; import { ContextMenuService } from 's' ; jest . mock ( 's' , ( ) => ( { Menu : class { public static buildFromTemplate ( ... args : any [ ] ) { return { popup : ( ) => void 0 , } ; } } , MenuItemConstructorOptions : class { } , } ) ) ; describe ( 's' , ( ) => { beforeAll ( ( ) => { ( ContextMenuService as any ) . currentMenu = { closePopup : ( ) => void 0 } ; } ) ; it ( 's' , async ( ) => { const options = { } ; let resolved = false ; const closePopupSpy = jest . spyOn ( ( ContextMenuService as any ) . currentMenu , 's' ) ; ContextMenuService . showMenuAndWaitForInput ( [ options ] ) . then ( ( ) => { resolved = true ; } ) ; expect ( closePopupSpy ) . toHaveBeenCalled ( ) ; expect ( options . click ) . not . toBeNull ( ) ; await options . click ( { } as any , null , null ) ; expect ( resolved ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O $complex$ O O $any[]$ O O O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $MenuItemConstructorOptions$ O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O $Promise<any>$ O O $any$ O O O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $false$ O O $any$ O O O O O O O O O
import 's' ; import { CosmosDbApiService } from 's' ; const mockArmToken = 's' ; const mockArgsPassedToFetch = [ ] ; let mockResponses ; jest . mock ( 's' , ( ) => { const fetch = ( url , headers ) => { mockArgsPassedToFetch . push ( { url , headers } ) ; return { ok : true , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ; const mockResponseTemplate = [ { value : [ { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , ] , } , { value : [ { id : 's' , name : 's' , location : 's' , type : 's' , kind : 's' , tags : { defaultExperience : 's' } , properties : { provisioningState : 's' , documentEndpoint : 's' , tableEndpoint : 's' , } , } , ] , } , { value : [ { id : 's' , name : 's' , location : 's' , type : 's' , kind : 's' , tags : { defaultExperience : 's' } , properties : { provisioningState : 's' , documentEndpoint : 's' , tableEndpoint : 's' , } , } , ] , } , { primaryMasterKey : 's' , } , { primaryMasterKey : 's' , } , { Databases : [ { id : 's' , _colls : 's' , _etag : 's' , _rid : 's' , _self : 's' , _ts : 0 , _users : 's' , } , ] , } , { Databases : [ { id : 's' , _colls : 's' , _etag : 's' , _rid : 's' , _self : 's' , _ts : 0 , _users : 's' , } , ] , } , { DocumentCollections : [ { id : 's' , } , ] , } , { DocumentCollections : [ { id : 's' , } , ] , } , ] ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockResponses = JSON . parse ( JSON . stringify ( mockResponseTemplate ) ) ; mockArgsPassedToFetch . length = 0 ; } ) ; it ( 's' , async ( ) => { const result = await getResult ( ) ; expect ( result . services . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { mockResponses = [ { value : [ ] } ] ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { mockResponses [ 0 ] = mockResponses [ 0 ] = { value : [ ] } ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { mockResponses [ 0 ] = mockResponses [ 0 ] = { primaryMasterKey : 's' } ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; } ) ; async function getResult ( ) { const it = CosmosDbApiService . getCosmosDbServices ( mockArmToken ) ; let result = undefined ; while ( true ) { const next = it . next ( result ) ; if ( next . done ) { result = next . value ; break ; } try { result = await next . value ; } catch ( e ) { break ; } } return result ; }	O O O O O $any$ O O O O O O O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O O O O O $boolean$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O O $complex$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O $complex$ O O O $any[]$ O $number$ O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O $undefined[]$ O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $undefined[]$ O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $string$ O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O O O O O O $Promise<any>$ O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O $undefined$ O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O $any$ O $IteratorReturnResult<any>$ O $any$ O O O O O O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O O $any$ O O
import 's' ; import { LuisApi } from 's' ; const mockArmToken = 's' ; const mockResponses = [ 's' , { error : { statusCode : 0 , message : 's' } } , { error : { statusCode : 0 , message : 's' } } , [ { id : 's' , name : 's' , description : 's' , culture : 's' , usageScenario : 's' , domain : 's' , versionsCount : 0 , createdDateTime : 's' , endpoints : { PRODUCTION : { versionId : 's' , isStaging : false , endpointUrl : 's' , region : null , assignedEndpointKey : null , endpointRegion : 's' , publishedDateTime : 's' , } , } , endpointHitsCount : 0 , activeVersion : 's' , ownerEmail : 's' , } , ] , { services : [ { authoringKey : 's' , appId : 's' , id : 's' , name : 's' , subscriptionKey : 's' , type : 's' , version : 's' , } , ] , } , ] ; let mockArgsPassedToFetch ; jest . mock ( 's' , ( ) => { const fetch = ( url , headers ) => { mockArgsPassedToFetch . push ( { url , headers } ) ; return { ok : true , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ; describe ( 's' , ( ) => { let result = undefined ; beforeEach ( async ( ) => { mockArgsPassedToFetch = [ ] ; const it = LuisApi . getServices ( mockArmToken ) ; result = undefined ; while ( true ) { const next = it . next ( result ) ; if ( next . done ) { result = next . value ; break ; } try { result = await next . value ; } catch ( e ) { break ; } } } ) ; it ( 's' , async ( ) => { expect ( result . services . length ) . toBe ( 0 ) ; expect ( mockArgsPassedToFetch . length ) . toBe ( 0 ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { Authorization : 's' , } , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : jasmine . any ( Object ) , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : jasmine . any ( Object ) , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : jasmine . any ( Object ) , } ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $boolean$ O O O $string$ O O O $null$ O O O $null$ O O O $string$ O O O $string$ O O O O O O O $number$ O O O $string$ O O O $string$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $undefined$ O $any$ O O O O O O $any$ O O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O $any$ O $undefined$ O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O $any$ O $IteratorReturnResult<any>$ O $any$ O O O O O O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O O O O O O O O O
import 's' ; import { QnaApiService } from 's' ; const mockArmToken = 's' ; const mockResponsesTemplate = [ { value : [ { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , ] , } , { value : [ { id : 's' , name : 's' , type : 's' , etag : "s" , location : 's' , sku : { name : 's' , } , kind : 's' , properties : { endpoint : 's' , internalId : 's' , dateCreated : 's' , apiProperties : { qnaRuntimeEndpoint : 's' , } , provisioningState : 's' , } , } , ] , } , { value : [ { id : 's' , name : 's' , type : 's' , etag : "s" , location : 's' , sku : { name : 's' , } , kind : 's' , properties : { endpoint : 's' , internalId : 's' , dateCreated : 's' , apiProperties : { qnaRuntimeEndpoint : 's' , } , provisioningState : 's' , } , } , ] , } , { 0 : 0 } , { 0 : 0 } , { primaryEndpointKey : 's' , secondaryEndpointKey : 's' , } , { knowledgebases : [ { id : 's' , hostName : 's' , lastAccessedTimestamp : 's' , lastChangedTimestamp : 's' , name : 's' , userId : 's' , urls : [ 's' ] , sources : [ ] , } , ] , } , { primaryEndpointKey : 's' , secondaryEndpointKey : 's' , } , { knowledgebases : [ { id : 's' , hostName : 's' , lastAccessedTimestamp : 's' , lastChangedTimestamp : 's' , name : 's' , userId : 's' , urls : [ 's' ] , sources : [ ] , } , ] , } , ] ; const mockArgsPassedToFetch = [ ] ; let mockResponses ; ( global as any ) . fetch = jest . fn ( ) ; ( fetch as any ) . mockImplementation ( ( url , headers ) => { mockArgsPassedToFetch . push ( { url , headers } ) ; return { ok : true , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ) ; describe ( 's' , ( ) => { let result ; beforeAll ( ( ) => ( mockResponses = JSON . parse ( JSON . stringify ( mockResponsesTemplate ) ) ) ) ; beforeEach ( async ( ) => { mockArgsPassedToFetch . length = 0 ; result = await getResult ( ) ; } ) ; it ( 's' , async ( ) => { expect ( result . services . length ) . toBe ( 0 ) ; expect ( mockArgsPassedToFetch . length ) . toBe ( 0 ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { headers : { headers : { 's' : jasmine . any ( String ) , Accept : 's' , Authorization : 's' , } , } , url : 's' , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { headers : { headers : { 's' : jasmine . any ( String ) , Accept : 's' , Authorization : 's' , } , } , url : 's' + 's' , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { headers : { headers : { 's' : jasmine . any ( String ) , Accept : 's' , Authorization : 's' , } , } , url : 's' + 's' , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : jasmine . any ( String ) , Authorization : 's' , Accept : 's' , } , method : 's' , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : jasmine . any ( String ) , Authorization : 's' , Accept : 's' , } , method : 's' , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : 0 , 's' : 's' , } , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : 0 , 's' : 's' , } , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : 0 , 's' : 's' , } , } , } ) ; expect ( mockArgsPassedToFetch [ 0 ] ) . toEqual ( { url : 's' , headers : { headers : { 's' : 0 , 's' : 's' , } , } , } ) ; expect ( result . services ) . toEqual ( [ { endpointKey : 's' , hostname : 's' , id : 's' , kbId : 's' , name : 's' , subscriptionKey : 0 , type : 's' , } , { endpointKey : 's' , hostname : 's' , id : 's' , kbId : 's' , name : 's' , subscriptionKey : 0 , type : 's' , } , ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockResponses = JSON . parse ( JSON . stringify ( mockResponsesTemplate ) ) ; } ) ; it ( 's' , async ( ) => { mockResponses = [ { value : [ ] } , { value : [ ] } ] ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { mockResponses [ 0 ] = mockResponses [ 0 ] = { value : [ ] } ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { mockResponses [ 0 ] = mockResponses [ 0 ] = { value : [ ] } ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { ( fetch as any ) . mockImplementation ( url => { let ok = true ; if ( url . includes ( 's' ) ) { ok = false ; mockResponses . shift ( ) ; } return { ok , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ) ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { ( fetch as any ) . mockImplementation ( url => { let ok = true ; if ( url . includes ( 's' ) ) { ok = false ; mockResponses . shift ( ) ; } return { ok , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ) ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; } ) ; async function getResult ( ) { const it = QnaApiService . getKnowledgeBases ( mockArmToken ) ; let result = undefined ; while ( true ) { const next = it . next ( result ) ; if ( next . done ) { result = next . value ; break ; } try { result = await next . value ; } catch ( e ) { break ; } } return result ; }	O O O O O $any$ O O O O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O O O O O O O O O O $number$ O O O O O $number$ O O O O O $string$ O O O $string$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $undefined[]$ O O O O O O O O O O O $string$ O O O $string$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $undefined[]$ O O O O O O O O O O O O O $any[]$ O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $any$ O O $any$ O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O O O O O $boolean$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O O O O O O O $any$ O O O O O O $any[]$ O $number$ O O O $any$ O O $Promise<any>$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O O $any$ O O $complex$ O O $complex$ O O O O $any$ O $any$ O $StringConstructor$ O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O $any$ O $any[]$ O O O O O $any$ O O $complex$ O O $complex$ O O O O $any$ O $any$ O $StringConstructor$ O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $complex$ O O $complex$ O O O O $any$ O $any$ O $StringConstructor$ O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $StringConstructor$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $StringConstructor$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any[]$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O O O O O O O O $any$ O O O O O O O O $any$ O O O $undefined[]$ O O O O O O $undefined[]$ O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $undefined[]$ O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $undefined[]$ O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O O O $any$ O $any$ O O O $boolean$ O O O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O O O O O O $boolean$ O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O O O $any$ O $any$ O O O $boolean$ O O O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O O O O O O $boolean$ O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O O O O O O $Promise<any>$ O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O $undefined$ O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O $any$ O $IteratorReturnResult<any>$ O $any$ O O O O O O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O O $any$ O O
import 's' ; import { StorageAccountApiService } from 's' ; const mockArmToken = 's' ; const mockResponseTemplate = [ { value : [ { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , { id : 's' , subscriptionId : 's' , tenantId : 's' , displayName : 's' , state : 's' , subscriptionPolicies : { locationPlacementId : 's' , quotaId : 's' , spendingLimit : 's' , } , authorizationSource : 's' , } , ] , } , { value : [ { id : 's' , name : 's' , type : 's' , etag : "s" , location : 's' , sku : { name : 's' , } , kind : 's' , properties : { provisioningState : 's' , } , } , ] , } , { value : [ { id : 's' , name : 's' , type : 's' , etag : "s" , location : 's' , sku : { name : 's' , } , kind : 's' , properties : { provisioningState : 's' , } , } , ] , } , { value : [ { id : 's' + 's' , name : 's' , type : 's' , etag : 's' , properties : { publicAccess : 's' , leaseStatus : 's' , leaseState : 's' , lastModifiedTime : 's' , hasImmutabilityPolicy : false , hasLegalHold : false , } , } , ] , } , { value : [ ] , } , { keys : [ { keyName : 's' , permissions : 's' , value : 's' , } , { keyName : 's' , permissions : 's' , value : 's' , } , ] , } , ] ; const mockArgsPassedToFetch = [ ] ; let mockResponses ; jest . mock ( 's' , ( ) => { const fetch = ( url , headers ) => { mockArgsPassedToFetch . push ( { url , headers } ) ; return { ok : true , json : async ( ) => mockResponses . shift ( ) , text : async ( ) => mockResponses . shift ( ) , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ; async function getResult ( ) { const it = StorageAccountApiService . getBlobStorageServices ( mockArmToken ) ; let result = undefined ; while ( true ) { const next = it . next ( result ) ; if ( next . done ) { result = next . value ; break ; } try { result = await next . value ; } catch ( e ) { break ; } } return result ; } describe ( 's' , ( ) => { beforeEach ( ( ) => { mockResponses = JSON . parse ( JSON . stringify ( mockResponseTemplate ) ) ; mockArgsPassedToFetch . length = 0 ; } ) ; it ( 's' , async ( ) => { const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ { type : 's' , id : 's' + 's' , tenantId : 's' , subscriptionId : 's' , name : 's' , connectionString : 's' + 's' , resourceGroup : 's' , serviceName : 's' , container : 's' , } , ] , code : 0 , } ) ; } ) ; it ( 's' , async ( ) => { mockResponses = [ { value : [ ] } ] ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; it ( 's' , async ( ) => { mockResponses [ 0 ] = mockResponses [ 0 ] = { value : [ ] } ; const result = await getResult ( ) ; expect ( result ) . toEqual ( { services : [ ] , code : 0 } ) ; } ) ; } ) ;	O O O O O $any$ O O O O O O O O O O $complex$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O O O $complex$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O O O O O O O O O O $undefined[]$ O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O O O O O $boolean$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O O O $Promise<any>$ O O O O $IterableIterator<any>$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O $undefined$ O O O O O O O $complex$ O $IterableIterator<any>$ O $complex$ O $any$ O O O O $complex$ O $boolean$ O O $any$ O $IteratorReturnResult<any>$ O $any$ O O O O O O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O $complex$ O O O $any[]$ O $number$ O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O $number$ O O O O O O O O O $any$ O O O O O O O O $any$ O O O $undefined[]$ O O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $undefined[]$ O O O O O O $any$ O O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $undefined[]$ O O O O $number$ O O O O O O O O O O O
import * as azureAuthActions from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { expect ( azureAuthActions . azurePersistLoginChanged ( true ) ) . toEqual ( { type : azureAuthActions . AZURE_PERSIST_LOGIN_CHANGED , payload : true , } ) ; } ) ; test ( 's' , ( ) => { expect ( azureAuthActions . azureLoggedInUserChanged ( 's' ) ) . toEqual ( { type : azureAuthActions . AZURE_LOGGED_IN_USER_CHANGED , payload : 's' , } ) ; } ) ; } ) ;	O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<boolean>$ O O O O O $any$ O O $string$ O $any$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O $any$ O O $string$ O $any$ O O O $string$ O O O O O O O O O O O O
import { BotActionType , load , setActive , setDirectory , close , mockAndSetActive , botHashGenerated , browse , closeBot , openBotViaFilePathAction , openBotViaUrlAction , restartConversation , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const bots = [ { } , null , undefined , { } ] ; const action = load ( bots ) ; expect ( action . type ) . toBe ( BotActionType . load ) ; expect ( action . payload ) . toEqual ( { bots : [ { } , { } ] } ) ; } ) ; it ( 's' , ( ) => { const bot = { } ; const action = setActive ( bot ) ; expect ( action . type ) . toBe ( BotActionType . setActive ) ; expect ( action . payload ) . toEqual ( { bot : { } } ) ; } ) ; it ( 's' , ( ) => { const directory = 's' ; const action = setDirectory ( directory ) ; expect ( action . type ) . toBe ( BotActionType . setDirectory ) ; expect ( action . payload ) . toEqual ( { directory } ) ; } ) ; it ( 's' , ( ) => { const action = close ( ) ; expect ( action . type ) . toBe ( BotActionType . close ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const mock = { name : 's' , someMockProperty : true } ; const action = mockAndSetActive ( mock ) ; expect ( action . type ) . toBe ( BotActionType . setActive ) ; expect ( action . payload ) . toEqual ( { bot : { version : 's' , name : 's' , description : 's' , services : [ ] , padlock : 's' , someMockProperty : true , } , } ) ; } ) ; it ( 's' , ( ) => { const hash = 's' ; const action = botHashGenerated ( hash ) ; expect ( action . type ) . toBe ( BotActionType . hashGenerated ) ; expect ( action . payload ) . toEqual ( { hash } ) ; } ) ; it ( 's' , ( ) => { const action = browse ( ) ; expect ( action . type ) . toBe ( BotActionType . browse ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = closeBot ( ) ; expect ( action . type ) . toBe ( BotActionType . close ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = openBotViaFilePathAction ( 's' ) ; expect ( action . type ) . toBe ( BotActionType . openViaFilePath ) ; expect ( action . payload ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const action = openBotViaUrlAction ( { } ) ; expect ( action . type ) . toBe ( BotActionType . openViaUrl ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const documentId = 's' ; const action = restartConversation ( conversationId , documentId ) ; expect ( action . type ) . toBe ( BotActionType . restartConversation ) ; expect ( action . payload ) . toEqual ( { conversationId , documentId } ) ; } ) ; } ) ;	O O $any$ O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O $BotAction<SetDirectoryPayload>$ O $BotAction<{}>$ O $BotAction<any>$ O $BotAction<HashPayload>$ O $BotAction<{}>$ O $BotAction<{}>$ O $BotAction<string>$ O $BotAction<any>$ O $BotAction<RestartConversationPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O ${}[]$ O O O O O O O $undefined$ O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<LoadBotPayload>$ O ${}[]$ O O $any$ O $BotAction<LoadBotPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.load$ O O $any$ O $BotAction<LoadBotPayload>$ O $LoadBotPayload$ O O $any$ O O ${}[]$ O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O $any$ O $BotAction<SetActivePayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setActive$ O O $any$ O $BotAction<SetActivePayload>$ O $SetActivePayload$ O O $any$ O O ${}$ O O O O O O O O O $any$ O O O O O O O O O O O O O $BotAction<SetDirectoryPayload>$ O $BotAction<SetDirectoryPayload>$ O O O O $any$ O $BotAction<SetDirectoryPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setDirectory$ O O $any$ O $BotAction<SetDirectoryPayload>$ O $SetDirectoryPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.close$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $boolean$ O O O O O $BotAction<any>$ O $BotAction<any>$ O $any$ O O $any$ O $BotAction<any>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.setActive$ O O $any$ O $BotAction<any>$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $boolean$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O $BotAction<HashPayload>$ O $BotAction<HashPayload>$ O O O O $any$ O $BotAction<HashPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.hashGenerated$ O O $any$ O $BotAction<HashPayload>$ O $HashPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.browse$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O $any$ O $BotAction<{}>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.close$ O O $any$ O $BotAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BotAction<string>$ O $BotAction<string>$ O O O O $any$ O $BotAction<string>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.openViaFilePath$ O O $any$ O $BotAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotAction<any>$ O $BotAction<any>$ O O O O O $any$ O $BotAction<any>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.openViaUrl$ O O $any$ O $BotAction<any>$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $BotAction<RestartConversationPayload>$ O $BotAction<RestartConversationPayload>$ O O O O O O $any$ O $BotAction<RestartConversationPayload>$ O $BotActionType$ O O $any$ O $any$ O $BotActionType.restartConversation$ O O $any$ O $BotAction<RestartConversationPayload>$ O $RestartConversationPayload$ O O $any$ O O $string$ O $string$ O O O O O O O O O
import { ChatActions , inspectorChanged , addTranscript , clearTranscripts , removeTranscript , webSpeechFactoryUpdated , webChatStoreUpdated , updatePendingSpeechTokenRetrieval , newChat , closeDocument , closeConversation , newConversation , appendToLog , clearLog , setInspectorObjects , setHighlightedObjects , updateChat , showContextMenuForActivity , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const inspectorWebView = { } ; const action = inspectorChanged ( inspectorWebView ) ; expect ( action . type ) . toBe ( ChatActions . activeInspectorChanged ) ; expect ( action . payload ) . toEqual ( { inspectorWebView } ) ; } ) ; it ( 's' , ( ) => { const filename = 's' ; const action = addTranscript ( filename ) ; expect ( action . type ) . toBe ( ChatActions . addTranscript ) ; expect ( action . payload ) . toEqual ( { filename } ) ; } ) ; it ( 's' , ( ) => { const action = clearTranscripts ( ) ; expect ( action . type ) . toBe ( ChatActions . clearTranscripts ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const filename = 's' ; const action = removeTranscript ( filename ) ; expect ( action . type ) . toBe ( ChatActions . removeTranscript ) ; expect ( action . payload ) . toEqual ( { filename } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const factory = ( ) => null ; const action = webSpeechFactoryUpdated ( documentId , factory ) ; expect ( action . type ) . toBe ( ChatActions . webSpeechFactoryUpdated ) ; expect ( action . payload ) . toEqual ( { factory , documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const store = { } ; const action = webChatStoreUpdated ( documentId , store ) ; expect ( action . type ) . toBe ( ChatActions . webChatStoreUpdated ) ; expect ( action . payload ) . toEqual ( { documentId , store } ) ; } ) ; it ( 's' , ( ) => { const pending = true ; const action = updatePendingSpeechTokenRetrieval ( pending ) ; expect ( action . type ) . toBe ( ChatActions . updatePendingSpeechTokenRetrieval ) ; expect ( action . payload ) . toEqual ( { pending } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const mode = 's' ; const additionalData = { someOtherProperty : true } ; const action = newChat ( documentId , mode , additionalData ) ; expect ( action . type ) . toBe ( ChatActions . newChat ) ; expect ( action . payload ) . toEqual ( { mode , documentId , conversationId : null , directLine : null , log : { entries : [ ] , } , inspectorObjects : [ ] , ui : { horizontalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , verticalSplitter : [ { absolute : null , percentage : 0 , } , { absolute : null , percentage : 0 , } , ] , } , someOtherProperty : true , } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = closeDocument ( documentId ) ; expect ( action . type ) . toBe ( ChatActions . closeDocument ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = closeConversation ( documentId ) ; expect ( action . type ) . toBe ( ChatActions . closeConversation ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const options = { } ; const action = newConversation ( documentId , options ) ; expect ( action . type ) . toBe ( ChatActions . newConversation ) ; expect ( action . payload ) . toEqual ( { documentId , options } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const entry = { } ; const action = appendToLog ( documentId , entry ) ; expect ( action . type ) . toBe ( ChatActions . appendLog ) ; expect ( action . payload ) . toEqual ( { documentId , entry } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const resolver = ( ) => null ; const action = clearLog ( documentId , resolver ) ; expect ( action . type ) . toBe ( ChatActions . clearLog ) ; expect ( action . payload ) . toEqual ( { documentId , resolver } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; let objs = [ { } , { } ] ; let action = setInspectorObjects ( documentId , objs ) ; expect ( action . type ) . toBe ( ChatActions . setInspectorObjects ) ; expect ( action . payload ) . toEqual ( { documentId , objs } ) ; objs = { } ; action = setInspectorObjects ( documentId , objs ) ; expect ( action . payload ) . toEqual ( { documentId , objs : [ objs ] } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; let objs = [ { } , { } ] ; let action = setHighlightedObjects ( documentId , objs ) ; expect ( action . type ) . toBe ( ChatActions . setHighlightedObjects ) ; expect ( action . payload ) . toEqual ( { documentId , objs } ) ; objs = { } ; action = setHighlightedObjects ( documentId , objs ) ; expect ( action . payload ) . toEqual ( { documentId , objs : [ objs ] } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const updatedValues = { updatedValue : 0 } ; const action = updateChat ( documentId , updatedValues ) ; expect ( action . type ) . toBe ( ChatActions . updateChat ) ; expect ( action . payload ) . toEqual ( { documentId , updatedValues } ) ; } ) ; it ( 's' , ( ) => { const activity = { } ; const action = showContextMenuForActivity ( activity ) ; expect ( action . type ) . toBe ( ChatActions . showContextMenuForActivity ) ; expect ( action . payload ) . toEqual ( activity ) ; } ) ; } ) ;	O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $ChatAction<AddTranscriptPayload>$ O $ChatAction<{}>$ O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<WebSpeechFactoryPayload>$ O $ChatAction<WebChatStorePayload>$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $complex$ O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O $ChatAction<NewConversationPayload>$ O $ChatAction<AppendLogPayload>$ O $ChatAction<ClearLogPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<UpdateChatPayload>$ O $ChatAction<any>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $ChatAction<ActiveInspectorChangedPayload>$ O $ChatAction<ActiveInspectorChangedPayload>$ O $any$ O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.activeInspectorChanged$ O O $any$ O $ChatAction<ActiveInspectorChangedPayload>$ O $ActiveInspectorChangedPayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AddTranscriptPayload>$ O O O O $any$ O $ChatAction<AddTranscriptPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.addTranscript$ O O $any$ O $ChatAction<AddTranscriptPayload>$ O $AddTranscriptPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $ChatAction<{}>$ O $ChatAction<{}>$ O O O $any$ O $ChatAction<{}>$ O $any$ O O $any$ O $any$ O $ChatActions.clearTranscripts$ O O $any$ O $ChatAction<{}>$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O O O O $any$ O $ChatAction<RemoveTranscriptPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.removeTranscript$ O O $any$ O $ChatAction<RemoveTranscriptPayload>$ O $RemoveTranscriptPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $ChatAction<WebSpeechFactoryPayload>$ O $ChatAction<WebSpeechFactoryPayload>$ O O O $any$ O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.webSpeechFactoryUpdated$ O O $any$ O $ChatAction<WebSpeechFactoryPayload>$ O $WebSpeechFactoryPayload$ O O $any$ O O $any$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O ${}$ O O O O O $ChatAction<WebChatStorePayload>$ O $ChatAction<WebChatStorePayload>$ O O O ${}$ O O $any$ O $ChatAction<WebChatStorePayload>$ O $any$ O O $any$ O $any$ O $ChatActions.webChatStoreUpdated$ O O $any$ O $ChatAction<WebChatStorePayload>$ O $WebChatStorePayload$ O O $any$ O O $string$ O ${}$ O O O O O O $any$ O O O O O O O O $true$ O O O O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $true$ O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.updatePendingSpeechTokenRetrieval$ O O $any$ O $ChatAction<PendingSpeechTokenRetrievalPayload>$ O $PendingSpeechTokenRetrievalPayload$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O O O $complex$ O $complex$ O O O O O $any$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $ChatActions.newChat$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O $string$ O $null$ O O O $null$ O O O $complex$ O O $undefined[]$ O O O O O O $undefined[]$ O O O O $complex$ O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O $complex$ O O O $null$ O O O $number$ O O O O O O $null$ O O O $number$ O O O O O O O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $any$ O $ChatAction<DocumentIdPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.closeDocument$ O O $any$ O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $any$ O $ChatAction<DocumentIdPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.closeConversation$ O O $any$ O $ChatAction<DocumentIdPayload>$ O $DocumentIdPayload$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O ${}$ O O O O O $ChatAction<NewConversationPayload>$ O $ChatAction<NewConversationPayload>$ O O O ${}$ O O $any$ O $ChatAction<NewConversationPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.newConversation$ O O $any$ O $ChatAction<NewConversationPayload>$ O $NewConversationPayload$ O O $any$ O O $string$ O ${}$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $ChatAction<AppendLogPayload>$ O $ChatAction<AppendLogPayload>$ O O O $any$ O O $any$ O $ChatAction<AppendLogPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.appendLog$ O O $any$ O $ChatAction<AppendLogPayload>$ O $AppendLogPayload$ O O $any$ O O $string$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $ChatAction<ClearLogPayload>$ O $ChatAction<ClearLogPayload>$ O O O $any$ O O $any$ O $ChatAction<ClearLogPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.clearLog$ O O $any$ O $ChatAction<ClearLogPayload>$ O $ClearLogPayload$ O O $any$ O O $string$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.setInspectorObjects$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $SetInspectorObjectsPayload$ O O $any$ O O $string$ O $any$ O O O $any$ O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetInspectorObjectsPayload>$ O $SetInspectorObjectsPayload$ O O $any$ O O $string$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.setHighlightedObjects$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $SetHighlightedObjectsPayload$ O O $any$ O O $string$ O $any$ O O O $any$ O O O O $ChatAction<SetHighlightedObjectsPayload>$ O $ChatAction<SetHighlightedObjectsPayload>$ O O O $any$ O O $any$ O $ChatAction<SetHighlightedObjectsPayload>$ O $SetHighlightedObjectsPayload$ O O $any$ O O $string$ O $any[]$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $number$ O O O O O $ChatAction<UpdateChatPayload>$ O $ChatAction<UpdateChatPayload>$ O O O $complex$ O O $any$ O $ChatAction<UpdateChatPayload>$ O $any$ O O $any$ O $any$ O $ChatActions.updateChat$ O O $any$ O $ChatAction<UpdateChatPayload>$ O $UpdateChatPayload$ O O $any$ O O $string$ O $complex$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $ChatAction<any>$ O $ChatAction<any>$ O $any$ O O $any$ O $ChatAction<any>$ O $any$ O O $any$ O $any$ O $ChatActions.showContextMenuForActivity$ O O $any$ O $ChatAction<any>$ O $any$ O O $any$ O $any$ O O O O O O O O
import { clientAwareSettingsChanged , CLIENT_AWARE_SETTINGS_CHANGED } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const settings = { } ; const action = clientAwareSettingsChanged ( settings ) ; expect ( action . type ) . toBe ( CLIENT_AWARE_SETTINGS_CHANGED ) ; expect ( action . payload ) . toEqual ( settings ) ; } ) ; } ) ;	O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $ClientAwareSettingsActions$ O $ClientAwareSettingsActions$ O $any$ O O $any$ O $ClientAwareSettingsActions$ O O O O $any$ O O O O $any$ O $ClientAwareSettingsActions$ O $any$ O O $any$ O $any$ O O O O O O O O
import { Action } from 's' ; export const EXECUTE_COMMAND = 's' ; export interface CommandAction < T > extends Action { payload : T ; } export interface CommandActionPayload { isRemote : boolean ; commandName : string ; args : any [ ] ; resolver ? : Function ; } export function executeCommand ( isRemote , commandName , resolver = null , ... args : any [ ] ) < CommandActionPayload > { return { type : EXECUTE_COMMAND , payload : { isRemote , commandName , resolver , args } , } ; }	O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $boolean$ O O O $string$ O O O $any[]$ O O O O O $Function$ O O $FunctionConstructor$ O O O O $CommandAction$ O $boolean$ O $any$ O $Function$ O O O O $any[]$ O O O O O O $any$ O O O O $string$ O O O $complex$ O O $boolean$ O $any$ O $Function$ O $any[]$ O O O O O
import { executeCommand , EXECUTE_COMMAND } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const isRemote = true ; const commandName = 's' ; const resolver = ( ) => null ; const action = executeCommand ( isRemote , commandName , resolver ) ; expect ( action . type ) . toBe ( EXECUTE_COMMAND ) ; expect ( action . payload ) . toEqual ( { isRemote , commandName , resolver , args : [ ] } ) ; } ) ; } ) ;	O O $CommandAction<CommandActionPayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $true$ O O O O O O O O O $any$ O O O O O O O $CommandAction<CommandActionPayload>$ O $CommandAction<CommandActionPayload>$ O $true$ O O O $any$ O O $any$ O $CommandAction<CommandActionPayload>$ O $any$ O O $any$ O O O O $any$ O $CommandAction<CommandActionPayload>$ O $CommandActionPayload$ O O $any$ O O $boolean$ O $string$ O $any$ O $undefined[]$ O O O O O O O O O O O O
import { IConnectedService , ServiceTypes } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; import { CONNECTED_SERVICES_PANEL_ID } from 's' ; export const OPEN_SERVICE_DEEP_LINK = 's' ; export const OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE = 's' ; export const OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU = 's' ; export const LAUNCH_EXTERNAL_LINK = 's' ; export const OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU = 's' ; export const LAUNCH_CONNECTED_SERVICE_EDITOR = 's' ; export const LAUNCH_CONNECTED_SERVICE_PICKER = 's' ; export interface ConnectedServiceAction < T > extends Action { payload : T ; } export interface ConnectedServicePayload { serviceType ? : ServiceTypes ; connectedService ? : IConnectedService ; authenticatedUser ? : string ; editorComponent ? : ComponentClass < any > ; panelId ? : string ; } export function launchConnectedServiceEditor < T > ( editorComponent < T > , connectedService ? ) < ConnectedServicePayload > { return { type : LAUNCH_CONNECTED_SERVICE_EDITOR , payload : { editorComponent , connectedService } , } ; } export interface ConnectedServicePickerPayload extends ConnectedServicePayload { azureAuthWorkflowComponents : { promptDialog : ComponentClass < any > ; loginSuccessDialog : ComponentClass < any > ; loginFailedDialog : ComponentClass < any > ; } ; pickerComponent : ComponentClass < any > ; getStartedDialog : ComponentClass < any > ; editorComponent : ComponentClass < any > ; progressIndicatorComponent ? : ComponentClass < any > ; } export function launchConnectedServicePicker ( payload ) < ConnectedServicePickerPayload > { return { type : LAUNCH_CONNECTED_SERVICE_PICKER , payload , } ; } export function openServiceDeepLink ( connectedService ) < ConnectedServicePayload > { return { type : OPEN_SERVICE_DEEP_LINK , payload : { connectedService } , } ; } export function openContextMenuForConnectedService < T > ( editorComponent < T > , connectedService ? ) < ConnectedServicePayload > { return { type : OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , payload : { editorComponent , connectedService } , } ; } export function openAddServiceContextMenu ( payload ) < ConnectedServicePickerPayload > { return { type : OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , payload , } ; } export function launchExternalLink ( payload ) < ConnectedServicePayload > { return { type : LAUNCH_EXTERNAL_LINK , payload , } ; } export function openSortContextMenu ( ) < ConnectedServicePayload > { return { type : OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , payload : { panelId : CONNECTED_SERVICES_PANEL_ID } , } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $string$ O O O O $any$ O O $any$ O O O O $string$ O O O O O O O $ConnectedServiceAction$ O $any$ O O $ComponentClass$ O $any$ O O $any$ $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $ConnectedServiceAction$ O $ConnectedServicePickerPayload$ O O $any$ O O O O $string$ O O O $ConnectedServicePickerPayload$ O O O O O O $ConnectedServiceAction$ O $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O O O $ConnectedServiceAction$ O $any$ O O $ComponentClass$ O $any$ O O $any$ $IConnectedService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O O O $ConnectedServiceAction$ O $ConnectedServicePickerPayload$ O O $any$ O O O O $string$ O O O $ConnectedServicePickerPayload$ O O O O O O $ConnectedServiceAction$ O $ConnectedServicePayload$ O O $any$ O O O O $string$ O O O $ConnectedServicePayload$ O O O O O O $ConnectedServiceAction$ O O O $any$ O O O O $string$ O O O $complex$ O O $string$ O O O O O O O
import { OPEN_SERVICE_DEEP_LINK , OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE , OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU , LAUNCH_EXTERNAL_LINK , OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU , LAUNCH_CONNECTED_SERVICE_EDITOR , LAUNCH_CONNECTED_SERVICE_PICKER , launchConnectedServiceEditor , launchConnectedServicePicker , openServiceDeepLink , openContextMenuForConnectedService , openAddServiceContextMenu , launchExternalLink , openSortContextMenu , } from 's' ; import { CONNECTED_SERVICES_PANEL_ID } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const editorComponent = { } ; const connectedService = { } ; const action = launchConnectedServiceEditor ( editorComponent , connectedService ) ; expect ( action . type ) . toBe ( LAUNCH_CONNECTED_SERVICE_EDITOR ) ; expect ( action . payload ) . toEqual ( { editorComponent , connectedService } ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = launchConnectedServicePicker ( payload ) ; expect ( action . type ) . toBe ( LAUNCH_CONNECTED_SERVICE_PICKER ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const connectedService = { } ; const action = openServiceDeepLink ( connectedService ) ; expect ( action . type ) . toBe ( OPEN_SERVICE_DEEP_LINK ) ; expect ( action . payload ) . toEqual ( { connectedService } ) ; } ) ; it ( 's' , ( ) => { const editorComponent = { } ; const connectedService = { } ; const action = openContextMenuForConnectedService ( editorComponent , connectedService ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_CONNECTED_SERVICE ) ; expect ( action . payload ) . toEqual ( { editorComponent , connectedService } ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = openAddServiceContextMenu ( payload ) ; expect ( action . type ) . toBe ( OPEN_ADD_CONNECTED_SERVICE_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = launchExternalLink ( payload ) ; expect ( action . type ) . toBe ( LAUNCH_EXTERNAL_LINK ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = openSortContextMenu ( ) ; expect ( action . type ) . toBe ( OPEN_CONNECTED_SERVICE_SORT_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { panelId : CONNECTED_SERVICES_PANEL_ID } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePickerPayload>$ O $ConnectedServicePickerPayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServiceAction<ConnectedServicePayload>$ O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $any$ O O $any$ O O O O $any$ O $ConnectedServiceAction<ConnectedServicePayload>$ O $ConnectedServicePayload$ O O $any$ O O $string$ O O O O O O O O O O O
import { DialogActions , setShowing } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const action = setShowing ( ) ; expect ( action . type ) . toBe ( DialogActions . setShowing ) ; expect ( action . payload ) . toEqual ( { showing : false } ) ; } ) ; } ) ;	O O $any$ O $SetShowingDialogAction$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $SetShowingDialogAction$ O $SetShowingDialogAction$ O O O $any$ O $SetShowingDialogAction$ O $DialogActions$ O O $any$ O $any$ O $DialogActions.setShowing$ O O $any$ O $SetShowingDialogAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O O O O O O
import { IDispatchService } from 's' ; import { Action } from 's' ; export const OPEN_DISPATCH_DEEP_LINK = 's' ; export const OPEN_DISPATCH_EXPLORER_CONTEXT_MENU = 's' ; export interface DispatchServiceAction < T > extends Action { payload : T ; } export interface DispatchServicePayload { dispatchService ? : IDispatchService ; } export function openDispatchDeepLink ( dispatchService ) < DispatchServicePayload > { return { type : OPEN_DISPATCH_DEEP_LINK , payload : { dispatchService } , } ; } export function openDispatchExplorerContextMenu ( dispatchService ) < DispatchServicePayload > { return { type : OPEN_DISPATCH_EXPLORER_CONTEXT_MENU , payload : { dispatchService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $DispatchServiceAction$ O $IDispatchService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O O O $DispatchServiceAction$ O $IDispatchService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O
import { OPEN_DISPATCH_DEEP_LINK , OPEN_DISPATCH_EXPLORER_CONTEXT_MENU , openDispatchDeepLink , openDispatchExplorerContextMenu , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const dispatchService = { } ; const action = openDispatchDeepLink ( dispatchService ) ; expect ( action . type ) . toBe ( OPEN_DISPATCH_DEEP_LINK ) ; expect ( action . payload ) . toEqual ( { dispatchService } ) ; } ) ; it ( 's' , ( ) => { const dispatchService = { } ; const action = openDispatchExplorerContextMenu ( dispatchService ) ; expect ( action . type ) . toBe ( OPEN_DISPATCH_EXPLORER_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { dispatchService } ) ; } ) ; } ) ;	O O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O O O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServicePayload$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $any$ O O $any$ O O O O $any$ O $DispatchServiceAction<DispatchServicePayload>$ O $DispatchServicePayload$ O O $any$ O O $any$ O O O O O O O O O
import { EditorActions , appendTab , addDocPendingChange , removeDocPendingChange , close , closeNonGlobalTabs , setDirtyFlag , open , updateDocument , setActiveTab , setActiveEditor , splitTab , swapTabs , toggleDraggingTab , dropTabOnLeftOverlay , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const srcEditorKey = 's' ; const destEditorKey = 's' ; const documentId = 's' ; const action = appendTab ( srcEditorKey , destEditorKey , documentId ) ; expect ( action . type ) . toBe ( EditorActions . appendTab ) ; expect ( action . payload ) . toEqual ( { srcEditorKey , destEditorKey , documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = addDocPendingChange ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . addDocPendingChange ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = removeDocPendingChange ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . removeDocPendingChange ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const editorKey = 's' ; const documentId = 's' ; const action = close ( editorKey , documentId ) ; expect ( action . type ) . toBe ( EditorActions . close ) ; expect ( action . payload ) . toEqual ( { documentId , editorKey } ) ; } ) ; it ( 's' , ( ) => { const action = closeNonGlobalTabs ( ) ; expect ( action . type ) . toBe ( EditorActions . closeAll ) ; expect ( action . payload ) . toEqual ( { includeGlobal : false } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const dirty = true ; const action = setDirtyFlag ( documentId , dirty ) ; expect ( action . type ) . toBe ( EditorActions . setDirtyFlag ) ; expect ( action . payload ) . toEqual ( { documentId , dirty } ) ; } ) ; it ( 's' , ( ) => { const document = { } ; const action = open ( document ) ; expect ( action . type ) . toBe ( EditorActions . open ) ; expect ( action . payload ) . toEqual ( document ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const updatedDocument = { dirty : true , contentType : 's' } ; const action = updateDocument ( documentId , updatedDocument ) ; expect ( action . type ) . toBe ( EditorActions . updateDocument ) ; expect ( action . payload ) . toEqual ( { documentId , dirty : true , contentType : 's' } ) ; } ) ; it ( 's' , ( ) => { const documentId = 's' ; const action = setActiveTab ( documentId ) ; expect ( action . type ) . toBe ( EditorActions . setActiveTab ) ; expect ( action . payload ) . toEqual ( { documentId } ) ; } ) ; it ( 's' , ( ) => { const editorKey = 's' ; const action = setActiveEditor ( editorKey ) ; expect ( action . type ) . toBe ( EditorActions . setActiveEditor ) ; expect ( action . payload ) . toEqual ( { editorKey } ) ; } ) ; it ( 's' , ( ) => { const contentType = 's' ; const documentId = 's' ; const srcEditorKey = 's' ; const destEditorKey = 's' ; const action = splitTab ( contentType , documentId , srcEditorKey , destEditorKey ) ; expect ( action . type ) . toBe ( EditorActions . splitTab ) ; expect ( action . payload ) . toEqual ( { contentType , documentId , srcEditorKey , destEditorKey } ) ; } ) ; it ( 's' , ( ) => { const srcEditorKey = 's' ; const destEditorKey = 's' ; const srcTabId = 's' ; const destTabId = 's' ; const action = swapTabs ( srcEditorKey , destEditorKey , srcTabId , destTabId ) ; expect ( action . type ) . toBe ( EditorActions . swapTabs ) ; expect ( action . payload ) . toEqual ( { srcEditorKey , destEditorKey , srcTabId , destTabId } ) ; } ) ; it ( 's' , ( ) => { const draggingTab = true ; const action = toggleDraggingTab ( draggingTab ) ; expect ( action . type ) . toBe ( EditorActions . toggleDraggingTab ) ; expect ( action . payload ) . toEqual ( { draggingTab } ) ; } ) ; it ( 's' , ( ) => { const tabId = 's' ; const action = dropTabOnLeftOverlay ( tabId ) ; expect ( action . type ) . toBe ( EditorActions . dropTabOnLeftOverlay ) ; expect ( action . payload ) . toEqual ( { tabId } ) ; } ) ; } ) ;	O O $any$ O $AppendTabAction$ O $AddDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O $CloseEditorAction$ O $CloseAllEditorAction$ O $SetDirtyFlagAction$ O $OpenEditorAction$ O $UpdateDocumentAction$ O $SetActiveTabAction$ O $SetActiveEditorAction$ O $SplitTabAction$ O $SwapTabsAction$ O $ToggleDraggingTabAction$ O $DropTabOnLeftOverlayAction$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $AppendTabAction$ O $AppendTabAction$ O O O O O O O O $any$ O $AppendTabAction$ O $EditorActions.appendTab$ O O $any$ O $any$ O $EditorActions.appendTab$ O O $any$ O $AppendTabAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O $any$ O $AddDocPendingChangeAction$ O $EditorActions.addDocPendingChange$ O O $any$ O $any$ O $EditorActions.addDocPendingChange$ O O $any$ O $AddDocPendingChangeAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $RemoveDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O O O O $any$ O $RemoveDocPendingChangeAction$ O $EditorActions.removeDocPendingChange$ O O $any$ O $any$ O $EditorActions.removeDocPendingChange$ O O $any$ O $RemoveDocPendingChangeAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $CloseEditorAction$ O $CloseEditorAction$ O O O O O O $any$ O $CloseEditorAction$ O $EditorActions.close$ O O $any$ O $any$ O $EditorActions.close$ O O $any$ O $CloseEditorAction$ O $complex$ O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O $any$ O $CloseAllEditorAction$ O $EditorActions.closeAll$ O O $any$ O $any$ O $EditorActions.closeAll$ O O $any$ O $CloseAllEditorAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O O O O $true$ O O O O $SetDirtyFlagAction$ O $SetDirtyFlagAction$ O O O $true$ O O $any$ O $SetDirtyFlagAction$ O $EditorActions.setDirtyFlag$ O O $any$ O $any$ O $EditorActions.setDirtyFlag$ O O $any$ O $SetDirtyFlagAction$ O $complex$ O O $any$ O O $string$ O $boolean$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $OpenEditorAction$ O $OpenEditorAction$ O $any$ O O $any$ O $OpenEditorAction$ O $EditorActions.open$ O O $any$ O $any$ O $EditorActions.open$ O O $any$ O $OpenEditorAction$ O $Partial<Document<any>>$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O O $boolean$ O O O $string$ O O O O O $UpdateDocumentAction$ O $UpdateDocumentAction$ O O O $any$ O O $any$ O $UpdateDocumentAction$ O $EditorActions.updateDocument$ O O $any$ O $any$ O $EditorActions.updateDocument$ O O $any$ O $UpdateDocumentAction$ O $Partial<Document<any>>$ O O $any$ O O $string$ O $boolean$ O O O $string$ O O O O O O O O $any$ O O O O O O O O O O O O O $SetActiveTabAction$ O $SetActiveTabAction$ O O O O $any$ O $SetActiveTabAction$ O $EditorActions.setActiveTab$ O O $any$ O $any$ O $EditorActions.setActiveTab$ O O $any$ O $SetActiveTabAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $SetActiveEditorAction$ O $SetActiveEditorAction$ O O O O $any$ O $SetActiveEditorAction$ O $EditorActions.setActiveEditor$ O O $any$ O $any$ O $EditorActions.setActiveEditor$ O O $any$ O $SetActiveEditorAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitTabAction$ O $SplitTabAction$ O O O O O O O O O O $any$ O $SplitTabAction$ O $EditorActions.splitTab$ O O $any$ O $any$ O $EditorActions.splitTab$ O O $any$ O $SplitTabAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O O O O O O O O O O $any$ O $SwapTabsAction$ O $EditorActions.swapTabs$ O O $any$ O $any$ O $EditorActions.swapTabs$ O O $any$ O $SwapTabsAction$ O $complex$ O O $any$ O O $string$ O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O $true$ O O O O $ToggleDraggingTabAction$ O $ToggleDraggingTabAction$ O $true$ O O $any$ O $ToggleDraggingTabAction$ O $EditorActions.toggleDraggingTab$ O O $any$ O $any$ O $EditorActions.toggleDraggingTab$ O O $any$ O $ToggleDraggingTabAction$ O $complex$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O $DropTabOnLeftOverlayAction$ O $DropTabOnLeftOverlayAction$ O O O O $any$ O $DropTabOnLeftOverlayAction$ O $EditorActions.dropTabOnLeftOverlay$ O O $any$ O $any$ O $EditorActions.dropTabOnLeftOverlay$ O O $any$ O $DropTabOnLeftOverlayAction$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { IEndpointService } from 's' ; import { Action } from 's' ; export const OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU = 's' ; export interface EndpointServiceAction < T > extends Action { payload : T ; } export interface EndpointServicePayload { endpointService ? : IEndpointService ; } export function openEndpointExplorerContextMenu ( endpointService ) < EndpointServicePayload > { return { type : OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU , payload : { endpointService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $EndpointServiceAction$ O $IEndpointService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O O O O O
import { openEndpointExplorerContextMenu , OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const endpointService = { } ; const action = openEndpointExplorerContextMenu ( endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_EXPLORER_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { endpointService } ) ; } ) ; } ) ;	O O $EndpointServiceAction<EndpointServicePayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServicePayload$ O O $any$ O O $any$ O O O O O O O O O
import { IEndpointService } from 's' ; import { ComponentClass } from 's' ; import { Action } from 's' ; export const OPEN_ENDPOINT_IN_EMULATOR = 's' ; export const OPEN_ENDPOINT_CONTEXT_MENU = 's' ; export const LAUNCH_ENDPOINT_EDITOR = 's' ; export interface EndpointServiceAction < T > extends Action { payload : T ; } export interface EndpointServicePayload { endpointService : IEndpointService ; focusExistingChatIfAvailable ? : boolean ; resolver ? : Function ; } export interface EndpointEditorPayload extends EndpointServicePayload { endpointEditorComponent ? : ComponentClass < any > ; } export function launchEndpointEditor ( endpointEditorComponent < any > , endpointService ? , resolver ? ) < EndpointEditorPayload > { return { type : LAUNCH_ENDPOINT_EDITOR , payload : { endpointEditorComponent , endpointService , resolver } , } ; } export function openEndpointInEmulator ( endpointService , focusExistingChatIfAvailable = false ) < EndpointServicePayload > { return { type : OPEN_ENDPOINT_IN_EMULATOR , payload : { endpointService , focusExistingChatIfAvailable } , } ; } export function openEndpointExplorerContextMenu ( endpointEditorComponent < any > , endpointService ? ) < EndpointEditorPayload > { return { type : OPEN_ENDPOINT_CONTEXT_MENU , payload : { endpointEditorComponent , endpointService } , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $any$ O $any$ O $any$ O $boolean$ O O O O $Function$ O O $FunctionConstructor$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $EndpointServiceAction$ O $ComponentClass$ O O O O $any$ $IEndpointService$ O $Function$ $Function$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O $Function$ O O O O O O O $EndpointServiceAction$ O $IEndpointService$ O $boolean$ O O O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $boolean$ O O O O O O O $EndpointServiceAction$ O $ComponentClass$ O O O O $any$ $IEndpointService$ O O $any$ O O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O
import { OPEN_ENDPOINT_IN_EMULATOR , OPEN_ENDPOINT_CONTEXT_MENU , LAUNCH_ENDPOINT_EDITOR , launchEndpointEditor , openEndpointInEmulator , openEndpointExplorerContextMenu , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const endpointEditorComponent = { } ; const endpointService = { } ; const action = launchEndpointEditor ( endpointEditorComponent , endpointService ) ; expect ( action . type ) . toBe ( LAUNCH_ENDPOINT_EDITOR ) ; expect ( action . payload ) . toEqual ( { endpointEditorComponent , endpointService } ) ; } ) ; it ( 's' , ( ) => { const endpointService = { } ; const action = openEndpointInEmulator ( endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_IN_EMULATOR ) ; expect ( action . payload ) . toEqual ( { endpointService , focusExistingChatIfAvailable : false } ) ; } ) ; it ( 's' , ( ) => { const endpointEditorComponent = { } ; const endpointService = { } ; const action = openEndpointExplorerContextMenu ( endpointEditorComponent , endpointService ) ; expect ( action . type ) . toBe ( OPEN_ENDPOINT_CONTEXT_MENU ) ; expect ( action . payload ) . toEqual ( { endpointEditorComponent , endpointService } ) ; } ) ; } ) ;	O O O O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointEditorPayload$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointServicePayload>$ O $EndpointServicePayload$ O O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O $any$ O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $any$ O O $any$ O O O O $any$ O $EndpointServiceAction<EndpointEditorPayload>$ O $EndpointEditorPayload$ O O $any$ O O $any$ O $any$ O O O O O O O O O
import { ExplorerActions , showExplorer , sortExplorerContents } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const show = true ; const action = showExplorer ( show ) ; expect ( action . type ) . toBe ( ExplorerActions . Show ) ; expect ( action . payload ) . toEqual ( { show } ) ; } ) ; it ( 's' , ( ) => { const panelId = 's' ; const sort = 's' ; const action = sortExplorerContents ( panelId , sort ) ; expect ( action . type ) . toBe ( ExplorerActions . Sort ) ; expect ( action . payload ) . toEqual ( { sortSelectionByPanelId : { [ panelId ] : sort } } ) ; } ) ; } ) ;	O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $true$ O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O $true$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O $any$ O $any$ O $ExplorerActions.Show$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O O $any$ O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $ExplorerAction<ExplorerPayload>$ O $ExplorerAction<ExplorerPayload>$ O O O O O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerActions$ O O $any$ O $any$ O $ExplorerActions.Sort$ O O $any$ O $ExplorerAction<ExplorerPayload>$ O $ExplorerPayload$ O O $any$ O O $complex$ O O O O O O O O O O O O O O O O O
import { FileInfo } from 's' ; export enum FileActions { setRoot = 's' , add = 's' , remove = 's' , clear = 's' , } export function addFile ( payload ) { return { type : FileActions . add , payload , } ; } export function clear ( ) { return { type : FileActions . clear , payload : { } , } ; } export function removeFile ( path ) { return { type : FileActions . remove , payload : { path } , } ; } export function setRoot ( path ) { return { type : FileActions . setRoot , payload : { path } , } ; }	O O $any$ O O O O O O $any$ O $FileActions.setRoot$ O O O $FileActions.add$ O O O $FileActions.remove$ O O O $FileActions.clear$ O O O O O O $complex$ O $FileInfo$ O O O O $FileActions$ O $any$ O $FileActions.add$ O $any$ O O O O O O $complex$ O O O O O $FileActions$ O $any$ O $FileActions.clear$ O ${}$ O O O O O O O O O $complex$ O $string$ O O O O $FileActions$ O $any$ O $FileActions.remove$ O $complex$ O O $string$ O O O O O O O $complex$ O $string$ O O O O $FileActions$ O $any$ O $FileActions.setRoot$ O $complex$ O O $string$ O O O O O
import { addFile , clear , removeFile , setRoot , FileActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = { } ; const action = addFile ( payload ) ; expect ( action . type ) . toBe ( FileActions . add ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = clear ( ) ; expect ( action . type ) . toBe ( FileActions . clear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const path = 's' ; const action = removeFile ( path ) ; expect ( action . type ) . toBe ( FileActions . remove ) ; expect ( action . payload ) . toEqual ( { path } ) ; } ) ; it ( 's' , ( ) => { const path = 's' ; const action = setRoot ( path ) ; expect ( action . type ) . toBe ( FileActions . setRoot ) ; expect ( action . payload ) . toEqual ( { path } ) ; } ) ; } ) ;	O O $complex$ O $complex$ O $complex$ O $complex$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $complex$ O $complex$ O $any$ O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.add$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.clear$ O O $any$ O $complex$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.remove$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $FileActions$ O O $any$ O $any$ O $FileActions.setRoot$ O O $any$ O $complex$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { FrameworkActionType , pushClientAwareSettings , setFrameworkSettings } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const frameworkSettings = { autoUpdate : true , } ; expect ( setFrameworkSettings ( frameworkSettings ) ) . toEqual ( { type : FrameworkActionType . SET_FRAMEWORK , payload : frameworkSettings , } ) ; } ) ; test ( 's' , ( ) => { expect ( pushClientAwareSettings ( ) ) . toEqual ( { type : FrameworkActionType . PUSH_CLIENT_AWARE_SETTINGS , payload : undefined , } ) ; } ) ; } ) ;	O O $any$ O $FrameworkAction<void>$ O $FrameworkAction<any>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $any$ O $FrameworkAction<any>$ O $complex$ O O O $any$ O O $FrameworkActionType$ O $any$ O $FrameworkActionType.SET_FRAMEWORK$ O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O $any$ O $FrameworkAction<void>$ O O O O $any$ O O $FrameworkActionType$ O $any$ O $FrameworkActionType.PUSH_CLIENT_AWARE_SETTINGS$ O $undefined$ O $undefined$ O O O O O O O O O O
import { select , NavBarActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const selection = 's' ; const action = select ( selection ) ; expect ( action . type ) . toBe ( NavBarActions . select ) ; expect ( action . payload ) . toEqual ( { selection } ) ; } ) ; } ) ;	O O $SelectNavBarAction$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $SelectNavBarAction$ O $SelectNavBarAction$ O O O O $any$ O $SelectNavBarAction$ O $NavBarActions$ O O $any$ O $any$ O $NavBarActions.select$ O O $any$ O $SelectNavBarAction$ O $complex$ O O $any$ O O $string$ O O O O O O O O O
import { beginAdd , finishAdd , beginRemove , finishRemove , markAllAsRead , beginClear , finishClear , NotificationActions , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const notification = { } ; const action = beginAdd ( notification ) ; expect ( action . type ) . toBe ( NotificationActions . beginAdd ) ; expect ( action . payload ) . toEqual ( { notification , read : false } ) ; } ) ; it ( 's' , ( ) => { const notification = { } ; const action = finishAdd ( notification ) ; expect ( action . type ) . toBe ( NotificationActions . finishAdd ) ; expect ( action . payload ) . toEqual ( { notification } ) ; } ) ; it ( 's' , ( ) => { const id = 's' ; const action = beginRemove ( id ) ; expect ( action . type ) . toBe ( NotificationActions . beginRemove ) ; expect ( action . payload ) . toEqual ( { id } ) ; } ) ; it ( 's' , ( ) => { const id = 's' ; const action = finishRemove ( id ) ; expect ( action . type ) . toBe ( NotificationActions . finishRemove ) ; expect ( action . payload ) . toEqual ( { id } ) ; } ) ; it ( 's' , ( ) => { const action = markAllAsRead ( ) ; expect ( action . type ) . toBe ( NotificationActions . markAllAsRead ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = beginClear ( ) ; expect ( action . type ) . toBe ( NotificationActions . beginClear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const action = finishClear ( ) ; expect ( action . type ) . toBe ( NotificationActions . finishClear ) ; expect ( action . payload ) . toEqual ( { } ) ; } ) ; } ) ;	O O $BeginAddNotificationAction$ O $FinishAddNotificationAction$ O $BeginRemoveNotificationAction$ O $FinishRemoveNotificationAction$ O $MarkAllAsReadNotificationAction$ O $BeginClearNotificationAction$ O $FinishClearNotificationAction$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $BeginAddNotificationAction$ O $BeginAddNotificationAction$ O $any$ O O $any$ O $BeginAddNotificationAction$ O $NotificationActions.beginAdd$ O O $any$ O $any$ O $NotificationActions.beginAdd$ O O $any$ O $BeginAddNotificationAction$ O $complex$ O O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $FinishAddNotificationAction$ O $FinishAddNotificationAction$ O $any$ O O $any$ O $FinishAddNotificationAction$ O $NotificationActions.finishAdd$ O O $any$ O $any$ O $NotificationActions.finishAdd$ O O $any$ O $FinishAddNotificationAction$ O $complex$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $BeginRemoveNotificationAction$ O $BeginRemoveNotificationAction$ O O O O $any$ O $BeginRemoveNotificationAction$ O $NotificationActions.beginRemove$ O O $any$ O $any$ O $NotificationActions.beginRemove$ O O $any$ O $BeginRemoveNotificationAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $FinishRemoveNotificationAction$ O $FinishRemoveNotificationAction$ O O O O $any$ O $FinishRemoveNotificationAction$ O $NotificationActions.finishRemove$ O O $any$ O $any$ O $NotificationActions.finishRemove$ O O $any$ O $FinishRemoveNotificationAction$ O $complex$ O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $MarkAllAsReadNotificationAction$ O $MarkAllAsReadNotificationAction$ O O O $any$ O $MarkAllAsReadNotificationAction$ O $NotificationActions.markAllAsRead$ O O $any$ O $any$ O $NotificationActions.markAllAsRead$ O O $any$ O $MarkAllAsReadNotificationAction$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $BeginClearNotificationAction$ O $BeginClearNotificationAction$ O O O $any$ O $BeginClearNotificationAction$ O $NotificationActions.beginClear$ O O $any$ O $any$ O $NotificationActions.beginClear$ O O $any$ O $BeginClearNotificationAction$ O ${}$ O O $any$ O O O O O O O O $any$ O O O O O O O O $FinishClearNotificationAction$ O $FinishClearNotificationAction$ O O O $any$ O $FinishClearNotificationAction$ O $NotificationActions.finishClear$ O O $any$ O $any$ O $NotificationActions.finishClear$ O O $any$ O $FinishClearNotificationAction$ O ${}$ O O $any$ O O O O O O O O O O O
import { disable , enable , PresentationActions } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const action = enable ( ) ; expect ( action . type ) . toBe ( PresentationActions . enable ) ; } ) ; it ( 's' , ( ) => { const action = disable ( ) ; expect ( action . type ) . toBe ( PresentationActions . disable ) ; } ) ; } ) ;	O O $PresentationAction$ O $PresentationAction$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O $any$ O $PresentationAction$ O $PresentationActions$ O O $any$ O $any$ O $PresentationActions.enable$ O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O $any$ O $PresentationAction$ O $PresentationActions$ O O $any$ O $any$ O $PresentationActions.disable$ O O O O O O O O
import { CANCEL_CURRENT_PROCESS , UPDATE_PROGRESS_INDICATOR , cancelCurrentProcess , updateProgressIndicator , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = { label : 's' , progress : 0 } ; const action = updateProgressIndicator ( payload ) ; expect ( action . type ) . toBe ( UPDATE_PROGRESS_INDICATOR ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = cancelCurrentProcess ( ) ; expect ( action . type ) . toBe ( CANCEL_CURRENT_PROCESS ) ; expect ( action . payload ) . toBe ( undefined ) ; } ) ; } ) ;	O O O O O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $complex$ O O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O $any$ O O O O $any$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorPayload$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<void>$ O O O $any$ O $ProgressIndicatorAction<void>$ O $any$ O O $any$ O O O O $any$ O $ProgressIndicatorAction<void>$ O $void$ O O $any$ O $undefined$ O O O O O O O O
import { setOpenUrl , SET_OPEN_URLS } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const openUrl = 's' ; const action = setOpenUrl ( openUrl ) ; expect ( action . type ) . toBe ( SET_OPEN_URLS ) ; expect ( action . payload ) . toEqual ( { openUrl } ) ; } ) ; } ) ;	O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O $any$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O $any$ O O O O $any$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolOpenUrlsPayload$ O O $any$ O O $string$ O O O O O O O O O
import { TRANSCRIPTS_UPDATED , TRANSCRIPTS_DIRECTORY_UPDATED , CHAT_FILES_UPDATED , CHATS_DIRECTORY_UPDATED , OPEN_CONTEXT_MENU_FOR_RESOURCE , EDIT_RESOURCE , RENAME_RESOURCE , OPEN_RESOURCE , OPEN_RESOURCE_SETTINGS , transcriptsUpdated , transcriptDirectoryUpdated , chatsDirectoryUpdated , chatFilesUpdated , openContextMenuForResource , editResource , renameResource , openResource , openResourcesSettings , } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const payload = [ { name : 's' , path : 's' } ] ; const action = transcriptsUpdated ( payload ) ; expect ( action . type ) . toBe ( TRANSCRIPTS_UPDATED ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const dir = 's' ; const action = transcriptDirectoryUpdated ( dir ) ; expect ( action . type ) . toBe ( TRANSCRIPTS_DIRECTORY_UPDATED ) ; expect ( action . payload ) . toBe ( dir ) ; } ) ; it ( 's' , ( ) => { const dir = 's' ; const action = chatsDirectoryUpdated ( dir ) ; expect ( action . type ) . toBe ( CHATS_DIRECTORY_UPDATED ) ; expect ( action . payload ) . toBe ( dir ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' , path : 's' } ] ; const action = chatFilesUpdated ( payload ) ; expect ( action . type ) . toBe ( CHAT_FILES_UPDATED ) ; expect ( action . payload ) . toBe ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = openContextMenuForResource ( payload ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_RESOURCE ) ; expect ( action . payload ) . toBe ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = editResource ( payload ) ; expect ( action . type ) . toBe ( EDIT_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = renameResource ( payload ) ; expect ( action . type ) . toBe ( RENAME_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' , path : 's' } ; const action = openResource ( payload ) ; expect ( action . type ) . toBe ( OPEN_RESOURCE ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const payload = { } ; const action = openResourcesSettings ( payload ) ; expect ( action . type ) . toBe ( OPEN_RESOURCE_SETTINGS ) ; expect ( action . payload ) . toEqual ( payload ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<string>$ O $ResourcesAction<any[]>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $ResourcesAction<ResourceSettingsPayload>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $complex$ O O $any$ O $ResourcesAction<any[]>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O $any$ O $ResourcesAction<string>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O $any$ O $ResourcesAction<string>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<string>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $complex$ O O $any$ O $ResourcesAction<any[]>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any[]>$ O $any[]$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $complex$ O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<any>$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O O O O O $ResourcesAction<ResourceSettingsPayload>$ O $ResourcesAction<ResourceSettingsPayload>$ O $any$ O O $any$ O $ResourcesAction<ResourceSettingsPayload>$ O $any$ O O $any$ O O O O $any$ O $ResourcesAction<ResourceSettingsPayload>$ O $ResourceSettingsPayload$ O O $any$ O $any$ O O O O O O O O
import { addSavedBotUrl , ADD_SAVED_BOT_URL } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( addSavedBotUrl ( 's' ) ) . toEqual ( { type : ADD_SAVED_BOT_URL , payload : 's' , } ) ; } ) ; } ) ;	O O $SavedBotUrlsAction<string>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SavedBotUrlsAction<string>$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O
import { switchTheme , SWITCH_THEME } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const themeName = 's' ; const themeComponents = [ 's' ] ; const action = switchTheme ( themeName , themeComponents ) ; expect ( action . type ) . toBe ( SWITCH_THEME ) ; expect ( action . payload ) . toEqual ( { themeName , themeComponents } ) ; } ) ; } ) ;	O O $ThemeAction<SwitchThemePayload>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $string[]$ O O O O O O $ThemeAction<SwitchThemePayload>$ O $ThemeAction<SwitchThemePayload>$ O O O $string[]$ O O $any$ O $ThemeAction<SwitchThemePayload>$ O O O O $any$ O O O O $any$ O $ThemeAction<SwitchThemePayload>$ O $SwitchThemePayload$ O O $any$ O O $string$ O $string[]$ O O O O O O O O O
import { UpdateStatus } from 's' ; import { setUpdateStatus , SET_UPDATE_STATUS } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( setUpdateStatus ( UpdateStatus . Idle ) ) . toEqual ( { type : SET_UPDATE_STATUS , payload : UpdateStatus . Idle } ) ; } ) ; } ) ;	O O $any$ O O O O O O $UpdateAction<any>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $UpdateAction<any>$ O $any$ O $any$ O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O O O
import { User } from 's' ; import * as userActions from 's' ; describe ( 's' , ( ) => { const user = { id : 's' , name : 's' , } ; const users = [ user ] ; test ( 's' , ( ) => { expect ( userActions . addUsers ( users ) ) . toEqual ( { type : userActions . ADD_USERS , payload : { users } , } ) ; } ) ; test ( 's' , ( ) => { expect ( userActions . removeUsers ( users ) ) . toEqual ( { type : userActions . REMOVE_USERS , payload : { users } , } ) ; } ) ; test ( 's' , ( ) => { expect ( userActions . setCurrentUser ( user ) ) . toEqual ( { type : userActions . SET_CURRENT_USER , payload : { user } , } ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O $any$ O O O O O O O O $User$ O O $string$ O O O $string$ O O O O O O $any[]$ O O $any$ O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any[]$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any[]$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any[]$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any[]$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $UserAction<UserPayload>$ O $any$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $any$ O O O O O O O O O O O
import { BotInfo } from 's' ; import { Action } from 's' ; export const OPEN_CONTEXT_MENU_FOR_BOT = 's' ; export interface WelcomePageAction < T > extends Action { payload : T ; } export function openContextMenuForBot ( bot ) < BotInfo > { return { type : OPEN_CONTEXT_MENU_FOR_BOT , payload : bot , } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $T$ O $any$ O O O O $WelcomePageAction$ O $BotInfo$ O O $any$ O O O O $string$ O O O $any$ O $any$ O O O O
import { openContextMenuForBot , OPEN_CONTEXT_MENU_FOR_BOT } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const bot = { } ; const action = openContextMenuForBot ( bot ) ; expect ( action . type ) . toBe ( OPEN_CONTEXT_MENU_FOR_BOT ) ; expect ( action . payload ) . toEqual ( bot ) ; } ) ; } ) ;	O O $WelcomePageAction<any>$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O $WelcomePageAction<any>$ O $WelcomePageAction<any>$ O $any$ O O $any$ O $WelcomePageAction<any>$ O $any$ O O $any$ O O O O $any$ O $WelcomePageAction<any>$ O $any$ O O $any$ O $any$ O O O O O O O O
import * as windowStateActions from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { expect ( windowStateActions . rememberTheme ( 's' ) ) . toEqual ( { type : windowStateActions . REMEMBER_THEME , payload : { theme : 's' , } , } ) ; } ) ; test ( 's' , ( ) => { const boundsState = { displayId : 0 , top : 0 , left : 0 , width : 0 , height : 0 , } ; expect ( windowStateActions . rememberBounds ( boundsState ) ) . toEqual ( { type : windowStateActions . REMEMBER_BOUNDS , payload : boundsState , } ) ; } ) ; test ( 's' , ( ) => { const zoomState = { zoomLevel : 0 } ; expect ( windowStateActions . rememberZoomLevel ( zoomState ) ) . toEqual ( { type : windowStateActions . REMEMBER_ZOOM_LEVEL , payload : zoomState , } ) ; } ) ; test ( 's' , ( ) => { const themes = [ { name : 's' , href : 's' } , { name : 's' , href : 's' } ] ; expect ( windowStateActions . setAvailableThemes ( themes ) ) . toEqual ( { type : windowStateActions . SET_AVAILABLE_THEMES , payload : { availableThemes : themes } , } ) ; } ) ; } ) ;	O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O O $string$ O $any$ O O O $complex$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O $any$ O $any$ O $WindowStateAction<RememberZoomLevelPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $WindowStateAction<SetAvailableThemesPayload>$ O $complex$ O O O $any$ O O $string$ O $any$ O O O $complex$ O O $complex$ O $complex$ O O O O O O O O O O O
import { getCurrentConversationId } from 's' ; let mockState = { bot : { } } ; jest . mock ( 's' , ( ) => ( { store : { getState : ( ) => mockState , } , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { mockState = { editor : undefined , } ; expect ( getCurrentConversationId ( ) ) . toBe ( 's' ) ; mockState = { chat : { chats : { 0 : { conversationId : 's' } , } , } , editor : { activeEditor : 's' , editors : { primary : { activeDocumentId : 's' , } , } , } , } ; expect ( getCurrentConversationId ( ) ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O ${}$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O $undefined$ O $undefined$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { SharedConstants } from 's' ; import { open } from 's' ; import { getOtherTabGroup , getTabGroupForDocument , hasNonGlobalTabs , showWelcomePage , tabGroupHasDocuments , } from 's' ; let mockState ; const mockDispatch = jest . fn ( ( ) => null ) ; const mockGetState = jest . fn ( ( ) => mockState ) ; const mockStore = { getState : mockGetState , dispatch : mockDispatch , } ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockState = { } ; mockGetState . mockClear ( ) ; mockDispatch . mockClear ( ) ; } ) ; test ( 's' , ( ) => { mockState = { editor : { editors : { primary : { documents : { 0 : { } , 0 : { isGlobal : true , } , } , } , secondary : { documents : { } , } , } , } , } ; let result = ! ! hasNonGlobalTabs ( ) ; expect ( result ) . toBe ( true ) ; result = ! ! hasNonGlobalTabs ( mockState . editor . editors ) ; expect ( result ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { mockState = { editor : { editors : { primary : { documents : { 0 : { } , 0 : { isGlobal : true , } , } , } , secondary : { documents : { } , } , } , } , } ; let result = getTabGroupForDocument ( 's' ) ; expect ( result ) . toBe ( 's' ) ; result = getTabGroupForDocument ( 's' , mockState . editor . editors ) ; expect ( result ) . toBe ( undefined ) ; } ) ; test ( 's' , ( ) => { expect ( getOtherTabGroup ( SharedConstants . EDITOR_KEY_PRIMARY ) ) . toBe ( SharedConstants . EDITOR_KEY_SECONDARY ) ; expect ( getOtherTabGroup ( SharedConstants . EDITOR_KEY_SECONDARY ) ) . toBe ( SharedConstants . EDITOR_KEY_PRIMARY ) ; } ) ; test ( 's' , ( ) => { showWelcomePage ( ) ; expect ( mockDispatch ) . toHaveBeenCalledWith ( open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_WELCOME_PAGE , documentId : SharedConstants . DocumentIds . DOCUMENT_ID_WELCOME_PAGE , isGlobal : true , } ) ) ; } ) ; test ( 's' , ( ) => { expect ( tabGroupHasDocuments ( { documents : { 0 : { } } } ) ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O O O O O O $OpenEditorAction$ O O O O O O $string$ O $string$ O $number$ O $void$ O $boolean$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O ${}$ O O O O $complex$ O O $boolean$ O O O O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O $boolean$ O O O $number$ O O O $any$ O $boolean$ O O $any$ O O O O $boolean$ O O O $number$ O $any$ O $any$ O $any$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O ${}$ O O O O $complex$ O O $boolean$ O O O O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O $string$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $void$ O O O $any$ O $any$ O O $any$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $true$ O O O O O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O ${}$ O O O O O O O O $any$ O O O O O O O O O O
import { forwardToRenderer } from 's' ; const mockEmulatorApplication = { mainBrowserWindow : { webContents : { send : jest . fn ( ( ) => null ) , } , } , } ; jest . mock ( 's' , ( ) => ( { get emulatorApplication ( ) { return mockEmulatorApplication ; } , } ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockEmulatorApplication . mainBrowserWindow . webContents . send . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { } ; forwardToRenderer ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockEmulatorApplication . mainBrowserWindow . webContents . send ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { type : 's' , meta : { doNotForward : true } , } ; forwardToRenderer ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockEmulatorApplication . mainBrowserWindow . webContents . send ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const mockNext = jest . fn ( ) ; const mockAction = { type : 's' , payload : { someProp : 0 } , } ; forwardToRenderer ( null ) ( mockNext ) ( mockAction ) ; expect ( mockNext ) . toHaveBeenCalledWith ( mockAction ) ; expect ( mockEmulatorApplication . mainBrowserWindow . webContents . send ) . toHaveBeenCalledWith ( 's' , mockAction ) ; } ) ; } ) ;	O O $any$ O O O O O $complex$ O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $complex$ O O $boolean$ O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O $complex$ O $any$ O O $any$ O O O $any$ O O O O O O O O
import { azureArmTokenDataChanged , invalidateArmToken } from 's' ; import { azureAuth , AzureAuthState } from 's' ; describe ( 's' , ( ) => { let startingState ; beforeEach ( ( ) => { startingState = { access_token : null , persistLogin : false , } ; } ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : undefined } ; const endingState = azureAuth ( startingState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = azureArmTokenDataChanged ( 's' ) ; const state = azureAuth ( startingState , action ) ; expect ( state . access_token ) . toEqual ( 's' ) ; } ) ; it ( 's' , ( ) => { const action = invalidateArmToken ( ) ; const state = azureAuth ( startingState , action ) ; expect ( state . access_token ) . toBe ( 's' ) ; } ) ; } ) ;	O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<{}>$ O O O O O O $AzureAuthState$ O $any$ O O O O $any$ O O O O O O O O $AzureAuthState$ O $any$ O O O O O $AzureAuthState$ O O $null$ O O O $false$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $null$ O O O $undefined$ O $undefined$ O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $complex$ O O $any$ O $AzureAuthState$ O O $any$ O $AzureAuthState$ O O O O O $any$ O O O O O O O O $AzureAuthAction<ArmTokenData>$ O $AzureAuthAction<ArmTokenData>$ O O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction<ArmTokenData>$ O O $any$ O $AzureAuthState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $AzureAuthAction<{}>$ O $AzureAuthAction<{}>$ O O O O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthState$ O $AzureAuthAction<{}>$ O O $any$ O $AzureAuthState$ O $string$ O O $any$ O O O O O O O O O O
import { combineReducers , createStore , Store } from 's' ; import { Settings } from 's' ; import { azureLoggedInUserChanged , azurePersistLoginChanged } from 's' ; import { azureAuthSettings } from 's' ; describe ( 's' , ( ) => { let store < Settings > ; beforeAll ( ( ) => { store = createStore ( combineReducers ( { azure : azureAuthSettings } ) ) ; } ) ; it ( 's' , ( ) => { expect ( JSON . stringify ( store . getState ( ) . azure ) ) . toBe ( JSON . stringify ( { } ) ) ; } ) ; it ( 's' , ( ) => { store . dispatch ( azurePersistLoginChanged ( true ) ) ; expect ( store . getState ( ) . azure . persistLogin ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { store . dispatch ( azureLoggedInUserChanged ( 's' ) ) ; expect ( store . getState ( ) . azure . signedInUser ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $AzureAuthAction<string>$ O $AzureAuthAction<boolean>$ O O O O O O $any$ O O O O $any$ O O O O O O O O $Store$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $JSON$ O $complex$ O $any$ O $any$ O O O $any$ O O O $any$ O $JSON$ O $complex$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<boolean>$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AzureAuthAction<string>$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { BotInfo } from 's' ; import { BotConfigWithPath } from 's' ; import { BotAction , load , setActive , setDirectory , close , mockAndSetActive } from 's' ; import { BotState , bot } from 's' ; describe ( 's' , ( ) => { let defaultState ; beforeEach ( ( ) => { defaultState = { activeBot : null , botFiles : [ ] , currentBotDirectory : null , } ; } ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... defaultState } ; const endingState = bot ( defaultState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const bots : BotInfo [ ] = [ { displayName : 's' , path : 's' , secret : null , } , { displayName : 's' , path : 's' , secret : 's' , } , { displayName : 's' , path : 's' , secret : null , } , null , ] ; const action = load ( bots ) ; const state = bot ( defaultState , action ) ; expect ( state . botFiles ) . not . toEqual ( bots ) ; expect ( state . botFiles . length ) . toBe ( 0 ) ; expect ( state . botFiles ) . toEqual ( [ { displayName : 's' , path : 's' , secret : null , } , { displayName : 's' , path : 's' , secret : 's' , } , { displayName : 's' , path : 's' , secret : null , } , ] ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const startingState = { ... defaultState , activeBot , } ; const action = close ( ) ; const state = bot ( startingState , action ) ; expect ( state . activeBot ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const action = setDirectory ( 's' ) ; const state = bot ( defaultState , action ) ; expect ( state . currentBotDirectory ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; expect ( defaultState . activeBot ) . toBe ( null ) ; const action = setActive ( activeBot ) ; const state = bot ( defaultState , action ) ; expect ( state . activeBot ) . toEqual ( activeBot ) ; expect ( state . activeBot . path ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , overrides : { endpoint : { endpoint : 's' , id : 's' , appId : 's' , appPassword : 's' , } , } , } ; const startingState = { ... defaultState , activeBot , } ; const newActiveBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const action = setActive ( newActiveBot ) ; const endingState = bot ( startingState , action ) ; expect ( endingState . activeBot . name ) . toBe ( 's' ) ; expect ( endingState . activeBot . overrides ) . toBeTruthy ( ) ; const endpointOverrides = endingState . activeBot . overrides . endpoint ; expect ( endpointOverrides . endpoint ) . toBe ( 's' ) ; expect ( endpointOverrides . id ) . toBe ( 's' ) ; expect ( endpointOverrides . appId ) . toBe ( 's' ) ; expect ( endpointOverrides . appPassword ) . toBe ( 's' ) ; } ) ; it ( "s" , ( ) => { const activeBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , overrides : { endpoint : { endpoint : 's' , id : 's' , appId : 's' , appPassword : 's' , } , } , } ; const startingState = { ... defaultState , activeBot , } ; const newActiveBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , } ; const action = setActive ( newActiveBot ) ; const endingState = bot ( startingState , action ) ; expect ( endingState . activeBot . name ) . toBe ( 's' ) ; expect ( endingState . activeBot . overrides ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const botMock = { name : 's' , description : 's' , padlock : null , path : 's' , services : [ ] , } ; const action = mockAndSetActive ( botMock ) ; const state = bot ( defaultState , action ) ; expect ( state . activeBot ) . not . toBe ( null ) ; expect ( state . activeBot . name ) . toBe ( 's' ) ; expect ( state . activeBot . description ) . toBe ( 's' ) ; expect ( state . activeBot . path ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $BotAction<LoadBotPayload>$ O $BotAction<SetActivePayload>$ O $BotAction<SetDirectoryPayload>$ O $BotAction<{}>$ O $BotAction<any>$ O O O O O O $any$ O $BotState$ O O O O $any$ O O O O O O O O $BotState$ O $any$ O O O O O $BotState$ O O $null$ O O O $undefined[]$ O O O O $null$ O O O O O O O O $any$ O O O O O O O O $BotAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $BotState$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<any>$ O O $any$ O $BotState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any[]$ O $any$ O O O O O $string$ O O O $string$ O O O $null$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $null$ O O O O O O O O O O $BotAction<LoadBotPayload>$ O $BotAction<LoadBotPayload>$ O $any[]$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<LoadBotPayload>$ O O $any$ O $BotState$ O $any[]$ O O $any$ O $any$ O $any[]$ O O $any$ O $BotState$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $BotState$ O $any[]$ O O $any$ O O O $string$ O O O $string$ O O O $null$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $null$ O O O O O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotAction<{}>$ O $BotAction<{}>$ O O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<{}>$ O O $any$ O $BotState$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotAction<SetDirectoryPayload>$ O $BotAction<SetDirectoryPayload>$ O O O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetDirectoryPayload>$ O O $any$ O $BotState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O $any$ O $BotState$ O $any$ O O $any$ O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $BotState$ O O O $BotState$ O $any$ O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $BotAction<SetActivePayload>$ O $BotAction<SetActivePayload>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<SetActivePayload>$ O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $string$ O O O $undefined[]$ O O O O O O O $BotAction<any>$ O $BotAction<any>$ O $any$ O O O $BotState$ O $BotState$ O $BotState$ O $BotAction<any>$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotState$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { LogEntry , LogItemType } from 's' ; import { addTranscript , appendToLog , ChatAction , clearLog , clearTranscripts , closeDocument , newChat , newConversation , removeTranscript , setInspectorObjects , updateChat , } from 's' ; import { closeNonGlobalTabs } from 's' ; import { chat , ChatState } from 's' ; describe ( 's' , ( ) => { const testChatId = 's' ; const DEFAULT_STATE = { changeKey : 0 , chats : { [ testChatId ] : { log : { entries : [ ] , } , } , } , transcripts : [ ] , } as any ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = chat ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = addTranscript ( 's' ) ; const state = chat ( DEFAULT_STATE , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . transcripts [ 0 ] ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , addTranscript ( 's' ) ) ; state = chat ( state , addTranscript ( 's' ) ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; const action = removeTranscript ( 's' ) ; state = chat ( state , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . transcripts ) . not . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , addTranscript ( 's' ) ) ; state = chat ( state , addTranscript ( 's' ) ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; const action = clearTranscripts ( ) ; state = chat ( state , action ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const newChatName = 's' ; const action = newChat ( newChatName , 's' ) ; const state = chat ( DEFAULT_STATE , action ) ; expect ( state . changeKey ) . toBe ( 0 ) ; expect ( state . chats [ newChatName ] ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let state = chat ( DEFAULT_STATE , newChat ( testChatId , 's' ) ) ; const action = closeDocument ( testChatId ) ; state = chat ( DEFAULT_STATE , action ) ; expect ( state . chats [ testChatId ] ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const action = newConversation ( testChatId , { testing : true } ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { } , } , } ; const endingState = chat ( startingState , action ) ; const expectedDoc = { ... endingState . chats [ testChatId ] , testing : true , } ; expect ( endingState . chats [ testChatId ] ) . toEqual ( expectedDoc ) ; } ) ; it ( 's' , ( ) => { const logEntry = { timestamp : 0 , items : [ { type : LogItemType . Text , payload : { level : 0 , text : 's' , } , } , ] , } ; const action = appendToLog ( testChatId , logEntry ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { log : { entries : [ ] , } , } , } , } ; const endingState = chat ( startingState , action ) ; expect ( endingState . chats [ testChatId ] . log . entries [ 0 ] ) . toBeTruthy ( ) ; expect ( endingState . chats [ testChatId ] . log . entries [ 0 ] ) . toEqual ( logEntry ) ; } ) ; it ( 's' , ( ) => { const logEntry = { timestamp : 0 , items : [ { type : LogItemType . Text , payload : { level : 0 , text : 's' , } , } , ] , } ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { log : { entries : [ ] , } , } , } , } ; let state = chat ( startingState , appendToLog ( testChatId , logEntry ) ) ; expect ( state . chats [ testChatId ] . log . entries . length ) . toBeGreaterThan ( 0 ) ; const action = clearLog ( testChatId ) ; state = chat ( state , action ) ; expect ( state . chats [ testChatId ] . log . entries . length ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const action = setInspectorObjects ( testChatId , { testing : true } ) ; const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , [ testChatId ] : { } , } , } ; const endingState = chat ( startingState , action ) ; expect ( endingState . chats [ testChatId ] . inspectorObjects . length ) . toBeGreaterThan ( 0 ) ; expect ( endingState . chats [ testChatId ] . inspectorObjects [ 0 ] ) . toEqual ( { testing : true , } ) ; } ) ; it ( 's' , ( ) => { const tempChat = 's' ; const alteredState = { changeKey : 0 , chats : { [ tempChat ] : { testing : true , } , } , transcripts : [ 's' , 's' , 's' ] , } as any ; const action = closeNonGlobalTabs ( ) ; const state = chat ( alteredState , action ) ; expect ( state . changeKey ) . toBe ( 0 ) ; expect ( state . transcripts . length ) . toBe ( 0 ) ; expect ( state . chats [ tempChat ] ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... DEFAULT_STATE , chats : { ... DEFAULT_STATE . chats , 0 : { id : 's' , userId : 's' , } , } , } ; const action = updateChat ( 's' , { id : 's' , userId : 's' , } ) ; const state = chat ( startingState , action ) ; expect ( state . chats . 0 . id ) . toBe ( 's' ) ; expect ( state . chats . 0 . userId ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AppendLogPayload>$ O $any$ O $ChatAction<ClearLogPayload>$ O $ChatAction<{}>$ O $ChatAction<DocumentIdPayload>$ O $complex$ O $ChatAction<NewConversationPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<UpdateChatPayload>$ O O O O O O O $CloseAllEditorAction$ O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O $ChatState$ O O $number$ O O O $complex$ O O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O $undefined[]$ O O O O O O O O $any$ O O O O O O O O $ChatAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $ChatState$ O O O $ChatState$ O O O $ChatState$ O $ChatAction<any>$ O O $any$ O $ChatState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ChatAction<AddTranscriptPayload>$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O $ChatAction<RemoveTranscriptPayload>$ O $ChatAction<RemoveTranscriptPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<RemoveTranscriptPayload>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $ChatState$ O O O $ChatState$ O $ChatAction<AddTranscriptPayload>$ O O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O $ChatAction<{}>$ O $ChatAction<{}>$ O O O $ChatState$ O O O $ChatState$ O $ChatAction<{}>$ O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O O O O $ChatState$ O O O $ChatState$ O $complex$ O O $any$ O $ChatState$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $ChatState$ O O O $ChatState$ O $complex$ O O O O O O O O $ChatAction<DocumentIdPayload>$ O $ChatAction<DocumentIdPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<DocumentIdPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $ChatAction<NewConversationPayload>$ O $ChatAction<NewConversationPayload>$ O O O O $boolean$ O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<NewConversationPayload>$ O O O O O O O $ChatState$ O $complex$ O O O O $boolean$ O O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $LogEntry$ O O $number$ O O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $string$ O O O O O O O O O O O O $ChatAction<AppendLogPayload>$ O $ChatAction<AppendLogPayload>$ O O O $any$ O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<AppendLogPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O O O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $LogEntry$ O O $number$ O O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $string$ O O O O O O O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<AppendLogPayload>$ O O O $any$ O O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O $number$ O O $any$ O O O O O $ChatAction<ClearLogPayload>$ O $ChatAction<ClearLogPayload>$ O O O O $ChatState$ O O O $ChatState$ O $ChatAction<ClearLogPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $ChatLog$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $ChatAction<SetInspectorObjectsPayload>$ O $ChatAction<SetInspectorObjectsPayload>$ O O O O $boolean$ O O O O O O O O O O $ChatState$ O $complex$ O O O $ChatState$ O $complex$ O O O O O O O O O O O O O $ChatState$ O O O O O $ChatAction<SetInspectorObjectsPayload>$ O O $any$ O $ChatState$ O $complex$ O O O O $any[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O $any[]$ O O O O O $any$ O O $boolean$ O O O O O O O O O $any$ O O O O O O O O O O O O O $ChatState$ O O $number$ O O O $complex$ O O O O O O O $boolean$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O O $ChatState$ O O O $ChatState$ O $CloseAllEditorAction$ O O $any$ O $ChatState$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $ChatState$ O O O O O $ChatState$ O $complex$ O $complex$ O O $string$ O O O $string$ O O O O O O O O O O $ChatAction<UpdateChatPayload>$ O $ChatAction<UpdateChatPayload>$ O O O O $string$ O O O $string$ O O O O O O O $ChatState$ O O O O O $ChatAction<UpdateChatPayload>$ O O $any$ O $ChatState$ O $complex$ O $any$ O $any$ O O $any$ O O O O $any$ O $ChatState$ O $complex$ O $any$ O $string$ O O $any$ O O O O O O O O O O
import { clientAwareSettingsChanged } from 's' ; import { clientAwareSettings } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( clientAwareSettings ( undefined , { type : 's' } as any ) ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const mockSettings = { someSetting : 0 } ; const action = clientAwareSettingsChanged ( mockSettings ) ; const state = clientAwareSettings ( { } as any , action ) ; expect ( state ) . toEqual ( mockSettings ) ; } ) ; } ) ;	O O $ClientAwareSettingsActions$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $ClientAwareSettingsActions$ O $ClientAwareSettingsActions$ O $any$ O O O $any$ O $any$ O O O O O O $ClientAwareSettingsActions$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { DialogAction , setShowing } from 's' ; import { dialog , DialogState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { showing : false , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = dialog ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = setShowing ( true ) ; const state = dialog ( DEFAULT_STATE , action ) ; expect ( state . showing ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $SetShowingDialogAction$ O O O O O O $DialogState$ O $any$ O O O O $any$ O O O O O O O O $DialogState$ O O $false$ O O O O O $any$ O O O O O O O O $DialogAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $DialogState$ O O O $DialogState$ O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O O $any$ O $DialogState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $DialogAction$ O $SetShowingDialogAction$ O O O O O $DialogState$ O $DialogState$ O $DialogState$ O $SetShowingDialogAction$ O O $any$ O $DialogState$ O $boolean$ O O $any$ O O O O O O O O O O
import { deepCopySlow , SharedConstants } from 's' ; import { addDocPendingChange , appendTab , close , closeNonGlobalTabs , dropTabOnLeftOverlay , EditorAction , open , removeDocPendingChange , setActiveEditor as setActiveEditorAction , setActiveTab , setDirtyFlag , splitTab , swapTabs , toggleDraggingTab , updateDocument , } from 's' ; import { editor , Editor , EditorState , fixupTabGroups , removeDocumentFromTabGroup , setActiveEditor , setDraggingTab , setEditorState , setNewPrimaryEditor , } from 's' ; jest . mock ( 's' , ( ) => ( { store : { getState : ( ) => ( { bot : { botFiles : [ ] , } , } ) , } , } ) ) ; let defaultState ; const { EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY } = SharedConstants ; describe ( 's' , ( ) => { beforeEach ( initializeDefaultState ) ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... defaultState } ; const endingState = editor ( defaultState , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , draggingTab : true , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , tabOrder : [ 's' , 's' ] , } , } , } ; const srcEditorKey = EDITOR_KEY_PRIMARY ; const destEditorKey = EDITOR_KEY_PRIMARY ; const docIdToAppend = 's' ; const action = appendTab ( srcEditorKey , destEditorKey , docIdToAppend ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . tabOrder [ 0 ] ) . not . toBe ( docIdToAppend ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . tabOrder [ 0 ] ) . toBe ( docIdToAppend ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , tabOrder : [ 's' , 's' ] , recentTabs : [ 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = EDITOR_KEY_PRIMARY ; const destEditorKey = EDITOR_KEY_SECONDARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const srcEditor = endingState . editors [ srcEditorKey ] ; const destEditor = endingState . editors [ destEditorKey ] ; expect ( Object . keys ( destEditor . documents ) ) . toContain ( 's' ) ; expect ( destEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( destEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( Object . keys ( srcEditor . documents ) ) . not . toContain ( 's' ) ; expect ( srcEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( srcEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = EDITOR_KEY_SECONDARY ; const destEditorKey = EDITOR_KEY_PRIMARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const srcEditorKey = EDITOR_KEY_PRIMARY ; const destEditorKey = EDITOR_KEY_SECONDARY ; const action = appendTab ( srcEditorKey , destEditorKey , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . tabOrder ) . toEqual ( [ ] ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const editorKey = EDITOR_KEY_PRIMARY ; const action = close ( editorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const modifiedEditor = endingState . editors [ editorKey ] ; expect ( Object . keys ( modifiedEditor . documents ) ) . not . toContain ( 's' ) ; expect ( modifiedEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( modifiedEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const editorKey = EDITOR_KEY_PRIMARY ; const action = close ( editorKey , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( Object . keys ( endingState . editors [ EDITOR_KEY_SECONDARY ] . documents ) ) . not . toContain ( 's' ) ; } ) ; } ) ; it ( 's' , ( ) => { const action = toggleDraggingTab ( true ) ; const state = editor ( defaultState , action ) ; expect ( state . draggingTab ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , } ; const action = setActiveEditorAction ( EDITOR_KEY_PRIMARY ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = setActiveTab ( 's' ) ; const endingState = editor ( startingState , action ) ; const newActiveEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( newActiveEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( newActiveEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( "s" , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { dirty : false } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const dirtyDocId = 's' ; const action = setDirtyFlag ( dirtyDocId , true ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . documents [ dirtyDocId ] . dirty ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { isGlobal : true } , 0 : { isGlobal : false } , 0 : { isGlobal : false } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { isGlobal : false } , 0 : { isGlobal : true } , 0 : { isGlobal : true } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , } , docsWithPendingChanges : [ 's' , 's' ] , } ; const action = closeNonGlobalTabs ( ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( endingState . docsWithPendingChanges ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { documentId : 's' } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const docToUpdateId = 's' ; const action = updateDocument ( docToUpdateId , { isGlobal : true , dirty : true , } ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . documents [ docToUpdateId ] ) . toEqual ( { documentId : 's' , isGlobal : true , dirty : true , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_SECONDARY ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; } ) ; it ( "s" , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = open ( { contentType : SharedConstants . ContentTypes . CONTENT_TYPE_APP_SETTINGS , documentId : 's' , isGlobal : true , } ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; } ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , draggingTab : true , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = splitTab ( SharedConstants . ContentTypes . CONTENT_TYPE_APP_SETTINGS , 's' , EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( Object . keys ( primaryEditor . documents ) ) . not . toContain ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toContain ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( endingState . draggingTab ) . toBe ( false ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , } , } ; const action = swapTabs ( EDITOR_KEY_PRIMARY , EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , } , } ; const action = swapTabs ( EDITOR_KEY_SECONDARY , EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_SECONDARY ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' , 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . not . toContain ( 's' ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , documents : { 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' ] , tabOrder : [ 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = swapTabs ( EDITOR_KEY_SECONDARY , EDITOR_KEY_PRIMARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const action = swapTabs ( EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY , 's' , 's' ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( null ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ ] ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , docsWithPendingChanges : [ 's' , 's' , 's' ] , } ; const 0 = addDocPendingChange ( 's' ) ; const 0 = editor ( startingState , 0 ) ; expect ( 0 . docsWithPendingChanges ) . toEqual ( [ 's' , 's' , 's' , 's' ] ) ; const 0 = addDocPendingChange ( 's' ) ; const 0 = editor ( 0 , 0 ) ; expect ( 0 . docsWithPendingChanges ) . toEqual ( [ 's' , 's' , 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , docsWithPendingChanges : [ 's' , 's' , 's' ] , } ; const action = removeDocPendingChange ( 's' ) ; const endingState = editor ( startingState , action ) ; expect ( endingState . docsWithPendingChanges ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( initializeDefaultState ) ; it ( 's' , ( ) => { let state = setDraggingTab ( true , defaultState ) ; expect ( state . draggingTab ) . toBe ( true ) ; state = setDraggingTab ( false , state ) ; expect ( state . draggingTab ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_SECONDARY ] : { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } , } , } ; const newPrimaryEditor = { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const endingState = setNewPrimaryEditor ( newPrimaryEditor , startingState ) ; expect ( endingState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . activeDocumentId ) . toEqual ( 's' ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( endingState . editors [ EDITOR_KEY_PRIMARY ] . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( endingState . editors [ EDITOR_KEY_PRIMARY ] . documents ) ) . toContain ( 's' ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . activeDocumentId ) . toBe ( null ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . documents ) . toEqual ( { } ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . recentTabs ) . toEqual ( [ ] ) ; expect ( endingState . editors [ EDITOR_KEY_SECONDARY ] . tabOrder ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const newState = setActiveEditor ( 's' , defaultState ) ; expect ( newState ) . not . toBe ( defaultState ) ; expect ( newState . activeEditor ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const updatedEditor = { activeDocumentId : 's' , documents : { } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const newState = setEditorState ( EDITOR_KEY_PRIMARY , updatedEditor , defaultState ) ; expect ( newState ) . not . toBe ( defaultState ) ; expect ( newState . editors [ EDITOR_KEY_PRIMARY ] . activeDocumentId ) . toBe ( 's' ) ; expect ( newState . editors [ EDITOR_KEY_PRIMARY ] . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( newState . editors [ EDITOR_KEY_PRIMARY ] . recentTabs ) . toEqual ( [ 's' ] ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const docToRemove = 's' ; const tempEditor = { activeDocumentId : docToRemove , documents : { [ docToRemove ] : { } , 0 : { } , } , tabOrder : [ docToRemove , 's' ] , recentTabs : [ docToRemove , 's' ] , } ; const modifiedEditor = removeDocumentFromTabGroup ( tempEditor , docToRemove ) ; expect ( modifiedEditor ) . not . toBe ( tempEditor ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( modifiedEditor . recentTabs ) . not . toContain ( docToRemove ) ; expect ( modifiedEditor . tabOrder ) . not . toContain ( docToRemove ) ; expect ( Object . keys ( modifiedEditor . documents ) ) . not . toContain ( docToRemove ) ; } ) ; it ( 's' , ( ) => { const tempEditor = { activeDocumentId : 's' , documents : { 0 : { } , } , tabOrder : [ 's' ] , recentTabs : [ 's' ] , } ; const modifiedEditor = removeDocumentFromTabGroup ( tempEditor , 's' ) ; expect ( modifiedEditor . activeDocumentId ) . toBe ( null ) ; expect ( modifiedEditor . documents ) . toEqual ( { } ) ; expect ( modifiedEditor . recentTabs ) . toEqual ( [ ] ) ; expect ( modifiedEditor . tabOrder ) . toEqual ( [ ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; const primaryEditor = endState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( endState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toContain ( 's' ) ; expect ( primaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( primaryEditor . tabOrder ) . toEqual ( [ 's' ] ) ; expect ( primaryEditor . recentTabs ) . toEqual ( [ 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( null ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ ] ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_SECONDARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : null , documents : { } , recentTabs : [ ] , tabOrder : [ ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; expect ( endState . activeEditor ) . toBe ( EDITOR_KEY_PRIMARY ) ; } ) ; it ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { ... defaultState . editors , [ EDITOR_KEY_PRIMARY ] : { ... defaultState . editors [ EDITOR_KEY_PRIMARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { ... defaultState . editors [ EDITOR_KEY_SECONDARY ] , activeDocumentId : 's' , documents : { 0 : { } , } , recentTabs : [ 's' ] , tabOrder : [ 's' ] , } , } , } ; const endState = fixupTabGroups ( startingState ) ; expect ( endState ) . toEqual ( startingState ) ; } ) ; } ) ; test ( 's' , ( ) => { const startingState = { ... defaultState , activeEditor : EDITOR_KEY_PRIMARY , editors : { [ EDITOR_KEY_PRIMARY ] : { activeDocumentId : 's' , documents : { 0 : { } , 0 : { } , 0 : { } , } , recentTabs : [ 's' , 's' , 's' ] , tabOrder : [ 's' , 's' , 's' ] , } , [ EDITOR_KEY_SECONDARY ] : { } , } , } ; const tabIdToDrop = 's' ; const action = dropTabOnLeftOverlay ( tabIdToDrop ) ; const endingState = editor ( startingState , action ) ; const primaryEditor = endingState . editors [ EDITOR_KEY_PRIMARY ] ; const secondaryEditor = endingState . editors [ EDITOR_KEY_SECONDARY ] ; expect ( primaryEditor . activeDocumentId ) . toBe ( tabIdToDrop ) ; expect ( primaryEditor . recentTabs ) . toHaveLength ( 0 ) ; expect ( primaryEditor . recentTabs [ 0 ] ) . toBe ( tabIdToDrop ) ; expect ( primaryEditor . tabOrder ) . toHaveLength ( 0 ) ; expect ( primaryEditor . tabOrder [ 0 ] ) . toBe ( tabIdToDrop ) ; expect ( Object . keys ( primaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( primaryEditor . documents [ tabIdToDrop ] ) . toBeTruthy ( ) ; expect ( secondaryEditor . activeDocumentId ) . toBe ( 's' ) ; expect ( secondaryEditor . recentTabs ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . recentTabs ) . toEqual ( [ 's' , 's' ] ) ; expect ( secondaryEditor . tabOrder ) . toHaveLength ( 0 ) ; expect ( secondaryEditor . tabOrder ) . toEqual ( [ 's' , 's' ] ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toHaveLength ( 0 ) ; expect ( Object . keys ( secondaryEditor . documents ) ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ; function initializeDefaultState ( ) { const DEFAULT_STATE = { activeEditor : null , draggingTab : false , editors : { [ EDITOR_KEY_PRIMARY ] : { activeDocumentId : null , documents : { } , tabOrder : [ ] , recentTabs : [ ] , } , [ EDITOR_KEY_SECONDARY ] : { activeDocumentId : null , documents : { } , tabOrder : [ ] , recentTabs : [ ] , } , } , docsWithPendingChanges : [ ] , } ; defaultState = deepCopySlow ( DEFAULT_STATE ) ; }	O O $any$ O $any$ O O O O O O $AddDocPendingChangeAction$ O $AppendTabAction$ O $CloseEditorAction$ O $CloseAllEditorAction$ O $DropTabOnLeftOverlayAction$ O $any$ O $OpenEditorAction$ O $RemoveDocPendingChangeAction$ O $SetActiveEditorAction$ O $SetActiveEditorAction$ O $SetActiveTabAction$ O $SetDirtyFlagAction$ O $SplitTabAction$ O $SwapTabsAction$ O $ToggleDraggingTabAction$ O $UpdateDocumentAction$ O O O O O O O O O $any$ O $any$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $undefined[]$ O O O O O O O O O O O O O O O O $EditorState$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $EditorAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $EditorState<any>$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $EditorAction$ O O $any$ O $EditorState<any>$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $true$ O O O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $AppendTabAction$ O $AppendTabAction$ O $any$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O O O O $any$ O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O O O O $any$ O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $AppendTabAction$ O $AppendTabAction$ O $any$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $AppendTabAction$ O $AppendTabAction$ O $any$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $AppendTabAction$ O $AppendTabAction$ O $any$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AppendTabAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $any$ O $any$ O O $CloseEditorAction$ O $CloseEditorAction$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O O $CloseEditorAction$ O $CloseEditorAction$ O $any$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $ToggleDraggingTabAction$ O $ToggleDraggingTabAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $ToggleDraggingTabAction$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O O O O $SetActiveEditorAction$ O $SetActiveEditorAction$ O $any$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetActiveEditorAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SetActiveTabAction$ O $SetActiveTabAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetActiveTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O $complex$ O O $false$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O $SetDirtyFlagAction$ O $SetDirtyFlagAction$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SetDirtyFlagAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O $complex$ O O $true$ O O O O $complex$ O O $false$ O O O O $complex$ O O $false$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O $complex$ O O $false$ O O O O $complex$ O O $true$ O O O O $complex$ O O $true$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O O $string[]$ O O O O O O O O O O $CloseAllEditorAction$ O $CloseAllEditorAction$ O O O O $EditorState<any>$ O O O $EditorState<any>$ O $CloseAllEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O $complex$ O O $string$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O $UpdateDocumentAction$ O $UpdateDocumentAction$ O O O O $true$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $UpdateDocumentAction$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O O O $any$ O O $string$ O O O $boolean$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $OpenEditorAction$ O $OpenEditorAction$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $true$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $OpenEditorAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O $true$ O O O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SplitTabAction$ O $SplitTabAction$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $EditorState<any>$ O O O $EditorState<any>$ O $SplitTabAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O $any$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O $any$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O $any$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $SwapTabsAction$ O $SwapTabsAction$ O $any$ O $any$ O O O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $SwapTabsAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string[]$ O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AddDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O $AddDocPendingChangeAction$ O $AddDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $AddDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $string[]$ O O O O O O O O O O O O $RemoveDocPendingChangeAction$ O $RemoveDocPendingChangeAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $RemoveDocPendingChangeAction$ O O $any$ O $EditorState<any>$ O $string[]$ O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $Editor$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $Editor<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $complex$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O O O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $Editor$ O O $string$ O O O ${}$ O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $any$ O $Editor<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O $any$ O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O $any$ O $EditorState<any>$ O $complex$ O $any$ O O $string[]$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $Editor$ O O $string$ O O O O O O O O O O O O O ${}$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O $Editor<any>$ O $Editor<any>$ O $Editor<any>$ O O O O $any$ O $Editor<any>$ O O $any$ O $any$ O $Editor<any>$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Editor$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $Editor<any>$ O $Editor<any>$ O $Editor<any>$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $complex$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O ${}$ O O O $EditorState<any>$ O $complex$ O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O O O O $EditorState<any>$ O $complex$ O $any$ O O $string$ O O O O O O ${}$ O O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O O O O $EditorState<any>$ O $EditorState<any>$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O $any$ O $EditorState<any>$ O O O O O O O O $any$ O O O O O O O O $EditorState$ O O O $EditorState<any>$ O $any$ O $any$ O O O O O $any$ O O O $string$ O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O $DropTabOnLeftOverlayAction$ O $DropTabOnLeftOverlayAction$ O O O O O $EditorState<any>$ O O O $EditorState<any>$ O $DropTabOnLeftOverlayAction$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O O $Editor<any>$ O $EditorState<any>$ O $complex$ O $any$ O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O O O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $Editor<any>$ O $complex$ O O O O O $any$ O O O $any$ O $Editor<any>$ O $string$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O $any$ O $Editor<any>$ O $string[]$ O O $any$ O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $Editor<any>$ O $complex$ O O O $any$ O O O O O O O O O O O O O O O $void$ O O O O $EditorState$ O O $null$ O O O $false$ O O O $complex$ O O O $any$ O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $any$ O O O $null$ O O O ${}$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O $undefined[]$ O O O O O O $EditorState<any>$ O $any$ O $EditorState<any>$ O O O
import { ExplorerAction , showExplorer } from 's' ; import { explorer , ExplorerState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { showing : false , sortSelectionByPanelId : { } , } ; it ( 's' , ( ) => { const emptyAction < any > = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = explorer ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action < any > = showExplorer ( true ) ; const state = explorer ( DEFAULT_STATE , action ) ; expect ( state . showing ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $ExplorerAction<ExplorerPayload>$ O O O O O O $ExplorerState$ O $any$ O O O O $any$ O O O O O O O O $ExplorerState$ O O $false$ O O O ${}$ O O O O O O $any$ O O O O O O O O $ExplorerAction$ O O O O O $null$ O O O $null$ O O O O O $complex$ O O O $ExplorerState$ O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction<any>$ O O $any$ O $ExplorerState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ExplorerAction$ O O O O $ExplorerAction<ExplorerPayload>$ O O O O O $ExplorerState$ O $ExplorerState$ O $ExplorerState$ O $ExplorerAction<any>$ O O $any$ O $ExplorerState$ O $boolean$ O O $any$ O O O O O O O O O O
import { frameworkDefault } from 's' ; import { setFrameworkSettings } from 's' ; import { framework } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = framework ( undefined , { type : 's' } as any ) ; expect ( state ) . toEqual ( frameworkDefault ) ; } ) ; it ( 's' , ( ) => { const mockSettings = { someSetting : 0 } ; const action = setFrameworkSettings ( mockSettings ) ; const state = framework ( { } as any , action ) ; expect ( state ) . toEqual ( mockSettings ) ; } ) ; } ) ;	O O $any$ O O O O O O $FrameworkAction<any>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $FrameworkAction<any>$ O $FrameworkAction<any>$ O $any$ O O O $any$ O $any$ O O O O O O $FrameworkAction<any>$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { NavBarAction , select } from 's' ; import { navBar , NavBarState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { selection : null , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = navBar ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = select ( 's' ) ; const state = navBar ( DEFAULT_STATE , action ) ; expect ( state . selection ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O $SelectNavBarAction$ O O O O O O $NavBarState$ O $any$ O O O O $any$ O O O O O O O O $NavBarState$ O O $null$ O O O O O $any$ O O O O O O O O $NavBarAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $NavBarState$ O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $SelectNavBarAction$ O O $any$ O $NavBarState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $NavBarAction$ O $SelectNavBarAction$ O O O O O $NavBarState$ O $NavBarState$ O $NavBarState$ O $SelectNavBarAction$ O O $any$ O $NavBarState$ O $string$ O O $any$ O O O O O O O O O O
import { newNotification } from 's' ; import { finishAdd , finishRemove , finishClear , NotificationAction } from 's' ; import notification , { NotificationState } from 's' ; describe ( 's' , ( ) => { let defaultState ; beforeEach ( ( ) => { defaultState = { allIds : [ ] , } ; } ) ; test ( 's' , ( ) => { const action = { type : null , payload : { } } ; const endingState = notification ( defaultState , action ) ; expect ( endingState ) . toEqual ( defaultState ) ; } ) ; test ( 's' , ( ) => { const 0 = newNotification ( 's' ) ; const action = finishAdd ( 0 ) ; let endingState = notification ( defaultState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === 0 . id ) ) . toBe ( true ) ; endingState = notification ( endingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === 0 . id ) ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const idToRemove = 's' ; const startingState = { allIds : [ idToRemove , 's' ] , } ; const action = finishRemove ( idToRemove ) ; let endingState = notification ( startingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === idToRemove ) ) . toBe ( false ) ; endingState = notification ( endingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; expect ( endingState . allIds . some ( id => id === idToRemove ) ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const startingState = { allIds : [ 's' , 's' , 's' ] , } ; const action = finishClear ( ) ; const endingState = notification ( startingState , action ) ; expect ( endingState . allIds . length ) . toBe ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $FinishAddNotificationAction$ O $FinishRemoveNotificationAction$ O $FinishClearNotificationAction$ O $any$ O O O O O $NotificationState$ O O $any$ O O O O $any$ O O O O O O O O $NotificationState$ O $any$ O O O O O $NotificationState$ O O $undefined[]$ O O O O O O O O O $any$ O O O O O O O O $NotificationAction$ O O $null$ O O O ${}$ O O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $complex$ O O $any$ O $NotificationState$ O O $any$ O $NotificationState$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $NotificationAction$ O $FinishAddNotificationAction$ O $any$ O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishAddNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O $any$ O O O $any$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishAddNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $NotificationState$ O O $string[]$ O O O O O O O O O O $NotificationAction$ O $FinishRemoveNotificationAction$ O O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishRemoveNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O O O O O $any$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishRemoveNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $NotificationState$ O $string[]$ O $boolean$ O $string$ O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $NotificationState$ O O $string[]$ O O O O O O O O O O O O $NotificationAction$ O $FinishClearNotificationAction$ O O O O $NotificationState$ O $NotificationState$ O $NotificationState$ O $FinishClearNotificationAction$ O O $any$ O $NotificationState$ O $string[]$ O $number$ O O $any$ O O O O O O O O O O
import { disable , enable , PresentationAction } from 's' ; import { presentation , PresentationState } from 's' ; describe ( 's' , ( ) => { const DEFAULT_STATE = { enabled : null , } ; it ( 's' , ( ) => { const emptyAction = { type : null , payload : null } ; const startingState = { ... DEFAULT_STATE } ; const endingState = presentation ( DEFAULT_STATE , emptyAction ) ; expect ( endingState ) . toEqual ( startingState ) ; } ) ; it ( 's' , ( ) => { const action = disable ( ) ; const state = presentation ( DEFAULT_STATE , action ) ; expect ( state . enabled ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const action = enable ( ) ; const state = presentation ( DEFAULT_STATE , action ) ; expect ( state . enabled ) . toBe ( true ) ; } ) ; } ) ;	O O $PresentationAction$ O $PresentationAction$ O $any$ O O O O O O $PresentationState$ O $any$ O O O O $any$ O O O O O O O O $PresentationState$ O O $null$ O O O O O $any$ O O O O O O O O $PresentationAction$ O O $null$ O O O $null$ O O O O O $complex$ O O O $PresentationState$ O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $PresentationAction$ O $PresentationAction$ O O O O $PresentationState$ O $PresentationState$ O $PresentationState$ O $PresentationAction$ O O $any$ O $PresentationState$ O $boolean$ O O $any$ O O O O O O O O O O
import { cancelCurrentProcess , updateProgressIndicator } from 's' ; import { initialState , progressIndicator } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = progressIndicator ( undefined , { type : 's' } as any ) ; expect ( state ) . toEqual ( initialState ) ; } ) ; it ( 's' , ( ) => { const payload = { label : 's' , progress : 0 } ; const action = updateProgressIndicator ( payload ) ; const state = progressIndicator ( { } as any , action ) ; expect ( state ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const state = progressIndicator ( { } as any , cancelCurrentProcess ( ) as any ) ; expect ( state ) . toEqual ( { canceled : true } ) ; } ) ; } ) ;	O O $ProgressIndicatorAction<void>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O $undefined$ O O $string$ O O O O O O O $any$ O $ProgressIndicatorState$ O O $any$ O $ProgressIndicatorState$ O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $number$ O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O $any$ O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O O O $ProgressIndicatorAction<ProgressIndicatorPayload>$ O O $any$ O $ProgressIndicatorState$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $ProgressIndicatorState$ O $ProgressIndicatorState$ O O O O O O $ProgressIndicatorAction<void>$ O O O O O O $any$ O $ProgressIndicatorState$ O O $any$ O O $boolean$ O O O O O O O O O O O
import { setOpenUrl } from 's' ; import { protocol , ProtocolState } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( protocol ( undefined , { type : 's' } as any ) ) . toEqual ( { openUrls : [ ] } ) ; } ) ; it ( 's' , ( ) => { const initialState = { openUrls : [ 's' ] } ; const action = setOpenUrl ( 's' ) ; const state = protocol ( initialState , action ) ; expect ( state ) . toEqual ( { openUrls : [ 's' , 's' ] } ) ; } ) ; } ) ;	O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O O $ProtocolState$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ProtocolState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $undefined[]$ O O O O O O O O O $any$ O O O O O O O O $ProtocolState$ O O $string[]$ O O O O O O O $ProtocolAction<ProtocolOpenUrlsPayload>$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O O O O $ProtocolState$ O $ProtocolState$ O $ProtocolState$ O $ProtocolAction<ProtocolOpenUrlsPayload>$ O O $any$ O $ProtocolState$ O O $any$ O O $string[]$ O O O O O O O O O O O O O O O
import { transcriptsUpdated , transcriptDirectoryUpdated , chatFilesUpdated , chatsDirectoryUpdated , editResource , } from 's' ; import { resources } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( resources ( undefined , { type : 's' } as any ) ) . toEqual ( { transcripts : [ ] , transcriptsPath : 's' , chats : [ ] , chatsPath : 's' , resourceToRename : null , } ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' } ] ; const action = transcriptsUpdated ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { transcripts : payload } ) ; } ) ; it ( 's' , ( ) => { const action = transcriptDirectoryUpdated ( 's' ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { transcriptsPath : 's' } ) ; } ) ; it ( 's' , ( ) => { const action = chatsDirectoryUpdated ( 's' ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { chatsPath : 's' } ) ; } ) ; it ( 's' , ( ) => { const payload = [ { name : 's' } ] ; const action = chatFilesUpdated ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { chats : payload } ) ; } ) ; it ( 's' , ( ) => { const payload = { name : 's' } ; const action = editResource ( payload ) ; const state = resources ( { } as any , action ) ; expect ( state ) . toEqual ( { resourceToRename : payload } ) ; } ) ; } ) ;	O O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<any[]>$ O $ResourcesAction<string>$ O $ResourcesAction<any>$ O O O O O O O $ResourcesState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ResourcesState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $undefined[]$ O O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $null$ O O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any[]>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<string>$ O O $any$ O $ResourcesState$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $ResourcesAction<string>$ O $ResourcesAction<string>$ O O O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<string>$ O O $any$ O $ResourcesState$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O O O O $ResourcesAction<any[]>$ O $ResourcesAction<any[]>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any[]>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $ResourcesAction<any>$ O $ResourcesAction<any>$ O $any$ O O O $ResourcesState$ O $ResourcesState$ O O O O O O $ResourcesAction<any>$ O O $any$ O $ResourcesState$ O O $any$ O O $any$ O $any$ O O O O O O O O O
import { ADD_SAVED_BOT_URL } from 's' ; import { savedBotUrls } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = savedBotUrls ( [ ] , { } as any ) ; expect ( state ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { const action = { type : ADD_SAVED_BOT_URL , payload : 's' } ; const state = savedBotUrls ( [ ] , action ) ; expect ( state ) . toEqual ( [ { url : 's' , lastAccessed : expect . any ( String ) } ] ) ; } ) ; it ( 's' , ( ) => { const action = { type : ADD_SAVED_BOT_URL , payload : 's' } ; const state = savedBotUrls ( [ { url : 's' , lastAccessed : new Date ( 's' ) . toUTCString ( ) } ] , action ) ; expect ( state ) . toEqual ( [ { url : 's' , lastAccessed : expect . any ( String ) } , { url : 's' , lastAccessed : expect . any ( String ) } , ] ) ; } ) ; } ) ;	O O O O O O O O O $BotUrl[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $BotUrl[]$ O $BotUrl[]$ O O O O O O O O O O $any$ O $BotUrl[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $BotUrl[]$ O $BotUrl[]$ O O O O $any$ O O $any$ O $BotUrl[]$ O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $BotUrl[]$ O $BotUrl[]$ O O O $string$ O O O $string$ O O $DateConstructor$ O O O O $string$ O O O O O $any$ O O $any$ O $BotUrl[]$ O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O O O O O
import { switchTheme } from 's' ; import { theme } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( theme ( undefined , { type : 's' } as any ) ) . toEqual ( { themeName : null , themeComponents : [ ] , } ) ; } ) ; it ( 's' , ( ) => { const action = switchTheme ( 's' , [ 's' ] ) ; const state = theme ( { } as any , action ) ; expect ( state ) . toEqual ( { themeName : 's' , themeComponents : [ 's' ] , } ) ; } ) ; } ) ;	O O $ThemeAction<SwitchThemePayload>$ O O O O O O $ThemeState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $ThemeState$ O $undefined$ O O $string$ O O O O O O O O $any$ O O $null$ O O O $undefined[]$ O O O O O O O O O O $any$ O O O O O O O O $ThemeAction<SwitchThemePayload>$ O $ThemeAction<SwitchThemePayload>$ O O O O O O O O O $ThemeState$ O $ThemeState$ O O O O O O $ThemeAction<SwitchThemePayload>$ O O $any$ O $ThemeState$ O O $any$ O O $string$ O O O $string[]$ O O O O O O O O O O O O O O
import { UpdateStatus } from 's' ; import { setUpdateStatus } from 's' ; import { update } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( update ( undefined , { type : undefined , payload : undefined } ) ) . toEqual ( { status : UpdateStatus . Idle } ) ; } ) ; it ( 's' , ( ) => { const state = { status : UpdateStatus . UpdateDownloading } ; const action = setUpdateStatus ( UpdateStatus . UpdateReadyToInstall ) ; expect ( update ( state , action ) ) . toEqual ( { status : UpdateStatus . UpdateReadyToInstall } ) ; } ) ; } ) ;	O O $any$ O O O O O O $UpdateAction<any>$ O O O O O O $UpdateState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $UpdateState$ O $undefined$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $UpdateAction<any>$ O $UpdateAction<any>$ O $any$ O $any$ O O $any$ O $UpdateState$ O $complex$ O $UpdateAction<any>$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O
import { addUsers , setCurrentUser } from 's' ; import { users } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( users ( undefined , { type : 's' } as any ) ) . toEqual ( { } ) ; } ) ; it ( 's' , ( ) => { const user = { id : 's' } ; const action = setCurrentUser ( user ) ; const state = users ( { } as any , action ) ; expect ( state ) . toEqual ( { currentUserId : 's' , usersById : { 0 : user } } ) ; } ) ; it ( 's' , ( ) => { const initialState = { usersById : { 0 : { } , } , } ; const action = addUsers ( [ { name : 's' , id : 's' } , { name : 's' , id : 's' } , { name : 's' , id : 's' } ] ) ; const state = users ( initialState , action ) ; expect ( state ) . toEqual ( { usersById : { 0 : { } , 0 : { name : 's' , id : 's' , } , 0 : { name : 's' , id : 's' , } , } , } ) ; } ) ; } ) ;	O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O $any$ O O O $any$ O $any$ O O O O O O $UserAction<UserPayload>$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O ${}$ O O O O O O O O O $UserAction<UserPayload>$ O $UserAction<UserPayload>$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $UserAction<UserPayload>$ O O $any$ O $any$ O O $any$ O O O O O ${}$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O O O
import { windowStateDefault } from 's' ; import { rememberBounds , rememberTheme , rememberZoomLevel , setAvailableThemes } from 's' ; import { windowState } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( windowState ( undefined , { type : 's' } as any ) ) . toEqual ( windowStateDefault ) ; } ) ; it ( 's' , ( ) => { const payload = { displayId : 0 , top : 0 , left : 0 , width : 0 , height : 0 } ; const action = rememberBounds ( payload ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( payload ) ; } ) ; it ( 's' , ( ) => { const action = rememberZoomLevel ( { zoomLevel : 0 } ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( { zoomLevel : 0 } ) ; } ) ; it ( 's' , ( ) => { const action = rememberTheme ( 's' ) ; const state = windowState ( { } as any , action ) ; expect ( state ) . toEqual ( { theme : 's' } ) ; } ) ; it ( 's' , ( ) => { const themes = [ { name : 's' , href : 's' } , { name : 's' , href : 's' } ] ; const action = setAvailableThemes ( themes ) ; const state = windowState ( { } as any , action ) ; expect ( state . availableThemes ) . toEqual ( themes ) ; } ) ; } ) ;	O O $any$ O O O O O O $WindowStateAction<RememberBoundsPayload>$ O $WindowStateAction<RememberThemePayload>$ O $WindowStateAction<RememberZoomLevelPayload>$ O $WindowStateAction<SetAvailableThemesPayload>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $WindowStateAction<RememberBoundsPayload>$ O $WindowStateAction<RememberBoundsPayload>$ O $complex$ O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberBoundsPayload>$ O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $WindowStateAction<RememberZoomLevelPayload>$ O $WindowStateAction<RememberZoomLevelPayload>$ O O $number$ O O O O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberZoomLevelPayload>$ O O $any$ O $any$ O O $any$ O O $number$ O O O O O O O O $any$ O O O O O O O O $WindowStateAction<RememberThemePayload>$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O $any$ O O O O O O $WindowStateAction<RememberThemePayload>$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O $WindowStateAction<SetAvailableThemesPayload>$ O $WindowStateAction<SetAvailableThemesPayload>$ O $complex$ O O O $any$ O $any$ O O O O O O $WindowStateAction<SetAvailableThemesPayload>$ O O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O
import 's' ; import { settingsDefault , SharedConstants } from 's' ; import { applyMiddleware , createStore , Store , combineReducers } from 's' ; import sagaMiddlewareFactory from 's' ; import { CommandServiceImpl , CommandServiceInstance } from 's' ; import { azureAuthSettings , framework , savedBotUrls , windowState , users } from 's' ; import { rememberTheme } from 's' ; import { RootState } from 's' ; import { settingsSagas } from 's' ; const mockEmulator = { startup : async ( ) => true , framework : { serverPort : null , server : { botEmulator : { facilities : { conversations : { conversations : { convo : { } } } } } } , } , } ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => mockEmulator , } , } ) ) ; jest . mock ( 's' , ( ) => ( { getActiveBot : ( ) => ( { } ) , } ) ) ; let mockStore < RootState > ; jest . mock ( 's' , ( ) => ( { get store ( ) { return mockStore ; } , } ) ) ; const sagaMiddleWare = sagaMiddlewareFactory ( ) ; jest . mock ( 's' , ( ) => ( { app : { getAppPath : ( ) => 's' } , ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; describe ( 's' , ( ) => { let commandService ; beforeAll ( ( ) => { const decorator = CommandServiceInstance ( ) ; const descriptor = decorator ( { descriptor : { } } , 's' ) as any ; commandService = descriptor . descriptor . get ( ) ; } ) ; beforeEach ( ( ) => { mockStore = createStore ( combineReducers ( { settings : combineReducers ( { azure : azureAuthSettings , framework , savedBotUrls , windowState , users , } ) , } ) , { settings : { ... settingsDefault , windowState : { availableThemes : [ { href : 's' , name : 's' } ] } , } , } , applyMiddleware ( sagaMiddleWare ) ) ; sagaMiddleWare . run ( settingsSagas ) ; } ) ; it ( 's' , ( ) => { const commandServiceSpy = jest . spyOn ( commandService , 's' ) ; mockStore . dispatch ( rememberTheme ( 's' ) ) ; expect ( commandServiceSpy ) . toHaveBeenCalledWith ( SharedConstants . Commands . UI . SwitchTheme , 's' , 's' ) ; } ) ; } ) ;	O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O $WindowStateAction<RememberThemePayload>$ O O O O O O $any$ O O O O O O $IterableIterator<any>$ O O O O O $complex$ O O $Promise<boolean>$ O O O O O O O $complex$ O O $null$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O ${}$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O ${}$ O O O O O O O O O O O O O O $Store$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $CommandServiceImpl$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $BotUrl[]$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $complex$ O O $complex$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $IterableIterator<any>$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $WindowStateAction<RememberThemePayload>$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O
import { TelemetryService } from 's' ; let mockAppInsights ; let mockSetup ; let mockDefaultClient ; let mockStart ; jest . mock ( 's' , ( ) => ( { get defaultClient ( ) { return mockDefaultClient ; } , get setup ( ) { return mockSetup ; } , get start ( ) { return mockStart ; } , } ) ) ; let mockSettings ; jest . mock ( 's' , ( ) => ( { getSettings : ( ) => mockSettings , } ) ) ; describe ( 's' , ( ) => { let tmpClient ; let tmpStartup ; beforeEach ( ( ) => { mockDefaultClient = { context : { keys : { cloudRoleInstance : 's' , } , tags : { cloudRoleInstance : 's' , } , } , } ; mockAppInsights = { } ; mockSettings = { framework : { collectUsageData : true } } ; mockSetup = jest . fn ( ( _iKey ) => mockAppInsights ) ; mockStart = jest . fn ( ( ) => null ) ; tmpClient = ( TelemetryService as any ) . _client ; tmpStartup = ( TelemetryService as any ) . startup ; } ) ; afterEach ( ( ) => { ( TelemetryService as any ) . _client = tmpClient ; ( TelemetryService as any ) . startup = tmpStartup ; } ) ; it ( 's' , ( ) => { const mockAutoCollect = jest . fn ( _config => mockAppInsights ) ; mockAppInsights = { setAutoCollectConsole : mockAutoCollect , setAutoCollectDependencies : mockAutoCollect , setAutoCollectExceptions : mockAutoCollect , setAutoCollectPerformance : mockAutoCollect , setAutoCollectRequests : mockAutoCollect , setAutoDependencyCorrelation : mockAutoCollect , } ; ( TelemetryService as any ) . startup ( ) ; expect ( mockSetup ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockSetup ) . toHaveBeenCalledWith ( 's' ) ; expect ( mockAutoCollect ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockStart ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockDefaultClient . context . tags . cloudRoleInstance ) . toBe ( 's' ) ; expect ( ( TelemetryService as any ) . _hasStarted ) . toBe ( true ) ; expect ( ( TelemetryService as any ) . _client ) . toBe ( mockDefaultClient ) ; } ) ; it ( 's' , ( ) => { mockSettings = { framework : { collectUsageData : false } } ; expect ( ( TelemetryService as any ) . enabled ) . toBe ( false ) ; mockSettings = { framework : { collectUsageData : true } } ; expect ( ( TelemetryService as any ) . enabled ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const mockAITrackEvent = jest . fn ( ( _name , _properties ) => null ) ; ( TelemetryService as any ) . _client = { trackEvent : mockAITrackEvent } ; mockSettings = { framework : { collectUsageData : false } } ; TelemetryService . trackEvent ( null , null ) ; expect ( mockAITrackEvent ) . not . toHaveBeenCalled ( ) ; mockSettings = { framework : { collectUsageData : true } } ; TelemetryService . trackEvent ( 's' , { } ) ; expect ( mockAITrackEvent ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $complex$ O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O O O O O $any$ O O O O $any$ O O $complex$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $string$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O $complex$ O O $boolean$ O O O O O $any$ O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O $complex$ O O $boolean$ O O O O O $any$ O O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O $boolean$ O O O O O $any$ O $void$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $complex$ O O $boolean$ O O O O O $any$ O $void$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import { BotInfo } from 's' ; import { botListsAreDifferent } from 's' ; test ( 's' , ( ) => { const 0 : BotInfo [ ] = [ { path : 's' , displayName : 's' , } , { path : 's' , displayName : 's' , } , { path : 's' , displayName : 's' , } , ] ; const 0 : BotInfo [ ] = [ ] ; expect ( botListsAreDifferent ( 0 , 0 ) ) . toBe ( true ) ; 0 [ 0 ] = { path : 's' , displayName : 's' } ; 0 [ 0 ] = { path : 's' , displayName : 's' } ; 0 [ 0 ] = { path : 's' , displayName : 's' } ; expect ( botListsAreDifferent ( 0 , 0 ) ) . toBe ( false ) ; 0 [ 0 ] = { path : 's' , displayName : 's' } ; expect ( botListsAreDifferent ( 0 , 0 ) ) . toBe ( true ) ; } ) ;	O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any[]$ O $any$ O O O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O O $any[]$ O $any$ O O O O O O $any$ O O O $any[]$ O $any[]$ O O O $any$ O O O O $any[]$ O O O O O $string$ O O O $string$ O O O O $any[]$ O O O O O $string$ O O O $string$ O O O O $any[]$ O O O O O $string$ O O O $string$ O O O O $any$ O O O $any[]$ O $any[]$ O O O $any$ O O O O $any[]$ O O O O O $string$ O O O $string$ O O O O $any$ O O O $any[]$ O $any[]$ O O O $any$ O O O O O O O
import { cleanupId , findIdWithRole } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const activities = [ { recipient : { id : 's' , role : 's' } , } , { recipient : { id : 's' , role : 's' } , } , ] ; expect ( findIdWithRole ( activities , 's' ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const activities = [ { type : 's' , recipient : { id : 's' , role : 's' } , } , { type : 's' , recipient : { id : 's' , role : 's' } , } , ] ; expect ( cleanupId ( activities ) ) . toEqual ( activities ) ; } ) ; it ( 's' , ( ) => { const botId = 's' ; const userId = 's' ; const activities = [ { type : 's' , from : { role : 's' } , recipient : { role : 's' } , } , { type : 's' , from : { role : 's' } , recipient : { role : 's' } , } , { type : 's' , from : { role : 's' } , recipient : { role : 's' } , } , { type : 's' , from : { role : 's' } , recipient : { role : 's' } , } , ] ; const fixedActivities = cleanupId ( activities , botId , userId ) ; expect ( fixedActivities ) . toEqual ( [ { type : 's' , from : { id : 's' , role : 's' } , recipient : { id : 's' , role : 's' } , } , { type : 's' , from : { id : 's' , role : 's' } , recipient : { id : 's' , role : 's' } , } , { type : 's' , from : { id : 's' , role : 's' } , recipient : { id : 's' , role : 's' } , } , { type : 's' , from : { id : 's' , role : 's' } , recipient : { id : 's' , role : 's' } , } , ] ) ; } ) ; } ) ; it ( 's' , ( ) => { const activities = [ { type : 's' , from : { id : 's' } , recipient : { id : 's' } , } , ] ; const fixedActivities = cleanupId ( activities ) ; expect ( fixedActivities ) . toEqual ( activities ) ; } ) ;	O O $any[]$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $string$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O O O O $any[]$ O $any[]$ O $any$ O O O O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O O O O $any[]$ O $any[]$ O $any$ O O $any$ O $any[]$ O O $any$ O $any$ O O O O O
import { APIException } from 's' ; import * as HttpStatus from 's' ; import { exceptionToAPIException } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const apiException = { error : { error : { code : 's' , message : 's' } } , statusCode : HttpStatus . BAD_REQUEST , } ; expect ( exceptionToAPIException ( apiException ) ) . toBe ( apiException ) ; } ) ; it ( 's' , ( ) => { const error = new Error ( 's' ) ; expect ( exceptionToAPIException ( error ) ) . toEqual ( { error : { error : { code : 's' , message : 's' , } , } , statusCode : HttpStatus . BAD_REQUEST , } ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $APIException$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O $any$ O $any$ O $Error$ O O O $any$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O
import { getBotsFromDisk } from 's' ; let botsJsonContent = 's' ; const mockReadFileSync = ( ) => botsJsonContent ; jest . mock ( 's' , ( ) => ( { readFileSync : ( ) => mockReadFileSync ( ) , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { botsJsonContent = JSON . stringify ( { bots : [ { displayName : 's' , path : 's' , secret : 's' } ] } ) ; const bots = getBotsFromDisk ( ) ; expect ( bots ) . toEqual ( [ { displayName : 's' , path : 's' } ] ) ; } ) ; it ( 's' , ( ) => { botsJsonContent = 's' ; const bots = getBotsFromDisk ( ) ; expect ( bots ) . toEqual ( [ ] ) ; } ) ; it ( 's' , ( ) => { botsJsonContent = new Error ( 's' ) ; const bots = getBotsFromDisk ( ) ; expect ( bots ) . toEqual ( [ ] ) ; } ) ; } ) ;	O O $any[]$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $JSON$ O $complex$ O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any[]$ O $any[]$ O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any[]$ O $any[]$ O O O $any$ O $any[]$ O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O $ErrorConstructor$ O O O O O $any[]$ O $any[]$ O O O $any$ O $any[]$ O O $any$ O O O O O O O O O O O
import { getLocalhostServiceUrl } from 's' ; jest . mock ( 's' , ( ) => ( { Emulator : { getInstance : ( ) => ( { framework : { serverUrl : 's' , } , } ) , } , } ) ) ; test ( 's' , ( ) => { expect ( getLocalhostServiceUrl ( ) ) . toBe ( 's' ) ; } ) ;	O O $string$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O O O O O $complex$ O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O $any$ O O O O O O O
import { getThemes } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const themes = getThemes ( ) ; expect ( themes ) . toEqual ( [ { href : 's' , name : 's' } , { href : 's' , name : 's' } , { href : 's' , name : 's' } , ] ) ; } ) ; } ) ;	O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $any$ O $complex$ O O $any$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O O O O O O
import { loadSettings } from 's' ; const mockSettings = { framework : { ngrokPath : 's' , bypassNgrokLocalhost : true , stateSizeLimit : 0 , 0 : false , useCodeValidation : false , localhost : 's' , locale : 's' , } , bots : [ { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , locale : 's' , } , ] , windowState : { zoomLevel : 0 , width : 0 , height : 0 , left : 0 , top : 0 , theme : 's' , availableThemes : [ { name : 's' , href : 's' , } , { name : 's' , href : 's' , } , { name : 's' , href : 's' , } , ] , displayId : 0 , } , users : { } , azure : { } , } ; jest . mock ( 's' , ( ) => ( { statSync : ( ) => ( { isFile : ( ) => true } ) , readFileSync : ( ) => 's' , writeFileSync : ( ) => true , } ) ) ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const settings = loadSettings ( 's' , mockSettings ) ; expect ( settings . users ) . not . toBeUndefined ( ) ; expect ( settings . users . currentUserId ) . not . toBe ( 's' ) ; expect ( Object . keys ( settings . users . usersById ) [ 0 ] ) . toBe ( settings . users . currentUserId ) ; } ) ; it ( 's' , ( ) => { mockSettings . users = { currentUserId : 's' , usersById : { 's' : { id : 's' , name : 's' , } , } , } ; const settings = loadSettings ( 's' , mockSettings ) ; expect ( settings . users . currentUserId ) . not . toBe ( 's' ) ; expect ( Object . keys ( settings . users . usersById ) [ 0 ] ) . toBe ( settings . users . currentUserId ) ; } ) ; } ) ;	O O $any$ O O O O O O O O O O O $string$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O $number$ O O O O O ${}$ O O O O ${}$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $boolean$ O O O O O O O O $string$ O O O O O O $boolean$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O ${}$ O O $string$ O O O $complex$ O O O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O
import { CommandRegistry , CommandRegistryImpl } from 's' ; import { TelemetryService } from 's' ; import { openFileFromCommandLine } from 's' ; jest . mock ( 's' , ( ) => ( { getSettings : ( ) => null , } ) ) ; jest . mock ( 's' , ( ) => ( { readFileSync => { if ( file . includes ( 's' ) ) { return 's' ; } if ( file . includes ( 's' ) ) { return 's' ; } if ( file . includes ( 's' ) ) { return `template` ; } return null ; } , } ) ) ; class MockCommandService implements CommandService { public registry : CommandRegistry = new CommandRegistryImpl ( ) ; public remoteCalls = [ ] ; public localCalls = [ ] ; async remoteCall ( ... args : any [ ] ) { this . remoteCalls . push ( args ) ; return null ; } async call ( ... args : any [ ] ) { this . localCalls . push ( args ) ; return null ; } on ( commandName , handler ? ) { return null ; } } describe ( 's' , ( ) => { let commandService ; let mockTrackEvent ; const trackEventBackup = TelemetryService . trackEvent ; beforeEach ( ( ) => { commandService = new MockCommandService ( ) ; mockTrackEvent = jest . fn ( ( ) => null ) ; TelemetryService . trackEvent = mockTrackEvent ; } ) ; afterAll ( ( ) => { TelemetryService . trackEvent = trackEventBackup ; } ) ; it ( 's' , async ( ) => { await openFileFromCommandLine ( 's' , commandService ) ; expect ( commandService . localCalls ) . toEqual ( [ [ 's' , 's' ] , [ 's' , null ] ] ) ; expect ( commandService . remoteCalls ) . toEqual ( [ [ 's' , null ] ] ) ; } ) ; it ( 's' , async ( ) => { await openFileFromCommandLine ( 's' , commandService ) ; expect ( commandService . remoteCalls ) . toEqual ( [ [ 's' , 's' , 's' , { activities : [ ] , inMemory : true , } , ] , ] ) ; expect ( mockTrackEvent ) . toHaveBeenCalledWith ( 's' , { method : 's' , } ) ; } ) ; it ( 's' , async ( ) => { let thrown ; try { await openFileFromCommandLine ( 's' , commandService ) ; } catch ( e ) { thrown = true ; expect ( e . message ) . toEqual ( 's' ) ; } expect ( thrown ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $file$ O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any[]$ O O O O O $any[]$ O O O O O $Promise<any>$ O O $any[]$ O O O O O O O O $any[]$ O $number$ O $any[]$ O O O O O O O $Promise<any>$ O O $any[]$ O O O O O O O O $any[]$ O $number$ O $any[]$ O O O O O O $any$ O $string$ O $Function$ $Function$ O O O O O O O $any$ O O O O O O O O $MockCommandService$ O O $any$ O O $void$ O $any$ O $void$ O $any$ O O O O O $MockCommandService$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $void$ O $any$ O O O O $any$ O O O O O $any$ O $void$ O $void$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $MockCommandService$ O O $any$ O $MockCommandService$ O $any[]$ O O $any$ O O O O O O O O O O O O O O O O $any$ O $MockCommandService$ O $any[]$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $MockCommandService$ O O $any$ O $MockCommandService$ O $any[]$ O O $any$ O O O O O O O O O O $undefined[]$ O O O O $boolean$ O O O O O O O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O O $boolean$ O O O O $Promise<void>$ O O O $MockCommandService$ O O O O O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O
import { isMac } from 's' ; describe ( 's' , ( ) => { let originalPlatform ; beforeEach ( ( ) => { originalPlatform = process . platform ; } ) ; afterEach ( ( ) => { Object . defineProperty ( process , 's' , { value : originalPlatform } ) ; } ) ; it ( 's' , ( ) => { Object . defineProperty ( process , 's' , { value : 's' } ) ; expect ( isMac ( ) ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { Object . defineProperty ( process , 's' , { value : 's' } ) ; expect ( isMac ( ) ) . toBe ( false ) ; } ) ; } ) ;	O O $boolean$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $ObjectConstructor$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $boolean$ O O O O $any$ O O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $boolean$ O O O O $any$ O O O O O O O O O O
import * as fs from 's' ; import * as ensureStoragePathUtil from 's' ; import { saveSettings } from 's' ; jest . mock ( 's' , ( ) => ( { ensureStoragePath : ( ) => 's' , } ) ) ; jest . mock ( 's' , ( ) => ( { writeFileSync : ( ) => true , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const ensureStoragePathSpy = jest . spyOn ( ( ensureStoragePathUtil as any ) . default , 's' ) . mockReturnValue ( 's' ) ; saveSettings < { } > ( 's' , { } ) ; expect ( ensureStoragePathSpy ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $void$ O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $boolean$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O
import { LogLevel , textItem } from 's' ; import got from 's' ; import { DOMParser } from 's' ; import { emulatorApplication } from 's' ; interface Version { type ? : string ; major : number ; minor : number ; subminor : number ; } export class VersionManager { public static hasChecked : boolean = false ; public static SDKTypes : string [ ] = [ 's' , 's' ] ; public static currentSdkVersion : Version = null ; public static checkVersion ( conversationId , userAgent ) { if ( ! VersionManager . hasChecked ) { const version = VersionManager . parseUserAgentForVersion ( userAgent ) ; VersionManager . checkCurrentSdkVersion ( conversationId , version ) ; VersionManager . hasChecked = true ; } } public static checkCurrentSdkVersion ( conversationId , version ) { if ( ! version || version . type === 's' ) { VersionManager . checkNodeSdkVersion ( conversationId , version ) ; } else { VersionManager . checkDotNetSdkVersion ( conversationId , version ) ; } } public static checkNodeSdkVersion ( conversationId , version ) { const options = { url : 's' , method : 's' , headers : { Accept : 's' , } , useElectronNet : true , } ; const responseCallback = resp => { if ( resp . body ) { try { const verObj = JSON . parse ( resp . body ) ; if ( verObj . latest ) { const latestVersion = VersionManager . parseVersion ( verObj . latest ) ; if ( ! version || VersionManager . isLess ( version , latestVersion ) ) { VersionManager . warnAboutNewSdkVersion ( conversationId , version , latestVersion ) ; } } } catch ( err ) { } } } ; got ( options ) . then ( responseCallback ) . catch ( err => { } ) ; } public static checkDotNetSdkVersion ( conversationId , version ) { const options = { url : 's' + "s" , method : 's' , useElectronNet : true , } ; const responseCallback = resp => { if ( resp . body ) { try { const doc = new DOMParser ( ) . parseFromString ( resp . body , 's' ) ; const entryElem = doc . documentElement . getElementsByTagName ( 's' ) [ 0 ] ; const properties = entryElem . getElementsByTagName ( 's' ) [ 0 ] ; const versionElem = properties . getElementsByTagName ( 's' ) [ 0 ] ; if ( versionElem . textContent ) { const latestVersion = VersionManager . parseVersion ( versionElem . textContent ) ; if ( ! version || VersionManager . isLess ( version , latestVersion ) ) { VersionManager . warnAboutNewSdkVersion ( conversationId , version , latestVersion ) ; } } } catch ( err ) { } } } ; got ( options ) . then ( responseCallback ) . catch ( err => { } ) ; } private static warnAboutNewSdkVersion ( conversationId , botVersion , latestVersion ) { emulatorApplication . mainWindow . logService . logToChat ( conversationId , textItem ( LogLevel . Warn , 's' + VersionManager . toString ( latestVersion ) + ( botVersion ? 's' + VersionManager . toString ( botVersion ) : 's' ) + 's' ) ) ; } private static parseUserAgentForVersion ( userAgent ) { if ( userAgent && userAgent . length ) { for ( let i = 0 ; i < VersionManager . SDKTypes . length ; i ++ ) { const type = VersionManager . SDKTypes [ i ] ; let idx = userAgent . indexOf ( type ) ; if ( idx !== - 0 ) { idx += type . length ; const endIdx = userAgent . indexOf ( 's' , idx ) ; if ( endIdx !== - 0 ) { const versionString = userAgent . substring ( idx , endIdx ) ; const version = VersionManager . parseVersion ( versionString ) ; if ( version ) { version . type = i === 0 ? 's' : 's' ; } return version ; } } } } return undefined ; } private static parseVersion ( versionString ) { const parts = versionString . split ( 's' ) ; if ( parts . length >= 0 ) { const version = { major : parseInt ( parts [ 0 ] , 0 ) , minor : parseInt ( parts [ 0 ] , 0 ) , subminor : parseInt ( parts [ 0 ] , 0 ) , } ; return version ; } return undefined ; } private static toString ( version ) { return version . major + 's' + version . minor + 's' + version . subminor ; } private static isLess ( a , b ) { return ( a . major < b . major || ( a . major === b . major && a . minor < b . minor ) || ( a . major === b . major && a . minor === b . minor && a . subminor < b . subminor ) ) ; } }	O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $EmulatorApplication$ O O O O O $any$ O $string$ O O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O O O $boolean$ O O O O O O O $string[]$ O O O O O O O O O O O O O $Version$ O $any$ O O O O O $void$ O $string$ O $string$ O O O O O $any$ O $boolean$ O O O $Version$ O $any$ O $Version$ O $string$ O O $any$ O $void$ O $string$ O $Version$ O O $any$ O $boolean$ O O O O O O O $void$ O $string$ O $Version$ O O O O O $Version$ O $Version$ O $string$ O O O O $any$ O $void$ O $string$ O $Version$ O O O O O $any$ O $void$ O $string$ O $Version$ O O O O O O $void$ O $string$ O $Version$ O O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $boolean$ O O O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $JSON$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $Version$ O $any$ O $Version$ O $any$ O $any$ O O O O O $Version$ O $any$ O $boolean$ O $Version$ O $Version$ O O O $any$ O $void$ O $string$ O $Version$ O $Version$ O O O O O O O $any$ O O O O O O $any$ O $complex$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O $void$ O $string$ O $Version$ O O O $complex$ O O $string$ O O O O O $string$ O O O $boolean$ O O O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $Version$ O $any$ O $Version$ O $any$ O $any$ O O O O O $Version$ O $any$ O $boolean$ O $Version$ O $Version$ O O O $any$ O $void$ O $string$ O $Version$ O $Version$ O O O O O O O $any$ O O O O O O $any$ O $complex$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O $void$ O $string$ O $Version$ O $Version$ O O $EmulatorApplication$ O $Window$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O $Version$ O O O $Version$ O O O $any$ O $string$ O $Version$ O O O O O O O O O O O O $Version$ O $string$ O O O O $string$ O $string$ O $number$ O O O O O $number$ O O O $number$ O $any$ O $string[]$ O $number$ O $number$ O O O O $string$ O $any$ O $string[]$ O $number$ O O O $number$ O $string$ O $number$ O $string$ O O O O $number$ O O O O O $number$ O $string$ O $number$ O O $number$ O $string$ O $number$ O O O $number$ O O O O $number$ O O O O O O $string$ O $string$ O $string$ O $number$ O $number$ O O O $Version$ O $any$ O $Version$ O $string$ O O O O $Version$ O O $Version$ O $string$ O $number$ O O O O O O O O O $Version$ O O O O O O $undefined$ O O O O $Version$ O $string$ O O O $string[]$ O $string$ O $complex$ O O O O O O $string[]$ O $number$ O O O O O $complex$ O O $number$ O $number$ O $string[]$ O O O O O O O $number$ O $number$ O $string[]$ O O O O O O O $number$ O $number$ O $string[]$ O O O O O O O O O O $complex$ O O O $undefined$ O O O O $string$ O $Version$ O O O $Version$ O $number$ O O O $Version$ O $number$ O O O $Version$ O $number$ O O O O $boolean$ O $Version$ O $Version$ O O O O $Version$ O $number$ O $Version$ O $number$ O O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O O O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O $Version$ O $number$ O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import { AttachmentContentTypes } from 's' ; import { Activity , Attachment , CardAction , CardImage , MediaCard , ReceiptCard , SigninCard , ThumbnailCard , } from 's' ; export abstract class ActivityVisitor { public traverseActivity ( activity ) { if ( activity ) { this . traverseMessageActivity ( activity ) ; } } public traverseMessageActivity ( messageActivity ) { if ( messageActivity ) { if ( messageActivity . attachments ) { messageActivity . attachments . forEach ( attachment => this . traverseAttachment ( attachment ) ) ; } } } public traverseAttachment ( attachment ) { if ( attachment ) { switch ( attachment . contentType ) { case AttachmentContentTypes . animationCard : case AttachmentContentTypes . videoCard : case AttachmentContentTypes . audioCard : this . traverseMediaCard ( attachment . content as MediaCard ) ; break ; case AttachmentContentTypes . heroCard : case AttachmentContentTypes . thumbnailCard : this . traverseThumbnailCard ( attachment . content as ThumbnailCard ) ; break ; case AttachmentContentTypes . receiptCard : this . traverseReceiptCard ( attachment . content as ReceiptCard ) ; break ; case AttachmentContentTypes . signInCard : this . traverseSignInCard ( attachment . content as SigninCard ) ; break ; default : break ; } } } public traverseMediaCard ( mediaCard ) { if ( mediaCard ) { this . traverseCardImage ( mediaCard . image ) ; this . traverseButtons ( mediaCard . buttons ) ; } } public traverseThumbnailCard ( thumbnailCard ) { this . visitCardAction ( thumbnailCard . tap ) ; this . traverseButtons ( thumbnailCard . buttons ) ; this . traverseCardImages ( thumbnailCard . images ) ; } public traverseSignInCard ( signInCard ) { this . traverseButtons ( signInCard . buttons ) ; } public traverseReceiptCard ( receiptCard ) { this . visitCardAction ( receiptCard . tap ) ; this . traverseButtons ( receiptCard . buttons ) ; } public traverseButtons ( buttons : CardAction [ ] ) { if ( buttons ) { buttons . forEach ( cardAction => this . visitCardAction ( cardAction ) ) ; } } public traverseCardImages ( cardImages : CardImage [ ] ) { if ( cardImages ) { cardImages . forEach ( image => { this . traverseCardImage ( image ) ; } ) ; } } public traverseCardImage ( cardImage ) { if ( cardImage ) { this . visitCardAction ( cardImage . tap ) ; } } protected abstract visitCardAction ( cardAction ) ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $void$ O $Activity$ O O O O $any$ O O O O $void$ O $any$ O O O O O $void$ O $Activity$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O O O O $void$ O $Attachment$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $void$ O $MediaCard$ O O O O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O O $void$ O $ThumbnailCard$ O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $SigninCard$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $ReceiptCard$ O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any[]$ O $any$ O O O O O O $any[]$ O O $any[]$ O $void$ O $any$ O O O $any$ O $any$ O O O O O O $void$ O $any[]$ O $any$ O O O O O O $any[]$ O O $any[]$ O $void$ O $any$ O O O O $void$ O $any$ O O O O O O O O $void$ O $CardImage$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $CardAction$ O O O
const EDITOR_KEY_PRIMARY = 's' ; const EDITOR_KEY_SECONDARY = 's' ; export const SharedConstants = { NOTIFICATION_FROM_MAIN : 's' , TEMP_BOT_IN_MEMORY_PATH : 's' , EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY , Commands : { Azure : { RetrieveArmToken : 's' , PersistAzureLoginChanged : 's' , SignUserOutOfAzure : 's' , } , Bot : { Create : 's' , Save : 's' , Open : 's' , SetActive : 's' , RestartEndpointService : 's' , Close : 's' , AddOrUpdateService : 's' , RemoveService : 's' , PatchBotList : 's' , Switch : 's' , OpenBrowse : 's' , Load : 's' , RemoveFromBotList : 's' , WatchForTranscriptFiles : 's' , WatchForChatFiles : 's' , ChatFilesUpdated : 's' , TranscriptFilesUpdated : 's' , TranscriptsPathUpdated : 's' , ChatsPathUpdated : 's' , } , ClientInit : { Loaded : 's' , PostWelcomeScreen : 's' , } , Electron : { CheckForUpdates : 's' , FetchRemote : 's' , ShowMessageBox : 's' , ShowOpenDialog : 's' , ShowSaveDialog : 's' , UpdateFileMenu : 's' , UpdateConversationMenu : 's' , SetFullscreen : 's' , SetTitleBar : 's' , DisplayContextMenu : 's' , OpenExternal : 's' , ToggleDevTools : 's' , UpdateAvailable : 's' , UpdateNotAvailable : 's' , ShowAboutDialog : 's' , OpenFileLocation : 's' , UnlinkFile : 's' , RenameFile : 's' , QuitAndInstall : 's' , } , Emulator : { SaveTranscriptToFile : 's' , FeedTranscriptFromDisk : 's' , FeedTranscriptFromMemory : 's' , GetServiceUrl : 's' , GetSpeechToken : 's' , NewTranscript : 's' , NewLiveChat : 's' , OpenTranscript : 's' , PromptToOpenTranscript : 's' , ReloadTranscript : 's' , OpenChatFile : 's' , AppendToLog : 's' , SetCurrentUser : 's' , DeleteConversation : 's' , PostActivityToConversation : 's' , StartEmulator : 's' , OpenProtocolUrls : 's' , ClearState : 's' , SendConversationUpdateUserAdded : 's' , SendBotContactAdded : 's' , SendBotContactRemoved : 's' , SendTyping : 's' , SendPing : 's' , SendDeleteUserData : 's' , } , Extension : { Connect : 's' , Disconnect : 's' , } , File : { Read : 's' , Write : 's' , SanitizeString : 's' , Clear : 's' , Add : 's' , Remove : 's' , Changed : 's' , } , ConnectedService : { GetConnectedServicesByType : 's' , } , Misc : { GetStoreState : 's' , } , Ngrok : { Reconnect : 's' , KillProcess : 's' , } , Notifications : { Add : 's' , Remove : 's' , } , OAuth : { SendTokenResponse : 's' , CreateOAuthWindow : 's' , } , Settings : { LoadAppSettings : 's' , ReceiveGlobalSettings : 's' , SaveBotUrl : 's' , } , Telemetry : { TrackEvent : 's' , } , UI : { ShowMarkdownPage : 's' , ShowWelcomePage : 's' , ShowBotCreationDialog : 's' , ShowOpenBotDialog : 's' , ShowSecretPromptDialog : 's' , SwitchNavBarTab : 's' , ShowAppSettings : 's' , SwitchTheme : 's' , SignInToAzure : 's' , ArmTokenReceivedOnStartup : 's' , ShowPostMigrationDialog : 's' , UpdateProgressIndicator : 's' , InvalidateAzureArmToken : 's' , ShowUpdateAvailableDialog : 's' , ShowUpdateUnavailableDialog : 's' , ShowProgressIndicator : 's' , OpenBotViaUrl : 's' , ShowOpenUrlDialog : 's' , ShowDataCollectionDialog : 's' , } , } , ContentTypes : { CONTENT_TYPE_LIVE_CHAT : 's' , CONTENT_TYPE_DEBUG : 's' , CONTENT_TYPE_MARKDOWN : 's' , CONTENT_TYPE_APP_SETTINGS : 's' , CONTENT_TYPE_WELCOME_PAGE : 's' , CONTENT_TYPE_TRANSCRIPT : 's' , } , Channels : { ReadmeUrl : 's' , HelpLabel : 's' , } , DocumentIds : { DOCUMENT_ID_APP_SETTINGS : 's' , DOCUMENT_ID_BOT_SETTINGS : 's' , DOCUMENT_ID_WELCOME_PAGE : 's' , DOCUMENT_ID_MARKDOWN_PAGE : 's' , } , EditorKeys : [ EDITOR_KEY_PRIMARY , EDITOR_KEY_SECONDARY ] , NavBarItems : { NAVBAR_BOT_EXPLORER : 's' , NAVBAR_SETTINGS : 's' , NAVBAR_NOTIFICATIONS : 's' , NAVBAR_RESOURCES : 's' , } , } ;	O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string[]$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O
export * from 's' ;	O O O O O
export enum ServiceCodes { OK , AccountNotFound , Error , }	O O $any$ O $ServiceCodes.OK$ O $ServiceCodes.AccountNotFound$ O $ServiceCodes.Error$ O O
export enum UpdateStatus { Idle , UpdateAvailable , UpdateDownloading , UpdateReadyToInstall , }	O O $any$ O $UpdateStatus.Idle$ O $UpdateStatus.UpdateAvailable$ O $UpdateStatus.UpdateDownloading$ O $UpdateStatus.UpdateReadyToInstall$ O O
export enum ValueTypes { BotState = 's' , Command = 's' , Debug = 's' , Diff = 's' , Error = 's' , Activity = 's' , } export class ValueTypesMask { public static [ ValueTypes . BotState ] = 0 ; public static [ ValueTypes . Command ] = 0 ; public static [ ValueTypes . Debug ] = 0 ; public static [ ValueTypes . Diff ] = 0 ; public static [ ValueTypes . Error ] = 0 ; public static [ ValueTypes . Activity ] = 0 ; public static BotState = 0 ; public static Command = 0 ; public static Debug = 0 ; public static Diff = 0 ; public static Error = 0 ; public static Activity = 0 ; private constructor ( ) { } }	O O $any$ O $ValueTypes.BotState$ O O O $ValueTypes.Command$ O O O $ValueTypes.Debug$ O O O $ValueTypes.Diff$ O O O $ValueTypes.Error$ O O O $ValueTypes.Activity$ O O O O O O $any$ O O O O $any$ O $ValueTypes.BotState$ O O O O O O O $any$ O $ValueTypes.Command$ O O O O O O O $any$ O $ValueTypes.Debug$ O O O O O O O $any$ O $ValueTypes.Diff$ O O O O O O O $any$ O $ValueTypes.Error$ O O O O O O O $any$ O $ValueTypes.Activity$ O O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { CardAction , PaymentRequest } from 's' ; import { ActivityVisitor } from 's' ; export class PaymentEncoder extends ActivityVisitor { public static PaymentEmulatorUrlProtocol : string = 's' ; protected visitCardAction ( cardAction ) { if ( cardAction && cardAction . type === 's' ) { const paymentRequest = cardAction . value as PaymentRequest ; const url = PaymentEncoder . PaymentEmulatorUrlProtocol + 's' + JSON . stringify ( paymentRequest ) ; cardAction . type = 's' ; cardAction . value = url ; } } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O O O O $void$ O $CardAction$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O $any$ O $string$ O O O $JSON$ O $complex$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O
export interface Bot { id ? : string ; botId ? : string ; botName ? : string ; botUrl ? : string ; locale ? : string ; msaAppId ? : string ; msaPassword ? : string ; } export interface BotInfo { path ? : string ; displayName ? : string ; transcriptsPath ? : string ; chatsPath ? : string ; }	O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O
export interface CommandLineArgs { storagepath ? : string ; }	O O $any$ O $string$ O O O O O
import { ETagObject } from 's' ; export interface Conversation extends ETagObject { conversationId ? : string ; token ? : string ; expires_in ? : number ; streamUrl ? : string ; }	O O $any$ O O O O O O $any$ O $any$ O $string$ O O O O $string$ O O O O $number$ O O O O $string$ O O O O O
export interface FileInfo { type : 's' | 's' ; name : string ; path : string ; }	O O $any$ O O O O O O O $string$ O O O $string$ O O O O
import { uniqueId } from 's' ; export enum NotificationType { Info , Error , Warning , } export interface NotificationCTAButton { text : string ; onClick ? : ( ... args : any [ ] ) => any ; } export interface Notification { id : string ; type : NotificationType ; message : string ; timestamp : number ; read : boolean ; buttons ? : NotificationCTAButton [ ] ; addButton : ( text , onClick ? : ( ... args : any [ ] ) => any ) => void ; } export class NotificationImpl implements Notification { public readonly id : string ; public readonly timestamp : number ; public type : NotificationType ; public message : string ; public read : boolean ; public buttons ? : NotificationCTAButton [ ] ; constructor ( ) { this . id = uniqueId ( ) ; this . timestamp = Date . now ( ) ; this . read = false ; this . buttons = [ ] ; } public addButton ( text , onClick ? : ( ... args : any [ ] ) => any ) { const button = { text , onClick } ; this . buttons . push ( button ) ; } }	O O $any$ O O O O O O $any$ O $NotificationType.Info$ O $NotificationType.Error$ O $NotificationType.Warning$ O O O O $any$ O $string$ O O O $any$ O O O O $any[]$ O O O O O O O O O O O $any$ O $string$ O O O $NotificationType$ O $any$ O $string$ O O O $number$ O O O $boolean$ O O O $NotificationCTAButton[]$ O O $any$ O O O $void$ O O $string$ O $any$ O O O O $any[]$ O O O O O O O O O O O O O O $any$ O $any$ O O O $string$ O O O O O $number$ O O O O $NotificationType$ O $any$ O O $string$ O O O O $boolean$ O O O O $NotificationCTAButton[]$ O O $any$ O O O O O O O O O $string$ O $any$ O O O O O $number$ O $DateConstructor$ O $number$ O O O O O $boolean$ O O O O O $NotificationCTAButton[]$ O O O O O O $void$ O $string$ O $any$ O O O O $any[]$ O O O O O O O O O O $NotificationCTAButton$ O O $string$ O $any$ O O O O $NotificationCTAButton[]$ O $number$ O $NotificationCTAButton$ O O O O
export interface NativeError { code ? : string ; message ? : string ; } export interface ErrorResponse { error : NativeError ; } export interface ResourceResponse { id : string ; } export interface ConversationResourceResponse { id : string ; activityId ? : string ; } export const ErrorCodes = { ServiceError : 's' , BadArgument : 's' , BadSyntax : 's' , MissingProperty : 's' , MessageSizeTooBig : 's' , } ; export interface APIException { statusCode : number ; error : ErrorResponse ; } export function createResourceResponse ( id ) { return { id } ; } export function createConversationResponse ( id , activityId ) { const response = { id } ; if ( activityId != null ) { response . activityId = activityId ; } return response ; } export function createErrorResponse ( code , message ) { return { error : { code , message , } , } ; } export function createAPIException ( statusCode , code , message ) { return { statusCode , error : createErrorResponse ( code , message ) , } ; }	O O $any$ O $string$ O O O O $string$ O O O O O O O $any$ O $NativeError$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O $number$ O O O $ErrorResponse$ O $any$ O O O O $ResourceResponse$ O $string$ O O O O $string$ O O O O O $ConversationResourceResponse$ O $string$ O $string$ O O O $ConversationResourceResponse$ O O $string$ O O O O $string$ O O O O $ConversationResourceResponse$ O $string$ O $string$ O O O $ConversationResourceResponse$ O O O O $ErrorResponse$ O $string$ O $string$ O O O O $complex$ O O $string$ O $string$ O O O O O O O O $APIException$ O $number$ O $string$ O $string$ O O O O $number$ O $ErrorResponse$ O $ErrorResponse$ O $string$ O $string$ O O O O O
import { User } from 's' ; import { Bot } from 's' ; export interface FrameworkSettings { ngrokPath ? : string ; bypassNgrokLocalhost ? : boolean ; runNgrokAtStartup ? : boolean ; stateSizeLimit ? : number ; 0 ? : boolean ; useCodeValidation ? : boolean ; localhost ? : string ; locale ? : string ; autoUpdate ? : boolean ; usePrereleases ? : boolean ; collectUsageData ? : boolean ; hasBeenShownDataCollectionModal ? : boolean ; hash ? : string ; userGUID ? : string ; useCustomId ? : boolean ; } export interface WindowStateSettings { displayId ? : number ; zoomLevel ? : number ; top ? : number ; left ? : number ; width ? : number ; height ? : number ; theme ? : string ; availableThemes ? : { name : string ; href : string } [ ] ; } export interface UserSettings { currentUserId ? : string ; usersById ? : { [ id ] : User } ; users ? : { [ id ] : User } ; } export interface AzureSettings { signedInUser ? : string ; armToken ? : string ; persistLogin ? : boolean ; } export interface PersistentSettings { framework ? : FrameworkSettings ; savedBotUrls ? : { url : string ; lastAccessed : string } [ ] ; windowState ? : WindowStateSettings ; users ? : UserSettings ; } export interface Settings extends PersistentSettings { azure ? : Partial < AzureSettings > ; } export class SettingsImpl implements Settings { public framework : FrameworkSettings ; public bots : Bot [ ] ; public savedBotUrls : { url : string ; lastAccessed : string } [ ] ; public windowState : WindowStateSettings ; public users : UserSettings ; public azure : AzureSettings ; public constructor ( source ? ) { const { framework , savedBotUrls , windowState , users , azure } = source || { } ; Object . assign ( this , { framework , savedBotUrls , windowState , users , azure } ) ; } public toJSON ( ) < Settings > { const { framework , savedBotUrls , windowState , users , azure = { } } = this ; const { armToken , ... azureProps } = azure ; return { framework , savedBotUrls , windowState , users , azure : azureProps } ; } } export const frameworkDefault = { ngrokPath : 's' , bypassNgrokLocalhost : true , runNgrokAtStartup : false , stateSizeLimit : 0 , 0 : false , useCodeValidation : false , localhost : 's' , locale : 's' , usePrereleases : false , autoUpdate : false , collectUsageData : false , hasBeenShownDataCollectionModal : false , userGUID : 's' , useCustomId : false , } ; export const windowStateDefault = { zoomLevel : 0 , width : 0 , height : 0 , left : 0 , top : 0 , theme : 's' , availableThemes : [ ] , } ; export const settingsDefault = { azure : { } , framework : frameworkDefault , savedBotUrls : [ ] , windowState : windowStateDefault , users : { usersById : { } } , } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O $boolean$ O O O O $boolean$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O O O O $any$ O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $string$ O O O O $complex$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O $string$ O O O O $complex$ O O O O $string$ O O $any$ O O $complex$ O O O O $string$ O O $any$ O O O O O $any$ O $string$ O O O O $string$ O O O O $boolean$ O O O O O O O $any$ O $FrameworkSettings$ O O $any$ O $complex$ O O O $string$ O O O $string$ O O O O O O $WindowStateSettings$ O O $any$ O $UserSettings$ O O $any$ O O O O $any$ O $any$ O $Partial<AzureSettings>$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $FrameworkSettings$ O $any$ O O $Bot[]$ O $any$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $WindowStateSettings$ O $any$ O O $UserSettings$ O $any$ O O $AzureSettings$ O $any$ O O O O $Settings$ $Settings$ O O O O $FrameworkSettings$ O $complex$ O $WindowStateSettings$ O $UserSettings$ O $Partial<AzureSettings>$ $Settings$ O $Settings$ O O O O $ObjectConstructor$ O O O O O O $FrameworkSettings$ O $complex$ O $WindowStateSettings$ O $UserSettings$ O $Partial<AzureSettings>$ O O O O O $Partial$ O O O $any$ O O O O $FrameworkSettings$ O $complex$ O $WindowStateSettings$ O $UserSettings$ O $AzureSettings$ O O O O O O O O O $string$ O O $complex$ O O $AzureSettings$ O O O $FrameworkSettings$ O $complex$ O $WindowStateSettings$ O $UserSettings$ O $complex$ O $complex$ O O O O O O $FrameworkSettings$ O O $string$ O O O $true$ O O O $false$ O O O $number$ O O O $false$ O O O $false$ O O O $string$ O O O $string$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $string$ O O O $false$ O O O O O O O $WindowStateSettings$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O $undefined[]$ O O O O O O O O $Settings$ O O ${}$ O O O O $FrameworkSettings$ O $FrameworkSettings$ O $undefined[]$ O O O O $WindowStateSettings$ O $WindowStateSettings$ O $complex$ O O ${}$ O O O O O O O
export interface LuisModel { id : string ; name : string ; description : string ; culture : string ; usageScenario : string ; domain : string ; versionsCount : number ; createdDateTime : string ; endpoints : { PRODUCTION : any ; STAGING : any ; } ; endpointHitsCount : number ; activeVersion : string ; ownerEmail : string ; region : LuisRegion ; } export declare type LuisRegion = 's' | 's' | 's' ;	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $complex$ O O $any$ O O O $any$ O O O O O $number$ O O O $string$ O O O $string$ O O O $LuisRegion$ O $any$ O O O O O $any$ O O O O O O O
import { UserSettings } from 's' ; export interface ClientAwareSettings { appPath : string ; cwd : string ; locale : string ; serverUrl : string ; users : UserSettings ; savedBotUrls : { url : string ; lastAccessed : string } [ ] ; }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $UserSettings$ O $any$ O $complex$ O O $string$ O O O $string$ O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BotConfigWithPath , uniqueId } from 's' ; import { IEndpointService , ServiceTypes } from 's' ; import { Activity } from 's' ; import { Notification , NotificationImpl , NotificationType } from 's' ; import { ValueTypesMask } from 's' ; export function isObject ( item ) { return ! ! ( item && typeof item === 's' && ! Array . isArray ( item ) ) ; } export function mergeDeep < T extends { } , R extends { } > ( target : T , source : R ) : T & R { const output : T & R = { ... { } , ... target } ; { Object . keys ( source ) . forEach ( key => { if ( isObject ( source [ key ] ) ) { if ( ! ( key in target ) ) { Object . assign ( output , { [ key ] : source [ key ] } ) ; } else { output [ key ] = mergeDeep ( target [ key ] , source [ key ] ) ; } } else { Object . assign ( output , { [ key ] : source [ key ] } ) ; } } ) ; } return output ; } export function deepCopySlow ( obj ) { return JSON . parse ( JSON . stringify ( obj ) ) ; } export const newBot = ( ... bots : BotConfigWithPath [ ] ) : BotConfigWithPath => { return Object . assign ( { } , { name : 's' , description : 's' , services : [ ] , } , ... bots ) ; } ; export const getFirstBotEndpoint = ( bot ) : IEndpointService => { if ( bot . services && bot . services . length ) { return bot . services . find ( service => service . type === ServiceTypes . Endpoint ) as IEndpointService ; } return null ; } ; export const getBotDisplayName = ( bot = newBot ( ) ) : string => { return bot . name || bot . path || ( getFirstBotEndpoint ( bot ) ? getFirstBotEndpoint ( bot ) . endpoint : null ) || 's' ; } ; export const newEndpoint = ( ... endpoints : IEndpointService [ ] ) : IEndpointService => { return Object . assign ( { } , { type : ServiceTypes . Endpoint , name : 's' , id : uniqueId ( ) , appId : 's' , appPassword : 's' , endpoint : 's' , } , ... endpoints ) ; } ; export const newNotification = ( message , type = NotificationType . Info ) : Notification => { const notification = new NotificationImpl ( ) ; notification . message = message ; notification . type = type ; return notification ; } ; export function isChatFile ( file = 's' ) { return file . endsWith ( 's' ) ; } export function isTranscriptFile ( file = 's' ) { return file . endsWith ( 's' ) ; } export function traceContainsDebugData ( trace ) { const valueTypeByte = trace ? ~ ~ ValueTypesMask [ trace . valueType ] : 0 ; return ! ! ( ( ValueTypesMask . BotState | ValueTypesMask . Command | ValueTypesMask . Activity ) & valueTypeByte ) ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $boolean$ O $any$ O O O O O O $any$ O O $any$ O O O O $ArrayConstructor$ O $complex$ O $any$ O O O O O O $complex$ O $any$ O O O O $any$ O O O O O $T$ O $any$ O $R$ O $any$ O O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O O O $T$ O O O $ObjectConstructor$ O $complex$ O $R$ O O $void$ O $string$ O O O O $boolean$ O $R$ O $string$ O O O O O O O O $string$ O $T$ O O O $ObjectConstructor$ O O O $complex$ O O O $string$ O O $R$ O $string$ O O O O O O O $complex$ O $string$ O O $complex$ O $T$ O $string$ O O $R$ O $string$ O O O O O O O $ObjectConstructor$ O O O $complex$ O O O $string$ O O $R$ O $string$ O O O O O O O O O O $complex$ O O O O $any$ O $any$ O O O $JSON$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O O O O $any$ O O O $ObjectConstructor$ O O O O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O $any[]$ O O O O O O $any$ O O $BotConfigWithPath$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $string$ O O $BotConfigWithPath$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O $any[]$ O $any$ O O O O $any$ O O O $ObjectConstructor$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any[]$ O O O O O O $Notification$ O O $string$ O $NotificationType$ O $any$ O $NotificationType.Info$ O O $any$ O O O $NotificationImpl$ O O $any$ O O O $NotificationImpl$ O $string$ O $string$ O $NotificationImpl$ O $NotificationType$ O $NotificationType$ O O $NotificationImpl$ O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O O O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O O O O O O O $boolean$ O $Activity$ O O O $number$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O O $number$ O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface FluxStandardAction { type : string ; error ? : boolean ; meta ? : any ; payload ? : any ; }	O O $any$ O $string$ O O O $boolean$ O O O O $any$ O O O O $any$ O O O O O
export * from 's' ;	O O O O O
import { NotificationImpl } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const 0 = new NotificationImpl ( ) ; const 0 = new NotificationImpl ( ) ; expect ( 0 . id ) . not . toBeFalsy ( ) ; expect ( 0 . timestamp ) . not . toBeFalsy ( ) ; expect ( 0 . read ) . toBe ( false ) ; expect ( 0 . buttons ) . not . toBeFalsy ( ) ; expect ( 0 . buttons ) . toHaveLength ( 0 ) ; expect ( 0 . id ) . not . toBe ( 0 . id ) ; } ) ; test ( 's' , ( ) => { const notif = new NotificationImpl ( ) ; notif . addButton ( 's' ) ; notif . addButton ( 's' , ( a , b ) => a + b ) ; expect ( notif . buttons ) . toHaveLength ( 0 ) ; expect ( notif . buttons [ 0 ] . text ) . toBe ( 's' ) ; expect ( notif . buttons [ 0 ] . onClick ) . toBeFalsy ( ) ; expect ( notif . buttons [ 0 ] . text ) . toBe ( 's' ) ; expect ( notif . buttons [ 0 ] . onClick ( 0 , 0 ) ) . toBe ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $NotificationImpl$ O O $any$ O O O O $NotificationImpl$ O O $any$ O O O $any$ O $NotificationImpl$ O $string$ O O $any$ O $any$ O O O $any$ O $NotificationImpl$ O $number$ O O $any$ O $any$ O O O $any$ O $NotificationImpl$ O $boolean$ O O $any$ O O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O $any$ O $any$ O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O $any$ O O O O $any$ O $NotificationImpl$ O $string$ O O $any$ O $any$ O $NotificationImpl$ O $string$ O O O O O $any$ O O O O O O O O $NotificationImpl$ O O $any$ O O O $NotificationImpl$ O $void$ O O O O $NotificationImpl$ O $void$ O O O O $number$ O $number$ O O $number$ O $number$ O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O $any$ O O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O O O $string$ O O $any$ O O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O O O $any$ O O $any$ O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O O O $string$ O O $any$ O O O O $any$ O $NotificationImpl$ O $NotificationCTAButton[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O
import { SettingsImpl } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const settings = new SettingsImpl ( { azure : { armToken : 's' } , } ) ; expect ( JSON . stringify ( settings ) ) . toBe ( JSON . stringify ( { azure : { } } ) ) ; expect ( JSON . stringify ( settings . toJSON ( ) ) ) . toBe ( JSON . stringify ( { azure : { } } ) ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $SettingsImpl$ O O $any$ O O $complex$ O O $string$ O O O O O O O $any$ O $JSON$ O $complex$ O $SettingsImpl$ O O O $any$ O $JSON$ O $complex$ O O ${}$ O O O O O O O $any$ O $JSON$ O $complex$ O $SettingsImpl$ O $Partial<Settings>$ O O O O O $any$ O $JSON$ O $complex$ O O ${}$ O O O O O O O O O O O O O
import { BotConfigWithPath } from 's' ; import { IEndpointService , ServiceTypes } from 's' ; import { isObject , deepCopySlow , newBot , newEndpoint , getFirstBotEndpoint , newNotification } from 's' ; import { NotificationType } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { const someObj = { a : 0 , b : 's' , c : false } ; const 0 = [ 0 , 0 , 0 ] ; const 0 = 's' ; const 0 = null ; expect ( isObject ( someObj ) ) . toBe ( true ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const a = { outer : 0 , inner : { prop : 's' } } ; const b = deepCopySlow ( a ) ; expect ( b ) . toEqual ( a ) ; expect ( b ) . not . toBe ( a ) ; } ) ; test ( 's' , ( ) => { const 0 = newBot ( ) ; const 0 = { name : 's' , description : 's' , padlock : 's' , services : [ ] , } ; const 0 = newBot ( 0 ) ; expect ( 0 . name ) . toBe ( 's' ) ; expect ( 0 . description ) . toBe ( 's' ) ; expect ( 0 . services ) . toHaveLength ( 0 ) ; expect ( 0 . name ) . toBe ( 's' ) ; expect ( 0 . description ) . toBe ( 's' ) ; expect ( 0 . padlock ) . toBe ( 's' ) ; } ) ; test ( 's' , ( ) => { const 0 = newEndpoint ( ) ; const 0 = { id : 's' , endpoint : 's' , type : ServiceTypes . Endpoint , appId : 's' , appPassword : 's' , name : 's' , } ; const 0 = newEndpoint ( 0 ) ; expect ( 0 . type ) . toBe ( ServiceTypes . Endpoint ) ; expect ( 0 . id ) . toBeTruthy ( ) ; expect ( 0 . endpoint ) . toBe ( 's' ) ; expect ( 0 . id ) . toBe ( 's' ) ; expect ( 0 . endpoint ) . toBe ( 's' ) ; expect ( 0 . appId ) . toBe ( 's' ) ; expect ( 0 . appPassword ) . toBe ( 's' ) ; expect ( 0 . name ) . toBe ( 's' ) ; } ) ; test ( 's' , ( ) => { const endpoint = { id : 's' , endpoint : 's' , type : ServiceTypes . Endpoint , appId : 's' , appPassword : 's' , name : 's' , } ; const bot = { name : 's' , description : 's' , padlock : 's' , services : [ endpoint ] , } ; expect ( getFirstBotEndpoint ( bot ) ) . toBe ( endpoint ) ; } ) ; test ( 's' , ( ) => { const notif = newNotification ( 's' ) ; expect ( notif . message ) . toBe ( 's' ) ; expect ( notif . type ) . toBe ( NotificationType . Info ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $boolean$ O $any$ O $any$ O $any$ O $any$ O $Notification$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $string$ O O O $boolean$ O O O O O $number[]$ O O O O O O O O O O O O O O O $any$ O O O $any$ O $boolean$ O $complex$ O O O $any$ O O O O $any$ O $boolean$ O $number[]$ O O O $any$ O O O O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $boolean$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $IEndpointService$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $IEndpointService$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $string$ O O O $any[]$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $Notification$ O $Notification$ O O O O $any$ O $Notification$ O $string$ O O $any$ O O O O $any$ O $Notification$ O $NotificationType$ O O $any$ O $any$ O $NotificationType.Info$ O O O O O O O O
'js' module . exports = { extends : 's' , rules : { 's' : 's' , } , } ;	O $complex$ O $complex$ O O $string$ O O O $complex$ O O O O O O O O O O
import { Logger , LogItem , LogItemType , LogLevel , TextLogItem } from 's' ; import { Activity } from 's' ; import * as log from 's' ; function shortId ( id ) { return [ id . substr ( 0 , 0 ) , id . substr ( - 0 ) ] . join ( 's' ) ; } function logLevel ( level ) { switch ( level ) { case LogLevel . Error : return log . error ; case LogLevel . Info : return log . info ; case LogLevel . Warn : return log . warn ; default : return log . silly ; } } export default class NpmLogger implements Logger { public logActivity ( conversationId , activity , role ) { log . verbose ( shortId ( conversationId ) , `template` , activity ) ; } public logMessage ( conversationId , ... items : LogItem < TextLogItem > [ ] ) { items . forEach ( message => { if ( message . type === LogItemType . Text ) { logLevel ( message . payload . level ) ( shortId ( conversationId ) , message . payload . text ) ; } } ) ; } public logException ( conversationId , err ) { log . error ( shortId ( conversationId ) , err . message ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $string$ O $string$ O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O O O O O O $any$ O $LogLevel$ O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $void$ O $string$ O $Activity$ O $string$ O O $any$ O $any$ O $string$ O $string$ O O O O $any$ O O O O $void$ O $string$ O O $any[]$ O $any$ O $any$ O O O O O $any[]$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O O $void$ O $string$ O $Error$ O O $any$ O $any$ O $string$ O $string$ O O $Error$ O $string$ O O O O
import { readFile } from 's' ; import { BotEmulator } from 's' ; import { config } from 's' ; import getPort from 's' ; import * as Restify from 's' ; import CORS from 's' ; import NpmLogger from 's' ; const program = require ( 's' ) ; const packageJSON = require ( 's' ) ; config ( ) ; program . version ( packageJSON . version ) . option ( 's' , 's' , 0 ) . option ( 's' , 's' ) . option ( 's' , 's' + 's' ) . option ( 's' , 's' , 's' ) . option ( 's' , 's' , 's' ) . option ( 's' , 's' , 's' ) . option ( 's' , 's' , false ) . option ( 's' , 's' ) . on ( 's' , ( ) => { console . log ( ) ; console . log ( 's' ) ; console . log ( ) ; console . log ( 's' + 's' ) ; console . log ( ) ; console . log ( 's' ) ; console . log ( ) ; } ) . parse ( process . argv ) ; program . appId = program . appId || process . env . MICROSOFT_APP_ID ; program . appPassword = program . appPassword || process . env . MICROSOFT_APP_PASSWORD ; async function main ( ) { const server = Restify . createServer ( { name : 's' , } ) ; const cors = CORS ( { origins : [ 's' ] , allowHeaders : [ 's' , 's' ] , exposeHeaders : [ ] , } ) ; server . pre ( cors . preflight ) ; server . use ( cors . actual ) ; const port = program . port || ( await getPort ( 0 ) ) ; const bot = new BotEmulator ( async ( ) => program . serviceUrl , ( ) => program . serviceUrl , ( ) => null || `template` , { loggerOrLogService : new NpmLogger ( ) , } ) ; if ( program . file ) { const botsJSON = await new Promise < string > ( ( resolve , reject ) => { readFile ( program . file , { encoding : 's' } , ( err , result ) => ( err ? reject ( err ) : resolve ( result ) ) ) ; } ) ; const botEndpoints = JSON . parse ( botsJSON ) ; botEndpoints . forEach ( endpoint => bot . facilities . endpoints . push ( endpoint . botUrl , endpoint ) ) ; } else { bot . facilities . endpoints . push ( program . botUrl , { botId : program . botId , botUrl : program . botUrl , msaAppId : program . appId , msaPassword : program . appPassword , 0 : program . 0 , } ) ; } bot . mount ( server ) ; const endpoints = bot . facilities . endpoints . getAll ( ) ; const urls = Object . keys ( endpoints ) . reduce ( ( endpoint , key ) => [ ... endpoint , endpoints [ key ] . botUrl ] , [ ] ) . sort ( ) ; server . listen ( port , ( ) => { console . log ( `template` ) ; console . log ( `template` ) ; } ) ; } main ( ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O $Console$ O $void$ O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O $Console$ O $void$ O O O O O O $Console$ O $void$ O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O $string[]$ O O O O O O O $undefined[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $NpmLogger$ O O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O O O $any$ O $JSON$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O O $any[]$ O $string$ O O O O $any[]$ O $any$ O $string$ O O $any$ O O O O O O $any[]$ O O O $any$ O $any$ O $any$ O O O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O O O $Promise<void>$ O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
interface AttachmentParams { attachmentId : string ; viewId : string ; } export default AttachmentParams ;	O $any$ O $string$ O O O $string$ O O O O O O $any$ O
import { APIException , ErrorResponse } from 's' ; function createErrorResponse ( code , message ) { return { error : { code , message , } , } ; } export default function createAPIException ( statusCode , code , message ) { return { statusCode , error : createErrorResponse ( code , message ) , } ; }	O O $any$ O $any$ O O O O O $ErrorResponse$ O $string$ O $string$ O O O O $complex$ O O $string$ O $string$ O O O O O O O O O $APIException$ O $number$ O $string$ O $string$ O O O O $number$ O $any$ O $any$ O $string$ O $string$ O O O O O
import 0 from 's' ; export default function uniqueId ( ) { return 0 ( ) . toString ( ) ; }	O $any$ O O O O O O $string$ O O O O $any$ O O O $any$ O O O O
import { ErrorCodes } from 's' ; import { AttachmentData } from 's' ; import * as HttpStatus from 's' ; import createAPIException from 's' ; import uniqueId from 's' ; export default class Attachments { private attachments : { [ key ] : AttachmentData } = { } ; public getAttachmentData ( id ) { return this . attachments [ id ] ; } public uploadAttachment ( attachmentData ) { if ( ! attachmentData . type ) { throw createAPIException ( HttpStatus . BAD_REQUEST , ErrorCodes . MissingProperty , 's' ) ; } if ( ! attachmentData . 0 ) { throw createAPIException ( HttpStatus . BAD_REQUEST , ErrorCodes . MissingProperty , 's' ) ; } const attachment = { ... attachmentData , id : uniqueId ( ) } ; this . attachments [ attachment . id ] = attachment ; return attachment . id ; } }	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $string$ O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O $AttachmentData$ O $string$ O O O O O $complex$ O $string$ O O O O $string$ O $AttachmentData$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $string$ O $string$ O O O O O O $complex$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O
import * as Restify from 's' ; export default function getFacility ( facility ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { ( req as any ) . facility = facility ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $string$ O $any$ O O O O O O
import * as Restify from 's' ; export default function getRouteName ( routeName ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { ( req as any ) . routeName = routeName ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $string$ O $any$ O O O O O O
import { ErrorResponse } from 's' ; export default function createErrorResponse ( code , message ) { return { error : { code , message , } , } ; }	O O $any$ O O O O O O O $ErrorResponse$ O $string$ O $string$ O O O O $complex$ O O $string$ O $string$ O O O O O O
import { APIException , ErrorCodes , ErrorResponse } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import createErrorResponse from 's' ; function exceptionToAPIException ( exception ) { if ( exception . error && exception . statusCode ) { return exception ; } else { return { error : createErrorResponse ( ErrorCodes . ServiceError , exception . message ) , statusCode : HttpStatus . BAD_REQUEST , } ; } } export default function sendErrorResponse ( req : Restify . Request , res : Restify . Response , next : Restify . Next , exception ) { const apiException = exceptionToAPIException ( exception ) ; res . send ( apiException . statusCode , apiException . error ) ; res . end ( ) ; return apiException . error ; }	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $APIException$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $ErrorResponse$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O
import { AttachmentData , AttachmentInfo } from 's' ; import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import AttachmentParams from 's' ; import sendErrorResponse from 's' ; export default function getAttachmentInfo ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const parms = req . params ; const attachment = botEmulator . facilities . attachments . getAttachmentData ( parms . attachmentId ) ; if ( attachment ) { const attachmentInfo = { name : attachment . name , type : attachment . type , views : [ ] , } ; if ( attachment . 0 ) { attachmentInfo . views . push ( { viewId : 's' , size : Buffer . from ( Buffer . from ( attachment . 0 . buffer as ArrayBuffer ) . toString ( ) , 's' ) . length , } ) ; } if ( attachment . 0 ) { attachmentInfo . views . push ( { viewId : 's' , size : Buffer . from ( Buffer . from ( attachment . 0 . buffer as ArrayBuffer ) . toString ( ) , 's' ) . length , } ) ; } res . send ( HttpStatus . OK , attachmentInfo ) ; res . end ( ) ; } else { sendErrorResponse ( req , res , next , createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , `template` ) ) ; } } catch ( err ) { sendErrorResponse ( req , res , next , createAPIException ( HttpStatus . INTERNAL_SERVER_ERROR , ErrorCodes . ServiceError , err . message ) ) ; } next ( ) ; } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $AttachmentParams$ O $any$ O $any$ O O $AttachmentData$ O $BotEmulator$ O $Facilities$ O $Attachments$ O $any$ O $AttachmentParams$ O $string$ O O O O $any$ O O O $AttachmentInfo$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined[]$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $ArrayBufferConstructor$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $ArrayBufferConstructor$ O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O
import { RequestHandlerType , Server } from 's' ; import { BotEmulator } from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import getAttachment from 's' ; import getAttachmentInfo from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandlerType [ ] ) { const facility = getFacility ( 's' ) ; server . get ( 's' , ... uses , facility , getRouteName ( 's' ) , getAttachmentInfo ( botEmulator ) ) ; server . get ( 's' , ... uses , facility , getRouteName ( 's' ) , getAttachment ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O
export const authentication = { tokenEndpoint : 's' , openIdMetadata : 's' , botTokenAudience : 's' , } ; export const usGovernmentAuthentication = { channelService : 's' , tokenEndpoint : 's' , openIdMetadata : 's' , botTokenAudience : 's' , 0 : 's' , 0 : 's' , } ; export const 0 = { tokenIssuer : 's' , } ; export const 0 = { 0 : 's' , 0 : 's' , } ; export const speech = { tokenEndpoint : 's' , } ;	O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O O O
const 0 = require ( 's' ) ; const getPem = require ( 's' ) ; export default class OpenIdMetadata { private lastUpdated = 0 ; private keys : Key [ ] ; constructor ( public fetch , public url ) { } public async getKey ( keyId ) { const now = new Date ( ) . getTime ( ) ; if ( this . lastUpdated < now - 0 * 0 * 0 * 0 * 0 ) { try { await this . refreshCache ( ) ; } catch { } } return this . findKey ( keyId ) ; } private async refreshCache ( ) { const 0 = await this . fetch ( this . url ) ; if ( 0 . status >= 0 ) { throw new Error ( `template` ) ; } const openIdConfig = ( await 0 . json ( ) ) as OpenIdConfig ; const 0 = await this . fetch ( openIdConfig . jwks_uri ) ; if ( 0 . status >= 0 ) { throw new Error ( `template` ) ; } this . lastUpdated = new Date ( ) . getTime ( ) ; this . keys = ( await 0 . json ( ) ) . keys as Key [ ] ; } private findKey ( keyId ) { if ( ! this . keys ) { return null ; } for ( let i = 0 ; i < this . keys . length ; i ++ ) { if ( this . keys [ i ] . kid === keyId ) { const key = this . keys [ i ] ; if ( ! key . n || ! key . e ) { return null ; } return getPem ( 0 . 0 ( key . n ) , key . e ) ; } } return null ; } } interface OpenIdConfig { issuer : string ; authorization_endpoint : string ; jwks_uri : string ; id_token_signing_alg_values_supported : string [ ] ; token_endpoint_auth_methods_supported : string [ ] ; } interface Key { kty : string ; use : string ; kid : string ; 0 : string ; n : string ; e : string ; 0 : string [ ] ; }	O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $number$ O O O O $Key[]$ O $any$ O O O O O O $any$ O O $string$ O O O O O $Promise<string>$ O $string$ O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O $Promise<void>$ O O O O O O O O O O O $string$ O $string$ O O O O O $Promise<void>$ O O O O $any$ O O O O $any$ O O O $string$ O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O $OpenIdConfig$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $OpenIdConfig$ O $string$ O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O $Key[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $string$ O $string$ O O O O O O O $Key[]$ O O O O O O O O O $number$ O O O $number$ O O O $Key[]$ O $number$ O $number$ O O O O O O O $Key[]$ O $number$ O O $string$ O $string$ O O O $Key$ O O O $Key[]$ O $number$ O O O O O $Key$ O $string$ O O $Key$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $Key$ O $string$ O O $Key$ O $string$ O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O
import * as jwt from 's' ; import * as Restify from 's' ; import { authentication , usGovernmentAuthentication , 0 , 0 } from 's' ; import OpenIdMetadata from 's' ; export default function createBotFrameworkAuthenticationMiddleware ( fetch ) { const openIdMetadata = new OpenIdMetadata ( fetch , authentication . openIdMetadata ) ; const usGovOpenIdMetadata = new OpenIdMetadata ( fetch , usGovernmentAuthentication . openIdMetadata ) ; return async ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) => { const authorization = req . header ( 's' ) ; if ( ! authorization ) { next ( ) ; return ; } const [ authMethod , token ] = authorization . trim ( ) . split ( 's' ) ; const decoded = "s" . test ( authMethod ) && token && jwt . decode ( token , { complete : true } ) ; if ( ! decoded ) { res . status ( 0 ) ; res . end ( ) ; return ; } if ( decoded . payload . aud === usGovernmentAuthentication . botTokenAudience ) { const key = await usGovOpenIdMetadata . getKey ( decoded . header . kid ) ; let issuer ; if ( decoded . payload . ver === 's' ) { issuer = usGovernmentAuthentication . 0 ; } else if ( decoded . payload . ver === 's' ) { issuer = usGovernmentAuthentication . 0 ; } else { res . status ( 0 ) ; res . end ( ) ; return ; } try { ( req as any ) . jwt = jwt . verify ( token , key , { audience : usGovernmentAuthentication . botTokenAudience , clockTolerance : 0 , issuer , } ) ; } catch ( err ) { res . status ( 0 ) ; res . end ( ) ; return ; } } else { const key = await openIdMetadata . getKey ( decoded . header . kid ) ; if ( ! key ) { res . status ( 0 ) ; res . end ( ) ; return ; } let issuer ; if ( decoded . payload . ver === 's' ) { issuer = 0 . 0 ; } else if ( decoded . payload . ver === 's' ) { issuer = 0 . 0 ; } else { res . status ( 0 ) ; res . end ( ) ; return ; } try { ( req as any ) . jwt = jwt . verify ( token , key , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer , } ) ; } catch ( err ) { try { ( req as any ) . jwt = jwt . verify ( token , key , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . tokenIssuer , } ) ; } catch ( err ) { res . status ( 0 ) ; res . end ( ) ; return ; } } } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $complex$ O O O $complex$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $OpenIdMetadata$ O O $any$ O $any$ O $complex$ O $string$ O O O $OpenIdMetadata$ O O $any$ O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $boolean$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O $OpenIdMetadata$ O $Promise<string>$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O O O $string$ O $number$ O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O $string$ O O $OpenIdMetadata$ O $Promise<string>$ O $any$ O $any$ O $any$ O O O O O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O $complex$ O $string$ O $number$ O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O $complex$ O $string$ O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O
import * as Restify from 's' ; const { bodyReader , jsonBodyParser : restifyJsonBodyParser } = Restify . plugins ; export default function jsonBodyParser ( options ? ) : Restify . RequestHandler [ ] { options = options || { mapParams : false } ; options . bodyReader = true ; const read = bodyReader ( options ) ; const parseJson = restifyJsonBodyParser ( options ) ; function parseBody ( req , res , next ) { if ( req . method === 's' ) { next ( ) ; return ; } if ( req . method === 's' && ! options . requestBodyOnGet ) { next ( ) ; return ; } if ( req . contentLength ( ) === 0 && ! req . isChunked ( ) ) { next ( ) ; return ; } let parser ; switch ( req . contentType ( ) . toLowerCase ( ) ) { case 's' : parser = parseJson [ 0 ] ; break ; default : break ; } if ( parser ) { parser ( req , res , next ) ; } else { next ( ) ; } } return [ read , parseBody ] ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any[]$ O $any$ $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $void$ O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function deleteStateForUser ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { botEmulator . facilities . botState . deleteBotData ( req . params . userId ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $BotEmulator$ O $Facilities$ O $BotState$ O $void$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function fetchBotData ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { ( req as any ) . botData = botEmulator . facilities . botState . getBotData ( req . params . channelId , req . params . conversationId , req . params . userId ) ; return next ( ) ; } ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function getConversationData ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { res . send ( HttpStatus . OK , ( req as any ) . botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function getPrivateConversationData ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { res . send ( HttpStatus . OK , ( req as any ) . botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function getUserData ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { res . send ( HttpStatus . OK , ( req as any ) . botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { BotData } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function setConversationData ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const botData = botEmulator . facilities . botState . setBotData ( req . params . channelId , req . params . conversationId , req . params . userId , req . body as BotData ) ; res . send ( HttpStatus . OK , botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { BotData } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function setPrivateConversationData ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const botData = botEmulator . facilities . botState . setBotData ( req . params . channelId , req . params . conversationId , req . params . userId , req . body as BotData ) ; res . send ( HttpStatus . OK , botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { BotData } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function setUserData ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const botData = botEmulator . facilities . botState . setBotData ( req . params . channelId , req . params . conversationId , req . params . userId , req . body as BotData ) ; res . send ( HttpStatus . OK , botData ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import jsonBodyParser from 's' ; import deleteStateForUser from 's' ; import createFetchBotDataMiddleware from 's' ; import getConversationData from 's' ; import getPrivateConversationData from 's' ; import getUserData from 's' ; import setConversationData from 's' ; import setPrivateConversationData from 's' ; import setUserData from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( botEmulator . options . fetch ) ; const fetchBotDataMiddleware = createFetchBotDataMiddleware ( botEmulator ) ; const facility = getFacility ( 's' ) ; server . get ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getUserData ( botEmulator ) ) ; server . get ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getConversationData ( botEmulator ) ) ; server . get ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getPrivateConversationData ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setUserData ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setConversationData ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setPrivateConversationData ( botEmulator ) ) ; server . del ( 's' , ... uses , verifyBotFramework , facility , getRouteName ( 's' ) , deleteStateForUser ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $BotEmulator$ O $any$ O $any$ O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O
export default function statusCodeFamily ( statusCode : number | string , expectedFamily ) { if ( typeof statusCode === 's' ) { statusCode = + statusCode ; } return Math . floor ( statusCode / 0 ) === Math . floor ( expectedFamily / 0 ) ; }	O O O $boolean$ O $complex$ O O O O O $number$ O O O O O $complex$ O O O O $complex$ O O $string$ O O O $Math$ O $number$ O $number$ O O O O $Math$ O $number$ O $number$ O O O O O
import { URL , URLSearchParams } from 's' ; import { BotEndpointOptions , SpeechAuthenticationToken } from 's' ; import * as HttpStatus from 's' ; import { authentication , speech as speechEndpoint , usGovernmentAuthentication } from 's' ; import statusCodeFamily from 's' ; const TIME_TO_REFRESH = 0 * 0 * 0 ; export default class BotEndpoint { public accessToken ? : string ; public accessTokenExpires ? : number ; public appId ? : string ; public appPassword ? : string ; public speechAuthenticationToken ? : SpeechAuthenticationToken ; constructor ( public id ? , public botId ? , public botUrl ? , public msaAppId ? , public msaPassword ? , public 0 ? , public channelService ? , private _options ? ) { this . appId = msaAppId ; this . appPassword = msaPassword ; } private willTokenExpireWithin ( millisecondsToExpire ) { return Date . now ( ) + millisecondsToExpire >= this . speechAuthenticationToken . expireAt ; } private async fetchSpeechToken ( ) < string > { const res = await this . fetchWithAuth ( new URL ( speechEndpoint . tokenEndpoint ) . toString ( ) ) ; if ( statusCodeFamily ( res . status , 0 ) ) { let body ; try { body = ( await res . json ( ) ) as SpeechAuthenticationToken ; } catch ( e ) { throw new Error ( `template` ) ; } if ( body . access_Token ) { this . speechAuthenticationToken = { accessToken : body . access_Token , region : body . region , expireAt : body . expireAt , tokenLife : body . tokenLife , } ; return this . speechAuthenticationToken . accessToken ; } else { throw new Error ( body . error || 's' ) ; } } else if ( res . status === 0 ) { throw new Error ( 's' ) ; } else { throw new Error ( `template` ) ; } } public async getSpeechToken ( refresh = false ) < string > { if ( ! this . msaAppId || ! this . msaPassword ) { throw new Error ( 's' ) ; } if ( this . speechAuthenticationToken && ! refresh ) { const tokenIsExpired = Date . now ( ) >= this . speechAuthenticationToken . expireAt ; if ( tokenIsExpired || this . willTokenExpireWithin ( this . speechAuthenticationToken . tokenLife / 0 ) ) { return this . fetchSpeechToken ( ) ; } return this . speechAuthenticationToken . accessToken ; } else { return this . fetchSpeechToken ( ) ; } } public async fetchWithAuth ( url , fetchOptions = { } , forceRefresh = false ) { if ( this . msaAppId ) { try { fetchOptions . headers = { ... fetchOptions . headers , Authorization : `template` , } ; } catch ( e ) { return { status : e . status , message : "s" , } ; } } const response = await this . _options . fetch ( url , fetchOptions ) ; if ( ( response . status === HttpStatus . UNAUTHORIZED || response . status === HttpStatus . FORBIDDEN ) && ( ! forceRefresh && this . msaAppId ) ) { return this . fetchWithAuth ( url , fetchOptions , true ) ; } return response ; } private async getAccessToken ( forceRefresh = false ) < string > { if ( ! forceRefresh && this . accessToken && Date . now ( ) < this . accessTokenExpires - TIME_TO_REFRESH ) { return this . accessToken ; } const tokenEndpoint = this . channelService === usGovernmentAuthentication . channelService ? usGovernmentAuthentication . tokenEndpoint : authentication . tokenEndpoint ; const resp = await this . _options . fetch ( tokenEndpoint , { method : 's' , body : new URLSearchParams ( { grant_type : 's' , client_id : this . msaAppId , client_secret : this . msaPassword , scope : `template` , ... ( this . 0 ? { atver : 0 } : { } ) , } as { [ key ] : string } ) . toString ( ) , headers : { 's' : 's' , } , } ) ; if ( statusCodeFamily ( resp . status , 0 ) ) { const oauthResponse = await resp . json ( ) ; this . accessToken = oauthResponse . access_token ; this . accessTokenExpires = Date . now ( ) + oauthResponse . expires_in * 0 ; return this . accessToken ; } else { throw { message : 's' + resp . status , status : resp . status , body : resp . body , } ; } } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $complex$ O $complex$ O $complex$ O O O O O O O $boolean$ O O O O $number$ O O O O O O O O O O $any$ O O $string$ O O O O O $number$ O O O O O $string$ O O O O O $string$ O O O O O $any$ O O $any$ O O O O $string$ $string$ O O $string$ $string$ O O $string$ $string$ O O $string$ $string$ O O $string$ $string$ O O $boolean$ $boolean$ O O $string$ $string$ O O $any$ $BotEndpointOptions$ O O O O $string$ O $string$ O O O $string$ O $string$ O O O $boolean$ O $number$ O O O $DateConstructor$ O $number$ O O O $number$ O O O $any$ O $any$ O O O O $Promise$ O O O O O O O $any$ O O O O $any$ O O $any$ O $complex$ O $string$ O O $any$ O O O O O O $boolean$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O $Promise$ O $boolean$ O O O O O O O O O O O O $string$ O O O O $string$ O O O O $ErrorConstructor$ O O O O O O O O O $any$ O O $boolean$ O O O $boolean$ O $DateConstructor$ O $number$ O O O O O $any$ O $any$ O O O $boolean$ O O O $boolean$ O O O $any$ O $any$ O O O O O O O O $Promise<string>$ O O O O O O O $any$ O $any$ O O O O O O O $Promise<string>$ O O O O O O O $any$ O $string$ O $any$ O O O O $boolean$ O O O O O O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O $string$ O O O O O O $any$ O $string$ O $any$ O O O O O O $any$ O O O O $Promise$ O $boolean$ O O O O O O O O O O $boolean$ O O O $string$ O $DateConstructor$ O $number$ O O O O O $number$ O $number$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O $complex$ O $string$ O O $any$ O O O O $any$ O $any$ O $string$ O O $string$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O $string$ O O O $string$ O $string$ O O O O O O O $boolean$ O O $number$ O O O O O O O O O O O O $string$ O O O O O O $any$ O O O $complex$ O O O O O O O O O O O O O $boolean$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O $number$ O $DateConstructor$ O $number$ O O O $any$ O $any$ O O O O O O $string$ O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O
export interface TokenResponse { token : string ; connectionName : string ; }	O O $any$ O $string$ O O O $string$ O O O O
import { TokenResponse } from 's' ; export class TokenCache { private static tokenStore : { [ key ] : TokenResponse } = { } ; public static addTokenToCache ( botId , userId , connectionName , token ) { this . tokenStore [ this . tokenKey ( botId , userId , connectionName ) ] = { connectionName , token , } ; } public static getTokenFromCache ( botId , userId , connectionName ) { return this . tokenStore [ this . tokenKey ( botId , userId , connectionName ) ] ; } public static deleteTokenFromCache ( botId , userId , connectionName ) { delete this . tokenStore [ this . tokenKey ( botId , userId , connectionName ) ] ; } private static tokenKey ( botId , userId , connectionName ) { return `template` ; } }	O O $any$ O O O O O O $any$ O O O $complex$ O O O $string$ O O $any$ O O O O O O O $void$ O $string$ O $string$ O $string$ O $string$ O O O O $complex$ O O O $string$ O $string$ O $string$ O $string$ O O O O $string$ O $string$ O O O O O O $TokenResponse$ O $string$ O $string$ O $string$ O O O O O $complex$ O O O $string$ O $string$ O $string$ O $string$ O O O O O O $void$ O $string$ O $string$ O $string$ O O O O O $complex$ O O O $string$ O $string$ O $string$ O $string$ O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O
import { ResourceResponse } from 's' ; export default function createResourceResponse ( id ) { return { id } ; }	O O $any$ O O O O O O O $ResourceResponse$ O $string$ O O O O $string$ O O O
import { Activity , Attachment , CardAction , CardImage , MediaCard , OAuthCard , ReceiptCard , SigninCard , ThumbnailCard , } from 's' ; import { AttachmentContentTypes } from 's' ; export default abstract class ActivityVisitor { public traverseActivity ( messageActivity ) { if ( ! messageActivity ) { return ; } if ( messageActivity && messageActivity . attachments ) { messageActivity . attachments . forEach ( attachment => { this . traverseAttachment ( attachment ) ; } ) ; } } public traverseAttachment ( attachment ) { if ( attachment ) { switch ( attachment . contentType ) { case AttachmentContentTypes . animationCard : case AttachmentContentTypes . videoCard : case AttachmentContentTypes . audioCard : this . traverseMediaCard ( attachment . content as MediaCard ) ; break ; case AttachmentContentTypes . heroCard : case AttachmentContentTypes . thumbnailCard : this . traverseThumbnailCard ( attachment . content as ThumbnailCard ) ; break ; case AttachmentContentTypes . receiptCard : this . traverseReceiptCard ( attachment . content as ReceiptCard ) ; break ; case AttachmentContentTypes . signInCard : this . traverseSignInCard ( attachment . content as SigninCard ) ; break ; case AttachmentContentTypes . oAuthCard : this . traverseOAuthCard ( attachment . content as OAuthCard ) ; break ; default : break ; } } } public traverseMediaCard ( mediaCard ) { if ( mediaCard ) { this . traverseCardImage ( mediaCard . image ) ; this . traverseButtons ( mediaCard . buttons ) ; } } public traverseThumbnailCard ( thumbnailCard ) { this . visitCardAction ( thumbnailCard . tap ) ; this . traverseButtons ( thumbnailCard . buttons ) ; this . traverseCardImages ( thumbnailCard . images ) ; } public traverseSignInCard ( signInCard ) { this . traverseButtons ( signInCard . buttons ) ; } public traverseOAuthCard ( oauthCard ) { const buttons = oauthCard . buttons ; if ( buttons ) { buttons . forEach ( cardAction => this . visitOAuthCardAction ( oauthCard . connectionName , cardAction ) ) ; } } public traverseReceiptCard ( receiptCard ) { this . visitCardAction ( receiptCard . tap ) ; this . traverseButtons ( receiptCard . buttons ) ; } public traverseButtons ( buttons : CardAction [ ] ) { if ( buttons ) { buttons . forEach ( cardAction => this . visitCardAction ( cardAction ) ) ; } } public traverseCardImages ( cardImages : CardImage [ ] ) { if ( cardImages ) { cardImages . forEach ( image => { this . traverseCardImage ( image ) ; } ) ; } } public traverseCardImage ( cardImage ) { if ( cardImage ) { this . visitCardAction ( cardImage . tap ) ; } } protected abstract visitCardAction ( cardAction ) ; protected visitOAuthCardAction ( connectionName , cardAction ) { this . visitCardAction ( cardAction ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $void$ O $Activity$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O O O O O O O $void$ O $Attachment$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $void$ O $MediaCard$ O O O O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O O $void$ O $ThumbnailCard$ O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $SigninCard$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $OAuthCard$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O O O $void$ O $ReceiptCard$ O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $void$ O $any[]$ O $any$ O O O O O O $any[]$ O O $any[]$ O $void$ O $any$ O O O $any$ O $any$ O O O O O O $void$ O $any[]$ O $any$ O O O O O O $any[]$ O O $any[]$ O $void$ O $any$ O O O O $void$ O $any$ O O O O O O O O $void$ O $CardImage$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $CardAction$ O O O $void$ O $string$ O $CardAction$ O O O O $any$ O $any$ O O O O
import { Activity , CardAction } from 's' ; import ActivityVisitor from 's' ; export default class OAuthClientEncoder extends ActivityVisitor { public static OAuthEmulatorUrlProtocol : string = 's' ; private _conversationId : string ; constructor ( activity ) { super ( ) ; this . _conversationId = activity && activity . conversation ? activity . conversation . id : undefined ; } protected visitCardAction ( cardAction ) { return null ; } protected visitOAuthCardAction ( connectionName , cardAction ) { if ( this . _conversationId && cardAction && cardAction . type === 's' && ! cardAction . value ) { const url = OAuthClientEncoder . OAuthEmulatorUrlProtocol + 's' + connectionName + 's' + this . _conversationId ; cardAction . type = 's' ; cardAction . value = url ; } } }	O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O O O O $string$ O O O O O $Activity$ O O O O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O $any$ O $CardAction$ O O O O O O O $void$ O $string$ O $CardAction$ O O O O O O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $string$ O $any$ O $string$ O O O $string$ O O O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O
import { CardAction } from 's' ; import ActivityVisitor from 's' ; export default class PaymentEncoder extends ActivityVisitor { public static PaymentEmulatorUrlProtocol : string = 's' ; protected visitCardAction ( cardAction ) { if ( cardAction && cardAction . type === 's' ) { const paymentRequest = cardAction . value as PaymentRequest ; const url = PaymentEncoder . PaymentEmulatorUrlProtocol + 's' + JSON . stringify ( paymentRequest ) ; cardAction . type = 's' ; cardAction . value = url ; } } }	O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O O O O $void$ O $CardAction$ O O O O $any$ O $any$ O $any$ O O O O O $PaymentRequest$ O $any$ O $any$ O $complex$ O O $string$ O $any$ O $string$ O O O $JSON$ O $complex$ O $PaymentRequest$ O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O
import { EventEmitter } from 's' ; import * as HttpStatus from 's' ; import updateIn from 's' ; import { appSettingsItem , CheckoutConversationSession , EmulatorMode , ErrorCodes , externalLinkItem , isLocalHostUrl , LogLevel , networkRequestItem , networkResponseItem , PaymentOperations , PaymentRequest , PaymentRequestComplete , PaymentRequestUpdate , ResourceResponse , textItem , TranscriptRecord , User , } from 's' ; import { Activity , Attachment , ChannelAccount , ConversationAccount , IContactRelationUpdateActivity , IInvokeActivity , IMessageActivity , } from 's' ; import { traceContainsDebugData , ValueTypesMask } from 's' ; import { BotEmulator } from 's' ; import { TokenCache } from 's' ; import createAPIException from 's' ; import createResourceResponse from 's' ; import OAuthClientEncoder from 's' ; import PaymentEncoder from 's' ; import uniqueId from 's' ; import BotEndpoint from 's' ; const moment = require ( 's' ) ; const maxDataUrlLength = Math . pow ( 0 , 0 ) ; interface ActivityBucket { activity : Activity ; watermark : number ; } export default class Conversation extends EventEmitter { public botEmulator : BotEmulator ; public botEndpoint : BotEndpoint ; public conversationId : string ; public user : User ; public mode : EmulatorMode ; public stateApiDeprecationWarningShown : boolean = false ; public codeVerifier : string = undefined ; public members : User [ ] = [ ] ; public nextWatermark = 0 ; private activities : ActivityBucket [ ] = [ ] ; private transcript : TranscriptRecord [ ] = [ ] ; private get conversationIsTranscript ( ) { return this . conversationId . includes ( 's' ) ; } constructor ( botEmulator , botEndpoint , conversationId , user , mode ) { super ( ) ; Object . assign ( this , { botEmulator , botEndpoint , conversationId , user , mode } ) ; this . members . push ( { id : ( botEndpoint && botEndpoint . botId ) || 's' , name : 's' , } ) ; this . members . push ( { id : user . id , name : user . name } ) ; } public normalize ( ) { this . transcript . length = 0 ; this . activities . length = 0 ; } public async postActivityToBot ( activity , recordInConversation ) { if ( ! this . botEndpoint ) { return this . botEmulator . facilities . logger . logMessage ( this . conversationId , textItem ( LogLevel . Error , `template` ) ) ; } activity = this . postage ( this . botEndpoint . botId , activity ) ; activity . from = activity . from || this . user ; activity . locale = this . botEmulator . facilities . locale ; if ( ! activity . recipient . name ) { activity . recipient . name = 's' ; } if ( ! activity . recipient . role ) { activity . recipient . role = 's' ; } activity . serviceUrl = await this . botEmulator . getServiceUrl ( this . botEndpoint . botUrl ) ; if ( ! this . conversationIsTranscript && ! isLocalHostUrl ( this . botEndpoint . botUrl ) && isLocalHostUrl ( activity . serviceUrl ) ) { this . botEmulator . facilities . logger . logMessage ( this . conversationId , textItem ( LogLevel . Error , 's' + 's' ) ) ; this . botEmulator . facilities . logger . logMessage ( this . conversationId , externalLinkItem ( 's' , 's' ) ) ; this . botEmulator . facilities . logger . logMessage ( this . conversationId , appSettingsItem ( 's' ) ) ; } const options = { body : JSON . stringify ( activity ) , headers : { 's' : 's' , } , method : 's' , } ; if ( recordInConversation ) { this . addActivityToQueue ( { ... activity } as Activity ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } ] ; this . emit ( 's' ) ; let status = 0 ; let resp = { json : async ( ) => ( { } ) } ; if ( ! this . conversationIsTranscript ) { resp = await this . botEndpoint . fetchWithAuth ( this . botEndpoint . botUrl , options ) ; status = resp . status ; } return { activityId : activity . id , response : resp , statusCode : status , } ; } public async sendConversationUpdate ( membersAdded : User [ ] , membersRemoved : User [ ] ) { if ( this . mode === 's' ) { return ; } const activity = { type : 's' , membersAdded , membersRemoved , } ; if ( this . activities . some ( act => act . activity == activity ) ) { return ; } const result = await this . postActivityToBot ( activity as Activity , false ) ; if ( ! "s" . test ( 's' + result . statusCode ) ) { this . botEmulator . facilities . logger . logException ( this . conversationId , result . response ) ; } const { headers , message } = result . response ; this . botEmulator . facilities . logger . logMessage ( this . conversationId , networkRequestItem ( 's' , activity , { 's' : 's' , } , 's' , 's' ) , networkResponseItem ( { id : result . activityId , message } , headers , result . statusCode , result . status , 's' ) , textItem ( LogLevel . Debug , `template` ) ) ; } public postActivityToUser ( activity , isHistoric = false ) { activity = this . processActivity ( activity ) ; activity = this . postage ( this . user . id , activity , isHistoric ) ; if ( ! activity . from . name ) { activity . from . name = 's' ; } if ( activity . name === 's' ) { activity . value . from . role = 's' ; } else if ( activity . name === 's' ) { activity . value . from . role = 's' ; } if ( ! activity . locale ) { activity . locale = this . botEmulator . facilities . locale ; } if ( ! activity . recipient . role ) { activity . recipient . role = 's' ; } this . addActivityToQueue ( activity ) ; this . transcript = [ ... this . transcript , { type : 's' , activity } ] ; this . emit ( 's' ) ; if ( activity . type === 's' ) { this . emit ( 's' ) ; } return createResourceResponse ( activity . id ) ; } public processActivity ( activity ) { const visitors = [ new PaymentEncoder ( ) , new OAuthClientEncoder ( activity ) ] ; activity = { ... activity } ; visitors . forEach ( v => v . traverseActivity ( activity ) ) ; return activity ; } public async processActivityForDataUrls ( activity ) < Activity > { const visitor = new DataUrlEncoder ( this . botEmulator ) ; activity = { ... activity } ; await visitor . traverseActivity ( activity ) ; return activity ; } public updateActivity ( updatedActivity ) { const { id } = updatedActivity ; const index = this . activities . findIndex ( entry => entry . activity . id === id ) ; if ( index === - 0 ) { throw createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , 's' ) ; } this . activities = updateIn ( this . activities , [ index , 's' ] , activity => ( { ... activity , ... updatedActivity } ) ) ; updatedActivity = this . activities [ index ] . activity ; this . emit ( 's' , { activity : updatedActivity } ) ; this . transcript = [ ... this . transcript , { type : 's' , activity : updatedActivity } ] ; this . emit ( 's' ) ; return createResourceResponse ( id ) ; } public deleteActivity ( id ) { const activityIndex = this . activities . findIndex ( entry => entry . activity . id === id ) ; if ( activityIndex === - 0 ) { throw createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , 's' ) ; } const { activity } = this . activities [ activityIndex ] ; this . activities = updateIn ( this . activities , [ activityIndex ] ) ; this . emit ( 's' , { activity } ) ; this . transcript = [ ... this . transcript , { type : 's' , activity : { id } } as TranscriptRecord ] ; this . emit ( 's' ) ; } public async addMember ( id , name ) < User > { name = name || `template` ; id = id || uniqueId ( ) ; const user = { name , id } ; this . members = [ ... this . members , user ] ; this . emit ( 's' , { user } ) ; if ( this . botEndpoint ) { await this . sendConversationUpdate ( [ user ] , undefined ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity : { type : 's' , membersAdded : [ user ] , } as Activity , } , ] ; this . emit ( 's' ) ; return user ; } public async removeMember ( id ) { const index = this . members . findIndex ( val => val . id === id ) ; if ( index !== - 0 ) { const user = this . members [ index ] ; this . members = updateIn ( this . members , [ index ] ) ; this . emit ( 's' , { user } ) ; } await this . sendConversationUpdate ( undefined , [ { id , name : undefined } ] ) ; this . transcript = [ ... this . transcript , { type : 's' , activity : { type : 's' , membersRemoved : [ { id } ] , } as Activity , } , ] ; this . emit ( 's' ) ; } public async sendContactAdded ( ) { const activity = { type : 's' , action : 's' , } as IContactRelationUpdateActivity ; try { await this . postActivityToBot ( activity as Activity , false ) ; } catch ( err ) { this . botEmulator . facilities . logger . logException ( this . conversationId , err ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } as TranscriptRecord ] ; this . emit ( 's' ) ; } public async sendContactRemoved ( ) { const activity = { type : 's' , action : 's' , } as IContactRelationUpdateActivity ; try { await this . postActivityToBot ( activity as Activity , false ) ; } catch ( err ) { this . botEmulator . facilities . logger . logException ( this . conversationId , err ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } as TranscriptRecord ] ; this . emit ( 's' ) ; } public async sendTyping ( ) { const activity = { type : 's' , } as Activity ; try { await this . postActivityToBot ( activity , false ) ; } catch ( err ) { this . botEmulator . facilities . logger . logException ( this . conversationId , err ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } ] ; this . emit ( 's' ) ; } public async sendPing ( ) { const activity = { type : 's' , } as Activity ; try { await this . postActivityToBot ( activity , false ) ; } catch ( err ) { this . botEmulator . facilities . logger . logException ( this . conversationId , err ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } ] ; this . emit ( 's' ) ; } public async sendDeleteUserData ( ) { const activity = { type : 's' , } as Activity ; try { await this . postActivityToBot ( activity , false ) ; } catch ( err ) { this . botEmulator . facilities . logger . logException ( this . conversationId , err ) ; } this . transcript = [ ... this . transcript , { type : 's' , activity } ] ; this . emit ( 's' ) ; } public async sendUpdateShippingAddressOperation ( checkoutSession , request , shippingAddress , shippingOptionId ) { return this . sendUpdateShippingOperation ( checkoutSession , PaymentOperations . UpdateShippingAddressOperationName , request , shippingAddress , shippingOptionId ) ; } public async sendUpdateShippingOptionOperation ( checkoutSession , request , shippingAddress , shippingOptionId ) { return this . sendUpdateShippingOperation ( checkoutSession , PaymentOperations . UpdateShippingOptionOperationName , request , shippingAddress , shippingOptionId ) ; } public async sendPaymentCompleteOperation ( checkoutSession , request , shippingAddress , shippingOptionId , payerEmail , payerPhone ) { if ( ! this . botEndpoint ) { return this . botEmulator . facilities . logger . logMessage ( this . conversationId , textItem ( LogLevel . Error , 's' ) ) ; } const paymentTokenHeader = { amount : request . details . total . amount , expiry : 's' , format : 0 , merchantId : request . methodData [ 0 ] . data . merchantId , paymentRequestId : request . id , timestamp : 's' , } ; const paymentTokenHeaderStr = JSON . stringify ( paymentTokenHeader ) ; const pthBytes = Buffer . from ( paymentTokenHeaderStr ) . toString ( 's' ) ; const paymentTokenSource = 's' ; const ptsBytes = Buffer . from ( paymentTokenSource ) . toString ( 's' ) ; const ptsigBytes = Buffer . from ( 's' ) . toString ( 's' ) ; const updateValue = { id : request . id , paymentRequest : request , paymentResponse : { details : { paymentToken : pthBytes + 's' + ptsBytes + 's' + ptsigBytes , } , methodName : request . methodData [ 0 ] . supportedMethods [ 0 ] , payerEmail , payerPhone , shippingAddress , shippingOption : shippingOptionId , } , } ; const activity = { type : 's' , name : PaymentOperations . PaymentCompleteOperationName , from : { id : checkoutSession . checkoutFromId } as ChannelAccount , conversation : { id : checkoutSession . checkoutConversationId } as ConversationAccount , relatesTo : { activityId : checkoutSession . paymentActivityId , bot : { id : this . botEndpoint . botId } as ChannelAccount , channelId : 's' , conversation : { id : this . conversationId } as ConversationAccount , serviceUrl : await this . botEmulator . getServiceUrl ( this . botEndpoint . botUrl ) , user : this . botEmulator . facilities . users . usersById ( this . botEmulator . facilities . users . currentUserId ) , } , value : updateValue , } as IInvokeActivity ; const { response } = await this . postActivityToBot ( activity as Activity , false ) ; return response ; } public async sendTokenResponse ( connectionName , token , doNotCache ? ) { const userId = this . botEmulator . facilities . users . currentUserId ; if ( ! doNotCache ) { TokenCache . addTokenToCache ( this . botEndpoint . botId , userId , connectionName , token ) ; } const activity = { type : 's' , name : 's' , value : { connectionName , token , } , } as Activity ; return this . postActivityToBot ( activity as Activity , false ) ; } public getActivitiesSince ( watermark ) : { activities : Activity [ ] ; watermark : number } { this . activities = watermark ? this . activities . filter ( entry => entry . watermark >= watermark ) : this . activities ; return { activities : this . activities . map ( entry => entry . activity ) , watermark : this . nextWatermark , } ; } public feedActivities ( activities : Activity [ ] ) { const { id : currUserId } = this . user ; let origUserId = null ; let origBotId = null ; activities . forEach ( activity => { if ( activity . conversation ) { activity . conversation . id = this . conversationId ; } const { type } = activity ; if ( activity . recipient && ( type === 's' || type === 's' || type === 's' || type === 's' ) ) { if ( ! origBotId && activity . recipient . role === 's' ) { origBotId = activity . recipient . id ; } if ( ! origUserId && activity . recipient . role === 's' ) { origUserId = activity . recipient . id ; } } } ) ; if ( this . botEndpoint && origUserId && origBotId ) { activities . forEach ( activity => { if ( activity . recipient . id === origBotId ) { activity . recipient . id = this . botEndpoint . botId ; } if ( activity . from . id === origBotId ) { activity . from . id = this . botEndpoint . botId ; } if ( activity . recipient . id === origUserId ) { activity . recipient . id = currUserId ; } if ( activity . from . id === origUserId ) { activity . from . id = currUserId ; } } ) ; } activities . forEach ( activity => { if ( activity . recipient && activity . recipient . role === 's' ) { activity = this . processActivity ( activity ) ; } this . addActivityToQueue ( activity ) ; } ) ; } public async getTranscript ( valueTypesToExtract = 0 ) < Activity [ ] > { const activities = this . transcript . filter ( record => record . type === 's' ) . map ( record => { const { activity } = record ; const extractValue = valueTypesToExtract && activity . valueType && ! ! ( valueTypesToExtract & ValueTypesMask [ activity . valueType ] ) ; return extractValue ? activity . value : activity ; } ) ; for ( let i = 0 ; i < activities . length ; i ++ ) { await this . processActivityForDataUrls ( activities [ i ] ) ; } return activities ; } private async sendUpdateShippingOperation ( checkoutSession , operation , request , shippingAddress , shippingOptionId ) { if ( ! this . botEndpoint ) { return this . botEmulator . facilities . logger . logMessage ( this . conversationId , textItem ( LogLevel . Error , 's' ) ) ; } const updateValue = { id : request . id , shippingAddress , shippingOption : shippingOptionId , details : request . details , } ; const activity = { type : 's' , name : operation , from : { id : checkoutSession . checkoutFromId } , conversation : { id : checkoutSession . checkoutConversationId } , relatesTo : { activityId : checkoutSession . paymentActivityId , bot : { id : this . botEndpoint . botId } , channelId : 's' , conversation : { id : this . conversationId } , serviceUrl : await this . botEmulator . getServiceUrl ( this . botEndpoint . botUrl ) , user : this . botEmulator . facilities . users . usersById ( this . botEmulator . facilities . users . currentUserId ) , } , value : updateValue , } as IInvokeActivity ; const { response } = await this . postActivityToBot ( activity as Activity , false ) ; return response ; } private postage ( recipientId , activity < Activity > , isHistoric = false ) { const date = moment ( ) ; const timestamp = isHistoric ? activity . timestamp : date . toISOString ( ) ; const recipient = isHistoric ? activity . recipient : ( { id : recipientId } as ChannelAccount ) ; return { ... activity , channelId : 's' , conversation : activity . conversation || ( { id : this . conversationId } as ConversationAccount ) , id : activity . id || uniqueId ( ) , localTimestamp : date . format ( ) , recipient , timestamp , } as Activity ; } private addActivityToQueue ( activity ) { if ( this . mode === 's' && ! traceContainsDebugData ( activity ) ) { return ; } if ( ! ( activity . channelData || { } ) . postback ) { this . activities = [ ... this . activities , { activity , watermark : this . nextWatermark ++ } ] ; } if ( activity && activity . recipient ) { this . botEmulator . facilities . logger . logActivity ( this . conversationId , activity , activity . recipient . role ) ; } } } class DataUrlEncoder { constructor ( public bot ) { } public async traverseActivity ( activity ) { const IMessageActivity = activity as IMessageActivity ; if ( IMessageActivity ) { await this . traverseIMessageActivity ( IMessageActivity ) ; } } public async traverseIMessageActivity ( IMessageActivity ) { if ( IMessageActivity && IMessageActivity . attachments ) { for ( let i = 0 ; i < IMessageActivity . attachments . length ; i ++ ) { await this . traverseAttachment ( IMessageActivity . attachments [ i ] ) ; } } } public async traverseAttachment ( attachment ) { if ( attachment && attachment . contentUrl ) { await this . visitContentUrl ( attachment ) ; } } protected async visitContentUrl ( attachment ) { if ( this . shouldBeDataUrl ( attachment . contentUrl ) ) { attachment . contentUrl = await this . makeDataUrl ( attachment . contentUrl ) ; } } protected async makeDataUrl ( url ) < string > { let resultUrl = url ; const imported = await this . bot . options . fetch ( url , { } ) ; if ( parseInt ( imported . headers . get ( 's' ) , 0 ) < maxDataUrlLength ) { const buffer = await imported . buffer ( ) ; const encoded = Buffer . from ( buffer ) . toString ( 's' ) ; const typeString = imported . headers . get ( 's' ) ; resultUrl = 's' + typeString + 's' + encoded ; } return resultUrl ; } protected shouldBeDataUrl ( url ) { return url && ( isLocalHostUrl ( url ) || url . indexOf ( 's' ) !== - 0 ) ; } }	O O $any$ O O O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O O $any$ O O O O $any$ O $any$ O O O O O $number$ O $Math$ O $number$ O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O $BotEmulator$ O $any$ O O $BotEndpoint$ O $any$ O O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O O $boolean$ O O O O O O $string$ O O O $undefined$ O O $any[]$ O $any$ O O O O O O O $number$ O O O O $ActivityBucket[]$ O $any$ O O O O O O O $any[]$ O $any$ O O O O O O O O $boolean$ O O O O O O $string$ O $boolean$ O O O O O O O $BotEmulator$ O $BotEndpoint$ O $string$ O $User$ O $EmulatorMode$ O O O O O O $ObjectConstructor$ O O O O O O $BotEmulator$ O $BotEndpoint$ O $string$ O $any$ O $any$ O O O O O $any[]$ O $number$ O O $string$ O O $BotEndpoint$ O $BotEndpoint$ O $string$ O O O O $string$ O O O O O O O O $any[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O O O O O $any[]$ O $number$ O O O O O $ActivityBucket[]$ O $number$ O O O O O O $Promise<any>$ O $Activity$ O $boolean$ O O O O O O O $BotEndpoint$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O O O $BotEndpoint$ O $string$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $BotEmulator$ O $Facilities$ O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $BotEmulator$ O $Promise<string>$ O O O $BotEndpoint$ O $string$ O O O O O O O $boolean$ O O $any$ O O O $BotEndpoint$ O $string$ O O $any$ O $any$ O $any$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O O $complex$ O O $string$ O $JSON$ O $complex$ O $any$ O O $complex$ O O O O O O O O $string$ O O O O O O O $boolean$ O O O O $void$ O O O $any$ O O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O O O O $any$ O O O O O $number$ O O O O $any$ O O $Promise<{}>$ O O O O O O O O O O O O O O O O $boolean$ O O $any$ O O O O $BotEndpoint$ O $any$ O O O $BotEndpoint$ O $string$ O $complex$ O O $number$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O $number$ O O O O O O $Promise<void>$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $any[]$ O $any[]$ O O O O O O O $ActivityBucket[]$ O $boolean$ O $ActivityBucket$ O $ActivityBucket$ O $any$ O $complex$ O O O O O O O $any$ O O O O $Promise<any>$ O $complex$ O $any$ O O O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O $complex$ O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $ResourceResponse$ O $Activity$ O $boolean$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $BotEmulator$ O $Facilities$ O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $Activity$ O $Activity$ O O O $complex$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O $complex$ O $void$ O $complex$ O $complex$ O $void)$ O $any$ O O O O $any$ O O O O $Promise$ O $Activity$ O O $any$ O O O $DataUrlEncoder$ O O $any$ O O O $BotEmulator$ O O $any$ O O O $any$ O O O $DataUrlEncoder$ O $Promise<void>$ O $any$ O O O $any$ O O O $ResourceResponse$ O $Activity$ O O O O $any$ O O $any$ O O $number$ O O O $ActivityBucket[]$ O $number$ O $ActivityBucket$ O $ActivityBucket$ O $any$ O $any$ O $any$ O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $ActivityBucket[]$ O $any$ O O O $ActivityBucket[]$ O O $number$ O O O O $any$ O O O O $any$ O O $any$ O O O O $any$ O O O $ActivityBucket[]$ O $number$ O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O O $void$ O $string$ O O O $number$ O O O $ActivityBucket[]$ O $number$ O $ActivityBucket$ O $ActivityBucket$ O $any$ O $any$ O $string$ O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $ActivityBucket[]$ O $number$ O O O O $ActivityBucket[]$ O $any$ O O O $ActivityBucket[]$ O O $number$ O O O O O $any$ O O O O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O O O O $any$ O O O O O O O $Promise$ O $string$ O $string$ O O $any$ O O $string$ O $string$ O O O $string$ O $string$ O $string$ O O O O $complex$ O O $string$ O $string$ O O O O $any[]$ O O O O O $any[]$ O $complex$ O O O O $any$ O O O O $complex$ O O O O O O O $BotEndpoint$ O O O O O $Promise<void>$ O O $complex$ O O $undefined$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O $complex$ O O O O $Promise<void>$ O $string$ O O O $number$ O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $string$ O O O O $number$ O O O O O O $any$ O O O $any[]$ O $number$ O O O O $any[]$ O $any$ O O O $any[]$ O O $number$ O O O O O $any$ O O O O $any$ O O O O O O O $Promise<void>$ O $undefined$ O O O $string$ O $undefined$ O $undefined$ O O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O $string$ O O O $complex$ O O O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O O O O O O $Promise<any>$ O $any$ O $any$ O O O O O O O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O $any$ O O O O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O O O O O O $Promise<any>$ O $any$ O $any$ O O O O O O O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O $any$ O O O O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O O $string$ O O O O O $any$ O O O O O O $Promise<any>$ O $any$ O O O O O O O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O O O O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O O $string$ O O O O O $any$ O O O O O O $Promise<any>$ O $any$ O O O O O O O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O O O O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O O $string$ O O O O O $any$ O O O O O O $Promise<any>$ O $any$ O O O O O O O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any[]$ O O O O O $any[]$ O O $string$ O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $CheckoutConversationSession$ O $PaymentRequest$ O $PaymentAddress$ O $string$ O O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O $PaymentAddress$ O $string$ O O O O O $Promise<any>$ O $CheckoutConversationSession$ O $PaymentRequest$ O $PaymentAddress$ O $string$ O O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O $PaymentAddress$ O $string$ O O O O O $Promise<any>$ O $CheckoutConversationSession$ O $PaymentRequest$ O $PaymentAddress$ O $string$ O $string$ O $string$ O O O O O O O $BotEndpoint$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $number$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O $JSON$ O $complex$ O $complex$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $PaymentRequestComplete$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $complex$ O O $string$ O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $string$ O $string$ O $PaymentAddress$ O $string$ O $string$ O O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $BotEndpoint$ O $string$ O O $any$ O $string$ O O O $any$ O O $string$ O O O $string$ O O $any$ O $string$ O O O O $BotEmulator$ O $Promise<string>$ O O O $BotEndpoint$ O $string$ O O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $string$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $Promise<any>$ O $any$ O $any$ O O O O O $any$ O O O O $Promise<any>$ O $string$ O $string$ O $boolean$ $boolean$ O O O $string$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $string$ O O O O $boolean$ O O $any$ O $void$ O O O $BotEndpoint$ O $string$ O $string$ O $string$ O $string$ O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O $string$ O O O O O $any$ O O O O $Promise<any>$ O $any$ O $any$ O O O O O O $complex$ O $number$ O O O $any[]$ O $any$ O O O $number$ O O O O O O $ActivityBucket[]$ O $number$ O O O $ActivityBucket[]$ O $complex$ O $ActivityBucket$ O $ActivityBucket$ O $number$ O $number$ O O O O $ActivityBucket[]$ O O O $any[]$ O O O $ActivityBucket[]$ O $U[]$ O $ActivityBucket$ O $ActivityBucket$ O $any$ O O $number$ O O O $number$ O O O O O $void$ O $any[]$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O O O $any[]$ O $void$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $BotEndpoint$ O $any$ O $any$ O O $any[]$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $BotEndpoint$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $BotEndpoint$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $void$ O $any$ O O O O O O O O $Promise$ O $number$ O O O O $any$ O O O O O $any[]$ O O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O O O O $U[]$ O $any$ O O O O $any$ O O $any$ O O $boolean$ O $number$ O $any$ O $any$ O O O O $number$ O $any$ O $any$ O $any$ O O O O $boolean$ O $any$ O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O O O O O O $Promise<any>$ O $any[]$ O $number$ O O O O O $any[]$ O O O O $Promise<any>$ O $CheckoutConversationSession$ O $string$ O $PaymentRequest$ O $PaymentAddress$ O $string$ O O O O O O O $BotEndpoint$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O O $PaymentRequestUpdate$ O O $any$ O $any$ O $any$ O $PaymentAddress$ O $string$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O $string$ O $string$ O $complex$ O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $complex$ O O $string$ O O O $BotEndpoint$ O $string$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O $string$ O O O O $BotEmulator$ O $Promise<string>$ O O O $BotEndpoint$ O $string$ O O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $string$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $Promise<any>$ O $any$ O $any$ O O O O O $any$ O O O $Activity$ O $string$ O $Partial$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $boolean$ O $any$ O $any$ O O O $string$ O $string$ O O $any$ O O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $void$ O $Activity$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O O $ActivityBucket[]$ O O O O O $ActivityBucket[]$ O O $any$ O $number$ O O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $BotEmulator$ O O O O O $Promise<void>$ O $Activity$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O $IMessageActivity$ O O O O $any$ O $any$ O $any$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $any$ O $number$ O O O O O O $Promise<void>$ O $any$ O $any$ O $number$ O O O O O O O O $Promise<void>$ O $Attachment$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O $Attachment$ O O O O O O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O O O O $Promise<string>$ O $any$ O $any$ O O O O O O $Promise$ O $string$ O O O O O O $string$ O $string$ O O $any$ O O O O $BotEmulator$ O $any$ O $any$ O $string$ O O O O O O O $number$ O $any$ O $any$ O $any$ O O O O O O O $number$ O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O O O $any$ O O O $string$ O O O $boolean$ O $string$ O O O $string$ O O $any$ O $string$ O O $string$ O $number$ O O O O O O O O O O
import { ConversationResourceResponse } from 's' ; export default function createConversationResponse ( id , activityId : string | null ) { const response = { id } ; if ( activityId !== null ) { response . activityId = activityId ; } return response ; }	O O $any$ O O O O O O O $ConversationResourceResponse$ O $string$ O $string$ O O O O O O O $ConversationResourceResponse$ O O $string$ O O O O $string$ O O O O $any$ O $any$ O $string$ O O O $any$ O O
import { APIException , ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import { ConversationParameters } from 's' ; import BotEndpoint from 's' ; import createAPIException from 's' ; class CreateConversationError { public static TOO_MANY_MEMBERS = new CreateConversationError ( ErrorCodes . BadSyntax , 's' ) ; public static BOT_MISSING = new CreateConversationError ( ErrorCodes . MissingProperty , 's' ) ; public static APP_ID_MISSING = new CreateConversationError ( ErrorCodes . MissingProperty , 's' ) ; constructor ( public errorCode , public message ) { if ( Object . isFrozen ( CreateConversationError ) ) { throw new Error ( 's' ) ; } Object . assign ( this , { errorCode , message } ) ; Object . freeze ( this ) ; } public toAPIException ( ) { return createAPIException ( HttpStatus . BAD_REQUEST , this . errorCode , this . message ) ; } } Object . freeze ( CreateConversationError ) ; function validateCreateConversationRequest ( params , endpoint ) : CreateConversationError | void { if ( params . members && params . members . length > 0 ) { return CreateConversationError . TOO_MANY_MEMBERS ; } if ( ! params . bot ) { return CreateConversationError . BOT_MISSING ; } if ( ! endpoint ) { return CreateConversationError . APP_ID_MISSING ; } } export { CreateConversationError , validateCreateConversationRequest } ;	O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O $CreateConversationError$ O O $any$ O $any$ O $any$ O O O O O O $CreateConversationError$ O O $any$ O $any$ O $any$ O O O O O O $CreateConversationError$ O O $any$ O $any$ O $any$ O O O O O O O $ErrorCodes$ O O $string$ O O O O $ObjectConstructor$ O $boolean$ O $any$ O O O O O $ErrorConstructor$ O O O O O $ObjectConstructor$ O O O O O O $any$ O $string$ O O O $ObjectConstructor$ O $complex$ O O O O O O $APIException$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O O $complex$ O $ConversationParameters$ O $BotEndpoint$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $CreateConversationError$ O O O O O $any$ O $any$ O O O $any$ O $CreateConversationError$ O O O O O $BotEndpoint$ O O O $any$ O $CreateConversationError$ O O O O O $any$ O $complex$ O O
import { ConversationParameters , ChannelAccount , ConversationAccount } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { EmulatorMode } from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import Conversation from 's' ; import createConversationResponse from 's' ; import sendErrorResponse from 's' ; import uniqueId from 's' ; import { validateCreateConversationRequest } from 's' ; export default function createConversation ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const botEndpoint = ( req as any ) . botEndpoint ; const conversationParameters = req . body ; const error = validateCreateConversationRequest ( conversationParameters , botEndpoint ) ; if ( error ) { sendErrorResponse ( req , res , next , error . toAPIException ( ) ) ; next ( ) ; return ; } const newConversation = getConversation ( conversationParameters , botEmulator , botEndpoint ) ; newConversation . normalize ( ) ; const activityId = getActivityId ( conversationParameters , botEndpoint , newConversation ) ; const response = createConversationResponse ( newConversation . conversationId , activityId ) ; res . send ( HttpStatus . OK , response ) ; res . end ( ) ; next ( ) ; } ; } function getConversation ( params : { conversationId : string ; members : any [ ] ; mode : EmulatorMode } , emulator , endpoint ) { let conversation ; if ( params . conversationId ) { conversation = emulator . facilities . conversations . conversationById ( params . conversationId ) ; } if ( ! conversation ) { const { members = [ ] } = params ; const [ member ] = members ; const currentUserId = emulator . facilities . users . currentUserId ; const { id = currentUserId || uniqueId ( ) , name = 's' } = member || { } ; conversation = emulator . facilities . conversations . newConversation ( emulator , endpoint , { id , name } , params . conversationId , params . mode ) ; } return conversation ; } function getActivityId ( params , endpoint , conversation ) : string | null { const { activity , members } = params ; if ( activity ) { activity . conversation = { id : conversation . conversationId } as ConversationAccount ; activity . from = { id : endpoint . botId } as ChannelAccount ; activity . recipient = { id : members [ 0 ] . id } as ChannelAccount ; const response = conversation . postActivityToUser ( activity ) ; return response . id ; } return null ; }	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O O O $complex$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $BotEndpoint$ O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $any$ O $BotEndpoint$ O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $CreateConversationError$ O $any$ O O O O $any$ O O O O O O O $Conversation$ O $Conversation$ O $any$ O $BotEmulator$ O $BotEndpoint$ O O $Conversation$ O $void$ O O O O $string$ O $string$ O $any$ O $BotEndpoint$ O $Conversation$ O O O $any$ O $any$ O $Conversation$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O $Conversation$ O $complex$ O O $string$ O O O $any[]$ O O O O O $any$ O $any$ O O $BotEmulator$ O $BotEndpoint$ O O O $Conversation$ O O O $complex$ O $string$ O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $complex$ O $string$ O O O O O O $Conversation$ O O O O $any[]$ O O O O O $complex$ O O O $any$ O O $any[]$ O O $string$ O $BotEmulator$ O $Facilities$ O $Users$ O $string$ O O O $any$ O $string$ O $string$ O O O $any$ O O O O $any$ O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $BotEmulator$ O $BotEndpoint$ O O $any$ O $any$ O O $complex$ O $string$ O $complex$ O $any$ O O O O $Conversation$ O O O $string$ O $ConversationParameters$ O $BotEndpoint$ O $Conversation$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O O $string$ O $Conversation$ O $string$ O O $any$ O $any$ O $any$ O O $string$ O $BotEndpoint$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $Conversation$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O
interface ConversationAPIPathParameters { conversationId : string ; activityId : string ; } export default ConversationAPIPathParameters ;	O $any$ O $string$ O O O $string$ O O O O O O $any$ O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import ConversationAPIPathParameters from 's' ; export default function deleteActivity ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const conversationParameters = req . params ; try { ( req as any ) . conversation . deleteActivity ( conversationParameters . activityId ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ConversationAPIPathParameters$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $ConversationAPIPathParameters$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import ConversationAPIPathParameters from 's' ; export default function fetchConversation ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const conversationParameters = req . params ; const conversation = botEmulator . facilities . conversations . conversationById ( conversationParameters . conversationId ) ; if ( ! conversation ) { throw createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , 's' ) ; } ( req as any ) . conversation = conversation ; return next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ConversationAPIPathParameters$ O $any$ O $any$ O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $ConversationAPIPathParameters$ O $string$ O O O O O $Conversation$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $Conversation$ O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function getActivityMembers ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { res . send ( HttpStatus . OK , ( req as any ) . conversation . members ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as Restify from 's' ; import { usGovernmentAuthentication } from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; export default function getBotEndpoint ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const request = req as any ; const { endpoints } = botEmulator . facilities ; if ( req . headers && 's' in req . headers ) { const { 's' : msaAppId = 's' , 's' : msaPassword = 's' , 's' : botUrl , 's' : channelServiceType , } = req . headers as { [ prop ] : string } ; let channelService ; if ( channelServiceType === 's' ) { channelService = usGovernmentAuthentication . channelService ; } let endpoint = endpoints . get ( botUrl ) ; if ( ! endpoint ) { const params = req . body as any ; endpoint = endpoints . push ( null , new BotEndpoint ( params . bot . id , params . bot . id , botUrl , msaAppId , msaPassword , false , channelService ) ) ; } else { endpoint . msaAppId = msaAppId ; endpoint . msaPassword = msaPassword ; } request . botEndpoint = endpoint ; } else { request . botEndpoint = endpoints . getByAppId ( request . jwt . appid ) ; } return next ( ) ; } ; }	O O O $any$ O O O O O O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $Endpoints$ O O $BotEmulator$ O $Facilities$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O O O O $any$ O O O $string$ O O O O $any$ O O O $string$ O O O $BotEndpoint$ O $Endpoints$ O $BotEndpoint$ O $string$ O O O O O $BotEndpoint$ O O O $any$ O $any$ O $any$ O O O $BotEndpoint$ O $Endpoints$ O $BotEndpoint$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O $string$ O O O $any$ O O O O O O $BotEndpoint$ O $string$ O $string$ O $BotEndpoint$ O $string$ O $string$ O O $any$ O $any$ O $BotEndpoint$ O O O O $any$ O $any$ O $Endpoints$ O $BotEndpoint$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function getConversationMembers ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { res . send ( HttpStatus . OK , ( req as any ) . conversation . members ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as crypto from 's' ; import { Attachment , OAuthCard } from 's' ; import { AttachmentContentTypes } from 's' ; import { Activity } from 's' ; import { BotEmulator } from 's' ; import uniqueId from 's' ; export default class OAuthLinkEncoder { public static OAuthUrlProtocol : string = 's' ; public static EmulateOAuthCards : boolean = false ; private readonly authorizationHeader : string ; private readonly conversationId : string ; private botEmulator : BotEmulator ; private activity : Activity ; constructor ( botEmulator , authorizationHeader , activity , conversationId ) { this . authorizationHeader = authorizationHeader ; this . activity = activity ; this . conversationId = conversationId ; this . botEmulator = botEmulator ; } public async resolveOAuthCards ( activity ) < boolean > { if ( this . conversationId && activity && activity . attachments && activity . attachments . length === 0 && activity . attachments [ 0 ] . contentType === AttachmentContentTypes . oAuthCard ) { const codeChallenge = this . generateCodeVerifier ( this . conversationId ) ; const attachment = activity . attachments [ 0 ] as Attachment ; const oauthCard = attachment . content as OAuthCard ; if ( oauthCard . buttons && oauthCard . buttons . length === 0 ) { const cardAction = oauthCard . buttons [ 0 ] ; if ( cardAction . type === 's' && ! cardAction . value && ! OAuthLinkEncoder . EmulateOAuthCards ) { const link = await this . getSignInLink ( oauthCard . connectionName , codeChallenge ) ; cardAction . value = link ; cardAction . type = 's' ; } } } return true ; } public generateCodeVerifier ( conversationId ) { const codeVerifier = uniqueId ( ) ; const conversation = this . botEmulator . facilities . conversations . conversationById ( conversationId ) ; conversation . codeVerifier = codeVerifier ; return crypto . createHash ( 's' ) . update ( codeVerifier ) . digest ( 's' ) ; } private async getSignInLink ( connectionName , codeChallenge ) < string > { const tokenExchangeState = { ConnectionName : connectionName , Conversation : { ActivityId : this . activity . id , Bot : this . activity . from , ChannelId : this . activity . channelId ? this . activity . channelId : 's' , Conversation : this . activity . conversation ? this . activity . conversation : { id : this . conversationId } , ServiceUrl : this . activity . serviceUrl , User : this . activity . recipient , } , } ; const serializedState = JSON . stringify ( tokenExchangeState ) ; const state = Buffer . from ( serializedState ) . toString ( 's' ) ; const headers = { Authorization : this . authorizationHeader , } ; let errorMessage ; try { const emulatorUrl = await this . botEmulator . getServiceUrlForOAuth ( ) ; const url = 's' + state + 's' + emulatorUrl + 's' + codeChallenge ; const response = await fetch ( url , { headers , method : 's' , } ) ; if ( response . ok ) { const link = await response . text ( ) ; return OAuthLinkEncoder . OAuthUrlProtocol + 's' + link + 's' + this . conversationId ; } errorMessage = response . statusText ; } catch ( e ) { errorMessage = e . message ; } throw new Error ( errorMessage ) ; } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O $string$ O O O O O O O $boolean$ O O O O O O O $string$ O O O O O $string$ O O O O $BotEmulator$ O $any$ O O $any$ O $any$ O O O $BotEmulator$ O $string$ O $Activity$ O $string$ O O O O $string$ O $string$ O O O $any$ O $any$ O O O $string$ O $string$ O O O $BotEmulator$ O $BotEmulator$ O O O O $Promise$ O $Activity$ O O O O O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $Attachment$ O $any$ O $any$ O O O O $any$ O O $OAuthCard$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $boolean$ O O O $string$ O O O O $Promise<string>$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O O O O $string$ O $string$ O O O $string$ O $string$ O O O O $Conversation$ O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $string$ O O $Conversation$ O $string$ O $string$ O O $any$ O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O $Promise$ O $string$ O $string$ O O O O O O $complex$ O O $string$ O $string$ O $complex$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O $string$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $string$ O $JSON$ O $complex$ O $complex$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $BotEmulator$ O $Promise<string>$ O O O O $string$ O O O $any$ O O O $string$ O O O $string$ O O $Response$ O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O $Response$ O $boolean$ O O O $string$ O O $Response$ O $Promise<string>$ O O O O $any$ O $string$ O O O $string$ O O O O O $string$ O O $string$ O $Response$ O $string$ O O O O $any$ O O $string$ O $any$ O $any$ O O O O $ErrorConstructor$ O $string$ O O O O
import { ResourceResponse } from 's' ; import { Activity } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import OAuthLinkEncoder from 's' ; import sendErrorResponse from 's' ; import ConversationAPIPathParameters from 's' ; export default function replyToActivity ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const activity = req . body as Activity ; const conversationParameters = req . params ; try { activity . id = activity . id || null ; activity . replyToId = req . params . activityId ; const continuation = function ( ) : void { const response = ( req as any ) . conversation . postActivityToUser ( activity ) ; res . send ( HttpStatus . OK , response ) ; res . end ( ) ; } ; const { conversationId } = conversationParameters ; const visitor = new OAuthLinkEncoder ( botEmulator , req . headers . authorization as string , activity , conversationId ) ; visitor . resolveOAuthCards ( activity ) . then ( _ => { continuation ( ) ; } ) . catch ( ( reason ) => { botEmulator . facilities . logger . logException ( conversationId , reason ) ; botEmulator . facilities . logger . logException ( conversationId , new Error ( 's' ) ) ; continuation ( ) ; } ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $ConversationAPIPathParameters$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $void$ O O O O O O O O $ResourceResponse$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $string$ O O $ConversationAPIPathParameters$ O O $OAuthLinkEncoder$ O O $any$ O $BotEmulator$ O $any$ O $any$ O $any$ O O O $any$ O $string$ O O $OAuthLinkEncoder$ O $Promise<boolean>$ O $any$ O O O O $boolean$ O O $void$ O O O O O O $complex$ O O $any$ O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O $string$ O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O $string$ O O $ErrorConstructor$ O O O O O $void$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { ResourceResponse } from 's' ; import { Activity } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function sendActivityToConversation ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const activity = req . body as Activity ; try { activity . id = null ; activity . replyToId = req . params . activityId ; const response = ( req as any ) . conversation . postActivityToUser ( activity ) ; res . send ( HttpStatus . OK , response ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $ResourceResponse$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { Activity } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import createResourceResponse from 's' ; export default function sendHistoryToConversation ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const { activities } : { activities : Activity [ ] } = req . body ; let successCount = 0 ; let firstErrorMessage = 's' ; for ( const activity of activities ) { try { ( req as any ) . conversation . postActivityToUser ( activity , true ) ; successCount ++ ; } catch ( err ) { if ( firstErrorMessage === 's' ) { firstErrorMessage = err ; } } } const id = `template` ; const response = createResourceResponse ( id ) ; res . send ( HttpStatus . OK , response ) ; res . end ( ) ; next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any[]$ O O O $any[]$ O $any$ O O O O $any$ O $any$ O O $number$ O O O O $string$ O O O O O O $any$ O $any[]$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $number$ O O O O O $any$ O O O O $string$ O O O O $string$ O $any$ O O O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O
import { ErrorCodes , ResourceResponse } from 's' ; import { Activity } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import ConversationAPIPathParameters from 's' ; import sendErrorResponse from 's' ; export default function updateActivity ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const activity = req . body as Activity ; const conversationParameters = req . params ; try { activity . replyToId = conversationParameters . activityId ; if ( activity . id !== conversationParameters . activityId ) { throw createAPIException ( HttpStatus . BAD_REQUEST , ErrorCodes . BadArgument , 's' ) ; } const response = ( req as any ) . conversation . updateActivity ( activity ) ; res . send ( HttpStatus . OK , response ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $ConversationAPIPathParameters$ O $any$ O $any$ O O O $any$ O $any$ O $ConversationAPIPathParameters$ O $string$ O O O $any$ O $any$ O $ConversationAPIPathParameters$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ResourceResponse$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { AttachmentData , ResourceResponse } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; export default function uploadAttachment ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const attachmentData = req . body as AttachmentData ; try { const resourceId = botEmulator . facilities . attachments . uploadAttachment ( attachmentData ) ; const resourceResponse = { id : resourceId } ; res . send ( HttpStatus . OK , resourceResponse ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $BotEmulator$ O $Facilities$ O $Attachments$ O $string$ O $any$ O O O $ResourceResponse$ O O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { EventEmitter } from 's' ; import { User } from 's' ; import { EmulatorMode } from 's' ; import { BotEmulator } from 's' ; import uniqueId from 's' ; import BotEndpoint from 's' ; import Conversation from 's' ; export default class ConversationSet extends EventEmitter { public conversations : { [ conversationId ] : Conversation } = { } ; public newConversation ( botEmulator , botEndpoint , user , conversationId = uniqueId ( ) , mode = 's' ) { const conversation = new Conversation ( botEmulator , botEndpoint , conversationId , user , mode ) ; if ( ! "s" . test ( conversation . conversationId ) ) { conversation . conversationId += 's' ; } this . conversations [ conversation . conversationId ] = conversation ; this . emit ( 's' , conversation ) ; return conversation ; } public conversationById ( conversationId ) { return this . conversations [ conversationId ] ; } public getConversationIds ( ) : string [ ] { return Object . keys ( this . conversations ) ; } public deleteConversation ( conversationId ) { return delete this . conversations [ conversationId ] ; } public getConversations ( ) : Conversation [ ] { return Object . values ( this . conversations ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O $Conversation$ O $BotEmulator$ O $BotEndpoint$ O $User$ O $string$ O $string$ O O O $EmulatorMode$ O O O O O $Conversation$ O O $any$ O $BotEmulator$ O $BotEndpoint$ O $string$ O $any$ O $any$ O O O O O O O $boolean$ O $Conversation$ O $string$ O O O $Conversation$ O $string$ O O O O O O $complex$ O $Conversation$ O $string$ O O $Conversation$ O O O $any$ O O O $Conversation$ O O O $Conversation$ O O O $Conversation$ O $string$ O O O O O $complex$ O $string$ O O O O $string[]$ O O O O O O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O $boolean$ O $string$ O O O O O O $complex$ O $string$ O O O O $Conversation[]$ O O O $any$ O O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O
import { User } from 's' ; export default class Users { public currentUserId : string = 's' ; public users : { [ userId ] : User } ; public usersById ( userId ) { return this . users [ userId ] ; } }	O O $any$ O O O O O O O $any$ O O $string$ O O O O O O $complex$ O O O $string$ O O $any$ O O O $User$ O $string$ O O O O O $complex$ O $string$ O O O O
import Conversation from 's' ; import ConversationSet from 's' ; import Users from 's' ; export * from 's' ; export { Conversation , ConversationSet , Users } ;	O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { ConversationMembers , ConversationsGetConversationsOptionalParams , ConversationsGetConversationsResponse , } from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { Conversation } from 's' ; export default function fetchConversations ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : void => { const conversationParameters = req . params ; const { continuationToken } = conversationParameters ; const { conversations : api } = botEmulator . facilities ; const conversations = api . getConversations ( ) ; const response = { } as ConversationsGetConversationsResponse ; if ( continuationToken ) { let tokenFound = false ; response . conversations = conversations . reduce ( ( continued : ConversationMembers [ ] , convo ) : ConversationMembers [ ] => { tokenFound = tokenFound || convo . conversationId === continuationToken ; if ( tokenFound ) { continued . push ( { id : convo . conversationId , members : convo . members } ) ; } return continued ; } , [ ] ) ; } else { response . conversations = conversations . map ( convo => ( { id : convo . conversationId , members : convo . members } ) ) ; } try { res . send ( HttpStatus . OK , response ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $void$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ConversationsGetConversationsOptionalParams$ O $any$ O $any$ O O O $any$ O O $any$ O O O $ConversationSet$ O $ConversationSet$ O O $BotEmulator$ O $Facilities$ O O $Conversation[]$ O $ConversationSet$ O $Conversation[]$ O O O O $any$ O O O O $any$ O O O $any$ O O O $boolean$ O O O $any$ O $any$ O $Conversation[]$ O $complex$ O O $any[]$ O $any$ O O O $Conversation$ O O $any$ O O O O $boolean$ O $boolean$ O $Conversation$ O $string$ O $any$ O O O $boolean$ O O $any[]$ O $number$ O O $string$ O $Conversation$ O $string$ O $any[]$ O $Conversation$ O $any[]$ O O O O O $any[]$ O O O O O O O O O O $any$ O $any$ O $Conversation[]$ O $U[]$ O $Conversation$ O O O $string$ O $Conversation$ O $string$ O $any[]$ O $Conversation$ O $any[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import createJsonBodyParser from 's' ; import createConversation from 's' ; import deleteActivity from 's' ; import createFetchConversationMiddleware from 's' ; import getActivityMembers from 's' ; import getBotEndpoint from 's' ; import getConversationMembers from 's' ; import replyToActivity from 's' ; import sendActivityToConversation from 's' ; import sendHistoryToConversation from 's' ; import updateActivity from 's' ; import uploadAttachment from 's' ; import getConversations from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( botEmulator . options . fetch ) ; const botEndpoint = getBotEndpoint ( botEmulator ) ; const facility = getFacility ( 's' ) ; const jsonBodyParser = createJsonBodyParser ( ) ; const fetchConversation = createFetchConversationMiddleware ( botEmulator ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser , botEndpoint , facility , getRouteName ( 's' ) , createConversation ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , sendActivityToConversation ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , sendHistoryToConversation ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , replyToActivity ( botEmulator ) ) ; server . put ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateActivity ( botEmulator ) ) ; server . del ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , deleteActivity ( botEmulator ) ) ; server . get ( 's' , ... uses , verifyBotFramework , facility , getRouteName ( 's' ) , getConversations ( botEmulator ) ) ; server . get ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , getConversationMembers ( botEmulator ) ) ; server . get ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , getActivityMembers ( botEmulator ) ) ; server . post ( 's' , ... uses , verifyBotFramework , jsonBodyParser , facility , getRouteName ( 's' ) , uploadAttachment ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $BotEmulator$ O $any$ O $any$ O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O $BotEmulator$ O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O O O O $void$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O
import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function getBotEndpoint ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const auth = req . header ( 's' ) ; const { endpoints } = botEmulator . facilities ; const tokenMatch = "s" . exec ( auth ) || [ ] ; ( req as any ) . botEndpoint = endpoints . get ( tokenMatch [ 0 ] ) || endpoints . getDefault ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $Endpoints$ O O $BotEmulator$ O $Facilities$ O O $complex$ O O O $RegExpExecArray$ O $any$ O O O O O O $any$ O O O O $any$ O $Endpoints$ O $BotEndpoint$ O $complex$ O O O O O $Endpoints$ O $BotEndpoint$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import Conversation from 's' ; export default function getActivities ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const conversation = ( req as any ) . conversation ; if ( conversation ) { const { activities , watermark } = conversation . getActivitiesSince ( Number ( req . query . watermark || 0 ) || 0 ) ; res . json ( HttpStatus . OK , { activities , watermark , } ) ; } else { res . send ( HttpStatus . NOT_FOUND , 's' ) ; } res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Conversation$ O O $any$ O O O O $any$ O O O $Conversation$ O O O O $any[]$ O $number$ O O $Conversation$ O $complex$ O $NumberConstructor$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O
import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function getConversation ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { ( req as any ) . conversation = botEmulator . facilities . conversations . conversationById ( req . params . conversationId ) ; next ( ) ; } ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $any$ O $any$ O $any$ O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function options ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { res . send ( HttpStatus . OK ) ; res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O
import { LogLevel , textItem } from 's' ; import { Activity } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import Conversation from 's' ; import sendErrorResponse from 's' ; import statusCodeFamily from 's' ; export default function postActivity ( botEmulator ) { const { logMessage } = botEmulator . facilities . logger ; return async ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) => { const conversation = ( req as any ) . conversation ; if ( ! conversation ) { res . send ( HttpStatus . NOT_FOUND , 's' ) ; res . end ( ) ; logMessage ( req . params . conversationId , textItem ( LogLevel . Error , 's' ) ) ; return ; } const activity = req . body as Activity ; try { const { activityId , response , statusCode } = await conversation . postActivityToBot ( activity , true ) ; if ( ! statusCodeFamily ( statusCode , 0 ) ) { if ( statusCode === HttpStatus . UNAUTHORIZED || statusCode === HttpStatus . FORBIDDEN ) { logMessage ( req . params . conversationId , textItem ( LogLevel . Error , 's' ) ) ; } res . send ( statusCode || HttpStatus . INTERNAL_SERVER_ERROR , await response . text ( ) ) ; } else { res . send ( statusCode , { id : activityId } ) ; } } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } res . end ( ) ; next ( ) ; } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $boolean$ O O O O O O $Promise<void>$ O $BotEmulator$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Conversation$ O O $any$ O O O O $any$ O O O O $Conversation$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $Conversation$ O $Promise<any>$ O $any$ O O O O O O O $boolean$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O
import { LogLevel , textItem } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import Conversation from 's' ; export default function reconnectToConversation ( botEmulator ) { const { logMessage } = botEmulator . facilities . logger ; return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const conversation = ( req as any ) . conversation ; if ( conversation ) { res . json ( HttpStatus . OK , { conversationId : conversation . conversationId , token : conversation . conversationId , expires_in : Math . pow ( 0 , 0 ) - 0 , streamUrl : 's' , } ) ; } else { res . send ( HttpStatus . NOT_FOUND , 's' ) ; logMessage ( req . params . conversationId , textItem ( LogLevel . Error , 's' ) ) ; } res . end ( ) ; next ( ) ; } ; }	O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Conversation$ O O $any$ O O O O $any$ O O O $Conversation$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O $Conversation$ O $string$ O $string$ O $Conversation$ O $string$ O $number$ O $Math$ O $number$ O O O O O O O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import onErrorResumeNext from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import uniqueId from 's' ; export default function startConversation ( botEmulator ) { return async ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : Promise < any > => { const auth = req . header ( 's' ) ; const tokenMatch = "s" . exec ( auth ) ; const botEndpoint = ( req as any ) . botEndpoint ; const conversationId = onErrorResumeNext ( ( ) => { const optionsJson = Buffer . from ( tokenMatch [ 0 ] , 's' ) . toString ( 's' ) ; return JSON . parse ( optionsJson ) . conversationId ; } ) || uniqueId ( ) ; const { users , conversations } = botEmulator . facilities ; const currentUser = users . usersById ( users . currentUserId ) ; let created = false ; let conversation = conversations . conversationById ( conversationId ) ; if ( ! conversation ) { conversation = conversations . newConversation ( botEmulator , botEndpoint , currentUser , conversationId ) ; if ( ! currentUser ) { res . send ( HttpStatus . BAD_REQUEST , 's' ) ; res . end ( ) ; next ( ) ; return ; } await conversation . sendConversationUpdate ( [ currentUser , { id : botEndpoint . botId , name : 's' } ] , undefined ) ; created = true ; } else if ( botEndpoint && ! conversationId . endsWith ( 's' ) ) { const membersToAddInConversationUpdate = [ ] ; const userIsNotInConversation = conversation . members . findIndex ( user => user . id === currentUser . id ) === - 0 ; if ( userIsNotInConversation ) { conversation . addMember ( currentUser . id , currentUser . name ) ; } else { membersToAddInConversationUpdate . push ( currentUser ) ; } const botIsNotInConversation = conversation . members . findIndex ( user => user . id === botEndpoint . botId ) === - 0 ; if ( botIsNotInConversation ) { conversation . addMember ( botEndpoint . botId , 's' ) ; } else { membersToAddInConversationUpdate . push ( { id : botEndpoint . botId , name : 's' } ) ; } if ( membersToAddInConversationUpdate . length ) { await conversation . sendConversationUpdate ( membersToAddInConversationUpdate , undefined ) ; } } ( req as any ) . conversation = conversation ; res . json ( created ? HttpStatus . CREATED : HttpStatus . OK , { conversationId : conversation . conversationId , token : botEndpoint && botEndpoint . id , expires_in : Math . pow ( 0 , 0 ) - 0 , streamUrl : 's' , } ) ; res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $string$ O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O O O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $any$ O O O $BotEndpoint$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $RegExpExecArray$ O O O O O O O $any$ O O O O O $JSON$ O $any$ O $any$ O O $any$ O O O O $string$ O O O O O $Users$ O $ConversationSet$ O O $BotEmulator$ O $Facilities$ O O $any$ O $Users$ O $any$ O $Users$ O $string$ O O O $boolean$ O O O O $Conversation$ O $ConversationSet$ O $Conversation$ O $any$ O O O O O $Conversation$ O O $Conversation$ O $ConversationSet$ O $Conversation$ O $BotEmulator$ O $BotEndpoint$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O O O $Conversation$ O $Promise<void>$ O O $any$ O O $string$ O $BotEndpoint$ O $string$ O $string$ O O O O O $undefined$ O O $boolean$ O O O O O O O $BotEndpoint$ O O $any$ O $any$ O O O O O O $any[]$ O O O O O $boolean$ O $Conversation$ O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $boolean$ O O $Conversation$ O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $number$ O $any$ O O O O $boolean$ O $Conversation$ O $any[]$ O $number$ O $any$ O $any$ O $any$ O $BotEndpoint$ O $string$ O O O O O O O $boolean$ O O $Conversation$ O $Promise<any>$ O $BotEndpoint$ O $string$ O O O O O O O $any[]$ O $number$ O O $string$ O $BotEndpoint$ O $string$ O $string$ O O O O O O O O $any[]$ O $number$ O O O $Conversation$ O $Promise<void>$ O $any[]$ O $undefined$ O O O O O $any$ O O O O $any$ O $Conversation$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O O $string$ O $Conversation$ O $string$ O $string$ O $BotEndpoint$ O $BotEndpoint$ O $string$ O $number$ O $Math$ O $number$ O O O O O O O O $string$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function stream ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { res . send ( HttpStatus . NOT_IMPLEMENTED ) ; res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O
import * as fs from 's' ; import { LogLevel , textItem } from 's' ; import { Attachment , AttachmentData } from 's' ; import * as Formidable from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import Conversation from 's' ; import sendErrorResponse from 's' ; export default function upload ( botEmulator ) { const { logMessage } = botEmulator . facilities . logger ; return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { if ( req . params . conversationId . includes ( 's' ) ) { res . end ( ) ; return ; } const conversation = ( req as any ) . conversation ; const botEndpoint = ( req as any ) . botEndpoint ; if ( ! conversation ) { res . send ( HttpStatus . NOT_FOUND , 's' ) ; res . end ( ) ; logMessage ( req . params . conversationId , textItem ( LogLevel . Error , 's' ) ) ; return ; } if ( req . getContentType ( ) !== 's' || ( req . getContentLength ( ) === 0 && ! req . isChunked ( ) ) ) { return ; } const form = new Formidable . IncomingForm ( ) ; form . multiples = true ; form . keepExtensions = true ; form . parse ( req , async ( err , fields , files ) => { try { const activity = JSON . parse ( fs . readFileSync ( files . activity . path , 's' ) ) ; let uploads = files . file ; if ( ! Array . isArray ( uploads ) ) { uploads = [ uploads ] ; } if ( uploads && uploads . length ) { const serviceUrl = await botEmulator . getServiceUrl ( botEndpoint . botUrl ) ; activity . attachments = [ ] ; uploads . forEach ( 0 => { const name = ( 0 as any ) . name || 's' ; const type = 0 . type ; const path = 0 . path ; const 0 = fs . readFileSync ( path , { encoding : 's' } ) ; const 0 = Buffer . from ( 0 , 's' ) ; const attachmentData = { type , name , 0 : new 0 ( 0 ) , 0 : new 0 ( 0 ) , } ; const attachmentId = botEmulator . facilities . attachments . uploadAttachment ( attachmentData ) ; const attachment = { name , contentType : type , contentUrl : `template` , } ; activity . attachments . push ( attachment ) ; } ) ; try { const { activityId , statusCode , response } = await conversation . postActivityToBot ( activity , true ) ; if ( ~ ~ statusCode === 0 && ~ ~ statusCode > 0 ) { res . send ( statusCode || HttpStatus . INTERNAL_SERVER_ERROR , await response . text ( ) ) ; res . end ( ) ; } else { res . send ( statusCode , { id : activityId } ) ; res . end ( ) ; } } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } } else { res . send ( HttpStatus . BAD_REQUEST , 's' ) ; res . end ( ) ; } } catch ( e ) { sendErrorResponse ( req , res , next , e ) ; } next ( ) ; } ) ; } ; }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $Conversation$ O O $any$ O O O O $any$ O O $BotEndpoint$ O O $any$ O O O O $any$ O O O O $Conversation$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $JSON$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $string$ O O $BotEmulator$ O $Promise<string>$ O $BotEndpoint$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $AttachmentData$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $string$ O $BotEmulator$ O $Facilities$ O $Attachments$ O $string$ O $any$ O O O $Attachment$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $Conversation$ O $Promise<any>$ O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O
import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getBotEndpoint from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createJsonBodyParserMiddleware from 's' ; import getActivities from 's' ; import getConversation from 's' ; import options from 's' ; import postActivity from 's' ; import reconnectToConversation from 's' ; import startConversation from 's' ; import stream from 's' ; import upload from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const botEndpoint = getBotEndpoint ( botEmulator ) ; const conversation = getConversation ( botEmulator ) ; const facility = getFacility ( 's' ) ; server . opts ( 's' , ... uses , facility , getRouteName ( 's' ) , options ( botEmulator ) ) ; server . post ( 's' , ... uses , botEndpoint , jsonBodyParser , facility , getRouteName ( 's' ) , startConversation ( botEmulator ) ) ; server . get ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , reconnectToConversation ( botEmulator ) ) ; server . get ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , getActivities ( botEmulator ) ) ; server . post ( 's' , ... uses , jsonBodyParser , botEndpoint , conversation , facility , getRouteName ( 's' ) , postActivity ( botEmulator ) ) ; server . post ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , upload ( botEmulator ) ) ; server . get ( 's' , ... uses , facility , getRouteName ( 's' ) , stream ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any[]$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $Promise<void>$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O
import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import { Next , Request , Response } from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import Conversation from 's' ; export interface ConversationAware extends Request { conversation : Conversation ; } export default function fetchConversation ( botEmulator ) { return ( req , res , next ) : any => { const conversation = botEmulator . facilities . conversations . conversationById ( req . params . conversationId ) ; if ( ! conversation ) { throw createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , 's' ) ; } req . conversation = conversation ; return next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $Conversation$ O $any$ O O O O O $any$ O $BotEmulator$ O O O O $ConversationAware$ O $Response$ O $Next$ O O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $ConversationAware$ O $any$ O $any$ O O O O O $Conversation$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $ConversationAware$ O $Conversation$ O $Conversation$ O O $any$ O O O O O O
import { ChannelAccount } from 's' ; import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function addUsers ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { const members : ChannelAccount [ ] = JSON . parse ( req . body || 's' ) ; const it = members [ Symbol . iterator ] ( ) ; let member ; while ( ( member = it . next ( ) . value ) ) { await req . conversation . addMember ( member . id , member . name ) ; } res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $any[]$ O $any$ O O O $JSON$ O $any$ O $ConversationAware$ O $any$ O O O O O $IterableIterator<any>$ O $any[]$ O $SymbolConstructor$ O $symbol$ O O O O O $any$ O O O O $any$ O $IterableIterator<any>$ O $complex$ O O O $any$ O O O O $ConversationAware$ O $Conversation$ O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function contactAdded ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { await req . conversation . sendContactAdded ( ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $ConversationAware$ O $Conversation$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function contactRemoved ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { await req . conversation . sendContactRemoved ( ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $ConversationAware$ O $Conversation$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function deleteUserData ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { await req . conversation . sendDeleteUserData ( ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $ConversationAware$ O $Conversation$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function getUsers ( _botEmulator ) { return ( req , res : Restify . Response , next : Restify . Next ) : any => { try { res . json ( HttpStatus . OK , req . conversation . members ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $ConversationAware$ O $Conversation$ O $any[]$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function paymentComplete ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { const { checkoutSession , request , shippingAddress , shippingOptionId , payerPhone , payerEmail } = req . body [ 0 ] ; const args = [ checkoutSession , request , shippingAddress , shippingOptionId , payerEmail , payerPhone ] ; try { const response = await req . conversation . sendPaymentCompleteOperation . apply ( req . conversation , args ) ; res . send ( HttpStatus . OK , response ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; res . send ( HttpStatus . INTERNAL_SERVER_ERROR ) ; } res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $ConversationAware$ O $any$ O O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ConversationAware$ O $Conversation$ O $Promise<any>$ O $any$ O $ConversationAware$ O $Conversation$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function ping ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { await req . conversation . sendPing ( ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $ConversationAware$ O $Conversation$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function removeUsers ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { res . send ( HttpStatus . NOT_IMPLEMENTED ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import { ConversationAware } from 's' ; export default function sendTokenResponse ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { const body : { token : string ; connectionName : string ; } = req . body [ 0 ] ; const { statusCode } = await req . conversation . sendTokenResponse ( body . connectionName , body . token , ! ! 0 ) ; if ( statusCode === HttpStatus . OK ) { res . send ( HttpStatus . OK , body ) ; } else { res . send ( statusCode ) ; } res . end ( ) ; next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $ConversationAware$ O $any$ O O O O O O $any$ O O O $ConversationAware$ O $Conversation$ O $Promise<any>$ O $complex$ O $string$ O $complex$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function typing ( botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { try { await req . conversation . sendTyping ( ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $ConversationAware$ O $Conversation$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function updateShippingAddress ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { const { checkoutSession , request , shippingAddress , shippingOptionId } = req . body [ 0 ] ; const args = [ checkoutSession , request , shippingAddress , shippingOptionId ] ; try { const response = await req . conversation . sendUpdateShippingAddressOperation . apply ( req . conversation , args ) ; const json = await response . json ( ) ; res . send ( HttpStatus . OK , json ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $ConversationAware$ O $any$ O O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ConversationAware$ O $Conversation$ O $Promise<any>$ O $any$ O $ConversationAware$ O $Conversation$ O $any[]$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import sendErrorResponse from 's' ; import { ConversationAware } from 's' ; export default function updateShippingOption ( _botEmulator ) { return async ( req , res : Restify . Response , next : Restify . Next ) : Promise < any > => { const { checkoutSession , request , shippingAddress , shippingOptionId } = req . body [ 0 ] ; const args = [ checkoutSession , request , shippingAddress , shippingOptionId ] ; try { const response = await req . conversation . sendUpdateShippingOptionOperation . apply ( req . conversation , args ) ; const json = await response . json ( ) ; res . send ( HttpStatus . OK , json ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<any>$ O $BotEmulator$ O O O O O $ConversationAware$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $ConversationAware$ O $any$ O O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ConversationAware$ O $Conversation$ O $Promise<any>$ O $any$ O $ConversationAware$ O $Conversation$ O $any[]$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import { Next , Request , Response } from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import Conversation from 's' ; import sendErrorResponse from 's' ; export interface ConversationAware extends Request { conversation : Conversation ; } export default function fetchConversation ( botEmulator ) { return ( req , res , next ) : any => { const conversation = botEmulator . facilities . conversations . conversationById ( req . params . conversationId ) ; if ( ! conversation ) { throw createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , 's' ) ; } try { res . json ( HttpStatus . OK , conversation . botEndpoint ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } next ( ) ; } ; }	O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $Conversation$ O $any$ O O O O O $any$ O $BotEmulator$ O O O O $ConversationAware$ O $Response$ O $Next$ O O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $ConversationAware$ O $any$ O $any$ O O O O O $Conversation$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $Conversation$ O $BotEndpoint$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $ConversationAware$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createJsonBodyParserMiddleware from 's' ; import addUsers from 's' ; import contactAdded from 's' ; import contactRemoved from 's' ; import deleteUserData from 's' ; import createFetchConversationMiddleware from 's' ; import getUsers from 's' ; import paymentComplete from 's' ; import ping from 's' ; import removeUsers from 's' ; import sendTokenResponse from 's' ; import typing from 's' ; import updateShippingAddress from 's' ; import updateShippingOption from 's' ; import getConversationEndpoint from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const fetchConversation = createFetchConversationMiddleware ( botEmulator ) ; const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const facility = getFacility ( 's' ) ; server . get ( 's' , getConversationEndpoint ( botEmulator ) ) ; server . get ( 's' , fetchConversation , facility , getRouteName ( 's' ) , getUsers ( botEmulator ) ) ; server . post ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , addUsers ( botEmulator ) ) ; server . del ( 's' , fetchConversation , facility , getRouteName ( 's' ) , removeUsers ( botEmulator ) ) ; server . post ( 's' , fetchConversation , facility , getRouteName ( 's' ) , contactAdded ( botEmulator ) ) ; server . del ( 's' , fetchConversation , facility , getRouteName ( 's' ) , contactRemoved ( botEmulator ) ) ; server . post ( 's' , fetchConversation , facility , getRouteName ( 's' ) , typing ( botEmulator ) ) ; server . post ( 's' , fetchConversation , facility , getRouteName ( 's' ) , ping ( botEmulator ) ) ; server . del ( 's' , fetchConversation , facility , getRouteName ( 's' ) , deleteUserData ( botEmulator ) ) ; server . post ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateShippingAddress ( botEmulator ) ) ; server . post ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateShippingOption ( botEmulator ) ) ; server . post ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , paymentComplete ( botEmulator ) ) ; server . post ( 's' , jsonBodyParser , facility , getRouteName ( 's' ) , sendTokenResponse ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any[]$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $any$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $any$ O $any$ O $BotEmulator$ O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O $Promise<any>$ O $BotEmulator$ O O O O
export default function approximateObjectSize ( object , cache : any [ ] = [ ] ) { switch ( typeof object ) { case 's' : return 0 ; case 's' : return 0 ; case 's' : return object . length * 0 ; case 's' : { let bytes = 0 ; cache . push ( object ) ; for ( const i in object ) { if ( ! object . hasOwnProperty ( i ) ) { continue ; } const value = object [ i ] ; if ( typeof value === 's' && value !== null ) { if ( cache . indexOf ( value ) !== - 0 ) { continue ; } cache . push ( value ) ; } bytes += approximateObjectSize ( value , cache ) ; } return bytes ; } default : return 0 ; } }	O O O $number$ O $any$ O $any[]$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O $number$ O O O $any[]$ O $number$ O $any$ O O O O O $string$ O $any$ O O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O O O $any$ O O O O O O $any[]$ O $number$ O $any$ O O O O O O O O O $any[]$ O $number$ O $any$ O O O $number$ O $number$ O $any$ O $any[]$ O O O O $number$ O O O O O O O O O
export default function botDataKey ( channelId , conversationId , userId ) { return `template` ; }	O O O $string$ O $string$ O $string$ O $string$ O O O O O O
import { BotData , ErrorCodes , externalLinkItem , LogLevel , textItem } from 's' ; import * as HttpStatus from 's' ; import approximateObjectSize from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import Conversation from 's' ; import botDataKey from 's' ; export default class BotState { private botDataStore : { [ key ] : BotData } = { } ; constructor ( public botEmulator , public stateSizeLimitKB ) { } public getBotData ( channelId , conversationId , userId ) { this . logBotStateApiDeprecationWarning ( conversationId ) ; const key = botDataKey ( channelId , conversationId , userId ) ; return ( this . botDataStore [ key ] || { data : null , eTag : 's' , } ) ; } public setBotData ( channelId , conversationId , userId , incomingData ) { this . logBotStateApiDeprecationWarning ( conversationId ) ; const key = botDataKey ( channelId , conversationId , userId ) ; const oldData = this . botDataStore [ key ] ; if ( oldData && oldData . eTag && oldData . eTag . length > 0 && incomingData . eTag !== 's' && oldData . eTag !== incomingData . eTag ) { throw createAPIException ( HttpStatus . PRECONDITION_FAILED , ErrorCodes . BadArgument , 's' ) ; } if ( this . stateSizeLimitKB > 0 && approximateObjectSize ( incomingData ) > this . stateSizeLimitKB * 0 ) { throw createAPIException ( HttpStatus . BAD_REQUEST , ErrorCodes . MessageSizeTooBig , 's' ) ; } const newData = { eTag : Date . now ( ) . toString ( ) , data : incomingData . data , } ; if ( ! incomingData . data ) { delete this . botDataStore [ key ] ; newData . eTag = 's' ; } else { this . botDataStore [ key ] = newData ; } return newData ; } public deleteBotData ( userId ) { const keys = Object . keys ( this . botDataStore ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; if ( key . endsWith ( `template` ) ) { delete this . botDataStore [ key ] ; } } } private logBotStateApiDeprecationWarning ( conversationId ) { const conversation = this . botEmulator . facilities . conversations . conversationById ( conversationId ) ; if ( conversation && ! conversation . stateApiDeprecationWarningShown ) { conversation . stateApiDeprecationWarningShown = true ; this . botEmulator . facilities . logger . logMessage ( conversationId , textItem ( LogLevel . Warn , 's' + 's' ) , externalLinkItem ( 's' , 's' ) ) ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $number$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O O O $BotEmulator$ O O $number$ O O O O $BotData$ O $string$ O $string$ O $string$ O O O O $void$ O $string$ O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O O $complex$ O $string$ O O O $null$ O O O $string$ O O O O O O O O $BotData$ O $string$ O $string$ O $string$ O $BotData$ O O O O $void$ O $string$ O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O $any$ O O O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $number$ O O O $number$ O $any$ O O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $BotData$ O O $string$ O $DateConstructor$ O $number$ O O O $string$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $complex$ O $string$ O O $any$ O $any$ O O O O O O O O $complex$ O $string$ O O $any$ O O O $any$ O O O $void$ O $string$ O O O $string[]$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O $string$ O $boolean$ O O O O O O O O $complex$ O $string$ O O O O O O $void$ O $string$ O O O $Conversation$ O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $string$ O O O O $Conversation$ O O $Conversation$ O $boolean$ O O $Conversation$ O $boolean$ O O O O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O
import { LogItem , LogItemType , LogLevel , LogService , TextLogItem } from 's' ; import log from 's' ; function logLevel ( logLevelArg ) { switch ( logLevelArg ) { case LogLevel . Error : return log . error ; case LogLevel . Info : return log . info ; case LogLevel . Warn : return log . warn ; default : return log . silly ; } } export default class ConsoleLogService implements LogService { public logToChat ( conversationId , ... items : LogItem < TextLogItem > [ ] ) { items . forEach ( message => { if ( message . type === LogItemType . Text ) { logLevel ( message . payload . level ) ( conversationId ? conversationId : 's' , message . payload . text ) ; } } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $LogLevel$ O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $void$ O $string$ O O $any[]$ O $any$ O $any$ O O O O O $any[]$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O O O O O O
import { BotEmulatorOptions } from 's' ; import 0 from 's' ; import onErrorResumeNext from 's' ; import uniqueId from 's' ; import BotEndpoint from 's' ; const { decode } = 0 ; export default class Endpoints { private _endpoints : { [ key ] : BotEndpoint } = { } ; constructor ( private _options ) { } public push ( id , botEndpoint < BotEndpoint > ) { id = id || botEndpoint . botUrl || uniqueId ( ) ; const botEndpointInstance = new BotEndpoint ( id , botEndpoint . botId , botEndpoint . botUrl , botEndpoint . msaAppId , botEndpoint . msaPassword , botEndpoint . 0 , botEndpoint . channelService , { fetch : this . _options . fetch , } ) ; this . _endpoints [ id ] = botEndpointInstance ; return botEndpointInstance ; } public reset ( ) { this . _endpoints = { } ; } public getDefault ( ) { return this . _endpoints [ Object . keys ( this . _endpoints ) [ 0 ] ] ; } public get ( id ) { const savedEndpoint = this . _endpoints [ id ] ; if ( savedEndpoint ) { return savedEndpoint ; } const token = onErrorResumeNext ( ( ) => JSON . parse ( decode ( id ) ) ) ; if ( token && token . endpointId ) { return this . get ( token . endpointId ) ; } return null ; } public getByAppId ( msaAppId ) { return this . _endpoints [ Object . keys ( this . _endpoints ) . find ( id => this . _endpoints [ id ] . msaAppId === msaAppId ) ] ; } public getAll ( ) : { [ key ] : BotEndpoint } { return this . _endpoints ; } }	O O $any$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O O $any$ O O O O O $any$ O O $any$ O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O O O $BotEmulatorOptions$ O O O O $BotEndpoint$ O $string$ O $Partial$ O $any$ O O O $string$ O $string$ O $Partial<BotEndpoint>$ O $string$ O $string$ O O O O $BotEndpoint$ O O $any$ O $string$ O $Partial<BotEndpoint>$ O $string$ O $Partial<BotEndpoint>$ O $string$ O $Partial<BotEndpoint>$ O $string$ O $Partial<BotEndpoint>$ O $string$ O $Partial<BotEndpoint>$ O $boolean$ O $Partial<BotEndpoint>$ O $string$ O O $any$ O O O $any$ O $any$ O O O O O O $complex$ O $string$ O O $BotEndpoint$ O O $BotEndpoint$ O O O $void$ O O O O O $complex$ O O O O O O $BotEndpoint$ O O O O O O $complex$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O O O O $BotEndpoint$ O $string$ O O O $BotEndpoint$ O O O $complex$ O $string$ O O O O $BotEndpoint$ O O O $BotEndpoint$ O O O $any$ O $any$ O O O O $JSON$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $BotEndpoint$ O $any$ O $any$ O O O O O O O O $BotEndpoint$ O $string$ O O O O O $complex$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $complex$ O $string$ O O O $complex$ O $string$ O O $string$ O $string$ O O O O O $complex$ O O O O O $string$ O O $any$ O O O O O $complex$ O O O
import { exceptionItem , inspectableObjectItem , Logger , LogItem , LogLevel , LogService , summaryTextItem , textItem , } from 's' ; import { Activity , ActivityTypes } from 's' ; export default class LoggerAdapter implements Logger { private static getDirectionalArrowFromRole ( role ) { if ( role === 's' ) { return 's' ; } return 's' ; } constructor ( public logService ) { } public logActivity = ( conversationId , activity , role ) => { const logItems : LogItem [ ] = [ textItem ( LogLevel . Debug , LoggerAdapter . getDirectionalArrowFromRole ( role ) ) , inspectableObjectItem ( activity . type , activity ) , summaryTextItem ( activity ) , ] ; if ( activity . value && activity . value . type === ActivityTypes . Message ) { const nestedActivity = activity . value as Activity ; if ( ! nestedActivity . id ) { nestedActivity . id = 's' + activity . id ; } logItems . push ( textItem ( LogLevel . Debug , LoggerAdapter . getDirectionalArrowFromRole ( nestedActivity . from . role ) ) , inspectableObjectItem ( nestedActivity . type , nestedActivity ) , summaryTextItem ( nestedActivity ) ) ; } this . logService . logToChat ( conversationId , ... logItems ) ; } ; public logMessage = ( conversationId , ... items : LogItem [ ] ) => { this . logService . logToChat ( conversationId , ... items ) ; } ; public logException = ( conversationId , err ) => { this . logService . logToChat ( conversationId , exceptionItem ( err ) ) ; } ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $string$ O $string$ O O O O $string$ O O O O O O O O O O O O O O O $LogService$ O O O O $void$ O O $string$ O $Activity$ O $string$ O O O O $any[]$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $string$ O O $any[]$ O O O O O $void$ O O $string$ O O $any[]$ O $any$ O O O O O O O $any$ O $any$ O $string$ O O $any[]$ O O O O O $void$ O O $string$ O $Error$ O O O O O $any$ O $any$ O $string$ O $any$ O $Error$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function getSessionId ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { res . json ( HttpStatus . OK , 's' ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O
import * as Restify from 's' ; import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import getSessionId from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const facility = getFacility ( 's' ) ; server . get ( 's' , facility , getRouteName ( 's' ) , getSessionId ( botEmulator ) ) ; server . get ( 's' , ( req : Restify . Request , res : Restify . Response ) => { const body = 's' + 's' + 's' + 's' ; res . writeHead ( 0 , { 's' : Buffer . byteLength ( body ) , 's' : 's' , } ) ; res . write ( body ) ; res . end ( ) ; } ) ; }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $string$ O O O O O O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import OAuthLinkEncoder from 's' ; import sendErrorResponse from 's' ; export default function emulateOAuthCards ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const emulate = req . params . emulate ; if ( emulate ) { OAuthLinkEncoder . EmulateOAuthCards = emulate . toLowerCase ( ) === 's' ; } else { OAuthLinkEncoder . EmulateOAuthCards = false ; } res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $string$ O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $boolean$ O $string$ O $string$ O O O O O O O O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O
export interface TokenParams { userId : string ; connectionName : string ; }	O O $any$ O $string$ O O O $string$ O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import sendErrorResponse from 's' ; import { TokenCache } from 's' ; import { TokenParams } from 's' ; import { TokenResponse } from 's' ; interface GetTokenParams extends TokenParams { code : string ; } export default function getToken ( _botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const params = req . params ; const botEndpoint = ( req as any ) . botEndpoint ; const tokenResponse = TokenCache . getTokenFromCache ( botEndpoint . botId , params . userId , params . connectionName ) ; if ( tokenResponse ) { res . send ( HttpStatus . OK , tokenResponse ) ; } else { res . send ( HttpStatus . NOT_FOUND ) ; } res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $GetTokenParams$ O $any$ O $any$ O O $BotEndpoint$ O O $any$ O O O O $any$ O O $TokenResponse$ O $any$ O $TokenResponse$ O $BotEndpoint$ O $string$ O $GetTokenParams$ O $string$ O $GetTokenParams$ O $string$ O O O O $TokenResponse$ O O $any$ O $any$ O $any$ O $any$ O $TokenResponse$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import sendErrorResponse from 's' ; import { TokenCache } from 's' ; import { TokenParams } from 's' ; export default function signOut ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { try { const params = req . params ; const botEndpoint = ( req as any ) . botEndpoint ; TokenCache . deleteTokenFromCache ( botEndpoint . botId , params . userId , params . connectionName ) ; res . send ( HttpStatus . OK ) ; res . end ( ) ; } catch ( err ) { sendErrorResponse ( req , res , next , err ) ; } } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $TokenParams$ O $any$ O $any$ O O $BotEndpoint$ O O $any$ O O O O $any$ O $any$ O $void$ O $BotEndpoint$ O $string$ O $TokenParams$ O $string$ O $TokenParams$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O
import * as HttpStatus from 's' ; import * as Restify from 's' ; import { BotEmulator } from 's' ; export default function tokenResponse ( botEmulator ) { return ( req : Restify . Request , res : Restify . Response , next : Restify . Next ) : any => { const body : { token : string ; connectionName : string ; } = req . body ; const conversationId = req . query . conversationId ; const conversation = botEmulator . facilities . conversations . conversationById ( conversationId ) ; conversation . sendTokenResponse ( body . connectionName , body . token , false ) . then ( response => { botEmulator . shutDownOAuthNgrokInstance ( ) ; if ( response . statusCode === HttpStatus . OK ) { res . send ( HttpStatus . OK , body ) ; } else { res . send ( response . statusCode ) ; } res . end ( ) ; } ) ; } ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $any$ O O $Conversation$ O $Promise<any>$ O $complex$ O $string$ O $complex$ O $string$ O O O O O O $any$ O O $BotEmulator$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O
import { RequestHandler , Server } from 's' ; import { BotEmulator } from 's' ; import getBotEndpoint from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import createJsonBodyParserMiddleware from 's' ; import emulateOAuthCards from 's' ; import getToken from 's' ; import signOut from 's' ; import tokenResponse from 's' ; export default function registerRoutes ( botEmulator , server , uses : RequestHandler [ ] ) { const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( botEmulator . options . fetch ) ; const botEndpoint = getBotEndpoint ( botEmulator ) ; const facility = getFacility ( 's' ) ; server . get ( 's' , verifyBotFramework , botEndpoint , facility , getRouteName ( 's' ) , getToken ( botEmulator ) ) ; server . post ( 's' , verifyBotFramework , facility , getRouteName ( 's' ) , emulateOAuthCards ( botEmulator ) ) ; server . del ( 's' , verifyBotFramework , botEndpoint , facility , getRouteName ( 's' ) , signOut ( botEmulator ) ) ; server . post ( 's' , ... uses , jsonBodyParser , facility , getRouteName ( 's' ) , tokenResponse ( botEmulator ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $BotEmulator$ O $Server$ O $any[]$ O $any$ O O O O O $any[]$ O $any[]$ O O O O $Promise<void>$ O $Promise<void>$ O $BotEmulator$ O $any$ O $any$ O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O $any$ O $any$ O O O O $any[]$ O $any[]$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O
export default function createStripEmptyBearerTokenMiddleware ( ) { return ( req , res , next ) => { if ( ! req . headers . authorization ) { return next ( ) ; } const pieces = req . headers . authorization . split ( 's' , 0 ) ; if ( pieces . length === 0 && pieces [ 0 ] === 's' ) { delete req . headers . authorization ; } return next ( ) ; } ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O
import { BotEmulatorOptions , Logger , LogService } from 's' ; import * as Restify from 's' ; import fetch from 's' ; import registerAttachmentRoutes from 's' ; import registerBotStateRoutes from 's' ; import registerConversationRoutes from 's' ; import registerDirectLineRoutes from 's' ; import registerEmulatorRoutes from 's' ; import Attachments from 's' ; import BotState from 's' ; import ConsoleLogService from 's' ; import ConversationSet from 's' ; import EndpointSet from 's' ; import LoggerAdapter from 's' ; import Users from 's' ; import registerSessionRoutes from 's' ; import registerUserTokenRoutes from 's' ; import stripEmptyBearerToken from 's' ; const DEFAULT_OPTIONS = { fetch , loggerOrLogService : new ConsoleLogService ( ) , stateSizeLimitKB : 0 , } ; export interface Facilities { attachments : Attachments ; botState : BotState ; conversations : ConversationSet ; endpoints : EndpointSet ; logger : Logger ; users : Users ; locale ? : string ; } export class BotEmulator { public getServiceUrl : ( botUrl ) => Promise < string > ; public getServiceUrlForOAuth : ( ) => Promise < string > ; public shutDownOAuthNgrokInstance : ( ) => void ; public options : BotEmulatorOptions ; public facilities : Facilities ; constructor ( getServiceUrl : ( botUrl ) => Promise < string > , getServiceUrlForOAuth : ( ) => Promise < string > , shutDownOAuthNgrokInstance : ( ) => void , options = DEFAULT_OPTIONS ) { this . getServiceUrl = getServiceUrl ; this . getServiceUrlForOAuth = getServiceUrlForOAuth ; this . shutDownOAuthNgrokInstance = shutDownOAuthNgrokInstance ; this . options = { ... DEFAULT_OPTIONS , ... options } ; const logService = this . options . loggerOrLogService as LogService ; const logger = logService && logService . logToChat ? new LoggerAdapter ( logService as LogService ) : ( this . options . loggerOrLogService as Logger ) ; this . facilities = { attachments : new Attachments ( ) , botState : new BotState ( this , this . options . stateSizeLimitKB ) , conversations : new ConversationSet ( ) , endpoints : new EndpointSet ( this . options ) , logger , users : new Users ( ) , } ; } public mount ( router : Restify . Server ) { const uses = [ Restify . plugins . acceptParser ( router . acceptable ) , stripEmptyBearerToken ( ) , Restify . plugins . dateParser ( ) , Restify . plugins . queryParser ( ) , ] ; registerAttachmentRoutes ( this , router , uses ) ; registerBotStateRoutes ( this , router , uses ) ; registerConversationRoutes ( this , router , uses ) ; registerDirectLineRoutes ( this , router , uses ) ; registerSessionRoutes ( this , router , uses ) ; registerUserTokenRoutes ( this , router , uses ) ; registerEmulatorRoutes ( this , router , uses ) ; return this ; } }	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O O $void$ O O O O $any$ O O O O $BotEmulatorOptions$ O O $any$ O $ConsoleLogService$ O O $any$ O O O $number$ O O O O O O O $any$ O $Attachments$ O $any$ O $BotState$ O $any$ O $ConversationSet$ O $any$ O $Endpoints$ O $any$ O $any$ O $any$ O $Users$ O $any$ O $string$ O O O O O O O $any$ O O $Promise<string>$ O O $string$ O O $PromiseConstructor$ O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O O O O O $void$ O O O O O O O $any$ O $any$ O O $Facilities$ O $any$ O O O $Promise<string>$ O O $string$ O O $PromiseConstructor$ O O O O $Promise<string>$ O O O O $PromiseConstructor$ O O O O $void$ O O O O O O $BotEmulatorOptions$ O $any$ O O O O $Promise<string>$ O $Promise<string>$ O O O $Promise<string>$ O $Promise<string>$ O O O $void$ O $void$ O O O $any$ O O O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O $Logger$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $Facilities$ O O $Attachments$ O O $any$ O O O $BotState$ O O $any$ O O O O O $any$ O $any$ O O $ConversationSet$ O O $any$ O O O $Endpoints$ O O $any$ O O O $any$ O O $any$ O $Users$ O O $any$ O O O O O O O $BotEmulator$ O $any$ O $any$ O $any$ O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O $void$ O O O $any$ O $any[]$ O O O O O O O
import { ErrorCodes } from 's' ; import { AttachmentData } from 's' ; import * as HttpStatus from 's' ; import { Next , Request , Response } from 's' ; import { BotEmulator } from 's' ; import createAPIException from 's' ; import AttachmentParams from 's' ; import sendErrorResponse from 's' ; export default function getAttachment ( bot ) { return ( req , res , next ) : any => { try { const parms = req . params ; const attachment = bot . facilities . attachments . getAttachmentData ( parms . attachmentId ) ; if ( attachment ) { if ( parms . viewId === 's' || parms . viewId === 's' ) { const 0 = parms . viewId === 's' ? attachment . 0 : attachment . 0 ; if ( 0 ) { let buffer ; if ( 0 . buffer ) { buffer = Buffer . from ( 0 as any ) ; } else { buffer = Buffer . from ( 0 . toString ( ) , 's' ) ; } res . contentType = attachment . type ; res . send ( HttpStatus . OK , buffer ) ; } else { sendErrorResponse ( req , res , next , createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , parms . viewId === 's' ? 's' : 's' ) ) ; } } } else { sendErrorResponse ( req , res , next , createAPIException ( HttpStatus . NOT_FOUND , ErrorCodes . BadArgument , `template` ) ) ; } } catch ( err ) { sendErrorResponse ( req , res , next , createAPIException ( HttpStatus . INTERNAL_SERVER_ERROR , ErrorCodes . ServiceError , err . message ) ) ; } next ( ) ; } ; }	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $BotEmulator$ O O O O $Request$ O $Response$ O $Next$ O O O O O O O O $AttachmentParams$ O $any$ O $any$ O O $AttachmentData$ O $BotEmulator$ O $Facilities$ O $Attachments$ O $any$ O $AttachmentParams$ O $string$ O O O O $any$ O O O O $AttachmentParams$ O $string$ O O O $AttachmentParams$ O $string$ O O O O O $any$ O $AttachmentParams$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $AttachmentParams$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O
import * as HttpStatus from 's' ; import Attachments from 's' ; import getAttachment from 's' ; import getAttachmentInfo from 's' ; describe ( 's' , ( ) => { let facilities ; let attachments ; let attachmentId ; const mockAttachmentData = new 0 ( Buffer . from ( 's' ) ) ; beforeEach ( ( ) => { attachments = new Attachments ( ) ; attachmentId = attachments . uploadAttachment ( { name : 's' , 0 : mockAttachmentData , type : 's' , 0 : mockAttachmentData , } ) ; facilities = { attachments , } ; } ) ; it ( 's' , ( ) => { const getAttachmentMiddleware = getAttachment ( { facilities } as any ) ; const req = { params : { viewId : 's' , attachmentId , } , } ; const res = { send : ( ) => null , end : ( ) => void 0 , contentType : 's' , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getAttachmentMiddleware ( req as any , res as any , function ( ) { return null ; } as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , Buffer . from ( mockAttachmentData ) ) ; expect ( res . contentType ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const getAttachmentMiddleware = getAttachment ( { facilities } as any ) ; ( attachments as any ) . attachments [ attachmentId ] . 0 = undefined ; ( attachments as any ) . attachments [ attachmentId ] . 0 = undefined ; const req = { params : { viewId : 's' , attachmentId , } , } ; const res = { send : ( ) => null , end : ( ) => null , contentType : 's' , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getAttachmentMiddleware ( req as any , res as any , function ( ) { return null ; } as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . NOT_FOUND , { error : { code : 's' , message : 's' , } , } ) ; expect ( res . contentType ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { let facilities ; let attachments ; let attachmentId ; beforeEach ( ( ) => { attachments = new Attachments ( ) ; attachmentId = attachments . uploadAttachment ( { name : 's' , 0 : new 0 ( Buffer . from ( 's' ) ) , type : 's' , 0 : new 0 ( Buffer . from ( 's' ) ) , } ) ; facilities = { attachments , } ; } ) ; it ( 's' , ( ) => { const getAttachmentInfoMiddleware = getAttachmentInfo ( { facilities , } as any ) ; const req = { params : { viewId : 's' , attachmentId , } , } ; const res = { send : ( ) => null , end : ( ) => null , contentType : 's' , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getAttachmentInfoMiddleware ( req as any , res as any , function ( ) { return null ; } as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { name : 's' , type : 's' , views : [ { size : 0 , viewId : 's' } , { size : 0 , viewId : 's' } ] , } ) ; } ) ; it ( 's' , ( ) => { const getAttachmentInfoMiddleware = getAttachmentInfo ( { facilities , } as any ) ; const req = { params : { viewId : 's' , attachmentId : 's' , } , } ; const res = { send : ( ) => null , end : ( ) => null , contentType : 's' , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getAttachmentInfoMiddleware ( req as any , res as any , function ( ) { return null ; } as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . NOT_FOUND , { error : { code : 's' , message : 's' , } , } ) ; } ) ; } ) ;	O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O O $any$ O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O $string$ O O O O O O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $any$ O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $complex$ O O O $complex$ O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O O O O $any$ O $any$ O O $any$ O $undefined$ O O $complex$ O O $complex$ O O $string$ O O O $any$ O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $complex$ O O O $complex$ O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O $any$ O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $complex$ O O O $complex$ O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $complex$ O O O $number$ O O O $string$ O O O O O $number$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $complex$ O O O $complex$ O O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O
import getFacility from 's' ; import getRouteName from 's' ; import registerRoutes from 's' ; import getAttachment from 's' ; import getAttachmentInfo from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const server = { get , } ; const uses = [ ] ; const emulator = { } ; registerRoutes ( emulator , server , uses ) ; expect ( getFacility ) . toHaveBeenCalledWith ( 's' ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , getFacility ( 's' ) , getRouteName ( 's' ) , getAttachmentInfo ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , getFacility ( 's' ) , getRouteName ( 's' ) , getAttachment ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $void$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O $any[]$ O O O O O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O
import { GenericActivity , ILogItem } from 's' ; import { BotEmulator } from 's' ; import ConsoleLogService from 's' ; import registerAttachmentRoutes from 's' ; import registerBotStateRoutes from 's' ; import registerConversationRoutes from 's' ; import registerDirectLineRoutes from 's' ; import registerEmulatorRoutes from 's' ; import registerSessionRoutes from 's' ; import registerUserTokenRoutes from 's' ; import stripEmptyBearerToken from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; const mockAcceptParser = jest . fn ( _acceptable => null ) ; const mockDateParser = jest . fn ( ( ) => null ) ; const mockQueryParser = jest . fn ( ( ) => null ) ; jest . mock ( 's' , ( ) => ( { plugins : { get acceptParser ( ) { return mockAcceptParser ; } , get dateParser ( ) { return mockDateParser ; } , get queryParser ( ) { return mockQueryParser ; } , } , } ) ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const getServiceUrl = _url => Promise . resolve ( 's' ) ; const getServiceUrlForOAuth = ( ) => Promise . resolve ( 's' ) ; const shutDownOAuthNgrokInstance = jest . fn ( ( ) => null ) ; const customFetch = ( _url , _options ) => Promise . resolve ( ) ; const customLogger = { logActivity : ( _conversationId , _activity , _role ) => 's' , logMessage : ( _conversationId , ... _items : ILogItem [ ] ) => 's' , logException : ( _conversationId , _err ) => 's' , } ; const customLogService = new ConsoleLogService ( ) ; const 0 = { fetch : customFetch , loggerOrLogService : customLogger , } ; const 0 = new BotEmulator ( getServiceUrl , getServiceUrlForOAuth , shutDownOAuthNgrokInstance , 0 ) ; const serviceUrl = await 0 . getServiceUrl ( 's' ) ; const serviceUrlForOAuth = await 0 . getServiceUrlForOAuth ( ) ; 0 . shutDownOAuthNgrokInstance ( ) ; expect ( serviceUrl ) . toBe ( 's' ) ; expect ( serviceUrlForOAuth ) . toBe ( 's' ) ; expect ( shutDownOAuthNgrokInstance ) . toHaveBeenCalled ( ) ; expect ( 0 . options ) . toEqual ( { ... 0 , stateSizeLimitKB : 0 } ) ; expect ( 0 . facilities . attachments ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . botState ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . conversations ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . endpoints ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . logger ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . users ) . not . toBeFalsy ( ) ; expect ( 0 . facilities . botState . stateSizeLimitKB ) . toBe ( 0 ) ; expect ( await 0 . facilities . logger . logActivity ( 's' , null , 's' ) ) . toBe ( 's' ) ; expect ( await 0 . facilities . logger . logException ( 's' , null ) ) . toBe ( 's' ) ; expect ( await 0 . facilities . logger . logMessage ( 's' ) ) . toBe ( 's' ) ; const 0 = { fetch : customFetch , loggerOrLogService : customLogService , } ; const 0 = new BotEmulator ( getServiceUrl , 0 ) ; expect ( ( 0 . facilities . logger as any ) . logService ) . toEqual ( customLogService ) ; } ) ; it ( 's' , ( ) => { const getServiceUrl = _url => Promise . resolve ( 's' ) ; const botEmulator = new BotEmulator ( getServiceUrl ) ; const restifyServer = { acceptable : true } ; const mockUses = [ mockAcceptParser ( restifyServer . acceptable ) , stripEmptyBearerToken ( ) , mockDateParser ( ) , mockQueryParser ( ) , ] ; mockAcceptParser . mockClear ( ) ; ( stripEmptyBearerToken as any ) . mockClear ( ) ; mockDateParser . mockClear ( ) ; mockQueryParser . mockClear ( ) ; const mountedEmulator = botEmulator . mount ( restifyServer as any ) ; expect ( mountedEmulator ) . toEqual ( botEmulator ) ; expect ( mockAcceptParser ) . toHaveBeenCalledWith ( restifyServer . acceptable ) ; expect ( stripEmptyBearerToken ) . toHaveBeenCalled ( ) ; expect ( mockDateParser ) . toHaveBeenCalled ( ) ; expect ( mockQueryParser ) . toHaveBeenCalled ( ) ; expect ( registerAttachmentRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerBotStateRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerConversationRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerDirectLineRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerSessionRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerUserTokenRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; expect ( registerEmulatorRoutes ) . toHaveBeenCalledWith ( botEmulator , restifyServer , mockUses ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<string>$ O $any$ O $PromiseConstructor$ O $complex$ O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O $any$ O $any$ O O $PromiseConstructor$ O $complex$ O O O O $complex$ O O $string$ O O $string$ O $GenericActivity$ O $string$ O O O O $string$ O O $string$ O O $any[]$ O $any$ O O O O O O $string$ O O $string$ O $Error$ O O O O O O O $ConsoleLogService$ O O $any$ O O O O $complex$ O O $Promise<void>$ O $Promise<void>$ O $complex$ O $complex$ O O O O $BotEmulator$ O O $any$ O $Promise<string>$ O $Promise<string>$ O $any$ O $complex$ O O O $string$ O O $BotEmulator$ O $Promise<string>$ O O O O O $string$ O O $BotEmulator$ O $Promise<string>$ O O O $BotEmulator$ O $void$ O O O $any$ O $string$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $BotEmulator$ O $any$ O O $any$ O O O $complex$ O $number$ O O O O O $any$ O $BotEmulator$ O $Facilities$ O $Attachments$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $Endpoints$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $any$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $Users$ O O $any$ O $any$ O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $number$ O O $any$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O $any$ O O O O O $any$ O O O O O $complex$ O O $Promise<void>$ O $Promise<void>$ O $ConsoleLogService$ O $ConsoleLogService$ O O O O $BotEmulator$ O O $any$ O $Promise<string>$ O $complex$ O O $any$ O O $BotEmulator$ O $Facilities$ O $any$ O O O O $any$ O O $any$ O $ConsoleLogService$ O O O O O $any$ O O O O O O O O $Promise<string>$ O $any$ O $PromiseConstructor$ O $complex$ O O O O O $BotEmulator$ O O $any$ O $Promise<string>$ O O O $complex$ O O $boolean$ O O O O O $any[]$ O O $any$ O $complex$ O $boolean$ O O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $BotEmulator$ O $BotEmulator$ O $BotEmulator$ O $complex$ O O O O $any$ O $BotEmulator$ O O $any$ O $BotEmulator$ O O $any$ O $any$ O O $any$ O $complex$ O $boolean$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O $any$ O $void$ O O $any$ O $BotEmulator$ O $complex$ O $any[]$ O O O O O O O O
import { User } from 's' ; import * as HttpStatus from 's' ; import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import BotState from 's' ; import Conversation from 's' ; import ConversationSet from 's' ; import deleteStateForUser from 's' ; import fetchBotData from 's' ; import getConversationData from 's' ; import getPrivateConversationData from 's' ; import getUserData from 's' ; import setConversationData from 's' ; import setPrivateConversationData from 's' ; describe ( 's' , ( ) => { let botState ; let emulator ; let conversation ; let user ; let res ; const channelId = 's' ; beforeEach ( ( ) => { res = { send : ( ) => null , end : ( ) => null , contentType : 's' , } ; emulator = { facilities : { logger : { logMessage : ( ) => true } } } as any ; emulator . facilities . conversations = new ConversationSet ( ) ; user = { id : 's' , name : 's' } ; const endpoint = new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { } ) ; conversation = emulator . facilities . conversations . newConversation ( emulator , endpoint , user ) ; botState = new BotState ( emulator , 0 ) ; jest . spyOn ( Date , 's' ) . mockReturnValue ( { toString : ( ) => 's' } ) ; botState . setBotData ( channelId , conversation . conversationId , user . id , { eTag : 's' , data : { state : 's' } , } ) ; emulator . facilities . botState = botState ; } ) ; it ( 's' , ( ) => { const deleteStateMiddleware = deleteStateForUser ( emulator ) ; const req = { params : { userId : user . id } , accepts : 's' , acceptsEncoding : 's' , } ; const sendSpy = jest . spyOn ( res , 's' ) ; deleteStateMiddleware ( req as any , res as any , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK ) ; expect ( emulator . facilities . botState . getBotData ( channelId , conversation . conversationId , user . id ) ) . toEqual ( { data : null , eTag : 's' , } ) ; } ) ; it ( 's' , ( ) => { const fetchBotDataMiddleware = fetchBotData ( emulator ) ; const req = { params : { userId : user . id , conversationId : conversation . conversationId , channelId , } , botData : null , } ; fetchBotDataMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( req . botData ) . toEqual ( { data : { state : 's' } , eTag : 's' } ) ; } ) ; it ( 's' , ( ) => { const getConversationDataMiddleware = getConversationData ( emulator ) ; const req = { botData : { testBotData : true } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getConversationDataMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , req . botData ) ; } ) ; it ( 's' , ( ) => { const privateConversationMiddleware = getPrivateConversationData ( emulator ) ; const req = { botData : { testBotData : true } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; privateConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , req . botData ) ; } ) ; it ( 's' , ( ) => { const getUserDataMiddleware = getUserData ( emulator ) ; const req = { botData : { testBotData : true } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; getUserDataMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , req . botData ) ; } ) ; it ( 's' , ( ) => { const setConversationMiddleware = setConversationData ( emulator ) ; const req = { params : { channelId , conversationId : conversation . conversationId , userId : 's' , } , body : { data : { newBotData : true } , eTag : 's' } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; setConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { data : req . body . data , eTag : 's' , } ) ; expect ( emulator . facilities . botState . getBotData ( channelId , conversation . conversationId , user . id ) ) . toEqual ( { data : { newBotData : true } , eTag : 's' , } ) ; } ) ; it ( 's' , ( ) => { const setPrivateConversationDataMiddleware = setPrivateConversationData ( emulator ) ; const req = { params : { channelId , conversationId : conversation . conversationId , userId : 's' , } , body : { data : { newBotData : true } , eTag : 's' } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; setPrivateConversationDataMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { data : req . body . data , eTag : 's' , } ) ; expect ( emulator . facilities . botState . getBotData ( channelId , conversation . conversationId , user . id ) ) . toEqual ( { data : { newBotData : true } , eTag : 's' , } ) ; } ) ; it ( 's' , ( ) => { const setUserDataMiddleware = setPrivateConversationData ( emulator ) ; const req = { params : { channelId , conversationId : conversation . conversationId , userId : 's' , } , body : { data : { newBotData : true } , eTag : 's' } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; setUserDataMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { data : req . body . data , eTag : 's' , } ) ; expect ( emulator . facilities . botState . getBotData ( channelId , conversation . conversationId , user . id ) ) . toEqual ( { data : { newBotData : true } , eTag : 's' , } ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $BotState$ O O $BotEmulator$ O O $Conversation$ O O $User$ O O $any$ O O O O O O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $BotEmulator$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O O O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $BotEmulator$ O $BotEndpoint$ O $any$ O O $BotState$ O O $any$ O $BotEmulator$ O O O O $any$ O $any$ O $DateConstructor$ O O O O $any$ O O $string$ O O O O O O O O $BotState$ O $any$ O O O $Conversation$ O $string$ O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O O O $BotEmulator$ O $Facilities$ O $BotState$ O $BotState$ O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O O O $Conversation$ O $string$ O $any$ O $any$ O O O $any$ O O $null$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $string$ O $Conversation$ O $string$ O $string$ O O O $null$ O O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $complex$ O $any$ O O $any$ O O $complex$ O O $string$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O $string$ O $Conversation$ O $string$ O $string$ O O O O O $complex$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O $complex$ O $string$ O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O O O $Conversation$ O $string$ O $any$ O $any$ O O O $any$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O $string$ O $Conversation$ O $string$ O $string$ O O O O O $complex$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O $complex$ O $string$ O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O O O $Conversation$ O $string$ O $any$ O $any$ O O O $any$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O $string$ O $Conversation$ O $string$ O $string$ O O O O O $complex$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O $complex$ O $string$ O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $BotState$ O $any$ O O O $Conversation$ O $string$ O $any$ O $any$ O O O $any$ O O $complex$ O O $boolean$ O O O O $string$ O O O O O O O O O O O O
import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import jsonBodyParser from 's' ; import registerRoutes from 's' ; import deleteStateForUser from 's' ; import createFetchBotDataMiddleware from 's' ; import getConversationData from 's' ; import getPrivateConversationData from 's' ; import getUserData from 's' ; import setConversationData from 's' ; import setPrivateConversationData from 's' ; import setUserData from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const post = jest . fn ( ( ) => null ) ; const del = jest . fn ( ( ) => null ) ; const server = { get , post , del , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( emulator . options . fetch ) ; const fetchBotDataMiddleware = createFetchBotDataMiddleware ( emulator ) ; const facility = getFacility ( 's' ) ; registerRoutes ( emulator , server , uses ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getUserData ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getConversationData ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchBotDataMiddleware , facility , getRouteName ( 's' ) , getPrivateConversationData ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setUserData ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setConversationData ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser ( ) , facility , getRouteName ( 's' ) , setPrivateConversationData ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , facility , getRouteName ( 's' ) , deleteStateForUser ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $void$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O
import { AttachmentData } from 's' ; import { ConversationParameters , Activity } from 's' ; import * as HttpStatus from 's' ; import { BotEmulator } from 's' ; import { usGovernmentAuthentication } from 's' ; import Attachments from 's' ; import BotEndpoint from 's' ; import Conversation from 's' ; import ConversationSet from 's' ; import Endpoints from 's' ; import Users from 's' ; import createConversation from 's' ; import deleteActivity from 's' ; import fetchConversation from 's' ; import getActivityMembers from 's' ; import getBotEndpoint from 's' ; import replyToActivity from 's' ; import sendActivityToConversation from 's' ; import sendHistoryToConversation from 's' ; import updateActivity from 's' ; import uploadAttachment from 's' ; import createFetchConversationMiddleware from 's' ; describe ( 's' , ( ) => { let emulator ; let res ; beforeEach ( ( ) => { res = { send : ( ) => null , end : ( ) => null , contentType : 's' , } ; emulator = createEmulatorUtil ( ) ; } ) ; it ( 's' , ( ) => { const bot = { role : 's' , name : 's' , id : 's' } ; const req = { botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { } ) , body : { isGroup : false , members : [ { id : 's' , name : 's' , role : 's' } ] , bot , conversationId : 's' , activity : null , channelData : null , } as ConversationParameters , } ; const createConversationMiddleware = createConversation . bind ( { botId : bot . id , } ) ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; createConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : 's' , } ) ; const newConversation = emulator . facilities . conversations . conversationById ( 's' ) ; expect ( newConversation ) . toBeTruthy ( ) ; expect ( newConversation . botEndpoint ) . toEqual ( req . botEndpoint ) ; expect ( newConversation . user ) . toEqual ( { id : 's' , name : 's' } ) ; expect ( newConversation . members ) . toEqual ( [ { id : 's' , name : 's' } , { id : 's' , name : 's' } ] ) ; } ) ; it ( 's' , ( ) => { const bot = { role : 's' , name : 's' , id : 's' } ; let req = { botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { } ) , body : { isGroup : false , members : [ { id : 's' , name : 's' , role : 's' } ] , bot , conversationId : 's' , activity : { } as Activity , channelData : null , } as ConversationParameters , } ; const createConversationMiddleware = createConversation . bind ( { botId : bot . id , } ) ( emulator ) ; let activity = { activityId : 's' } ; res . send = ( _ , actvty ) => ( activity = actvty ) ; createConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; const conversation = emulator . facilities . conversations . conversationById ( 's' ) ; req = { params : { activityId : activity . activityId , } , conversation , } ; expect ( ( conversation as any ) . activities . length ) . toBe ( 0 ) ; const deleteActivityMiddleware = deleteActivity ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; deleteActivityMiddleware ( req , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK ) ; expect ( ( conversation as any ) . activities . length ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { const targetConversation = createConversationUtil ( emulator ) ; const req = { params : { conversationId : 's' , } , conversation : null , } ; const fetchConversationMiddleware = fetchConversation ( emulator ) ; fetchConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( req . conversation ) . toBe ( targetConversation ) ; } ) ; it ( 's' , ( ) => { const conversation = createConversationUtil ( emulator ) ; const getActivityMembersMiddleware = getActivityMembers ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; const req = { conversation , } ; getActivityMembersMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , conversation . members ) ; } ) ; it ( 's' , async ( ) => { const conversation = createConversationUtil ( emulator ) ; const mockActivity = { conversation : { id : 's' , } , id : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , from : { id : 's' , } , timestamp : 's' , type : 's' , channelId : 's' , membersAdded : [ { id : 's' , name : 's' , role : 's' , } , ] , membersRemoved : [ ] , } ; const replyToActivityMiddleware = replyToActivity ( emulator ) ; const req = { conversation , body : mockActivity , params : { activityId : 's' , } , headers : { authorization : Buffer . from ( 's' ) . toString ( 's' ) , } , } ; const sendSpy = jest . spyOn ( res , 's' ) ; await replyToActivityMiddleware ( req as any , res , ( ( ) => null ) as any ) ; const { activities } = conversation . getActivitiesSince ( 0 ) ; expect ( activities . length ) . toBe ( 0 ) ; expect ( activities [ 0 ] . replyToId ) . toBe ( 's' ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : activities [ 0 ] . id , } ) ; } ) ; it ( 's' , ( ) => { const conversation = createConversationUtil ( emulator ) ; const mockActivity = { conversation : { id : 's' , } , id : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , from : { id : 's' , } , timestamp : 's' , type : 's' , channelId : 's' , membersAdded : [ { id : 's' , name : 's' , role : 's' , } , ] , membersRemoved : [ ] , } ; const req = { conversation , body : mockActivity , params : { activityId : 's' , } , } ; const sendActivityMiddleware = sendActivityToConversation ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; sendActivityMiddleware ( req as any , res , ( ( ) => null ) as any ) ; const { activities } = conversation . getActivitiesSince ( 0 ) ; expect ( activities . length ) . toBe ( 0 ) ; expect ( activities [ 0 ] . replyToId ) . toBe ( 's' ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : activities [ 0 ] . id , } ) ; } ) ; it ( 's' , ( ) => { const mockActivities = [ { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , serviceUrl : 's' , } , { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , serviceUrl : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , attachments : [ { contentType : 's' , content : { type : 's' , horizontalAlignment : 's' , separator : true , height : 's' , body : [ { type : 's' , horizontalAlignment : 's' , spacing : 's' , height : 's' , columns : [ { type : 's' , spacing : 's' , items : [ { type : 's' , size : 's' , weight : 's' , text : 's' , } , { type : 's' , size : 's' , text : "s" , wrap : true , } , ] , } , { type : 's' , spacing : 's' , items : [ { type : 's' , horizontalAlignment : 's' , url : 's' , size : 's' , } , ] , width : 's' , } , ] , } , ] , actions : [ { type : 's' , title : 's' , data : { intent : 's' , } , } , { type : 's' , title : 's' , data : { intent : 's' , } , } , ] , $schema : 's' , version : 's' , } , } , ] , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , ] ; const conversation = createConversationUtil ( emulator ) ; const req = { conversation , body : { activities : mockActivities } , } ; const sendHistoryToConversationMiddleware = sendHistoryToConversation ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; sendHistoryToConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; const { activities } = conversation . getActivitiesSince ( 0 ) ; expect ( activities . length ) . toBe ( 0 ) ; activities . forEach ( ( activity , index ) => { expect ( activity ) . toEqual ( { ... mockActivities [ index ] , localTimestamp : jasmine . any ( String ) , } ) ; } ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : jasmine . any ( String ) , } ) ; } ) ; it ( 's' , ( ) => { const mockActivity = { conversation : { id : 's' , } , id : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , from : { id : 's' , } , attachments : [ ] , timestamp : 's' , type : 's' , channelId : 's' , membersAdded : [ { id : 's' , name : 's' , role : 's' , } , ] , membersRemoved : [ ] , } ; const conversation = createConversationUtil ( emulator ) ; const req = { conversation , body : mockActivity as any , params : { activityId : mockActivity . id , } , } ; sendActivityToConversation ( emulator ) ( req as any , res , ( ( ) => null ) as any ) ; const { activities } = conversation . getActivitiesSince ( 0 ) ; const [ activity ] = activities ; const updateActivityMiddleware = updateActivity ( emulator ) ; req . body = { ... req . body , text : 's' , id : activity . id , } as Activity ; req . params . activityId = activity . id ; const sendSpy = jest . spyOn ( res , 's' ) ; updateActivityMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : jasmine . any ( String ) , } ) ; expect ( ( conversation . getActivitiesSince ( 0 ) . activities [ 0 ] as Activity ) . text ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const mockAttachment = { type : 's' , 0 : Buffer . from ( 's' ) . toString ( 's' ) , } as AttachmentData ; const uploadAttachmentMiddleware = uploadAttachment ( emulator ) ; const req = { body : mockAttachment , } ; const sendSpy = jest . spyOn ( res , 's' ) ; uploadAttachmentMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : jasmine . any ( String ) , } ) ; expect ( Object . keys ( ( emulator . facilities . attachments as any ) . attachments ) . length ) . toBe ( 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { let emulator ; let res ; let getBotEndpointMiddleware ; let sentResponses ; beforeEach ( ( ) => { sentResponses = [ ] ; res = { send : ( ... args ) => sentResponses . push ( args ) , end : ( ) => null , contentType : 's' , } ; emulator = createEmulatorUtil ( ) ; getBotEndpointMiddleware = getBotEndpoint ( emulator ) ; } ) ; it ( 's' , ( ) => { const req = { body : { bot : { id : 's' , } , } , headers : { 's' : 's' , 's' : 's' , 's' : 's' , } , } as any ; getBotEndpointMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( emulator . facilities . endpoints . get ( 's' ) ) . not . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { const req = { body : { bot : { id : 's' , } , } , headers : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } , } as any ; getBotEndpointMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( emulator . facilities . endpoints . get ( 's' ) ) . not . toBeNull ( ) ; const endpoint = emulator . facilities . endpoints . get ( 's' ) ; expect ( endpoint . channelService ) . toEqual ( usGovernmentAuthentication . channelService ) ; } ) ; it ( 's' , ( ) => { const req = { jwt : { appId : 's' , } , } as any ; emulator . facilities . endpoints . push ( null , { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , } ) ; getBotEndpointMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( req . botEndpoint ) . not . toBeNull ( ) ; } ) ; it ( 's' , ( ) => { emulator . facilities . endpoints . push ( null , { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , } ) ; const bot = { role : 's' , name : 's' , id : 's' } ; const req = { headers : { 's' : 's' , 's' : 's' , 's' : 's' , } , body : { isGroup : false , members : [ { id : 's' , name : 's' , role : 's' } ] , bot , conversationId : 's' , activity : null , channelData : null , } as ConversationParameters , } as any ; getBotEndpointMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( req . botEndpoint . msaAppId ) . toBe ( 's' ) ; expect ( req . botEndpoint . msaPassword ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const mockConversations = { 's' : { conversationId : 's' , members : [ ] } , 's' : { conversationId : 's' , members : [ ] } , 's' : { conversationId : 's' , members : [ ] } , } ; ( emulator . facilities . conversations as any ) [ 's' ] = mockConversations ; const req = { params : { continuationToken : 's' } } as any ; const fetchConversationMiddleware = createFetchConversationMiddleware ( emulator ) ; fetchConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sentResponses [ 0 ] [ 0 ] ) . toEqual ( { conversations : [ { id : 's' , members : [ ] , } , { id : 's' , members : [ ] , } , ] , } ) ; } ) ; } ) ; function createConversationUtil ( emulator ) { const bot = { role : 's' , name : 's' , id : 's' } ; const req = { botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { } ) , body : { isGroup : false , members : [ { id : 's' , name : 's' , role : 's' } ] , bot , conversationId : 's' , activity : { } as Activity , channelData : null , } as ConversationParameters , } ; const createConversationMiddleware = createConversation . bind ( { botId : bot . id , } ) ( emulator ) ; createConversationMiddleware ( req as any , { send : ( ) => null , end : ( ) => null } , ( ( ) => null ) as any ) ; return emulator . facilities . conversations . conversationById ( 's' ) ; } function createEmulatorUtil ( ) { const emulator = { facilities : { logger : { logMessage : ( ) => true } } , } as any ; emulator . facilities . conversations = new ConversationSet ( ) ; emulator . facilities . users = new Users ( ) ; emulator . facilities . users . currentUserId = 's' ; emulator . facilities . endpoints = new Endpoints ( emulator ) ; emulator . facilities . logger = { logActivity : ( ) => null } as any ; emulator . facilities . attachments = new Attachments ( ) ; emulator . options = { } ; return emulator ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O $any$ O O O O O O O O $BotEmulator$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $BotEmulator$ O $BotEmulator$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O $string$ O O O $null$ O O O $null$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $complex$ O $string$ O O O O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O O O O $any$ O $Conversation$ O O $any$ O O O $any$ O $Conversation$ O $BotEndpoint$ O O $any$ O $complex$ O $BotEndpoint$ O O $any$ O $Conversation$ O $any$ O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $Conversation$ O $any[]$ O O $any$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O $string$ O O O $any$ O O O O $any$ O $null$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $complex$ O $string$ O O O O $BotEmulator$ O O O $complex$ O O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O O O O $any$ O O $complex$ O O $string$ O $complex$ O $string$ O O O $Conversation$ O O O $any$ O O $Conversation$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $Conversation$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O O O O O $null$ O O O O O O $any$ O $any$ O $BotEmulator$ O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $complex$ O $any$ O O $any$ O $Conversation$ O O O O O $any$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $Conversation$ O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $Conversation$ O $any[]$ O O O O O $any$ O O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $undefined[]$ O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $Conversation$ O $complex$ O $complex$ O $complex$ O O $string$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O O O $any[]$ O O $Conversation$ O $complex$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $undefined[]$ O O O O O O O $complex$ O O $Conversation$ O $complex$ O $complex$ O $complex$ O O $string$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O O O $any[]$ O O $Conversation$ O $complex$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O O O O $Conversation$ O O O O O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $any[]$ O O $Conversation$ O $complex$ O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any[]$ O $void$ O O $any$ O $number$ O O O $any$ O $any$ O O $any$ O O O O O $number$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $undefined[]$ O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $undefined[]$ O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $complex$ O O $Conversation$ O $any$ O $complex$ O O O $complex$ O O $string$ O $complex$ O $string$ O O O O O $any$ O $BotEmulator$ O O $complex$ O O O $any$ O O O O O O O O O O O O O $any[]$ O O $Conversation$ O $complex$ O O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $BotEmulator$ O O $complex$ O $any$ O O O $complex$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $complex$ O $complex$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O $any$ O O $Conversation$ O $complex$ O O O O $any[]$ O O O O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O $any$ O $ObjectConstructor$ O $complex$ O O $BotEmulator$ O $Facilities$ O $Attachments$ O O O O $any$ O O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $BotEmulator$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O O O $any[]$ O O $any$ O $any$ O $any[]$ O O $any$ O O O O O O $string$ O O O O O $BotEmulator$ O $BotEmulator$ O O O $any$ O $any$ O $BotEmulator$ O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $any$ O $BotEmulator$ O $Facilities$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O $any$ O O O O $BotEndpoint$ O $BotEmulator$ O $Facilities$ O $Endpoints$ O $BotEndpoint$ O O O O $any$ O $BotEndpoint$ O $string$ O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O O O O O O O $BotEmulator$ O $Facilities$ O $Endpoints$ O $BotEndpoint$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $BotEmulator$ O $Facilities$ O $Endpoints$ O $BotEndpoint$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O $complex$ O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O $string$ O O O $null$ O O O $null$ O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O $string$ O O O $undefined[]$ O O O O O O O O $string$ O O O $undefined[]$ O O O O O O O O $string$ O O O $undefined[]$ O O O O O O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O O O O O O O O O O $any$ O O $complex$ O O $string$ O O O O O O O O $void$ O $void$ O $BotEmulator$ O O $void$ O $any$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O $complex$ O O O $string$ O O O $undefined[]$ O O O O O O O $string$ O O O $undefined[]$ O O O O O O O O O O O O O O O O O O $Conversation$ O $BotEmulator$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O $boolean$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O $string$ O O O $any$ O O O O $any$ O $null$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $complex$ O $string$ O O O O $BotEmulator$ O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O O O O O O $BotEmulator$ O O O O $any$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O $any$ O O
import { OK } from 's' ; import replyToActivity from 's' ; const mockResolveOAuthCards = jest . fn ( ) . mockResolvedValue ( true ) ; jest . mock ( 's' , ( ) => { return jest . fn ( ) . mockImplementation ( ( ) => { return { resolveOAuthCards : mockResolveOAuthCards } ; } ) ; } ) ; describe ( 's' , ( ) => { const mockReq = { body : { id : 's' , } , conversation : { postActivityToUser : jest . fn ( ( ) => 's' ) , } , headers : { authorization : 's' , } , params : { activityId : 's' , conversationId : 's' , } , } ; const mockRes = { end : jest . fn ( ( ) => null ) , send : jest . fn ( ( ) => null ) , } ; const mockNext = jest . fn ( ( ) => null ) ; const mockBotEmulator = { facilities : { logger : { logException : jest . fn ( ( ) => null ) , } , } , } ; beforeEach ( ( ) => { mockResolveOAuthCards . mockClear ( ) ; mockReq . conversation . postActivityToUser . mockClear ( ) ; mockRes . end . mockClear ( ) ; mockRes . send . mockClear ( ) ; mockNext . mockClear ( ) ; mockBotEmulator . facilities . logger . logException . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { replyToActivity ( mockBotEmulator ) ( mockReq , mockRes , mockNext ) ; await new Promise ( resolve => setTimeout ( resolve , 0 ) ) ; expect ( mockReq . conversation . postActivityToUser ) . toHaveBeenCalledWith ( { ... mockReq . body , replyToId : mockReq . params . activityId , } ) ; expect ( mockRes . send ) . toHaveBeenCalledWith ( OK , 's' ) ; expect ( mockRes . end ) . toHaveBeenCalled ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockReq . body . id = undefined ; replyToActivity ( mockBotEmulator ) ( mockReq , mockRes , mockNext ) ; await new Promise ( resolve => setTimeout ( resolve , 0 ) ) ; expect ( mockReq . conversation . postActivityToUser ) . toHaveBeenCalledWith ( { ... mockReq . body , replyToId : mockReq . params . activityId , id : null , } ) ; expect ( mockRes . send ) . toHaveBeenCalledWith ( OK , 's' ) ; expect ( mockRes . end ) . toHaveBeenCalled ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; mockReq . body . id = 's' ; } ) ; it ( 's' , async ( ) => { const ngrokError = new Error ( 's' ) ; mockResolveOAuthCards . mockRejectedValueOnce ( ngrokError ) ; replyToActivity ( mockBotEmulator ) ( mockReq , mockRes , mockNext ) ; await new Promise ( resolve => setTimeout ( resolve , 0 ) ) ; expect ( mockBotEmulator . facilities . logger . logException ) . toHaveBeenCalledWith ( 's' , ngrokError ) ; expect ( mockBotEmulator . facilities . logger . logException ) . toHaveBeenCalledWith ( 's' , new Error ( 's' ) ) ; expect ( mockReq . conversation . postActivityToUser ) . toHaveBeenCalledWith ( { ... mockReq . body , replyToId : mockReq . params . activityId , } ) ; expect ( mockRes . send ) . toHaveBeenCalledWith ( OK , 's' ) ; expect ( mockRes . end ) . toHaveBeenCalled ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $void$ O $number$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $undefined$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $void$ O $number$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $null$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O $any$ O $any$ O $Error$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $void$ O $number$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $Error$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O
import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import createJsonBodyParser from 's' ; import registerRoutes from 's' ; import createConversation from 's' ; import deleteActivity from 's' ; import createFetchConversationMiddleware from 's' ; import getActivityMembers from 's' ; import getBotEndpoint from 's' ; import getConversationMembers from 's' ; import replyToActivity from 's' ; import sendActivityToConversation from 's' ; import sendHistoryToConversation from 's' ; import updateActivity from 's' ; import uploadAttachment from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const post = jest . fn ( ( ) => null ) ; const del = jest . fn ( ( ) => null ) ; const put = jest . fn ( ( ) => null ) ; const server = { get , post , del , put , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( emulator . options . fetch ) ; const botEndpoint = getBotEndpoint ( emulator ) ; const facility = getFacility ( 's' ) ; const jsonBodyParser = createJsonBodyParser ( ) ; const fetchConversation = createFetchConversationMiddleware ( emulator ) ; registerRoutes ( emulator , server , uses ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , botEndpoint , facility , getRouteName ( 's' ) , createConversation ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , sendActivityToConversation ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , sendHistoryToConversation ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , replyToActivity ( emulator ) ) ; expect ( put ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateActivity ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , deleteActivity ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , getConversationMembers ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , fetchConversation , facility , getRouteName ( 's' ) , getActivityMembers ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , verifyBotFramework , jsonBodyParser , facility , getRouteName ( 's' ) , uploadAttachment ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $void$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $Promise<void>$ O $any[]$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O
import * as HttpStatus from 's' ; import { ConversationParameters } from 's' ; import { BotEmulator } from 's' ; import Conversation from 's' ; import BotEndpoint from 's' ; import createConversation from 's' ; import ConversationSet from 's' ; import Users from 's' ; import Attachments from 's' ; import getActivities from 's' ; import getConversation from 's' ; import options from 's' ; import postActivity from 's' ; import reconnectToConversation from 's' ; import startConversation from 's' ; import stream from 's' ; import upload from 's' ; jest . mock ( 's' , ( ) => ( { ipcMain : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , ipcRenderer : new Proxy ( { } , { get ( ) { return ( ) => ( { } ) ; } , has ( ) { return true ; } , } ) , } ) ) ; jest . mock ( 's' , ( ) => ( { IncomingForm : class { parse ( req , callback : ( mockErr , mockFields , mockFiles ) => any ) { return callback ( null , null , { activity : req . activity , file : req . file } ) ; } } , } ) ) ; jest . mock ( 's' , ( ) => ( { readFileSync : ( ) => 's' , } ) ) ; describe ( 's' , ( ) => { let emulator ; let res ; beforeEach ( ( ) => { res = { send : ( ) => null , end : ( ) => null , json : ( ) => null , contentType : 's' , } ; emulator = { facilities : { logger : { logMessage : ( ) => true , logActivity : ( ) => true , logException : ( ) => null , } , } , } as any ; emulator . facilities . conversations = new ConversationSet ( ) ; emulator . facilities . users = new Users ( ) ; emulator . facilities . users . currentUserId = 's' ; emulator . facilities . users . users = { 's' : { id : 's' , name : 's' } , } ; emulator . facilities . attachments = new Attachments ( ) ; emulator . getServiceUrl = ( ) => 's' ; emulator . options = { tunnelingServiceUrl : 's' , } ; } ) ; it ( 's' , ( ) => { const mockActivities = [ { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , serviceUrl : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , attachments : [ { contentType : 's' , content : { type : 's' , horizontalAlignment : 's' , separator : true , height : 's' , body : [ { type : 's' , horizontalAlignment : 's' , spacing : 's' , height : 's' , columns : [ { type : 's' , spacing : 's' , items : [ { type : 's' , size : 's' , weight : 's' , text : 's' , } , { type : 's' , size : 's' , text : "s" , wrap : true , } , ] , } , { type : 's' , spacing : 's' , items : [ { type : 's' , horizontalAlignment : 's' , url : 's' , size : 's' , } , ] , width : 's' , } , ] , } , ] , actions : [ { type : 's' , title : 's' , data : { intent : 's' , } , } , { type : 's' , title : 's' , data : { intent : 's' , } , } , ] , $schema : 's' , version : 's' , } , } , ] , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , } , ] ; const conversation = createConversationUtil ( emulator ) ; conversation . feedActivities ( mockActivities ) ; const getActivitiesMiddleware = getActivities ( emulator ) ; const req = { query : { watermark : 0 } , conversation , } ; const jsonSpy = jest . spyOn ( res , 's' ) ; getActivitiesMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( jsonSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { activities : mockActivities , watermark : mockActivities . length , } ) ; } ) ; it ( 's' , ( ) => { const conversation = createConversationUtil ( emulator ) ; const getConversationMiddleware = getConversation ( emulator ) ; const req = { params : { conversationId : conversation . conversationId } , conversation : null , } ; getConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( req . conversation ) . toBe ( conversation ) ; } ) ; it ( 's' , ( ) => { const sendSpy = jest . spyOn ( res , 's' ) ; options ( emulator ) ( { } as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK ) ; } ) ; it ( 's' , async ( ) => { const mockActivity = { conversation : { id : 's' , } , id : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , text : 's' , timestamp : 's' , type : 's' , channelId : 's' , } ; const conversation = createConversationUtil ( emulator ) ; const postActivityMiddleware = postActivity ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; const req = { conversation , body : mockActivity , params : { conversationId : conversation . conversationId , } , } ; await postActivityMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { id : 's' } ) ; expect ( ( conversation as any ) . activities [ 0 ] ) . toEqual ( { activity : { ... mockActivity , serviceUrl : 's' , channelId : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : jasmine . any ( String ) , localTimestamp : jasmine . any ( String ) , } , watermark : 0 , } ) ; } ) ; it ( 's' , ( ) => { const conversation = createConversationUtil ( emulator ) ; const reconnectToConversationMiddleware = reconnectToConversation ( emulator ) ; const req = { conversation , params : { conversationId : conversation . conversationId } , } ; const jsonSpy = jest . spyOn ( res , 's' ) ; reconnectToConversationMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( jsonSpy ) . toHaveBeenCalledWith ( HttpStatus . OK , { conversationId : 's' , expires_in : 0 , streamUrl : 's' , token : 's' , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const req = { header : ( ) => 's' , botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { fetch : async ( ) => true , } ) , conversation : null , } ; const jsonSpy = jest . spyOn ( res , 's' ) ; await startConversation ( emulator ) ( req as any , res , ( ( ) => null ) as any ) ; expect ( jsonSpy ) . toHaveBeenCalledWith ( HttpStatus . CREATED , { conversationId : jasmine . any ( String ) , expires_in : 0 , streamUrl : 's' , token : 's' , } ) ; expect ( req . conversation ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { const conversation = createConversationUtil ( emulator ) ; const req = { header : ( ) => 's' , botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { fetch : async ( ) => true , } ) , conversation : null , } ; const jsonSpy = jest . spyOn ( res , 's' ) ; await startConversation ( emulator ) ( req as any , res , ( ( ) => null ) as any ) ; expect ( jsonSpy ) . toHaveBeenCalledWith ( HttpStatus . CREATED , { conversationId : 's' , expires_in : 0 , streamUrl : 's' , token : 's' , } ) ; expect ( req . conversation ) . toBeTruthy ( ) ; expect ( conversation . members . length ) . toBe ( 0 ) ; } ) ; } ) ; it ( 's' , ( ) => { const streamMiddleware = stream ( emulator ) ; const sendSpy = jest . spyOn ( res , 's' ) ; streamMiddleware ( { } as any , res , ( ( ) => null ) as any ) ; expect ( sendSpy ) . toHaveBeenCalledWith ( HttpStatus . NOT_IMPLEMENTED ) ; } ) ; it ( 's' , async ( ) => { const conversation = createConversationUtil ( emulator , 's' ) ; const req = { conversation , params : { conversationId : 's' } , activity : { path : 's' } , file : { name : 's' , type : 's' , path : 's' , } , getContentType : ( ) => 's' , isChunked : ( ) => true , getContentLength : ( ) => 0 , botEndpoint : conversation . botEndpoint , } ; res . send = ( ) => void 0 ; await upload ( emulator ) ( req as any , res , ( ( ) => null ) as any ) ; await Promise . resolve ( true ) ; await Promise . resolve ( true ) ; const { activities } = conversation as any ; expect ( activities . length ) . toBe ( 0 ) ; expect ( activities [ 0 ] . activity . attachments [ 0 ] . name ) . toEqual ( 's' ) ; } ) ; } ) ; function createConversationUtil ( emulator , conversationId = 's' ) { const bot = { role : 's' , name : 's' , id : 's' } ; const req = { botEndpoint : new BotEndpoint ( 's' , 's' , 's' , 's' , 's' , false , 's' , { fetch : async ( ) => ( { json : async ( ) => ( { } ) , text : async ( ) => 's' , status : 0 , } ) , } ) , body : { members : [ { id : 's' , name : 's' , role : 's' } ] , bot , conversationId , } as ConversationParameters , } ; const createConversationMiddleware = createConversation . bind ( { botId : bot . id , } ) ( emulator ) ; createConversationMiddleware ( req as any , { send : ( ) => null , end : ( ) => null } , ( ( ) => null ) as any ) ; return emulator . facilities . conversations . conversationById ( conversationId + 's' ) ; }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O ${}$ O O $ProxyConstructor$ O O O O O $any$ O O O O O O O O O O O O O O $true$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O O O $any$ O O O O O O O O $BotEmulator$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $BotEmulator$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O O O O O O O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O O $any$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $string$ O O O $BotEmulator$ O $Facilities$ O $Users$ O $complex$ O O O O O $string$ O O O $string$ O O O O O O $BotEmulator$ O $Facilities$ O $Attachments$ O O $any$ O O O $BotEmulator$ O $Promise<string>$ O O O O O O $BotEmulator$ O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O O O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $boolean$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O $Conversation$ O $void$ O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $number$ O O O O $Conversation$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $number$ O O O $number$ O O O O O O O $any$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O $Conversation$ O $string$ O O $null$ O O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $complex$ O $any$ O O $any$ O $Conversation$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $BotEmulator$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $Promise<void>$ O $Promise<void>$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $Conversation$ O $complex$ O $complex$ O $complex$ O O $string$ O $Conversation$ O $string$ O O O O O O $Promise<void>$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O O $Conversation$ O O O O $any$ O O O O O $any$ O O $complex$ O O O $complex$ O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $StringConstructor$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O $number$ O O O O O O O O O $any$ O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $Conversation$ O $complex$ O O $string$ O $Conversation$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O $Promise<boolean>$ O O O O O O O O O O $null$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O $BotEmulator$ O O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O $complex$ O O $string$ O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O $Promise<boolean>$ O O O O O O O O O O $null$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<any>$ O $BotEmulator$ O O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O $complex$ O $any$ O O $any$ O O O $any$ O $Conversation$ O $any[]$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Conversation$ O $Conversation$ O $BotEmulator$ O O O O O $complex$ O O $Conversation$ O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $boolean$ O O O O O O $number$ O O O O O O $BotEndpoint$ O $Conversation$ O $BotEndpoint$ O O O $any$ O $any$ O O O O O O O O $any$ O $BotEmulator$ O O $complex$ O O O $any$ O O O O O O O O O O O O $PromiseConstructor$ O $complex$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O O $Conversation$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O O $Conversation$ O $BotEmulator$ O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O O O O $complex$ O O O O O O O $Promise<{}>$ O O O O O O O O O O $Promise<string>$ O O O O O O O $number$ O O O O O O O O O $any$ O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O $string$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O $complex$ O $string$ O O O O $BotEmulator$ O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $string$ O O O O O
import getBotEndpoint from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createJsonBodyParserMiddleware from 's' ; import getActivities from 's' ; import getConversation from 's' ; import options from 's' ; import postActivity from 's' ; import reconnectToConversation from 's' ; import startConversation from 's' ; import stream from 's' ; import upload from 's' ; import registerRoutes from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const post = jest . fn ( ( ) => null ) ; const opts = jest . fn ( ( ) => null ) ; const server = { get , post , opts , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const botEndpoint = getBotEndpoint ( emulator ) ; const conversation = getConversation ( emulator ) ; const facility = getFacility ( 's' ) ; registerRoutes ( emulator , server , uses ) ; expect ( opts ) . toHaveBeenCalledWith ( 's' , ... uses , facility , getRouteName ( 's' ) , options ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , botEndpoint , jsonBodyParser , facility , getRouteName ( 's' ) , startConversation ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , reconnectToConversation ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , getActivities ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , jsonBodyParser , botEndpoint , conversation , facility , getRouteName ( 's' ) , postActivity ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , botEndpoint , conversation , facility , getRouteName ( 's' ) , upload ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , ... uses , facility , getRouteName ( 's' ) , stream ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any[]$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $Promise<void>$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O
import { BotEmulator } from 's' ; import ConversationSet from 's' ; import Users from 's' ; import Endpoints from 's' ; import Attachments from 's' ; import BotEndpoint from 's' ; import getConversationEndpoint from 's' ; describe ( 's' , ( ) => { let emulator ; let res ; let sentResponses ; beforeEach ( ( ) => { sentResponses = [ ] ; res = { json : ( ... args ) => sentResponses . push ( args ) , end : ( ) => null , contentType : 's' , } ; emulator = createEmulatorUtil ( ) ; } ) ; it ( 's' , ( ) => { const targetEndpoint = new BotEndpoint ( 's' ) ; const targetConversation = emulator . facilities . conversations . newConversation ( emulator , targetEndpoint , { name : 's' , id : 's' , } ) ; const getConversationEndpointMiddleware = getConversationEndpoint ( emulator ) ; const req = { params : { conversationId : targetConversation . conversationId } } ; getConversationEndpointMiddleware ( req as any , res , ( ( ) => null ) as any ) ; expect ( sentResponses [ 0 ] [ 0 ] ) . toBe ( 0 ) ; expect ( sentResponses [ 0 ] [ 0 ] ) . toBe ( targetEndpoint ) ; } ) ; } ) ; function createEmulatorUtil ( ) { const emulator = { facilities : { logger : { logMessage : ( ) => true } } , } as any ; emulator . facilities . conversations = new ConversationSet ( ) ; emulator . facilities . users = new Users ( ) ; emulator . facilities . users . currentUserId = 's' ; emulator . facilities . endpoints = new Endpoints ( emulator ) ; emulator . facilities . logger = { logActivity : ( ) => null } as any ; emulator . facilities . attachments = new Attachments ( ) ; emulator . options = { } ; return emulator ; }	O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $BotEmulator$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O O O $any[]$ O O $any$ O $any$ O $any[]$ O O $any$ O O O O O O $string$ O O O O O $BotEmulator$ O $BotEmulator$ O O O O O O $any$ O O O O O O O O $BotEndpoint$ O O $any$ O O O O O $Conversation$ O $BotEmulator$ O $Facilities$ O $ConversationSet$ O $Conversation$ O $BotEmulator$ O $BotEndpoint$ O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $BotEmulator$ O O O $complex$ O O $complex$ O O $string$ O $Conversation$ O $string$ O O O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $BotEndpoint$ O O O O O O O O O $BotEmulator$ O O O O $any$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O O $any$ O O
import getFacility from 's' ; import getRouteName from 's' ; import createJsonBodyParserMiddleware from 's' ; import addUsers from 's' ; import contactAdded from 's' ; import contactRemoved from 's' ; import deleteUserData from 's' ; import createFetchConversationMiddleware from 's' ; import getUsers from 's' ; import paymentComplete from 's' ; import ping from 's' ; import removeUsers from 's' ; import sendTokenResponse from 's' ; import typing from 's' ; import updateShippingAddress from 's' ; import updateShippingOption from 's' ; import registerRoutes from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const post = jest . fn ( ( ) => null ) ; const del = jest . fn ( ( ) => null ) ; const server = { get , post , del , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const fetchConversation = createFetchConversationMiddleware ( emulator ) ; const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const facility = getFacility ( 's' ) ; registerRoutes ( emulator , server , uses ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , getUsers ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , addUsers ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , removeUsers ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , contactAdded ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , contactRemoved ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , typing ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , ping ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , fetchConversation , facility , getRouteName ( 's' ) , deleteUserData ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateShippingAddress ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , updateShippingOption ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , jsonBodyParser , fetchConversation , facility , getRouteName ( 's' ) , paymentComplete ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , jsonBodyParser , facility , getRouteName ( 's' ) , sendTokenResponse ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $any[]$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $any$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $Promise<any>$ O O O O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any[]$ O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any[]$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any[]$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O O O O O O O
import Attachments from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => 's' ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => 's' ) ) ; describe ( 's' , ( ) => { const attachments = new Attachments ( ) ; it ( 's' , ( ) => { const attachmentData = { type : 's' , 0 : [ 0 ] , data : 0 , } ; const attachmentId = attachments . uploadAttachment ( attachmentData ) ; expect ( attachmentId ) . toBe ( 's' ) ; const retrievedAttachment = attachments . getAttachmentData ( attachmentId ) ; expect ( retrievedAttachment ) . toEqual ( { ... attachmentData , id : attachmentId } ) ; } ) ; it ( 's' , ( ) => { const attachmentData = { data : 0 , } ; expect ( ( ) => attachments . uploadAttachment ( attachmentData ) ) . toThrow ( 's' ) ; } ) ; it ( 's' , ( ) => { const attachmentData = { data : 0 , type : 's' , } ; expect ( ( ) => attachments . uploadAttachment ( attachmentData ) ) . toThrow ( 's' ) ; } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $Attachments$ O O $any$ O O O $any$ O O O O O O O O $any$ O O $string$ O O O $number[]$ O O O O O $number$ O O O O O O $string$ O $Attachments$ O $string$ O $any$ O O $any$ O $string$ O O $any$ O O O O O $any$ O $Attachments$ O $any$ O $string$ O O $any$ O $any$ O O $any$ O O O $any$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $any$ O O O O $Attachments$ O $string$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O O $string$ O O O O O $any$ O O O O $Attachments$ O $string$ O $any$ O O O $any$ O O O O O O O O O O
import botDataKey from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let key = botDataKey ( 's' , 's' , 's' ) ; expect ( key ) . toBe ( 's' ) ; key = botDataKey ( 's' , 's' , 's' ) ; expect ( key ) . toBe ( 's' ) ; } ) ; } ) ;	O $string$ O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O O O O O $any$ O $string$ O O $any$ O O O O $string$ O $string$ O O O O O O O O $any$ O $string$ O O $any$ O O O O O O O O O O
import { URLSearchParams } from 's' ; import { authentication , usGovernmentAuthentication } from 's' ; import BotEndpoint from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const endpoint = new BotEndpoint ( ) ; const currentTime = Date . now ( ) ; endpoint . speechAuthenticationToken = { expireAt : currentTime + 0 , } as any ; expect ( ( endpoint as any ) . willTokenExpireWithin ( 0 ) ) . toBe ( true ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( 's' , 's' , 's' , 's' , 's' ) ; endpoint . speechAuthenticationToken = { accessToken : 's' , region : 's' , expireAt : Date . now ( ) + 0 * 0 * 0 , tokenLife : 0 * 0 * 0 , } ; const refresh = false ; const token = await endpoint . getSpeechToken ( refresh ) ; expect ( token ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( 's' , 's' , 's' , 's' , 's' ) ; endpoint . speechAuthenticationToken = { expireAt : Date . now ( ) - 0 , } as any ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( 's' ) ; const token = await endpoint . getSpeechToken ( ) ; expect ( token ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( 's' , 's' , 's' , 's' , 's' ) ; endpoint . speechAuthenticationToken = { expireAt : Date . now ( ) + 0 * 0 * 0 , tokenLife : 0 * 0 * 0 , } as any ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( 's' ) ; const token = await endpoint . getSpeechToken ( ) ; expect ( token ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( 's' , 's' , 's' , 's' , 's' ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( 's' ) ; const token = await endpoint . getSpeechToken ( true ) ; expect ( token ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; try { await endpoint . getSpeechToken ( ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { json : ( ) => Promise . resolve ( { access_Token : 's' , region : 's' , expireAt : 0 , tokenLife : 0 , } ) , status : 0 , } ) ; const token = await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( token ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { json : async ( ) => Promise . reject ( new Error ( 's' ) ) , status : 0 , } ) ; try { await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( `template` ) ) ; } } ) ; it ( `template` , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { json : ( ) => Promise . resolve ( { error : 's' } ) , status : 0 , } ) ; try { await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( `template` , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { json : ( ) => Promise . resolve ( { } ) , status : 0 , } ) ; try { await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( `template` , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { status : 0 , } ) ; try { await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( `template` , async ( ) => { const endpoint = new BotEndpoint ( ) ; jest . spyOn ( endpoint as any , 's' ) . mockResolvedValueOnce ( { status : 0 , } ) ; try { await ( endpoint as any ) . fetchSpeechToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( `template` ) ) ; } } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; endpoint . msaAppId = 's' ; const mockGetAccessToken = jest . fn ( ( ) => Promise . resolve ( 's' ) ) ; ( endpoint as any ) . getAccessToken = mockGetAccessToken ; const mockResponse = 's' ; const mockFetch = jest . fn ( ( ) => Promise . resolve ( mockResponse ) ) ; ( endpoint as any ) . _options = { fetch : mockFetch } ; const response = await endpoint . fetchWithAuth ( 's' ) ; expect ( response ) . toBe ( 's' ) ; expect ( mockGetAccessToken ) . toHaveBeenCalledWith ( false ) ; expect ( mockFetch ) . toHaveBeenCalledWith ( 's' , { headers : { Authorization : 's' } } ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; endpoint . msaAppId = 's' ; const mockGetAccessToken = jest . fn ( ( ) => Promise . resolve ( 's' ) ) ; ( endpoint as any ) . getAccessToken = mockGetAccessToken ; const mockResponse = 's' ; const mockFetch = jest . fn ( ) . mockImplementationOnce ( ( ) => Promise . resolve ( { status : 0 } ) ) . mockImplementationOnce ( ( ) => Promise . resolve ( mockResponse ) ) ; ( endpoint as any ) . _options = { fetch : mockFetch } ; const response = await endpoint . fetchWithAuth ( 's' ) ; expect ( response ) . toBe ( 's' ) ; expect ( mockGetAccessToken ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockGetAccessToken ) . toHaveBeenCalledWith ( true ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; endpoint . msaAppId = 's' ; const mockGetAccessToken = jest . fn ( ( ) => Promise . resolve ( 's' ) ) ; ( endpoint as any ) . getAccessToken = mockGetAccessToken ; const mockResponse = 's' ; const mockFetch = jest . fn ( ) . mockImplementationOnce ( ( ) => Promise . resolve ( { status : 0 } ) ) . mockImplementationOnce ( ( ) => Promise . resolve ( mockResponse ) ) ; ( endpoint as any ) . _options = { fetch : mockFetch } ; const response = await endpoint . fetchWithAuth ( 's' ) ; expect ( response ) . toBe ( 's' ) ; expect ( mockGetAccessToken ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockGetAccessToken ) . toHaveBeenCalledWith ( true ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; const msaAppId = 's' ; const msaPw = 's' ; endpoint . msaAppId = msaAppId ; endpoint . msaPassword = msaPw ; endpoint . 0 = false ; endpoint . channelService = undefined ; const tokenRefreshTime = 0 * 0 * 0 ; const accessTokenExpires = Date . now ( ) * 0 + tokenRefreshTime ; endpoint . accessTokenExpires = accessTokenExpires ; const mockOauthResponse = { access_token : 's' , expires_in : 0 } ; const mockResponse = { json : jest . fn ( ( ) => Promise . resolve ( mockOauthResponse ) ) , status : 0 } ; const mockFetch = jest . fn ( ( ) => Promise . resolve ( mockResponse ) ) ; ( endpoint as any ) . _options = { fetch : mockFetch } ; let response = await ( endpoint as any ) . getAccessToken ( ) ; expect ( response ) . toBe ( 's' ) ; expect ( endpoint . accessToken ) . toBe ( 's' ) ; expect ( endpoint . accessTokenExpires ) . not . toEqual ( accessTokenExpires ) ; expect ( endpoint . accessTokenExpires ) . toEqual ( jasmine . any ( Number ) ) ; expect ( mockFetch ) . toHaveBeenCalledWith ( authentication . tokenEndpoint , { method : 's' , body : new URLSearchParams ( { grant_type : 's' , client_id : msaAppId , client_secret : msaPw , scope : `template` , } as { [ key ] : string } ) . toString ( ) , headers : { 's' : 's' , } , } ) ; endpoint . 0 = true ; endpoint . channelService = usGovernmentAuthentication . channelService ; response = await ( endpoint as any ) . getAccessToken ( ) ; expect ( response ) . toBe ( 's' ) ; expect ( endpoint . accessToken ) . toBe ( 's' ) ; expect ( endpoint . accessTokenExpires ) . not . toEqual ( accessTokenExpires ) ; expect ( endpoint . accessTokenExpires ) . toEqual ( jasmine . any ( Number ) ) ; expect ( mockFetch ) . toHaveBeenCalledWith ( usGovernmentAuthentication . tokenEndpoint , { method : 's' , body : new URLSearchParams ( { grant_type : 's' , client_id : msaAppId , client_secret : msaPw , scope : `template` , atver : 's' , } as { [ key ] : string } ) . toString ( ) , headers : { 's' : 's' , } , } ) ; } ) ; it ( 's' , async ( ) => { const endpoint = new BotEndpoint ( ) ; const msaAppId = 's' ; const msaPw = 's' ; endpoint . msaAppId = msaAppId ; endpoint . msaPassword = msaPw ; endpoint . 0 = false ; endpoint . channelService = undefined ; const tokenRefreshTime = 0 * 0 * 0 ; const accessTokenExpires = Date . now ( ) * 0 + tokenRefreshTime ; endpoint . accessTokenExpires = accessTokenExpires ; const mockResponse = { status : 0 } ; const mockFetch = jest . fn ( ( ) => Promise . resolve ( mockResponse ) ) ; ( endpoint as any ) . _options = { fetch : mockFetch } ; try { await ( endpoint as any ) . getAccessToken ( ) ; expect ( false ) . toBe ( true ) ; } catch ( e ) { expect ( e ) . toEqual ( { body : undefined , message : 's' , status : 0 } ) ; } } ) ; } ) ;	O O $any$ O O O O O O $complex$ O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $BotEndpoint$ O O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O $BotEndpoint$ O $any$ O O $number$ O $number$ O O O O O O O $any$ O O $BotEndpoint$ O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O $BotEndpoint$ O $any$ O O $string$ O O O $string$ O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $number$ O O O O O O O O O O $false$ O O O O $string$ O O $BotEndpoint$ O $Promise<string>$ O $false$ O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O $BotEndpoint$ O $any$ O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O O O O $string$ O O $BotEndpoint$ O $Promise<string>$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O $BotEndpoint$ O $any$ O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $number$ O O O O O O O O O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O O O O $string$ O O $BotEndpoint$ O $Promise<string>$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O O O O $string$ O O $BotEndpoint$ O $Promise<string>$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O $BotEndpoint$ O $Promise<string>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O O O O $number$ O O O O O O O $any$ O O O $BotEndpoint$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $Promise<never>$ O O O O O $PromiseConstructor$ O $Promise<T>$ O O $ErrorConstructor$ O O O O O $number$ O O O O O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O $number$ O O O O O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $Promise<{}>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $number$ O O O O O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $number$ O O O O O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $any$ O $any$ O $BotEndpoint$ O O O O O O $any$ O O $number$ O O O O O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $BotEndpoint$ O $string$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O O $any$ O $any$ O O O $any$ O O $BotEndpoint$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $complex$ O O $string$ O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $BotEndpoint$ O $string$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O $number$ O O O O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O O $any$ O $any$ O O O $any$ O O $BotEndpoint$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O $BotEndpoint$ O $string$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O $number$ O O O O O O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $BotEndpoint$ O O O O $any$ O O $any$ O $any$ O O O $any$ O O $BotEndpoint$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O $BotEndpoint$ O $string$ O O O $BotEndpoint$ O $string$ O O O $BotEndpoint$ O $boolean$ O O O $BotEndpoint$ O $string$ O $undefined$ O O $number$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O $number$ O $BotEndpoint$ O $number$ O $number$ O O $complex$ O O $string$ O O O $number$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $complex$ O O O $number$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $complex$ O O O O $BotEndpoint$ O O O O $any$ O O $any$ O $any$ O O O $any$ O O O $BotEndpoint$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $BotEndpoint$ O $string$ O O $any$ O O O O $any$ O $BotEndpoint$ O $number$ O O $any$ O $any$ O $number$ O O $any$ O $BotEndpoint$ O $number$ O O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $any$ O $any$ O O $any$ O $complex$ O $string$ O O $string$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O $any$ O O O $complex$ O O O O O O O O O O O $BotEndpoint$ O $boolean$ O O O $BotEndpoint$ O $string$ O O O $string$ O $any$ O O O $BotEndpoint$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $BotEndpoint$ O $string$ O O $any$ O O O O $any$ O $BotEndpoint$ O $number$ O O $any$ O $any$ O $number$ O O $any$ O $BotEndpoint$ O $number$ O O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $any$ O $any$ O O $any$ O O O $string$ O O $string$ O O O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O $any$ O O O $complex$ O O O O O O O O O O O O O O $any$ O O O O O O O O O $BotEndpoint$ O O $any$ O O O O O O O O O O O O O $BotEndpoint$ O $string$ O O O $BotEndpoint$ O $string$ O O O $BotEndpoint$ O $boolean$ O O O $BotEndpoint$ O $string$ O $undefined$ O O $number$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O $number$ O $BotEndpoint$ O $number$ O $number$ O O $complex$ O O $number$ O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $complex$ O O O O $BotEndpoint$ O O O O $any$ O O $any$ O $any$ O O O O O O $BotEndpoint$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $undefined$ O $undefined$ O $string$ O O O $number$ O O O O O O O O O O O O
import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import createAPIException from 's' ; import BotState from 's' ; import botDataKey from 's' ; let mockApproximatedObjectSize ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => mockApproximatedObjectSize ) ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { mockApproximatedObjectSize = 0 ; } ) ; it ( 's' , ( ) => { const channelId = 's' ; const convoId = 's' ; const userId = 's' ; const dataKey = botDataKey ( channelId , convoId , userId ) ; const botData = { data : 's' } ; const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const botState = new BotState ( null , null ) ; ( botState as any ) . botDataStore = { [ dataKey ] : botData } ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; const data = botState . getBotData ( channelId , convoId , userId ) ; expect ( data ) . toBe ( botData ) ; expect ( mockLogDeprecationWarning ) . toHaveBeenCalledWith ( convoId ) ; } ) ; it ( 's' , ( ) => { const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const botState = new BotState ( null , null ) ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; const data = botState . getBotData ( 's' , 's' , 's' ) ; expect ( data ) . toEqual ( { data : null , eTag : 's' } ) ; } ) ; it ( 's' , ( ) => { const channelId = 's' ; const convoId = 's' ; const userId = 's' ; const dataKey = botDataKey ( channelId , convoId , userId ) ; const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const botState = new BotState ( null , null ) ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; const botData = { data : 's' } ; const data = botState . setBotData ( channelId , convoId , userId , botData ) ; expect ( mockLogDeprecationWarning ) . toHaveBeenCalledWith ( convoId ) ; expect ( data . eTag ) . toEqual ( jasmine . any ( String ) ) ; expect ( data . data ) . toBe ( botData . data ) ; expect ( ( botState as any ) . botDataStore [ dataKey ] ) . toBe ( data ) ; } ) ; it ( 's' , ( ) => { const channelId = 's' ; const convoId = 's' ; const userId = 's' ; const dataKey = botDataKey ( channelId , convoId , userId ) ; const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const botData = { data : null } ; const botState = new BotState ( null , null ) ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; ( botState as any ) . botDataStore [ dataKey ] = botData ; expect ( ( botState as any ) . botDataStore [ dataKey ] ) . toBe ( botData ) ; const data = botState . setBotData ( channelId , convoId , userId , botData ) ; expect ( mockLogDeprecationWarning ) . toHaveBeenCalledWith ( convoId ) ; expect ( data . eTag ) . toBe ( 's' ) ; expect ( data . data ) . toBe ( null ) ; expect ( ( botState as any ) . botDataStore [ dataKey ] ) . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const channelId = 's' ; const convoId = 's' ; const userId = 's' ; const dataKey = botDataKey ( channelId , convoId , userId ) ; const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const oldBotData = { data : 's' , eTag : 's' } ; const newBotData = { data : 's' , eTag : 's' } ; const botState = new BotState ( null , null ) ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; ( botState as any ) . botDataStore [ dataKey ] = oldBotData ; try { botState . setBotData ( channelId , convoId , userId , newBotData ) ; } catch ( e ) { expect ( e ) . toEqual ( createAPIException ( HttpStatus . PRECONDITION_FAILED , ErrorCodes . BadArgument , 's' ) ) ; } } ) ; it ( 's' , ( ) => { const mockLogDeprecationWarning = jest . fn ( ( ) => null ) ; const botState = new BotState ( null , null ) ; mockApproximatedObjectSize = 0 ; botState . stateSizeLimitKB = 0 ; ( botState as any ) . logBotStateApiDeprecationWarning = mockLogDeprecationWarning ; const botData = { data : 's' } ; try { botState . setBotData ( 's' , 's' , 's' , botData ) ; } catch ( e ) { expect ( e ) . toEqual ( createAPIException ( HttpStatus . BAD_REQUEST , ErrorCodes . MessageSizeTooBig , 's' ) ) ; } } ) ; it ( 's' , ( ) => { const userId = 's' ; const 0 = botDataKey ( 's' , 's' , userId ) ; const 0 = botDataKey ( 's' , 's' , userId ) ; const 0 = { data : 's' } ; const 0 = { data : 's' } ; const botState = new BotState ( null , null ) ; ( botState as any ) . botDataStore = { [ 0 ] : 0 , [ 0 ] : 0 , } ; expect ( Object . keys ( ( botState as any ) . botDataStore ) ) . toHaveLength ( 0 ) ; botState . deleteBotData ( userId ) ; expect ( Object . keys ( ( botState as any ) . botDataStore ) ) . toHaveLength ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $complex$ O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O O O $string$ O O $complex$ O O O $BotState$ O O O O $any$ O $any$ O O $any$ O $BotState$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O $any$ O O $any$ O $BotState$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O $null$ O O O $string$ O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O $any$ O $BotState$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $BotState$ O O O O $any$ O $string$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $null$ O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O $any$ O O $BotState$ O O O O $any$ O $string$ O O $any$ O $any$ O O $BotState$ O O O O $any$ O $string$ O O O $any$ O $any$ O O O $any$ O $BotState$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $BotState$ O O O O $any$ O $string$ O O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O O $string$ O O O $string$ O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O $any$ O O $BotState$ O O O O $any$ O $string$ O O $any$ O O O $BotState$ O $any$ O O O O O O O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $BotState$ O O $any$ O O O O O O $any$ O O O $BotState$ O $number$ O O O O $BotState$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O $BotState$ O $any$ O O O O O O O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $string$ O $string$ O O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $BotState$ O O $any$ O O O O O O O $BotState$ O O O O $any$ O O O $string$ O O $complex$ O O $string$ O O $complex$ O O O $any$ O $ObjectConstructor$ O $complex$ O O $BotState$ O O O O $any$ O O O $any$ O O O O $BotState$ O $void$ O O O O $any$ O $ObjectConstructor$ O $complex$ O O $BotState$ O O O O $any$ O O O $any$ O O O O O O O O O O
import { LogLevel } from 's' ; import log from 's' ; import ConsoleLogService from 's' ; jest . mock ( 's' , ( ) => ( { error : jest . fn ( ( ) => null ) , info : jest . fn ( ( ) => null ) , warn : jest . fn ( ( ) => null ) , silly : jest . fn ( ( ) => null ) , } ) ) ; describe ( 's' , ( ) => { const errorSpy = jest . spyOn ( log , 's' ) ; const infoSpy = jest . spyOn ( log , 's' ) ; const warnSpy = jest . spyOn ( log , 's' ) ; const sillySpy = jest . spyOn ( log , 's' ) ; beforeEach ( ( ) => { errorSpy . mockClear ( ) ; infoSpy . mockClear ( ) ; warnSpy . mockClear ( ) ; sillySpy . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const messages = [ { type : 's' , payload : { level : LogLevel . Debug , text : 's' } } , { type : 's' , payload : { level : LogLevel . Error , text : 's' } } , { type : 's' , payload : { level : LogLevel . Info , text : 's' } } , { type : 's' , payload : { level : LogLevel . Warn , text : 's' } } , { type : undefined } , ] ; const consoleLogService = new ConsoleLogService ( ) ; consoleLogService . logToChat ( conversationId , ... messages ) ; expect ( errorSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( errorSpy ) . toHaveBeenCalledWith ( conversationId , 's' ) ; expect ( infoSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( infoSpy ) . toHaveBeenCalledWith ( conversationId , 's' ) ; expect ( warnSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( warnSpy ) . toHaveBeenCalledWith ( conversationId , 's' ) ; expect ( sillySpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( sillySpy ) . toHaveBeenCalledWith ( conversationId , 's' ) ; } ) ; it ( 's' , ( ) => { const messages = [ { type : 's' , payload : { level : LogLevel . Debug , text : 's' } } , { type : 's' , payload : { level : LogLevel . Error , text : 's' } } , { type : 's' , payload : { level : LogLevel . Info , text : 's' } } , { type : 's' , payload : { level : LogLevel . Warn , text : 's' } } , { type : undefined } , ] ; const consoleLogService = new ConsoleLogService ( ) ; consoleLogService . logToChat ( undefined , ... messages ) ; expect ( errorSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( errorSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( infoSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( infoSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( warnSpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( warnSpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; expect ( sillySpy ) . toHaveBeenCalledTimes ( 0 ) ; expect ( sillySpy ) . toHaveBeenCalledWith ( 's' , 's' ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $undefined$ O $undefined$ O O O O O $ConsoleLogService$ O O $any$ O O O $ConsoleLogService$ O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $undefined$ O $undefined$ O O O O O $ConsoleLogService$ O O $any$ O O O $ConsoleLogService$ O $void$ O $undefined$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O
import { BotEmulator } from 's' ; import BotEndpoint from 's' ; import Conversation from 's' ; const mockTranscript = [ { type : 's' , activity : { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] , channelId : 's' , conversation : { id : 's' , } , id : 's' , localTimestamp : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , timestamp : 's' , from : { id : 's' , name : 's' , } , locale : 's' , serviceUrl : 's' , } , } , { type : 's' , activity : { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , locale : 's' , } , } , { type : 's' , activity : { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , role : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : 's' , localTimestamp : 's' , timestamp : 's' , locale : 's' , } , } , ] ; const mockActivity = { type : 's' , membersAdded : [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] , } ; const mockUserActivity = { type : 's' , serviceUrl : 's' , channelId : 's' , from : { id : 's' , name : 's' , role : 's' , } , conversation : { id : 's' , } , recipient : { id : 's' , name : 's' , } , text : 's' , inputHint : 's' , replyToId : 's' , id : null , } ; describe ( 's' , ( ) => { let botEndpointBotId ; let botEndpoint ; let botEmulator ; let conversation ; let conversationId ; let user ; const fetch = ( function ( ) { const fetch = ( ) => { return { ok : true , json : async ( ) => ( { } ) , text : async ( ) => 's' , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch as any ; } ) ( ) ; beforeEach ( ( ) => { botEndpointBotId = 's' ; botEndpoint = new BotEndpoint ( 's' , botEndpointBotId , 's' , null , null , null , null , { fetch } ) ; botEmulator = new BotEmulator ( async ( ) => 's' , { fetch , loggerOrLogService : { logMessage : async ( ) => true , logActivity : async ( ) => true , } as any , } ) ; conversationId = 's' ; user = { id : 's' } ; conversation = new Conversation ( botEmulator , botEndpoint , conversationId , user ) ; } ) ; it ( 's' , ( ) => { const mockProcessActivity = jest . fn ( activity => ( { ... activity , processed : true , } ) ) ; conversation . processActivity = mockProcessActivity ; const fedActivities = [ ] ; const mockAddActivityToQueue = jest . fn ( activity => { fedActivities . push ( activity ) ; } ) ; ( conversation as any ) . addActivityToQueue = mockAddActivityToQueue ; const activities = [ { conversation : { } , type : 's' , from : { role : 's' } , recipient : { role : 's' , id : 's' } , } , { conversation : { } , type : 's' , from : { role : 's' } , recipient : { role : 's' , id : 's' } , } , { conversation : { } , type : 's' , from : { role : 's' , id : 's' } , recipient : { role : 's' } , } , { conversation : { } , type : 's' , from : { role : 's' , id : 's' } , recipient : { role : 's' } , } , ] ; conversation . feedActivities ( activities ) ; expect ( fedActivities ) . toEqual ( [ { conversation : { id : 's' } , type : 's' , from : { role : 's' } , recipient : { role : 's' , id : 's' } , processed : true , } , { conversation : { id : 's' } , type : 's' , from : { role : 's' } , recipient : { role : 's' , id : 's' } , } , { conversation : { id : 's' } , type : 's' , from : { role : 's' , id : 's' } , recipient : { role : 's' } , processed : true , } , { conversation : { id : 's' } , type : 's' , from : { role : 's' , id : 's' } , recipient : { role : 's' } , } , ] ) ; } ) ; it ( 's' , async ( ) => { ( conversation as any ) . transcript = mockTranscript ; const transcripts = await conversation . getTranscript ( ) ; expect ( transcripts . length ) . toBe ( 0 ) ; let i = transcripts . length ; while ( i -- ) { expect ( transcripts [ i ] ) . toEqual ( mockTranscript [ i ] . activity ) ; } } ) ; it ( 's' , async ( ) => { const result = await conversation . postActivityToBot ( mockActivity , true ) ; expect ( result . activityId ) . toEqual ( jasmine . any ( String ) ) ; } ) ; it ( 's' , async ( ) => { await conversation . postActivityToBot ( mockActivity , true ) ; const spy = jest . spyOn ( conversation , 's' ) . mockResolvedValueOnce ( { response : { status : 0 , } , statusCode : 0 , } ) ; await conversation . sendConversationUpdate ( mockActivity . membersAdded , mockActivity . membersAdded ) ; expect ( spy ) . toHaveBeenCalledWith ( { membersAdded : [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] , membersRemoved : [ { id : 's' , name : 's' } , { id : 's' , name : 's' } ] , type : 's' , } , false ) ; } ) ; it ( 's' , async ( ) => { const activity = await conversation . postActivityToUser ( mockUserActivity ) ; expect ( activity ) . toEqual ( { id : jasmine . any ( String ) , } ) ; } ) ; it ( 's' , async ( ) => { let result = await conversation . postActivityToBot ( mockActivity , true ) ; const updatedActivity = { id : result . activityId , test : 's' } ; result = await conversation . updateActivity ( updatedActivity ) ; expect ( result . id ) . toBe ( updatedActivity . id ) ; } ) ; it ( 's' , async ( ) => { const result = await conversation . postActivityToBot ( mockActivity , true ) ; let activityDeleted = false ; conversation . on ( 's' , ( ) => ( activityDeleted = true ) ) ; await conversation . deleteActivity ( result . activityId ) ; expect ( activityDeleted ) . toBeTruthy ( ) ; } ) ; it ( 's' , async ( ) => { await conversation . sendContactRemoved ( ) ; expect ( ( conversation as any ) . transcript [ 0 ] . activity . action ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { await conversation . sendTyping ( ) ; expect ( ( conversation as any ) . transcript [ 0 ] . activity . type ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { await conversation . sendPing ( ) ; expect ( ( conversation as any ) . transcript [ 0 ] . activity . type ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { } ) ; } ) ;	O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $null$ O O O O O $any$ O O O O O O O O $any$ O O $any$ O O $any$ O O $Conversation$ O O $any$ O O $any$ O O $any$ O O O O O O O $complex$ O O O O O O O $boolean$ O O O $Promise<{}>$ O O O O O O O O O O $Promise<string>$ O O O O O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O O O O O $any$ O O O O O $any$ O O O $any$ O O $any$ O O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O $Promise<boolean>$ O O O O O O O $Promise<boolean>$ O O O O O O O O O O O O O O $any$ O O O $any$ O O $string$ O O O O $Conversation$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $boolean$ O O O O O O O $Conversation$ O $any$ O $any$ O O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O O O O $Conversation$ O O O O $any$ O $any$ O O $any$ O O O ${}$ O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O ${}$ O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O ${}$ O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O O ${}$ O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O O O $Conversation$ O $void$ O $any$ O O $any$ O $any[]$ O O $any$ O O O $complex$ O O $string$ O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $boolean$ O O O O O O $complex$ O O $string$ O O O O $string$ O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O $boolean$ O O O O O O $complex$ O O $string$ O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O O O O O O O O O O $any$ O O O O O O O O O $Conversation$ O O O O $any$ O O O O $any[]$ O O $Conversation$ O $Promise<any[]>$ O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O $number$ O $any[]$ O $number$ O O O $number$ O O O $any$ O $any[]$ O $number$ O O O $any$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Conversation$ O $Promise<any>$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O $any$ O O O O O O O O O $Conversation$ O $Promise<any>$ O $complex$ O O O O O $any$ O $any$ O $any$ O $Conversation$ O O O O $any$ O O $complex$ O O $number$ O O O O O $number$ O O O O O O O $Conversation$ O $Promise<void>$ O $complex$ O $complex$ O $complex$ O $complex$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Conversation$ O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Conversation$ O $Promise<any>$ O $complex$ O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O $Conversation$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $complex$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O $Conversation$ O $Promise<any>$ O $complex$ O O O O O $boolean$ O O O $Conversation$ O $any$ O O O O O O O $boolean$ O O O O O O $Conversation$ O $void$ O $any$ O $any$ O O $any$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O O $Conversation$ O $Promise<void>$ O O O $any$ O O $Conversation$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Conversation$ O $Promise<void>$ O O O $any$ O O $Conversation$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Conversation$ O $Promise<void>$ O O O $any$ O O $Conversation$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O
import ConversationSet from 's' ; describe ( 's' , ( ) => { let conversationSet ; beforeEach ( ( ) => { conversationSet = new ConversationSet ( ) ; } ) ; it ( 's' , ( ) => { const conversation = conversationSet . newConversation ( { } as any , { botId : 's' } as any , { id : 's' , name : 's' } , 's' ) ; expect ( conversation . conversationId ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const conversation = conversationSet . newConversation ( { } as any , { botId : 's' } as any , { id : 's' , name : 's' } , 's' ) ; expect ( conversation . conversationId ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const conversation = conversationSet . newConversation ( { } as any , { botId : 's' } as any , { id : 's' , name : 's' } , 's' ) ; expect ( conversationSet . conversationById ( 's' ) ) . toBe ( conversation ) ; } ) ; it ( 's' , ( ) => { conversationSet . newConversation ( { } as any , { botId : 's' } as any , { id : 's' , name : 's' } , 's' ) ; conversationSet . newConversation ( { } as any , { botId : 's' } as any , { id : 's' , name : 's' } , 's' ) ; const conversations = conversationSet . getConversationIds ( ) ; expect ( conversations ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O O $ConversationSet$ O $any$ O O O O O $ConversationSet$ O O $any$ O O O O O O $any$ O O O O O O O O $Conversation$ O $ConversationSet$ O $Conversation$ O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O $any$ O $Conversation$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $Conversation$ O $ConversationSet$ O $Conversation$ O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O $any$ O $Conversation$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $Conversation$ O $ConversationSet$ O $Conversation$ O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O $any$ O $ConversationSet$ O $Conversation$ O O O O O $any$ O $Conversation$ O O O O O $any$ O O O O O O O $ConversationSet$ O $Conversation$ O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O $ConversationSet$ O $Conversation$ O O O O O O O $string$ O O O O O O O $string$ O O O $string$ O O O O O O O O $string[]$ O $ConversationSet$ O $string[]$ O O O $any$ O $string[]$ O O $any$ O O O O O O O O O O O O O O
import Endpoints from 's' ; import BotEndpoint from 's' ; const mockId = 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => mockId ) ) ; let mockDecodedToken ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => mockDecodedToken ) ) ; describe ( 's' , ( ) => { let endpoints ; const mockFetch = jest . fn ( ( ) => null ) ; beforeEach ( ( ) => { const options = { fetch : mockFetch , } ; endpoints = new Endpoints ( options ) ; mockDecodedToken = { endpointId : 's' } ; } ) ; it ( 's' , ( ) => { const id = 's' ; const botEndpoint = { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , 0 : false , channelService : undefined , } ; let pushedEndpoint = endpoints . push ( id , botEndpoint ) ; expect ( pushedEndpoint ) . toEqual ( new BotEndpoint ( id , botEndpoint . botId , botEndpoint . botUrl , botEndpoint . msaAppId , botEndpoint . msaPassword , botEndpoint . 0 , botEndpoint . channelService , { fetch : mockFetch , } ) ) ; expect ( ( endpoints as any ) . _endpoints [ id ] ) . toEqual ( pushedEndpoint ) ; pushedEndpoint = endpoints . push ( 's' , botEndpoint ) ; expect ( pushedEndpoint ) . toEqual ( new BotEndpoint ( botEndpoint . botUrl , botEndpoint . botId , botEndpoint . botUrl , botEndpoint . msaAppId , botEndpoint . msaPassword , botEndpoint . 0 , botEndpoint . channelService , { fetch : mockFetch , } ) ) ; expect ( ( endpoints as any ) . _endpoints [ botEndpoint . botUrl ] ) . toEqual ( pushedEndpoint ) ; botEndpoint . botUrl = 's' ; pushedEndpoint = endpoints . push ( 's' , botEndpoint ) ; expect ( pushedEndpoint ) . toEqual ( new BotEndpoint ( mockId , botEndpoint . botId , botEndpoint . botUrl , botEndpoint . msaAppId , botEndpoint . msaPassword , botEndpoint . 0 , botEndpoint . channelService , { fetch : mockFetch , } ) ) ; expect ( ( endpoints as any ) . _endpoints [ mockId ] ) . toEqual ( pushedEndpoint ) ; } ) ; it ( 's' , ( ) => { const endpoint = { botUrl : 's' } ; ( endpoints as any ) . _endpoints [ 's' ] = endpoint ; expect ( ( endpoints as any ) . _endpoints [ 's' ] ) . toBe ( endpoint ) ; endpoints . reset ( ) ; expect ( ( endpoints as any ) . _endpoints [ 's' ] ) . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const 0 = { botUrl : 's' } ; const 0 = { botUrl : 's' } ; ( endpoints as any ) . _endpoints [ 's' ] = 0 ; ( endpoints as any ) . _endpoints [ 's' ] = 0 ; expect ( endpoints . getDefault ( ) ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const endpoint = { botUrl : 's' } ; ( endpoints as any ) . _endpoints [ 's' ] = endpoint ; expect ( endpoints . get ( 's' ) ) . toBe ( endpoint ) ; } ) ; it ( 's' , ( ) => { const endpoint = { botUrl : 's' } ; ( endpoints as any ) . _endpoints [ 's' ] = endpoint ; expect ( endpoints . get ( 's' ) ) . toBe ( endpoint ) ; } ) ; it ( 's' , ( ) => { mockDecodedToken = { } ; expect ( endpoints . get ( 's' ) ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const endpoint = { botUrl : 's' , msaAppId : 's' } ; ( endpoints as any ) . _endpoints [ 's' ] = endpoint ; expect ( endpoints . getByAppId ( 's' ) ) . toBe ( endpoint ) ; } ) ; it ( 's' , ( ) => { const 0 = { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , 0 : 's' , } ; const 0 = { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , 0 : 's' , } ; const 0 = { botId : 's' , botUrl : 's' , msaAppId : 's' , msaPassword : 's' , 0 : 's' , } ; ( endpoints as any ) . _endpoints [ 's' ] = 0 ; ( endpoints as any ) . _endpoints [ 's' ] = 0 ; ( endpoints as any ) . _endpoints [ 's' ] = 0 ; expect ( endpoints . getAll ( ) ) . toEqual ( { 0 : 0 , 0 : 0 , 0 : 0 , } ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O O $Endpoints$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $Endpoints$ O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $undefined$ O $undefined$ O O O O $BotEndpoint$ O $Endpoints$ O $BotEndpoint$ O O O O O O $any$ O $BotEndpoint$ O O $any$ O O $any$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $Endpoints$ O O O O $any$ O O O O O $any$ O $BotEndpoint$ O O $BotEndpoint$ O $Endpoints$ O $BotEndpoint$ O O O O O O $any$ O $BotEndpoint$ O O $any$ O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $Endpoints$ O O O O $any$ O O O $string$ O O O $any$ O $BotEndpoint$ O O O O $string$ O O O $BotEndpoint$ O $Endpoints$ O $BotEndpoint$ O O O O O O $any$ O $BotEndpoint$ O O $any$ O O $any$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $Endpoints$ O O O O $any$ O O O O O $any$ O $BotEndpoint$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $Endpoints$ O O O O $any$ O O O O $complex$ O $any$ O O $Endpoints$ O O O O $any$ O O O O O $any$ O $complex$ O O $Endpoints$ O $void$ O O O $any$ O O $Endpoints$ O O O O $any$ O O O O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $Endpoints$ O O O O $any$ O O O O $complex$ O O $Endpoints$ O O O O $any$ O O O O $complex$ O $any$ O $Endpoints$ O $BotEndpoint$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $Endpoints$ O O O O $any$ O O O O $complex$ O $any$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $Endpoints$ O O O O $any$ O O O O $complex$ O $any$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $Endpoints$ O O O O $any$ O O O O $complex$ O $any$ O $Endpoints$ O $BotEndpoint$ O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $Endpoints$ O O O O $any$ O O O O O O O $Endpoints$ O O O O $any$ O O O O O O O $Endpoints$ O O O O $any$ O O O O O O $any$ O $Endpoints$ O $complex$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O
import { exceptionItem , inspectableObjectItem , LogLevel , summaryTextItem , textItem } from 's' ; import { Activity , ActivityTypes } from 's' ; import { LogItem } from 's' ; import LoggerAdapter from 's' ; describe ( 's' , ( ) => { const mockLogToChat = jest . fn ( ( ) => null ) ; const logService = { logToChat : mockLogToChat , } ; let loggerAdapter ; beforeEach ( ( ) => { loggerAdapter = new LoggerAdapter ( logService ) ; mockLogToChat . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const activity = { type : 's' , text : 's' , } ; loggerAdapter . logActivity ( conversationId , activity , 's' ) ; expect ( mockLogToChat ) . toHaveBeenCalledWith ( conversationId , textItem ( LogLevel . Debug , 's' ) , inspectableObjectItem ( activity . type , activity ) , summaryTextItem ( activity ) ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const activity = { type : 's' , text : 's' , } ; loggerAdapter . logActivity ( conversationId , activity , 's' ) ; expect ( mockLogToChat ) . toHaveBeenCalledWith ( conversationId , textItem ( LogLevel . Debug , 's' ) , inspectableObjectItem ( activity . type , activity ) , summaryTextItem ( activity ) ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const messages = [ { type : 's' , payload : { text : 's' } } ] ; loggerAdapter . logMessage ( conversationId , ... messages ) ; expect ( mockLogToChat ) . toHaveBeenCalledWith ( conversationId , ... messages ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const error = new Error ( 's' ) ; loggerAdapter . logException ( conversationId , error ) ; expect ( mockLogToChat ) . toHaveBeenCalledWith ( conversationId , exceptionItem ( error ) ) ; } ) ; it ( 's' , ( ) => { const conversationId = 's' ; const activity = { id : 's' , label : 's' , type : ActivityTypes . Trace , value : { type : ActivityTypes . Message , from : { role : 's' } , text : 's' , } , } as Activity ; const logItems : LogItem [ ] = [ textItem ( LogLevel . Debug , 's' ) , inspectableObjectItem ( activity . type , activity ) , summaryTextItem ( activity ) , textItem ( LogLevel . Debug , 's' ) , inspectableObjectItem ( activity . value . type , activity . value ) , summaryTextItem ( activity . value ) , ] ; loggerAdapter . logActivity ( conversationId , activity , 's' ) ; expect ( mockLogToChat ) . toHaveBeenCalledWith ( conversationId , ... logItems ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O $LoggerAdapter$ O $any$ O O O O O $LoggerAdapter$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $LoggerAdapter$ O $void$ O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $LoggerAdapter$ O $void$ O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O O O O $LoggerAdapter$ O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O $LoggerAdapter$ O $void$ O O O $Error$ O O $any$ O $any$ O O $any$ O O O $any$ O $Error$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $complex$ O O $string$ O O O O $string$ O O O O O O O $any$ O O $any[]$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $LoggerAdapter$ O $void$ O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any[]$ O O O O O O O O
import Users from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const users = new Users ( ) ; expect ( users . currentUserId ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const user = { data : 's' } ; const users = new Users ( ) ; users . users = { 0 : user } ; const retrievedUser = users . usersById ( 's' ) ; expect ( retrievedUser ) . toBe ( user ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $Users$ O O $any$ O O O $any$ O $Users$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $Users$ O O $any$ O O O $Users$ O $complex$ O O $any$ O $any$ O O O $any$ O $Users$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import Endpoints from 's' ; import getBotEndpoint from 's' ; describe ( 's' , ( ) => { const mockEmulator = { facilities : { } , } as any ; const mockNext = function ( ) { return null ; } ; mockNext . ifError = function ( ) { return null ; } ; beforeEach ( ( ) => { mockEmulator . facilities . endpoints = new Endpoints ( { } ) ; } ) ; it ( 's' , ( ) => { const mockToken = 's' ; const mockEndpoint = { id : mockToken } as any ; const mockReq = { header : ( ) => `template` , } as any ; mockEmulator . facilities . endpoints . push ( mockToken , mockEndpoint ) ; const route = getBotEndpoint ( mockEmulator as any ) ; route ( mockReq as any , { } as any , mockNext ) ; expect ( mockReq . botEndpoint . id ) . toBe ( mockEndpoint . id ) ; } ) ; it ( 's' , ( ) => { const mockEndpoint = { id : 's' } as any ; mockEmulator . facilities . endpoints . push ( 's' , mockEndpoint ) ; const mockReq = { header : ( ) => 's' , } as any ; const route = getBotEndpoint ( mockEmulator as any ) ; route ( mockReq , { } as any , mockNext ) ; expect ( mockReq . botEndpoint . id ) . toBe ( mockEndpoint . id ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O O ${}$ O O O O O O O O O $complex$ O O O O O O O O O O $complex$ O $any$ O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O $string$ O O O O O O O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O
import getFacility from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const facility = 's' ; const req = { } ; const res = { } ; const next = jest . fn ( ( ) => null ) ; const middleware = getFacility ( facility ) ; middleware ( req , res , next ) ; expect ( req . facility ) . toEqual ( facility ) ; expect ( next ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O
import getRouteName from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const routeName = 's' ; const req = { } ; const res = { } ; const next = jest . fn ( ( ) => null ) ; const middleware = getRouteName ( routeName ) ; middleware ( req , res , next ) ; expect ( req . routeName ) . toEqual ( routeName ) ; expect ( next ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O
import getFacility from 's' ; import getRouteName from 's' ; import getSessionId from 's' ; import registerRoutes from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const server = { get , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const facility = getFacility ( 's' ) ; registerRoutes ( emulator , server , uses ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , facility , getRouteName ( 's' ) , getSessionId ( emulator ) ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , jasmine . any ( Function ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $FunctionConstructor$ O O O O O O O O O
import getBotEndpoint from 's' ; import getFacility from 's' ; import getRouteName from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; import createJsonBodyParserMiddleware from 's' ; import emulateOAuthCards from 's' ; import getToken from 's' ; import signOut from 's' ; import tokenResponse from 's' ; import registerRoutes from 's' ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( ) => null ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const get = jest . fn ( ( ) => null ) ; const post = jest . fn ( ( ) => null ) ; const del = jest . fn ( ( ) => null ) ; const server = { get , post , del , } ; const uses = [ ] ; const emulator = { options : { fetch : ( ) => null } , } ; const jsonBodyParser = createJsonBodyParserMiddleware ( ) ; const verifyBotFramework = createBotFrameworkAuthenticationMiddleware ( emulator . options . fetch ) ; const botEndpoint = getBotEndpoint ( emulator ) ; const facility = getFacility ( 's' ) ; registerRoutes ( emulator , server , uses ) ; expect ( get ) . toHaveBeenCalledWith ( 's' , verifyBotFramework , botEndpoint , facility , getRouteName ( 's' ) , getToken ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , verifyBotFramework , facility , getRouteName ( 's' ) , emulateOAuthCards ( emulator ) ) ; expect ( del ) . toHaveBeenCalledWith ( 's' , verifyBotFramework , botEndpoint , facility , getRouteName ( 's' ) , signOut ( emulator ) ) ; expect ( post ) . toHaveBeenCalledWith ( 's' , ... uses , jsonBodyParser , facility , getRouteName ( 's' ) , tokenResponse ( emulator ) ) ; } ) ; } ) ;	O $any$ O O O O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O O $complex$ O O $any$ O O O O O O O O O O $any[]$ O $any[]$ O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $any$ O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $Promise<void>$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $any[]$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O
import { TokenCache } from 's' ; describe ( 's' , ( ) => { const botId = 's' ; const userId = 's' ; const connectionName = 's' ; const token = 's' ; const tokenKey = `template` ; beforeEach ( ( ) => { ( TokenCache as any ) . tokenStore = { } ; } ) ; it ( 's' , ( ) => { TokenCache . addTokenToCache ( botId , userId , connectionName , token ) ; expect ( ( TokenCache as any ) . tokenStore [ tokenKey ] ) . toEqual ( { connectionName , token , } ) ; } ) ; it ( 's' , ( ) => { const tokenEntry = { connectionName , token } ; ( TokenCache as any ) . tokenStore [ tokenKey ] = tokenEntry ; TokenCache . deleteTokenFromCache ( botId , userId , connectionName ) ; expect ( ( TokenCache as any ) . tokenStore [ tokenKey ] ) . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const tokenEntry = { connectionName , token } ; ( TokenCache as any ) . tokenStore [ tokenKey ] = tokenEntry ; expect ( TokenCache . getTokenFromCache ( botId , userId , connectionName ) ) . toBe ( tokenEntry ) ; } ) ; it ( 's' , ( ) => { expect ( ( TokenCache as any ) . tokenKey ( botId , userId , connectionName ) ) . toBe ( tokenKey ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O O O O O O O $any$ O O $any$ O O O O $any$ O $string$ O O O $any$ O O $string$ O $string$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O $string$ O O O $any$ O O O O $any$ O $string$ O O $complex$ O $any$ O $void$ O O O O O O O O $any$ O O $any$ O O O O $any$ O $string$ O O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O $string$ O O O $any$ O O O O $any$ O $string$ O O $complex$ O $any$ O $any$ O $TokenResponse$ O O O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O $any$ O O O O $any$ O O O O O O O O O $any$ O $string$ O O O O O O O O
import { AttachmentContentTypes , CardAction , MediaCard , MessageActivity , OAuthCard , ReceiptCard , SigninCard , ThumbnailCard , } from 's' ; import ActivityVisitor from 's' ; class MockActivityVisitor extends ActivityVisitor { public cardActionVisitors : CardAction [ ] = [ ] ; visitCardAction ( cardAction ) { this . cardActionVisitors . push ( cardAction ) ; } } describe ( 's' , ( ) => { let activityVisitor ; beforeEach ( ( ) => { activityVisitor = new MockActivityVisitor ( ) ; } ) ; it ( 's' , ( ) => { const mockMediaCard < MediaCard > = { image : { url : 's' , alt : 's' , tap : { image : 's' , title : 's' , type : 's' , value : 's' } , } , buttons : [ { image : 's' , title : 's' , type : 's' , value : 's' } ] , } ; const mockThumbnailCard < ThumbnailCard > = { buttons : [ { image : 's' , title : 's' , type : 's' , value : 's' } ] , tap : { image : 's' , title : 's' , type : 's' , value : 's' } , images : [ { url : 's' , alt : 's' , tap : { image : 's' , title : 's' , type : 's' , value : 's' } , } , ] , } ; const mockReceiptCard < ReceiptCard > = { buttons : [ { image : 's' , title : 's' , type : 's' , value : 's' } ] , tap : { image : 's' , title : 's' , type : 's' , value : 's' } , } ; const mockOauthCard < OAuthCard > = { buttons : [ { image : 's' , title : 's' , type : 's' , value : 's' } ] , connectionName : 's' , } ; const mockSigninCard < SigninCard > = { buttons : [ { image : 's' , title : 's' , type : 's' , value : 's' } ] , text : 's' , } ; const mockMessageActivity = { attachments : [ { contentType : AttachmentContentTypes . animationCard , content : mockMediaCard , } , { contentType : AttachmentContentTypes . audioCard , content : mockMediaCard , } , { contentType : AttachmentContentTypes . heroCard , content : mockThumbnailCard , } , { contentType : AttachmentContentTypes . oAuthCard , content : mockOauthCard , } , { contentType : AttachmentContentTypes . receiptCard , content : mockReceiptCard , } , { contentType : AttachmentContentTypes . signInCard , content : mockSigninCard , } , { contentType : AttachmentContentTypes . thumbnailCard , content : mockThumbnailCard , } , { contentType : AttachmentContentTypes . videoCard , content : mockMediaCard , } , ] , } ; activityVisitor . traverseActivity ( mockMessageActivity ) ; const { cardActionVisitors } = activityVisitor ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . image . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . image . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . images [ 0 ] . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockOauthCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockReceiptCard . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockReceiptCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockSigninCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . buttons [ 0 ] ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockThumbnailCard . images [ 0 ] . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . image . tap ) ; expect ( cardActionVisitors [ 0 ] ) . toBe ( mockMediaCard . buttons [ 0 ] ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any[]$ O $any$ O O O O O O $void$ O $CardAction$ O O O O $any[]$ O $number$ O $any$ O O O O $any$ O O O O O O O O $MockActivityVisitor$ O $any$ O O O O O $MockActivityVisitor$ O O $any$ O O O O O O $any$ O O O O O O O O $Partial$ O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $Partial$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $complex$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $Partial$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $Partial$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $Partial$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $MessageActivity$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $MockActivityVisitor$ O $void$ O $any$ O O O O $any[]$ O O $MockActivityVisitor$ O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O
import approximateObjectSize from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const size = approximateObjectSize ( { 0 : 's' , 0 : true , 0 : 0 , 0 : { 0 : 's' } , } , [ ] ) ; expect ( size ) . toBe ( 0 ) ; } ) ; } ) ;	O $number$ O O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O $number$ O O $string$ O O O $boolean$ O O O $number$ O O O O O O $string$ O O O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O O O O
import { usGovernmentAuthentication , authentication , 0 , 0 } from 's' ; import createBotFrameworkAuthenticationMiddleware from 's' ; const mockGetKey = jest . fn ( ) . mockResolvedValue ( `template` ) ; jest . mock ( 's' , ( ) => { return jest . fn ( ) . mockImplementation ( ( ) => ( { getKey : mockGetKey , } ) ) ; } ) ; let mockDecode ; let mockVerify ; jest . mock ( 's' , ( ) => ( { get decode ( ) { return mockDecode ; } , get verify ( ) { return mockVerify ; } , } ) ) ; describe ( 's' , ( ) => { const authMiddleware = createBotFrameworkAuthenticationMiddleware ( jest . fn ( ) . mockResolvedValue ( true ) ) ; const mockNext = jest . fn ( ( ) => null ) ; const mockStatus = jest . fn ( ( ) => null ) ; const mockEnd = jest . fn ( ( ) => null ) ; let mockPayload ; beforeEach ( ( ) => { mockNext . mockClear ( ) ; mockEnd . mockClear ( ) ; mockStatus . mockClear ( ) ; mockDecode = jest . fn ( ( ) => ( { header : { kid : 's' , } , payload : mockPayload , } ) ) ; mockVerify = jest . fn ( ( ) => 's' ) ; mockGetKey . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { const mockHeader = jest . fn ( ( ) => false ) ; const req = { header : mockHeader } ; const result = await authMiddleware ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockHeader ) . toHaveBeenCalled ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockDecode = jest . fn ( ( ) => null ) ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockHeader ) . toHaveBeenCalled ( ) ; expect ( mockDecode ) . toHaveBeenCalledWith ( 's' , { complete : true } ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : usGovernmentAuthentication . botTokenAudience , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : usGovernmentAuthentication . botTokenAudience , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : usGovernmentAuthentication . botTokenAudience , clockTolerance : 0 , issuer : usGovernmentAuthentication . 0 , } ) ; expect ( req . jwt ) . toBe ( 's' ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : usGovernmentAuthentication . botTokenAudience , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : usGovernmentAuthentication . botTokenAudience , clockTolerance : 0 , issuer : usGovernmentAuthentication . 0 , } ) ; expect ( req . jwt ) . toBe ( 's' ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : usGovernmentAuthentication . botTokenAudience , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; mockVerify = jest . fn ( ( ) => { throw new Error ( 's' ) ; } ) ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : usGovernmentAuthentication . botTokenAudience , clockTolerance : 0 , issuer : usGovernmentAuthentication . 0 , } ) ; expect ( req . jwt ) . toBeUndefined ( ) ; expect ( mockNext ) . not . toHaveBeenCalled ( ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; it ( `template` , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; mockGetKey . mockResolvedValueOnce ( null ) ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; expect ( mockNext ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . 0 , } ) ; expect ( req . jwt ) . toBe ( 's' ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . 0 , } ) ; expect ( req . jwt ) . toBe ( 's' ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; mockVerify . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . 0 , } ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . tokenIssuer , } ) ; expect ( req . jwt ) . toBe ( 's' ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { mockPayload = { aud : 's' , ver : 's' , } ; const mockHeader = jest . fn ( ( ) => 's' ) ; const req = { header : mockHeader } ; const res = { status : mockStatus , end : mockEnd , } ; mockVerify . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) . mockImplementationOnce ( ( ) => { throw new Error ( 's' ) ; } ) ; const result = await authMiddleware ( req , res , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockVerify ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . 0 , } ) ; expect ( mockVerify ) . toHaveBeenCalledWith ( 's' , 's' , { audience : authentication . botTokenAudience , clockTolerance : 0 , issuer : 0 . tokenIssuer , } ) ; expect ( mockStatus ) . toHaveBeenCalledWith ( 0 ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; expect ( req . jwt ) . toBeUndefined ( ) ; expect ( mockNext ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O O O $complex$ O O O $complex$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $void$ O O $Promise<void>$ O $any$ O O O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $boolean$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $string$ O O O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $string$ O O O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $string$ O O O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $void$ O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O O $any$ O O O O O O $string$ O $complex$ O $string$ O $number$ O O O $string$ O $complex$ O $string$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import createApiException from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const exception = createApiException ( 0 , 's' , 's' ) ; expect ( exception . statusCode ) . toBe ( 0 ) ; expect ( exception . error ) . toEqual ( { error : { code : 's' , message : 's' , } , } ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O
import createConversationResponse from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const response = createConversationResponse ( 's' , 's' ) ; expect ( response ) . toEqual ( { activityId : 's' , id : 's' , } ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O
import createErrorResponse from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const response = createErrorResponse ( 's' , 's' ) ; expect ( response ) . toEqual ( { error : { code : 's' , message : 's' , } , } ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O
import createResourceResponse from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const response = createResourceResponse ( 's' ) ; expect ( response ) . toEqual ( { id : 's' } ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O O O O
import * as Restify from 's' ; import jsonBodyParser from 's' ; let mockBodyParser = jest . fn ( ( ) => null ) ; jest . mock ( 's' , ( ) => ( { plugins : { bodyReader : jest . fn ( options => options ) , jsonBodyParser : jest . fn ( ( ) => [ mockBodyParser ] ) , } , } ) ) ; describe ( 's' , ( ) => { let bodyParsingFunctions ; const mockOptions = { } ; const mockNext = jest . fn ( ( ) => null ) ; beforeEach ( ( ) => { ( Restify . plugins . bodyReader as any ) . mockClear ( ) ; ( Restify . plugins . jsonBodyParser as any ) . mockClear ( ) ; bodyParsingFunctions = jsonBodyParser ( mockOptions ) ; mockNext . mockClear ( ) ; mockBodyParser . mockClear ( ) ; } ) ; it ( 's' , ( ) => { bodyParsingFunctions = jsonBodyParser ( null ) ; expect ( bodyParsingFunctions . length ) . toBe ( 0 ) ; expect ( bodyParsingFunctions [ 0 ] ) . toEqual ( { bodyReader : true , mapParams : false } ) ; bodyParsingFunctions = jsonBodyParser ( mockOptions ) ; expect ( bodyParsingFunctions [ 0 ] ) . toEqual ( { bodyReader : true } ) ; } ) ; it ( 's' , ( ) => { const req = { method : 's' } ; const result = jsonBodyParser ( mockOptions ) [ 0 ] ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { mockOptions . requestBodyOnGet = false ; const req = { method : 's' } ; const result = jsonBodyParser ( mockOptions ) [ 0 ] ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const req = { method : 's' , contentLength : jest . fn ( ( ) => 0 ) , isChunked : jest . fn ( ( ) => false ) , } ; const result = jsonBodyParser ( mockOptions ) [ 0 ] ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const req = { method : 's' , contentLength : jest . fn ( ( ) => 0 ) , contentType : jest . fn ( ( ) => 's' ) , } ; const result = jsonBodyParser ( mockOptions ) [ 0 ] ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockBodyParser ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const req = { method : 's' , contentLength : jest . fn ( ( ) => 0 ) , contentType : jest . fn ( ( ) => 's' ) , } ; mockBodyParser = null ; const result = jsonBodyParser ( mockOptions ) [ 0 ] ( req , null , mockNext ) ; expect ( result ) . toBeUndefined ( ) ; expect ( mockNext ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O O $any$ O O O O $any[]$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any[]$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O $any$ O $any[]$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O $string$ O O O O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any[]$ O $any$ O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O
import OAuthClientEncoder from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const activity = { conversation : { id : 's' } } ; const encoder = new OAuthClientEncoder ( activity ) ; expect ( ( encoder as any ) . _conversationId ) . toBe ( activity . conversation . id ) ; } ) ; it ( 's' , ( ) => { const activity = { conversation : { } } ; const encoder = new OAuthClientEncoder ( activity ) ; expect ( ( encoder as any ) . _conversationId ) . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const encoder = new OAuthClientEncoder ( null ) ; expect ( ( encoder as any ) . visitCardAction ( null ) ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const activity = { conversation : { id : 's' } } ; const connectionName = 's' ; const cardAction = { type : 's' } ; const encodedOAuthUrl = OAuthClientEncoder . OAuthEmulatorUrlProtocol + 's' + connectionName + 's' + activity . conversation . id ; const encoder = new OAuthClientEncoder ( activity ) ; ( encoder as any ) . visitOAuthCardAction ( connectionName , cardAction ) ; expect ( cardAction . type ) . toBe ( 's' ) ; expect ( cardAction . value ) . toEqual ( encodedOAuthUrl ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O O O O $OAuthClientEncoder$ O O $any$ O $any$ O O $any$ O O $OAuthClientEncoder$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O ${}$ O O O O O O $OAuthClientEncoder$ O O $any$ O $any$ O O $any$ O O $OAuthClientEncoder$ O O O O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $OAuthClientEncoder$ O O $any$ O O O O $any$ O O $OAuthClientEncoder$ O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O O O O O O O O O $any$ O O $string$ O O O O O $string$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O $OAuthClientEncoder$ O O $any$ O $any$ O O O $OAuthClientEncoder$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O
import { AttachmentContentTypes } from 's' ; import OAuthLinkEncoder from 's' ; jest . mock ( 's' , ( ) => ( ) => 's' ) ; const mockArgsSentToFetch = [ ] ; let ok = true ; let statusText = 's' ; let shouldThrow = false ; describe ( 's' , ( ) => { let encoder ; beforeAll ( ( ) => { ( global as any ) . fetch = async ( ... args ) => { mockArgsSentToFetch . push ( args ) ; if ( shouldThrow ) { throw new Error ( "s" ) ; } return { text : async ( ) => 's' , ok , statusText , } ; } ; } ) ; beforeEach ( ( ) => { ok = true ; statusText = 's' ; shouldThrow = false ; mockArgsSentToFetch . length = 0 ; const emulator = { getServiceUrl : async ( ) => 's' , getServiceUrlForOAuth : async ( ) => 's' , facilities : { conversations : { conversationById : ( ) => ( { codeVerifier : 's' , botEndpoint : { botUrl : 's' , } , conversationId : 's' , } ) , } , } , } ; encoder = new OAuthLinkEncoder ( emulator as any , 's' , { attachments : [ { contentType : AttachmentContentTypes . oAuthCard } ] , text : 's' , } , 's' ) ; } ) ; it ( 's' , async ( ) => { const mockActivity = { attachments : [ { contentType : AttachmentContentTypes . oAuthCard , content : { buttons : [ { type : 's' } ] , } , } , ] , text : 's' , } ; await encoder . resolveOAuthCards ( mockActivity ) ; expect ( mockActivity . attachments [ 0 ] . content . buttons [ 0 ] ) . toEqual ( { type : 's' , value : 's' , } ) ; } ) ; it ( 's' , async ( ) => { ok = false ; statusText = 's' ; const mockActivity = { attachments : [ { contentType : AttachmentContentTypes . oAuthCard , content : { buttons : [ { type : 's' } ] , } , } , ] , text : 's' , } ; try { await encoder . resolveOAuthCards ( mockActivity ) ; expect ( false ) ; } catch ( e ) { expect ( e . message ) . toEqual ( statusText ) ; } } ) ; it ( 's' , async ( ) => { shouldThrow = true ; const mockActivity = { attachments : [ { contentType : AttachmentContentTypes . oAuthCard , content : { buttons : [ { type : 's' } ] , } , } , ] , text : 's' , } ; try { await encoder . resolveOAuthCards ( mockActivity ) ; expect ( false ) ; } catch ( e ) { expect ( e . message ) . toEqual ( "s" ) ; } } ) ; it ( 's' , async ( ) => { const v = encoder . generateCodeVerifier ( 's' ) ; expect ( v ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O O O O O O O O O $any[]$ O O O O O $boolean$ O O O O $string$ O O O O $boolean$ O O O $any$ O O O O O O O O $OAuthLinkEncoder$ O $any$ O O O O O O $any$ O O O O $any$ O O O O $any[]$ O O O $any[]$ O $number$ O $any[]$ O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O $Promise<string>$ O O O O O O O $boolean$ O $string$ O O O O O O O O $any$ O O O O O $boolean$ O O O $string$ O O O $boolean$ O O O $any[]$ O $number$ O O O O $complex$ O O $Promise<string>$ O O O O O O O $Promise<string>$ O O O O O O O $complex$ O O $complex$ O O $complex$ O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $string$ O O O O O O O O O O O O $OAuthLinkEncoder$ O O $any$ O $complex$ O O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O $string$ O O O O O O $OAuthLinkEncoder$ O $Promise<boolean>$ O $complex$ O O $any$ O $complex$ O $complex$ O O O O $complex$ O $complex$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $boolean$ O O O $string$ O O O O $complex$ O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O $OAuthLinkEncoder$ O $Promise<boolean>$ O $complex$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O $any$ O O O O O O O O $boolean$ O O O O $complex$ O O $complex$ O O O $any$ O $any$ O $any$ O $complex$ O O $complex$ O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O $OAuthLinkEncoder$ O $Promise<boolean>$ O $complex$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $string$ O $OAuthLinkEncoder$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O
import OpenIdMetadata from 's' ; jest . mock ( 's' , ( ) => ( { 0 : jest . fn ( value => `template` ) , } ) ) ; jest . mock ( 's' , ( ) => jest . fn ( ( n , e ) => `template` ) ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const mockRefreshCache = jest . fn ( ( ) => Promise . resolve ( ) ) ; const mockFindKey = jest . fn ( ( ) => 's' ) ; const openIdMetadata = new OpenIdMetadata ( null , null ) ; const lastUpdated = new Date ( ) . getTime ( ) - 0 * 0 * 0 * 0 * 0 ; ( openIdMetadata as any ) . lastUpdated = lastUpdated ; ( openIdMetadata as any ) . refreshCache = mockRefreshCache ; ( openIdMetadata as any ) . findKey = mockFindKey ; const key = await openIdMetadata . getKey ( 's' ) ; expect ( mockRefreshCache ) . toHaveBeenCalled ( ) ; expect ( mockFindKey ) . toHaveBeenCalledWith ( 's' ) ; expect ( key ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { const mockFetch = jest . fn ( ) . mockResolvedValueOnce ( { json : jest . fn ( ) . mockResolvedValue ( { jwks_uri : 's' } ) , } ) . mockResolvedValueOnce ( { json : jest . fn ( ) . mockResolvedValue ( { keys : [ 's' , 's' , 's' ] } ) , } ) ; const timeBeforeRefresh = new Date ( ) . getTime ( ) - 0 ; const openIdMetadata = new OpenIdMetadata ( mockFetch , 's' ) ; await ( openIdMetadata as any ) . refreshCache ( ) ; expect ( mockFetch ) . toHaveBeenCalledWith ( 's' ) ; expect ( mockFetch ) . toHaveBeenCalledWith ( 's' ) ; expect ( ( openIdMetadata as any ) . lastUpdated ) . toBeGreaterThan ( timeBeforeRefresh ) ; expect ( ( openIdMetadata as any ) . keys ) . toEqual ( [ 's' , 's' , 's' ] ) ; } ) ; it ( 's' , async ( ) => { const mockFetch = jest . fn ( ) . mockResolvedValueOnce ( { status : 0 , statusCode : 0 } ) ; const openIdMetadata = new OpenIdMetadata ( mockFetch , 's' ) ; await expect ( ( openIdMetadata as any ) . refreshCache ( ) ) . rejects . toThrowError ( 's' ) ; } ) ; it ( 's' , async ( ) => { const mockFetch = jest . fn ( ) . mockResolvedValueOnce ( { json : jest . fn ( ) . mockResolvedValue ( { jwks_uri : 's' } ) , } ) . mockResolvedValueOnce ( { status : 0 , statusCode : 0 , } ) ; const openIdMetadata = new OpenIdMetadata ( mockFetch , 's' ) ; await expect ( ( openIdMetadata as any ) . refreshCache ( ) ) . rejects . toThrowError ( 's' ) ; } ) ; it ( 's' , ( ) => { const keyId = 's' ; const openIdMetadata = new OpenIdMetadata ( null , null ) ; const key = { kid : keyId , n : 's' , e : 's' , } ; ( openIdMetadata as any ) . keys = [ key ] ; const retrievedKey = ( openIdMetadata as any ) . findKey ( keyId ) ; expect ( retrievedKey ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const openIdMetadata = new OpenIdMetadata ( null , null ) ; ( openIdMetadata as any ) . keys = undefined ; expect ( ( openIdMetadata as any ) . findKey ( 's' ) ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const 0 = 's' ; const 0 = 's' ; const openIdMetadata = new OpenIdMetadata ( null , null ) ; const 0 = { kid : 0 , n : 's' , } ; const 0 = { kid : 0 , e : 's' , } ; ( openIdMetadata as any ) . keys = [ 0 , 0 ] ; const 0 = ( openIdMetadata as any ) . findKey ( 0 ) ; expect ( 0 ) . toBe ( null ) ; const 0 = ( openIdMetadata as any ) . findKey ( 0 ) ; expect ( 0 ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { const openIdMetadata = new OpenIdMetadata ( null , null ) ; ( openIdMetadata as any ) . keys = [ ] ; expect ( ( openIdMetadata as any ) . findKey ( 's' ) ) . toBe ( null ) ; } ) ; } ) ;	O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $OpenIdMetadata$ O O $any$ O O O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O O O O O O O O O $OpenIdMetadata$ O O O O $any$ O $number$ O O $OpenIdMetadata$ O O O O $any$ O $any$ O O $OpenIdMetadata$ O O O O $any$ O $any$ O O $string$ O O $OpenIdMetadata$ O $Promise<string>$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $string[]$ O O O O O O O O O O O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O $OpenIdMetadata$ O O $any$ O $any$ O O O O O O $OpenIdMetadata$ O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O $any$ O $number$ O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $number$ O O O $number$ O O O O O O $OpenIdMetadata$ O O $any$ O $any$ O O O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O O O O O O $any$ O O $number$ O O O $number$ O O O O O O O $OpenIdMetadata$ O O $any$ O $any$ O O O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $OpenIdMetadata$ O O $any$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $OpenIdMetadata$ O O O O $any$ O O $complex$ O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $OpenIdMetadata$ O O $any$ O O O O O O O $OpenIdMetadata$ O O O O $any$ O $undefined$ O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $OpenIdMetadata$ O O $any$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $OpenIdMetadata$ O O O O $any$ O O $complex$ O $complex$ O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $OpenIdMetadata$ O O $any$ O O O O O O O $OpenIdMetadata$ O O O O $any$ O O O O $any$ O O $OpenIdMetadata$ O O O O $any$ O O O O O $any$ O O O O O O O O O O
import PaymentEncoder from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const paymentEncoder = new PaymentEncoder ( ) ; const cardAction = { type : 's' , value : { id : 's' , onshippingaddresschange : null , onshippingoptionchange : null , shippingAddress : null , shippingOption : null , shippingType : null , abort : null , canMakePayment : null , show : null , addEventListener : null , removeEventListener : null , } , } ; const paymentRequest = cardAction . value as PaymentRequest ; const encodedPaymentUrl = PaymentEncoder . PaymentEmulatorUrlProtocol + 's' + JSON . stringify ( paymentRequest ) ; ( paymentEncoder as any ) . visitCardAction ( cardAction ) ; expect ( cardAction . type ) . toBe ( 's' ) ; expect ( cardAction . value ) . toEqual ( encodedPaymentUrl ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $PaymentEncoder$ O O $any$ O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O $null$ O O O O O O O O $PaymentRequest$ O $any$ O $any$ O $complex$ O O $string$ O $any$ O $string$ O O O $JSON$ O $complex$ O $PaymentRequest$ O O O $PaymentEncoder$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O
export default function safeStringify ( o , space ? : string | number ) { const cache = [ ] ; if ( typeof o !== 's' ) { return `template` ; } else { return JSON . stringify ( o , ( key , value ) => { if ( typeof value === 's' && value !== null ) { if ( cache . indexOf ( value ) ) { return ; } cache . push ( value ) ; } return value ; } , space ) ; } }	O O O $string$ O $any$ O $complex$ O O O O O O O O $any[]$ O O O O O O O $any$ O O O O O O O O O O O $JSON$ O $complex$ O $any$ O O $string$ O $any$ O O O O O O $any$ O O O $any$ O O O O O O $any[]$ O $number$ O $any$ O O O O O O $any[]$ O $number$ O $any$ O O O O $any$ O O O $complex$ O O O O
import { ErrorCodes } from 's' ; import * as HttpStatus from 's' ; import sendErrorResponse from 's' ; import createErrorResponse from 's' ; describe ( 's' , ( ) => { const mockSend = jest . fn ( ( ) => { } ) ; const mockEnd = jest . fn ( ( ) => { } ) ; const response = { end : mockEnd , send : mockSend } ; beforeEach ( ( ) => { mockSend . mockClear ( ) ; mockEnd . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const exception = { error : 's' , statusCode : 0 } ; const error = sendErrorResponse ( null , response , null , exception ) ; expect ( error ) . toBe ( exception . error ) ; expect ( mockSend ) . toHaveBeenCalledWith ( exception . statusCode , exception . error ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const exception = { message : 's' } ; const error = sendErrorResponse ( null , response , null , exception ) ; expect ( error ) . toEqual ( createErrorResponse ( ErrorCodes . ServiceError , exception . message ) ) ; expect ( mockSend ) . toHaveBeenCalledWith ( HttpStatus . BAD_REQUEST , error ) ; expect ( mockEnd ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O O O $any$ O $any$ O O O $any$ O O O $complex$ O O $any$ O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O O $any$ O $complex$ O $number$ O $complex$ O $string$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $any$ O $any$ O O O $any$ O O O $complex$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $complex$ O $string$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O
import statusCodeFamily from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( statusCodeFamily ( 0 , 0 ) ) . toBe ( true ) ; expect ( statusCodeFamily ( 's' , 0 ) ) . toBe ( false ) ; } ) ; } ) ;	O $boolean$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O O O $any$ O O O O $any$ O $boolean$ O O O O O O O $any$ O O O O O O O O O O
export type StringProvider = ( ) => string ;	O O $any$ O O O O O O
import stripEmptyBearerToken from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const middleware = stripEmptyBearerToken ( ) ; const next = jest . fn ( ( ) => null ) ; const request = { headers : { authorization : 's' } } ; middleware ( request , null , next ) ; expect ( request . headers . authorization ) . toBe ( undefined ) ; expect ( next ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const middleware = stripEmptyBearerToken ( ) ; const next = jest . fn ( ( ) => null ) ; const request = { headers : { authorization : null } } ; middleware ( request , null , next ) ; expect ( request . headers . authorization ) . toBe ( null ) ; expect ( next ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O $any$ O $complex$ O O O $any$ O O $any$ O $complex$ O $complex$ O $string$ O O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $null$ O O O O O $any$ O $complex$ O O O $any$ O O $any$ O $complex$ O $complex$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O
import uniqueId from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const 0 = uniqueId ( ) ; const 0 = uniqueId ( ) ; const 0 = uniqueId ( ) ; expect ( 0 ) . not . toBe ( 0 ) ; expect ( 0 ) . not . toBe ( 0 ) ; expect ( 0 ) . not . toBe ( 0 ) ; } ) ; } ) ;	O $string$ O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O $string$ O $string$ O O O O $string$ O $string$ O O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
export const mockChatLogs = [ { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { hyperlink : 's' , text : 's' , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { text : 's' , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , timestamp : 's' , type : 's' , value : 's' , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , timestamp : 's' , type : 's' , value : 's' , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { first : 's' , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { } , } , } , { id : 's' , state : { slot : 's' , values : { first : 's' , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelData : { clientActivityID : 's' , } , channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , localTimestamp : 's' , locale : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , serviceUrl : 's' , text : 's' , textFormat : 's' , timestamp : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , valueType : 's' , } , } , type : 's' , } , { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , inputHint : 's' , recipient : { id : 's' , name : 's' , role : 's' , } , replyToId : 's' , serviceUrl : 's' , text : 's' , type : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , { items : [ { payload : { level : 0 , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { age : 0 , fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , retryPrompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , text : 's' , } , type : 's' , } , { payload : { obj : { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : [ { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , { id : 's' , state : { slot : 's' , values : { age : 0 , fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , { id : 's' , state : { options : { prompt : 's' , retryPrompt : 's' , } , state : { } , } , } , ] , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } , } , type : 's' , } , ] , timestamp : 0 , } , ] ; export const 0 = { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : { 's' : { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , 's' : { id : 's' , state : { slot : 's' , values : { } , } , } , 's' : { id : 's' , state : { 's' : 's' , 's' : 's' , values : { 's' : 's' , } , } , } , 's' : { id : 's' , state : { options : { 's' : 's' , 's' : 's' , } , state : { } , } , } , } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } ; export const 0 = { channelId : 's' , conversation : { id : 's' , } , from : { id : 's' , name : 's' , role : 's' , } , id : 's' , label : 's' , localTimestamp : 's' , locale : 's' , name : 's' , recipient : { id : 's' , role : 's' , } , serviceUrl : 's' , timestamp : 's' , type : 's' , value : { conversationState : { dialogState : { dialogStack : { 's' : { id : 's' , state : { options : { } , stepIndex : 0 , values : { instanceId : 's' , } , } , } , 's' : { id : 's' , state : { 's' : 's' , 's' : 's' , values : { fullname : { slot : 's' , values : { first : 's' , last : 's' , } , } , } , } , } , 's' : { 's' : 's' , 's' : 's' , state : { 's' : 's' , 's' : { first : 's' , } , options : { prompt : 's' , } , state : { } , } , } , 's' : { id : 's' , state : { options : { prompt : 's' , } , state : { } , } , } , } , } , eTag : 's' , } , userState : { } , } , valueType : 's' , } ;	O O $complex$ O O O $complex$ O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O $number$ O O O O O O $complex$ O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O $number$ O O O O O O $complex$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $number$ O O O O O O $complex$ O O O $complex$ O O $string$ O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O $number$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O O O $string$ O O O $complex$ O O O O O O O O O O $complex$ O O O O O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O O O O O O O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O ${}$ O O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O O O O O O O $string$ O O O O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O ${}$ O O O O O O O O O O O O $string$ O O O O O ${}$ O O O O O O $string$ O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
import { InspectorHost } from 's' ; import { Activity } from 's' ; import { ExtensionChannel } from 's' ; import { InspectableObjectLogItem , LogEntry , LogItem , LogItemType } from 's' ; import { ValueTypes } from 's' ; import { diff } from 's' ; export function IpcHandler ( type ) { return function ( elementDescriptor ) { const { key , descriptor } = elementDescriptor ; const initializer = function ( ) { const host = ( window as any ) . host as InspectorHost ; const bound = this [ key ] . bind ( this ) ; host . on ( type as any , bound ) ; return bound ; } ; elementDescriptor . extras = [ { kind : 's' , key , placement : 's' , initializer , descriptor : { ... descriptor , value : undefined } , } , ] ; return elementDescriptor ; } ; } export function IpcHost ( mixins : ( keyof InspectorHost ) [ ] ) { return function ( elementDescriptor ) { const { elements } = elementDescriptor ; const host = ( window as any ) . host as InspectorHost ; mixins . forEach ( mixin => { const value = typeof host [ mixin ] === 's' ? ( host [ mixin ] as Function ) . bind ( host ) : host [ mixin ] ; const element = elements . find ( element => element . key === mixin ) ; const descriptor = { key : mixin , kind : 's' , placement : 's' , descriptor : { get : ( ) => value , } , } ; if ( element ) { Object . assign ( element , descriptor ) ; } else { elements . push ( descriptor ) ; } } ) ; return { ... elementDescriptor , elements } ; } ; } export async function updateTheme ( themeInfo : { themeName : string ; themeComponents : string [ ] } ) < void > { document . getElementById ( 's' ) . className = themeInfo . themeName ; const oldThemeComponents = document . querySelectorAll ( 's' ) ; const head = document . querySelector ( 's' ) ; const fragment = document . createDocumentFragment ( ) ; const promises = [ ] ; themeInfo . themeComponents . forEach ( themeComponent => { const link = document . createElement ( 's' ) ; promises . push ( new Promise ( resolve => { link . addEventListener ( 's' , resolve ) ; } ) ) ; link . href = themeComponent ; link . rel = 's' ; link . setAttribute ( 's' , 's' ) ; fragment . appendChild ( link ) ; } ) ; head . insertBefore ( fragment , head . firstElementChild ) ; await Promise . all ( promises ) ; oldThemeComponents . forEach ( themeComponent => { if ( themeComponent . parentElement ) { themeComponent . parentElement . removeChild ( themeComponent ) ; } } ) ; } export function getBotState ( entries : LogEntry < InspectableObjectLogItem > [ ] , referenceBotState , offset = - 0 ) { if ( ! referenceBotState ) { return null ; } const allBotStates = extractBotStateActivitiesFromLogEntries ( entries ) ; const index = allBotStates . findIndex ( botState => botState . id === referenceBotState . id ) + offset ; return allBotStates [ index ] ; } export function extractBotStateActivitiesFromLogEntries ( entries : LogEntry < InspectableObjectLogItem > [ ] ) : Activity [ ] { if ( ! entries ) { return [ ] ; } return entries . reduce ( ( agg , entry ) => agg . concat ( entry . items ) , [ ] ) . filter ( ( item < InspectableObjectLogItem > ) => { const activity = item . payload . obj as Activity ; return item . type === LogItemType . InspectableObject && activity . valueType === ValueTypes . BotState ; } ) . map ( ( item ) => ( item . payload as InspectableObjectLogItem ) . obj as Activity ) ; } export function buildDiff ( a , b ) { const lhs = [ ] ; const rhs = [ ] ; const deltas = diff ( b . value , a . value ) ; ( deltas || [ ] ) . forEach ( diff => { switch ( diff . kind ) { case 's' : { const { item , path } = diff ; path . push ( diff . index ) ; if ( item . kind === 's' ) { lhs . push ( path ) ; } else if ( item . kind === 's' ) { rhs . push ( path ) ; lhs . push ( path ) ; } else { rhs . push ( path ) ; } } break ; case 's' : lhs . push ( diff . path ) ; break ; case 's' : rhs . push ( diff . path ) ; lhs . push ( diff . path ) ; break ; case 's' : rhs . push ( diff . path ) ; break ; } } ) ; const botStateClone = JSON . parse ( JSON . stringify ( a , ( key , value ) => { if ( value instanceof Array ) { return Object . keys ( value ) . reduce ( ( conversion , key ) => { conversion [ 's' + key ] = value [ key ] ; return conversion ; } , { } ) ; } return value ; } ) ) ; botStateClone . valueType = ValueTypes . Diff ; rhs . forEach ( path => { buildDiffNode ( 's' , path , botStateClone . value , botStateClone . value ) ; } ) ; lhs . forEach ( path => { buildDiffNode ( 's' , path , botStateClone . value , b . value ) ; } ) ; return botStateClone ; } export function buildDiffNode ( prependWith , path : ( string | number ) [ ] , target , source ) { let key ; for ( let i = 0 ; i < path . length ; i ++ ) { key = path [ i ] ; if ( key in target && target [ key ] !== null && typeof target [ key ] === 's' ) { target = target [ key ] ; source = source [ key ] ; } else { break ; } } const value = source [ key ] ; delete target [ key ] ; target [ prependWith + key ] = value ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $MethodDecorator$ O $ExtensionChannel$ O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O O $complex$ O O O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $string$ O O O $any$ O $any$ O O O $any$ O $undefined$ O $undefined$ O O O O O O O $any$ O O O O O O $any$ O $complex$ O O O $any$ O O O O O O O O $any$ O O O O $any$ O O $any$ O O $any$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $void$ O $complex$ O O O $any$ O O $any$ O $complex$ O O O O O $any$ O $complex$ O O $FunctionConstructor$ O O $any$ O $any$ O O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $complex$ O O $complex$ O $complex$ O $string$ O O O $string$ O O O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O O $ObjectConstructor$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $complex$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise$ O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O O $Document$ O $HTMLElement$ O O O O $string$ O $complex$ O $string$ O O $NodeListOf<Element>$ O $Document$ O O O O O O O $HTMLHeadElement$ O $Document$ O O O O O O O $DocumentFragment$ O $Document$ O $DocumentFragment$ O O O O $any[]$ O O O O $complex$ O $string[]$ O $void$ O $string$ O O O $HTMLLinkElement$ O $Document$ O O O O O O $any[]$ O $number$ O O $PromiseConstructor$ O $void$ O O $HTMLLinkElement$ O O O O O $void$ O O O O O O $HTMLLinkElement$ O $string$ O $string$ O $HTMLLinkElement$ O $string$ O O O $HTMLLinkElement$ O $void$ O O O O O O $DocumentFragment$ O $T$ O $HTMLLinkElement$ O O O O O $HTMLHeadElement$ O $T$ O $DocumentFragment$ O $HTMLHeadElement$ O $Element$ O O O $PromiseConstructor$ O O O $any[]$ O O $NodeListOf<Element>$ O $void$ O $Element$ O O O O $Element$ O $HTMLElement$ O O $Element$ O $HTMLElement$ O $T$ O $Element$ O O O O O O O O O $Activity$ O $any[]$ O $any$ O $any$ O O O O $Activity$ O $number$ O O O O O O O O $any$ O O O O O O O $any[]$ O $any[]$ O $any[]$ O O O $number$ O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O O $any[]$ O $number$ O O O O O $any[]$ O $any[]$ O $any$ O $any$ O O O O O $any$ O O O O O O $any[]$ O O O O O O O O $any[]$ O $complex$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $LogItem$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $LogItem$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Activity$ O $Activity$ O $Activity$ O O O $any[]$ O O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any[]$ O $number$ O $any$ O O O O O O $any$ O $any$ O O O O $any[]$ O $number$ O $any$ O O $any[]$ O $number$ O $any$ O O O O O $any[]$ O $number$ O $any$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O O O O O O O O $Activity$ O $JSON$ O $any$ O $JSON$ O $complex$ O $any$ O O $string$ O $any$ O O O O O $any$ O $ArrayConstructor$ O O O $ObjectConstructor$ O $complex$ O $any[]$ O O $complex$ O O $any$ O $string$ O O O $any$ O O O $string$ O O $any[]$ O $string$ O O O $any$ O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any[]$ O $void$ O $any$ O O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $void$ O $any$ O O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $void$ O $string$ O $complex$ O O O O O O O O O $any$ O $any$ O O O $any$ O O O O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O $any$ O $complex$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $string$ O $any$ O O $any$ O O
'js' const { WatchIgnorePlugin } = require ( 's' ) ; const CopyWebpackPlugin = require ( 's' ) ; const path = require ( 's' ) ; module . exports = { entry : { index : path . resolve ( 's' ) , } , devtool : 's' , target : 's' , module : { rules : [ { test : "s" , use : [ 's' , { loader : 's' , options : { localIdentName : 's' , modules : true , sass : false , namedExport : true , camelCase : true , sourcemaps : true , banner : 's' , } , } , 's' , 's' , ] , } , { test : "s" , use : [ 's' ] , } , { test : "s" , exclude : [ "s" ] , use : { loader : 's' , options : { ignore : [ 's' ] , } , } , } , ] , } , devServer : { hot : true , inline : true , port : 0 , historyApiFallback : false , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' ] , } , output : { path : path . resolve ( 's' ) , filename : 's' , publicPath : 's' , } , stats : { warnings : false , } , externals : { } , plugins : [ new WatchIgnorePlugin ( [ 's' , 's' , 's' ] ) , new CopyWebpackPlugin ( [ { from : 's' , to : 's' } ] ) , ] , } ;	O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O O $RegExp$ O O O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O $RegExp$ O O O $string[]$ O O O O O O O O $RegExp$ O O O $RegExp[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $complex$ O O $boolean$ O O O O O ${}$ O O O O $any[]$ O O O $any$ O O O O O O O O O O O $any$ O O O $string$ O O O $string$ O O O O O O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import { ApiKeyCredentials } from 's' ; import { LuisAuthoring , LuisAuthoringModels } from 's' ; import * as LSCache from 's' ; import { LuisAppInfo } from 's' ; import { AppInfo } from 's' ; import { IntentInfo } from 's' ; import { LuisResponse } from 's' ; const DefaultVersion = 's' ; const TrainStatusRetryCount = 0 ; const WaitIntervalInMs = 0 ; const CacheTtlInMins = 0 ; const CortanaAppId = 's' ; const clientOptions = { customHeaders : { 's' : 's' } } ; const luisRegion : LuisAuthoringModels . AzureRegions = 's' ; const luisCloud : LuisAuthoringModels . AzureClouds = 's' ; enum TrainStatus { Success = 0 , Fail = 0 , UpToDate = 0 , InProgress = 0 , } class LuisClientError extends Error { private static getMessage ( message , statusCode : number | undefined ) { let errorMessage = message ; if ( statusCode ) { errorMessage += 's' + statusCode ; } return errorMessage ; } constructor ( message , statusCode ? ) { super ( LuisClientError . getMessage ( message , statusCode ) ) ; } } export class LuisClient { private _client : LuisAuthoring ; private luisAppInfo : LuisAppInfo ; private static getNormalizedEntityType ( entityType = 's' ) { const builtinPrefix = 's' ; const builtInPrefixLength = builtinPrefix . length ; if ( entityType . startsWith ( builtinPrefix ) ) { let typeEndIndex = entityType . indexOf ( 's' , builtInPrefixLength ) ; if ( typeEndIndex < 0 ) { typeEndIndex = entityType . length ; } return entityType . substring ( builtInPrefixLength , typeEndIndex ) ; } return entityType ; } private static getCacheKey ( apiName , appId , versionId ? ) { let key = apiName + 's' + appId ; if ( versionId ) { key += 's' ; key += versionId ; } return key ; } constructor ( luisAppInfo ) { this . luisAppInfo = luisAppInfo ; this . configureClient ( ) ; } public getLoggedInUserApps ( ) < LuisAuthoringModels . AppsListResponse > { this . configureClient ( ) ; return this . _client . apps . list ( luisRegion , luisCloud , clientOptions ) ; } public async getApplicationInfo ( ) < AppInfo > { const opCacheKey = LuisClient . getCacheKey ( 's' , this . luisAppInfo . appId ) ; let cached ; if ( ( cached = LSCache . get ( opCacheKey ) ) != null ) { return cached || ( { } as AppInfo ) ; } this . configureClient ( ) ; const r = await this . _client . apps . get ( luisRegion , luisCloud , this . luisAppInfo . appId , clientOptions ) ; const { _response : response } = r ; let appInfo = { } as AppInfo ; if ( response . status === 0 || ( response . status === 0 && this . luisAppInfo . appId . toLowerCase ( ) === CortanaAppId ) ) { appInfo = { authorized : false , activeVersion : 's' , name : null , appId : this . luisAppInfo . appId , endpoints : { } , isDispatchApp : false , } ; } else if ( response . status !== 0 ) { throw new LuisClientError ( 's' , response . status ) ; } else { appInfo = { ... response . parsedBody , authorized : true , appId : this . luisAppInfo . appId , isDispatchApp : response . parsedBody . activeVersion . toLocaleLowerCase ( ) . startsWith ( 's' ) , } ; LSCache . set ( opCacheKey , appInfo , CacheTtlInMins ) ; } return appInfo ; } public async getApplicationIntents ( appInfo ) < LuisAuthoringModels . IntentClassifier [ ] > { const opCacheKey = LuisClient . getCacheKey ( 's' , appInfo . appId , appInfo . activeVersion ) ; let cached : IntentInfo [ ] ; if ( ( cached = LSCache . get ( opCacheKey ) ) != null ) { return cached || ( [ ] as any ) ; } this . configureClient ( ) ; const r = await this . _client . model . listIntents ( luisRegion , luisCloud , appInfo . appId , appInfo . activeVersion , clientOptions ) ; const intents = r . _response . parsedBody ; LSCache . set ( opCacheKey , intents , CacheTtlInMins ) ; return intents ; } public async reassignIntent ( appInfo , luisResponse , newIntent ) < void > { this . configureClient ( ) ; const exampleLabelObject : LuisAuthoringModels . ExampleLabelObject = { text : luisResponse . query , intentName : newIntent , entityLabels : luisResponse . entities . map ( e => { return { entityName : LuisClient . getNormalizedEntityType ( e . type || 's' ) , startCharIndex : e . startIndex , endCharIndex : e . endIndex , } ; } ) , } ; const appId = appInfo . appId ; const versionId = appInfo . activeVersion || DefaultVersion ; const r = await this . _client . examples . add ( luisRegion , luisCloud , appId , versionId , exampleLabelObject , clientOptions ) ; if ( r . _response . status !== 0 ) { throw new LuisClientError ( 's' , r . _response . status ) ; } } public async publish ( appInfo , staging ) < any > { this . configureClient ( ) ; const endpointKey = staging ? 's' : 's' ; const region : LuisAuthoringModels . AzureRegions = appInfo . endpoints [ endpointKey ] . endpointRegion ; if ( ! region ) { throw new LuisClientError ( 's' ) ; } const applicationPublishRequest : LuisAuthoringModels . ApplicationPublishObject = { isStaging : staging , versionId : appInfo . activeVersion , } ; const r = await this . _client . apps . publish ( region , luisCloud , appInfo . appId , applicationPublishRequest , clientOptions ) ; if ( r . _response . status !== 0 ) { throw new LuisClientError ( 's' , r . _response . status ) ; } } public async train ( appInfo ) < any > { this . configureClient ( ) ; const trainResponse = await this . _client . train . trainVersion ( luisRegion , luisCloud , appInfo . appId , appInfo . activeVersion , clientOptions ) ; if ( trainResponse . _response . status !== 0 ) { throw new LuisClientError ( 's' , trainResponse . _response . status ) ; } let retryCounter = 0 ; return new Promise ( ( resolve , reject ) => { const intervalId = setInterval ( async ( ) => { const trainStatusResponse = await this . _client . train . getStatus ( luisRegion , luisCloud , appInfo . appId , appInfo . activeVersion , clientOptions ) ; if ( retryCounter ++ >= TrainStatusRetryCount ) { clearInterval ( intervalId ) ; reject ( 's' ) ; } if ( trainStatusResponse . _response . status !== 0 ) { return ; } if ( trainStatusResponse . every ( s => s . details . statusId === TrainStatus . UpToDate || s . details . statusId === TrainStatus . Success ) ) { clearInterval ( intervalId ) ; resolve ( ) ; } } , WaitIntervalInMs ) ; } ) ; } private configureClient ( ) { const creds = new ApiKeyCredentials ( { inHeader : { 's' : this . luisAppInfo . key } } ) ; this . _client = new LuisAuthoring ( creds ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O $complex$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $TrainStatus.Success$ O O O $TrainStatus.Fail$ O O O $TrainStatus.UpToDate$ O O O $TrainStatus.InProgress$ O O O O O $any$ O $ErrorConstructor$ O O O $string$ O $string$ O $number$ O O O O O O O $string$ O $string$ O O O $number$ O O $string$ O O O $number$ O O O $string$ O O O O $string$ O $number$ $number$ O O O O $any$ O $string$ O $string$ O $number$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $string$ O $string$ O O O O O O O O O O $number$ O O O $number$ O O O $string$ O $boolean$ O O O O O O $number$ O $string$ O $number$ O O O $number$ O O O O $number$ O O O O $number$ O $string$ O $number$ O O O $string$ O $string$ O $number$ O $number$ O O O O $string$ O O O O $string$ O $string$ O $string$ O $string$ $string$ O O O $string$ O $string$ O O O $string$ O O O $string$ O O $string$ O O O $string$ O $string$ O O O $string$ O O O O $LuisAppInfo$ O O O O $any$ O $any$ O O O $void$ O O O O O $Promise$ O O O $any$ O $any$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O $Promise$ O O O $any$ O O O $string$ O $any$ O $string$ O O O O O $any$ O $any$ O O O $AppInfo$ O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O O $any$ O O O O O $void$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O O $any$ O O $AppInfo$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $boolean$ O O O $string$ O O O $null$ O O O $any$ O O O $any$ O $any$ O ${}$ O O O O $boolean$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O O O O $Promise$ O $AppInfo$ O O $any$ O $any$ O O O O O $string$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O O O O O O $any[]$ O $any$ O $any$ O $string$ O O O O O O O $any[]$ O O O O O O O O O O O $void$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O O O O $Promise$ O $AppInfo$ O $LuisResponse$ O $string$ O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $Promise$ O $AppInfo$ O $boolean$ O O O O O O O $void$ O O O O $string$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $boolean$ O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $Promise$ O $AppInfo$ O O O O O O O $void$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $number$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $number$ O $number$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O $number$ O O O O O $void$ O $number$ O O $void$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $TrainStatus.UpToDate$ O $any$ O $any$ O $any$ O $any$ O $TrainStatus.Success$ O O O $void$ O $number$ O O $void$ O O O O O O O O O O O O O O $void$ O O O O $any$ O O $any$ O O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O
import { LuisAppInfo } from 's' ; import { LuisClient } from 's' ; jest . mock ( 's' , ( ) => ( { get : ( ) => null , set : ( ) => null , } ) ) ; describe ( 's' , ( ) => { const appInfo = { appId : 's' , key : 's' , appInfo : { authorized : true , isDispatchApp : false , appId : 's' , } , } ; it ( 's' , ( ) => { const client = new LuisClient ( appInfo ) ; expect ( ( client as any ) . luisAppInfo ) . toBe ( appInfo ) ; expect ( ( client as any ) . _client ) . toBeTruthy ( ) ; } ) ; describe ( 's' , ( ) => { let client ; const mockGetApp = jest . fn ( ) . mockResolvedValue ( { _response : { status : 0 , parsedBody : { activeVersion : 's' } } } ) ; const mockListApps = jest . fn ( ) . mockResolvedValue ( [ ] ) ; const mockListIntents = jest . fn ( ) . mockResolvedValue ( { _response : { parsedBody : [ ] } } ) ; const mockAddExample = jest . fn ( ) . mockResolvedValue ( { _response : { status : 0 } } ) ; const mockPublishApp = jest . fn ( ) . mockResolvedValue ( { _response : { status : 0 } } ) ; const mockTrainVersion = jest . fn ( ) . mockResolvedValue ( { _response : { status : 0 } } ) ; const mockGetStatus = jest . fn ( ) . mockResolvedValue ( { _response : { status : 0 } , every : ( ) => true } ) ; const mockClient = { apps : { get : mockGetApp , list : mockListApps , publish : mockPublishApp , } , examples : { add : mockAddExample , } , model : { listIntents : mockListIntents , } , train : { getStatus : mockGetStatus , trainVersion : mockTrainVersion , } , } ; beforeEach ( ( ) => { client = new LuisClient ( appInfo ) ; ( client as any ) . configureClient = jest . fn ( ( ) => { ( client as any ) . _client = mockClient ; } ) ; mockAddExample . mockClear ( ) ; mockGetApp . mockClear ( ) ; mockGetStatus . mockClear ( ) ; mockListApps . mockClear ( ) ; mockListIntents . mockClear ( ) ; mockPublishApp . mockClear ( ) ; mockTrainVersion . mockClear ( ) ; } ) ; it ( 's' , async ( ) => { expect ( await client . getLoggedInUserApps ( ) ) . toEqual ( [ ] ) ; } ) ; it ( 's' , async ( ) => { expect ( await client . getApplicationIntents ( appInfo . appInfo ) ) . toEqual ( [ ] ) ; } ) ; it ( 's' , async ( ) => { const mockLuisResponse = { query : 's' , entities : [ { type : 's' , startIndex : 0 , endIndex : 0 } ] , } ; try { await client . reassignIntent ( appInfo . appInfo , mockLuisResponse , 's' ) ; } catch ( e ) { throw new Error ( 's' ) ; } } ) ; it ( 's' , async ( ) => { const mockLuisResponse = { query : 's' , entities : [ { type : 's' , startIndex : 0 , endIndex : 0 } ] , } ; mockAddExample . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; try { await client . reassignIntent ( appInfo . appInfo , mockLuisResponse , 's' ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const mockAppInfo = { activeVersion : 's' , appId : 's' , endpoints : { PRODUCTION : { endpointRegion : 's' } } , } ; try { await client . publish ( mockAppInfo , false ) ; } catch ( e ) { throw new Error ( 's' ) ; } } ) ; it ( 's' , async ( ) => { const mockAppInfo = { activeVersion : 's' , appId : 's' , endpoints : { PRODUCTION : { endpointRegion : 's' } } , } ; mockPublishApp . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; try { await client . publish ( mockAppInfo , false ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const mockAppInfo = { endpoints : { STAGING : { } } } ; try { await client . publish ( mockAppInfo , true ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const info = await client . getApplicationInfo ( ) ; expect ( info ) . toEqual ( { activeVersion : 's' , authorized : true , appId : 's' , isDispatchApp : false } ) ; } ) ; it ( 's' , async ( ) => { mockGetApp . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; const info = await client . getApplicationInfo ( ) ; expect ( info ) . toEqual ( { authorized : false , activeVersion : 's' , name : null , appId : 's' , endpoints : { } , isDispatchApp : false , } ) ; } ) ; it ( 's' , async ( ) => { mockGetApp . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; ( client as any ) . luisAppInfo . appId = 's' ; const info = await client . getApplicationInfo ( ) ; expect ( info ) . toEqual ( { authorized : false , activeVersion : 's' , name : null , appId : 's' , endpoints : { } , isDispatchApp : false , } ) ; } ) ; it ( 's' , async ( ) => { mockGetApp . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; try { await client . getApplicationInfo ( ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { const result = await client . train ( { } as any ) ; expect ( result ) . toBe ( undefined ) ; } ) ; it ( 's' , async ( ) => { mockTrainVersion . mockResolvedValueOnce ( { _response : { status : 0 } } ) ; try { await client . train ( { } as any ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( new Error ( 's' ) ) ; } } ) ; it ( 's' , async ( ) => { mockGetStatus . mockResolvedValue ( { _response : { status : 0 } } ) ; try { await client . train ( { } as any ) ; throw new Error ( 's' ) ; } catch ( e ) { expect ( e ) . toEqual ( 's' ) ; } } , 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $LuisAppInfo$ O O $string$ O O O $string$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O $any$ O O O O O O O O $LuisClient$ O O $any$ O $any$ O O $any$ O O $LuisClient$ O O O O $any$ O O $any$ O $any$ O O $any$ O O $LuisClient$ O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $LuisClient$ O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $undefined[]$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O O $number$ O O O O $boolean$ O O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $LuisClient$ O O $any$ O $any$ O O O $LuisClient$ O O O O $any$ O $any$ O $any$ O O O O O O $LuisClient$ O O O O $any$ O $complex$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $LuisClient$ O $Promise<any>$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O $LuisClient$ O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $string$ O O O $complex$ O O O $string$ O O O $number$ O O O $number$ O O O O O O O O O O $LuisClient$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $string$ O O O $complex$ O O O $string$ O O O $number$ O O O $number$ O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O O O $LuisClient$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O O O O O O $LuisClient$ O $Promise<any>$ O $any$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O O O $LuisClient$ O $Promise<any>$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $complex$ O O ${}$ O O O O O O O O O $LuisClient$ O $Promise<any>$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $LuisClient$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $boolean$ O O O $string$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O $any$ O O $LuisClient$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $string$ O O O $null$ O O O $string$ O O O ${}$ O O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O $LuisClient$ O O O O $any$ O $any$ O O O O $any$ O O $LuisClient$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $string$ O O O $null$ O O O $string$ O O O ${}$ O O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O O O $LuisClient$ O $Promise<any>$ O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $LuisClient$ O $Promise<any>$ O O O O O O O $any$ O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O O O $LuisClient$ O $Promise<any>$ O O O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O O O $LuisClient$ O $Promise<any>$ O O O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O
'js' const { DefinePlugin , WatchIgnorePlugin } = require ( 's' ) ; const CopyWebpackPlugin = require ( 's' ) ; const path = require ( 's' ) ; module . exports = { entry : { luis : path . resolve ( 's' ) , } , devtool : 's' , target : 's' , module : { rules : [ { test : "s" , use : [ 's' , { loader : 's' , options : { localIdentName : 's' , modules : true , sass : false , namedExport : true , camelCase : true , sourcemaps : true , banner : 's' , } , } , 's' , 's' , ] , } , { test : "s" , use : [ 's' ] , } , { test : "s" , exclude : [ "s" ] , use : { loader : 's' , options : { ignore : [ 's' ] , } , } , } , ] , } , devServer : { hot : true , inline : true , port : 0 , historyApiFallback : false , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' ] , } , output : { path : path . resolve ( 's' ) , filename : 's' , publicPath : 's' , } , stats : { warnings : false , } , externals : { } , plugins : [ new WatchIgnorePlugin ( [ 's' , 's' , 's' ] ) , new CopyWebpackPlugin ( [ { from : 's' , to : 's' , } , { from : 's' , to : 's' , } , { from : 's' , to : 's' , } , ] ) , new DefinePlugin ( { process : { env : { } } , } ) , ] , } ;	O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O O $RegExp$ O O O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O $RegExp$ O O O $string[]$ O O O O O O O O $RegExp$ O O O $RegExp[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $complex$ O O $boolean$ O O O O O ${}$ O O O O $any[]$ O O O $any$ O O O O O O O O O O O $any$ O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O O O $any$ O O $complex$ O O ${}$ O O O O O O O O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
export interface Answer { id : number ; text : string ; score : number ; filters : any ; }	O O $any$ O $number$ O O O $string$ O O O $number$ O O O $any$ O O O O
import { MessageActivity } from 's' ; export interface QnAMakerTraceInfo { message : MessageActivity ; queryResults : QueryResult [ ] ; knowledgeBaseId : string ; scoreThreshold : number ; top : number ; strictFilters : any ; metadataBoost : any ; } export interface QueryResult { questions : string [ ] ; answer : string ; score : number ; metadata : any ; source : string ; id : number ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $QueryResult[]$ O $any$ O O O $string$ O O O $number$ O O O $number$ O O O $any$ O O O $any$ O O O O O O $any$ O $string[]$ O O O O O $string$ O O O $number$ O O O $any$ O O O $string$ O O O $number$ O O O O
import { ServiceBase } from 's' ; const operations = require ( 's' ) ; const knowledgebase = require ( 's' ) ; class QnAMakerClientError extends Error { private static getMessage ( message , statusCode : number | undefined ) { let errorMessage = message ; if ( statusCode ) { errorMessage += 's' + statusCode ; } return errorMessage ; } constructor ( message , statusCode ? ) { super ( QnAMakerClientError . getMessage ( message , statusCode ) ) ; } } const MaxRetries = 0 ; const WaitIntervalInMs = 0 ; export interface QnAKbInfo { kbId : string ; subscriptionKey : string ; baseUri : string ; } export class QnAMakerClient { private qnaMakerKbInfo : QnAKbInfo ; private knowledgebase : any ; private operations : any ; constructor ( qnaMakerKbInfo ) { this . qnaMakerKbInfo = qnaMakerKbInfo ; this . knowledgebase = new knowledgebase ( ) ; this . operations = new operations ( ) ; } public async updateKnowledgebase ( kbId , requestBody ) < any > { this . configureClient ( ) ; const params = { kbId , } ; let result = await this . knowledgebase . updateKnowledgebase ( params , requestBody ) ; if ( result . status !== 0 ) { throw new QnAMakerClientError ( 's' , result . statusCode ) ; } const resultJson = await result . json ( ) ; let retryCounter = 0 ; return new Promise ( ( resolve , reject ) => { let intervalId ; const callLoop = async ( ) => { result = await this . operations . getOperationDetails ( { operationId : resultJson . operationId , } ) ; if ( retryCounter ++ >= MaxRetries ) { clearInterval ( intervalId ) ; reject ( 's' ) ; } if ( result . status !== 0 ) { return ; } const trainingStatus = await result . json ( ) ; if ( trainingStatus . operationState === 's' ) { clearInterval ( intervalId ) ; resolve ( result ) ; } } ; intervalId = window . setInterval ( callLoop , WaitIntervalInMs ) ; } ) ; } public async publish ( kbId ) < any > { this . configureClient ( ) ; const params = { kbId , } ; const result = await this . knowledgebase . publishKnowledgebase ( params ) ; return result ; } public async getOperationDetails ( opId ) < any > { this . configureClient ( ) ; const params = { operationId : opId , } ; const result = await this . operations . getOperationDetails ( params ) ; return result ; } private configureClient ( ) { ServiceBase . config = { endpointBasePath : this . qnaMakerKbInfo . baseUri , subscriptionKey : this . qnaMakerKbInfo . subscriptionKey , } ; } }	O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $ErrorConstructor$ O O O $string$ O $string$ O $number$ O O O O O O O $string$ O $string$ O O O $number$ O O $string$ O O O $number$ O O O $string$ O O O O $string$ O $number$ $number$ O O O O $any$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O $QnAKbInfo$ O $any$ O O $any$ O O O O $any$ O O O O O $QnAKbInfo$ O O O O $QnAKbInfo$ O $QnAKbInfo$ O O O $any$ O O $any$ O O O O O $any$ O O $any$ O O O O O O $Promise$ O $string$ O $any$ O O O O O O O $void$ O O O O $complex$ O O $string$ O O O O $any$ O O O O $any$ O $any$ O $complex$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $number$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $number$ O O $Promise<void>$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $number$ O O O O O $void$ O $number$ O O $void$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O $number$ O O $void$ O $any$ O O O O O $number$ O $complex$ O $number)$ O $Promise<void>$ O O O O O O O O O O $Promise$ O $string$ O O O O O O O $void$ O O O O $complex$ O O $string$ O O O O $any$ O O O O $any$ O $any$ O $complex$ O O O $any$ O O O O $Promise$ O $string$ O O O O O O O $void$ O O O O $complex$ O O $string$ O $string$ O O O O $any$ O O O O $any$ O $any$ O $complex$ O O O $any$ O O O $void$ O O O $any$ O $any$ O O $string$ O O O $QnAKbInfo$ O $string$ O $string$ O O O $QnAKbInfo$ O $string$ O O O O O
'js' const { WatchIgnorePlugin } = require ( 's' ) ; const UglifyJsPlugin = require ( 's' ) ; const path = require ( 's' ) ; const buildConfig = mode => { const config = { optimization : { minimizer : [ new UglifyJsPlugin ( { cache : true , cacheKeys ( defaultCacheKeys ) { delete defaultCacheKeys [ 's' ] ; return Object . assign ( { } , defaultCacheKeys , { 's' : require ( 's' ) . version } ) ; } , minify ( file , sourceMap ) { const uglifyJsOptions = { } ; if ( sourceMap ) { uglifyJsOptions . sourceMap = { content : sourceMap , } ; } return require ( 's' ) . minify ( file , uglifyJsOptions ) ; } , } ) , ] , } , entry : { qna : path . resolve ( 's' ) , } , module : { rules : [ { test : "s" , use : [ 's' , { loader : 's' , options : { localIdentName : 's' , modules : true , sass : false , namedExport : true , camelCase : true , sourcemaps : true , banner : 's' , } , } , 's' , 's' , ] , } , { test : "s" , use : [ 's' ] , } , { test : "s" , exclude : [ "s" ] , use : { loader : 's' , options : { ignore : [ 's' ] , } , } , } , ] , } , devServer : { inline : true , port : 0 , historyApiFallback : false , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' ] , } , output : { path : path . resolve ( 's' ) , filename : 's' , publicPath : 's' , } , stats : { warnings : false , } , } ; if ( mode === 's' ) { config . plugins = [ new WatchIgnorePlugin ( [ 's' , 's' , 's' ] ) ] ; } return config ; } ; module . exports = function ( env , argv ) { return buildConfig ( argv . mode ) ; } ;	O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O $any$ O O O $complex$ O O $complex$ O O $any[]$ O O O $any$ O O $boolean$ O O O $any$ O $any$ O O O $any$ O O O O O $ObjectConstructor$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $complex$ O O O O O O $any$ O O $complex$ O $complex$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $complex$ O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O $RegExp$ O O O $string[]$ O O O O O O O O $RegExp$ O O O $RegExp[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $boolean$ O O O $number$ O O O $boolean$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $complex$ O O $boolean$ O O O O O O O O O $any$ O O O O $complex$ O $any$ O O O $any$ O O O O O O O O O O O O O $complex$ O O O $complex$ O $complex$ O O O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import { Activity } from 's' ; import { IBotConfiguration } from 's' ; import { ExtensionChannel } from 's' ; export interface InspectorHost { readonly bot : IBotConfiguration ; readonly logger : { log ( message ) : ( ) => void ; error ( message ) : ( ) => void ; logLuisEditorDeepLink ( message ) : ( ) => void ; } ; on ( event : ExtensionChannel . Inspect , handler : ( activity ) => void ) : ( ) => void ; on ( event : ExtensionChannel . BotUpdated , handler : ( bot ) => void ) : ( ) => void ; on ( event : ExtensionChannel . AccessoryClick , handler : ( id , currentState ) => void ) : ( ) => void ; on ( event : ExtensionChannel . Theme , handler : ( themeInfo : { themeName : string ; themeComponents : string [ ] } ) => void ) : void ; createAriaAlert ( msg ) : void ; enableAccessory ( id , enabled ) : void ; setAccessoryState ( id , state ) : void ; setInspectorTitle ( title ) : void ; trackEvent ( name , properties ? : { [ key ] : any } ) : void ; setHighlightedObjects ( documentId , items : Activity | Activity [ ] ) : void ; setInspectorObjects ( documentId , items : Activity | Activity [ ] ) : void ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O $complex$ O O $void$ O $string$ O O O O O O O $void$ O $string$ O O O O O O O $void$ O $string$ O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O $void$ O O $Activity$ O O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O $void$ O O $IBotConfiguration$ O O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O $void$ O O $string$ O $string$ O O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O $void$ O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O O O O $void$ O $string$ O O O O $void$ O $string$ O $boolean$ O O O O $void$ O $string$ O $string$ O O O O $void$ O $string$ O O O O $void$ O $string$ O $complex$ O O O O $string$ O O O O O O O O $void$ O $string$ O $any$ O $any$ O $any$ O O O O O O $void$ O $string$ O $any$ O $any$ O $any$ O O O O O O O
export * from 's' ;	O O O O O
export * from 's' ;	O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
import * as nodeUrl from 's' ; import { 0 as 0 } from 's' ; import 0 from 's' ; export function 0 ( ) { return 0 ( ) . toString ( ) ; } export function uniqueId ( ) { return 0 ( ) . toString ( ) ; } export function isObject ( item ) { return item && typeof item === 's' && ! Array . isArray ( item ) ; } export function isLocalHostUrl ( url ) { const localhostNames = [ 's' , 's' , 's' ] ; let parsedUrl ; if ( nodeUrl ) { try { parsedUrl = nodeUrl . parse ( url ) ; } catch ( e ) { return false ; } } else { try { parsedUrl = new URL ( url ) ; } catch ( e ) { return false ; } } return localhostNames . some ( name => parsedUrl . hostname === name ) ; }	O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O $string$ O O O O $any$ O O O $any$ O O O O O O $string$ O O O O $any$ O O O $any$ O O O O O O $boolean$ O $any$ O O O $any$ O O $any$ O O O O $ArrayConstructor$ O $complex$ O $any$ O O O O O $boolean$ O $string$ O O O $string[]$ O O O O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O O O O $any$ O O $complex$ O $string$ O O O O O $any$ O O O O O O O O $string[]$ O $boolean$ O $string$ O $any$ O $any$ O $string$ O O O
export interface ChannelAccount { id ? : string ; name ? : string ; role ? : string ; }	O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O O
import { ChannelAccount } from 's' ; export interface ConversationAccount extends ChannelAccount { isGroup ? : boolean ; }	O O $any$ O O O O O O $any$ O $any$ O $boolean$ O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
export interface ETagObject { eTag ? : string ; }	O O $any$ O $string$ O O O O O
import { Activity } from 's' ; import { ETagObject } from 's' ; export interface ConversationHistory extends ETagObject { activities : Activity [ ] ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any[]$ O $any$ O O O O
export type ChannelService = 's' | 's' ;	O O $any$ O O O O O
export type EmulatorMode = 's' | 's' | 's' | 's' ;	O O $any$ O O O O O O O O O
export interface User { id : string ; name : string ; }	O O $any$ O $string$ O O O $string$ O O O O
import { ConversationParameters } from 's' ; import { ChannelService } from 's' ; import { EmulatorMode } from 's' ; import { User } from 's' ; export interface StartConversationParams extends ConversationParameters { endpoint ? : string ; appId ? : string ; appPassword ? : string ; user ? : User ; mode ? : EmulatorMode ; channelService ? : ChannelService ; conversationId ? : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $User$ O O $any$ O $EmulatorMode$ O O $any$ O $ChannelService$ O O $any$ O $string$ O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
export interface Attachment { contentType ? : string ; contentUrl ? : string ; content ? : any ; name ? : string ; thumbnailUrl ? : string ; }	O O $any$ O $string$ O O O O $string$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O O
export interface AttachmentData { type : string ; name : string ; 0 : string ; 0 : string ; }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O
export interface AttachmentView { viewId : string ; size : number ; }	O O $any$ O $string$ O O O $number$ O O O O
import { AttachmentView } from 's' ; export interface AttachmentInfo { name : string ; type : string ; views : AttachmentView [ ] ; }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $AttachmentView[]$ O $any$ O O O O
export enum AttachmentContentTypes { animationCard = 's' , audioCard = 's' , heroCard = 's' , receiptCard = 's' , signInCard = 's' , oAuthCard = 's' , thumbnailCard = 's' , videoCard = 's' , }	O O $any$ O $AttachmentContentTypes.animationCard$ O O O $AttachmentContentTypes.audioCard$ O O O $AttachmentContentTypes.heroCard$ O O O $AttachmentContentTypes.receiptCard$ O O O $AttachmentContentTypes.signInCard$ O O O $AttachmentContentTypes.oAuthCard$ O O O $AttachmentContentTypes.thumbnailCard$ O O O $AttachmentContentTypes.videoCard$ O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
export interface CardAction { image : string ; title : string ; type : string ; value ? : any ; }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $any$ O O O O O
import { CardAction } from 's' ; export interface CardImage { url : string ; alt : string ; tap : CardAction ; }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $CardAction$ O $any$ O O
export interface CardMediaUrl { url : string ; profile : string ; }	O O $any$ O $string$ O O O $string$ O O O O
export interface Fact { key : string ; value : string ; }	O O $any$ O $string$ O O O $string$ O O O O
import { CardAction } from 's' ; export interface Keyboard { buttons : CardAction [ ] ; }	O O $any$ O O O O O O $any$ O $CardAction[]$ O $any$ O O O O
import { CardAction } from 's' ; import { CardImage } from 's' ; import { CardMediaUrl } from 's' ; import { Keyboard } from 's' ; export interface MediaCard extends Keyboard { title : string ; subtitle : string ; text : string ; image : CardImage ; media : CardMediaUrl [ ] ; autoloop : boolean ; autostart : boolean ; shareable : boolean ; buttons : CardAction [ ] ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $CardImage$ O $any$ O $CardMediaUrl[]$ O $any$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $CardAction[]$ O $any$ O O O O
import { CardAction } from 's' ; export interface OAuthCard { text : string ; connectionName : string ; buttons : CardAction [ ] ; }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $CardAction[]$ O $any$ O O O O
import { CardAction } from 's' ; import { CardImage } from 's' ; export interface ReceiptItem { title : string ; subtitle : string ; text : string ; image : CardImage ; price : string ; quantity : string ; tap : CardAction ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $CardImage$ O $any$ O $string$ O O O $string$ O O O $CardAction$ O $any$ O O
import { CardAction } from 's' ; import { Fact } from 's' ; import { ReceiptItem } from 's' ; export interface ReceiptCard { title : string ; items : ReceiptItem [ ] ; facts : Fact [ ] ; tap : CardAction ; total : string ; tax : string ; vat : string ; buttons : CardAction [ ] ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $ReceiptItem[]$ O $any$ O O O $Fact[]$ O $any$ O O O $CardAction$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $CardAction[]$ O $any$ O O O O
import { CardAction } from 's' ; export interface SigninCard { text : string ; buttons : CardAction [ ] ; }	O O $any$ O O O O O O $any$ O $string$ O O O $CardAction[]$ O $any$ O O O O
import { CardAction } from 's' ; import { CardImage } from 's' ; import { Keyboard } from 's' ; export interface ThumbnailCard extends Keyboard { title : string ; subtitle : string ; text : string ; images : CardImage [ ] ; tap : CardAction ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $CardImage[]$ O $any$ O O O $CardAction$ O $any$ O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum EmulatorChannel { CreateAriaAlert = 's' , EnableAccessory = 's' , Log = 's' , LogError = 's' , LogLuisDeepLink = 's' , SetAccessoryState = 's' , SetHightlightedObjects = 's' , SetInspectorObjects = 's' , SetInspectorTitle = 's' , TrackEvent = 's' , } export enum ExtensionChannel { AccessoryClick = 's' , BotUpdated = 's' , ChatLogUpdated = 's' , HighlightedObjectsUpdated = 's' , Inspect = 's' , Theme = 's' , ToggleDevTools = 's' , }	O O $any$ O $EmulatorChannel.CreateAriaAlert$ O O O $EmulatorChannel.EnableAccessory$ O O O $EmulatorChannel.Log$ O O O $EmulatorChannel.LogError$ O O O $EmulatorChannel.LogLuisDeepLink$ O O O $EmulatorChannel.SetAccessoryState$ O O O $EmulatorChannel.SetHightlightedObjects$ O O O $EmulatorChannel.SetInspectorObjects$ O O O $EmulatorChannel.SetInspectorTitle$ O O O $EmulatorChannel.TrackEvent$ O O O O O O $any$ O $ExtensionChannel.AccessoryClick$ O O O $ExtensionChannel.BotUpdated$ O O O $ExtensionChannel.ChatLogUpdated$ O O O $ExtensionChannel.HighlightedObjectsUpdated$ O O O $ExtensionChannel.Inspect$ O O O $ExtensionChannel.Theme$ O O O $ExtensionChannel.ToggleDevTools$ O O O O
export * from 's' ;	O O O O O
export enum LogLevel { Debug , Info , Warn , Error , }	O O $any$ O $LogLevel.Debug$ O $LogLevel.Info$ O $LogLevel.Warn$ O $LogLevel.Error$ O O
import { Activity } from 's' ; import { LogLevel } from 's' ; export enum LogItemType { Text = 's' , ExternalLink = 's' , InspectableObject = 's' , NetworkRequest = 's' , NetworkResponse = 's' , SummaryText = 's' , OpenAppSettings = 's' , Exception = 's' , NgrokExpiration = 's' , LuisEditorDeepLink = 's' , } export type LogItemPayload = | TextLogItem | ExternalLinkLogItem | InspectableObjectLogItem | NetworkRequestLogItem | NetworkResponseLogItem | SummaryTextLogItem | OpenAppSettingsLogItem | ExceptionLogItem | NgrokExpirationLogItem | LuisEditorDeepLinkLogItem ; export interface LogItem < T = LogItemPayload > { type : LogItemType ; payload : T ; } export interface TextLogItem { level : LogLevel ; text : string ; } export interface ExternalLinkLogItem { text : string ; hyperlink : string ; } export interface InspectableObjectLogItem { text : string ; obj : Activity | { [ propName ] : { } } ; } export interface NetworkRequestLogItem { facility ? : string ; body ? : string ; headers ? : { [ header ] : number | string | string [ ] } ; method ? : string ; url ? : string ; } export interface NetworkResponseLogItem { body ? : string ; headers ? : { [ header ] : number | string | string [ ] } ; statusCode ? : number ; statusMessage ? : string ; srcUrl ? : string ; } export interface SummaryTextLogItem { obj : any ; } export interface OpenAppSettingsLogItem { text : string ; } export interface LuisEditorDeepLinkLogItem { text : string ; } export interface ExceptionLogItem { err : any ; } export interface NgrokExpirationLogItem { text : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $LogItemType.Text$ O O O $LogItemType.ExternalLink$ O O O $LogItemType.InspectableObject$ O O O $LogItemType.NetworkRequest$ O O O $LogItemType.NetworkResponse$ O O O $LogItemType.SummaryText$ O O O $LogItemType.OpenAppSettings$ O O O $LogItemType.Exception$ O O O $LogItemType.NgrokExpiration$ O O O $LogItemType.LuisEditorDeepLink$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $LogItemType$ O $any$ O $T$ O $any$ O O O O $any$ O $LogLevel$ O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O O O $string$ O O O O O O O O O $any$ O $string$ O O O O $string$ O O O O $complex$ O O O O $string$ O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $complex$ O O O O $string$ O O O O O O O O O O O $number$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O O
import { LogItem } from 's' ; export interface LogEntry < T = any > { timestamp : number ; items : LogItem < T > [ ] ; }	O O $any$ O O O O O O $any$ O $any$ O O O O $number$ O O O $LogItem<T>[]$ O $any$ O $any$ O O O O O
import { LogItem } from 's' ; export interface LogService { logToChat ( conversationId , ... items : LogItem [ ] ) : void ; }	O O $any$ O O O O O O $any$ O $void$ O $string$ O O $LogItem<LogItemPayload>[]$ O $any$ O O O O O O O
import { Activity } from 's' ; import { LogEntry } from 's' ; import { ExceptionLogItem , ExternalLinkLogItem , InspectableObjectLogItem , LogItem , LogItemPayload , LogItemType , LuisEditorDeepLinkLogItem , NetworkRequestLogItem , NetworkResponseLogItem , NgrokExpirationLogItem , OpenAppSettingsLogItem , SummaryTextLogItem , TextLogItem , } from 's' ; import { LogLevel } from 's' ; export function makeEnumerableObject ( src ) { if ( typeof src !== 's' ) { return src ; } const dst = { } ; const keys = Object . getOwnPropertyNames ( src ) ; keys . forEach ( key => ( dst [ key ] = src [ key ] ) ) ; return dst ; } export function textItem ( level , text ) < TextLogItem > { return { type : LogItemType . Text , payload : { level , text , } , } ; } export function externalLinkItem ( text , hyperlink ) < ExternalLinkLogItem > { return { type : LogItemType . ExternalLink , payload : { text , hyperlink , } , } ; } export function inspectableObjectItem ( text , obj ) < InspectableObjectLogItem > { return { type : LogItemType . InspectableObject , payload : { text , obj , } , } ; } export function summaryTextItem ( obj ) < SummaryTextLogItem > { return { type : LogItemType . SummaryText , payload : { obj , } , } ; } export function appSettingsItem ( text ) < OpenAppSettingsLogItem > { return { type : LogItemType . OpenAppSettings , payload : { text , } , } ; } export function exceptionItem ( err ) < ExceptionLogItem > { return { type : LogItemType . Exception , payload : { err : makeEnumerableObject ( err ) , } , } ; } export function networkRequestItem ( facility , body , headers , method , url ) < NetworkRequestLogItem > { return { type : LogItemType . NetworkRequest , payload : { facility , body , headers , method , url , } , } ; } export function networkResponseItem ( body , headers , statusCode , statusMessage , srcUrl ) < NetworkResponseLogItem > { return { type : LogItemType . NetworkResponse , payload : { body , headers , statusCode , statusMessage , srcUrl , } , } ; } export function ngrokExpirationItem ( text ) < NgrokExpirationLogItem > { return { type : LogItemType . NgrokExpiration , payload : { text , } , } ; } export function logEntry ( ... items : LogItem < LogItemPayload > [ ] ) { return { timestamp : Date . now ( ) , items : [ ... items ] , } ; } export function luisEditorDeepLinkItem ( text ) < LuisEditorDeepLinkLogItem > { return { type : LogItemType . LuisEditorDeepLink , payload : { text , } , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O ${}$ O O O O O $string[]$ O $ObjectConstructor$ O $string[]$ O $any$ O O $string[]$ O $void$ O $string$ O O ${}$ O $string$ O O $any$ O $string$ O O O O O ${}$ O O O O $LogItem$ O $LogLevel$ O $string$ O O $any$ O O O O $LogItemType.Text$ O $any$ O $LogItemType.Text$ O $complex$ O O $LogLevel$ O $string$ O O O O O O O O $LogItem$ O $string$ O $string$ O O $any$ O O O O $LogItemType.ExternalLink$ O $any$ O $LogItemType.ExternalLink$ O $complex$ O O $string$ O $string$ O O O O O O O O $LogItem$ O $string$ O $Activity$ O O $any$ O O O O $LogItemType.InspectableObject$ O $any$ O $LogItemType.InspectableObject$ O $complex$ O O $string$ O $any$ O O O O O O O O $LogItem$ O $Activity$ O O $any$ O O O O $LogItemType.SummaryText$ O $any$ O $LogItemType.SummaryText$ O $complex$ O O $any$ O O O O O O O O $LogItem$ O $string$ O O $any$ O O O O $LogItemType.OpenAppSettings$ O $any$ O $LogItemType.OpenAppSettings$ O $complex$ O O $string$ O O O O O O O O $LogItem$ O $any$ O O $any$ O O O O $LogItemType.Exception$ O $any$ O $LogItemType.Exception$ O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $LogItem$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $LogItemType.NetworkRequest$ O $any$ O $LogItemType.NetworkRequest$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $LogItem$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $LogItemType.NetworkResponse$ O $any$ O $LogItemType.NetworkResponse$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $LogItem$ O $string$ O O $any$ O O O O $LogItemType.NgrokExpiration$ O $any$ O $LogItemType.NgrokExpiration$ O $complex$ O O $string$ O O O O O O O O $LogEntry$ O O $LogItem<LogItemPayload>[]$ O $any$ O $any$ O O O O O O O $number$ O $DateConstructor$ O $number$ O O O $LogItem<LogItemPayload>[]$ O O O $LogItem<LogItemPayload>[]$ O O O O O O O $LogItem$ O $string$ O O $any$ O O O O $LogItemType.LuisEditorDeepLink$ O $any$ O $LogItemType.LuisEditorDeepLink$ O $complex$ O O $string$ O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
export interface PaymentAddress { addressLine : string [ ] ; city : string ; country : string ; dependentLocality : string ; languageCode : string ; organization : string ; phone : string ; postalCode : string ; recipient : string ; region : string ; sortingCode : string ; }	O O $any$ O $string[]$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O
export interface CheckoutConversationSession { paymentActivityId : string ; checkoutConversationId : string ; checkoutFromId : string ; }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O O
export interface PaymentCurrencyAmount { currency : string ; currencySystem : string ; value : string ; }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O O
import { PaymentCurrencyAmount } from 's' ; export interface PaymentItem { label : string ; pending ? : boolean ; amount : PaymentCurrencyAmount ; }	O O $any$ O O O O O O $any$ O $string$ O O O $boolean$ O O O O $PaymentCurrencyAmount$ O $any$ O O
import { PaymentItem } from 's' ; export interface PaymentDetailsModifier { additionalDisplayItems : PaymentItem [ ] ; data : any ; supportedMethods : string [ ] ; total : PaymentItem ; }	O O $any$ O O O O O O $any$ O $PaymentItem[]$ O $any$ O O O $any$ O O O $string[]$ O O O O O $PaymentItem$ O $any$ O O
import { PaymentCurrencyAmount } from 's' ; export interface PaymentShippingOption { id : string ; label : string ; selected ? : boolean ; amount : PaymentCurrencyAmount ; }	O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $boolean$ O O O O $PaymentCurrencyAmount$ O $any$ O O
import { PaymentDetailsModifier } from 's' ; import { PaymentItem } from 's' ; import { PaymentShippingOption } from 's' ; export interface PaymentDetails { total : PaymentItem ; displayItems : PaymentItem [ ] ; shippingOptions : PaymentShippingOption [ ] ; modifiers : PaymentDetailsModifier [ ] ; error : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $PaymentItem$ O $any$ O $PaymentItem[]$ O $any$ O O O $PaymentShippingOption[]$ O $any$ O O O $PaymentDetailsModifier[]$ O $any$ O O O $string$ O O O O
export interface PaymentMethodData { supportedMethods : string [ ] ; data : any ; }	O O $any$ O $string[]$ O O O O O $any$ O O O O
export enum PaymentOperations { PaymentCompleteOperationName = 's' , UpdateShippingAddressOperationName = 's' , UpdateShippingOptionOperationName = 's' , }	O O $any$ O $PaymentOperations.PaymentCompleteOperationName$ O O O $PaymentOperations.UpdateShippingAddressOperationName$ O O O $PaymentOperations.UpdateShippingOptionOperationName$ O O O O
export interface PaymentOptions { requestPayerEmail ? : boolean ; requestPayerName ? : boolean ; requestPayerPhone ? : boolean ; requestShipping ? : boolean ; shippingType : string ; }	O O $any$ O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $string$ O O O O
import { PaymentDetails } from 's' ; import { PaymentMethodData } from 's' ; import { PaymentOptions } from 's' ; export interface PaymentRequest { details : PaymentDetails ; expires : string ; id : string ; methodData : PaymentMethodData [ ] ; options : PaymentOptions ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $PaymentDetails$ O $any$ O $string$ O O O $string$ O O O $PaymentMethodData[]$ O $any$ O O O $PaymentOptions$ O $any$ O O
import { PaymentAddress } from 's' ; export interface PaymentResponse { details : any ; methodName : string ; payerEmail : string ; payerPhone : string ; shippingAddress : PaymentAddress ; shippingOption : string ; }	O O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $PaymentAddress$ O $any$ O $string$ O O O O
import { PaymentRequest } from 's' ; import { PaymentResponse } from 's' ; export interface PaymentRequestComplete { id : string ; paymentRequest : PaymentRequest ; paymentResponse : PaymentResponse ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $PaymentRequest$ O $any$ O $PaymentResponse$ O $any$ O O
import { PaymentAddress } from 's' ; import { PaymentDetails } from 's' ; export interface PaymentRequestUpdate { details : PaymentDetails ; id : string ; shippingAddress : PaymentAddress ; shippingOption : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $PaymentDetails$ O $any$ O $string$ O O O $PaymentAddress$ O $any$ O $string$ O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ConversationResourceResponse { id : string ; activityId ? : string ; }	O O $any$ O $string$ O O O $string$ O O O O O
export interface Error { code ? : string ; message ? : string ; }	O O $any$ O $string$ O O O O $string$ O O O O O
import { Error } from 's' ; export interface ErrorResponse { error : Error ; }	O O $any$ O O O O O O $any$ O $Error$ O $any$ O O
export interface ResourceResponse { id : string ; }	O O $any$ O $string$ O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { ErrorResponse } from 's' ; export interface APIException { error : ErrorResponse ; statusCode : number ; }	O O $any$ O O O O O O $any$ O $ErrorResponse$ O $any$ O $number$ O O O O
import { BotConfigurationBase } from 's' ; import { IBotConfiguration , IEndpointService } from 's' ; export interface BotConfigOverrides { readonly endpoint ? : Partial < IEndpointService > ; } export interface BotConfigWithPath extends IBotConfiguration { path ? : string ; overrides ? : BotConfigOverrides ; } export class BotConfigWithPathImpl extends BotConfigurationBase implements BotConfigWithPath { public path = 's' ; public overrides = null ; public static fromJSON ( source < BotConfigWithPathImpl > ) { const botConfig = super . fromJSON ( source ) as Partial < BotConfigWithPathImpl > ; const { path = 's' , overrides = null } = source ; const botConfigWithPath = new BotConfigWithPathImpl ( ) ; Object . assign ( botConfigWithPath , botConfig , { path , overrides } ) ; return botConfigWithPath ; } public toJSON ( ) { const botConfig = super . toJSON ( ) ; const { path , overrides } = this ; return { ... botConfig , path , overrides } ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O O $BotConfigOverrides$ O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O O $any$ O O O O O $BotConfigWithPathImpl$ O $Partial$ O $any$ O O O O $Partial<BotConfigWithPathImpl>$ O O O $any$ O $Partial<BotConfigWithPathImpl>$ O O $any$ O $any$ O O O O $string$ O O O $any$ O O O O $Partial<BotConfigWithPathImpl>$ O O $BotConfigWithPathImpl$ O O $any$ O O O $ObjectConstructor$ O O O $BotConfigWithPathImpl$ O $Partial<BotConfigWithPathImpl>$ O O $string$ O $any$ O O O O $BotConfigWithPathImpl$ O O O $BotConfigWithPath$ O O O O $any$ O O O $any$ O O O O O $string$ O $any$ O O O O O O O $any$ O $string$ O $any$ O O O O
export interface BotData { eTag : string ; data : any ; }	O O $any$ O $string$ O O O $any$ O O O O
import { Activity } from 's' ; import { LogItem } from 's' ; export interface Logger { logActivity ( conversationId , activity , role ) ; logMessage ( conversationId , ... items : LogItem [ ] ) ; logException ( conversationId , err ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $string$ O $Activity$ O $string$ O O $any$ O $string$ O O $LogItem<LogItemPayload>[]$ O $any$ O O O O $any$ O $string$ O $Error$ O O O
import { LogService } from 's' ; import { Logger } from 's' ; export interface BotEmulatorOptions { fetch ? : ( url , options ) => Promise < any > ; loggerOrLogService ? : Logger | LogService ; stateSizeLimitKB ? : number ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $Promise<any>$ O O O $string$ O $any$ O O $PromiseConstructor$ O O O O $complex$ O O $any$ O $any$ O $number$ O O O O O
export interface BotEndpointOptions { fetch ? : ( url , options ) => Promise < any > ; 0 ? : boolean ; useCodeValidation ? : boolean ; }	O O $any$ O $Promise<any>$ O O O $string$ O $any$ O O $PromiseConstructor$ O O O O $boolean$ O O O O $boolean$ O O O O O
export interface Entity { type ? : string ; }	O O $any$ O $string$ O O O O O
export enum ErrorCodes { ServiceError = 's' , BadArgument = 's' , BadSyntax = 's' , MissingProperty = 's' , MessageSizeTooBig = 's' , }	O O $any$ O $ErrorCodes.ServiceError$ O O O $ErrorCodes.BadArgument$ O O O $ErrorCodes.BadSyntax$ O O O $ErrorCodes.MissingProperty$ O O O $ErrorCodes.MessageSizeTooBig$ O O O O
export interface SpeechAuthenticationToken { accessToken : string ; region : string ; expireAt : number ; tokenLife : number ; }	O O $any$ O $string$ O O O $string$ O O O $number$ O O O $number$ O O O O
import { Activity } from 's' ; export interface TranscriptRecord { type : string ; activity : Activity ; }	O O $any$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IEndpointService } from 's' ; import { BotConfigOverrides , BotConfigWithPath , BotConfigWithPathImpl } from 's' ; export function applyBotConfigOverrides ( targetBot , overrides ) { const botConfig = BotConfigWithPathImpl . fromJSON ( { ... targetBot , ... { overrides } , } ) ; return botConfig ; } export function botsAreTheSame ( 0 , 0 ) { if ( 0 && 0 ) { return 0 . path === 0 . path ; } return false ; } export function mergeEndpoints ( 0 , 0 < IEndpointService > ) { return { ... 0 , ... 0 } ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $BotConfigWithPath$ O $BotConfigWithPath$ O $BotConfigOverrides$ O O O $BotConfigWithPath$ O $any$ O $BotConfigWithPathImpl$ O O O $BotConfigWithPath$ O O O $BotConfigOverrides$ O O O O O O $BotConfigWithPath$ O O O O $boolean$ O $BotConfigWithPath$ O $BotConfigWithPath$ O O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O O $BotConfigWithPath$ O $string$ O $BotConfigWithPath$ O $string$ O O O O O O O O $IEndpointService$ O $IEndpointService$ O $Partial$ O $any$ O O O O O O $any$ O O $any$ O O O
export function 0 ( obj : { [ key ] : any } , isDiff = false ) { if ( ! obj ) { return null ; } let json = JSON . stringify ( obj , null , 0 ) ; json = json . replace ( "s" , 's' ) ; json = json . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; json = json . replace ( "s" , 's' ) ; let parentClassName = 's' ; json = json . replace ( "s" , match => { let className = isDiff ? 's' : 's' ; if ( match . startsWith ( 's' ) ) { if ( match . endsWith ( 's' ) ) { className = isDiff ? 's' : 's' ; if ( isDiff ) { if ( match . substr ( 0 , 0 ) === 's' ) { parentClassName = className = 's' ; } if ( match . substr ( 0 , 0 ) === 's' ) { parentClassName = className = 's' ; } } } else { className = isDiff ? 's' : 's' ; } } else if ( ! isDiff && "s" . test ( match ) ) { className = 's' ; } else if ( ! isDiff && "s" . test ( match ) ) { className = 's' ; } const isKey = className === 's' ; if ( parentClassName && parentClassName !== className ) { className = parentClassName ; parentClassName = 's' ; } if ( isKey ) { const exec = "s" . exec ( match ) ; return `template` ; } else { return `template` ; } } ) ; return json ; }	O O $string$ O $complex$ O O O $string$ O O O O O $boolean$ O O O O O O O $complex$ O O O O O O O $string$ O $JSON$ O $complex$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O O $string$ O O O $string$ O $string$ O $complex$ O O O $string$ O O O $string$ O $boolean$ O O O O O O O $string$ O $boolean$ O O O O O O O $string$ O $boolean$ O O O O O $string$ O $boolean$ O O O O O O O $boolean$ O O O O $string$ O $string$ O O O O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O O O $string$ O $string$ O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O $boolean$ O O O $boolean$ O $string$ O O O $string$ O O O O O O O O $boolean$ O O O $boolean$ O $string$ O O O $string$ O O O O O $boolean$ O $string$ O O O O O $string$ O $string$ O $string$ O O $string$ O $string$ O $string$ O O O O O O $boolean$ O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O O O O O O O O O O O O O $string$ O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { StartConversationParams } from 's' ; import { uniqueId } from 's' ; export const headers = { 's' : 's' , } ; export class ConversationService { public static addUser ( serviceUrl , conversationId , name ? , id ? ) { const url = `template` ; return fetch ( url , { headers , method : 's' , body : JSON . stringify ( [ { name , id } ] ) , } ) ; } public static removeUser ( serviceUrl , conversationId , id ) { const url = `template` ; return fetch ( url , { headers , method : 's' , body : JSON . stringify ( [ { id } ] ) , } ) ; } public static removeRandomUser ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static botContactAdded ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static botContactRemoved ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static typing ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static ping ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static deleteUserData ( serviceUrl , conversationId ) { const url = `template` ; return fetch ( url , { headers , method : 's' , } ) ; } public static getConversationEndpoint ( serverUrl , conversationId ) < Response > { const url = `template` ; return fetch ( url ) ; } public static startConversation ( serverUrl , payload < StartConversationParams > ) < Response > { const { endpoint , appId = 's' , appPassword = 's' , user , channelService , ... body } = payload ; const url = serverUrl + `template` ; return fetch ( url , { method : 's' , headers : { 's' : 's' , 's' : ( endpoint || 's' ) . trim ( ) , 's' : ( appId || 's' ) . trim ( ) , 's' : ( appPassword || 's' ) . trim ( ) , 's' : ( channelService || 's' ) . trim ( ) . toLowerCase ( ) , } , body : JSON . stringify ( { bot : { id : uniqueId ( ) , name : 's' , role : 's' , } , members : [ user ] , ... body , } ) , } ) ; } }	O O $any$ O O O O O O $string$ O O O O O O $complex$ O O O O O O O O O O $any$ O O O $Promise<Response>$ O $string$ O $string$ O $string$ $string$ O $string$ $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O $string$ O $JSON$ O $complex$ O O O $string$ O $string$ O O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O $string$ O $JSON$ O $complex$ O O O $string$ O O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise<Response>$ O $string$ O $string$ O O O $string$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O $Promise$ O $string$ O $string$ O O $complex$ O O O $string$ O O O O $complex$ O $string$ O O O O O $Promise$ O $string$ O $Partial$ O $any$ O O O $complex$ O O O O $string$ O $string$ O O O $string$ O O O $User$ O $ChannelService$ O O $complex$ O O $Partial<StartConversationParams>$ O O $string$ O $string$ O O O O $complex$ O $string$ O O $string$ O O O $complex$ O O O O O O O O O $string$ O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O O O $ChannelService$ O O O O $string$ O O O $string$ O O O O O $string$ O $JSON$ O $complex$ O O $complex$ O O $string$ O $string$ O O O $string$ O O O $string$ O O O O O $User[]$ O O $User$ O O O $complex$ O O O O O O O O O
export * from 's' ;	O O O O O
import { HTMLAttributes } from 's' ; export interface ExtensionPortal { title ? : string ; url ? : string ; } export interface ExtensionFile { type ? : string ; value ? : string ; } export interface InspectorCriteria { path ? : string ; value ? : string ; } export interface InspectorAccessory { id ? : string ; states ? : { [ id ] : InspectorAccessoryState } ; className ? : string ; } export interface InspectorAccessoryState extends HTMLAttributes < HTMLButtonElement > { label ? : string ; icon ? : string ; } export interface ExtensionInspector { name ? : string ; src ? : string ; preloadPath ? : string ; criteria ? : InspectorCriteria | InspectorCriteria [ ] ; summaryText ? : string | string [ ] ; accessories ? : InspectorAccessory [ ] ; } export interface ExtensionConfigClient { basePath ? : string ; portals ? : ExtensionPortal [ ] ; files ? : ExtensionFile [ ] ; inspectors ? : ExtensionInspector [ ] ; debug ? : { enabled ? : boolean ; webpack ? : { port ? : number ; host ? : string ; } ; } ; } export interface ExtensionConfigNode { main ? : string ; debug ? : { enabled ? : boolean ; websocket ? : { port ? : number ; host ? : string ; } ; } ; } export interface ExtensionConfig { name ? : string ; location ? : string ; node ? : ExtensionConfigNode ; client ? : ExtensionConfigClient ; }	O O $any$ O O O O O O $any$ O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $complex$ O O O O $string$ O O $any$ O O $string$ O O O O O O O $any$ O $any$ O $complex$ O O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O $string$ O O O O $complex$ O O $any$ O $any$ O O O $complex$ O O O O O O O O $InspectorAccessory[]$ O O $any$ O O O O O O $any$ O $string$ O O O O $ExtensionPortal[]$ O O $any$ O O O $ExtensionFile[]$ O O $any$ O O O $ExtensionInspector[]$ O O $any$ O O O $complex$ O O O $boolean$ O O O O $complex$ O O O $number$ O O O O $string$ O O O O O O O O O O O $any$ O $string$ O O O O $complex$ O O O $boolean$ O O O O $complex$ O O O $number$ O O O O $string$ O O O O O O O O O O O $any$ O $string$ O O O O $string$ O O O O $ExtensionConfigNode$ O O $any$ O $ExtensionConfigClient$ O O $any$ O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { uniqueId } from 's' ; import { CommandRegistry , CommandRegistryImpl } from 's' ; interface Sender { send ( channel , ... args : any [ ] ) : void ; } export class CommandServiceImpl { public readonly registry : CommandRegistry ; private readonly ipcListener : EventEmitter ; private ipcSender : Sender ; private notFoundHandler : ( commandName , ... args : any [ ] ) => any ; constructor ( ipcListener , channelName = 's' , registry = new CommandRegistryImpl ( ) ) { this . ipcListener = ipcListener ; this . ipcSender = 's' in ipcListener ? ( ipcListener as Sender ) : null ; this . registry = registry ; this . initializeListeners ( ) ; } public on ( event , handler : ( commandName , ... args : any [ ] ) => any ) { if ( event === 's' ) { this . notFoundHandler = handler ; return undefined ; } else { return this . registry . registerCommand ( event , handler ) ; } } public async call < T > ( commandName , ... args : any [ ] ) < T | Error > { const command = this . registry . getCommand ( commandName ) ; if ( ! command ) { if ( this . notFoundHandler ) { return this . notFoundHandler ( commandName , ... args ) ; } else { throw new Error ( `template` ) ; } } else { return ( await command ( ... args ) ) as T ; } } public async remoteCall < T > ( commandName , ... args : any [ ] ) < T > { const transactionId = uniqueId ( ) ; return new Promise < T > ( ( resolve , reject ) => { this . ipcListener . once ( transactionId , ( event , ... args ) => { const [ success , ... responseArgs ] = args ; if ( success ) { const result = responseArgs . length ? responseArgs . shift ( ) : undefined ; resolve ( result ) ; } else { reject ( responseArgs . shift ( ) ) ; } } ) ; if ( this . ipcSender ) { this . ipcSender . send ( 's' , commandName , transactionId , ... args ) ; } } ) ; } protected onIpcMessage = async ( event , commandName , transactionId , ... args : any [ ] ) => { try { let result = await this . call < any > ( commandName , ... args ) ; result = Array . isArray ( result ) ? result : [ result ] ; this . ipcSender . send ( transactionId , true , ... result ) ; } catch ( err ) { const message = err . message ? err . message : err ; this . ipcSender . send ( transactionId , false , message ) ; } } ; private initializeListeners ( ) { this . ipcListener . on ( 's' , this . onIpcMessage ) ; if ( process . type === 's' && ! this . ipcSender ) { this . ipcListener . once ( 's' , event => { this . ipcSender = event . sender ; } ) ; } else { this . ipcSender . send ( 's' ) ; } } }	O O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O O O O O $any$ O $void$ O $string$ O O $any[]$ O O O O O O O O O O O $any$ O O O $CommandRegistry$ O $any$ O O O $any$ O $any$ O O $Sender$ O $any$ O O $any$ O O $string$ O O $any[]$ O O O O O O O O O O $EventEmitter$ O $string$ O O O $CommandRegistryImpl$ O O $any$ O O O O O O $any$ O $any$ O O O $Sender$ O O O $any$ O O $any$ O $any$ O O O O O O $CommandRegistry$ O $CommandRegistryImpl$ O O O $void$ O O O O O $void$ O $string$ O $any$ O O $string$ O O $any[]$ O O O O O O O O O O O $string$ O O O O O O $any$ O $any$ O O $undefined$ O O O O O O O $CommandRegistry$ O $void$ O $string$ O $any$ O O O O O O $Promise$ O $any$ O O $string$ O O $any[]$ O O O O O O $any$ O $ErrorConstructor$ O O O $Function$ O O O $CommandRegistry$ O $Function$ O $string$ O O O O O $Function$ O O O O O O $any$ O O O O O $any$ O $string$ O O $any[]$ O O O O O O O $ErrorConstructor$ O O O O O O O O O O O $Function$ O O $any[]$ O O O $any$ O O O O O $Promise$ O $any$ O O $string$ O O $any[]$ O O O O O O $any$ O O O $string$ O $string$ O O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O O $any$ O $any$ O $string$ O O $Event$ O O $any$ O O O O O $any$ O O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $undefined$ O $void$ O $any$ O O O O O $void$ O $any$ O $any$ O O O O O O O O O O O O $Sender$ O O O O $Sender$ O $void$ O O O $string$ O $string$ O O $any[]$ O O O O O O O O $Promise<void>$ O O O $Event$ O $string$ O $string$ O O $any[]$ O O O O O O O O O O $any$ O O O O $complex$ O O O O $string$ O O $any[]$ O O $any$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O O $any$ O O O O $Sender$ O $void$ O $string$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Sender$ O $void$ O $string$ O O O $any$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O O O $Sender$ O O O O $any$ O $any$ O O O $any$ O O O O $Sender$ O $any$ O $any$ O O O O O O O O O $Sender$ O $void$ O O O O O O O
export interface CommandRegistry { registerCommand ( id , command ) : void ; getCommand ( id ) : Function ; } export class CommandRegistryImpl implements CommandRegistry { private commands : { [ id ] : Function } = { } ; public registerCommand ( id , handler ? ) { if ( ! id || ( typeof id === 's' && typeof handler !== 's' ) ) { throw new Error ( 's' ) ; } this . commands [ id ] = handler ; } public getCommand ( id ) { return this . commands [ id ] ; } }	O O $any$ O $void$ O $string$ O $Function$ O O O O $Function$ O $string$ O O $FunctionConstructor$ O O O O $any$ O $any$ O O $complex$ O O O $string$ O O $FunctionConstructor$ O O O O O O $void$ O $string$ O $Function$ $Function$ O O O O O $string$ O O O $string$ O O O O $Function$ O O O O O O O $ErrorConstructor$ O O O O O O O $complex$ O $string$ O O $Function$ O O O $Function$ O $string$ O O O O O $complex$ O $string$ O O O O
import { ipcMain , ipcRenderer } from 's' ; import { CommandServiceImpl } from 's' ; export * from 's' ; export * from 's' ; const commandServiceByChannelId = { } ; function getCommandService ( channelId ) { if ( commandServiceByChannelId [ channelId ] ) { return commandServiceByChannelId [ channelId ] ; } const ipc = process . type === 's' ? ipcMain : ipcRenderer ; commandServiceByChannelId [ channelId ] = new CommandServiceImpl ( ipc ) ; return commandServiceByChannelId [ channelId ] ; } export function CommandServiceInstance ( channelId = 's' ) { return function ( descriptor ) { descriptor . kind = 's' ; descriptor . descriptor = ( function ( propertyDescriptor = { } ) { return { get : function ( ) { return getCommandService ( channelId ) ; } , enumerable : propertyDescriptor . enumerable !== undefined ? propertyDescriptor . enumerable : true , } ; } ) ( descriptor . descriptor ) ; delete descriptor . initializer ; return descriptor ; } ; } export function Command ( id , channelId = 's' ) { return function ( elementDescriptor ) { const { key , descriptor } = elementDescriptor ; const initializer = function ( ) { const bound = this [ key ] . bind ( this ) ; const { registry } = getCommandService ( channelId ) ; registry . registerCommand ( id , bound ) ; return bound ; } ; elementDescriptor . extras = [ { kind : 's' , key , placement : 's' , initializer , descriptor : { ... descriptor , value : undefined } , } , ] ; return elementDescriptor ; } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O ${}$ O O O O O $CommandServiceImpl$ O $string$ O O O O ${}$ O $string$ O O O O ${}$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O ${}$ O $string$ O O O $any$ O $any$ O O O ${}$ O $string$ O O O O O $PropertyDecorator$ O $string$ O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O $CommandServiceImpl$ O O O O O O $CommandServiceImpl$ O $string$ O O O O $any$ O $any$ O $any$ O $undefined$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O $MethodDecorator$ O $string$ O $string$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O O O $any$ O O $any$ O O O O O O $CommandRegistry$ O O $CommandServiceImpl$ O $string$ O O $CommandRegistry$ O $void$ O $string$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $string$ O O O $any$ O $any$ O O O $any$ O $undefined$ O $undefined$ O O O O O O O $any$ O O O O
import { ConversationService , headers as headersInstance } from 's' ; let mockFetchArgs ; ( global as any ) . fetch = ( function ( ) { const fetch = ( url , opts ) => { mockFetchArgs = { url , opts } ; return { ok : true , json : async ( ) => ( { } ) , text : async ( ) => 's' , } ; } ; ( fetch as any ) . Headers = class { } ; ( fetch as any ) . Response = class { } ; return fetch ; } ) ( ) ; interface MockOpts { headers : Headers ; method : 's' | 's' | 's' ; body ? : any ; } interface MockFetch { url ? : string ; opts ? : MockOpts ; } describe ( 's' , ( ) => { test ( 's' , ( ) => { ConversationService . addUser ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; const members = JSON . parse ( body ) ; expect ( members [ 0 ] . name ) . toBeFalsy ( ) ; expect ( members [ 0 ] . id ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . removeUser ( 's' , 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; const users = JSON . parse ( body ) ; expect ( users [ 0 ] . id ) . toBe ( 's' ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . removeRandomUser ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . botContactAdded ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . botContactRemoved ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . typing ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . ping ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . deleteUserData ( 's' , 's' ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeFalsy ( ) ; expect ( headersInstance ) . toEqual ( headers ) ; } ) ; test ( 's' , ( ) => { ConversationService . startConversation ( 's' , { appId : 's' , appPassword : 's' , endpoint : 's' , channelService : 's' , } ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeTruthy ( ) ; expect ( headers ) . toEqual ( { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } ) ; } ) ; test ( 's' , ( ) => { ConversationService . startConversation ( 's' , { appId : 's' , appPassword : 's' , endpoint : 's' , channelService : 's' , } ) ; const { url , opts } = mockFetchArgs ; expect ( url ) . toBe ( 's' ) ; const { body , headers , method } = opts ; expect ( headers === headers ) . toBeTruthy ( ) ; expect ( method ) . toBe ( 's' ) ; expect ( body ) . toBeTruthy ( ) ; expect ( headers ) . toEqual ( { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } ) ; } ) ; } ) ;	O O $any$ O $complex$ O $complex$ O O O O O $MockFetch$ O O $any$ O O O O $any$ O O O O O O O $complex$ O O $any$ O $any$ O O O $MockFetch$ O O $any$ O $any$ O O O O $boolean$ O O O $Promise<{}>$ O O O O O O O O O O $Promise<string>$ O O O O O O O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O $complex$ O O O O O O O $any$ O $Headers$ O $complex$ O O O O O O O O O $any$ O O O O O O $any$ O $string$ O O O O $MockOpts$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O $JSON$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O $JSON$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O $Headers$ O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $Headers$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $Promise<Response>$ O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O $string$ O $MockOpts$ O O $MockFetch$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $Headers$ O O O O $MockOpts$ O $any$ O $Headers$ O $Headers$ O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $Headers$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ServiceTypes } from 's' ; import { BotConfigWithPathImpl } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { const endpointService = { type : ServiceTypes . Endpoint , name : 's' , id : 's' , appId : 's' , appPassword : 's' , endpoint : 's' , } ; it ( 's' , ( ) => { const constructedBotConfig = BotConfigWithPathImpl . fromJSON ( { name : 's' , description : 's' , services : [ endpointService ] , path : 's' , overrides : { endpoint : { endpoint : 's' , name : 's' , appId : 's' , } , } , } ) ; expect ( constructedBotConfig . name ) . toBe ( 's' ) ; expect ( constructedBotConfig . description ) . toBe ( 's' ) ; expect ( constructedBotConfig . path ) . toBe ( 's' ) ; expect ( constructedBotConfig . services [ 0 ] ) . toEqual ( endpointService ) ; expect ( constructedBotConfig . overrides ) . toEqual ( { endpoint : { endpoint : 's' , name : 's' , appId : 's' , } , } ) ; } ) ; it ( 's' , ( ) => { const botConfigVariable = { name : 's' , description : 's' , services : [ endpointService ] , path : 's' , overrides : { endpoint : { endpoint : 's' , name : 's' , appId : 's' , } , } , extraneousProp : true , } ; const constructedBotConfig = BotConfigWithPathImpl . fromJSON ( botConfigVariable ) ; expect ( constructedBotConfig . name ) . toBe ( 's' ) ; expect ( constructedBotConfig . description ) . toBe ( 's' ) ; expect ( constructedBotConfig . path ) . toBe ( 's' ) ; expect ( constructedBotConfig . services [ 0 ] ) . toEqual ( endpointService ) ; expect ( constructedBotConfig . overrides ) . toEqual ( { endpoint : { endpoint : 's' , name : 's' , appId : 's' , } , } ) ; expect ( Object . keys ( constructedBotConfig ) ) . toContain ( 's' ) ; } ) ; it ( 's' , ( ) => { const botConfig = BotConfigWithPathImpl . fromJSON ( { name : 's' , description : 's' , path : 's' , padlock : null , services : [ ] , overrides : { } , } ) ; const serializedVersion = JSON . stringify ( botConfig ) ; expect ( serializedVersion . includes ( 's' ) ) . toBe ( true ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O O O O O O O $BotConfigWithPathImpl$ O $any$ O $BotConfigWithPathImpl$ O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $string$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $any$ O O O O O $any$ O $complex$ O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $boolean$ O O O O O O $BotConfigWithPathImpl$ O $any$ O $BotConfigWithPathImpl$ O $complex$ O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $string$ O O $any$ O O O O $any$ O $BotConfigWithPathImpl$ O $any$ O O O O O $any$ O $complex$ O O $any$ O $BotConfigWithPathImpl$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $BotConfigWithPathImpl$ O O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPathImpl$ O $any$ O $BotConfigWithPathImpl$ O O $string$ O O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O ${}$ O O O O O O O O $string$ O $JSON$ O $complex$ O $BotConfigWithPathImpl$ O O $any$ O $string$ O $boolean$ O O O O O $any$ O O O O O O O O O O O O O
export interface BotEndpoint { botId : string ; botUrl : string ; msaAppId : string ; msaPassword : string ; 0 ? : boolean ; channelService ? : string ; }	O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O O $string$ O O O O O
import { LogLevel } from 's' ; import { textItem , externalLinkItem , inspectableObjectItem , summaryTextItem , appSettingsItem , exceptionItem , networkRequestItem , networkResponseItem , logEntry , ngrokExpirationItem , makeEnumerableObject , luisEditorDeepLinkItem , } from 's' ; describe ( 's' , ( ) => { test ( 's' , ( ) => { } ) ; test ( 's' , ( ) => { const item = textItem ( LogLevel . Error , 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { level : LogLevel . Error , text : 's' , } ) ; } ) ; test ( 's' , ( ) => { const item = externalLinkItem ( 's' , 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { text : 's' , hyperlink : 's' } ) ; } ) ; test ( 's' , ( ) => { const item = inspectableObjectItem ( 's' , { a : 0 , b : 's' } ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { text : 's' , obj : { a : 0 , b : 's' } , } ) ; } ) ; test ( 's' , ( ) => { const item = summaryTextItem ( { a : 0 , b : true , c : 's' } ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { obj : { a : 0 , b : true , c : 's' } } ) ; } ) ; test ( 's' , ( ) => { const item = appSettingsItem ( 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { text : 's' } ) ; } ) ; test ( 's' , ( ) => { const item = exceptionItem ( 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { err : makeEnumerableObject ( 's' ) } ) ; } ) ; test ( 's' , ( ) => { const item = networkRequestItem ( 's' , 's' , 's' , 's' , 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { facility : 's' , body : 's' , headers : 's' , method : 's' , url : 's' , } ) ; } ) ; test ( 's' , ( ) => { const item = networkResponseItem ( 's' , 's' , 's' , 's' , 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { body : 's' , headers : 's' , statusCode : 's' , statusMessage : 's' , srcUrl : 's' , } ) ; } ) ; test ( 's' , ( ) => { const 0 = textItem ( LogLevel . Debug , 's' ) ; const 0 = textItem ( LogLevel . Warn , 's' ) ; const entry = logEntry ( 0 , 0 ) ; expect ( entry . timestamp ) . toBeGreaterThan ( 0 ) ; expect ( entry . items ) . toHaveLength ( 0 ) ; expect ( entry . items [ 0 ] ) . toBe ( 0 ) ; expect ( entry . items [ 0 ] ) . toBe ( 0 ) ; } ) ; test ( 's' , ( ) => { const item = ngrokExpirationItem ( 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { text : 's' } ) ; } ) ; test ( 's' , ( ) => { const item = luisEditorDeepLinkItem ( 's' ) ; expect ( item . type ) . toBe ( 's' ) ; expect ( item . payload ) . toEqual ( { text : 's' } ) ; } ) ; } ) ;	O O $any$ O O O O O O $LogItem<TextLogItem>$ O $LogItem<ExternalLinkLogItem>$ O $LogItem<InspectableObjectLogItem>$ O $LogItem<SummaryTextLogItem>$ O $LogItem<OpenAppSettingsLogItem>$ O $LogItem<ExceptionLogItem>$ O $LogItem<NetworkRequestLogItem>$ O $LogItem<NetworkResponseLogItem>$ O $LogEntry<any>$ O $LogItem<NgrokExpirationLogItem>$ O $any$ O $LogItem<LuisEditorDeepLinkLogItem>$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O $LogItem<TextLogItem>$ O $LogItem<TextLogItem>$ O $any$ O $LogLevel.Error$ O O O O $any$ O $LogItem<TextLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<TextLogItem>$ O $TextLogItem$ O O $any$ O O $LogLevel$ O $any$ O $LogLevel.Error$ O $string$ O O O O O O O O O $any$ O O O O O O O O $LogItem<ExternalLinkLogItem>$ O $LogItem<ExternalLinkLogItem>$ O O O O O O $any$ O $LogItem<ExternalLinkLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<ExternalLinkLogItem>$ O $ExternalLinkLogItem$ O O $any$ O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O O $LogItem<InspectableObjectLogItem>$ O $LogItem<InspectableObjectLogItem>$ O O O O $number$ O O O $string$ O O O O O $any$ O $LogItem<InspectableObjectLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<InspectableObjectLogItem>$ O $InspectableObjectLogItem$ O O $any$ O O $string$ O O O $complex$ O O $number$ O O O $string$ O O O O O O O O O O $any$ O O O O O O O O $LogItem<SummaryTextLogItem>$ O $LogItem<SummaryTextLogItem>$ O O $number$ O O O $boolean$ O O O $string$ O O O O O $any$ O $LogItem<SummaryTextLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<SummaryTextLogItem>$ O $SummaryTextLogItem$ O O $any$ O O $complex$ O O $number$ O O O $boolean$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $LogItem<OpenAppSettingsLogItem>$ O $LogItem<OpenAppSettingsLogItem>$ O O O O $any$ O $LogItem<OpenAppSettingsLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<OpenAppSettingsLogItem>$ O $OpenAppSettingsLogItem$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $LogItem<ExceptionLogItem>$ O $LogItem<ExceptionLogItem>$ O O O O $any$ O $LogItem<ExceptionLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<ExceptionLogItem>$ O $ExceptionLogItem$ O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O $LogItem<NetworkRequestLogItem>$ O $LogItem<NetworkRequestLogItem>$ O O O O O O O O O O O O $any$ O $LogItem<NetworkRequestLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<NetworkRequestLogItem>$ O $NetworkRequestLogItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $LogItem<NetworkResponseLogItem>$ O $LogItem<NetworkResponseLogItem>$ O O O O O O O O O O O O $any$ O $LogItem<NetworkResponseLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<NetworkResponseLogItem>$ O $NetworkResponseLogItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $LogItem<TextLogItem>$ O $LogItem<TextLogItem>$ O $any$ O $LogLevel.Debug$ O O O O O $LogItem<TextLogItem>$ O $LogItem<TextLogItem>$ O $any$ O $LogLevel.Warn$ O O O O O $LogEntry<any>$ O $LogEntry<any>$ O $LogItem<TextLogItem>$ O $LogItem<TextLogItem>$ O O $any$ O $LogEntry<any>$ O $number$ O O $any$ O O O O $any$ O $LogEntry<any>$ O $LogItem<any>[]$ O O $any$ O O O O $any$ O $LogEntry<any>$ O $LogItem<any>[]$ O O O O O $any$ O $LogItem<TextLogItem>$ O O $any$ O $LogEntry<any>$ O $LogItem<any>[]$ O O O O O $any$ O $LogItem<TextLogItem>$ O O O O O $any$ O O O O O O O O $LogItem<NgrokExpirationLogItem>$ O $LogItem<NgrokExpirationLogItem>$ O O O O $any$ O $LogItem<NgrokExpirationLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<NgrokExpirationLogItem>$ O $NgrokExpirationLogItem$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O $LogItem<LuisEditorDeepLinkLogItem>$ O $LogItem<LuisEditorDeepLinkLogItem>$ O O O O $any$ O $LogItem<LuisEditorDeepLinkLogItem>$ O $LogItemType$ O O $any$ O O O O $any$ O $LogItem<LuisEditorDeepLinkLogItem>$ O $LuisEditorDeepLinkLogItem$ O O $any$ O O $string$ O O O O O O O O O O O
import { IEndpointService , ServiceTypes } from 's' ; import { BotConfigOverrides , BotConfigWithPath } from 's' ; import { applyBotConfigOverrides , botsAreTheSame , mergeEndpoints } from 's' ; describe ( 's' , ( ) => { const bot = { name : 's' , description : 's' , path : 's' , padlock : null , services : [ ] , overrides : null , version : 's' , } ; it ( 's' , ( ) => { const overrides = { endpoint : { endpoint : 's' , appId : 's' , appPassword : 's' , id : 's' , } , } ; const overriddenBot = applyBotConfigOverrides ( bot , overrides ) ; expect ( overriddenBot . overrides ) . not . toBe ( null ) ; expect ( overriddenBot . overrides . endpoint . endpoint ) . toBe ( 's' ) ; expect ( overriddenBot . overrides . endpoint . appId ) . toBe ( 's' ) ; expect ( overriddenBot . overrides . endpoint . appPassword ) . toBe ( 's' ) ; expect ( overriddenBot . overrides . endpoint . id ) . toBe ( 's' ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const falsyBot = null ; const 0 = botsAreTheSame ( bot , falsyBot ) ; const 0 = botsAreTheSame ( falsyBot , bot ) ; expect ( 0 ) . toBe ( false ) ; expect ( 0 ) . toBe ( false ) ; } ) ; it ( "s" , ( ) => { const nonMatchingBot = { name : 's' , description : 's' , padlock : null , services : [ ] , version : 's' , } ; const result = botsAreTheSame ( bot , nonMatchingBot ) ; expect ( result ) . toBe ( false ) ; } ) ; it ( 's' , ( ) => { const matchingBot = { name : 's' , description : 's' , padlock : null , services : [ ] , path : 's' , version : 's' , } ; const result = botsAreTheSame ( bot , matchingBot ) ; expect ( result ) . toBe ( true ) ; } ) ; } ) ; describe ( 's' , ( ) => { const 0 = { type : ServiceTypes . Endpoint , name : 's' , id : 's' , endpoint : 's' , appId : 's' , appPassword : 's' , } ; const 0 < IEndpointService > = { id : 's' , endpoint : 's' , appId : 's' , appPassword : null , } ; const result = mergeEndpoints ( 0 , 0 ) ; expect ( result . name ) . toBe ( 's' ) ; expect ( result . endpoint ) . toBe ( 's' ) ; expect ( result . id ) . toBe ( 's' ) ; expect ( result . appId ) . toBe ( 's' ) ; expect ( result . appPassword ) . toBe ( null ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $BotConfigWithPath$ O O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $null$ O O O $string$ O O O O O $any$ O O O O O O O O $BotConfigOverrides$ O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $BotConfigWithPath$ O $BotConfigWithPath$ O $BotConfigWithPath$ O $BotConfigOverrides$ O O $any$ O $BotConfigWithPath$ O $BotConfigOverrides$ O O $any$ O $any$ O O O O $any$ O $BotConfigWithPath$ O $BotConfigOverrides$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPath$ O $BotConfigOverrides$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPath$ O $BotConfigOverrides$ O $any$ O $any$ O O $any$ O O O O $any$ O $BotConfigWithPath$ O $BotConfigOverrides$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O O O $boolean$ O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O O $boolean$ O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O $any$ O $boolean$ O O $any$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O O O O $boolean$ O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotConfigWithPath$ O O $string$ O O O $string$ O O O $null$ O O O $undefined[]$ O O O O $string$ O O O $string$ O O O O O O $boolean$ O O O $BotConfigWithPath$ O $BotConfigWithPath$ O O $any$ O $boolean$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $IEndpointService$ O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $Partial$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $null$ O O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { isLocalHostUrl , isObject , uniqueId , 0 } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const 0 = uniqueId ( ) ; const 0 = uniqueId ( ) ; const 0 = uniqueId ( ) ; expect ( 0 ) . not . toEqual ( 0 ) ; expect ( 0 ) . not . toEqual ( 0 ) ; expect ( 0 ) . not . toEqual ( 0 ) ; } ) ; it ( 's' , ( ) => { const 0 = 0 ; const 0 = 's' ; const 0 = true ; const 0 = [ 0 , 's' , false ] ; expect ( isObject ( 0 ) ) . toBe ( false ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; expect ( isObject ( 0 ) ) . toBe ( false ) ; const obj = { someProp : 0 } ; expect ( isObject ( obj ) ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const 0 = 0 ( ) ; const 0 = 0 ( ) ; const 0 = 0 ( ) ; expect ( 0 ) . not . toEqual ( 0 ) ; expect ( 0 ) . not . toEqual ( 0 ) ; expect ( 0 ) . not . toEqual ( 0 ) ; } ) ; it ( 's' , ( ) => { expect ( isLocalHostUrl ( 's' ) ) . toBeTruthy ( ) ; expect ( isLocalHostUrl ( 's' ) ) . toBeTruthy ( ) ; expect ( isLocalHostUrl ( 's' ) ) . toBeFalsy ( ) ; expect ( isLocalHostUrl ( 's' ) ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $boolean$ O $boolean$ O $string$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O $string$ O $string$ O O O O $string$ O $string$ O O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $true$ O O O O $complex$ O O O O O O O O O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $boolean$ O $true$ O O O $any$ O O O O $any$ O $boolean$ O $complex$ O O O $any$ O O O O O $complex$ O O $number$ O O O O $any$ O $boolean$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O $string$ O $string$ O O O O $string$ O $string$ O O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O $any$ O O O $any$ O $boolean$ O O O O O $any$ O O O $any$ O $boolean$ O O O O O $any$ O O O $any$ O $boolean$ O O O O O $any$ O O O O O O O O O
'js' module . exports = { extends : 's' , } ;	O $complex$ O $complex$ O O $string$ O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; export function filterChildren ( children , predicate ) { return React . Children . map ( children , child => ( child && predicate ( child ) ? child : false ) ) ; } let uid = Date . now ( ) ; export function hmrSafeNameComparison ( 0 , 0 , invert = false ) { const { name : 0 = uid ++ , displayName : 0 = uid ++ } = 0 ; const { name : 0 = uid ++ , displayName : 0 = uid ++ } = 0 ; const result = 0 === 0 || 0 === 0 || 0 === 0 || 0 === 0 ; return invert ? ! result : result ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O $any$ O O O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O $any$ O O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O $boolean$ O $boolean$ O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
import { filterChildren , hmrSafeNameComparison } from 's' ; jest . mock ( 's' , ( ) => ( { Children : { map : ( array , fn ) => array . map ( fn ) , } , } ) ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const 0 = { name : 's' , displayName : 's' } ; const 0 = { name : 's' , displayName : 's' } ; expect ( hmrSafeNameComparison ( 0 , 0 ) ) . toBe ( false ) ; expect ( hmrSafeNameComparison ( 0 , 0 , true ) ) . toBe ( true ) ; } ) ; it ( 's' , ( ) => { const 0 = { name : 's' } ; const 0 = { name : 's' } ; const predicate = child => child . name . startsWith ( 's' ) ; const filteredChildren = filterChildren ( [ 0 , 0 ] , predicate ) ; expect ( filteredChildren ) . toHaveLength ( 0 ) ; expect ( filteredChildren [ 0 ] ) . toBe ( 0 ) ; expect ( filteredChildren [ 0 ] ) . toBe ( false ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $any$ O O O $complex$ O $complex$ O O O $any$ O O O O $any$ O O O $complex$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
const booleanNumber = 's' ; const keys = 's' ; const string = 's' ; const background = 's' ; export default { 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : background , 0 : 's' , 0 : booleanNumber , 0 : 's' , 0 : string , 0 : 's' , 0 : keys , 0 : 's' , 0 : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
'js' const { WatchIgnorePlugin } = require ( 's' ) ; const path = require ( 's' ) ; module . exports = { entry : { index : path . resolve ( 's' ) , } , devtool : 's' , module : { rules : [ { test : "s" , use : [ 's' , { loader : 's' , options : { localIdentName : 's' , modules : true , sass : false , namedExport : true , camelCase : true , sourcemaps : true , banner : 's' , } , } , 's' , 's' , ] , } , { test : "s" , use : [ { loader : 's' , options : { limit : 0 , } , } , ] , } , { test : "s" , exclude : [ "s" ] , use : { loader : 's' , options : { ignore : [ 's' ] , } , } , } , ] , } , externals : { react : 's' , 's' : 's' , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' , 's' ] , } , output : { path : path . resolve ( 's' ) , filename : 's' , libraryTarget : 's' , library : 's' , } , plugins : [ new WatchIgnorePlugin ( [ 's' ] ) ] , } ;	O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $complex$ O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $complex$ O O $complex$ O O O $RegExp$ O O O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O $RegExp$ O O O $complex$ O O O $string$ O O O $complex$ O O $number$ O O O O O O O O O O O O $RegExp$ O O O $RegExp[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O $string$ O O O O O O O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O O O $any[]$ O O O $any$ O O O O O O O O O
'js' module . exports = { extends : 's' , rules : { semi : [ 0 , 's' ] , indent : [ 0 ] , 's' : 0 , 's' : [ 0 , { named : 's' , anonymous : 's' , asyncArrow : 's' , } , ] , 's' : [ 0 , 's' ] , } , } ;	O $complex$ O $complex$ O O $string$ O O O $complex$ O O $complex$ O O O O O O O $number[]$ O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O
'js' const { ActivityHandler } = require ( 's' ) ; class 0 extends ActivityHandler { constructor ( ) { super ( ) ; this . onMessage ( async ( context , next ) => { const { text } = context . activity ; switch ( text . toLowerCase ( ) ) { case 's' : await context . sendActivity ( context . activity . from . id ) ; break ; case 's' : await context . sendActivity ( 's' ) ; await context . sendActivity ( 's' ) ; break ; default : break ; } await next ( ) ; } ) ; this . onMembersAdded ( async ( context , next ) => { const membersAdded = context . activity . membersAdded ; for ( let cnt = 0 ; cnt < membersAdded . length ; ++ cnt ) { if ( membersAdded [ cnt ] . id !== context . activity . recipient . id ) { await context . sendActivity ( 's' ) ; } } await next ( ) ; } ) ; } } module . exports . 0 = 0 ;	O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O $number$ O $any$ O $any$ O O $number$ O O O O $any$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $any$ O $any$ O
'js' const dotenv = require ( 's' ) ; const path = require ( 's' ) ; const restify = require ( 's' ) ; const { BotFrameworkAdapter } = require ( 's' ) ; const { 0 } = require ( 's' ) ; const ENV_FILE = path . join ( __dirname , 's' ) ; dotenv . config ( { path : ENV_FILE } ) ; const server = restify . createServer ( ) ; server . listen ( process . env . port || process . env . PORT || 0 , ( ) => { console . log ( `template` ) ; } ) ; const adapter = new BotFrameworkAdapter ( { appId : process . env . MicrosoftAppId , appPassword : process . env . MicrosoftAppPassword , } ) ; adapter . onTurnError = async ( context , error ) => { console . error ( `template` ) ; await context . sendActivity ( `template` ) ; } ; const bot = new 0 ( ) ; server . post ( 's' , ( req , res ) => { adapter . processActivity ( req , res , async context => { await bot . run ( context ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Console$ O $void$ O O O O O O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $Console$ O $void$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O
'js' const Enzyme = require ( 's' ) ; const Adapter = require ( 's' ) ; Enzyme . configure ( { adapter : new Adapter ( ) } ) ; window . require = function ( ) { return { ipcRenderer : { on ( ) { return null ; } , send ( ) { return null ; } , } , shell : { openExternal : window . _openExternal , } , } ; } ; window . _openExternal = jest . fn ( ( ) => null ) ; window . define = function ( ) { return null ; } ; window . TextEncoder = class { encode ( ) { return 's' ; } } ; window . TextDecoder = class { decode ( ) { return 's' ; } } ; window . crypto = { random : ( ) => Math . random ( ) * 0 , subtle : { digest : async ( ) => Promise . resolve ( 's' ) , } , } ; window . MutationObserver = class { observe ( ) { } disconnect ( ) { } } ; jest . mock ( 's' , ( ) => ( { ipcMain : { on : ( ) => null , send : ( ) => null , } , ipcRenderer : { on : ( ) => null , send : ( ) => null , } , } ) ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O O O O O $complex$ O $any$ O O O O O O O $complex$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O $complex$ O O $any$ O $complex$ O $any$ O O O O O O O $complex$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $any$ O O O O O O O O O O $complex$ O $complex$ O O O $string$ O O O O O O O O O $complex$ O $complex$ O O O $string$ O O O O O O O O O $complex$ O $Crypto$ O O $number$ O O O O $Math$ O $number$ O O O O O $complex$ O O $Promise<string>$ O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $complex$ O $complex$ O O O $void$ O O O O $void$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O