'js' 's' ; const pkg = require ( 's' ) ; export default { input : 's' , external : [ 's' , 's' ] , output : { banner : `template` , file : `template` , format : 's' , globals : { 's' : 's' , 's' : 's' } , name : pkg . moduleName , sourcemap : true , } , onwarn : ( warning , next ) => { if ( warning . code === 's' ) { return ; } next ( warning ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class AppComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter , NgZone } from 's' ; export class LeafletUtil { static mapToArray < T > ( map : { [ key ] : T } ) : T [ ] { const toReturn : T [ ] = [ ] ; for ( const k in map ) { if ( map . hasOwnProperty ( k ) ) { toReturn . push ( map [ k ] ) ; } } return toReturn ; } static handleEvent < T > ( zone , eventEmitter < T > , event : T ) { if ( 0 < eventEmitter . observers . length ) { zone . run ( ( ) => { eventEmitter . emit ( event ) ; } ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Directive , ElementRef , EventEmitter , HostListener , Input , NgZone , OnChanges , OnInit , Output , SimpleChange } from 's' ; import { latLng , LatLng , LatLngBounds , LeafletEvent , LeafletMouseEvent , map , Map , MapOptions } from 's' ; import { LeafletUtil } from 's' ; @ Directive ( { selector : 's' } ) export class LeafletDirective implements OnChanges , OnInit { readonly DEFAULT_ZOOM = 0 ; readonly DEFAULT_CENTER = latLng ( 0 , - 0 ) ; readonly DEFAULT_FPZ_OPTIONS = { } ; resizeTimer : any ; map : Map ; @ Input ( 's' ) fitBoundsOptions = this . DEFAULT_FPZ_OPTIONS ; @ Input ( 's' ) panOptions = this . DEFAULT_FPZ_OPTIONS ; @ Input ( 's' ) zoomOptions = this . DEFAULT_FPZ_OPTIONS ; @ Input ( 's' ) zoomPanOptions = this . DEFAULT_FPZ_OPTIONS ; @ Input ( 's' ) options : MapOptions = { } ; @ Output ( 's' ) mapReady = new EventEmitter < Map > ( ) ; @ Input ( 's' ) zoom : number ; @ Output ( 's' ) zoomChange = new EventEmitter < number > ( ) ; @ Input ( 's' ) center : LatLng ; @ Output ( 's' ) centerChange = new EventEmitter < LatLng > ( ) ; @ Input ( 's' ) fitBounds : LatLngBounds ; @ Input ( 's' ) maxBounds : LatLngBounds ; @ Input ( 's' ) minZoom : number ; @ Input ( 's' ) maxZoom : number ; @ Output ( 's' ) onClick = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onDoubleClick = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMouseDown = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMouseUp = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMouseMove = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMouseOver = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMouseOut = new EventEmitter < LeafletMouseEvent > ( ) ; @ Output ( 's' ) onMapMove = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onMapMoveStart = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onMapMoveEnd = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onMapZoom = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onMapZoomStart = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onMapZoomEnd = new EventEmitter < LeafletEvent > ( ) ; constructor ( private element , private zone ) { } ngOnInit ( ) { this . zone . runOutsideAngular ( ( ) => { this . map = map ( this . element . nativeElement , this . options ) ; this . addMapEventListeners ( ) ; } ) ; if ( null != this . center && null != this . zoom ) { this . setView ( this . center , this . zoom ) ; } if ( null != this . fitBounds ) { this . setFitBounds ( this . fitBounds ) ; } if ( null != this . maxBounds ) { this . setMaxBounds ( this . maxBounds ) ; } if ( null != this . minZoom ) { this . setMinZoom ( this . minZoom ) ; } if ( null != this . maxZoom ) { this . setMaxZoom ( this . maxZoom ) ; } this . doResize ( ) ; this . mapReady . emit ( this . map ) ; } ngOnChanges ( changes : { [ key ] : SimpleChange } ) { if ( changes [ 's' ] && changes [ 's' ] && null != this . zoom && null != this . center ) { this . setView ( changes [ 's' ] . currentValue , changes [ 's' ] . currentValue ) ; } else if ( changes [ 's' ] ) { this . setZoom ( changes [ 's' ] . currentValue ) ; } else if ( changes [ 's' ] ) { this . setCenter ( changes [ 's' ] . currentValue ) ; } if ( changes [ 's' ] ) { this . setFitBounds ( changes [ 's' ] . currentValue ) ; } if ( changes [ 's' ] ) { this . setMaxBounds ( changes [ 's' ] . currentValue ) ; } if ( changes [ 's' ] ) { this . setMinZoom ( changes [ 's' ] . currentValue ) ; } if ( changes [ 's' ] ) { this . setMaxZoom ( changes [ 's' ] . currentValue ) ; } } public getMap ( ) { return this . map ; } @ HostListener ( 's' , [ ] ) onResize ( ) { this . delayResize ( ) ; } private addMapEventListeners ( ) { this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onClick , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onDoubleClick , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMouseDown , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMouseUp , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMouseOver , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMouseOut , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMouseMove , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapZoomStart , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapZoom , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapZoomEnd , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapMoveStart , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapMove , e ) ) ; this . map . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onMapMoveEnd , e ) ) ; this . map . on ( 's' , ( ) => { const zoom = this . map . getZoom ( ) ; if ( zoom !== this . zoom ) { this . zoom = zoom ; LeafletUtil . handleEvent ( this . zone , this . zoomChange , zoom ) ; } const center = this . map . getCenter ( ) ; if ( null != center || null != this . center ) { if ( ( ( null == center || null == this . center ) && center !== this . center ) || ( center . lat !== this . center . lat || center . lng !== this . center . lng ) ) { this . center = center ; LeafletUtil . handleEvent ( this . zone , this . centerChange , center ) ; } } } ) ; } private doResize ( ) { this . zone . runOutsideAngular ( ( ) => { this . map . invalidateSize ( { } ) ; } ) ; } private delayResize ( ) { if ( null != this . resizeTimer ) { clearTimeout ( this . resizeTimer ) ; } this . resizeTimer = setTimeout ( this . doResize . bind ( this ) , 0 ) ; } private setView ( center , zoom ) { if ( this . map && null != center && null != zoom ) { this . map . setView ( center , zoom , this . zoomPanOptions ) ; } } private setZoom ( zoom ) { if ( this . map && null != zoom ) { this . map . setZoom ( zoom , this . zoomOptions ) ; } } private setCenter ( center ) { if ( this . map && null != center ) { this . map . panTo ( center , this . panOptions ) ; } } private setFitBounds ( latLngBounds ) { if ( this . map && null != latLngBounds ) { this . map . fitBounds ( latLngBounds , this . fitBoundsOptions ) ; } } private setMaxBounds ( latLngBounds ) { if ( this . map && null != latLngBounds ) { this . map . setMaxBounds ( latLngBounds ) ; } } private setMinZoom ( zoom ) { if ( this . map && null != zoom ) { this . map . setMinZoom ( zoom ) ; } } private setMaxZoom ( zoom ) { if ( this . map && null != zoom ) { this . map . setMaxZoom ( zoom ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletMouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LatLng$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LatLng$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LatLngBounds$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LatLngBounds$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { LeafletDirective } from 's' ; import { Map } from 's' ; export class LeafletDirectiveWrapper { protected leafletDirective : LeafletDirective ; constructor ( leafletDirective ) { this . leafletDirective = leafletDirective ; } init ( ) { } getMap ( ) { return this . leafletDirective . getMap ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletDirective$ O O O O O O O O O O O O O O $Map$ O O O O O O O O O O O O O O
import { Directive , EventEmitter , Input , NgZone , OnChanges , OnDestroy , OnInit , Output , SimpleChange } from 's' ; import { Layer , LeafletEvent } from 's' ; import { LeafletDirective } from 's' ; import { LeafletDirectiveWrapper } from 's' ; import { LeafletUtil } from 's' ; @ Directive ( { selector : 's' } ) export class LeafletLayerDirective implements OnChanges , OnDestroy , OnInit { @ Input ( 's' ) layer : Layer ; @ Output ( 's' ) onAdd = new EventEmitter < LeafletEvent > ( ) ; @ Output ( 's' ) onRemove = new EventEmitter < LeafletEvent > ( ) ; private leafletDirective : LeafletDirectiveWrapper ; constructor ( leafletDirective , private zone ) { this . leafletDirective = new LeafletDirectiveWrapper ( leafletDirective ) ; } ngOnInit ( ) { this . leafletDirective . init ( ) ; } ngOnDestroy ( ) { this . layer . remove ( ) ; } ngOnChanges ( changes : { [ key ] : SimpleChange } ) { if ( changes [ 's' ] ) { const p = changes [ 's' ] . previousValue ; const n = changes [ 's' ] . currentValue ; this . zone . runOutsideAngular ( ( ) => { if ( null != p ) { p . remove ( ) ; } if ( null != n ) { this . addLayerEventListeners ( n ) ; this . leafletDirective . getMap ( ) . addLayer ( n ) ; } } ) ; } } private addLayerEventListeners ( l ) { l . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onAdd , e ) ) ; l . on ( 's' , ( e ) => LeafletUtil . handleEvent ( this . zone , this . onRemove , e ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletDirective$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $Layer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Layer$ O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletEvent$ O O O O O O O O O O O O O O O O O O O O
import { Directive , DoCheck , Input , IterableDiffer , IterableDiffers , NgZone , OnDestroy , OnInit } from 's' ; import { Layer } from 's' ; import { LeafletDirective } from 's' ; import { LeafletDirectiveWrapper } from 's' ; @ Directive ( { selector : 's' } ) export class LeafletLayersDirective implements DoCheck , OnDestroy , OnInit { layersValue : Layer [ ] ; layersDiffer : IterableDiffer < Layer > ; @ Input ( 's' ) set layers ( v : Layer [ ] ) { this . layersValue = v ; this . updateLayers ( ) ; } get layers ( ) : Layer [ ] { return this . layersValue ; } private leafletDirective : LeafletDirectiveWrapper ; constructor ( leafletDirective , private differs , private zone ) { this . leafletDirective = new LeafletDirectiveWrapper ( leafletDirective ) ; this . layersDiffer = this . differs . find ( [ ] ) . create < Layer > ( ) ; } ngDoCheck ( ) { this . updateLayers ( ) ; } ngOnInit ( ) { this . leafletDirective . init ( ) ; this . updateLayers ( ) ; } ngOnDestroy ( ) { this . layers = [ ] ; } private updateLayers ( ) { const map = this . leafletDirective . getMap ( ) ; if ( null != map && null != this . layersDiffer ) { const changes = this . layersDiffer . diff ( this . layersValue ) ; if ( null != changes ) { this . zone . runOutsideAngular ( ( ) => { changes . forEachRemovedItem ( ( c ) => { map . removeLayer ( c . item ) ; } ) ; changes . forEachAddedItem ( ( c ) => { map . addLayer ( c . item ) ; } ) ; } ) ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletDirective$ O O $IterableDiffers$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class LeafletControlLayersChanges { layersRemoved : number = 0 ; layersChanged : number = 0 ; layersAdded : number = 0 ; changed ( ) { return ! ( this . layersRemoved === 0 && this . layersChanged === 0 && this . layersAdded === 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter , KeyValueChanges , NgZone } from 's' ; import { control , Control , Layer } from 's' ; import { LeafletControlLayersChanges } from 's' ; export class LeafletControlLayersWrapper { protected layersControl : Control . Layers ; protected layersControlReady : EventEmitter < Control . Layers > ; constructor ( private zone , layersControlReady < Control . Layers > ) { this . layersControlReady = layersControlReady ; } getLayersControl ( ) { return this . layersControl ; } init ( controlConfig , controlOptions ) : Control . Layers { const baseLayers = controlConfig . baseLayers || { } ; const overlays = controlConfig . overlays || { } ; this . zone . runOutsideAngular ( ( ) => { this . layersControl = control . layers ( baseLayers , overlays , controlOptions ) ; } ) ; this . layersControlReady . emit ( this . layersControl ) ; return this . layersControl ; } applyBaseLayerChanges ( changes < string , Layer > ) { let results = new LeafletControlLayersChanges ( ) ; if ( null != this . layersControl ) { results = this . applyChanges ( changes , this . layersControl . addBaseLayer ) ; } return results ; } applyOverlayChanges ( changes < string , Layer > ) { let results = new LeafletControlLayersChanges ( ) ; if ( null != this . layersControl ) { results = this . applyChanges ( changes , this . layersControl . addOverlay ) ; } return results ; } private applyChanges ( changes < string , Layer > , addFn : ( layer , name ) => void ) { const results = new LeafletControlLayersChanges ( ) ; if ( null != changes ) { this . zone . runOutsideAngular ( ( ) => { changes . forEachChangedItem ( ( c ) => { this . layersControl . removeLayer ( c . previousValue ) ; addFn . call ( this . layersControl , c . currentValue , c . key ) ; results . layersChanged ++ ; } ) ; changes . forEachRemovedItem ( ( c ) => { this . layersControl . removeLayer ( c . previousValue ) ; results . layersRemoved ++ ; } ) ; changes . forEachAddedItem ( ( c ) => { addFn . call ( this . layersControl , c . currentValue , c . key ) ; results . layersAdded ++ ; } ) ; } ) ; } return results ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletControlLayersChanges$ O $KeyValueChanges$ O O O O O O O O $LeafletControlLayersChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletControlLayersChanges$ O $KeyValueChanges$ O O O O O O O O $LeafletControlLayersChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletControlLayersChanges$ O $KeyValueChanges$ O O O O O O O O O $Layer$ O $string$ O O O O O O $LeafletControlLayersChanges$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Layer } from 's' ; export class LeafletControlLayersConfig { baseLayers : { [ name ] : Layer } = { } ; overlays : { [ name ] : Layer } = { } ; }	O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O
import { Directive , DoCheck , EventEmitter , Input , KeyValueDiffer , KeyValueDiffers , NgZone , OnDestroy , OnInit , Output } from 's' ; import { Control , Layer } from 's' ; import { LeafletDirective } from 's' ; import { LeafletDirectiveWrapper } from 's' ; import { LeafletControlLayersWrapper } from 's' ; import { LeafletControlLayersConfig } from 's' ; @ Directive ( { selector : 's' } ) export class LeafletLayersControlDirective implements DoCheck , OnDestroy , OnInit { layersControlConfigValue : LeafletControlLayersConfig ; baseLayersDiffer : KeyValueDiffer < string , Layer > ; overlaysDiffer : KeyValueDiffer < string , Layer > ; @ Input ( 's' ) set layersControlConfig ( v ) { if ( null == v ) { v = new LeafletControlLayersConfig ( ) ; } if ( null == v . baseLayers ) { v . baseLayers = { } ; } if ( null == v . overlays ) { v . overlays = { } ; } this . layersControlConfigValue = v ; this . updateLayers ( ) ; } get layersControlConfig ( ) : LeafletControlLayersConfig { return this . layersControlConfigValue ; } @ Input ( 's' ) layersControlOptions : any ; @ Output ( 's' ) layersControlReady = new EventEmitter < Control . Layers > ( ) ; private controlLayers : LeafletControlLayersWrapper ; private leafletDirective : LeafletDirectiveWrapper ; constructor ( leafletDirective , private differs , private zone ) { this . leafletDirective = new LeafletDirectiveWrapper ( leafletDirective ) ; this . controlLayers = new LeafletControlLayersWrapper ( this . zone , this . layersControlReady ) ; this . baseLayersDiffer = this . differs . find ( { } ) . create < string , Layer > ( ) ; this . overlaysDiffer = this . differs . find ( { } ) . create < string , Layer > ( ) ; } ngOnInit ( ) { this . leafletDirective . init ( ) ; this . zone . runOutsideAngular ( ( ) => { this . controlLayers . init ( { } , this . layersControlOptions ) . addTo ( this . leafletDirective . getMap ( ) ) ; } ) ; this . updateLayers ( ) ; } ngOnDestroy ( ) { this . layersControlConfig = { baseLayers : { } , overlays : { } } ; this . controlLayers . getLayersControl ( ) . remove ( ) ; } ngDoCheck ( ) { this . updateLayers ( ) ; } protected updateLayers ( ) { const map = this . leafletDirective . getMap ( ) ; const layersControl = this . controlLayers . getLayersControl ( ) ; if ( null != map && null != layersControl ) { if ( null != this . baseLayersDiffer && null != this . layersControlConfigValue . baseLayers ) { const changes = this . baseLayersDiffer . diff ( this . layersControlConfigValue . baseLayers ) ; this . controlLayers . applyBaseLayerChanges ( changes ) ; } if ( null != this . overlaysDiffer && null != this . layersControlConfigValue . overlays ) { const changes = this . overlaysDiffer . diff ( this . layersControlConfigValue . overlays ) ; this . controlLayers . applyOverlayChanges ( changes ) ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletControlLayersConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletDirective$ O O $KeyValueDiffers$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Directive , DoCheck , EventEmitter , Input , KeyValueDiffer , KeyValueDiffers , NgZone , OnDestroy , OnInit , Output } from 's' ; import { Control , Layer } from 's' ; import { LeafletUtil } from 's' ; import { LeafletDirective } from 's' ; import { LeafletDirectiveWrapper } from 's' ; import { LeafletControlLayersWrapper } from 's' ; @ Directive ( { selector : 's' } ) export class LeafletBaseLayersDirective implements DoCheck , OnDestroy , OnInit { baseLayersValue : { [ name ] : Layer } ; baseLayersDiffer : KeyValueDiffer < string , Layer > ; @ Input ( 's' ) set baseLayers ( v : { [ name ] : Layer } ) { this . baseLayersValue = v ; this . updateBaseLayers ( ) ; } get baseLayers ( ) : { [ name ] : Layer } { return this . baseLayersValue ; } @ Input ( 's' ) layersControlOptions : Control . LayersOptions ; @ Output ( 's' ) layersControlReady = new EventEmitter < Control . Layers > ( ) ; private baseLayer : Layer ; private leafletDirective : LeafletDirectiveWrapper ; private controlLayers : LeafletControlLayersWrapper ; constructor ( leafletDirective , private differs , private zone ) { this . leafletDirective = new LeafletDirectiveWrapper ( leafletDirective ) ; this . controlLayers = new LeafletControlLayersWrapper ( this . zone , this . layersControlReady ) ; this . baseLayersDiffer = this . differs . find ( { } ) . create < string , Layer > ( ) ; } ngOnDestroy ( ) { this . baseLayers = { } ; this . controlLayers . getLayersControl ( ) . remove ( ) ; } ngOnInit ( ) { this . leafletDirective . init ( ) ; this . zone . runOutsideAngular ( ( ) => { this . controlLayers . init ( { } , this . layersControlOptions ) . addTo ( this . leafletDirective . getMap ( ) ) ; } ) ; this . updateBaseLayers ( ) ; } ngDoCheck ( ) { this . updateBaseLayers ( ) ; } protected updateBaseLayers ( ) { const map = this . leafletDirective . getMap ( ) ; const layersControl = this . controlLayers . getLayersControl ( ) ; if ( null != map && null != layersControl && null != this . baseLayersDiffer ) { const changes = this . baseLayersDiffer . diff ( this . baseLayersValue ) ; const results = this . controlLayers . applyBaseLayerChanges ( changes ) ; if ( results . changed ( ) ) { this . syncBaseLayer ( ) ; } } } protected syncBaseLayer ( ) { const map = this . leafletDirective . getMap ( ) ; const layers = LeafletUtil . mapToArray ( this . baseLayers ) ; let foundLayer ; map . eachLayer ( ( l ) => { foundLayer = layers . find ( ( bl ) => ( l === bl ) ) ; } ) ; if ( null != foundLayer ) { this . baseLayer = foundLayer ; } else { if ( layers . length > 0 ) { this . baseLayer = layers [ 0 ] ; this . zone . runOutsideAngular ( ( ) => { this . baseLayer . addTo ( map ) ; } ) ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LeafletDirective$ O O $KeyValueDiffers$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Layer$ O O O O O O $Layer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ModuleWithProviders , NgModule } from 's' ; import { LeafletDirective } from 's' ; import { LeafletLayerDirective } from 's' ; import { LeafletLayersDirective } from 's' ; import { LeafletLayersControlDirective } from 's' ; import { LeafletBaseLayersDirective } from 's' ; @ NgModule ( { exports : [ LeafletDirective , LeafletLayerDirective , LeafletLayersDirective , LeafletLayersControlDirective , LeafletBaseLayersDirective ] , declarations : [ LeafletDirective , LeafletLayerDirective , LeafletLayersDirective , LeafletLayersControlDirective , LeafletBaseLayersDirective ] } ) export class LeafletModule { static forRoot ( ) { return { ngModule : LeafletModule , providers : [ ] } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ModuleWithProviders$ O O O O O O O O O O O O O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletDemoComponent { showDemo = false ; ngOnInit ( ) { setTimeout ( ( ) => { this . showDemo = true ; } , 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { latLng , LatLng , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletCoreDemoComponent { optionsSpec : any = { layers : [ { url : 's' , attribution : 's' } ] , zoom : 0 , center : [ 0 , - 0 ] } ; zoom = this . optionsSpec . zoom ; center = latLng ( this . optionsSpec . center ) ; options = { layers : [ tileLayer ( this . optionsSpec . layers [ 0 ] . url , { attribution : this . optionsSpec . layers [ 0 ] . attribution } ) ] , zoom : this . optionsSpec . zoom , center : latLng ( this . optionsSpec . center ) } ; formZoom = this . zoom ; zoomLevels = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; lat = this . center . lat ; lng = this . center . lng ; onCenterChange ( center ) { setTimeout ( ( ) => { this . lat = center . lat ; this . lng = center . lng ; } ) ; } onZoomChange ( zoom ) { setTimeout ( ( ) => { this . formZoom = zoom ; } ) ; } doApply ( ) { this . center = latLng ( this . lat , this . lng ) ; this . zoom = this . formZoom ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LatLng$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { Subject } from 's' ; import { debounceTime , scan } from 's' ; import { latLng , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletEventsDemoComponent { eventCount = 0 ; eventLog : string = 's' ; options = { zoom : 0 , center : latLng ( [ 0 , - 0 ] ) } ; baselayer = tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) ; eventSubject = new Subject < string > ( ) ; constructor ( ) { this . eventSubject . pipe ( scan ( ( acc , v ) => `template` , 's' ) , debounceTime ( 0 ) ) . subscribe ( ( v ) => { this . eventLog = v ; } ) ; } handleEvent ( eventType ) { this . eventSubject . next ( eventType ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O
import { Layer } from 's' ; export class LeafletLayersDemoModel { constructor ( public baseLayers : { id : string , name : string , enabled : boolean , layer : Layer } [ ] , public baseLayer , public overlayLayers : { id : string , name : string , enabled : boolean , layer : Layer } [ ] = [ ] ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { circle , geoJSON , icon , latLng , Layer , marker , polygon , tileLayer } from 's' ; import { LeafletLayersDemoModel } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletLayersDemoComponent { LAYER_OCM = { id : 's' , name : 's' , enabled : true , layer : tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) } ; LAYER_OSM = { id : 's' , name : 's' , enabled : false , layer : tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) } ; circle = { id : 's' , name : 's' , enabled : true , layer : circle ( [ 0 , - 0 ] , { radius : 0 } ) } ; polygon = { id : 's' , name : 's' , enabled : true , layer : polygon ( [ [ 0 , - 0 ] , [ 0 , - 0 ] , [ 0 , - 0 ] ] ) } ; square = { id : 's' , name : 's' , enabled : true , layer : polygon ( [ [ 0 , - 0 ] , [ 0 , - 0 ] , [ 0 , - 0 ] , [ 0 , - 0 ] ] ) } ; marker = { id : 's' , name : 's' , enabled : true , layer : marker ( [ 0 , - 0 ] , { icon : icon ( { iconSize : [ 0 , 0 ] , iconAnchor : [ 0 , 0 ] , iconUrl : 's' , shadowUrl : 's' } ) } ) } ; geoJSON = { id : 's' , name : 's' , enabled : true , layer : geoJSON ( ( { type : 's' , coordinates : [ [ [ - 0 , 0 ] , [ - 0 , 0 ] , [ - 0 , 0 ] , [ - 0 , 0 ] ] ] } ) as any , { style : ( ) => ( { color : 's' } ) } ) } ; model = new LeafletLayersDemoModel ( [ this . LAYER_OSM , this . LAYER_OCM ] , this . LAYER_OCM . id , [ this . circle , this . polygon , this . square , this . marker , this . geoJSON ] ) ; layers : Layer [ ] ; layersControl = { baseLayers : { 's' : this . LAYER_OSM . layer , 's' : this . LAYER_OCM . layer } , overlays : { Circle : this . circle . layer , Square : this . square . layer , Polygon : this . polygon . layer , Marker : this . marker . layer , GeoJSON : this . geoJSON . layer } } ; options = { zoom : 0 , center : latLng ( 0 , - 0 ) } ; constructor ( ) { this . apply ( ) ; } apply ( ) { const baseLayer = this . model . baseLayers . find ( ( l ) => ( l . id === this . model . baseLayer ) ) ; const newLayers = this . model . overlayLayers . filter ( ( l ) => l . enabled ) . map ( ( l ) => l . layer ) ; newLayers . unshift ( baseLayer . layer ) ; this . layers = newLayers ; return false ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { icon , latLng , marker , Marker , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletNgForLayersDemoComponent { LAYER_OSM = tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) ; options = { layers : [ this . LAYER_OSM ] , zoom : 0 , center : latLng ( 0 , - 0 ) } ; markers : Marker [ ] = [ ] ; addMarker ( ) { const newMarker = marker ( [ 0 + 0 * ( Math . random ( ) - 0 ) , - 0 + 0 * ( Math . random ( ) - 0 ) ] , { icon : icon ( { iconSize : [ 0 , 0 ] , iconAnchor : [ 0 , 0 ] , iconUrl : 's' , shadowUrl : 's' } ) } ) ; this . markers . push ( newMarker ) ; } removeMarker ( ) { this . markers . pop ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { latLng , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletBaseLayersDemoComponent { LAYER_OCM = { id : 's' , name : 's' , enabled : true , layer : tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) } ; LAYER_OSM = { id : 's' , name : 's' , enabled : false , layer : tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) } ; layersControlOptions = { position : 's' } ; baseLayers = { 's' : this . LAYER_OSM . layer , 's' : this . LAYER_OCM . layer } ; options = { zoom : 0 , center : latLng ( 0 , - 0 ) } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' ; import { icon , latLng , Layer , marker , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class LeafletMarkersDemoComponent { LAYER_OSM = tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) ; options = { layers : [ this . LAYER_OSM ] , zoom : 0 , center : latLng ( 0 , - 0 ) } ; markers : Layer [ ] = [ ] ; addMarker ( ) { const newMarker = marker ( [ 0 + 0 * ( Math . random ( ) - 0 ) , - 0 + 0 * ( Math . random ( ) - 0 ) ] , { icon : icon ( { iconSize : [ 0 , 0 ] , iconAnchor : [ 0 , 0 ] , iconUrl : 's' , shadowUrl : 's' } ) } ) ; this . markers . push ( newMarker ) ; } removeMarker ( ) { this . markers . pop ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangeDetectionStrategy , Component } from 's' ; import { icon , Layer , marker } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , changeDetection : ChangeDetectionStrategy . OnPush } ) export class LeafletPerformanceDemoComponent { markers : Layer [ ] = [ ] ; mutableAdd ( ) { const newMarker = marker ( [ 0 + 0 * ( Math . random ( ) - 0 ) , - 0 + 0 * ( Math . random ( ) - 0 ) ] , { icon : icon ( { iconSize : [ 0 , 0 ] , iconAnchor : [ 0 , 0 ] , iconUrl : 's' , shadowUrl : 's' } ) } ) ; this . markers . push ( newMarker ) ; } mutableRemove ( ) { this . markers . pop ( ) ; } newArray ( ) { this . markers = this . markers . slice ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ChangeDetectionStrategy , Component , Input } from 's' ; import { latLng , Layer , tileLayer } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , changeDetection : ChangeDetectionStrategy . OnPush } ) export class LeafletWrapperComponent { @ Input ( 's' ) markers : Layer [ ] = [ ] ; LAYER_OSM = tileLayer ( 's' , { maxZoom : 0 , attribution : 's' } ) ; options = { layers : [ this . LAYER_OSM ] , zoom : 0 , center : latLng ( 0 , - 0 ) } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' ; import { CommonModule } from 's' ; import { FormsModule } from 's' ; import { LeafletModule } from 's' ; import { LeafletDemoComponent } from 's' ; import { LeafletCoreDemoComponent } from 's' ; import { LeafletEventsDemoComponent } from 's' ; import { LeafletLayersDemoComponent } from 's' ; import { LeafletNgForLayersDemoComponent } from 's' ; import { LeafletBaseLayersDemoComponent } from 's' ; import { LeafletMarkersDemoComponent } from 's' ; import { LeafletPerformanceDemoComponent } from 's' ; import { LeafletWrapperComponent } from 's' ; @ NgModule ( { imports : [ CommonModule , FormsModule , LeafletModule . forRoot ( ) ] , declarations : [ LeafletDemoComponent , LeafletCoreDemoComponent , LeafletEventsDemoComponent , LeafletLayersDemoComponent , LeafletNgForLayersDemoComponent , LeafletBaseLayersDemoComponent , LeafletMarkersDemoComponent , LeafletPerformanceDemoComponent , LeafletWrapperComponent ] , exports : [ LeafletDemoComponent ] , bootstrap : [ LeafletDemoComponent ] , providers : [ ] } ) export class LeafletDemoModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' ; import { BrowserModule } from 's' ; import { AppComponent } from 's' ; import { LeafletDemoModule } from 's' ; @ NgModule ( { imports : [ BrowserModule , LeafletDemoModule ] , declarations : [ AppComponent ] , bootstrap : [ AppComponent ] , providers : [ ] } ) export class AppModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import { platformBrowserDynamic } from 's' ; import { AppModule } from 's' ; platformBrowserDynamic ( ) . bootstrapModule ( AppModule ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ; import 's' ;	O O O O O O O O O O O O O O O O O O O O O
import { tileLayer , TileLayer } from 's' ; export class LeafletTileLayerDefinition { constructor ( public type , public url , public options ) { } static createTileLayer ( layerDef ) { let layer ; switch ( layerDef . type ) { case 's' : layer = tileLayer ( layerDef . url , layerDef . options ) ; break ; case 's' : default : layer = tileLayer . wms ( layerDef . url , layerDef . options ) ; break ; } return layer ; } static createTileLayers ( layerDefs : { [ key ] : LeafletTileLayerDefinition } ) : { [ key ] : TileLayer } { const layers : { [ key ] : TileLayer } = { } ; for ( const k in layerDefs ) { if ( layerDefs . hasOwnProperty ( k ) ) { layers [ k ] = ( LeafletTileLayerDefinition . createTileLayer ( layerDefs [ k ] ) ) ; } } return layers ; } createTileLayer ( ) { return LeafletTileLayerDefinition . createTileLayer ( this ) ; } }	O O O O O O O O O O O O O O O O $string$ O O $string$ O O $any$ O O O O $TileLayer$ O $LeafletTileLayerDefinition$ O O O $TileLayer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TileLayer$ O O O O O O O O O O O O O
export { LeafletModule } from 's' ; export { LeafletDirective } from 's' ; export { LeafletDirectiveWrapper } from 's' ; export { LeafletUtil } from 's' ; export { LeafletLayerDirective } from 's' ; export { LeafletLayersDirective } from 's' ; export { LeafletTileLayerDefinition } from 's' ; export { LeafletBaseLayersDirective } from 's' ; export { LeafletLayersControlDirective } from 's' ; export { LeafletControlLayersWrapper } from 's' ; export { LeafletControlLayersConfig } from 's' ; export { LeafletControlLayersChanges } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const path = require ( 's' ) , webpack = require ( 's' ) , StatsWriterPlugin = require ( 's' ) . StatsWriterPlugin , HtmlWebpackPlugin = require ( 's' ) , pkg = require ( 's' ) ; module . exports = ( ) => { let wpConfig = { mode : 's' } ; wpConfig . devServer = { port : 0 , stats : { modules : false , colors : true } , watchOptions : { aggregateTimeout : 0 , poll : 0 } } ; wpConfig . devtool = 's' ; wpConfig . entry = { application : path . posix . resolve ( 's' ) } ; wpConfig . output = { path : path . posix . resolve ( 's' ) , publicPath : 's' , filename : 's' , chunkFilename : 's' } ; wpConfig . resolve = { extensions : [ 's' , 's' , 's' ] } ; wpConfig . module = { rules : [ { test : "s" , parser : { system : true } , } , { test : "s" , use : 's' } , { test : "s" , use : 's' , enforce : 's' , exclude : [ "s" ] } , { test : "s" , use : 's' , enforce : 's' } , { test : "s" , use : [ 's' , 's' , 's' , 's' ] } , { test : "s" , use : 's' } , { test : "s" , use : 's' } , { test : "s" , use : 's' } , { test : "s" , use : 's' } , { test : "s" , use : 's' } ] } ; wpConfig . optimization = { splitChunks : { chunks : 's' , } } ; wpConfig . plugins = [ ] ; wpConfig . plugins . push ( new webpack . ProvidePlugin ( { } ) , new StatsWriterPlugin ( { chunkModules : true , filename : 's' , fields : null } ) , new webpack . ContextReplacementPlugin ( "s" , path . posix . resolve ( 's' ) ) , new HtmlWebpackPlugin ( { template : path . posix . resolve ( 's' ) , inject : 's' } ) ) ; return wpConfig ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O