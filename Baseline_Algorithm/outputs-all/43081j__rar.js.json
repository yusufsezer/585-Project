'js' ( function ( ) { 's' ; var Reader = function ( type ) { this . type = type || Reader . OPEN_URI ; this . size = null ; this . file = null ; } ; Reader . OPEN_FILE = 0 ; Reader . OPEN_URI = 0 ; Reader . OPEN_LOCAL = 0 ; if ( typeof require === 's' ) { var fs = require ( 's' ) ; } Reader . prototype . open = function ( file , callback ) { this . file = file ; var self = this ; switch ( this . type ) { case Reader . OPEN_LOCAL : fs . stat ( this . file , function ( err , stat ) { if ( err ) { return callback ( err ) ; } self . size = stat . size ; fs . open ( self . file , 's' , function ( err , fd ) { if ( err ) { return callback ( err ) ; } self . fd = fd ; callback ( ) ; } ) ; } ) ; break ; case Reader . OPEN_FILE : this . size = this . file . size ; callback ( ) ; break ; default : this . ajax ( { uri : this . file , type : 's' , } , function ( err , resp , xhr ) { if ( err ) { return callback ( err ) ; } self . size = parseInt ( xhr . getResponseHeader ( 's' ) ) ; callback ( ) ; } ) ; break ; } } ; Reader . prototype . close = function ( ) { if ( this . type === Reader . OPEN_LOCAL ) { fs . close ( this . fd ) ; } } ; Reader . prototype . read = function ( length , position , callback ) { if ( this . type === Reader . OPEN_LOCAL ) { this . readLocal ( length , position , callback ) ; } else if ( this . type === Reader . OPEN_FILE ) { this . readFile ( length , position , callback ) ; } else { this . readUri ( length , position , callback ) ; } } ; Reader . prototype . readBlob = function ( length , position , type , callback ) { if ( typeof type === 's' ) { callback = type ; type = 's' ; } this . read ( length , position , function ( err , data ) { if ( err ) { callback ( err ) ; return ; } callback ( null , new Blob ( [ data ] , { type : type } ) ) ; } ) ; } ; Reader . prototype . readLocal = function ( length , position , callback ) { var buffer = new Buffer ( length ) ; fs . read ( this . fd , buffer , 0 , length , position , function ( err , bytesRead , buffer ) { if ( err ) { return callback ( err ) ; } var ab = new ArrayBuffer ( buffer . length ) , view = new 0 ( ab ) ; for ( var i = 0 ; i < buffer . length ; i ++ ) { view [ i ] = buffer [ i ] ; } callback ( null , ab ) ; } ) ; } ; Reader . prototype . ajax = function ( opts , callback ) { var options = { type : 's' , uri : null , responseType : 's' } ; if ( typeof opts === 's' ) { opts = { uri : opts } ; } for ( var k in opts ) { options [ k ] = opts [ k ] ; } var xhr = new XMLHttpRequest ( ) ; xhr . onreadystatechange = function ( ) { if ( xhr . readyState !== 0 ) return ; if ( xhr . status !== 0 && xhr . status !== 0 ) { return callback ( 's' + xhr . status + 's' ) ; } callback ( null , xhr . response , xhr ) ; } ; xhr . responseType = options . responseType ; xhr . open ( options . type , options . uri , true ) ; if ( options . range ) { options . range = [ ] . concat ( options . range ) ; if ( options . range . length === 0 ) { xhr . setRequestHeader ( 's' , 's' + options . range [ 0 ] + 's' + options . range [ 0 ] ) ; } else { xhr . setRequestHeader ( 's' , 's' + options . range [ 0 ] ) ; } } xhr . send ( ) ; } ; Reader . prototype . readUri = function ( length , position , callback ) { this . ajax ( { uri : this . file , type : 's' , responseType : 's' , range : [ position , position + length - 0 ] } , function ( err , buffer ) { if ( err ) { return callback ( err ) ; } return callback ( null , buffer ) ; } ) ; } ; Reader . prototype . readFile = function ( length , position , callback ) { var slice = this . file . slice ( position , position + length ) , fr = new FileReader ( ) ; fr . onload = function ( e ) { callback ( null , e . target . result ) ; } ; fr . onerror = function ( e ) { callback ( 's' ) ; } ; fr . readAsArrayBuffer ( slice ) ; } ; DataView . prototype . getString = function ( length , offset , raw ) { offset = offset || 0 ; length = length || ( this . byteLength - offset ) ; if ( length < 0 ) { length += this . byteLength ; } var str = 's' ; if ( typeof Buffer !== 's' ) { var data = [ ] ; for ( var i = offset ; i < ( offset + length ) ; i ++ ) { data . push ( this . 0 ( i ) ) ; } return ( new Buffer ( data ) ) . toString ( ) ; } else { for ( var i = offset ; i < ( offset + length ) ; i ++ ) { str += String . fromCharCode ( this . 0 ( i ) ) ; } if ( raw ) { return str ; } return decodeURIComponent ( escape ( str ) ) ; } } ; DataView . prototype . 0 = function ( length , offset , bom ) { offset = offset || 0 ; length = length || ( this . byteLength - offset ) ; var littleEndian = false , str = 's' , useBuffer = false ; if ( typeof Buffer !== 's' ) { str = [ ] ; useBuffer = true ; } if ( length < 0 ) { length += this . byteLength ; } if ( bom ) { var bomInt = this . 0 ( offset ) ; if ( bomInt === 0 ) { littleEndian = true ; } offset += 0 ; length -= 0 ; } for ( var i = offset ; i < ( offset + length ) ; i += 0 ) { var ch = this . 0 ( i , littleEndian ) ; if ( ( ch >= 0 && ch <= 0 ) || ( ch >= 0 && ch <= 0 ) ) { if ( useBuffer ) { str . push ( ch ) ; } else { str += String . fromCharCode ( ch ) ; } } else if ( ch >= 0 && ch <= 0 ) { ch -= 0 ; if ( useBuffer ) { str . push ( ( ( 0 & ch ) >> 0 ) + 0 ) ; str . push ( ( 0 & ch ) + 0 ) ; } else { str += String . fromCharCode ( ( ( 0 & ch ) >> 0 ) + 0 ) + String . fromCharCode ( ( 0 & ch ) + 0 ) ; } } } if ( useBuffer ) { return ( new Buffer ( str ) ) . toString ( ) ; } else { return decodeURIComponent ( escape ( str ) ) ; } } ; DataView . prototype . getSynch = function ( num ) { var out = 0 , mask = 0 ; while ( mask ) { out >>= 0 ; out |= num & mask ; mask >>= 0 ; } return out ; } ; DataView . prototype . 0 = function ( offset ) { return this . getSynch ( this . 0 ( offset ) ) ; } ; DataView . prototype . 0 = function ( offset ) { return this . getSynch ( this . 0 ( offset ) ) ; } ; DataView . prototype . 0 = function ( offset , littleEndian ) { if ( littleEndian ) { return this . 0 ( offset ) + ( this . 0 ( offset + 0 ) << 0 ) + ( this . 0 ( offset + 0 ) << 0 ) ; } return this . 0 ( offset + 0 ) + ( this . 0 ( offset + 0 ) << 0 ) + ( this . 0 ( offset ) << 0 ) ; } ; var RarEntry = function ( ) { this . name = null ; this . path = null ; this . size = 0 ; this . sizePacked = 0 ; this . crc = null ; this . offset = 0 ; this . blockSize = 0 ; this . headerSize = 0 ; this . encrypted = false ; this . version = null ; this . time = null ; this . method = null ; this . os = null ; this . partial = false ; this . continuesFrom = false ; this . continues = false ; } ; RarEntry . METHOD_STORE = 0 ; RarEntry . METHOD_FASTEST = 0 ; RarEntry . METHOD_FAST = 0 ; RarEntry . METHOD_NORMAL = 0 ; RarEntry . METHOD_GOOD = 0 ; RarEntry . METHOD_BEST = 0 ; var RarArchive = function ( ) { if ( ! ( this instanceof RarArchive ) ) { return new RarArchive ( arguments [ 0 ] , arguments [ 0 ] ) ; } this . options = { type : RarArchive . OPEN_URI , } ; var opts = arguments [ 0 ] ; if ( typeof opts === 's' ) { opts = { file : opts , type : RarArchive . OPEN_URI } ; } else if ( typeof window !== 's' && window . File && opts instanceof window . File ) { opts = { file : opts , type : RarArchive . OPEN_FILE } ; } for ( var k in opts ) { this . options [ k ] = opts [ k ] ; } if ( ! this . options . file ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , 's' ) ; return ; } if ( this . options . type === RarArchive . OPEN_FILE ) { if ( typeof window === 's' || ! window . File || ! window . FileReader || typeof ArrayBuffer === 's' ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , 's' ) ; } } else if ( this . options . type === RarArchive . OPEN_LOCAL ) { if ( typeof require !== 's' ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , 's' ) ; return ; } } else { } this . file = this . options . file ; this . rd = new Reader ( this . options . type ) ; this . entries = [ ] ; this . valid = false ; this . validate ( arguments [ 0 ] ) ; } ; RarArchive . prototype . validate = function ( callback ) { var self = this ; this . rd . open ( this . file , function ( err ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return ; } self . rd . read ( 0 , 0 , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return ; } var view = new DataView ( data ) ; if ( view . getString ( 0 , 0 , true ) !== 's' ) { if ( callback ) callback . call ( self , 's' ) ; return ; } var crc = view . 0 ( 0 , true ) , type = view . 0 ( 0 ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; if ( type !== 0 ) { if ( callback ) callback . call ( self , 's' ) ; return ; } if ( ( flags & 0 ) !== 0 ) { if ( callback ) callback . call ( self , 's' ) ; return ; } self . valid = true ; self . readHeaders ( size + 0 , callback ) ; } ) ; } ) ; } ; RarArchive . prototype . parseEntry = function ( offset , callback ) { var self = this ; this . rd . read ( 0 , offset , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return ; } var view = new DataView ( data ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; self . rd . read ( size , offset , function ( err , data ) { var view = new DataView ( data ) ; var entry = new RarEntry ; entry . partial = ( ( flags & 0 ) !== 0 || ( flags & 0 ) !== 0 ) ; entry . continuesFrom = ( ( flags & 0 ) !== 0 ) ; entry . continues = ( ( flags & 0 ) !== 0 ) ; entry . offset = offset ; entry . sizePacked = view . 0 ( 0 , true ) ; entry . size = view . 0 ( 0 , true ) ; entry . crc = view . 0 ( 0 , true ) ; entry . time = ( function ( ) { var time = view . 0 ( 0 , true ) . toString ( 0 ) ; if ( time . length < 0 ) { time = ( new Array ( 0 - time . length + 0 ) ) . join ( 's' ) + time ; } time = time . match ( "s" ) . slice ( 0 ) . map ( function ( val ) { return parseInt ( val , 0 ) ; } ) ; return new Date ( 0 + time [ 0 ] , time [ 0 ] - 0 , time [ 0 ] , time [ 0 ] , time [ 0 ] , time [ 0 ] ) ; } ) ( ) ; entry . os = ( function ( ) { var os = view . 0 ( 0 ) ; switch ( os ) { case 0 : return 's' ; case 0 : return 's' ; case 0 : return 's' ; case 0 : return 's' ; case 0 : return 's' ; case 0 : return 's' ; } } ) ( ) ; entry . version = view . 0 ( 0 ) ; entry . method = view . 0 ( 0 ) ; entry . encrypted = ( ( flags & 0 ) !== 0 ) ; var nameSize = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { entry . sizePacked += view . 0 ( 0 , true ) * 0 ; entry . size += view . 0 ( 0 , true ) * 0 ; entry . path = view . getString ( nameSize , 0 ) ; } else { entry . path = view . getString ( nameSize , 0 ) ; } if ( ( flags & 0 ) !== 0 && entry . path . indexOf ( 's' ) !== - 0 ) { entry . path = entry . path . split ( 's' ) [ 0 ] ; } entry . name = entry . path ; if ( entry . name . indexOf ( 's' ) !== - 0 ) { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } else { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } entry . headerSize = size ; entry . blockSize = entry . headerSize + entry . sizePacked ; if ( callback ) callback . call ( self , null , entry ) ; } ) ; } ) ; } ; RarArchive . prototype . readHeaders = function ( offset , callback ) { var self = this ; var cb = function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return ; } var view = new DataView ( data ) , crc = view . 0 ( 0 , true ) , type = view . 0 ( 0 ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { size += view . 0 ( 0 , true ) ; } switch ( type ) { case 0 : self . parseEntry ( offset , function ( err , entry ) { if ( err ) { if ( callback ) callback . call ( self , 's' ) ; return ; } self . entries . push ( entry ) ; offset += entry . blockSize ; if ( offset >= self . rd . size ) { if ( callback ) callback . call ( self , null ) ; return ; } self . rd . read ( 0 , offset , cb ) ; } ) ; break ; default : offset += size ; if ( offset >= self . rd . size ) { if ( callback ) callback . call ( self , null ) ; return ; } self . rd . read ( 0 , offset , cb ) ; break ; } } ; if ( this . rd . size <= 0 ) { if ( callback ) callback . call ( self , null , this . entries ) ; return ; } this . rd . read ( 0 , offset , cb ) ; } ; RarArchive . prototype . get = function ( entry , callback ) { if ( ! this . valid ) { if ( callback ) callback . call ( this , 's' ) ; return ; } if ( ! ( entry instanceof RarEntry ) ) { if ( callback ) callback . call ( this , 's' ) ; return ; } if ( entry . method !== RarEntry . METHOD_STORE ) { if ( callback ) callback . call ( this , 's' ) ; return ; } this . rd . readBlob ( entry . blockSize - 0 , entry . offset + entry . headerSize , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return ; } if ( callback ) callback . call ( self , null , data ) ; } ) ; } ; RarArchive . OPEN_FILE = Reader . OPEN_FILE ; RarArchive . OPEN_URI = Reader . OPEN_URI ; RarArchive . OPEN_LOCAL = Reader . OPEN_LOCAL ; if ( typeof module !== 's' && module . exports ) { module . exports = RarArchive ; } else { if ( typeof define === 's' && define . amd ) { define ( 's' , [ ] , function ( ) { return RarArchive ; } ) ; } else { window . RarArchive = RarArchive ; } } } ) ( ) ;	O O O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O O O O $any$ O O O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $Reader$ O O O O O O O $any$ O O O $any$ O $number$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $Reader$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Reader$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $Reader$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $number$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O $any$ O O O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $Reader$ O $any$ O $number$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $number$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $number$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $complex$ O O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O $any$ O $any$ O O O O O O O $ArrayBuffer$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $number$ O O $any$ O $number$ O O O $any$ O O O $ArrayBuffer$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $complex$ O O $string$ O O O $null$ O O O $string$ O O O O O O O $any$ O O O O $any$ O O $string$ O $string$ O O O O O O $string$ O $any$ O O $complex$ O $string$ O O $any$ O $string$ O O O O $XMLHttpRequest$ O O $complex$ O O O $XMLHttpRequest$ O $any$ O O O O O O O $XMLHttpRequest$ O $number$ O O O O O O O $XMLHttpRequest$ O $number$ O O O $XMLHttpRequest$ O $number$ O O O O O $any$ O O O $XMLHttpRequest$ O $number$ O O O O O $any$ O O O $XMLHttpRequest$ O $any$ O $XMLHttpRequest$ O O O O $XMLHttpRequest$ O $XMLHttpRequestResponseType$ O $complex$ O $string$ O $XMLHttpRequest$ O $complex$ O $complex$ O $string$ O $complex$ O $any$ O O O O O O $complex$ O $any$ O O $complex$ O $any$ O O O O $complex$ O $complex$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $XMLHttpRequest$ O $void$ O O O O O $complex$ O $any$ O O O O O O $complex$ O $any$ O O O O O O O O $XMLHttpRequest$ O $void$ O O O O O $complex$ O $any$ O O O O O O O $XMLHttpRequest$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O O $void$ O O $any$ O O O $any$ O $string$ O O O $string$ O O O $any[]$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $FileReader$ O O $complex$ O O O $FileReader$ O $any$ O O O $ProgressEvent<FileReader>$ O O $any$ O O O $ProgressEvent<FileReader>$ O $FileReader$ O $complex$ O O O O $FileReader$ O $any$ O O O $ProgressEvent<FileReader>$ O O $any$ O O O O O O $FileReader$ O $void$ O $any$ O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O $string$ O O O O O O $any$ O O O O O $any[]$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O O O O O $any$ O $any[]$ O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $string$ O $StringConstructor$ O $string$ O O O $any$ O $any$ O O O O O O $any$ O O O $string$ O O O $string$ O $string$ O $string$ O O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $boolean$ O O O $string$ O O O $boolean$ O O O O O O $any$ O O O O $string$ O O O O $boolean$ O O O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O $boolean$ O O $string$ O $any$ O $any$ O O O O O $string$ O $StringConstructor$ O $string$ O $any$ O O O O O O O $any$ O O O $any$ O O O O $any$ O O O O O $boolean$ O O $string$ O $any$ O O O O O $any$ O O O O O O O O $string$ O $any$ O O O O $any$ O O O O O O O O $string$ O $StringConstructor$ O $string$ O O O O O $any$ O O O O O O O O $StringConstructor$ O $string$ O O O O $any$ O O O O O O O O O O $boolean$ O O O O O $any$ O $string$ O O O $any$ O O O O O O O $string$ O $string$ O $string$ O O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O $number$ O O O $number$ O O O O O $number$ O O $number$ O O O $number$ O $any$ O $number$ O $number$ O O O O O $number$ O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $boolean$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O $any$ O $IArguments$ O O O O $IArguments$ O O O O O O O O $complex$ O O $number$ O $any$ O $number$ O O O O $any$ O $IArguments$ O O O O O O O $any$ O O O O $any$ O O $string$ O $string$ O $number$ O $any$ O $number$ O O O O O O O $complex$ O O O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O O $any$ O O $File$ O $File$ O $number$ O $any$ O $number$ O O O O O O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O $string$ O O O O O O O O $any$ O $any$ O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O $complex$ O O O O $complex$ O $complex$ O O $complex$ O $complex$ O O $ArrayBufferConstructor$ O O O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O $Reader$ O O $any$ O O O $any$ O $any$ O O O O $any[]$ O O O O O O $boolean$ O O O O O $any$ O $IArguments$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O O O $RarArchive$ O O O O O $Reader$ O $void$ O O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O $RarArchive$ O $Reader$ O $void$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O O $DataView$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O O O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O $RarArchive$ O $boolean$ O O O $RarArchive$ O $void$ O $number$ O O O $any$ O O O O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $RarArchive$ O O O O O $Reader$ O $void$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O $RarArchive$ O $Reader$ O $void$ O $number$ O $any$ O O O $any$ O $any$ O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O $RarEntry$ O O $any$ O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $number$ O $any$ O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O O O O O O O $string$ O $DataView$ O $number$ O O O O O O $string$ O O O O O O $string$ O $number$ O O O O $string$ O O O $ArrayConstructor$ O O O $string$ O $number$ O O O O O $string$ O O O O $string$ O O $string$ O $string$ O $complex$ O O O O $string[]$ O O O O $U[]$ O O O $string$ O O O $number$ O $string$ O O O O O O O O O $DateConstructor$ O O O $string$ O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O O O O $RarEntry$ O $any$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $any$ O $DataView$ O $any$ O $number$ O O O O O O O $RarEntry$ O $any$ O $DataView$ O $any$ O $number$ O O O O O O O O $number$ O O O O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $number$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O O $any$ O $any$ O $any$ O $RarArchive$ O O O $RarEntry$ O O O O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $RarArchive$ O O O O $void$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O $RarArchive$ O $void$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O $RarArchive$ O $any[]$ O $number$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $RarArchive$ O $Reader$ O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O $RarArchive$ O $Reader$ O $void$ O O O $any$ O $void$ O O O O O O O O O $any$ O $number$ O O O $any$ O $RarArchive$ O $Reader$ O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O $RarArchive$ O $Reader$ O $void$ O O O $any$ O $void$ O O O O O O O O O O O $Reader$ O $any$ O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O $any[]$ O O O O O O O $Reader$ O $void$ O O O $any$ O $void$ O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $RarEntry$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $Reader$ O $void$ O $RarEntry$ O $number$ O O O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O O O O O O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $complex$ O $any$ O $any$ O O O O O O O O
'js' var Rar = require ( 's' ) ; Rar . fromLocal ( 's' ) . then ( ( archive ) => { archive . entries . forEach ( ( val ) => { console . log ( val . path ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $Console$ O $void$ O $any$ O $any$ O O O O O O O O
'js' var Rar = ( function ( exports ) { 's' ; function __awaiter ( thisArg , _arguments , P , generator ) { return new ( P || ( P = Promise ) ) ( function ( resolve , reject ) { function fulfilled ( value ) { try { step ( generator . next ( value ) ) ; } catch ( e ) { reject ( e ) ; } } function rejected ( value ) { try { step ( generator . throw ( value ) ) ; } catch ( e ) { reject ( e ) ; } } function step ( result ) { result . done ? resolve ( result . value ) : new P ( function ( resolve ) { resolve ( result . value ) ; } ) . then ( fulfilled , rejected ) ; } step ( ( generator = generator . apply ( thisArg , _arguments ) ) . next ( ) ) ; } ) ; } class Reader { constructor ( ) { this . size = 0 ; } readBlob ( length , position , blobType ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { if ( ! blobType ) { blobType = 's' ; } const data = this . read ( length , position ) ; return new Blob ( [ data ] , { type : blobType } ) ; } ) ; } } class UriReader extends Reader { constructor ( uri ) { super ( ) ; this . uri = uri ; } open ( ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return fetch ( this . uri , { method : 's' } ) . then ( ( response ) => { if ( ! response . ok ) { throw new Error ( 's' ) ; } const length = response . headers . get ( 's' ) ; if ( length !== null ) { this . size = parseInt ( length , 0 ) ; } } ) ; } ) ; } close ( ) { return Promise . resolve ( ) ; } reset ( ) { return ; } read ( length , position ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return fetch ( this . uri , { method : 's' , headers : { Range : `template` } } ) . then ( ( response ) => { if ( ! response . ok ) { throw new Error ( 's' ) ; } return response . arrayBuffer ( ) ; } ) ; } ) ; } } let fsImport ; if ( typeof require === 's' ) { fsImport = require ( 's' ) ; } class LocalReader extends Reader { constructor ( path ) { super ( ) ; this . path = path ; } open ( ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return new Promise ( ( resolve , reject ) => { fsImport . stat ( this . path , ( err , stat ) => { if ( err ) { reject ( new Error ( 's' ) ) ; return ; } this . size = stat . size ; resolve ( ) ; } ) ; } ) ; } ) ; } close ( ) { return Promise . resolve ( ) ; } reset ( ) { return ; } read ( length , position ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return new Promise ( ( resolve , reject ) => { fsImport . open ( this . path , 's' , ( err , fd ) => { if ( err ) { reject ( new Error ( 's' ) ) ; return ; } fsImport . read ( fd , new Buffer ( length ) , 0 , length , position , ( readErr , _bytesRead , buffer ) => { if ( readErr ) { reject ( new Error ( 's' ) ) ; return ; } const ab = new ArrayBuffer ( buffer . length ) ; const view = new 0 ( ab ) ; for ( let i = 0 ; i < buffer . length ; i ++ ) { view [ i ] = buffer [ i ] ; } fsImport . close ( fd , ( closeErr ) => { if ( closeErr ) { reject ( new Error ( 's' ) ) ; return ; } resolve ( ab ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } } class NativeFileReader extends Reader { constructor ( file ) { super ( ) ; this . file = file ; this . size = file . size ; } open ( ) { return Promise . resolve ( ) ; } close ( ) { return Promise . resolve ( ) ; } reset ( ) { return ; } read ( length , position ) { const slice = this . file . slice ( position , position + length ) ; const fr = new FileReader ( ) ; return new Promise ( ( resolve , reject ) => { fr . addEventListener ( 's' , ( ) => { resolve ( fr . result ) ; } ) ; fr . addEventListener ( 's' , ( ) => { reject ( new Error ( 's' ) ) ; } ) ; fr . readAsArrayBuffer ( slice ) ; } ) ; } } class RarEntry { constructor ( ) { this . name = null ; this . path = null ; this . size = 0 ; this . sizePacked = 0 ; this . crc = null ; this . offset = 0 ; this . blockSize = 0 ; this . headerSize = 0 ; this . encrypted = false ; this . version = null ; this . time = null ; this . method = null ; this . os = null ; this . partial = false ; this . continuesFrom = false ; this . continues = false ; } } ( function ( RarMethod ) { RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; RarMethod [ RarMethod [ "s" ] = 0 ] = "s" ; } ) ( exports . RarMethod || ( exports . RarMethod = { } ) ) ; function getString ( view , length , offset , raw ) { offset = offset || 0 ; length = length || ( view . byteLength - offset ) ; if ( length < 0 ) { length += view . byteLength ; } let str = 's' ; if ( typeof Buffer !== 's' ) { const data = [ ] ; for ( let i = offset ; i < ( offset + length ) ; i ++ ) { data . push ( view . 0 ( i ) ) ; } return ( new Buffer ( data ) ) . toString ( ) ; } else { for ( let i = offset ; i < ( offset + length ) ; i ++ ) { str += String . fromCharCode ( view . 0 ( i ) ) ; } if ( raw ) { return str ; } return decodeURIComponent ( window . escape ( str ) ) ; } } function fromFile ( file ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return fromReader ( new NativeFileReader ( file ) ) ; } ) ; } function fromUri ( uri ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return fromReader ( new UriReader ( uri ) ) ; } ) ; } function fromLocal ( path ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return fromReader ( new LocalReader ( path ) ) ; } ) ; } function fromReader ( reader ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { const result = new RarArchive ( reader ) ; yield result . load ( ) ; return result ; } ) ; } class RarArchive { constructor ( reader ) { this . entries = [ ] ; this . _loaded = false ; this . _reader = reader ; } get loaded ( ) { return this . _loaded ; } load ( ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { if ( this . loaded ) { return ; } yield this . _reader . open ( ) ; const header = yield this . _reader . read ( 0 , 0 ) ; const headerView = new DataView ( header ) ; if ( getString ( headerView , 0 , 0 , true ) !== 's' ) { throw new Error ( 's' ) ; } const headerType = headerView . 0 ( 0 ) ; const headerFlags = headerView . 0 ( 0 , true ) ; const headerSize = headerView . 0 ( 0 , true ) ; if ( headerType !== 0 ) { throw new Error ( 's' ) ; } if ( ( headerFlags & 0 ) !== 0 ) { throw new Error ( 's' ) ; } if ( this . _reader . size <= 0 ) { return ; } const maxSize = this . _reader . size ; let offset = headerSize + 0 ; while ( offset < maxSize ) { const piece = yield this . _reader . read ( 0 , offset ) ; const view = new DataView ( piece ) ; const type = view . 0 ( 0 ) ; const flags = view . 0 ( 0 , true ) ; let size = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { size += view . 0 ( 0 , true ) ; } switch ( type ) { case 0 : const entry = yield this . parseEntry ( size , offset ) ; this . entries . push ( entry ) ; offset += entry . blockSize ; break ; default : offset += size ; } } } ) ; } get ( entry ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { if ( entry . method !== exports . RarMethod . STORE ) { throw new Error ( 's' ) ; } const blob = yield this . _reader . readBlob ( entry . blockSize - 0 , entry . offset + entry . headerSize ) ; return blob ; } ) ; } parseEntryTime ( time ) { if ( time . length < 0 ) { time = ( new Array ( 0 - time . length + 0 ) ) . join ( 's' ) + time ; } const matches = time . match ( "s" ) ; if ( ! matches ) { return new Date ( ) ; } const vals = matches . slice ( 0 ) . map ( ( val ) => { return parseInt ( val , 0 ) ; } ) ; return new Date ( 0 + vals [ 0 ] , vals [ 0 ] - 0 , vals [ 0 ] , vals [ 0 ] , vals [ 0 ] , vals [ 0 ] ) ; } parseEntryOS ( value ) { if ( value < 0 || value > 0 ) { return 's' ; } return [ 's' , 's' , 's' , 's' , 's' , 's' ] [ value ] ; } parseEntry ( size , offset ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { const data = yield this . _reader . read ( size , offset ) ; const view = new DataView ( data ) ; const flags = view . 0 ( 0 , true ) ; const entry = new RarEntry ( ) ; entry . partial = ( ( flags & 0 ) !== 0 || ( flags & 0 ) !== 0 ) ; entry . continuesFrom = ( ( flags & 0 ) !== 0 ) ; entry . continues = ( ( flags & 0 ) !== 0 ) ; entry . offset = offset ; entry . sizePacked = view . 0 ( 0 , true ) ; entry . size = view . 0 ( 0 , true ) ; entry . crc = view . 0 ( 0 , true ) ; entry . time = this . parseEntryTime ( view . 0 ( 0 , true ) . toString ( 0 ) ) ; entry . os = this . parseEntryOS ( view . 0 ( 0 ) ) ; entry . version = view . 0 ( 0 ) ; entry . method = view . 0 ( 0 ) ; entry . encrypted = ( ( flags & 0 ) !== 0 ) ; const nameSize = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { entry . sizePacked += view . 0 ( 0 , true ) * 0 ; entry . size += view . 0 ( 0 , true ) * 0 ; entry . path = getString ( view , nameSize , 0 ) ; } else { entry . path = getString ( view , nameSize , 0 ) ; } if ( ( flags & 0 ) !== 0 && entry . path . indexOf ( 's' ) !== - 0 ) { entry . path = entry . path . split ( 's' ) [ 0 ] ; } entry . name = entry . path ; if ( entry . name . indexOf ( 's' ) !== - 0 ) { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } else { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } entry . headerSize = size ; entry . blockSize = entry . headerSize + entry . sizePacked ; return entry ; } ) ; } } exports . Reader = Reader ; exports . UriReader = UriReader ; exports . LocalReader = LocalReader ; exports . NativeFileReader = NativeFileReader ; exports . fromFile = fromFile ; exports . fromUri = fromUri ; exports . fromLocal = fromLocal ; exports . fromReader = fromReader ; exports . RarArchive = RarArchive ; return exports ; } ( { } ) ) ;	O O ${}$ O O O O ${}$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $PromiseConstructor$ O O O O O $any$ O $any$ O O O $void$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $void$ O $void$ O O O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O O O O O O O $Promise<Response>$ O O O $any$ O O $string$ O O O O O O O O $Response$ O O O O O O $Response$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O $string$ O $Response$ O $Headers$ O $string$ O O O O O O $string$ O O O O O O $number$ O $number$ O $string$ O O O O O O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $Promise<Response>$ O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $Response$ O O O O O O $Response$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O $Response$ O $Promise<ArrayBuffer>$ O O O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O $any$ O $void$ O O O O O O O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O $any$ O $any$ O O O O O O O O $ArrayBuffer$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $number$ O O $any$ O $number$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O $void$ O $ArrayBuffer$ O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O $void$ O O O O O O $Promise<any>$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $FileReader$ O O $complex$ O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $FileReader$ O $complex$ O O O O O O O $void$ O $FileReader$ O $complex$ O O O O O $FileReader$ O $complex$ O O O O O O O $void$ O O $ErrorConstructor$ O O O O O O O O $FileReader$ O $void$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $boolean$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O ${}$ O $any$ O O ${}$ O ${}$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O $any$ O O O O O $any[]$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any[]$ O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $string$ O $StringConstructor$ O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $string$ O O O $string$ O $complex$ O $string$ O $string$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $RarArchive$ O O $any$ O $any$ O O O $RarArchive$ O $any$ O O O O $RarArchive$ O O O O O O $any$ O O O $any$ O O O O $any[]$ O O O O O O $boolean$ O O O O O $any$ O $any$ O O O $boolean$ O O O O O O $boolean$ O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O O $any$ O $DataView$ O O O O O O O O O O O O O $ErrorConstructor$ O O O O O O $number$ O $DataView$ O $number$ O O O O O $number$ O $DataView$ O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $number$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $number$ O $number$ O O O O O $number$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O $number$ O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O $number$ O $DataView$ O $number$ O O O O O $number$ O $DataView$ O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O $any$ O O O O $any$ O $number$ O $number$ O O O O $any$ O $any$ O $any$ O O $number$ O $any$ O $any$ O O O O O $number$ O $number$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O ${}$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $Date$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $ArrayConstructor$ O O O $any$ O $any$ O O O O O $string$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $DateConstructor$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $number$ O $any$ O O O O O O O O O $DateConstructor$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $string$ O $any$ O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O $number$ O $DataView$ O $number$ O O O O O O O $RarEntry$ O O $any$ O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $number$ O $any$ O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O O O $any$ O $DataView$ O $number$ O O O O O O $string$ O O O O O $RarEntry$ O $any$ O O O $any$ O $DataView$ O $number$ O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $any$ O $any$ O $DataView$ O $number$ O O O O O O O $RarEntry$ O $any$ O $any$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $number$ O $any$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O $RarEntry$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O ${}$ O O O O O O O O
'js' ( function ( ) { "s" ; var Reader = function ( type ) { this . type = type || Reader . OPEN_URI ; this . size = null ; this . file = null } ; Reader . OPEN_FILE = 0 ; Reader . OPEN_URI = 0 ; Reader . OPEN_LOCAL = 0 ; if ( typeof require === "s" ) { var fs = require ( "s" ) } Reader . prototype . open = function ( file , callback ) { this . file = file ; var self = this ; switch ( this . type ) { case Reader . OPEN_LOCAL : fs . stat ( this . file , function ( err , stat ) { if ( err ) { return callback ( err ) } self . size = stat . size ; fs . open ( self . file , "s" , function ( err , fd ) { if ( err ) { return callback ( err ) } self . fd = fd ; callback ( ) } ) } ) ; break ; case Reader . OPEN_FILE : this . size = this . file . size ; callback ( ) ; break ; default : this . ajax ( { uri : this . file , type : "s" } , function ( err , resp , xhr ) { if ( err ) { return callback ( err ) } self . size = parseInt ( xhr . getResponseHeader ( "s" ) ) ; callback ( ) } ) ; break } } ; Reader . prototype . close = function ( ) { if ( this . type === Reader . OPEN_LOCAL ) { fs . close ( this . fd ) } } ; Reader . prototype . read = function ( length , position , callback ) { if ( this . type === Reader . OPEN_LOCAL ) { this . readLocal ( length , position , callback ) } else if ( this . type === Reader . OPEN_FILE ) { this . readFile ( length , position , callback ) } else { this . readUri ( length , position , callback ) } } ; Reader . prototype . readBlob = function ( length , position , type , callback ) { if ( typeof type === "s" ) { callback = type ; type = "s" } this . read ( length , position , function ( err , data ) { if ( err ) { callback ( err ) ; return } callback ( null , new Blob ( [ data ] , { type : type } ) ) } ) } ; Reader . prototype . readLocal = function ( length , position , callback ) { var buffer = new Buffer ( length ) ; fs . read ( this . fd , buffer , 0 , length , position , function ( err , bytesRead , buffer ) { if ( err ) { return callback ( err ) } var ab = new ArrayBuffer ( buffer . length ) , view = new 0 ( ab ) ; for ( var i = 0 ; i < buffer . length ; i ++ ) { view [ i ] = buffer [ i ] } callback ( null , ab ) } ) } ; Reader . prototype . ajax = function ( opts , callback ) { var options = { type : "s" , uri : null , responseType : "s" } ; if ( typeof opts === "s" ) { opts = { uri : opts } } for ( var k in opts ) { options [ k ] = opts [ k ] } var xhr = new XMLHttpRequest ; xhr . onreadystatechange = function ( ) { if ( xhr . readyState !== 0 ) return ; if ( xhr . status !== 0 && xhr . status !== 0 ) { return callback ( "s" + xhr . status + "s" ) } callback ( null , xhr . response , xhr ) } ; xhr . responseType = options . responseType ; xhr . open ( options . type , options . uri , true ) ; if ( options . range ) { options . range = [ ] . concat ( options . range ) ; if ( options . range . length === 0 ) { xhr . setRequestHeader ( "s" , "s" + options . range [ 0 ] + "s" + options . range [ 0 ] ) } else { xhr . setRequestHeader ( "s" , "s" + options . range [ 0 ] ) } } xhr . send ( ) } ; Reader . prototype . readUri = function ( length , position , callback ) { this . ajax ( { uri : this . file , type : "s" , responseType : "s" , range : [ position , position + length - 0 ] } , function ( err , buffer ) { if ( err ) { return callback ( err ) } return callback ( null , buffer ) } ) } ; Reader . prototype . readFile = function ( length , position , callback ) { var slice = this . file . slice ( position , position + length ) , fr = new FileReader ; fr . onload = function ( e ) { callback ( null , e . target . result ) } ; fr . onerror = function ( e ) { callback ( "s" ) } ; fr . readAsArrayBuffer ( slice ) } ; DataView . prototype . getString = function ( length , offset , raw ) { offset = offset || 0 ; length = length || this . byteLength - offset ; if ( length < 0 ) { length += this . byteLength } var str = "s" ; if ( typeof Buffer !== "s" ) { var data = [ ] ; for ( var i = offset ; i < offset + length ; i ++ ) { data . push ( this . 0 ( i ) ) } return new Buffer ( data ) . toString ( ) } else { for ( var i = offset ; i < offset + length ; i ++ ) { str += String . fromCharCode ( this . 0 ( i ) ) } if ( raw ) { return str } return decodeURIComponent ( escape ( str ) ) } } ; DataView . prototype . 0 = function ( length , offset , bom ) { offset = offset || 0 ; length = length || this . byteLength - offset ; var littleEndian = false , str = "s" , useBuffer = false ; if ( typeof Buffer !== "s" ) { str = [ ] ; useBuffer = true } if ( length < 0 ) { length += this . byteLength } if ( bom ) { var bomInt = this . 0 ( offset ) ; if ( bomInt === 0 ) { littleEndian = true } offset += 0 ; length -= 0 } for ( var i = offset ; i < offset + length ; i += 0 ) { var ch = this . 0 ( i , littleEndian ) ; if ( ch >= 0 && ch <= 0 || ch >= 0 && ch <= 0 ) { if ( useBuffer ) { str . push ( ch ) } else { str += String . fromCharCode ( ch ) } } else if ( ch >= 0 && ch <= 0 ) { ch -= 0 ; if ( useBuffer ) { str . push ( ( ( 0 & ch ) >> 0 ) + 0 ) ; str . push ( ( 0 & ch ) + 0 ) } else { str += String . fromCharCode ( ( ( 0 & ch ) >> 0 ) + 0 ) + String . fromCharCode ( ( 0 & ch ) + 0 ) } } } if ( useBuffer ) { return new Buffer ( str ) . toString ( ) } else { return decodeURIComponent ( escape ( str ) ) } } ; DataView . prototype . getSynch = function ( num ) { var out = 0 , mask = 0 ; while ( mask ) { out >>= 0 ; out |= num & mask ; mask >>= 0 } return out } ; DataView . prototype . 0 = function ( offset ) { return this . getSynch ( this . 0 ( offset ) ) } ; DataView . prototype . 0 = function ( offset ) { return this . getSynch ( this . 0 ( offset ) ) } ; DataView . prototype . 0 = function ( offset , littleEndian ) { if ( littleEndian ) { return this . 0 ( offset ) + ( this . 0 ( offset + 0 ) << 0 ) + ( this . 0 ( offset + 0 ) << 0 ) } return this . 0 ( offset + 0 ) + ( this . 0 ( offset + 0 ) << 0 ) + ( this . 0 ( offset ) << 0 ) } ; var RarEntry = function ( ) { this . name = null ; this . path = null ; this . size = 0 ; this . sizePacked = 0 ; this . crc = null ; this . offset = 0 ; this . blockSize = 0 ; this . headerSize = 0 ; this . encrypted = false ; this . version = null ; this . time = null ; this . method = null ; this . os = null ; this . partial = false ; this . continuesFrom = false ; this . continues = false } ; RarEntry . METHOD_STORE = 0 ; RarEntry . METHOD_FASTEST = 0 ; RarEntry . METHOD_FAST = 0 ; RarEntry . METHOD_NORMAL = 0 ; RarEntry . METHOD_GOOD = 0 ; RarEntry . METHOD_BEST = 0 ; var RarArchive = function ( ) { if ( ! ( this instanceof RarArchive ) ) { return new RarArchive ( arguments [ 0 ] , arguments [ 0 ] ) } this . options = { type : RarArchive . OPEN_URI } ; var opts = arguments [ 0 ] ; if ( typeof opts === "s" ) { opts = { file : opts , type : RarArchive . OPEN_URI } } else if ( typeof window !== "s" && window . File && opts instanceof window . File ) { opts = { file : opts , type : RarArchive . OPEN_FILE } } for ( var k in opts ) { this . options [ k ] = opts [ k ] } if ( ! this . options . file ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , "s" ) ; return } if ( this . options . type === RarArchive . OPEN_FILE ) { if ( typeof window === "s" || ! window . File || ! window . FileReader || typeof ArrayBuffer === "s" ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , "s" ) } } else if ( this . options . type === RarArchive . OPEN_LOCAL ) { if ( typeof require !== "s" ) { if ( arguments [ 0 ] ) arguments [ 0 ] . call ( this , "s" ) ; return } } else { } this . file = this . options . file ; this . rd = new Reader ( this . options . type ) ; this . entries = [ ] ; this . valid = false ; this . validate ( arguments [ 0 ] ) } ; RarArchive . prototype . validate = function ( callback ) { var self = this ; this . rd . open ( this . file , function ( err ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return } self . rd . read ( 0 , 0 , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return } var view = new DataView ( data ) ; if ( view . getString ( 0 , 0 , true ) !== "s" ) { if ( callback ) callback . call ( self , "s" ) ; return } var crc = view . 0 ( 0 , true ) , type = view . 0 ( 0 ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; if ( type !== 0 ) { if ( callback ) callback . call ( self , "s" ) ; return } if ( ( flags & 0 ) !== 0 ) { if ( callback ) callback . call ( self , "s" ) ; return } self . valid = true ; self . readHeaders ( size + 0 , callback ) } ) } ) } ; RarArchive . prototype . parseEntry = function ( offset , callback ) { var self = this ; this . rd . read ( 0 , offset , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return } var view = new DataView ( data ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; self . rd . read ( size , offset , function ( err , data ) { var view = new DataView ( data ) ; var entry = new RarEntry ; entry . partial = ( flags & 0 ) !== 0 || ( flags & 0 ) !== 0 ; entry . continuesFrom = ( flags & 0 ) !== 0 ; entry . continues = ( flags & 0 ) !== 0 ; entry . offset = offset ; entry . sizePacked = view . 0 ( 0 , true ) ; entry . size = view . 0 ( 0 , true ) ; entry . crc = view . 0 ( 0 , true ) ; entry . time = function ( ) { var time = view . 0 ( 0 , true ) . toString ( 0 ) ; if ( time . length < 0 ) { time = new Array ( 0 - time . length + 0 ) . join ( "s" ) + time } time = time . match ( "s" ) . slice ( 0 ) . map ( function ( val ) { return parseInt ( val , 0 ) } ) ; return new Date ( 0 + time [ 0 ] , time [ 0 ] - 0 , time [ 0 ] , time [ 0 ] , time [ 0 ] , time [ 0 ] ) } ( ) ; entry . os = function ( ) { var os = view . 0 ( 0 ) ; switch ( os ) { case 0 : return "s" ; case 0 : return "s" ; case 0 : return "s" ; case 0 : return "s" ; case 0 : return "s" ; case 0 : return "s" } } ( ) ; entry . version = view . 0 ( 0 ) ; entry . method = view . 0 ( 0 ) ; entry . encrypted = ( flags & 0 ) !== 0 ; var nameSize = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { entry . sizePacked += view . 0 ( 0 , true ) * 0 ; entry . size += view . 0 ( 0 , true ) * 0 ; entry . path = view . getString ( nameSize , 0 ) } else { entry . path = view . getString ( nameSize , 0 ) } if ( ( flags & 0 ) !== 0 && entry . path . indexOf ( "s" ) !== - 0 ) { entry . path = entry . path . split ( "s" ) [ 0 ] } entry . name = entry . path ; if ( entry . name . indexOf ( "s" ) !== - 0 ) { entry . name = entry . name . substr ( entry . name . lastIndexOf ( "s" ) + 0 ) } else { entry . name = entry . name . substr ( entry . name . lastIndexOf ( "s" ) + 0 ) } entry . headerSize = size ; entry . blockSize = entry . headerSize + entry . sizePacked ; if ( callback ) callback . call ( self , null , entry ) } ) } ) } ; RarArchive . prototype . readHeaders = function ( offset , callback ) { var self = this ; var cb = function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return } var view = new DataView ( data ) , crc = view . 0 ( 0 , true ) , type = view . 0 ( 0 ) , flags = view . 0 ( 0 , true ) , size = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { size += view . 0 ( 0 , true ) } switch ( type ) { case 0 : self . parseEntry ( offset , function ( err , entry ) { if ( err ) { if ( callback ) callback . call ( self , "s" ) ; return } self . entries . push ( entry ) ; offset += entry . blockSize ; if ( offset >= self . rd . size ) { if ( callback ) callback . call ( self , null ) ; return } self . rd . read ( 0 , offset , cb ) } ) ; break ; default : offset += size ; if ( offset >= self . rd . size ) { if ( callback ) callback . call ( self , null ) ; return } self . rd . read ( 0 , offset , cb ) ; break } } ; if ( this . rd . size <= 0 ) { if ( callback ) callback . call ( self , null , this . entries ) ; return } this . rd . read ( 0 , offset , cb ) } ; RarArchive . prototype . get = function ( entry , callback ) { if ( ! this . valid ) { if ( callback ) callback . call ( this , "s" ) ; return } if ( ! ( entry instanceof RarEntry ) ) { if ( callback ) callback . call ( this , "s" ) ; return } if ( entry . method !== RarEntry . METHOD_STORE ) { if ( callback ) callback . call ( this , "s" ) ; return } this . rd . readBlob ( entry . blockSize - 0 , entry . offset + entry . headerSize , function ( err , data ) { if ( err ) { if ( callback ) callback . call ( self , err ) ; return } if ( callback ) callback . call ( self , null , data ) } ) } ; RarArchive . OPEN_FILE = Reader . OPEN_FILE ; RarArchive . OPEN_URI = Reader . OPEN_URI ; RarArchive . OPEN_LOCAL = Reader . OPEN_LOCAL ; if ( typeof module !== "s" && module . exports ) { module . exports = RarArchive } else { if ( typeof define === "s" && define . amd ) { define ( "s" , [ ] , function ( ) { return RarArchive } ) } else { window . RarArchive = RarArchive } } } ) ( ) ;	O O O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O O O O $any$ O O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $Reader$ O O O O O O O $any$ O O O $any$ O $number$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O $Reader$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Reader$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O $Reader$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $number$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O $any$ O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O $Reader$ O $any$ O $number$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $void$ O O O O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $number$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O O O O $complex$ O O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O $any$ O $any$ O O O O O O O $ArrayBuffer$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $number$ O O $any$ O $number$ O O $any$ O O O $ArrayBuffer$ O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $complex$ O O $string$ O O O $null$ O O O $string$ O O O O O O O $any$ O O O O $any$ O O $string$ O $string$ O O O O O $string$ O $any$ O O $complex$ O $string$ O O $any$ O $string$ O O O $XMLHttpRequest$ O O $complex$ O $XMLHttpRequest$ O $any$ O O O O O O O $XMLHttpRequest$ O $number$ O O O O O O O $XMLHttpRequest$ O $number$ O O O $XMLHttpRequest$ O $number$ O O O O O $any$ O O O $XMLHttpRequest$ O $number$ O O O O $any$ O O O $XMLHttpRequest$ O $any$ O $XMLHttpRequest$ O O O $XMLHttpRequest$ O $XMLHttpRequestResponseType$ O $complex$ O $string$ O $XMLHttpRequest$ O $complex$ O $complex$ O $string$ O $complex$ O $any$ O O O O O O $complex$ O $any$ O O $complex$ O $any$ O O O O $complex$ O $complex$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $XMLHttpRequest$ O $void$ O O O O O $complex$ O $any$ O O O O O O $complex$ O $any$ O O O O O O O $XMLHttpRequest$ O $void$ O O O O O $complex$ O $any$ O O O O O O $XMLHttpRequest$ O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O O $void$ O O $any$ O O O $any$ O $string$ O O O $string$ O O O $any[]$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $FileReader$ O O $complex$ O $FileReader$ O $any$ O O O $ProgressEvent<FileReader>$ O O $any$ O O O $ProgressEvent<FileReader>$ O $FileReader$ O $complex$ O O O $FileReader$ O $any$ O O O $ProgressEvent<FileReader>$ O O $any$ O O O O O $FileReader$ O $void$ O $any$ O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O O O $any$ O O $string$ O O O O O O $any$ O O O O O $any[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O O O $any$ O $any[]$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $StringConstructor$ O $string$ O O O $any$ O $any$ O O O O O $any$ O O O $string$ O O $string$ O $string$ O $string$ O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $boolean$ O O O $string$ O O O $boolean$ O O O O O O $any$ O O O O $string$ O O O O $boolean$ O O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O O $boolean$ O O $string$ O $any$ O $any$ O O O O $string$ O $StringConstructor$ O $string$ O $any$ O O O O O O $any$ O O O $any$ O O O O $any$ O O O O O $boolean$ O O $string$ O $any$ O O O O O $any$ O O O O O O O O $string$ O $any$ O O O O $any$ O O O O O O O $string$ O $StringConstructor$ O $string$ O O O O O $any$ O O O O O O O O $StringConstructor$ O $string$ O O O O $any$ O O O O O O O O O $boolean$ O O O O $any$ O $string$ O O $any$ O O O O O O $string$ O $string$ O $string$ O O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O $number$ O O O $number$ O O O O O $number$ O O $number$ O O O $number$ O $any$ O $number$ O $number$ O O O O $number$ O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $DataViewConstructor$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O $boolean$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O $any$ O $IArguments$ O O O O $IArguments$ O O O O O O O $complex$ O O $number$ O $any$ O $number$ O O O $any$ O $IArguments$ O O O O O O O $any$ O O O O $any$ O O $string$ O $string$ O $number$ O $any$ O $number$ O O O O O O $complex$ O O O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O O $any$ O O $File$ O $File$ O $number$ O $any$ O $number$ O O O O O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O $string$ O O O O O O O $any$ O $any$ O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O $complex$ O O O O $complex$ O $complex$ O O $complex$ O $complex$ O O $ArrayBufferConstructor$ O O O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O $IArguments$ O O O O $IArguments$ O O O O $any$ O O O O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O $Reader$ O O $any$ O O O $any$ O $any$ O O O O $any[]$ O O O O O O $boolean$ O O O O O $any$ O $IArguments$ O O O O O O $any$ O $any$ O $void$ O O O $any$ O O O $RarArchive$ O O O O O $Reader$ O $void$ O O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O $RarArchive$ O $Reader$ O $void$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O O $DataView$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O O O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O $RarArchive$ O $boolean$ O O O $RarArchive$ O $void$ O $number$ O O O $any$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $RarArchive$ O O O O O $Reader$ O $void$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O $RarArchive$ O $Reader$ O $void$ O $number$ O $any$ O O O $any$ O $any$ O O O $DataView$ O O $DataViewConstructor$ O $any$ O O O $RarEntry$ O O $any$ O $RarEntry$ O $boolean$ O O $number$ O O O O O O O $number$ O O O O O O $RarEntry$ O $boolean$ O O $number$ O O O O O O $RarEntry$ O $boolean$ O O $number$ O O O O O O $RarEntry$ O $number$ O $any$ O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $any$ O O O O O O $string$ O $DataView$ O $number$ O O O O O O $string$ O O O O O O $string$ O $number$ O O O O $string$ O O $ArrayConstructor$ O O O $string$ O $number$ O O O O $string$ O O O O $string$ O $string$ O $string$ O $complex$ O O O O $string[]$ O O O O $U[]$ O O O $string$ O O O $number$ O $string$ O O O O O O O O $DateConstructor$ O O O $string$ O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O O $RarEntry$ O $any$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $any$ O $DataView$ O $number$ O O O O $RarEntry$ O $boolean$ O O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $any$ O $DataView$ O $any$ O $number$ O O O O O O $RarEntry$ O $any$ O $DataView$ O $any$ O $number$ O O O O O O O $number$ O O O O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O O O $RarEntry$ O $any$ O $any$ O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O O O $RarEntry$ O $any$ O $RarEntry$ O $any$ O $any$ O $RarEntry$ O $any$ O $any$ O O O O O O O $RarEntry$ O $number$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O O $any$ O $any$ O $any$ O $RarArchive$ O O O $RarEntry$ O O O O O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O $RarArchive$ O O O O $void$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O $any$ O O O O O $DataView$ O O $DataViewConstructor$ O $any$ O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O $number$ O $DataView$ O $number$ O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O $RarArchive$ O $void$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O $RarArchive$ O $any[]$ O $number$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $RarArchive$ O $Reader$ O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O $RarArchive$ O $Reader$ O $void$ O O O $any$ O $void$ O O O O O O O O $any$ O $number$ O O O $any$ O $RarArchive$ O $Reader$ O $any$ O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O O $RarArchive$ O $Reader$ O $void$ O O O $any$ O $void$ O O O O O O O O O O $Reader$ O $any$ O O O O O O $any$ O $any$ O $any$ O $RarArchive$ O O O O O $any[]$ O O O O O O $Reader$ O $void$ O O O $any$ O $void$ O O O $any$ O $any$ O $void$ O O O $any$ O $any$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $RarEntry$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $Reader$ O $void$ O $RarEntry$ O $number$ O O O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O O O O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O $any$ O $number$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O $complex$ O $any$ O $any$ O O O O O O O
'js' import typescript from 's' ; export default { input : 's' , output : { name : 's' , file : 's' , format : 's' } , plugins : [ typescript ( { module : 's' , typescript : require ( 's' ) } ) ] } ;	O O $any$ O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O $any[]$ O O $any$ O O $string$ O O O $any$ O $any$ O O O O O O O O
export enum RarMethod { STORE = 0 , FASTEST = 0 , FAST = 0 , NORMAL = 0 , GOOD = 0 , BEST = 0 }	O O $any$ O $RarMethod.STORE$ O O O $RarMethod.FASTEST$ O O O $RarMethod.FAST$ O O O $RarMethod.NORMAL$ O O O $RarMethod.GOOD$ O O O $RarMethod.BEST$ O O O
import { RarMethod } from 's' ; export class RarEntry { public name : string | null = null ; public path : string | null = null ; public size : number = 0 ; public sizePacked : number = 0 ; public crc : number | null = null ; public offset : number = 0 ; public blockSize : number = 0 ; public headerSize : number = 0 ; public encrypted : boolean = false ; public version : number | null = null ; public time : Date | null = null ; public method : RarMethod | null = null ; public os : string | null = null ; public partial : boolean = false ; public continuesFrom : boolean = false ; public continues : boolean = false ; }	O O $any$ O O O O O O $any$ O O $string$ O O O O O O O O $string$ O O O O O O O O $number$ O O O O O O $number$ O O O O O O $number$ O O O O O O O O $number$ O O O O O O $number$ O O O O O O $number$ O O O O O O $boolean$ O O O O O O $number$ O O O O O O O O $Date$ O $DateConstructor$ O O O O O O $RarMethod$ O $any$ O O O O O O $string$ O O O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O
export abstract class Reader { public size : number = 0 ; public abstract open ( ) < void > ; public abstract close ( ) < void > ; public abstract read ( length , position ) < ArrayBuffer > ; public abstract reset ( ) ; public async readBlob ( length , position , blobType ? ) < Blob > { if ( ! blobType ) { blobType = 's' ; } const data = await this . read ( length , position ) ; return new Blob ( [ data ] , { type : blobType } ) ; } }	O O O $any$ O O $number$ O O O O O O O $Promise$ O O O O O O O O $Promise$ O O O O O O O O $Promise$ O $number$ O $number$ O O $ArrayBufferConstructor$ O O O O $void$ O O O O O $Promise$ O $number$ O $number$ O $string$ $string$ O O $complex$ O O O O O $string$ O O $string$ O O O O O $ArrayBuffer$ O O O O $Promise<ArrayBuffer>$ O $number$ O $number$ O O O O $complex$ O O $ArrayBuffer$ O O O $string$ O $string$ O O O O O
import { Reader } from 's' ; export class UriReader extends Reader { public uri : string ; constructor ( uri ) { super ( ) ; this . uri = uri ; } public async open ( ) { return fetch ( this . uri , { method : 's' } ) . then ( ( response ) => { if ( ! response . ok ) { throw new Error ( 's' ) ; } const length = response . headers . get ( 's' ) ; if ( length !== null ) { this . size = parseInt ( length , 0 ) ; } } ) ; } public close ( ) { return Promise . resolve ( ) ; } public reset ( ) { return ; } public async read ( length , position ) { return fetch ( this . uri , { method : 's' , headers : { Range : `template` } } ) . then ( ( response ) => { if ( ! response . ok ) { throw new Error ( 's' ) ; } return response . arrayBuffer ( ) ; } ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O O O $string$ O $string$ O O O O $Promise<void>$ O O O O $Promise<Response>$ O O O $string$ O O $string$ O O O O O O O O $Response$ O O O O O O $Response$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O $string$ O $Response$ O $Headers$ O $string$ O O O O O O $string$ O O O O O O $number$ O $number$ O $string$ O O O O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $void$ O O O O O O O O $Promise<ArrayBuffer>$ O $number$ O $number$ O O O $Promise<Response>$ O O O $string$ O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $Response$ O O O O O O $Response$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O $Response$ O $Promise<ArrayBuffer>$ O O O O O O O O
import * as fs from 's' ; import { Reader } from 's' ; let fsImport : typeof fs ; if ( typeof require === 's' ) { fsImport = require ( 's' ) ; } export class LocalReader extends Reader { public path : string ; constructor ( path ) { super ( ) ; this . path = path ; } public async open ( ) { return new Promise < void > ( ( resolve , reject ) => { fsImport . stat ( this . path , ( err , stat ) => { if ( err ) { reject ( new Error ( 's' ) ) ; return ; } this . size = stat . size ; resolve ( ) ; } ) ; } ) ; } public close ( ) { return Promise . resolve ( ) ; } public reset ( ) { return ; } public async read ( length , position ) { return new Promise < ArrayBuffer > ( ( resolve , reject ) => { fsImport . open ( this . path , 's' , ( err , fd ) => { if ( err ) { reject ( new Error ( 's' ) ) ; return ; } fsImport . read ( fd , new Buffer ( length ) , 0 , length , position , ( readErr , _bytesRead , buffer ) => { if ( readErr ) { reject ( new Error ( 's' ) ) ; return ; } const ab = new ArrayBuffer ( buffer . length ) ; const view = new 0 ( ab ) ; for ( let i = 0 ; i < buffer . length ; i ++ ) { view [ i ] = buffer [ i ] ; } fsImport . close ( fd , ( closeErr ) => { if ( closeErr ) { reject ( new Error ( 's' ) ) ; return ; } resolve ( ab ) ; } ) ; } ) ; } ) ; } ) ; } }	O O O $any$ O O O O O $any$ O O O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O O O $string$ O $string$ O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O O $number$ O $any$ O $any$ O $void$ O O O O O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $void$ O O O O O O O O $Promise<ArrayBuffer>$ O $number$ O $number$ O O O O $PromiseConstructor$ O $ArrayBufferConstructor$ O O O $void$ O $void$ O O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O $number$ O $number$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O $any$ O $any$ O O O O O O O O $ArrayBuffer$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $number$ O O $any$ O $number$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $void$ O O $ErrorConstructor$ O O O O O O O O $void$ O $ArrayBuffer$ O O O O O O O O O O O O O O O O
import { Reader } from 's' ; export class NativeFileReader extends Reader { public file : File ; constructor ( file ) { super ( ) ; this . file = file ; this . size = file . size ; } public open ( ) { return Promise . resolve ( ) ; } public close ( ) { return Promise . resolve ( ) ; } public reset ( ) { return ; } public read ( length , position ) { const slice = this . file . slice ( position , position + length ) ; const fr = new FileReader ( ) ; return new Promise < ArrayBuffer > ( ( resolve , reject ) => { fr . addEventListener ( 's' , ( ) => { resolve ( fr . result as ArrayBuffer ) ; } ) ; fr . addEventListener ( 's' , ( ) => { reject ( new Error ( 's' ) ) ; } ) ; fr . readAsArrayBuffer ( slice ) ; } ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O $File$ O $complex$ O O O $File$ O O O O O O O O $File$ O $File$ O O O $number$ O $File$ O $number$ O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $void$ O O O O O O O $Promise<ArrayBuffer>$ O $number$ O $number$ O O O $Blob$ O O O $File$ O $Blob$ O $number$ O $number$ O $number$ O O O $FileReader$ O O $complex$ O O O O O $PromiseConstructor$ O $ArrayBufferConstructor$ O O O $void$ O $void$ O O O $FileReader$ O $complex$ O O O O O O O $void$ O $FileReader$ O $complex$ O $ArrayBufferConstructor$ O O O O O $FileReader$ O $complex$ O O O O O O O $void$ O O $ErrorConstructor$ O O O O O O O O $FileReader$ O $void$ O $Blob$ O O O O O O O
export function getString ( view , length ? , offset ? , raw ? ) { offset = offset || 0 ; length = length || ( view . byteLength - offset ) ; if ( length < 0 ) { length += view . byteLength ; } let str = 's' ; if ( typeof Buffer !== 's' ) { const data = [ ] ; for ( let i = offset ; i < ( offset + length ) ; i ++ ) { data . push ( view . 0 ( i ) ) ; } return ( new Buffer ( data ) ) . toString ( ) ; } else { for ( let i = offset ; i < ( offset + length ) ; i ++ ) { str += String . fromCharCode ( view . 0 ( i ) ) ; } if ( raw ) { return str ; } return decodeURIComponent ( ( window as any ) . escape ( str ) ) ; } }	O O $any$ O $DataView$ O $number$ $number$ O $number$ $number$ O $boolean$ $boolean$ O O $number$ O $number$ O O O $number$ O $number$ O O $DataView$ O $number$ O $number$ O O O O $number$ O O O O $number$ O $DataView$ O $number$ O O O $string$ O O O O O O $any$ O O O O O $any[]$ O O O O O O O $number$ O $number$ O $number$ O O $number$ O $number$ O O $number$ O O O $any[]$ O $number$ O $DataView$ O $number$ O $number$ O O O O O O O $any$ O $any[]$ O O O $any$ O O O O O O O O O $number$ O $number$ O $number$ O O $number$ O $number$ O O $number$ O O O $string$ O $StringConstructor$ O $string$ O $DataView$ O $number$ O $number$ O O O O O O $boolean$ O O O $string$ O O O $string$ O O $complex$ O O O O $any$ O $string$ O O O O O
import { Reader } from 's' ; import { UriReader } from 's' ; import { LocalReader } from 's' ; import { NativeFileReader } from 's' ; import { RarEntry } from 's' ; import { RarMethod } from 's' ; import * as util from 's' ; export { Reader , UriReader , LocalReader , NativeFileReader , RarMethod } ; export async function fromFile ( file ) { return fromReader ( new NativeFileReader ( file ) ) ; } export async function fromUri ( uri ) { return fromReader ( new UriReader ( uri ) ) ; } export async function fromLocal ( path ) { return fromReader ( new LocalReader ( path ) ) ; } export async function fromReader ( reader ) { const result = new RarArchive ( reader ) ; await result . load ( ) ; return result ; } export class RarArchive { public entries : RarEntry [ ] = [ ] ; private _reader : Reader ; private _loaded : boolean = false ; public get loaded ( ) : boolean { return this . _loaded ; } constructor ( reader ) { this . _reader = reader ; } public async load ( ) < void > { if ( this . loaded ) { return ; } await this . _reader . open ( ) ; const header = await this . _reader . read ( 0 , 0 ) ; const headerView = new DataView ( header ) ; if ( util . getString ( headerView , 0 , 0 , true ) !== 's' ) { throw new Error ( 's' ) ; } const headerType = headerView . 0 ( 0 ) ; const headerFlags = headerView . 0 ( 0 , true ) ; const headerSize = headerView . 0 ( 0 , true ) ; if ( headerType !== 0 ) { throw new Error ( 's' ) ; } if ( ( headerFlags & 0 ) !== 0 ) { throw new Error ( 's' ) ; } if ( this . _reader . size <= 0 ) { return ; } const maxSize = this . _reader . size ; let offset = headerSize + 0 ; while ( offset < maxSize ) { const piece = await this . _reader . read ( 0 , offset ) ; const view = new DataView ( piece ) ; const type = view . 0 ( 0 ) ; const flags = view . 0 ( 0 , true ) ; let size = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { size += view . 0 ( 0 , true ) ; } switch ( type ) { case 0 : const entry = await this . parseEntry ( size , offset ) ; this . entries . push ( entry ) ; offset += entry . blockSize ; break ; default : offset += size ; } } } public async get ( entry ) < Blob > { if ( entry . method !== RarMethod . STORE ) { throw new Error ( 's' ) ; } const blob = await this . _reader . readBlob ( entry . blockSize - 0 , entry . offset + entry . headerSize ) ; return blob ; } private parseEntryTime ( time ) { if ( time . length < 0 ) { time = ( new Array ( 0 - time . length + 0 ) ) . join ( 's' ) + time ; } const matches = time . match ( "s" ) ; if ( ! matches ) { return new Date ( ) ; } const vals = matches . slice ( 0 ) . map ( ( val ) => { return parseInt ( val , 0 ) ; } ) ; return new Date ( 0 + vals [ 0 ] , vals [ 0 ] - 0 , vals [ 0 ] , vals [ 0 ] , vals [ 0 ] , vals [ 0 ] ) ; } private parseEntryOS ( value ) { if ( value < 0 || value > 0 ) { return 's' ; } return [ 's' , 's' , 's' , 's' , 's' , 's' ] [ value ] ; } private async parseEntry ( size , offset ) < RarEntry > { const data = await this . _reader . read ( size , offset ) ; const view = new DataView ( data ) ; const flags = view . 0 ( 0 , true ) ; const entry = new RarEntry ( ) ; entry . partial = ( ( flags & 0 ) !== 0 || ( flags & 0 ) !== 0 ) ; entry . continuesFrom = ( ( flags & 0 ) !== 0 ) ; entry . continues = ( ( flags & 0 ) !== 0 ) ; entry . offset = offset ; entry . sizePacked = view . 0 ( 0 , true ) ; entry . size = view . 0 ( 0 , true ) ; entry . crc = view . 0 ( 0 , true ) ; entry . time = this . parseEntryTime ( view . 0 ( 0 , true ) . toString ( 0 ) ) ; entry . os = this . parseEntryOS ( view . 0 ( 0 ) ) ; entry . version = view . 0 ( 0 ) ; entry . method = view . 0 ( 0 ) ; entry . encrypted = ( ( flags & 0 ) !== 0 ) ; const nameSize = view . 0 ( 0 , true ) ; if ( ( flags & 0 ) !== 0 ) { entry . sizePacked += view . 0 ( 0 , true ) * 0 ; entry . size += view . 0 ( 0 , true ) * 0 ; entry . path = util . getString ( view , nameSize , 0 ) ; } else { entry . path = util . getString ( view , nameSize , 0 ) ; } if ( ( flags & 0 ) !== 0 && entry . path . indexOf ( 's' ) !== - 0 ) { entry . path = entry . path . split ( 's' ) [ 0 ] ; } entry . name = entry . path ; if ( entry . name . indexOf ( 's' ) !== - 0 ) { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } else { entry . name = entry . name . substr ( entry . name . lastIndexOf ( 's' ) + 0 ) ; } entry . headerSize = size ; entry . blockSize = entry . headerSize + entry . sizePacked ; return entry ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<RarArchive>$ O $File$ O O O $Promise<RarArchive>$ O O $any$ O $File$ O O O O O O O $Promise<RarArchive>$ O $string$ O O O $Promise<RarArchive>$ O O $any$ O $string$ O O O O O O O $Promise<RarArchive>$ O $string$ O O O $Promise<RarArchive>$ O O $any$ O $string$ O O O O O O O $Promise<RarArchive>$ O $Reader$ O O O $RarArchive$ O O $any$ O $Reader$ O O O $RarArchive$ O $Promise<void>$ O O O O $RarArchive$ O O O O $any$ O O $RarEntry[]$ O $any$ O O O O O O O $Reader$ O $any$ O O $boolean$ O O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $Reader$ O O O O $Reader$ O $Reader$ O O O O $Promise$ O O O O O O O O O O $boolean$ O O O O O O O O $Reader$ O $Promise<void>$ O O O O $ArrayBuffer$ O O O O $Reader$ O $Promise<ArrayBuffer>$ O O O O O O O $DataView$ O O $DataViewConstructor$ O $ArrayBuffer$ O O O O $any$ O $any$ O $DataView$ O O O O O O O O O O O O O $ErrorConstructor$ O O O O O O $number$ O $DataView$ O $number$ O O O O O $number$ O $DataView$ O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $number$ O O O O O O O O O $ErrorConstructor$ O O O O O O O O O $Reader$ O $number$ O O O O O O O O $number$ O O O $Reader$ O $number$ O O $number$ O $number$ O O O O O $number$ O $number$ O O O $ArrayBuffer$ O O O O $Reader$ O $Promise<ArrayBuffer>$ O O O $number$ O O O $DataView$ O O $DataViewConstructor$ O $ArrayBuffer$ O O O $number$ O $DataView$ O $number$ O O O O O $number$ O $DataView$ O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O $RarEntry$ O O O O $Promise<RarEntry>$ O $number$ O $number$ O O O O $RarEntry[]$ O $number$ O $RarEntry$ O O $number$ O $RarEntry$ O $number$ O O O O O $number$ O $number$ O O O O O O $Promise$ O $RarEntry$ O O $complex$ O O O O $RarEntry$ O $RarMethod$ O $any$ O $RarMethod.STORE$ O O O O $ErrorConstructor$ O O O O O O $Blob$ O O O O $Reader$ O $Promise<Blob>$ O $RarEntry$ O $number$ O O O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O O $Blob$ O O O $Date$ O $string$ O O O O $string$ O $number$ O O O O $string$ O O O $ArrayConstructor$ O O O $string$ O $number$ O O O O O $string$ O O O O $string$ O O O $RegExpMatchArray$ O $string$ O $complex$ O O O O O O O $RegExpMatchArray$ O O O O $DateConstructor$ O O O O O $number[]$ O $RegExpMatchArray$ O $string[]$ O O O O $U[]$ O O $string$ O O O O $number$ O $string$ O O O O O O O O O $DateConstructor$ O O O $number[]$ O O O O $number[]$ O O O O O O $number[]$ O O O O $number[]$ O O O O $number[]$ O O O O $number[]$ O O O O O O O $string$ O $number$ O O O O $number$ O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O $Promise$ O $number$ O $number$ O O $any$ O O O $ArrayBuffer$ O O O O $Reader$ O $Promise<ArrayBuffer>$ O $number$ O $number$ O O O $DataView$ O O $DataViewConstructor$ O $ArrayBuffer$ O O O $number$ O $DataView$ O $number$ O O O O O O O $RarEntry$ O O $any$ O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O $RarEntry$ O $number$ O $number$ O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O $RarEntry$ O $Date$ O O O $Date$ O $DataView$ O $number$ O O O O O O $string$ O O O O O $RarEntry$ O $string$ O O O $string$ O $DataView$ O $number$ O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O $RarEntry$ O $RarMethod$ O $DataView$ O $number$ O O O O $RarEntry$ O $boolean$ O O O $number$ O O O O O O O O $number$ O $DataView$ O $number$ O O O O O O O O O $number$ O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $number$ O $DataView$ O $number$ O O O O O O O O $RarEntry$ O $string$ O $any$ O $any$ O $DataView$ O $number$ O O O O O O O $RarEntry$ O $string$ O $any$ O $any$ O $DataView$ O $number$ O O O O O O O O $number$ O O O O O O $RarEntry$ O $string$ O $number$ O O O O O O O O $RarEntry$ O $string$ O $RarEntry$ O $string$ O $complex$ O O O O O O O O $RarEntry$ O $string$ O $RarEntry$ O $string$ O O O $RarEntry$ O $string$ O $number$ O O O O O O O O $RarEntry$ O $string$ O $RarEntry$ O $string$ O $string$ O $RarEntry$ O $string$ O $number$ O O O O O O O O O O $RarEntry$ O $string$ O $RarEntry$ O $string$ O $string$ O $RarEntry$ O $string$ O $number$ O O O O O O O O $RarEntry$ O $number$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O $RarEntry$ O $number$ O O $RarEntry$ O O O
import { assert } from 's' ; import { LocalReader } from 's' ; import * as path from 's' ; const testFile = path . join ( __dirname , 's' ) ; const fakeFile = path . join ( __dirname , 's' ) ; const abToString = ( buf ) => { return String . fromCharCode . apply ( null , new 0 ( buf ) as unknown as number [ ] ) ; } ; suite ( 's' , ( ) => { let reader ; setup ( ( ) => { reader = new LocalReader ( testFile ) ; } ) ; test ( 's' , async ( ) => { await reader . open ( ) ; assert . equal ( reader . size , 0 ) ; } ) ; test ( 's' , async ( ) => { reader = new LocalReader ( fakeFile ) ; try { await reader . open ( ) ; throw new Error ( 's' ) ; } catch ( e ) { assert . equal ( e . message , 's' ) ; } } ) ; test ( 's' , async ( ) => { await reader . open ( ) ; let result = abToString ( await reader . read ( 0 , 0 ) ) ; assert . equal ( result , 's' ) ; result = abToString ( await reader . read ( 0 , 0 ) ) ; assert . equal ( result , 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ArrayBuffer$ O O O O $StringConstructor$ O $string$ O $any$ O O O O O O $ArrayBuffer$ O O O O O O O O O O O $any$ O O O O O O O O $LocalReader$ O $any$ O O O O O $LocalReader$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $LocalReader$ O $Promise<void>$ O O O $any$ O $any$ O $LocalReader$ O $number$ O O O O O O O $any$ O O O O O O O O $LocalReader$ O O $any$ O $any$ O O O O O $LocalReader$ O $Promise<void>$ O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $LocalReader$ O $Promise<void>$ O O O O $any$ O $any$ O O $LocalReader$ O $Promise<ArrayBuffer>$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $LocalReader$ O $Promise<ArrayBuffer>$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O
import { assert } from 's' ; import { UriReader } from 's' ; import * as sinon from 's' ; const abToString = ( buf ) => { return String . fromCharCode . apply ( null , new 0 ( buf ) as unknown as number [ ] ) ; } ; class MockHeaders { private _headers : { [ k ] : string } ; constructor ( obj : { [ k ] : string } ) { this . _headers = obj ; } public get ( k ) { return this . _headers [ k ] ; } } class MockResponse { public status : number ; public body : string ; public headers : MockHeaders ; public get ok ( ) { return this . status < 0 ; } constructor ( status , body , headers : { [ k ] : string } ) { this . status = status ; this . headers = new MockHeaders ( headers ) ; this . body = body ; } public arrayBuffer ( ) { const buffer = new ArrayBuffer ( this . body . length ) ; const view = new 0 ( buffer ) ; for ( let i = 0 , len = this . body . length ; i < len ; i ++ ) { view [ i ] = this . body . charCodeAt ( i ) ; } return buffer ; } } suite ( 's' , ( ) => { let reader ; let fetch : sinon . SinonStub ; setup ( ( ) => { fetch = ( global as any ) . fetch = sinon . stub ( ) ; reader = new UriReader ( 's' ) ; } ) ; test ( 's' , async ( ) => { fetch . resolves ( new MockResponse ( 0 , 's' , { 's' : 's' } ) ) ; await reader . open ( ) ; assert . equal ( reader . size , 0 ) ; } ) ; test ( 's' , async ( ) => { fetch . resolves ( new MockResponse ( 0 , 's' , { 's' : 's' } ) ) ; try { await reader . open ( ) ; throw new Error ( 's' ) ; } catch ( e ) { assert . equal ( e . message , 's' ) ; } } ) ; test ( 's' , async ( ) => { fetch . resolves ( new MockResponse ( 0 , 's' , { 's' : 's' } ) ) ; await reader . open ( ) ; assert . isTrue ( fetch . calledWithExactly ( 's' , { method : 's' } ) ) ; fetch . resolves ( new MockResponse ( 0 , 's' , { 's' : 's' , 's' : 's' , 's' : 's' } ) ) ; let result = abToString ( await reader . read ( 0 , 0 ) ) ; assert . isTrue ( fetch . calledWithExactly ( 's' , { method : 's' , headers : { Range : 's' } } ) ) ; assert . equal ( result , 's' ) ; fetch . resolves ( new MockResponse ( 0 , 's' , { 's' : 's' , 's' : 's' , 's' : 's' } ) ) ; result = abToString ( await reader . read ( 0 , 0 ) ) ; assert . isTrue ( fetch . calledWithExactly ( 's' , { method : 's' , headers : { Range : 's' } } ) ) ; assert . equal ( result , 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O $ArrayBuffer$ O O O O $StringConstructor$ O $string$ O $any$ O O O O O O $ArrayBuffer$ O O O O O O O O O O O O $any$ O O $complex$ O O O $string$ O O O O O O O $complex$ O O O $string$ O O O O O O O O $complex$ O $complex$ O O O $string$ O $string$ O O O O O $complex$ O $string$ O O O O O $any$ O O $number$ O O O O $string$ O O O O $MockHeaders$ O $any$ O O O $boolean$ O O O O O O $number$ O O O O O O $number$ O $string$ O $complex$ O O O $string$ O O O O O O O O $number$ O $number$ O O O $MockHeaders$ O O $any$ O $complex$ O O O O $string$ O $string$ O O O $ArrayBuffer$ O O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O O O $string$ O $number$ O O O O O O O O $ArrayBuffer$ O O O O O $number$ O O O $number$ O O O $string$ O $number$ O $number$ O $number$ O $number$ O O O O O $number$ O O O O $string$ O $number$ O $number$ O O O O $ArrayBuffer$ O O O $any$ O O O O O O O O $UriReader$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O $UriReader$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O $UriReader$ O $Promise<void>$ O O O $any$ O $any$ O $UriReader$ O $number$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O $UriReader$ O $Promise<void>$ O O O O O $ErrorConstructor$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O $UriReader$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $UriReader$ O $Promise<ArrayBuffer>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O $UriReader$ O $Promise<ArrayBuffer>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O
import { assert } from 's' ; import * as util from 's' ; suite ( 's' , ( ) => { suite ( 's' , ( ) => { let view ; setup ( ( ) => { const buffer = new ArrayBuffer ( 0 ) ; const data = new 0 ( buffer ) ; data [ 0 ] = 0 ; data [ 0 ] = 0 ; data [ 0 ] = 0 ; view = new DataView ( buffer ) ; } ) ; test ( 's' , ( ) => { const result = util . getString ( view ) ; assert . equal ( result , 's' ) ; } ) ; test ( 's' , ( ) => { const result = util . getString ( view , 0 ) ; assert . equal ( result , 's' ) ; } ) ; test ( 's' , ( ) => { const result = util . getString ( view , undefined , 0 ) ; assert . equal ( result , 's' ) ; } ) ; test ( 's' , ( ) => { const result = util . getString ( view , 0 , 0 ) ; assert . equal ( result , 's' ) ; } ) ; test ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $DataView$ O $any$ O O O O O O $ArrayBuffer$ O O $ArrayBufferConstructor$ O O O O O O O O O O $ArrayBuffer$ O O O O O O O O O O O O O O O O O O O O O O O $DataView$ O O $DataViewConstructor$ O $ArrayBuffer$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $DataView$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $DataView$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $DataView$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $DataView$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O