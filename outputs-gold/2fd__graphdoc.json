import Bluebird from "s" ; import fs from "s" ; import fse from "s" ; import path from "s" ; const MODULE_BASE_PATH = "s" ; export function resolve ( relative ) { if ( relative . slice ( 0 , MODULE_BASE_PATH . length ) === MODULE_BASE_PATH ) { return path . resolve ( __dirname , "s" , relative . slice ( MODULE_BASE_PATH . length ) ) ; } return path . resolve ( relative ) ; } export const readFile = Bluebird . promisify < string , string , string > ( fs . readFile ) ; export const writeFile = Bluebird . promisify < undefined , string , any > ( ( file , data , cb : ( err , result ? ) => void ) => fs . writeFile ( file , data , cb ) ) ; export const copyAll = Bluebird . promisify < undefined , string , string > ( ( from , to , cb : ( err , result ? ) => void ) => fse . copy ( from , to , cb ) ) ; export const readDir = Bluebird . promisify < string [ ] , string > ( fs . readdir ) ; export const mkDir = Bluebird . promisify < string , string > ( fs . mkdir as any ) ; export const removeBuildDirectory = Bluebird . promisify < void , string > ( fse . remove as any ) ; export async function createBuildDirectory ( buildDirectory , templateDirectory , assets : string [ ] ) { const files = await readDir ( templateDirectory ) ; await Bluebird . all ( files . filter ( file => path . extname ( file ) !== "s" ) . map ( file => copyAll ( path . resolve ( templateDirectory , file ) , path . resolve ( buildDirectory , file ) ) ) ) ; await mkDir ( path . resolve ( buildDirectory , "s" ) ) ; await Bluebird . all ( assets . map ( asset => copyAll ( asset , path . resolve ( buildDirectory , "s" , path . basename ( asset ) ) ) ) ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O $Error$ O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O $Error$ O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Bluebird from "s" ; import Handlebars from "s" ; import request from "s" ; import { readFile , writeFile } from "s" ; import { execSync } from "s" ; Handlebars . registerHelper ( "s" , ( command ) => { return execSync ( command ) . toString ( "s" ) ; } ) ; async function fromGithub ( endpoint ) { return Bluebird . promisify ( request ) ( { method : "s" , url : "s" + endpoint , json : true , headers : { "s" : "s" } } ) . then ( ( response : request . RequestResponse & { body : any } ) => response . body ) ; } Promise . all ( [ readFile ( "s" , "s" ) , fromGithub ( "s" ) , fromGithub ( "s" ) . then ( ( contributors < { login : string } > ) => contributors . filter ( c => c . login !== "s" ) ) ] ) . then ( ( [ template , project , contributors ] ) => { return writeFile ( "s" , Handlebars . compile ( template ) ( { project , contributors } ) ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DeepTypeRef , Description , TypeRef } from "s" ; export const LIST = "s" ; export const NON_NULL = "s" ; export const SCALAR = "s" ; export const OBJECT = "s" ; export const INTERFACE = "s" ; export const UNION = "s" ; export const ENUM = "s" ; export const INPUT_OBJECT = "s" ; export function getTypeOf ( t : DeepTypeRef | TypeRef ) { if ( t . kind === LIST || t . kind === NON_NULL ) { return getTypeOf ( ( t as DeepTypeRef ) . ofType ) ; } return t as TypeRef ; } export function getFilenameOf ( type : DeepTypeRef | TypeRef | Description ) { const name = type . kind === LIST || type . kind === NON_NULL ? getTypeOf ( type as DeepTypeRef ) . name . toLowerCase ( ) : ( type as Description ) . name . toLowerCase ( ) ; if ( name [ 0 ] === "s" && name [ 0 ] === "s" ) { return name . slice ( 0 ) + "s" ; } return name + "s" ; } const fullTypeFragment = `template` ; const inputValueFragment = `template` ; const typeRefFragment = `template` ; export const query = `template` ; export const queryRoot = `template` ; export const queryTypes = `template` ; export const queryDirectives = `template` ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TypeRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DeepTypeRef , Description , InputValue , TypeRef } from "s" ; import { LIST , NON_NULL } from "s" ; export class HTML { index = 0 ; code ( code ) { return `template` ; } highlight ( text ) { return `template` ; } sup ( text ) { return `template` ; } line ( code ? ) { const row = this . index ++ ; return `template` ; } tab ( code ) { return `template` ; } keyword ( keyword ) { return `template` ; } comment ( comment ) { return `template` ; } identifier ( type ) { return `template` ; } parameter ( arg ) { return `template` ; } property ( name ) { return `template` ; } useIdentifier ( type : DeepTypeRef | TypeRef | Description , toUrl ) { switch ( type . kind ) { case LIST : return ( "s" + this . useIdentifier ( ( type as DeepTypeRef ) . ofType , toUrl ) + "s" ) ; case NON_NULL : return this . useIdentifier ( ( type as DeepTypeRef ) . ofType , toUrl ) + "s" ; default : return `template` ; } } useIdentifierLength ( type : DeepTypeRef | TypeRef | Description , base = 0 ) { switch ( type . kind ) { case LIST : return this . useIdentifierLength ( ( type as DeepTypeRef ) . ofType , base + 0 ) ; case NON_NULL : return this . useIdentifierLength ( ( type as DeepTypeRef ) . ofType , base + 0 ) ; default : return base + ( type . name || "s" ) . length ; } } value ( val ) { return val [ 0 ] === 's' ? `template` : `template` ; } } export function split ( text , len ) : string [ ] { return text . split ( "s" ) . reduce ( ( result : string [ ] , word ) => { const last = result . length - 0 ; const lineLen = result [ last ] . length ; if ( lineLen === 0 ) { result [ last ] = word ; } else if ( lineLen < len ) { result [ last ] = result [ last ] + "s" + word ; } else { result . push ( word ) ; } return result ; } , [ "s" ] ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O $Description$ O O O O O O $string$ O $InputValue$ O O O O O O $string$ O $string$ O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import url from "s" ; import { DeepTypeRef , Description , Directive , DocumentSectionInterface , NavigationItemInterface , NavigationSectionInterface , PluginInterface , Schema , SchemaType , TypeRef } from "s" ; import { getFilenameOf } from "s" ; export abstract class Plugin { static collect < T > ( collection : T [ ] [ ] ) : T [ ] { let result : T [ ] = [ ] ; collection . forEach ( item => { if ( Array . isArray ( item ) ) { result = result . concat ( item ) ; } } ) ; return result ; } static async collectNavigations ( plugins : PluginInterface [ ] , buildForType ? ) < NavigationSectionInterface [ ] > { const navigationCollection = await Promise . all < NavigationSectionInterface [ ] > ( plugins . map ( plugin => { return plugin . getNavigations ? plugin . getNavigations ( buildForType ) : ( null as any ) ; } ) ) ; return Plugin . collect ( navigationCollection ) ; } static async collectDocuments ( plugins : PluginInterface [ ] , buildForType ? ) < DocumentSectionInterface [ ] > { const navigationCollection = await Promise . all < DocumentSectionInterface [ ] > ( plugins . map ( plugin => { return plugin . getDocuments ? plugin . getDocuments ( buildForType ) : ( null as any ) ; } ) ) ; return Plugin . collect ( navigationCollection ) ; } static async collectHeaders ( plugins : PluginInterface [ ] , buildForType ? ) < string [ ] > { const headerCollection = await Promise . all < string [ ] > ( plugins . map ( plugin => { return plugin . getHeaders ? plugin . getHeaders ( buildForType ) : ( null as any ) ; } ) ) ; return Plugin . collect ( headerCollection ) ; } static async collectAssets ( plugins : PluginInterface [ ] ) < string [ ] > { const assetCollection = await Promise . all < string [ ] > ( plugins . map ( plugin => { return plugin . getAssets ? plugin . getAssets ( ) : ( null as any ) ; } ) ) ; return Plugin . collect ( assetCollection ) ; } queryType : SchemaType | null = null ; mutationType : SchemaType | null = null ; subscriptionType : SchemaType | null = null ; typeMap : { [ name ] : SchemaType } = { } ; directiveMap : { [ name ] : Directive } = { } ; constructor ( public document , public projectPackage , public graphdocPackage ) { this . document . types = this . document . types ? this . document . types . sort ( sortTypes ) : [ ] ; this . document . directives = this . document . directives ? this . document . directives . sort ( ( a , b ) => ( a . name || "s" ) . localeCompare ( b . name || "s" ) ) : [ ] ; this . document . types . forEach ( type => { this . typeMap [ type . name || "s" ] = type ; } ) ; this . document . directives . forEach ( directive => { this . directiveMap [ directive . name || "s" ] = directive ; } ) ; if ( document . queryType ) { this . queryType = this . typeMap [ document . queryType . name || "s" ] ; } if ( document . mutationType ) { this . mutationType = this . typeMap [ document . mutationType . name || "s" ] ; } if ( document . subscriptionType ) { this . subscriptionType = this . typeMap [ document . subscriptionType . name || "s" ] ; } } url ( type : DeepTypeRef | TypeRef | Description ) { return url . resolve ( this . projectPackage . graphdoc . baseUrl , getFilenameOf ( type ) ) ; } } export class NavigationSection implements NavigationSectionInterface { constructor ( public title , public items : NavigationItem [ ] = [ ] ) { } } export class NavigationItem implements NavigationItemInterface { constructor ( public text , public href , public isActive ) { } } export class DocumentSection implements DocumentSectionInterface { constructor ( public title , public description ) { } } function priorityType ( type ) { const name = type . name || "s" ; if ( name [ 0 ] === "s" && name [ 0 ] === "s" ) { return 0 ; } else if ( name [ 0 ] === "s" ) { return 0 ; } else { return 0 ; } } export function sortTypes ( a , b ) { const priorityA = priorityType ( a ) ; const priorityB = priorityType ( b ) ; if ( priorityA === priorityB ) { return ( a . name || "s" ) . localeCompare ( b . name || "s" ) ; } else { return priorityA - priorityB ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O $Schema$ O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $boolean$ O O O O O O O O O O O O O $string$ O O $string$ O O O O O $number$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $SchemaType$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { OutputInterface } from "s" ; export interface IOutputOptions { verbose : boolean ; } export class Output { constructor ( public out , public options ) { } ok ( ref , value ) { this . out . log ( "s" , "s" , ref , "s" , value ) ; } info ( ref , value ) { if ( this . options . verbose ) { this . out . log ( "s" , "s" , ref , "s" , value ) ; } } error ( err : NodeJS . ErrnoException ) { this . out . error ( "s" , "s" , err . message || err ) ; if ( this . options . verbose ) { this . out . error ( "s" , "s" , err . stack || "s" ) ; } this . out . error ( "s" ) ; process . exit ( 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O $OutputInterface$ O O $IOutputOptions$ O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import marked from "s" ; import slug from "s" ; import { DocumentSectionInterface , NavigationSectionInterface , PluginInterface , TypeRef } from "s" ; import { Plugin } from "s" ; export function slugTemplate ( ) { return ( text , render ) => slug ( render ( text ) ) . toLowerCase ( ) ; } export interface ITemplateData { title : string ; type ? : TypeRef ; description : string ; headers : string ; navigations : NavigationSectionInterface [ ] ; documents : DocumentSectionInterface [ ] ; projectPackage : any ; graphdocPackage : any ; slug : typeof slugTemplate ; } type Headers = string [ ] ; type Navs = NavigationSectionInterface [ ] ; type Docs = DocumentSectionInterface [ ] ; export async function createData ( projectPackage , graphdocPackage , plugins : PluginInterface [ ] , type ? ) < ITemplateData > { const name = ( type && type . name ) || "s" ; const [ headers , navigations , documents ] : [ Headers , Navs , Docs ] = await Promise . all ( [ Plugin . collectHeaders ( plugins , name ) , Plugin . collectNavigations ( plugins , name ) , Plugin . collectDocuments ( plugins , name ) ] ) ; const title = name || projectPackage . graphdoc . title || "s" ; const description = type ? marked ( type . description || "s" ) : projectPackage . description ; return { title , type , description , headers : headers . join ( "s" ) , navigations , documents , projectPackage , graphdocPackage , slug : slugTemplate } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O $any$ O O O O O O O O $TypeRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { HTML , split } from "s" ; export { NavigationItem , NavigationSection , DocumentSection , Plugin , sortTypes } from "s" ; export { query , getTypeOf , getFilenameOf , ENUM , INPUT_OBJECT , INTERFACE , LIST , NON_NULL , OBJECT , SCALAR , UNION } from "s" ; export { Output } from "s" ; export { createData } from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Bluebird from "s" ; import request from "s" ; import { ApolloIntrospection , GraphQLIntrospection , Introspection , Schema , SchemaLoader } from "s" ; import { query as introspectionQuery } from "s" ; export interface IHttpSchemaLoaderOptions { endpoint : string ; headers : string [ ] ; queries : string [ ] ; } async function r ( options : request . OptionsWithUrl ) { return new Bluebird < Schema > ( ( resolve , reject ) => { request ( options , ( error , res , body : Introspection | string ) => { if ( error ) { return reject ( error ) ; } if ( ( res . statusCode as number ) >= 0 ) { return reject ( new Error ( "s" + res . statusCode + "s" + res . statusMessage + "s" + options . url ) ) ; } if ( typeof body === "s" ) { return reject ( new Error ( 's' + options . url + 's' + body . slice ( 0 , 0 ) + "s" ) ) ; } return resolve ( ( body as ApolloIntrospection ) . __schema || ( body as GraphQLIntrospection ) . data . __schema ) ; } ) ; } ) ; } export const httpSchemaLoader = async ( options ) => { const requestOptions : request . OptionsWithUrl = { url : options . endpoint , method : "s" , body : { query : introspectionQuery } , json : true } ; requestOptions . headers = options . headers . reduce ( ( result , header ) => { const [ name , value ] = header . split ( "s" , 0 ) ; result [ name ] = value ; return result ; } , { } ) ; requestOptions . qs = options . queries . reduce ( ( result , query ) => { const [ name , value ] = query . split ( "s" , 0 ) ; result [ name ] = value ; return result ; } , { } ) ; return r ( requestOptions ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaLoader$ O O O $IHttpSchemaLoaderOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { buildSchema , execute , parse } from "s" ; import { resolve } from "s" ; import { ApolloIntrospection , GraphQLIntrospection , Introspection , SchemaLoader } from "s" ; import { query as introspectionQuery } from "s" ; import { readFile } from "s" ; export interface IIdlSchemaLoaderOptions { schemaFile : string ; } export const idlSchemaLoader = async ( options ) => { const schemaPath = resolve ( options . schemaFile ) ; const idl = await readFile ( schemaPath , "s" ) ; const introspection = ( await execute ( buildSchema ( idl ) , parse ( introspectionQuery ) ) ) as Introspection ; return ( ( introspection as ApolloIntrospection ) . __schema || ( introspection as GraphQLIntrospection ) . data . __schema ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaLoader$ O O O $IIdlSchemaLoaderOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { buildSchema , execute , parse } from "s" ; import { resolve } from "s" ; import { ApolloIntrospection , GraphQLIntrospection , Introspection , SchemaLoader } from "s" ; import { query as introspectionQuery } from "s" ; export interface IJsSchemaLoaderOptions { schemaFile : string ; } export const jsSchemaLoader = async ( options ) => { const schemaPath = resolve ( options . schemaFile ) ; let schemaModule = require ( schemaPath ) ; let schema ; if ( typeof schemaModule === "s" ) { schemaModule = schemaModule . default ; } if ( Array . isArray ( schemaModule ) ) { schema = schemaModule . join ( "s" ) ; } else if ( typeof schemaModule === "s" ) { schema = schemaModule ( ) . join ( "s" ) ; } else { throw new Error ( `template` ) ; } const introspection = ( await execute ( buildSchema ( schema ) , parse ( introspectionQuery ) ) ) as Introspection ; return ( ( introspection as ApolloIntrospection ) . __schema || ( introspection as GraphQLIntrospection ) . data . __schema ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaLoader$ O O O $IJsSchemaLoaderOptions$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { resolve } from "s" ; import { ApolloIntrospection , GraphQLIntrospection , Introspection , Schema , SchemaLoader } from "s" ; export interface IJsonSchemaLoaderOptions { schemaFile : string ; } export const jsonSchemaLoader = ( options ) => { try { const schemaPath = resolve ( options . schemaFile ) ; const introspection = require ( schemaPath ) ; const schema = ( introspection as ApolloIntrospection ) . __schema || ( introspection as GraphQLIntrospection ) . data . __schema ; return Promise . resolve ( schema ) ; } catch ( err ) { return Promise . reject ( err ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaLoader$ O O $IJsonSchemaLoaderOptions$ O O O O O O O O O O O O O O O O $Introspection$ O O O O O O O $Schema$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { IHttpSchemaLoaderOptions , httpSchemaLoader } from "s" ; export { IIdlSchemaLoaderOptions , idlSchemaLoader } from "s" ; export { IJsSchemaLoaderOptions as TJsSchemaLoaderOptions , jsSchemaLoader } from "s" ; export { IJsonSchemaLoaderOptions as TJsonSchemaLoaderOptions , jsonSchemaLoader } from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BooleanFlag , Command , InputInterface , ListValueFlag , NoParams , OutputInterface , ValueFlag } from "s" ; import Bluebird from "s" ; import fs from "s" ; import glob from "s" ; import { render } from "s" ; import path from "s" ; import { PluginInterface , Schema , TypeRef } from "s" ; import { httpSchemaLoader , idlSchemaLoader , jsonSchemaLoader , jsSchemaLoader } from "s" ; import { createData , getFilenameOf , Output , Plugin } from "s" ; import { createBuildDirectory , readFile , removeBuildDirectory , resolve , writeFile } from "s" ; const graphdocPackageJSON = require ( path . resolve ( __dirname , "s" ) ) ; export interface IFlags { configFile : string ; endpoint : string ; headers : string [ ] ; queries : string [ ] ; schemaFile : string ; plugins : string [ ] ; template : string ; data : any ; output : string ; force : boolean ; verbose : boolean ; version : boolean ; } export interface IPartials { [ name ] : string | undefined ; index ? : string ; } export interface IProjectPackage { graphdoc : IFlags ; } export type Input = InputInterface < IFlags , { } > ; export class GraphQLDocumentGenerator extends Command < IFlags , { } > { public description = graphdocPackageJSON . description + "s" + graphdocPackageJSON . version ; public params = new NoParams ( ) ; public flags = [ new ValueFlag ( "s" , [ "s" , "s" ] , "s" , String , "s" ) , new ValueFlag ( "s" , [ "s" , "s" ] , 's' ) , new ListValueFlag ( "s" , [ "s" , "s" ] , 's' ) , new ListValueFlag ( "s" , [ "s" , "s" ] , 's' ) , new ValueFlag ( "s" , [ "s" , "s" , "s" ] , 's' ) , new ListValueFlag ( "s" , [ "s" , "s" ] , "s" ) , new ValueFlag ( "s" , [ "s" , "s" ] , "s" ) , new ValueFlag ( "s" , [ "s" , "s" ] , "s" ) , new ValueFlag ( "s" , [ "s" , "s" ] , "s" , JSON . parse , { } ) , new ValueFlag ( "s" , [ "s" , "s" ] , "s" ) , new BooleanFlag ( "s" , [ "s" , "s" ] , "s" ) , new BooleanFlag ( "s" , [ "s" , "s" ] , "s" ) , new BooleanFlag ( "s" , [ "s" , "s" ] , "s" ) ] ; public async action ( input , out ) { const output = new Output ( out , input . flags ) ; try { if ( input . flags . version ) { return output . out . log ( "s" , graphdocPackageJSON . version ) ; } const projectPackageJSON = await this . getProjectPackage ( input ) ; const schema = await this . getSchema ( projectPackageJSON ) ; const plugins : PluginInterface [ ] = this . getPluginInstances ( projectPackageJSON . graphdoc . plugins , schema , projectPackageJSON , graphdocPackageJSON ) ; projectPackageJSON . graphdoc . plugins . forEach ( plugin => output . info ( "s" , plugin ) ) ; const assets : string [ ] = await Plugin . collectAssets ( plugins ) ; assets . forEach ( asset => output . info ( "s" , path . relative ( process . cwd ( ) , asset ) ) ) ; output . info ( "s" , path . relative ( process . cwd ( ) , projectPackageJSON . graphdoc . output ) ) ; await this . ensureOutputDirectory ( projectPackageJSON . graphdoc . output , projectPackageJSON . graphdoc . force ) ; await createBuildDirectory ( projectPackageJSON . graphdoc . output , projectPackageJSON . graphdoc . template , assets ) ; const partials = await this . getTemplatePartials ( projectPackageJSON . graphdoc . template ) ; output . info ( "s" , "s" ) ; await this . renderFile ( projectPackageJSON , partials , plugins ) ; const renderTypes = ( [ ] as any [ ] ) . concat ( schema . types || [ ] ) . concat ( schema . directives || [ ] ) . map ( ( type ) => { output . info ( "s" , type . name || "s" ) ; return this . renderFile ( projectPackageJSON , partials , plugins , type ) ; } ) ; const files = await Promise . all ( renderTypes ) ; output . ok ( "s" , String ( files . length + 0 ) + "s" ) ; } catch ( err ) { output . error ( err ) ; } } public async ensureOutputDirectory ( dir , force ) { try { const stats = fs . statSync ( dir ) ; if ( ! stats . isDirectory ( ) ) { return Promise . reject ( new Error ( "s" + dir + "s" ) ) ; } if ( ! force ) { return Promise . reject ( new Error ( dir + "s" ) ) ; } return removeBuildDirectory ( dir ) ; } catch ( err ) { return err . code === "s" ? Promise . resolve ( ) : Promise . reject ( err ) ; } } public getProjectPackage ( input ) { let packageJSON : any & { graphdoc : any } ; try { packageJSON = require ( path . resolve ( input . flags . configFile ) ) ; } catch ( err ) { packageJSON = { } ; } packageJSON . graphdoc = { ... ( packageJSON . graphdoc || { } ) , ... input . flags } ; if ( packageJSON . graphdoc . data ) { const data = packageJSON . graphdoc . data ; packageJSON . graphdoc = { ... data , ... packageJSON . graphdoc } ; } if ( packageJSON . graphdoc . plugins . length === 0 ) { packageJSON . graphdoc . plugins = [ "s" ] ; } packageJSON . graphdoc . baseUrl = packageJSON . graphdoc . baseUrl || "s" ; packageJSON . graphdoc . template = resolve ( packageJSON . graphdoc . template || "s" ) ; packageJSON . graphdoc . output = path . resolve ( packageJSON . graphdoc . output ) ; packageJSON . graphdoc . version = graphdocPackageJSON . version ; if ( ! packageJSON . graphdoc . output ) { return Promise . reject ( new Error ( "s" ) ) ; } return Promise . resolve ( packageJSON ) ; } public getPluginInstances ( paths : string [ ] , schema , projectPackageJSON , pluginGraphdocPackageJSON ) : PluginInterface [ ] { return paths . map ( p => { const absolutePaths = resolve ( p ) ; const plugin = require ( absolutePaths ) . default ; return typeof plugin === "s" ? new plugin ( schema , projectPackageJSON , pluginGraphdocPackageJSON ) : plugin ; } ) ; } public async getTemplatePartials ( templateDir ) < IPartials > { const partials = { } ; const files : string [ ] = await Bluebird . promisify ( ( pattern , options : glob . IOptions , cb : ( err , matches : string [ ] ) => void ) => glob ( pattern , options , cb ) ) ( "s" , { cwd : templateDir } ) ; await Promise . all ( files . map ( file => { const name = path . basename ( file , "s" ) ; return readFile ( path . resolve ( templateDir , file ) , "s" ) . then ( content => ( partials [ name ] = content ) ) ; } ) ) ; if ( ! partials . index ) { throw new Error ( `template` ) ; } return partials ; } public async getSchema ( projectPackage ) < Schema > { if ( projectPackage . graphdoc . schemaFile ) { const schemaFileExt = path . extname ( projectPackage . graphdoc . schemaFile ) ; switch ( schemaFileExt ) { case "s" : return jsonSchemaLoader ( projectPackage . graphdoc ) ; case "s" : case "s" : case "s" : case "s" : return idlSchemaLoader ( projectPackage . graphdoc ) ; case "s" : return jsSchemaLoader ( projectPackage . graphdoc ) ; default : return Promise . reject ( new Error ( "s" + schemaFileExt ) ) ; } } else if ( projectPackage . graphdoc . endpoint ) { return httpSchemaLoader ( projectPackage . graphdoc ) ; } else { return Promise . reject ( new Error ( "s" ) ) ; } } public async renderFile ( projectPackageJSON , partials , plugins : PluginInterface [ ] , type ? ) { const templateData = await createData ( projectPackageJSON , graphdocPackageJSON , plugins , type ) ; const file = type ? getFilenameOf ( type ) : "s" ; const filePath = path . resolve ( projectPackageJSON . graphdoc . output , file ) ; return writeFile ( filePath , render ( partials . index as string , templateData , partials ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Input$ O $OutputInterface$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IProjectPackage$ O O O O O O O O O O $Schema$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPartials$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TypeRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Input$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Schema$ O $object$ O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O $IPartials$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $IProjectPackage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IProjectPackage$ O $IPartials$ O O O O O O O O $TypeRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' "s" ; const { ArgvInput , ColorConsoleOutput , ConsoleOutput } = require ( "s" ) ; const { GraphQLDocumentGenerator } = require ( "s" ) ; const argv = process . argv . filter ( arg => arg !== "s" ) ; new GraphQLDocumentGenerator ( ) . handle ( new ArgvInput ( argv ) , argv . length === process . argv . length ? new ColorConsoleOutput ( ) : new ConsoleOutput ( ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { NavigationItem , NavigationSection , Plugin } from "s" ; export default class NavigationDirectives extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . directives . map ( directive => new NavigationItem ( directive . name , this . url ( directive ) , directive . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import NavigationDirectives from "s" ; import schema from "s" ; import projectPackage from "s" ; describe ( "s" , ( ) => { const plugin = new NavigationDirectives ( schema . data . __schema , projectPackage , { } ) ; test ( "s" , ( ) => { const nav = plugin . getNavigations ( "s" ) ; expect ( nav ) . toBeInstanceOf ( Array ) ; expect ( nav ) . toEqual ( [ { title : "s" , items : [ { text : "s" , href : "s" , isActive : false } , { text : "s" , href : "s" , isActive : false } , { text : "s" , href : "s" , isActive : false } ] } ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { ENUM , NavigationItem , NavigationSection , Plugin } from "s" ; export default class NavigationEnums extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . types . filter ( type => type . kind === ENUM ) . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import NavigationEnums from "s" ; import schema from "s" ; import projectPackage from "s" ; describe ( "s" , ( ) => { const plugin = new NavigationEnums ( schema . data . __schema , projectPackage , { } ) ; test ( "s" , ( ) => { const navigations = plugin . getNavigations ( "s" ) ; expect ( navigations ) . toBeInstanceOf ( Array ) ; expect ( navigations ) . toEqual ( [ { title : "s" , items : [ { text : "s" , href : "s" , isActive : false } , { text : "s" , href : "s" , isActive : false } ] } ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { INPUT_OBJECT , NavigationItem , NavigationSection , Plugin } from "s" ; export default class NavigationInputs extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . types . filter ( type => type . kind === INPUT_OBJECT ) . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import NavigationInputs from "s" ; import schema from "s" ; import projectPackage from "s" ; describe ( "s" , ( ) => { const plugin = new NavigationInputs ( schema . data . __schema , projectPackage , { } ) ; test ( "s" , ( ) => { const nav = plugin . getNavigations ( "s" ) ; expect ( nav ) . toBeInstanceOf ( Array ) ; expect ( nav ) . toEqual ( [ { title : "s" , items : [ { text : "s" , href : "s" , isActive : false } ] } ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { INTERFACE , NavigationItem , NavigationSection , Plugin } from "s" ; export default class NavigationInterfaces extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . types . filter ( type => type . kind === INTERFACE ) . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import NavigationInterfaces from "s" ; import schema from "s" ; import projectPackage from "s" ; describe ( "s" , ( ) => { const plugin = new NavigationInterfaces ( schema . data . __schema , projectPackage , { } ) ; test ( "s" , ( ) => { const nav = plugin . getNavigations ( "s" ) ; expect ( nav ) . toBeInstanceOf ( Array ) ; expect ( nav ) . toEqual ( [ ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { resolve } from "s" ; import striptags from "s" ; import { DocumentSectionInterface , PluginInterface , Schema , SchemaType } from "s" ; import { ENUM , getTypeOf , INPUT_OBJECT , INTERFACE , OBJECT , Plugin , SCALAR , UNION } from "s" ; export default class RequireByPlugin extends Plugin implements PluginInterface { requireBy : Map < string , SchemaType [ ] > ; constructor ( public document , public projectPackage , public graphdocPackage ) { super ( document , projectPackage , graphdocPackage ) ; this . requireBy = new Map ( ) ; if ( Array . isArray ( document . types ) ) { document . types . forEach ( ( type ) => { switch ( type . kind ) { case SCALAR : case ENUM : return ; case OBJECT : case INTERFACE : case UNION : case INPUT_OBJECT : this . getDependencies ( type ) . forEach ( ( curr ) => { const deps = this . requireBy . get ( curr ) || [ ] ; deps . push ( type ) ; this . requireBy . set ( curr , deps ) ; } ) ; break ; } } ) ; } } getAssets ( ) { return [ resolve ( __dirname , "s" ) ] ; } getDependencies ( type ) : string [ ] { const deps : string [ ] = [ ] ; if ( Array . isArray ( type . interfaces ) && type . interfaces . length > 0 ) { type . interfaces . forEach ( i => deps . push ( i . name ) ) ; } if ( Array . isArray ( type . fields ) && type . fields . length > 0 ) { type . fields . forEach ( field => { deps . push ( getTypeOf ( field . type ) . name ) ; if ( Array . isArray ( field . args ) && field . args . length > 0 ) { field . args . forEach ( arg => { deps . push ( getTypeOf ( arg . type ) . name ) ; } ) ; } } ) ; } if ( Array . isArray ( type . inputFields ) && type . inputFields . length > 0 ) { type . inputFields . forEach ( field => { deps . push ( getTypeOf ( field . type ) . name ) ; } ) ; } if ( type . kind !== INTERFACE && Array . isArray ( type . possibleTypes ) && type . possibleTypes . length > 0 ) { type . possibleTypes . forEach ( t => { deps . push ( getTypeOf ( t ) . name ) ; } ) ; } return deps ; } getDescription ( type ) { return ( "s" + 's' + this . url ( type ) + 's' + type . name + "s" + striptags ( type . description || "s" ) . replace ( "s" , "s" ) + 's' + type . name + "s" + type . description + "s" + "s" + "s" ) ; } getDocuments ( buildForType ? ) : DocumentSectionInterface [ ] { if ( ! buildForType ) { return [ ] ; } const requireBy = this . requireBy . get ( buildForType ) ; if ( ! Array . isArray ( requireBy ) || requireBy . length === 0 ) { return [ { title : "s" , description : 's' + "s" + "s" } ] ; } const used = new Set ( ) ; return [ { title : "s" , description : 's' + requireBy . filter ( t => { return used . has ( t . name ) ? false : used . add ( t . name ) ; } ) . map ( t => this . getDescription ( t ) ) . join ( "s" ) + "s" } ] ; } getHeaders ( ) : string [ ] { return [ 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Schema$ O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { resolve } from "s" ; import wrap from "s" ; import { Directive , DocumentSectionInterface , EnumValue , Field , InputValue , PluginInterface , Schema , SchemaType } from "s" ; import { DocumentSection , ENUM , HTML , INPUT_OBJECT , INTERFACE , OBJECT , Plugin , SCALAR , UNION } from "s" ; const MAX_CODE_LEN = 0 ; export default class SchemaPlugin extends Plugin implements PluginInterface { private html : HTML ; getHeaders ( ) : string [ ] { return [ 's' , 's' , 's' ] ; } getAssets ( ) { return [ resolve ( __dirname , "s" ) , resolve ( __dirname , "s" ) ] ; } getDocuments ( buildForType ? ) : DocumentSectionInterface [ ] { this . html = new HTML ( ) ; const code = this . code ( buildForType ) ; if ( code ) { return [ new DocumentSection ( "s" , this . html . code ( code ) ) ] ; } return [ ] ; } code ( buildForType ? ) { if ( ! buildForType ) { return this . schema ( this . document ) ; } const directive = this . document . directives . find ( eachDirective => eachDirective . name === ( buildForType as string ) ) ; if ( directive ) { return this . directive ( directive ) ; } const type = this . document . types . find ( eachType => eachType . name === ( buildForType as string ) ) ; if ( type ) { switch ( type . kind ) { case SCALAR : return this . scalar ( type ) ; case OBJECT : return this . object ( type ) ; case INTERFACE : return this . interfaces ( type ) ; case UNION : return this . union ( type ) ; case ENUM : return this . enum ( type ) ; case INPUT_OBJECT : return this . inputObject ( type ) ; } } throw new TypeError ( "s" + buildForType ) ; } argument ( arg ) { return ( this . html . property ( arg . name ) + "s" + this . html . useIdentifier ( arg . type , this . url ( arg . type ) ) ) ; } argumentLength ( arg ) { return arg . name . length + 0 + this . html . useIdentifierLength ( arg . type ) ; } arguments ( fieldOrDirectives : Field | Directive ) { if ( fieldOrDirectives . args . length === 0 ) { return "s" ; } return ( "s" + fieldOrDirectives . args . map ( arg => this . argument ( arg ) ) . join ( "s" ) + "s" ) ; } argumentsLength ( fieldOrDirectives : Field | Directive ) { if ( fieldOrDirectives . args . length === 0 ) { return 0 ; } return fieldOrDirectives . args . reduce ( ( sum , arg ) => sum + this . argumentLength ( arg ) , 0 ) ; } argumentsMultiline ( fieldOrDirectives : Field | Directive ) : string [ ] { if ( fieldOrDirectives . args . length === 0 ) { return [ ] ; } const maxIndex = fieldOrDirectives . args . length - 0 ; return fieldOrDirectives . args . map ( ( arg , index ) => { return index < maxIndex ? this . argument ( arg ) + "s" : this . argument ( arg ) ; } ) ; } argumentDescription ( arg ) : string [ ] { const desc = arg . description === null ? "s" + this . html . highlight ( "s" ) + "s" : arg . description ; return this . description ( this . html . highlight ( arg . name ) + "s" + desc ) ; } argumentsDescription ( fieldOrDirectives : Field | Directive ) : string [ ] { if ( fieldOrDirectives . args . length === 0 ) { return [ ] ; } const reduceArguments = ( descriptions : string [ ] , arg ) => descriptions . concat ( this . argumentDescription ( arg ) ) ; return fieldOrDirectives . args . reduce ( reduceArguments , [ this . html . comment ( "s" ) ] ) ; } deprecated ( fieldOrEnumVal : Field | EnumValue ) { if ( ! fieldOrEnumVal . isDeprecated ) { return "s" ; } if ( ! fieldOrEnumVal . deprecationReason ) { return this . html . keyword ( "s" ) ; } return ( this . html . keyword ( "s" ) + "s" + this . html . value ( 's' + fieldOrEnumVal . deprecationReason + 's' ) + "s" ) ; } deprecatedLength ( fieldOrEnumVal : Field | EnumValue ) { if ( ! fieldOrEnumVal . isDeprecated ) { return 0 ; } if ( ! fieldOrEnumVal . deprecationReason ) { return "s" . length ; } return ( 's' . length + fieldOrEnumVal . deprecationReason . length + 's' . length ) ; } description ( description : string | null ) : string [ ] { if ( description ) { return wrap ( description , { width : MAX_CODE_LEN } ) . split ( "s" ) . map ( l => this . html . comment ( l ) ) ; } return [ ] ; } directive ( directive ) { return this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . keyword ( "s" + directive . name ) + this . arguments ( directive ) + "s" + directive . locations . map ( location => this . html . keyword ( location ) ) . join ( "s" ) ) ; } enum ( type ) { const reduceEnumValues = ( lines : string [ ] , enumValue ) => lines . concat ( [ "s" ] , this . description ( enumValue . description ) , [ this . html . property ( enumValue . name ) + this . deprecated ( enumValue ) ] ) ; return ( this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) + "s" ) + ( type . enumValues || [ ] ) . reduce ( reduceEnumValues , [ ] ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) + this . html . line ( "s" ) ) ; } field ( field ) { const fieldDescription = this . description ( field . description ) ; const argumentsDescription = this . argumentsDescription ( field ) ; if ( fieldDescription . length > 0 && argumentsDescription . length ) { fieldDescription . push ( this . html . comment ( "s" ) ) ; } const fieldDefinition = field . args . length > 0 && this . fieldLength ( field ) > MAX_CODE_LEN ? [ this . html . property ( field . name ) + "s" , ... this . argumentsMultiline ( field ) . map ( l => this . html . tab ( l ) ) , "s" + this . html . useIdentifier ( field . type , this . url ( field . type ) ) + "s" + this . deprecated ( field ) ] : [ this . html . property ( field . name ) + this . arguments ( field ) + "s" + this . html . useIdentifier ( field . type , this . url ( field . type ) ) + "s" + this . deprecated ( field ) ] ; return ( [ ] as string [ ] ) . concat ( fieldDescription ) . concat ( argumentsDescription ) . concat ( fieldDefinition ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) ; } fieldLength ( field ) { return ( field . name . length + this . argumentsLength ( field ) + "s" . length + this . html . useIdentifierLength ( field ) + "s" . length + this . deprecatedLength ( field ) ) ; } fields ( type ) { let fields = "s" ; fields += this . html . line ( ) ; fields += ( type . fields || [ ] ) . map ( field => this . field ( field ) ) . join ( this . html . line ( ) ) ; if ( type . fields && type . fields . length > 0 ) { fields += this . html . line ( ) ; } return fields ; } inputObject ( type ) { return ( this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) + "s" ) + this . inputValues ( type . inputFields || [ ] ) + this . html . line ( "s" ) ) ; } inputValues ( inputValues : InputValue [ ] ) { return inputValues . map ( inputValue => this . html . line ( this . html . tab ( this . inputValue ( inputValue ) ) ) ) . join ( "s" ) ; } inputValue ( arg ) { const argDescription = this . description ( arg . description ) ; return ( [ ] as string [ ] ) . concat ( argDescription ) . concat ( [ this . html . property ( arg . name ) + "s" + this . html . useIdentifier ( arg . type , this . url ( arg . type ) ) ] ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) ; } interfaces ( type ) { return ( this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) + "s" ) + this . fields ( type ) + this . html . line ( "s" ) ) ; } object ( type ) { const interfaces = ( type . interfaces || [ ] ) . map ( i => this . html . useIdentifier ( i , this . url ( i ) ) ) . join ( "s" ) ; const implement = interfaces . length === 0 ? "s" : "s" + this . html . keyword ( "s" ) + "s" + interfaces ; return ( this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) + implement + "s" ) + this . fields ( type ) + this . html . line ( "s" ) ) ; } scalar ( type ) { return this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) ) ; } schema ( schema ) { let definition = this . html . line ( this . html . keyword ( "s" ) + "s" ) ; if ( schema . queryType ) { definition += this . html . line ( ) + this . description ( schema . queryType . description ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) + this . html . line ( this . html . tab ( this . html . property ( "s" ) + "s" + this . html . useIdentifier ( schema . queryType , this . url ( schema . queryType ) ) ) ) ; } if ( schema . mutationType ) { definition += this . html . line ( ) + this . description ( schema . mutationType . description ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) + this . html . line ( this . html . tab ( this . html . property ( "s" ) + "s" + this . html . useIdentifier ( schema . mutationType , this . url ( schema . mutationType ) ) ) ) ; } if ( schema . subscriptionType ) { definition += this . html . line ( ) + this . description ( schema . subscriptionType . description ) . map ( line => this . html . line ( this . html . tab ( line ) ) ) . join ( "s" ) + this . html . line ( this . html . tab ( this . html . property ( "s" ) + "s" + this . html . useIdentifier ( schema . subscriptionType , this . url ( schema . subscriptionType ) ) ) ) ; } definition += this . html . line ( "s" ) ; return definition ; } union ( type ) { return this . html . line ( this . html . keyword ( "s" ) + "s" + this . html . identifier ( type ) + "s" + ( type . possibleTypes || [ ] ) . map ( eachType => this . html . useIdentifier ( eachType , this . url ( eachType ) ) ) . join ( "s" ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $InputValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $InputValue$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InputValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InputValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O $EnumValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $Field$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $InputValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $SchemaType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { NavigationItem , NavigationSection , OBJECT , Plugin } from "s" ; export default class NavigationObjects extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { const obj = this . document . types . filter ( type => { return ( type . kind === OBJECT && ( ! this . queryType || this . queryType . name !== type . name ) && ( ! this . mutationType || this . mutationType . name !== type . name ) && ( ! this . subscriptionType || this . subscriptionType . name !== type . name ) ) ; } ) ; return obj . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { NavigationItem , NavigationSection , Plugin , SCALAR } from "s" ; export default class NavigationScalars extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . types . filter ( type => type . kind === SCALAR ) . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationSectionInterface , PluginInterface } from "s" ; import { NavigationItem , NavigationSection , Plugin } from "s" ; export default class NavigationSchema extends Plugin implements PluginInterface { getNavigations ( buildFrom ? ) : NavigationSectionInterface [ ] { const section = new NavigationSection ( "s" , [ ] ) ; if ( this . document . queryType ) { section . items . push ( new NavigationItem ( this . document . queryType . name , this . url ( this . document . queryType ) , buildFrom === this . document . queryType . name ) ) ; } if ( this . document . mutationType ) { section . items . push ( new NavigationItem ( this . document . mutationType . name , this . url ( this . document . mutationType ) , buildFrom === this . document . mutationType . name ) ) ; } if ( this . document . subscriptionType ) { section . items . push ( new NavigationItem ( this . document . subscriptionType . name , this . url ( this . document . subscriptionType ) , buildFrom === this . document . subscriptionType . name ) ) ; } return [ section ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NavigationItemInterface , PluginInterface } from "s" ; import { NavigationItem , NavigationSection , Plugin , UNION } from "s" ; export default class NavigationScalars extends Plugin implements PluginInterface { getTypes ( buildForType ) : NavigationItemInterface [ ] { return this . document . types . filter ( type => type . kind === UNION ) . map ( type => new NavigationItem ( type . name , this . url ( type ) , type . name === buildForType ) ) ; } getNavigations ( buildForType ) { const types : NavigationItemInterface [ ] = this . getTypes ( buildForType ) ; if ( types . length === 0 ) { return [ ] ; } return [ new NavigationSection ( "s" , types ) ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DocumentSectionInterface , NavigationSectionInterface , PluginInterface , Schema } from "s" ; import { Plugin } from "s" ; import RequireByPlugin from "s" ; import DocumentSchema from "s" ; import NavigationDirective from "s" ; import NavigationEnum from "s" ; import NavigationInput from "s" ; import NavigationInterfaces from "s" ; import NavigationObject from "s" ; import NavigationScalar from "s" ; import NavigationSchema from "s" ; import NavigationUnion from "s" ; export default class NavigationDirectives extends Plugin implements PluginInterface { plugins : PluginInterface [ ] ; constructor ( document , graphdocPackage , projectPackage ) { super ( document , graphdocPackage , projectPackage ) ; this . plugins = [ new NavigationSchema ( document , graphdocPackage , projectPackage ) , new NavigationScalar ( document , graphdocPackage , projectPackage ) , new NavigationEnum ( document , graphdocPackage , projectPackage ) , new NavigationInterfaces ( document , graphdocPackage , projectPackage ) , new NavigationUnion ( document , graphdocPackage , projectPackage ) , new NavigationObject ( document , graphdocPackage , projectPackage ) , new NavigationInput ( document , graphdocPackage , projectPackage ) , new NavigationDirective ( document , graphdocPackage , projectPackage ) , new DocumentSchema ( document , graphdocPackage , projectPackage ) , new RequireByPlugin ( document , graphdocPackage , projectPackage ) ] ; } getNavigations ( buildForType ? ) < NavigationSectionInterface [ ] > { return Plugin . collectNavigations ( this . plugins , buildForType ) ; } getDocuments ( buildForType ? ) < DocumentSectionInterface [ ] > { return Plugin . collectDocuments ( this . plugins , buildForType ) ; } getHeaders ( buildForType ? ) < string [ ] > { return Plugin . collectHeaders ( this . plugins , buildForType ) ; } getAssets ( ) < string [ ] > { return Plugin . collectAssets ( this . plugins ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Schema$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O
'js' ( function ( ) { ready ( function ( ) { var tables = window . document . getElementsByClassName ( 's' ) ; for ( var i = 0 ; i < tables . length ; i ++ ) { var table = tables [ i ] ; table . addEventListener ( 's' , onClick ) ; } window . addEventListener ( "s" , onHashChange , false ) ; onHashChange ( ) ; } ) ; function onHashChange ( ) { var id = window . location . href . split ( 's' ) [ 0 ] ; if ( ! id ) { return ; } var lcid = id . indexOf ( 's' ) === - 0 ? id . replace ( 's' , 's' ) : id ; var lineCode = window . document . getElementById ( lcid ) ; if ( ! lineCode ) { return ; } var highlighted = lineCode . closest ( 's' ) . getElementsByClassName ( 's' ) ; for ( var i = 0 ; i < highlighted . length ; i ++ ) { highlighted [ i ] . classList . remove ( 's' ) ; } lineCode . classList . add ( 's' ) ; } function onClick ( e ) { var target = e . target ; if ( ! target . classList . contains ( 's' ) ) { return ; } var href = window . location . href . split ( 's' ) [ 0 ] ; window . location . href = href + 's' + target . id ; } function ready ( fn ) { if ( document . attachEvent ? document . readyState === "s" : document . readyState !== "s" ) { fn ( ) ; } else { document . addEventListener ( 's' , fn ) ; } } } ) ( ) ; ( function ( e ) { e . closest = e . closest || function ( css ) { var node = this ; while ( node ) { if ( node . matches ( css ) ) return node ; else node = node . parentElement ; } return null ; } } ) ( Element . prototype ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' ( function ( ) { var HIDE_CLASS = 's' ; var ITEM_CLASS = 's' ; function Item ( li ) { this . li = li ; this . type = li . title ; this . typeLowerCase = li . title . toLowerCase ( ) ; } Item . prototype . contains = function ( searchText ) { return this . typeLowerCase . indexOf ( searchText ) >= 0 ; } Item . prototype . isHide = function ( ) { this . li . classList . contains ( HIDE_CLASS ) ; } Item . prototype . hide = function ( ) { if ( ! this . isHide ( ) ) this . li . classList . add ( HIDE_CLASS ) ; } Item . prototype . show = function ( ) { this . li . classList . remove ( HIDE_CLASS ) ; } function ItemList ( items ) { this . items = items ; } ItemList . fromSelector = function ( selector ) { var lis = document . querySelectorAll ( selector ) ; var items = Array . prototype . map . call ( lis , function ( li ) { return new Item ( li ) ; } ) return new ItemList ( items ) ; } ItemList . prototype . showIfmatch = function ( match ) { match = match . toLowerCase ( match ) ; this . items . forEach ( function ( item ) { item . contains ( match ) ? item . show ( ) : item . hide ( ) ; } ) } var items = ItemList . fromSelector ( 's' ) ; var input = document . getElementById ( 's' ) ; var lastMatch = 's' ; function onChange ( ) { if ( input . value === lastMatch ) return ; lastMatch = input . value ; items . showIfmatch ( lastMatch ) ; } input . addEventListener ( 's' , onChange ) ; input . addEventListener ( 's' , onChange ) ; input . addEventListener ( 's' , onChange ) ; } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' ( function ( ) { var navScroll = document . getElementById ( 's' ) ; var header = document . querySelector ( 's' ) ; var active = document . querySelector ( 's' ) ; if ( active ) navScroll . scrollTop = active . offsetTop - header . offsetHeight - Math . ceil ( active . offsetHeight / 0 ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' ( function ( ) { var ACTIVE_CLASS = 's' ; var navigation = document . querySelector ( 's' ) ; var toggles = document . querySelectorAll ( 's' ) ; function toggleNavigation ( ) { navigation . classList . contains ( ACTIVE_CLASS ) ? navigation . classList . remove ( ACTIVE_CLASS ) : navigation . classList . add ( ACTIVE_CLASS ) ; } Array . prototype . forEach . call ( toggles , function ( toggle ) { toggle . addEventListener ( 's' , toggleNavigation ) ; } ) } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GraphQLEnumType , GraphQLID , GraphQLInterfaceType , GraphQLList , GraphQLNonNull , GraphQLObjectType , GraphQLSchema , GraphQLString } from "s" ; const episodeEnum = new GraphQLEnumType ( { description : "s" , name : "s" , values : { EMPIRE : { description : "s" , value : 0 } , JEDI : { description : "s" , value : 0 } , NEWHOPE : { description : "s" , value : 0 } } } ) ; const characterInterface = new GraphQLInterfaceType ( { name : "s" , description : "s" , fields : ( ) => ( { id : { type : new GraphQLNonNull ( GraphQLID ) , description : "s" } , name : { type : GraphQLString , description : "s" } , friends : { type : new GraphQLList ( characterInterface ) , description : "s" + "s" } , appearsIn : { type : new GraphQLList ( episodeEnum ) , description : "s" } , secretBackstory : { type : GraphQLString , description : "s" } } ) , resolveType : _ => humanType } ) ; const humanType = new GraphQLObjectType ( { name : "s" , description : "s" , fields : ( ) => ( { id : { type : new GraphQLNonNull ( GraphQLID ) , description : "s" } , name : { type : GraphQLString , description : "s" } , friends : { type : new GraphQLList ( characterInterface ) , description : "s" + "s" , resolve => human } , appearsIn : { type : new GraphQLList ( episodeEnum ) , description : "s" } , homePlanet : { type : GraphQLString , description : "s" } , secretBackstory : { type : GraphQLString , description : "s" , resolve : ( ) => { throw new Error ( "s" ) ; } } } ) , interfaces : [ characterInterface ] } ) ; const droidType = new GraphQLObjectType ( { name : "s" , description : "s" , fields : ( ) => ( { id : { type : new GraphQLNonNull ( GraphQLID ) , description : "s" } , name : { type : GraphQLString , description : "s" } , friends : { type : new GraphQLList ( characterInterface ) , description : "s" + "s" , resolve => droid } , appearsIn : { type : new GraphQLList ( episodeEnum ) , description : "s" } , secretBackstory : { type : GraphQLString , description : "s" , resolve : ( ) => { throw new Error ( "s" ) ; } } , primaryFunction : { type : GraphQLString , description : "s" } } ) , interfaces : [ characterInterface ] } ) ; const queryType = new GraphQLObjectType ( { name : "s" , description : "s" , fields : ( ) => ( { hero : { type : characterInterface , description : "s" , args : { episode : { description : "s" + "s" , type : episodeEnum } } , resolve : ( ) => null } , human : { type : humanType , description : "s" , args : { id : { description : "s" , type : new GraphQLNonNull ( GraphQLID ) } } , resolve : ( ) => null } , droid : { type : droidType , description : "s" , args : { id : { description : "s" , type : new GraphQLNonNull ( GraphQLID ) } } , resolve : ( ) => null } } ) } ) ; const mutationType = new GraphQLObjectType ( { name : "s" , description : "s" , fields : ( ) => ( { favorite : { type : episodeEnum , description : "s" , args : { episode : { type : new GraphQLNonNull ( episodeEnum ) , description : "s" } } , resolve : ( _ , { episode } ) => episode } } ) } ) ; export const StarWarsSchema = new GraphQLSchema ( { query : queryType , mutation : mutationType } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $human$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $droid$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { writeFileSync } from "s" ; import { printSchema } from "s" ; import { StarWarsSchema } from "s" ; writeFileSync ( __dirname + "s" , printSchema ( StarWarsSchema ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import express from "s" ; import graphqlHTTP from "s" ; import { GraphQLNonNull , GraphQLObjectType , GraphQLSchema , GraphQLString } from "s" ; import pack from "s" ; const app = express ( ) ; export const EmptySchema = new GraphQLSchema ( { query : new GraphQLObjectType ( { name : "s" , description : "s" , fields : { version : { type : new GraphQLNonNull ( GraphQLString ) , resolve : ( ) => pack . version } } } ) } ) ; app . use ( "s" , graphqlHTTP ( { schema : EmptySchema , graphiql : true } ) ) ; app . listen ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const Character = `template` ; const Droid = `template` ; const Episode = `template` ; const Human = `template` ; const Mutation = `template` ; const Query = `template` ; const Schema = `template` ; export default ( ) => [ Character , Droid , Episode , Human , Mutation , Query , Schema ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O