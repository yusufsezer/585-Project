import { AutoSubscribeStore , autoSubscribe , StoreBase , } from 's' ; interface Answer { answer : string ; image : string ; } @ AutoSubscribeStore class GameStore extends StoreBase { private _isLoading : boolean = false ; private _answer : string = 's' ; private _image : string = 's' ; private _error : string = 's' ; public guess ( ) { this . _guessStart ( ) ; fetch ( 's' ) . then ( response => response . json ( ) ) . then ( this . onSuccess ) . catch ( this . onError ) ; } @ autoSubscribe public getAnswer ( ) { return this . _answer ; } @ autoSubscribe public getImage ( ) { return this . _image ; } @ autoSubscribe public getError ( ) { return this . _error ; } @ autoSubscribe public isLoading ( ) { return this . _isLoading ; } private _guessStart = ( ) => { this . _isLoading = true ; this . _answer = 's' ; this . _error = 's' ; this . _image = 's' ; this . trigger ( ) ; } private onSuccess = ( { answer , image } ) => { this . _isLoading = false ; this . _answer = answer ; this . _image = image ; this . _error = 's' ; this . trigger ( ) ; } private onError = ( { message } ) => { this . _isLoading = false ; this . _error = message ; this . trigger ( ) ; } } export default new GameStore ( ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O O O $string$ O O O O O O $string$ O O O O O O $string$ O O O O O O $void$ O O O O O $void$ O O O $Promise<Response>$ O O O O O O $Response$ O $Response$ O $Promise<any>$ O O O O O O O O $void$ O O $complex$ O O O $void$ O O O O $any$ O $string$ O O O O O O $string$ O O O $any$ O $string$ O O O O O O $string$ O O O $any$ O $string$ O O O O O O $string$ O O O $any$ O $boolean$ O O O O O O $boolean$ O O O $void$ O O O O O O O $boolean$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $any$ O O O O O $void$ O O O $string$ O $string$ $Answer$ O O O O O $boolean$ O O O O O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O O O O O $any$ O O O O O $void$ O O O $string$ $Error$ O O O O O $boolean$ O O O O O $string$ O $string$ O O O $any$ O O O O O O O O $any$ O O O
import * as webpack from 's' ; import * as path from 's' ; import * as HtmlWebpackPlugin from 's' ; const DIST_PATH = path . join ( __dirname , 's' ) ; const APP_PATH = path . join ( __dirname , 's' ) ; const config : webpack . Configuration = { entry : APP_PATH , output : { filename : 's' , path : DIST_PATH , } , resolve : { extensions : [ 's' , 's' , 's' ] } , module : { rules : [ { test : "s" , loader : 's' } ] } , plugins : [ new webpack . NamedModulesPlugin ( ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( APP_PATH , 's' ) , } ) , ] , devServer : { contentBase : APP_PATH , openPage : 's' , open : true , port : 0 , stats : 's' , } , } ; export default config ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O $complex$ O O $string$ O O O $string$ O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string$ O O O O O O $any[]$ O O O $any$ O $any$ O O O O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O $complex$ O O $string$ O $string$ O $string$ O O O $boolean$ O O O $number$ O O O $string$ O O O O O O O O O $any$ O
import { AutoSubscribeStore , autoSubscribe , StoreBase , } from 's' ; @ AutoSubscribeStore class CounterStore extends StoreBase { private _counter : number = 0 ; public increment ( ) { this . _counter = this . _counter + 0 ; this . trigger ( ) ; } public decrement ( ) { this . _counter = this . _counter - 0 ; this . trigger ( ) ; } public reset ( ) { this . _counter = 0 ; this . trigger ( ) ; } @ autoSubscribe public getCounter ( ) { return this . _counter ; } } export default new CounterStore ( ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $number$ O O O O O O $void$ O O O O O $number$ O O O $number$ O O O O O $any$ O O O O O $void$ O O O O O $number$ O O O $number$ O O O O O $any$ O O O O O $void$ O O O O O $number$ O O O O O $any$ O O O O O $any$ O $number$ O O O O O O $number$ O O O O O O $any$ O O O
import * as webpack from 's' ; import * as path from 's' ; import * as HtmlWebpackPlugin from 's' ; const DIST_PATH = path . join ( __dirname , 's' ) ; const APP_PATH = path . join ( __dirname , 's' ) ; const config : webpack . Configuration = { entry : APP_PATH , output : { filename : 's' , path : DIST_PATH , } , resolve : { extensions : [ 's' , 's' , 's' ] } , module : { rules : [ { test : "s" , loader : 's' } ] } , plugins : [ new webpack . NamedModulesPlugin ( ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( APP_PATH , 's' ) , } ) , ] , devServer : { contentBase : APP_PATH , openPage : 's' , open : true , port : 0 , stats : 's' , } , } ; export default config ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O $complex$ O O $string$ O O O $string$ O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string$ O O O O O O $any[]$ O O O $any$ O $any$ O O O O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O $complex$ O O $string$ O $string$ O $string$ O O O $boolean$ O O O $number$ O O O $string$ O O O O O O O O O $any$ O
'js' const enzyme = require ( 's' ) ; const Adapter = require ( 's' ) ; enzyme . configure ( { adapter : new Adapter ( ) } ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O O O O O
'js' const ForkTsCheckerWebpackPlugin = require ( 's' ) ; const path = require ( 's' ) ; const ROOT_PATH = path . join ( __dirname , 's' ) ; const TS_CONFIG_PATH = path . join ( ROOT_PATH , 's' , 's' ) ; module . exports = { devtool : 's' , mode : 's' , resolve : { extensions : [ 's' , 's' , 's' ] , } , module : { rules : [ { test : "s" , loader : 's' , options : { transpileOnly : true , configFile : TS_CONFIG_PATH , } , exclude : "s" , } ] } , plugins : [ new ForkTsCheckerWebpackPlugin ( { tsconfig : TS_CONFIG_PATH } ) , ] , } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O $complex$ O O $string$ O O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $string$ O O O $complex$ O O $boolean$ O O O $any$ O $any$ O O O $RegExp$ O O O O O O O $any[]$ O O O $any$ O O $any$ O $any$ O O O O O O O
'js' const webpack = require ( 's' ) ; module . exports = config => ( config . set ( { basePath : 's' , frameworks : [ 's' ] , reporters : [ 's' , 's' ] , browsers : [ process . env . TRAVIS ? 's' : 's' , ] , plugins : [ 's' , 's' , 's' , 's' , 's' , 's' , ] , customLaunchers : { ChromeHeadlessNoSandbox : { base : 's' , flags : [ 's' ] , } } , preprocessors : { 's' : [ 's' , 's' ] , } , files : [ { pattern : 's' , watched : false } , ] , logLevel : config . LOG_INFO , colors : true , mime : { 's' : [ 's' , 's' ] , } , webpack , webpackMiddleware : { stats : 's' , } } ) ) ;	O O $complex$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O O O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O $string[]$ O O O O O O O O O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O $complex$ O O O O O O O O O O O O $complex$ O O O $string$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O $complex$ O O O O O O O O O O O O $complex$ O $complex$ O O $string$ O O O O O O O O
'js' require ( 's' ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . forEach ( context ) ;	O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O
'js' module . exports = require ( 's' ) ;	O $any$ O $any$ O $any$ O O O O
import { __decorate as tslibDecorate } from 's' ; declare var __decorate ; class FakeClassWithDecorator { @ ( ( FakeClassWithDecoratorPrototype , fooName , descriptor < any > ) => descriptor ) foo ( ) { return FakeClassWithDecorator ; } } __decorate = __decorate || tslibDecorate ; export { FakeClassWithDecorator as __unused , __decorate as decorate , } ;	O O $any$ O $any$ O O O O O O $Function$ O O $any$ O O O O $object$ O $string$ O $TypedPropertyDescriptor$ O O O O O $TypedPropertyDescriptor<any>$ O $complex$ O O O O $any$ O O O $Function$ O $Function$ O $any$ O O O $any$ O $any$ O $Function$ O $Function$ O O O
export interface IOptions { setTimeout : < T extends any [ ] > ( handler : ( params : T ) => void , timeout ? : number | undefined , ... params : T ) => number ; clearTimeout : ( id ? ) => void ; shouldComponentUpdateComparator : < T > ( values : T , compareTo : T ) => boolean ; defaultThrottleMs : number ; preventTryCatchInRender : boolean ; development : boolean ; } interface IProcess { env : { NODE_ENV ? : string } ; } declare var process ; let OptionsVals = { setTimeout : setTimeout . bind ( null ) , clearTimeout : clearTimeout . bind ( null ) , shouldComponentUpdateComparator : ( ) => false , defaultThrottleMs : 0 , preventTryCatchInRender : false , development : typeof process !== 's' && process . env && process . env . NODE_ENV !== 's' , } ; export default OptionsVals ;	O O $any$ O $number$ O O $any$ O O O O O O $void$ O O $T$ O $any$ O O O O $number$ O O O O O O O $T$ O $any$ O O O O $void$ O O $number$ $number$ O O O O $boolean$ O O $any$ O O $T$ O $any$ O $T$ O $any$ O O O O $number$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O $complex$ O O $string$ O O O O O O O O $IProcess$ O O $IOptions$ O O $any$ O $number$ O $any$ O O O O $any$ O $void$ O $any$ O O O O $false$ O O O O O O $number$ O O O $false$ O O O $boolean$ O O $IProcess$ O O O $IProcess$ O $complex$ O $IProcess$ O $complex$ O $string$ O O O O O O O $IOptions$ O
const CompoundKeyJoinerString = 's' ; export interface Dictionary < T > { [ index ] : T ; } export type KeyOrKeys = string | number | ( string | number ) [ ] ; export function noop ( ) { } export function isFunction ( object ) : object is Function { return typeof object === 's' ; } export function isString ( object ) : object is string { return typeof object === 's' ; } export function isNumber ( object ) : object is number { return typeof object === 's' ; } export const normalizeKey = ( key : string | number ) : string => ( isNumber ( key ) ? key . toString ( ) : key ) ; export const normalizeKeys = ( keyOrKeys ) : string [ ] => ( Array . isArray ( keyOrKeys ) ? keyOrKeys . map ( normalizeKey ) : [ normalizeKey ( keyOrKeys ) ] ) ; export const formCompoundKey = ( ... keys : ( string | number ) [ ] ) : string => { return keys . join ( CompoundKeyJoinerString ) ; } ; export const assert = ( cond , message ? : string | undefined ) : void => { if ( ! cond ) { throw new Error ( `template` ) ; } } ; export const values = < T > ( value < T > ) : T [ ] => { if ( isFunction ( Object . values ) ) { return Object . values ( value ) ; } return Object . keys ( value ) . map ( key => value [ key ] ) ; } ; export const flat = < T > ( value : T [ ] [ ] ) : T [ ] => { if ( isFunction ( value . flat ) ) { return value . flat ( ) ; } return value . reduce ( ( acc , val ) => acc . concat ( val ) , [ ] as T [ ] ) ; } ; export const remove = < T > ( array : T [ ] , predicate : ( value : T ) => boolean ) : void => { for ( let i = array . length - 0 ; i >= 0 ; i -- ) { if ( predicate ( array [ i ] ) ) { array . splice ( i , 0 ) ; } } } ; export const uniq = < T > ( array : T [ ] ) : T [ ] => { const set = new Set ( array ) ; if ( isFunction ( Array . from ) ) { return Array . from ( set ) ; } const uniq : T [ ] = [ ] ; set . forEach ( value => uniq . push ( value ) ) ; return uniq ; } ; export const find = < T > ( array : T [ ] , predicate : ( value : T , index , array : T [ ] ) => boolean ) : T | undefined => { if ( isFunction ( array . find ) ) { return array . find ( predicate ) ; } const len = array . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( predicate ( array [ i ] , i , array ) ) { return array [ i ] ; } } return undefined ; } ;	O O O O O O O $any$ O $any$ O O O $string$ O O $any$ O O O O $any$ O O O O O O O O O O O O O O O $void$ O O O O O O $complex$ O $any$ O O $any$ O $FunctionConstructor$ O O O $any$ O O O O O O $complex$ O $any$ O O $any$ O O O O O $any$ O O O O O O $complex$ O $any$ O O $any$ O O O O O $any$ O O O O O O $string$ O O $complex$ O O O O O O O O O $complex$ O $complex$ O O $number$ O $string$ O O O $string$ O O O O $string[]$ O O $KeyOrKeys$ O O O O O O O $ArrayConstructor$ O $complex$ O $KeyOrKeys$ O O $complex$ O $U[]$ O $string$ O O O $string$ O $complex$ O O O O O O $string$ O O O $complex$ O O O O O O O O O O O O O O $complex$ O $string$ O O O O O O O O $void$ O O $any$ O $string$ O O O O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $T[]$ O O $any$ O O $Dictionary$ O $any$ O O O $any$ O O O O O O $complex$ O $ObjectConstructor$ O $complex$ O O O O $ObjectConstructor$ O $complex$ O $Dictionary<T>$ O O O O $ObjectConstructor$ O $complex$ O $Dictionary<T>$ O O $U[]$ O $string$ O $Dictionary<T>$ O $string$ O O O O O O O $T[]$ O O $any$ O O $T[][]$ O $any$ O O O O O O $any$ O O O O O O $complex$ O $T[][]$ O O O O O O $T[][]$ O O O O O O O $T[][]$ O $complex$ O O $T[]$ O $T[]$ O O $T[]$ O $complex$ O $T[]$ O O O O O $any$ O O O O O O O O $void$ O O $any$ O O $T[]$ O $any$ O O O $boolean$ O O $T$ O $any$ O O O O O O O O O O O $number$ O $T[]$ O $number$ O O O $number$ O O O $number$ O O O O O $boolean$ O $T[]$ O $number$ O O O O $T[]$ O $complex$ O $number$ O O O O O O O O O O $T[]$ O O $any$ O O $T[]$ O $any$ O O O O $any$ O O O O O $Set<T>$ O O $SetConstructor$ O $T[]$ O O O O $complex$ O $ArrayConstructor$ O $complex$ O O O O $ArrayConstructor$ O $complex$ O $Set<T>$ O O O O $T[]$ O $any$ O O O O O O $Set<T>$ O O O $T$ O $T[]$ O $number$ O $T$ O O O O $T[]$ O O O O O $T$ O O $any$ O O $T[]$ O $any$ O O O $boolean$ O O $T$ O $any$ O $number$ O $T[]$ O $any$ O O O O O O O $any$ O O O O O O $complex$ O $T[]$ O $complex$ O O O O $T[]$ O $complex$ O $boolean$ O O O O $number$ O $T[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O O $boolean$ O $T[]$ O $number$ O O $number$ O $T[]$ O O O O $T[]$ O $number$ O O O O O $undefined$ O O O
import { noop } from 's' ; declare var global : { performance : Performance ; } ; export interface Performance { mark : ( name ) => void ; measure : ( name , startMark , endMark ) => void ; } const BuildStateBeginMark = 's' ; const BuildStateEndMark = 's' ; const CallbackBeginMark = 's' ; const CallbackEndMark = 's' ; export class Instrumentation { private _perf = Instrumentation . _getPerformanceImpl ( ) ; private static _getPerformanceImpl ( ) { const g = typeof global !== 's' ? global : undefined ; const w = typeof window !== 's' ? window : undefined ; const { performance } = ( g || w || { performance : undefined } ) ; if ( performance && performance . mark && performance . measure ) { return performance ; } return { mark : noop , measure : noop , } ; } private _measure ( measureName , beginMark , endMark ) { this . _perf . mark ( endMark ) ; try { this . _perf . measure ( measureName , beginMark , endMark ) ; } catch ( e ) { } } beginBuildState ( ) { this . _perf . mark ( BuildStateBeginMark ) ; } endBuildState ( target ) { const measureName = `template` ; this . _measure ( measureName , BuildStateBeginMark , BuildStateEndMark ) ; } beginInvokeStoreCallbacks ( ) { this . _perf . mark ( CallbackBeginMark ) ; } endInvokeStoreCallbacks ( target , count ) { const measureName = `template` ; this . _measure ( measureName , CallbackBeginMark , CallbackEndMark ) ; } } export let impl : Instrumentation | undefined ; export function setPerformanceMarkingEnabled ( enabled ) { impl = enabled ? new Instrumentation ( ) : undefined ; }	O O $void$ O O O O O O $complex$ O O $Performance$ O $any$ O O O O O $any$ O $void$ O O $string$ O O O O $void$ O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $Performance$ O $any$ O $Performance$ O O O O O $Performance$ O O O O $complex$ O O $complex$ O O O $complex$ O $undefined$ O O $complex$ O O $complex$ O O O $complex$ O $undefined$ O O O $Performance$ O O O $complex$ O $complex$ O O $undefined$ O $undefined$ O O O O O $Performance$ O $Performance$ O $void$ O $Performance$ O $void$ O O O $Performance$ O O O O $void$ O $void$ O $void$ O $void$ O O O O O $void$ O $string$ O $string$ O $string$ O O O O $Performance$ O $void$ O $string$ O O O O O O $Performance$ O $void$ O $string$ O $string$ O $string$ O O O O O $any$ O O O O $void$ O O O O O $Performance$ O $void$ O O O O O $void$ O $any$ O O O $string$ O O O O O $void$ O $string$ O O O O O O O $void$ O O O O O $Performance$ O $void$ O O O O O $void$ O $any$ O $number$ O O O $string$ O O O O O $void$ O $string$ O O O O O O O O O O $Instrumentation$ O $any$ O O O O O $void$ O $boolean$ O O $Instrumentation$ O $boolean$ O O $any$ O O O $undefined$ O O
import { StoreBase } from 's' ; export interface SubscriptionCallbackFunction { ( keys ? : string [ ] ) : void ; } export interface SubscriptionCallbackBuildStateFunction < S > { ( keys ? : string [ ] ) : Partial < S > | void ; } export interface StoreSubscription < P , S > { store : StoreBase ; callbackBuildState ? : SubscriptionCallbackBuildStateFunction < S > ; callback ? : SubscriptionCallbackFunction ; keyPropertyName ? : keyof P ; specificKeyValue ? : string | number ; enablePropertyName ? : keyof P ; }	O O $any$ O O O O O O $any$ O O $string[]$ O O O O O O O O O O O O $any$ O $any$ O O O $string[]$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $StoreBase$ O $any$ O $SubscriptionCallbackBuildStateFunction<S>$ O O $any$ O $any$ O O $SubscriptionCallbackFunction$ O O $any$ O $complex$ O O O $any$ O $complex$ O O O O O O $complex$ O O O $any$ O O
import * as Instrumentation from 's' ; import Options from 's' ; import { Dictionary , KeyOrKeys , assert , flat , isNumber , isString , normalizeKey , normalizeKeys , remove , uniq , values } from 's' ; import { SubscriptionCallbackFunction } from 's' ; export interface AutoSubscription { store : StoreBase ; callback : ( ) => void ; key : string ; used : boolean ; } interface CallbackMetadata { keys : string [ ] | null ; throttledUntil : number | undefined ; bypassBlock : boolean ; } type CallbackMap = Map < SubscriptionCallbackFunction , CallbackMetadata > ; export abstract class StoreBase { private static storeIdCounter = 0 ; static readonly Key_All = 's' ; private readonly _subscriptions : Dictionary < SubscriptionCallbackFunction [ ] > = { } ; private readonly _autoSubscriptions : Dictionary < AutoSubscription [ ] > = { } ; private _subTokenNum = 0 ; private readonly _subsByNum : { [ token ] : { key : string ; callback : SubscriptionCallbackFunction ; } ; } = { } ; readonly storeId = `template` ; private _throttleData : { timerId : number ; callbackTime : number } | undefined ; private static _triggerPending = false ; private static _isTriggering = false ; private static _triggerBlockCount = 0 ; private static _bypassThrottle = false ; private static readonly _pendingCallbacks : CallbackMap = new Map ( ) ; static pushTriggerBlock ( ) { this . _triggerBlockCount ++ ; } static popTriggerBlock ( ) { this . _triggerBlockCount -- ; assert ( this . _triggerBlockCount >= 0 , 's' ) ; if ( this . _triggerBlockCount === 0 ) { StoreBase . _resolveCallbacks ( ) ; } } static setThrottleStatus ( enabled ) { this . _bypassThrottle = ! enabled ; StoreBase . _resolveCallbacks ( ) ; } constructor ( private readonly _throttleMs ? , private readonly _bypassTriggerBlocks = false ) { } protected trigger ( keyOrKeys ? ) { const throttleMs = this . _throttleMs !== undefined ? this . _throttleMs : Options . defaultThrottleMs ; let throttledUntil : number | undefined ; if ( throttleMs ) { if ( ! this . _throttleData ) { this . _throttleData = { timerId : Options . setTimeout ( this . _handleThrottledCallbacks , this . _throttleMs ) , callbackTime : Date . now ( ) + throttleMs , } ; } throttledUntil = this . _throttleData . callbackTime ; } const bypassBlock = this . _bypassTriggerBlocks ; if ( ! keyOrKeys && ! isNumber ( keyOrKeys ) ) { flat ( values ( this . _subscriptions ) ) . forEach ( sub => this . _setupAllKeySubscription ( sub , throttledUntil , bypassBlock ) ) ; flat ( values ( this . _autoSubscriptions ) ) . forEach ( sub => this . _setupAllKeySubscription ( sub . callback , throttledUntil , bypassBlock ) ) ; } else { const keys = normalizeKeys ( keyOrKeys ) ; keys . forEach ( key => { ( this . _subscriptions [ key ] || [ ] ) . forEach ( callback => this . _setupSpecificKeySubscription ( [ key ] , callback , throttledUntil , bypassBlock ) ) ; ( this . _autoSubscriptions [ key ] || [ ] ) . forEach ( sub => this . _setupSpecificKeySubscription ( [ key ] , sub . callback , throttledUntil , bypassBlock ) ) ; } ) ; ( this . _subscriptions [ StoreBase . Key_All ] || [ ] ) . forEach ( callback => this . _setupSpecificKeySubscription ( keys , callback , throttledUntil , bypassBlock ) ) ; ( this . _autoSubscriptions [ StoreBase . Key_All ] || [ ] ) . forEach ( sub => this . _setupSpecificKeySubscription ( keys , sub . callback , throttledUntil , bypassBlock ) ) ; } if ( ! throttledUntil || bypassBlock ) { StoreBase . _resolveCallbacks ( ) ; } } private static _updateExistingMeta ( meta : CallbackMetadata | undefined , throttledUntil : number | undefined , bypassBlock ) { if ( ! meta ) { return ; } if ( throttledUntil && meta . throttledUntil ) { meta . throttledUntil = Math . min ( meta . throttledUntil , throttledUntil ) ; } if ( ! throttledUntil ) { meta . throttledUntil = undefined ; } if ( bypassBlock ) { meta . bypassBlock = true ; } } private _setupAllKeySubscription ( callback , throttledUntil : number | undefined , bypassBlock ) { const existingMeta = StoreBase . _pendingCallbacks . get ( callback ) ; const newMeta = { keys : null , throttledUntil , bypassBlock } ; if ( existingMeta && throttledUntil && existingMeta . throttledUntil ) { newMeta . throttledUntil = Math . min ( throttledUntil , existingMeta . throttledUntil ) ; } if ( existingMeta && existingMeta . bypassBlock ) { newMeta . bypassBlock = true ; } StoreBase . _pendingCallbacks . set ( callback , newMeta ) ; } private _setupSpecificKeySubscription ( keys : string [ ] , callback , throttledUntil : number | undefined , bypassBlock ) { const existingMeta = StoreBase . _pendingCallbacks . get ( callback ) ; StoreBase . _updateExistingMeta ( existingMeta , throttledUntil , bypassBlock ) ; if ( existingMeta === undefined ) { StoreBase . _pendingCallbacks . set ( callback , { keys : [ ... keys ] , throttledUntil , bypassBlock } ) ; } else if ( existingMeta . keys === null ) { } else { const keyCount = keys . length ; for ( let i = 0 ; i < keyCount ; i ++ ) { existingMeta . keys . push ( keys [ i ] ) ; } } } private _handleThrottledCallbacks = ( ) => { this . _throttleData = undefined ; StoreBase . _resolveCallbacks ( ) ; } ; private static _resolveCallbacks ( ) { if ( StoreBase . _isTriggering ) { StoreBase . _triggerPending = true ; return ; } StoreBase . _isTriggering = true ; StoreBase . _triggerPending = false ; if ( Instrumentation . impl ) { Instrumentation . impl . beginInvokeStoreCallbacks ( ) ; } let callbacksCount = 0 ; const currentTime = Date . now ( ) ; const callbacks : [ SubscriptionCallbackFunction , string [ ] | undefined ] [ ] = [ ] ; this . _pendingCallbacks . forEach ( ( meta , callback , map ) => { if ( StoreBase . _triggerBlockCount > 0 && ! meta . bypassBlock ) { return ; } if ( meta . throttledUntil && meta . throttledUntil > currentTime && ! StoreBase . _bypassThrottle ) { return ; } const uniquedKeys = meta . keys ? uniq ( meta . keys ) : meta . keys ; callbacks . push ( [ callback , uniquedKeys || undefined ] ) ; map . delete ( callback ) ; } ) ; callbacks . forEach ( ( [ callback , keys ] ) => { callbacksCount ++ ; callback ( keys ) ; } ) ; if ( Instrumentation . impl ) { Instrumentation . impl . endInvokeStoreCallbacks ( this . constructor , callbacksCount ) ; } StoreBase . _isTriggering = false ; if ( this . _triggerPending ) { StoreBase . _resolveCallbacks ( ) ; } } subscribe ( callback , rawKey : string | number = StoreBase . Key_All ) { const key = normalizeKey ( rawKey ) ; assert ( key && isString ( key ) , `template` ) ; let callbacks = this . _subscriptions [ key ] ; if ( ! callbacks ) { this . _subscriptions [ key ] = [ callback ] ; if ( key !== StoreBase . Key_All && ! this . _autoSubscriptions [ key ] ) { this . _startedTrackingKey ( key ) ; } } else { callbacks . push ( callback ) ; } let token = this . _subTokenNum ++ ; this . _subsByNum [ token ] = { key : key , callback : callback } ; return token ; } unsubscribe ( subToken ) { assert ( this . _subsByNum [ subToken ] , `template` ) ; let key = this . _subsByNum [ subToken ] . key ; let callback = this . _subsByNum [ subToken ] . callback ; delete this . _subsByNum [ subToken ] ; StoreBase . _pendingCallbacks . delete ( callback ) ; let callbacks = this . _subscriptions [ key ] ; assert ( callbacks , `template` ) ; const index = callbacks . indexOf ( callback ) ; if ( index !== - 0 ) { callbacks . splice ( index , 0 ) ; if ( callbacks . length === 0 ) { delete this . _subscriptions [ key ] ; if ( key !== StoreBase . Key_All && ! this . _autoSubscriptions [ key ] ) { this . _stoppedTrackingKey ( key ) ; } } } else { assert ( false , 's' ) ; } } trackAutoSubscription ( subscription ) { const key = subscription . key ; const callbacks = this . _autoSubscriptions [ key ] ; if ( ! callbacks ) { this . _autoSubscriptions [ key ] = [ subscription ] ; if ( key !== StoreBase . Key_All && ! this . _subscriptions [ key ] ) { this . _startedTrackingKey ( key ) ; } } else { callbacks . push ( subscription ) ; } } removeAutoSubscription ( subscription ) { const key = subscription . key ; let subs = this . _autoSubscriptions [ key ] ; assert ( subs , `template` ) ; const oldLength = subs . length ; remove ( subs , sub => sub === subscription ) ; assert ( subs . length === oldLength - 0 , 's' ) ; StoreBase . _pendingCallbacks . delete ( subscription . callback ) ; if ( subs . length === 0 ) { delete this . _autoSubscriptions [ key ] ; if ( key !== StoreBase . Key_All && ! this . _subscriptions [ key ] ) { this . _stoppedTrackingKey ( key ) ; } } } protected _startedTrackingKey ( key ) { } protected _stoppedTrackingKey ( key ) { } protected _getSubscriptionKeys ( ) : string [ ] { return Object . keys ( this . _subscriptions ) . concat ( Object . keys ( this . _autoSubscriptions ) ) ; } protected _isTrackingKey ( key ) { return ! ! this . _subscriptions [ key ] || ! ! this . _autoSubscriptions [ key ] ; } }	O O O $any$ O O O O $IOptions$ O O O O O $any$ O $any$ O $void$ O $T[]$ O $complex$ O $complex$ O $string$ O $string[]$ O $void$ O $T[]$ O $T[]$ O O O O O O $any$ O O O O O O $any$ O $StoreBase$ O $any$ O $void$ O O O O O O $string$ O O O $boolean$ O O O O O $any$ O $string[]$ O O O O O O O $number$ O O O O O $boolean$ O O O O O $any$ O $MapConstructor$ O $any$ O $any$ O O O O O $any$ O O O $number$ O O O O O O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $any$ O $any$ O O O O O O O O O $Dictionary<AutoSubscription[]>$ O $any$ O $any$ O O O O O O O O $number$ O O O O O $complex$ O O O $number$ O O O $string$ O O O $SubscriptionCallbackFunction$ O $any$ O O O O O O O O O $string$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O $boolean$ O O O O O $boolean$ O O O O O $number$ O O O O O $boolean$ O O O O O O $complex$ O $any$ O O $MapConstructor$ O O O O $void$ O O O O O $number$ O O O O $void$ O O O O O $number$ O O $void$ O O O $number$ O O O O O O O O O O $number$ O O O O $any$ O $void$ O O O O O O $void$ O $boolean$ O O O O $boolean$ O O $boolean$ O $any$ O $void$ O O O O O O O O $number$ $number$ O O O $boolean$ O O O O O O $void$ O $KeyOrKeys$ $KeyOrKeys$ O O O $number$ O O O $number$ O $undefined$ O O O $number$ O $IOptions$ O $number$ O O $number$ O O O O O O O $number$ O O O O O O O $complex$ O O O O $complex$ O O $number$ O $IOptions$ O $number$ O O O $void$ O O O $number$ O O $number$ O $DateConstructor$ O $number$ O O O $number$ O O O O $number$ O O O $complex$ O $number$ O O O $boolean$ O O O $boolean$ O O O O $KeyOrKeys$ O O $complex$ O $KeyOrKeys$ O O O $T[]$ O $T[]$ O O O $Dictionary<SubscriptionCallbackFunction[]>$ O O O $void$ O $SubscriptionCallbackFunction$ O O O $void$ O $SubscriptionCallbackFunction$ O $number$ O $boolean$ O O O $T[]$ O $T[]$ O O O $Dictionary<AutoSubscription[]>$ O O O $void$ O $AutoSubscription$ O O O $void$ O $AutoSubscription$ O $void$ O $number$ O $boolean$ O O O O O O O $string[]$ O $string[]$ O $KeyOrKeys$ O O $string[]$ O $void$ O $string$ O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O O O $void$ O $SubscriptionCallbackFunction$ O O O $void$ O O $string$ O O $SubscriptionCallbackFunction$ O $number$ O $boolean$ O O O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O O O $void$ O $AutoSubscription$ O O O $void$ O O $string$ O O $AutoSubscription$ O $void$ O $number$ O $boolean$ O O O O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $any$ O O O O O O O O $void$ O $SubscriptionCallbackFunction$ O O O $void$ O $string[]$ O $SubscriptionCallbackFunction$ O $number$ O $boolean$ O O O O O O $Dictionary<AutoSubscription[]>$ O $any$ O O O O O O O O $void$ O $AutoSubscription$ O O O $void$ O $string[]$ O $AutoSubscription$ O $void$ O $number$ O $boolean$ O O O O O O O $number$ O $boolean$ O O $any$ O $void$ O O O O O O O $void$ O $CallbackMetadata$ O $any$ O O O $number$ O O O O O $boolean$ O O O O O $CallbackMetadata$ O O O O O O O $number$ O $CallbackMetadata$ O $number$ O O $CallbackMetadata$ O $number$ O $Math$ O $number$ O $CallbackMetadata$ O $number$ O $number$ O O O O O O $number$ O O $CallbackMetadata$ O $number$ O $undefined$ O O O O $boolean$ O O $CallbackMetadata$ O $boolean$ O O O O O O $void$ O $SubscriptionCallbackFunction$ O $number$ O O O O O $boolean$ O O O $CallbackMetadata$ O $any$ O $complex$ O $CallbackMetadata$ O $SubscriptionCallbackFunction$ O O O $complex$ O O $null$ O O O $number$ O $boolean$ O O O O $CallbackMetadata$ O $number$ O $CallbackMetadata$ O $number$ O O $complex$ O $number$ O $Math$ O $number$ O $number$ O $CallbackMetadata$ O $number$ O O O O O $CallbackMetadata$ O $CallbackMetadata$ O $boolean$ O O $complex$ O $boolean$ O O O O $any$ O $complex$ O $complex$ O $SubscriptionCallbackFunction$ O $complex$ O O O O $void$ O $string[]$ O O O O O $SubscriptionCallbackFunction$ O $number$ O O O O O $boolean$ O O O $CallbackMetadata$ O $any$ O $complex$ O $CallbackMetadata$ O $SubscriptionCallbackFunction$ O O $any$ O $void$ O $CallbackMetadata$ O $number$ O $boolean$ O O O O $CallbackMetadata$ O $undefined$ O O $any$ O $complex$ O $complex$ O $SubscriptionCallbackFunction$ O O $string[]$ O O O $string[]$ O O $number$ O $boolean$ O O O O O O O $CallbackMetadata$ O $string[]$ O O O O O O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O $CallbackMetadata$ O $string[]$ O $number$ O $string[]$ O $number$ O O O O O O O $void$ O O O O O O O $complex$ O $undefined$ O $any$ O $void$ O O O O O O O $void$ O O O O O $any$ O $boolean$ O O $any$ O $boolean$ O O O O O O $any$ O $boolean$ O O O $any$ O $boolean$ O O O O O $any$ O $Instrumentation$ O O $any$ O $Instrumentation$ O $void$ O O O O O $number$ O O O O $number$ O $DateConstructor$ O $number$ O O O O $complex$ O O $any$ O O O O O O O O O O O O O O O $complex$ O $void$ O O $CallbackMetadata$ O $SubscriptionCallbackFunction$ O $complex$ O O O O O $any$ O $number$ O O O O $CallbackMetadata$ O $boolean$ O O O O O O O $CallbackMetadata$ O $number$ O $CallbackMetadata$ O $number$ O $number$ O O $any$ O $boolean$ O O O O O O $string[]$ O $CallbackMetadata$ O $string[]$ O $T[]$ O $CallbackMetadata$ O $string[]$ O O $CallbackMetadata$ O $string[]$ O $complex$ O $number$ O O $SubscriptionCallbackFunction$ O $string[]$ O $undefined$ O O O $complex$ O $boolean$ O $SubscriptionCallbackFunction$ O O O O O $complex$ O $void$ O O O $SubscriptionCallbackFunction$ O $string[]$ O O O O $number$ O O $SubscriptionCallbackFunction$ O $string[]$ O O O O O O O $any$ O $Instrumentation$ O O $any$ O $Instrumentation$ O $void$ O O O $Function$ O $number$ O O O $any$ O $boolean$ O O O O O O O $boolean$ O O $any$ O $void$ O O O O O $number$ O $SubscriptionCallbackFunction$ O $complex$ O O O O O $any$ O O O O O $string$ O $string$ O $complex$ O O $void$ O $string$ O $complex$ O $string$ O O O O O O $SubscriptionCallbackFunction[]$ O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O O $SubscriptionCallbackFunction[]$ O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O $SubscriptionCallbackFunction$ O O O O $string$ O $any$ O O O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O O $void$ O $string$ O O O O O O $SubscriptionCallbackFunction[]$ O $number$ O $SubscriptionCallbackFunction$ O O O O $number$ O O O $number$ O O O O $complex$ O $number$ O O O $string$ O $string$ O $SubscriptionCallbackFunction$ O $SubscriptionCallbackFunction$ O O O $number$ O O $void$ O $number$ O O $void$ O O O $complex$ O $number$ O O O O O O $string$ O O O $complex$ O $number$ O O $string$ O O $SubscriptionCallbackFunction$ O O O $complex$ O $number$ O O $SubscriptionCallbackFunction$ O O O O $complex$ O $number$ O O $any$ O $complex$ O $boolean$ O $SubscriptionCallbackFunction$ O O O $SubscriptionCallbackFunction[]$ O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O $void$ O $SubscriptionCallbackFunction[]$ O O O O O $number$ O $SubscriptionCallbackFunction[]$ O $number$ O $SubscriptionCallbackFunction$ O O O O $number$ O O O O O $SubscriptionCallbackFunction[]$ O $complex$ O $number$ O O O O O O $SubscriptionCallbackFunction[]$ O $number$ O O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O $string$ O $any$ O O O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O O $void$ O $string$ O O O O O O O $void$ O O O O O O O O $void$ O $AutoSubscription$ O O O $string$ O $AutoSubscription$ O $string$ O O $AutoSubscription[]$ O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O O $AutoSubscription[]$ O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O $AutoSubscription$ O O O O $string$ O $any$ O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O O $void$ O $string$ O O O O O O $AutoSubscription[]$ O $number$ O $AutoSubscription$ O O O O $void$ O $AutoSubscription$ O O O $string$ O $AutoSubscription$ O $string$ O O $AutoSubscription[]$ O O O $Dictionary<AutoSubscription[]>$ O $string$ O O $void$ O $AutoSubscription[]$ O O O O O $number$ O $AutoSubscription[]$ O $number$ O $void$ O $AutoSubscription[]$ O $AutoSubscription$ O $AutoSubscription$ O $AutoSubscription$ O O $void$ O $AutoSubscription[]$ O $number$ O $number$ O O O O O O $any$ O $complex$ O $boolean$ O $AutoSubscription$ O $void$ O O O O $AutoSubscription[]$ O $number$ O O O O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O $string$ O $any$ O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O O $void$ O $string$ O O O O O O $void$ O $string$ O O O O $void$ O $string$ O O O O $string[]$ O O O O O O O O $ObjectConstructor$ O $complex$ O O O $Dictionary<SubscriptionCallbackFunction[]>$ O O $complex$ O $ObjectConstructor$ O $complex$ O O O $Dictionary<AutoSubscription[]>$ O O O O O $boolean$ O $string$ O O O O O O O $Dictionary<SubscriptionCallbackFunction[]>$ O $string$ O O O O O O $Dictionary<AutoSubscription[]>$ O $string$ O O O O
import * as Decorator from 's' ; import Options from 's' ; import { KeyOrKeys , assert , formCompoundKey , isFunction , isNumber , isString , normalizeKeys } from 's' ; import { StoreBase } from 's' ; interface MetadataIndex { [ methodName ] : MetadataIndexData ; } interface MetadataIndexData { hasAutoSubscribeDecorator ? : boolean ; keyIndexes ? : number [ ] ; } interface MetadataProperties { __decorated ? : boolean ; } type Metadata = MetadataIndex & MetadataProperties ; type InstanceTargetWithMetadata = InstanceTarget & { __resubMetadata : Metadata ; } ; export interface InstanceTarget { } export interface AutoSubscribeHandler { handle ( instance , store , key ) : void ; } const enum AutoOptions { None , Enabled , Forbid } interface HandlerWraper { handler : AutoSubscribeHandler | undefined ; instance : InstanceTarget ; useAutoSubscriptions : AutoOptions ; inAutoSubscribe : boolean ; } let handlerWrapper : HandlerWraper | undefined ; function createAutoSubscribeWrapper < T extends Function > ( handler : AutoSubscribeHandler | undefined , useAutoSubscriptions , existingMethod : T , thisArg ) : T { return function AutoSubscribeWrapper ( this , ... args : any [ ] ) { const instance = thisArg || this ; const previousHandlerWrapper = handlerWrapper ; handlerWrapper = { handler : handler , instance : instance , useAutoSubscriptions : useAutoSubscriptions , inAutoSubscribe : false , } ; const result = _tryFinally ( ( ) => { return existingMethod . apply ( instance , args ) ; } , ( ) => { handlerWrapper = previousHandlerWrapper ; } ) ; return result ; } as any as T ; } export function enableAutoSubscribeWrapper < T extends Function > ( handler , existingMethod : T , thisArg ) : T { return createAutoSubscribeWrapper ( handler , AutoOptions . Enabled , existingMethod , thisArg ) ; } export function forbidAutoSubscribeWrapper < T extends any [ ] , R > ( existingMethod : ( ... args : T ) => R , thisArg ? ) : ( ... args : T ) => R { if ( ! Options . development ) { return thisArg ? existingMethod . bind ( thisArg ) : existingMethod ; } return createAutoSubscribeWrapper ( undefined , AutoOptions . Forbid , existingMethod , thisArg ) ; } export function enableAutoSubscribe ( handler ) { return < T > ( target , propertyKey : string | symbol , descriptor < T > ) => { const existingMethod = descriptor . value as any as Function ; assert ( isFunction ( existingMethod ) , 's' ) ; descriptor . value = enableAutoSubscribeWrapper ( handler , existingMethod , undefined ) as any as T ; return descriptor ; } ; } function _tryFinally < TResult > ( tryFunc : ( ) => TResult , finallyFunc ) { try { return tryFunc ( ) ; } finally { finallyFunc ( ) ; } } function instanceTargetToInstanceTargetWithMetadata ( instanceTarget ) { const newTarget = instanceTarget as InstanceTargetWithMetadata ; newTarget . __resubMetadata = newTarget . __resubMetadata || { } ; return newTarget ; } function getMethodMetadata ( instance , methodName ) { if ( ! instance . __resubMetadata [ methodName ] ) { instance . __resubMetadata [ methodName ] = { } ; } return instance . __resubMetadata [ methodName ] ; } export const AutoSubscribeStore = < TFunction extends Function > ( func ) : TFunction => { const target = instanceTargetToInstanceTargetWithMetadata ( func . prototype ) ; target . __resubMetadata . __decorated = true ; if ( Options . development ) { Object . getOwnPropertyNames ( target ) . forEach ( property => { if ( isFunction ( target [ property ] ) && property !== 's' ) { const metaForMethod = target . __resubMetadata [ property ] ; if ( ! metaForMethod || ! metaForMethod . hasAutoSubscribeDecorator ) { Decorator . decorate ( [ warnIfAutoSubscribeEnabled ] , target , property , null ) ; } } } ) ; } return func ; } ; function makeAutoSubscribeDecorator ( shallow = false , autoSubscribeKeys ? : string [ ] ) { return < T > ( target , methodName : string | symbol , descriptor < T > ) => { const methodNameString = methodName . toString ( ) ; const targetWithMetadata = instanceTargetToInstanceTargetWithMetadata ( target ) ; const metaForMethod = getMethodMetadata ( targetWithMetadata , methodNameString ) ; metaForMethod . hasAutoSubscribeDecorator = true ; const existingMethod = descriptor . value as any as Function ; assert ( isFunction ( existingMethod ) , 's' ) ; descriptor . value = function AutoSubscribe ( this , ... args : any [ ] ) { assert ( targetWithMetadata . __resubMetadata . __decorated , `template` ) ; const scopedHandleWrapper = handlerWrapper ; if ( ! scopedHandleWrapper || scopedHandleWrapper . useAutoSubscriptions === AutoOptions . None ) { return existingMethod . apply ( this , args ) ; } if ( scopedHandleWrapper . useAutoSubscriptions === AutoOptions . Forbid ) { assert ( false , `template` + `template` ) ; return existingMethod . apply ( this , args ) ; } let keyParamValues : ( string | number ) [ ] = [ ] ; if ( metaForMethod . keyIndexes ) { keyParamValues = metaForMethod . keyIndexes . map ( index => { let keyArg : number | string = args [ index ] ; if ( isNumber ( keyArg ) ) { keyArg = keyArg . toString ( ) ; } assert ( keyArg , `template` + `template` ) ; assert ( isString ( keyArg ) , `template` + `template` ) ; return keyArg ; } ) ; } const specificKeyValues : string [ ] = ( autoSubscribeKeys && autoSubscribeKeys . length > 0 ) ? autoSubscribeKeys . map ( autoSubKey => formCompoundKey ( ... keyParamValues . concat ( autoSubKey ) ) ) : [ ( keyParamValues . length > 0 ) ? formCompoundKey ( ... keyParamValues ) : StoreBase . Key_All ] ; let wasInAutoSubscribe ; const result = _tryFinally ( ( ) => { scopedHandleWrapper . useAutoSubscriptions = shallow ? AutoOptions . None : AutoOptions . Enabled ; wasInAutoSubscribe = scopedHandleWrapper . inAutoSubscribe ; scopedHandleWrapper . inAutoSubscribe = true ; specificKeyValues . forEach ( specificKeyValue => { scopedHandleWrapper . handler ! ! ! . handle . apply ( scopedHandleWrapper . instance , [ scopedHandleWrapper . instance , this , specificKeyValue ] ) ; } ) ; return existingMethod . apply ( this , args ) ; } , ( ) => { scopedHandleWrapper . useAutoSubscriptions = AutoOptions . Enabled ; scopedHandleWrapper . inAutoSubscribe = wasInAutoSubscribe ; } ) ; return result ; } as any as T ; return descriptor ; } ; } export const autoSubscribe = makeAutoSubscribeDecorator ( true , undefined ) ; export function autoSubscribeWithKey ( keyOrKeys ) { assert ( keyOrKeys || isNumber ( keyOrKeys ) , 's' ) ; return makeAutoSubscribeDecorator ( true , normalizeKeys ( keyOrKeys ) ) ; } export function key ( target , methodName , index ) { const targetWithMetadata = instanceTargetToInstanceTargetWithMetadata ( target ) ; const metaForMethod = getMethodMetadata ( targetWithMetadata , methodName ) ; metaForMethod . keyIndexes = [ index ] . concat ( metaForMethod . keyIndexes || [ ] ) ; } export function disableWarnings < T extends Function > ( target , methodName , descriptor < T > ) < T > { const targetWithMetadata = instanceTargetToInstanceTargetWithMetadata ( target ) ; const metaForMethod = getMethodMetadata ( targetWithMetadata , methodName ) ; metaForMethod . hasAutoSubscribeDecorator = true ; if ( ! Options . development ) { return descriptor ; } const existingMethod = descriptor . value ! ! ! ; descriptor . value = function DisableWarnings ( this , ... args : any [ ] ) { assert ( targetWithMetadata . __resubMetadata . __decorated , `template` ) ; const scopedHandleWrapper = handlerWrapper ; if ( ! scopedHandleWrapper || scopedHandleWrapper . useAutoSubscriptions === AutoOptions . None ) { return existingMethod . apply ( this , args ) ; } let wasInAutoSubscribe ; let wasUseAutoSubscriptions ; const result = _tryFinally ( ( ) => { wasInAutoSubscribe = scopedHandleWrapper . inAutoSubscribe ; scopedHandleWrapper . inAutoSubscribe = true ; wasUseAutoSubscriptions = scopedHandleWrapper . useAutoSubscriptions ; if ( scopedHandleWrapper . useAutoSubscriptions === AutoOptions . Forbid ) { scopedHandleWrapper . useAutoSubscriptions = AutoOptions . None ; } return existingMethod . apply ( this , args ) ; } , ( ) => { scopedHandleWrapper . inAutoSubscribe = wasInAutoSubscribe ; scopedHandleWrapper . useAutoSubscriptions = wasUseAutoSubscriptions ; } ) ; return result ; } as any as T ; return descriptor ; } export function warnIfAutoSubscribeEnabled < T extends Function > ( target , methodName , descriptor < T > ) < T > { if ( ! Options . development ) { return descriptor ; } const targetWithMetadata = instanceTargetToInstanceTargetWithMetadata ( target ) ; if ( Options . development ) { getMethodMetadata ( targetWithMetadata , methodName ) ; } const originalMethod = descriptor . value ! ! ! ; descriptor . value = function WarnIfAutoSubscribeEnabled ( this , ... args : any [ ] ) { assert ( targetWithMetadata . __resubMetadata . __decorated , `template` ) ; assert ( ! handlerWrapper || handlerWrapper . useAutoSubscriptions !== AutoOptions . Enabled || handlerWrapper . inAutoSubscribe , `template` ) ; return originalMethod . apply ( this , args ) ; } as any as T ; return descriptor ; }	O O O $any$ O O O O $IOptions$ O O O O O $any$ O $void$ O $string$ O $complex$ O $complex$ O $complex$ O $string[]$ O O O O O O $any$ O O O O O $any$ O O $string$ O O $any$ O O O $any$ O $boolean$ O O O O $number[]$ O O O O O O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $Metadata$ O $any$ O O O O O $any$ O O O O $any$ O $void$ O $InstanceTarget$ O $StoreBase$ O $string$ O O O O O O O $any$ O $AutoOptions.None$ O $AutoOptions.Enabled$ O $AutoOptions.Forbid$ O O $any$ O $AutoSubscribeHandler$ O $any$ O O O $InstanceTarget$ O $any$ O $AutoOptions$ O $any$ O $boolean$ O O O O O $HandlerWraper$ O $any$ O O O O $T$ O $any$ O $FunctionConstructor$ O O $AutoSubscribeHandler$ O $any$ O O O $AutoOptions$ O $T$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any[]$ O O O O O O O $any$ O $any$ O O O O $HandlerWraper$ O $HandlerWraper$ O $HandlerWraper$ O O $AutoSubscribeHandler$ O $AutoSubscribeHandler$ O $any$ O $any$ O $AutoOptions$ O $AutoOptions$ O $false$ O O O O O O $any$ O $TResult$ O O O O O O $T$ O $any$ O $any$ O $any[]$ O O O O O O O O $HandlerWraper$ O $HandlerWraper$ O O O O O $any$ O O O O O $any$ O O O O $T$ O $any$ O $FunctionConstructor$ O O $AutoSubscribeHandler$ O $T$ O $any$ O $any$ O O $any$ O O $T$ O $AutoSubscribeHandler$ O $any$ O $AutoOptions.Enabled$ O $T$ O $any$ O O O O O $R$ O $any$ O O O O O $any$ O O $R$ O O O $T$ O $any$ O O $any$ O $any$ $any$ O O O O $T$ O $any$ O O $any$ O O O O $IOptions$ O $boolean$ O O O $any$ O $R$ O $any$ O $any$ O O $R$ O O O $T$ O $undefined$ O $any$ O $AutoOptions.Forbid$ O $R$ O $any$ O O O O O $MethodDecorator$ O $AutoSubscribeHandler$ O O O O $any$ O O $InstanceTarget$ O $complex$ O O O O O $TypedPropertyDescriptor$ O $any$ O O O O O $Function$ O $TypedPropertyDescriptor<T>$ O $T$ O O O $FunctionConstructor$ O $void$ O $complex$ O $Function$ O O O O O $TypedPropertyDescriptor<T>$ O $T$ O $T$ O $AutoSubscribeHandler$ O $Function$ O $undefined$ O O O O $any$ O O $TypedPropertyDescriptor<T>$ O O O O O $TResult$ O $any$ O O $TResult$ O O O O $any$ O $Function$ O O O O O $TResult$ O O O O O O $Function$ O O O O O O $InstanceTargetWithMetadata$ O $InstanceTarget$ O O O $InstanceTargetWithMetadata$ O $InstanceTarget$ O $any$ O $InstanceTargetWithMetadata$ O $Metadata$ O $InstanceTargetWithMetadata$ O $Metadata$ O O O O O $InstanceTargetWithMetadata$ O O O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $string$ O O O O O $InstanceTargetWithMetadata$ O $Metadata$ O $string$ O O O $InstanceTargetWithMetadata$ O $Metadata$ O $string$ O O O O O O O $InstanceTargetWithMetadata$ O $Metadata$ O $string$ O O O O O $ClassDecorator$ O O $any$ O $FunctionConstructor$ O O $TFunction$ O O $any$ O O O $InstanceTargetWithMetadata$ O $InstanceTargetWithMetadata$ O $TFunction$ O $any$ O O $InstanceTargetWithMetadata$ O $Metadata$ O $boolean$ O O O O O $IOptions$ O $boolean$ O O $ObjectConstructor$ O $string[]$ O $InstanceTargetWithMetadata$ O O $void$ O $string$ O O O O $complex$ O $InstanceTargetWithMetadata$ O $string$ O O O $string$ O O O O O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $Metadata$ O $string$ O O O O O $MetadataIndexData$ O O $MetadataIndexData$ O $boolean$ O O $any$ O $Function$ O O $TypedPropertyDescriptor<T>$ O O $InstanceTargetWithMetadata$ O $string$ O O O O O O O O O O O $TFunction$ O O O O $MethodDecorator$ O $boolean$ O O O $string[]$ O O O O O O O O O $any$ O O $InstanceTarget$ O $complex$ O O O O O $TypedPropertyDescriptor$ O $any$ O O O O O $string$ O $complex$ O $string)$ O O O O $InstanceTargetWithMetadata$ O $InstanceTargetWithMetadata$ O $InstanceTarget$ O O O $MetadataIndexData$ O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $string$ O O $MetadataIndexData$ O $boolean$ O O O O $Function$ O $TypedPropertyDescriptor<T>$ O $T$ O O O $FunctionConstructor$ O $void$ O $complex$ O $Function$ O O O O O $TypedPropertyDescriptor<T>$ O $T$ O O $any$ O $any$ O O $any[]$ O O O O O O $void$ O $InstanceTargetWithMetadata$ O $Metadata$ O $boolean$ O O O O O $HandlerWraper$ O $HandlerWraper$ O O O O $HandlerWraper$ O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.None$ O O O $Function$ O $any$ O O O $any[]$ O O O O O $HandlerWraper$ O $complex$ O $any$ O $AutoOptions.Forbid$ O O $void$ O O O O O O O O O $Function$ O $any$ O O O $any[]$ O O O O $complex$ O O O O O O O O O O O O O O $MetadataIndexData$ O $number[]$ O O $complex$ O $MetadataIndexData$ O $number[]$ O $U[]$ O $number$ O O O $complex$ O O O O O $any[]$ O $number$ O O O O $complex$ O $complex$ O O O $complex$ O $number$ O $string$ O O O O $void$ O $string$ O O O O O O $void$ O $complex$ O $string$ O O O O O O O O $string$ O O O O O O $string[]$ O O O O O O $string[]$ O $string[]$ O $number$ O O O O $string[]$ O $U[]$ O $string$ O $string$ O O $complex$ O $complex$ O $string$ O O O O O O $complex$ O $number$ O O O O $string$ O O $complex$ O O $any$ O O O O O $boolean$ O O $any$ O $TResult$ O O O O O $HandlerWraper$ O $AutoOptions$ O $boolean$ O $any$ O $AutoOptions.None$ O $any$ O $AutoOptions.Enabled$ O $boolean$ O $HandlerWraper$ O $boolean$ O $HandlerWraper$ O $boolean$ O O O $string[]$ O $void$ O $string$ O O $HandlerWraper$ O $AutoSubscribeHandler$ O O O O $void$ O $any$ O $HandlerWraper$ O $InstanceTarget$ O O $HandlerWraper$ O $InstanceTarget$ O O O $string$ O O O O O O O $Function$ O $any$ O O O $any[]$ O O O O O O O O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.Enabled$ O $HandlerWraper$ O $boolean$ O $boolean$ O O O O O $any$ O O O O O $any$ O O $TypedPropertyDescriptor<T>$ O O O O O O $MethodDecorator$ O $MethodDecorator$ O O O $undefined$ O O O O $MethodDecorator$ O $KeyOrKeys$ O O $void$ O $KeyOrKeys$ O $complex$ O $KeyOrKeys$ O O O O O O $MethodDecorator$ O O O $string[]$ O $KeyOrKeys$ O O O O O O $void$ O $InstanceTarget$ O $string$ O $number$ O O O $InstanceTargetWithMetadata$ O $InstanceTargetWithMetadata$ O $InstanceTarget$ O O O $MetadataIndexData$ O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $string$ O O $MetadataIndexData$ O $number[]$ O O $number$ O O $complex$ O $MetadataIndexData$ O $number[]$ O O O O O O O O $TypedPropertyDescriptor$ O $any$ O $FunctionConstructor$ O O $InstanceTarget$ O $string$ O $TypedPropertyDescriptor$ O $any$ O O O $any$ O O O $InstanceTargetWithMetadata$ O $InstanceTargetWithMetadata$ O $InstanceTarget$ O O O $MetadataIndexData$ O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $string$ O O $MetadataIndexData$ O $boolean$ O O O O O O $IOptions$ O $boolean$ O O O $TypedPropertyDescriptor<T>$ O O O $T$ O $TypedPropertyDescriptor<T>$ O $T$ O O O O $TypedPropertyDescriptor<T>$ O $T$ O O $any$ O $any$ O O $any[]$ O O O O O O $void$ O $InstanceTargetWithMetadata$ O $Metadata$ O $boolean$ O O O O O $HandlerWraper$ O $HandlerWraper$ O O O O $HandlerWraper$ O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.None$ O O O $T$ O $any$ O O O $any[]$ O O O O $boolean$ O O $AutoOptions$ O O $any$ O $TResult$ O O O O O $boolean$ O $HandlerWraper$ O $boolean$ O $HandlerWraper$ O $boolean$ O O O $AutoOptions$ O $HandlerWraper$ O $AutoOptions$ O O O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.Forbid$ O O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.None$ O O O $T$ O $any$ O O O $any[]$ O O O O O O O O $HandlerWraper$ O $boolean$ O $boolean$ O $HandlerWraper$ O $AutoOptions$ O $AutoOptions$ O O O O O $any$ O O O O O $any$ O O $TypedPropertyDescriptor<T>$ O O O O $TypedPropertyDescriptor$ O $any$ O $FunctionConstructor$ O O $InstanceTarget$ O $string$ O $TypedPropertyDescriptor$ O $any$ O O O $any$ O O O O O $IOptions$ O $boolean$ O O O $TypedPropertyDescriptor<T>$ O O O $InstanceTargetWithMetadata$ O $InstanceTargetWithMetadata$ O $InstanceTarget$ O O O O $IOptions$ O $true$ O O $MetadataIndexData$ O $InstanceTargetWithMetadata$ O $string$ O O O O $T$ O $TypedPropertyDescriptor<T>$ O $T$ O O O O $TypedPropertyDescriptor<T>$ O $T$ O O $any$ O $any$ O O $any[]$ O O O O O O $void$ O $InstanceTargetWithMetadata$ O $Metadata$ O $boolean$ O O O O $void$ O O $HandlerWraper$ O $HandlerWraper$ O $AutoOptions$ O $any$ O $AutoOptions.Enabled$ O $HandlerWraper$ O $boolean$ O O O O O $T$ O $any$ O O O $any[]$ O O O O O O $any$ O O $TypedPropertyDescriptor<T>$ O O
import isEqual from 's' ; import { Dictionary } from 's' ; import ComponentBase from 's' ; export function CustomEqualityShouldComponentUpdate < P extends React . Props < any > , S extends Dictionary < any > > ( comparator : ( this < P , S > , nextProps < P > , nextState < S > , nextContext ) => boolean ) { return function < T extends { new ( props ) : ComponentBase < P , S > } > ( constructor : T ) : T { constructor . prototype . shouldComponentUpdate = comparator ; return constructor ; } ; } export function DeepEqualityShouldComponentUpdate < T extends { new ( props ) : ComponentBase < any , any > } > ( constructor : T ) : T { return CustomEqualityShouldComponentUpdate < any , any > ( deepEqualityComparator ) ( constructor ) ; } function deepEqualityComparator < P extends React . Props < any > , S extends Dictionary < any > > ( this < P , S > , nextProps < P > , nextState < S > , nextContext ) { return isEqual ( this . state , nextState ) || isEqual ( this . props , nextProps ) || isEqual ( this . context , nextContext ) ; }	O $any$ O O O O O $any$ O O O O O $any$ O O O O O $T$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $boolean$ O O $ComponentBase$ O $any$ O $any$ O O $Readonly$ O $any$ O O $Readonly$ O $any$ O O $any$ O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $T$ O $any$ O O $any$ O $T$ O $any$ O $any$ O $boolean$ O O $T$ O O O O O O $T$ O $any$ O O O O $any$ O O $any$ O O O O O O O O $T$ O $any$ O O $any$ O O $T$ O O O O O O $boolean$ O O $T$ O O O O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $ComponentBase$ O $any$ O $any$ O O $Readonly$ O $any$ O O $Readonly$ O $any$ O O $any$ O O O $any$ O O O $any$ O $Readonly<S>$ O O $any$ O O O $any$ O $Readonly<P>$ O O $any$ O O O $any$ O $any$ O O O
import * as Types from 's' ; export { autoSubscribeWithKey , AutoSubscribeStore , disableWarnings , autoSubscribe , key , } from 's' ; export { CustomEqualityShouldComponentUpdate , DeepEqualityShouldComponentUpdate } from 's' ; export { setPerformanceMarkingEnabled } from 's' ; export { default as Options } from 's' ; export { formCompoundKey } from 's' ; export { ComponentBase } from 's' ; export { StoreBase } from 's' ; export { Types } ;	O O O $any$ O O O O O $MethodDecorator$ O $ClassDecorator$ O $TypedPropertyDescriptor<T>$ O $MethodDecorator$ O $void$ O O O O O O O $T$ O $T$ O O O O O O $void$ O O O O O O $IOptions$ O $IOptions$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O
import * as Lint from 's' ; import ts from 's' ; import { isMethodDeclaration } from 's' ; import { isCallExpression , isPropertyAccessExpression } from 's' ; const DEBUG = false ; const ERROR_MESSAGE = 's' ; export class Rule extends Lint . Rules . AbstractRule { static metadata : Lint . IRuleMetadata = { ruleName : 's' , description : 's' , rationale : 's' , optionsDescription : 's' , options : { } , type : 's' , typescriptOnly : true , } ; apply ( sourceFile : ts . SourceFile ) : Lint . RuleFailure [ ] { return this . applyWithFunction ( sourceFile , walk , this . ruleArguments ) ; } } interface MethodInfo { name : string ; calling : string [ ] ; node : ts . MethodDeclaration ; stateNodes : ts . Node [ ] ; } let methods : { [ key ] : MethodInfo } = { } ; let method ; function analyzeMethodBody ( node : ts . Node ) { if ( isCallExpression ( node ) ) { let expr = node . getText ( ) ; if ( expr . indexOf ( 's' ) === 0 ) { const index = expr . indexOf ( 's' ) ; if ( index ) { const name = expr . substring ( 0 , index ) ; method . calling . push ( name ) ; if ( DEBUG ) { console . log ( 's' , method . name + 's' + name ) ; } } } analyzeNodeChildren ( node , 's' ) ; } else if ( isPropertyAccessExpression ( node ) ) { if ( node . getText ( ) . lastIndexOf ( 's' ) !== - 0 ) { method . stateNodes . push ( node ) ; analyzeNodeChildren ( node , 's' , true ) ; } else { analyzeNodeChildren ( node , 's' , true ) ; } } else { analyzeNodeChildren ( node , 's' ) ; } } function analyzeNodeChildren ( node : ts . Node , context , skip ? ) { if ( DEBUG ) { console . log ( context , node . kind , node . getText ( ) ) ; } if ( ! skip ) { node . forEachChild ( analyzeMethodBody ) ; } } function walk ( ctx : Lint . WalkContext < string [ ] > ) { return ts . forEachChild ( ctx . sourceFile , function cb ( node ) : void { if ( isMethodDeclaration ( node ) ) { const methodName = node . name . getText ( ) ; method = { name : methodName , calling : [ ] , node , stateNodes : [ ] } ; methods [ node . name . getText ( ) ] = method ; if ( node . body ) { analyzeMethodBody ( node . body ) ; } } else if ( node . kind === ts . SyntaxKind . EndOfFileToken ) { let visitedMethods : { [ key ] : boolean } = { } ; let queue : MethodInfo [ ] = [ ] ; const methodsList = ctx . options . concat ( [ 's' ] ) ; methodsList . forEach ( ( methodName ) => { const method = methods [ methodName ] ; if ( method ) { queue . push ( method ) ; } } ) ; while ( queue . length > 0 ) { const method = queue . pop ( ) ! ! ! ; if ( ! visitedMethods [ method . name ] ) { visitedMethods [ method . name ] = true ; method . stateNodes . forEach ( ( node : ts . Node ) => { ctx . addFailureAtNode ( node , ERROR_MESSAGE ) ; } ) ; method . calling . forEach ( ( name ) => { const called = methods [ name ] ; if ( called ) { queue . push ( called ) ; } } ) ; } } methods = { } ; } else { return ts . forEachChild ( node , cb ) ; } } ) ; }	O O O $any$ O O O O $any$ O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O $false$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O ${}$ O O O O $string$ O O O $boolean$ O O O O O $any[]$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $void$ O O O $any$ O O O O O $any$ O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O $any[]$ O $any$ O $any$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $MethodInfo$ O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O $MethodInfo$ O $string[]$ O $number$ O $any$ O O O O $false$ O O $Console$ O $void$ O O O $MethodInfo$ O $string$ O O O $any$ O O O O O $void$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $MethodInfo$ O $any[]$ O $number$ O $any$ O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O O O O O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $string$ O $boolean$ $boolean$ O O O O $false$ O O $Console$ O $void$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $boolean$ O O $any$ O $any$ O $void$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O O O O O O $complex$ O $any$ O O O O $string$ O $MethodDeclaration$ O $PropertyName$ O $string$ O O O $MethodInfo$ O O $string$ O $string$ O $undefined[]$ O O O O $MethodDeclaration$ O $undefined[]$ O O O O O $complex$ O $MethodDeclaration$ O $PropertyName$ O $string$ O O O O $MethodInfo$ O O O $MethodDeclaration$ O $Block$ O O $void$ O $MethodDeclaration$ O $Block$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O O O O O $MethodInfo[]$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $string$ O O O O $MethodInfo$ O $complex$ O $string$ O O O O $MethodInfo$ O O $MethodInfo[]$ O $number$ O $MethodInfo$ O O O O O O O O $MethodInfo[]$ O $number$ O O O O O $MethodInfo$ O $MethodInfo[]$ O $MethodInfo$ O O O O O O O O O $complex$ O $MethodInfo$ O $string$ O O O $complex$ O $MethodInfo$ O $string$ O O O O $MethodInfo$ O $any[]$ O $void$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $MethodInfo$ O $string[]$ O $void$ O O $string$ O O O O $MethodInfo$ O $complex$ O $string$ O O O O $MethodInfo$ O O $MethodInfo[]$ O $number$ O $MethodInfo$ O O O O O O O O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $void$ O O O O O O O
import ts from 's' ; import { RuleFailure , Rules , RuleWalker } from 's' ; const MISSING_SUPER_CALL = 's' ; const MISSING_TOP_LEVEL_SUPER_CALL = 's' ; const SUPER_REGEXP = "s" ; export class Rule extends Rules . AbstractRule { apply ( sourceFile : ts . SourceFile ) : RuleFailure [ ] { const options = this . getOptions ( ) ; const overrideCallsSuperWalker = new OverrideCallsSuperWalker ( sourceFile , options ) ; const methodNamesToCheck = options . ruleArguments ; methodNamesToCheck . forEach ( f => overrideCallsSuperWalker . addOverrideMethodToCheck ( f ) ) ; return this . applyWithWalker ( overrideCallsSuperWalker ) ; } } class OverrideCallsSuperWalker extends RuleWalker { private _methodNamesToCheck : string [ ] = [ ] ; addOverrideMethodToCheck ( methodName ) { this . _methodNamesToCheck . push ( methodName ) ; } visitMethodDeclaration ( node : ts . MethodDeclaration ) { const methodName = node . name . getText ( ) ; if ( this . _methodNamesToCheck . includes ( methodName ) ) { this . _checkOverrideCallsSuper ( node , methodName ) ; } super . visitMethodDeclaration ( node ) ; } private _checkOverrideCallsSuper ( node : ts . MethodDeclaration , methodName ) { let hasSuperCall = false ; if ( node . body ) { hasSuperCall = node . body . statements . some ( statement => { if ( statement . kind !== ts . SyntaxKind . ExpressionStatement ) { return false ; } const expressionStatement = statement as ts . ExpressionStatement ; if ( expressionStatement . expression . kind !== ts . SyntaxKind . CallExpression ) { return false ; } const callExpression = expressionStatement . expression as ts . CallExpression ; if ( callExpression . expression . kind !== ts . SyntaxKind . PropertyAccessExpression ) { return false ; } const propertyAccessExpression = callExpression . expression as ts . PropertyAccessExpression ; if ( propertyAccessExpression . expression . kind !== ts . SyntaxKind . SuperKeyword ) { return false ; } return this . _hasSuperCallForSameMethodName ( callExpression , methodName ) ; } ) ; } if ( ! hasSuperCall ) { const failureTemplate = this . _hasSuperCallForSameMethodName ( node , methodName ) ? MISSING_TOP_LEVEL_SUPER_CALL : MISSING_SUPER_CALL ; const failureString = failureTemplate . replace ( "s" , methodName ) ; this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , failureString ) ) ; } } private _hasSuperCallForSameMethodName ( node : ts . Node , methodName ) { const text = node . getText ( ) ; let match : RegExpExecArray | null ; while ( ( match = SUPER_REGEXP . exec ( text ) ) ) { if ( match [ 0 ] === methodName ) { SUPER_REGEXP . lastIndex = 0 ; return true ; } } return false ; } }	O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $RegExp$ O O O O O $any$ O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O $any$ O O O O $OverrideCallsSuperWalker$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $OverrideCallsSuperWalker$ O $void$ O $any$ O O O O O O $any$ O $OverrideCallsSuperWalker$ O O O O O $any$ O $any$ O O $string[]$ O O O O O O O O $void$ O $string$ O O O O $string[]$ O $number$ O $string$ O O O $void$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $string[]$ O $boolean$ O $any$ O O O O O $void$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $string$ O O O $boolean$ O O O O O $any$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O $any$ O $string$ O O O O O O O O O $boolean$ O O O O O O O $boolean$ O $any$ O $string$ O O O O O O O $string$ O O O $complex$ O O O $string$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O O O O O $boolean$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O O $RegExpExecArray$ O $any$ O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $any$ O O O O O O $RegExpExecArray$ O O O O $string$ O O $RegExp$ O $number$ O O O O O O O O O O O O O
import { StoreBase } from 's' ; import { isEqual , uniq } from 's' ; import { warnIfAutoSubscribeEnabled , autoSubscribeWithKey , AutoSubscribeStore , disableWarnings , autoSubscribe , key , } from 's' ; import { assert , formCompoundKey } from 's' ; export const enum TriggerKeys { First , Second } export type StoreData = number ; @ AutoSubscribeStore export class SimpleStore extends StoreBase { private _storeDataById : Record < string , StoreData > = { } ; private _subscribeWithKeyData = { A : 0 , B : 0 , } ; private _subscribeWithEnumKeyData = { [ TriggerKeys . First ] : 0 , [ TriggerKeys . Second ] : 0 , } ; @ autoSubscribe dangerousGetAllStoreDataMutable ( ) < string , StoreData > { return this . _storeDataById ; } @ autoSubscribe getStoreData ( @ key id ) { return this . _get ( id ) ; } @ autoSubscribeWithKey ( 's' ) getDataSingleKeyed ( ) { return this . _subscribeWithKeyData . A ; } @ autoSubscribeWithKey ( [ 's' , 's' ] ) getDataMultiKeyed ( ) { return this . _subscribeWithKeyData . A + this . _subscribeWithKeyData . B ; } @ autoSubscribeWithKey ( TriggerKeys . First ) getDataSingleEnumKeyed ( ) { return this . _subscribeWithEnumKeyData [ TriggerKeys . First ] ; } @ autoSubscribeWithKey ( [ TriggerKeys . First , TriggerKeys . Second ] ) getDataMultiEnumKeyed ( ) { return this . _subscribeWithEnumKeyData [ TriggerKeys . First ] + this . _subscribeWithEnumKeyData [ TriggerKeys . Second ] ; } @ autoSubscribeWithKey ( TriggerKeys . First ) getSingleKeySingleAutoSubKey ( @ key id ) { return this . _get ( id ) + this . _subscribeWithEnumKeyData [ TriggerKeys . First ] ; } @ autoSubscribeWithKey ( [ TriggerKeys . First , TriggerKeys . Second ] ) getSingleKeyMultiAutoSubKey ( @ key id ) { return this . _get ( id ) + this . _subscribeWithEnumKeyData [ TriggerKeys . First ] + this . _subscribeWithEnumKeyData [ TriggerKeys . Second ] ; } @ autoSubscribe getMultiKeyNoAutoSubKey ( @ key id , @ key 0 ) { return this . _get ( id ) + this . _get ( 0 ) ; } @ autoSubscribeWithKey ( TriggerKeys . First ) getMultiKeySingleAutoSubKey ( @ key id , @ key 0 ) { return this . _get ( id ) + this . _get ( 0 ) + this . _subscribeWithEnumKeyData [ TriggerKeys . First ] ; } @ autoSubscribeWithKey ( [ TriggerKeys . First , TriggerKeys . Second ] ) getMultiKeyMultiAutoSubKey ( @ key id , @ key 0 ) { return this . _get ( id ) + this . _get ( 0 ) + this . _subscribeWithEnumKeyData [ TriggerKeys . First ] + this . _subscribeWithEnumKeyData [ TriggerKeys . Second ] ; } setStoreDataForKeyedSubscription ( key : 's' | 's' , data ) { this . _subscribeWithKeyData [ key ] = data ; this . trigger ( key ) ; } setStoreDataForCompoundEnumKeyedSubscription ( idOrIds : string [ ] , key , data ) { this . _subscribeWithEnumKeyData [ key ] = data ; this . trigger ( formCompoundKey ( ... idOrIds , key ) ) ; } setStoreDataForEnumKeyedSubscription ( key , data ) { this . _subscribeWithEnumKeyData [ key ] = data ; this . trigger ( key ) ; } @ disableWarnings triggerArbitraryKey ( key : string | number | undefined ) { this . trigger ( key ) ; } clearStoreData ( ) { this . _storeDataById = { } ; } @ warnIfAutoSubscribeEnabled setStoreData ( id , triggerKey , storeData ) { this . _storeDataById [ id ] = storeData ; this . trigger ( triggerKey ) ; } @ disableWarnings protected _getSubscriptionKeys ( ) : string [ ] { const keys = super . _getSubscriptionKeys ( ) ; assert ( isEqual ( keys , uniq ( keys ) ) , 's' ) ; return keys ; } private _get ( id ) { return this . _storeDataById [ id ] ; } test_getSubscriptionKeys ( ) : string [ ] { return this . _getSubscriptionKeys ( ) ; } test_getSubscriptions ( ) { return ( this as any ) . _subscriptions ; } test_getAutoSubscriptions ( ) { return ( this as any ) . _autoSubscriptions ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $TypedPropertyDescriptor<T>$ O $MethodDecorator$ O $ClassDecorator$ O $TypedPropertyDescriptor<T>$ O $MethodDecorator$ O $void$ O O O O O O O $void$ O $string$ O O O O O O O $any$ O $TriggerKeys.First$ O $TriggerKeys.Second$ O O O $any$ O O O O $ClassDecorator$ O O $any$ O $any$ O O $complex$ O $any$ O O O $any$ O O O O O O $complex$ O O $number$ O O O $number$ O O O O O O $complex$ O O O $any$ O $TriggerKeys.First$ O O O O O $any$ O $TriggerKeys.Second$ O O O O O O O $MethodDecorator$ $Record$ O O O O O $any$ O O O O O $complex$ O O O $MethodDecorator$ $StoreData$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $MethodDecorator$ O O O $number$ O O O O O O $complex$ O $number$ O O O $MethodDecorator$ O O O O O O O $number$ O O O O O O $complex$ O $number$ O O O $complex$ O $number$ O O O $MethodDecorator$ O $any$ O $TriggerKeys.First$ O $number$ O O O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $MethodDecorator$ O O $any$ O $TriggerKeys.First$ O $any$ O $TriggerKeys.Second$ O O $number$ O O O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $complex$ O $any$ O $TriggerKeys.Second$ O O O O $MethodDecorator$ O $any$ O $TriggerKeys.First$ O $number$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $MethodDecorator$ O O $any$ O $TriggerKeys.First$ O $any$ O $TriggerKeys.Second$ O O $number$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $complex$ O $any$ O $TriggerKeys.Second$ O O O O $MethodDecorator$ $number$ O O $void$ $string$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $number$ O $string$ O O O O $MethodDecorator$ O $any$ O $TriggerKeys.First$ O $number$ O O $void$ $string$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $number$ O $string$ O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $MethodDecorator$ O O $any$ O $TriggerKeys.First$ O $any$ O $TriggerKeys.Second$ O O $number$ O O $void$ $string$ O O $void$ $string$ O O O O O $number$ O $string$ O O O O $number$ O $string$ O O O O $complex$ O $any$ O $TriggerKeys.First$ O O O O $complex$ O $any$ O $TriggerKeys.Second$ O O O $void$ O O O O O O O $number$ O O O O $complex$ O O O O $number$ O O O $void$ O O O O O $void$ O $string[]$ O O O O O $TriggerKeys$ O $number$ O O O O $complex$ O $TriggerKeys$ O O $number$ O O O $void$ O $string$ O O $string[]$ O $TriggerKeys$ O O O O $void$ O $TriggerKeys$ O $number$ O O O O $complex$ O $TriggerKeys$ O O $number$ O O O $void$ O $TriggerKeys$ O O O O $TypedPropertyDescriptor<T>$ $void$ O $complex$ O O O O O O O O O O $void$ O $complex$ O O O $void$ O O O O O $complex$ O O O O O O $TypedPropertyDescriptor<T>$ $void$ O $string$ O $string$ O $StoreData$ O O O O $complex$ O $string$ O O $number$ O O O $void$ O $string$ O O O O $TypedPropertyDescriptor<T>$ O $string[]$ O O O O O O O O $string[]$ O O O $string[]$ O O O $void$ O $any$ O $string[]$ O $any$ O $string[]$ O O O O O O O $string[]$ O O O $StoreData$ O $string$ O O O O O $complex$ O $string$ O O O $string[]$ O O O O O O O O O O $string[]$ O O O O $any$ O O O O O O O O O O $any$ O O $any$ O O O O O O O O O O $any$ O O O
import { StoreBase } from 's' ; import Options from 's' ; type TKeys = string [ ] | undefined ; class BraindeadStore extends StoreBase { Key_Something = 's' ; 0 = 's' ; foundAll = false ; allKeys : TKeys ; allSub ! : number ; foundKey = false ; keyKeys : TKeys ; keySub ! : number ; setupSubs ( ) { this . allSub = this . subscribe ( ( keys ) => { this . foundAll = true ; this . allKeys = keys ; } ) ; this . keySub = this . subscribe ( ( keys ) => { this . foundKey = true ; this . keyKeys = keys ; } , this . Key_Something ) ; } emitAll ( ) { this . trigger ( ) ; } emitSomething ( ) { this . trigger ( this . Key_Something ) ; } emitSomethings ( ) { this . trigger ( [ this . Key_Something , this . 0 ] ) ; } } class TriggerableStore extends StoreBase { emit ( keys : string [ ] ) { this . trigger ( keys ) ; } } describe ( 's' , function ( ) { beforeEach ( ( ) => { jasmine . clock ( ) . install ( ) ; jasmine . clock ( ) . mockDate ( new Date ( ) ) ; Options . setTimeout = setTimeout . bind ( null ) ; Options . clearTimeout = clearTimeout . bind ( null ) ; } ) ; afterEach ( ( ) => { jasmine . clock ( ) . uninstall ( ) ; Options . setTimeout = setTimeout . bind ( null ) ; Options . clearTimeout = clearTimeout . bind ( null ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( 0 , false ) ; store . setupSubs ( ) ; store . emitAll ( ) ; expect ( store . foundAll && store . foundKey ) . toBeTruthy ( ) ; expect < TKeys > ( store . allKeys ) . toBeUndefined ( ) ; expect < TKeys > ( store . keyKeys ) . toBeUndefined ( ) ; store . foundAll = store . foundKey = false ; store . allKeys = store . keyKeys = undefined ; store . emitSomething ( ) ; expect < TKeys > ( store . allKeys ) . toEqual ( [ store . Key_Something ] ) ; expect < TKeys > ( store . keyKeys ) . toEqual ( [ store . Key_Something ] ) ; expect ( store . foundAll && store . foundKey ) . toBeTruthy ( ) ; store . foundAll = store . foundKey = false ; store . allKeys = store . keyKeys = undefined ; store . emitSomethings ( ) ; expect < TKeys > ( store . allKeys ) . toEqual ( [ store . Key_Something , store . 0 ] ) ; expect < TKeys > ( store . keyKeys ) . toEqual ( [ store . Key_Something ] ) ; expect ( store . foundAll && store . foundKey ) . toBeTruthy ( ) ; expect ( store . foundAll && store . foundKey ) . toBeTruthy ( ) ; store . foundAll = store . foundKey = false ; store . allKeys = store . keyKeys = undefined ; StoreBase . pushTriggerBlock ( ) ; store . emitAll ( ) ; store . emitSomething ( ) ; store . emitSomethings ( ) ; expect ( ! store . foundAll && ! store . foundKey ) . toBeTruthy ( ) ; StoreBase . popTriggerBlock ( ) ; expect < TKeys > ( store . allKeys ) . toBeUndefined ( ) ; expect < TKeys > ( store . keyKeys ) . toBeUndefined ( ) ; expect ( store . foundAll && store . foundKey ) . toBeTruthy ( ) ; store . foundAll = store . foundKey = false ; store . allKeys = store . keyKeys = undefined ; store . unsubscribe ( store . allSub ) ; store . emitAll ( ) ; expect ( ! store . foundAll && store . foundKey ) . toBeTruthy ( ) ; store . foundAll = store . foundKey = false ; store . allKeys = store . keyKeys = undefined ; store . unsubscribe ( store . keySub ) ; store . emitSomething ( ) ; expect ( ! store . foundAll && ! store . foundKey ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( 0 , true ) ; store . setupSubs ( ) ; store . emitAll ( ) ; expect ( store . foundAll ) . toBeTruthy ( ) ; expect < TKeys > ( store . allKeys ) . toBeUndefined ( ) ; store . foundAll = false ; store . allKeys = undefined ; StoreBase . pushTriggerBlock ( ) ; store . emitAll ( ) ; expect ( store . foundAll ) . toBeTruthy ( ) ; expect < TKeys > ( store . allKeys ) . toBeUndefined ( ) ; store . foundAll = false ; store . allKeys = undefined ; StoreBase . popTriggerBlock ( ) ; expect ( store . foundAll ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( 0 , false ) ; store . setupSubs ( ) ; store . emitAll ( ) ; expect ( store . foundAll ) . toBeFalsy ( ) ; jasmine . clock ( ) . tick ( 0 ) ; expect ( store . foundAll ) . toBe ( false ) ; jasmine . clock ( ) . tick ( 0 ) ; expect ( store . foundAll ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( ) ; let 0 = 0 ; const 0 = store . subscribe ( ( ) => { 0 ++ ; store . unsubscribe ( 0 ) ; store . emitAll ( ) ; } ) ; let 0 = 0 ; const 0 = store . subscribe ( ( ) => { 0 ++ ; store . unsubscribe ( 0 ) ; store . emitAll ( ) ; } ) ; store . emitAll ( ) ; expect ( 0 ) . toEqual ( 0 ) ; expect ( 0 ) . toEqual ( 0 ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( 0 , false ) ; let callbackCount = 0 ; const subCallback = ( ) : void => { callbackCount ++ ; } ; store . subscribe ( subCallback , store . Key_Something ) ; store . subscribe ( subCallback , store . 0 ) ; store . subscribe ( subCallback ) ; store . emitSomething ( ) ; store . emitSomethings ( ) ; store . emitAll ( ) ; expect ( callbackCount ) . toBe ( 0 ) ; jasmine . clock ( ) . tick ( 0 ) ; expect ( callbackCount ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { let store = new BraindeadStore ( 0 , false ) ; let 0 = new BraindeadStore ( 0 , false ) ; let callbackCount = 0 ; const subCallback = ( keys ? : string [ ] ) : void => { expect ( keys ) . toEqual ( [ 's' , 's' ] ) ; callbackCount ++ ; } ; store . subscribe ( subCallback , store . Key_Something ) ; store . subscribe ( subCallback , store . 0 ) ; store . subscribe ( subCallback ) ; 0 . subscribe ( subCallback ) ; expect ( callbackCount ) . toBe ( 0 ) ; store . emitSomethings ( ) ; 0 . emitSomething ( ) ; expect ( callbackCount ) . toBe ( 0 ) ; jasmine . clock ( ) . tick ( 0 ) ; expect ( callbackCount ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { let store = new TriggerableStore ( ) ; let callbackCalled = false ; const subCallback = ( keys ? : string [ ] ) : void => { expect ( keys ! ! ! . length ) . toEqual ( 0 ) ; callbackCalled = true ; } ; store . subscribe ( subCallback ) ; StoreBase . pushTriggerBlock ( ) ; store . emit ( [ 's' ] ) ; let keysToTrigger : string [ ] = [ ] ; for ( let i = 0 ; i < 0 ; i ++ ) { keysToTrigger . push ( i . toString ( ) ) ; } store . emit ( keysToTrigger ) ; StoreBase . popTriggerBlock ( ) ; expect ( callbackCalled ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O $IOptions$ O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $boolean$ O O O $string[]$ O $any$ O $number$ O O O O $boolean$ O O O $string[]$ O $any$ O $number$ O O O O $void$ O O O O O $number$ O O O $number$ O O $TKeys$ O O O O O $boolean$ O O O O O $string[]$ O $string[]$ O O O O O O $number$ O O O $number$ O O $TKeys$ O O O O O $boolean$ O O O O O $string[]$ O $string[]$ O O O O O $string$ O O O $void$ O O O O O $void$ O O O O $void$ O O O O O $void$ O O O $string$ O O O $void$ O O O O O $void$ O O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $void$ O $string[]$ O O O O O O O O $void$ O $string[]$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O $DateConstructor$ O O O O $IOptions$ O $number$ O $number$ O $any$ O O O O $IOptions$ O $void$ O $void$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O $IOptions$ O $number$ O $number$ O $any$ O O O O $IOptions$ O $void$ O $void$ O $any$ O O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O $any$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $BraindeadStore$ O $string[]$ O $undefined$ O $BraindeadStore$ O $void$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O $BraindeadStore$ O $string$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O $BraindeadStore$ O $string$ O O O $any$ O $BraindeadStore$ O $false$ O $BraindeadStore$ O $false$ O O $any$ O O O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $BraindeadStore$ O $string[]$ O $undefined$ O $BraindeadStore$ O $void$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O $BraindeadStore$ O $string$ O $BraindeadStore$ O $string$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O $BraindeadStore$ O $string$ O O O $any$ O $BraindeadStore$ O $false$ O $BraindeadStore$ O $false$ O O $any$ O O O $any$ O $BraindeadStore$ O $false$ O $BraindeadStore$ O $false$ O O $any$ O O O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $BraindeadStore$ O $string[]$ O $undefined$ O $any$ O $void$ O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O O $BraindeadStore$ O $false$ O O $BraindeadStore$ O $false$ O O $any$ O O O $any$ O $void$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $any$ O $BraindeadStore$ O $false$ O $BraindeadStore$ O $false$ O O $any$ O O O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $BraindeadStore$ O $string[]$ O $undefined$ O $BraindeadStore$ O $void$ O $BraindeadStore$ O $number$ O O $BraindeadStore$ O $void$ O O O $any$ O O $BraindeadStore$ O $false$ O $BraindeadStore$ O $false$ O O $any$ O O O $BraindeadStore$ O $boolean$ O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $BraindeadStore$ O $string[]$ O $undefined$ O $BraindeadStore$ O $void$ O $BraindeadStore$ O $number$ O O $BraindeadStore$ O $void$ O O O $any$ O O $BraindeadStore$ O $false$ O O $BraindeadStore$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $BraindeadStore$ O $boolean$ O O $any$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $undefined$ O $any$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $BraindeadStore$ O $false$ O O $any$ O O O $any$ O $any$ O O $BraindeadStore$ O $string[]$ O O $any$ O O O $BraindeadStore$ O $boolean$ O O O $BraindeadStore$ O $string[]$ O $undefined$ O $any$ O $void$ O O O $any$ O $BraindeadStore$ O $false$ O O $any$ O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $BraindeadStore$ O $boolean$ O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O $BraindeadStore$ O $boolean$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $BraindeadStore$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O $number$ O O O O $number$ O $BraindeadStore$ O $number$ O O O O O $number$ O O $BraindeadStore$ O $void$ O $number$ O O $BraindeadStore$ O $void$ O O O O O O O $number$ O O O O $number$ O $BraindeadStore$ O $number$ O O O O O $number$ O O $BraindeadStore$ O $void$ O $number$ O O $BraindeadStore$ O $void$ O O O O O O $BraindeadStore$ O $void$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O O O O $number$ O O O O $void$ O O O O O O O $number$ O O O O $BraindeadStore$ O $number$ O $void$ O $BraindeadStore$ O $string$ O O $BraindeadStore$ O $number$ O $void$ O $BraindeadStore$ O $string$ O O $BraindeadStore$ O $number$ O $void$ O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $BraindeadStore$ O O $any$ O O O O O O O $BraindeadStore$ O O $any$ O O O O O O O $number$ O O O O $void$ O O $string[]$ O O O O O O O O O O $any$ O $string[]$ O O $any$ O O O O O O O O $number$ O O O O $BraindeadStore$ O $number$ O $void$ O $BraindeadStore$ O $string$ O O $BraindeadStore$ O $number$ O $void$ O $BraindeadStore$ O $string$ O O $BraindeadStore$ O $number$ O $void$ O O $BraindeadStore$ O $number$ O $void$ O O $any$ O $number$ O O $any$ O O O O $BraindeadStore$ O $void$ O O O $BraindeadStore$ O $void$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $TriggerableStore$ O O $any$ O O O O $boolean$ O O O O $void$ O O $string[]$ O O O O O O O O O O $any$ O $string[]$ O O O O $number$ O O $any$ O O O O $boolean$ O O O O O $TriggerableStore$ O $number$ O $void$ O O $any$ O $void$ O O O $TriggerableStore$ O $void$ O O O O O O O $string[]$ O O O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O $string[]$ O $number$ O $number$ O $string$ O O O O O $TriggerableStore$ O $void$ O $string[]$ O O $any$ O $void$ O O O $any$ O $false$ O O $any$ O O O O O O O O O