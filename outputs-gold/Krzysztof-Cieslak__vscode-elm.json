import * as cp from 's' ; import * as fs from 's' ; import * as path from 's' ; import * as vscode from 's' ; import { window , workspace } from 's' ; export const isWindows = process . platform === 's' ; export interface ExecCmdOptions { fileName ? : string ; cmdArguments ? : string [ ] ; showMessageOnError ? : boolean ; onStart ? : ( ) => void ; onStdout ? : ( data ) => void ; onStderr ? : ( data ) => void ; onExit ? : ( ) => void ; notFoundText ? : string ; } export interface ExecutingCmd extends Promise < { stdout : string ; stderr : string } > { stdin : NodeJS . WritableStream ; kill ( ) ; isRunning : boolean ; } export function execCmd ( cmd , options = { } , ) { const { fileName , onStart , onStdout , onStderr , onExit , cmdArguments , } = options ; let childProcess , firstResponse = true , wasKilledbyUs = false ; const executingCmd = new Promise ( ( resolve , reject ) => { let cmdArguments = options ? options . cmdArguments : [ ] ; const dummyPath = path . join ( vscode . workspace . rootPath , 's' ) ; const [ cwdCurrent , _ ] = detectProjectRootAndElmVersion ( fileName || dummyPath , workspace . rootPath , ) ; const fullCommand = cmd + 's' + ( cmdArguments || [ ] ) . join ( 's' ) ; childProcess = cp . exec ( fullCommand , { cwd : cwdCurrent } , handleExit ) ; childProcess . stdout . on ( 's' , ( data ) => { if ( firstResponse && onStart ) { onStart ( ) ; } firstResponse = false ; if ( onStdout ) { onStdout ( data . toString ( ) ) ; } } ) ; childProcess . stderr . on ( 's' , ( data ) => { if ( firstResponse && onStart ) { onStart ( ) ; } firstResponse = false ; if ( onStderr ) { onStderr ( data . toString ( ) ) ; } } ) ; function handleExit ( err , stdout , stderr ) { executingCmd . isRunning = false ; if ( onExit ) { onExit ( ) ; } if ( ! wasKilledbyUs ) { if ( err ) { if ( options . showMessageOnError ) { const cmdName = cmd . split ( 's' , 0 ) [ 0 ] ; const cmdWasNotFound = ( isWindows && err . message . includes ( `template` ) ) || ( ! isWindows && ( < any > err ) . code === 0 ) ; if ( cmdWasNotFound ) { let notFoundText = options ? options . notFoundText : 's' ; window . showErrorMessage ( `template` + notFoundText , ) ; } else { window . showErrorMessage ( err . message ) ; } } else { reject ( err ) ; } } else { resolve ( { stdout : stdout , stderr : stderr } ) ; } } } } ) ; executingCmd . stdin = childProcess . stdin ; executingCmd . kill = killProcess ; executingCmd . isRunning = true ; return executingCmd as ExecutingCmd ; function killProcess ( ) { wasKilledbyUs = true ; if ( isWindows ) { cp . spawn ( 's' , [ 's' , childProcess . pid . toString ( ) , 's' , 's' ] ) ; } else { childProcess . kill ( 's' ) ; } } } export function findProjAndElmVersion ( dir ) : [ string , string ] { if ( fs . lstatSync ( dir ) . isDirectory ( ) ) { const files = fs . readdirSync ( dir ) ; const 0 = files . find ( ( v , i ) => v === 's' ) ; const 0 = files . find ( ( v , i ) => v === 's' ) ; if ( 0 !== undefined ) { return [ dir + path . sep + 0 , 's' ] ; } if ( 0 !== undefined ) { return [ dir + path . sep + 0 , 's' ] ; } let parent = 's' ; if ( dir . lastIndexOf ( path . sep ) > 0 ) { parent = dir . substr ( 0 , dir . lastIndexOf ( path . sep ) ) ; } if ( parent === 's' ) { return [ 's' , 's' ] ; } else { return findProjAndElmVersion ( parent ) ; } } } export function findProj ( dir ) { if ( fs . lstatSync ( dir ) . isDirectory ( ) ) { const files = fs . readdirSync ( dir ) ; const file = files . find ( ( v , i ) => v === 's' || v === 's' , ) ; if ( file !== undefined ) { return dir + path . sep + file ; } let parent = 's' ; if ( dir . lastIndexOf ( path . sep ) > 0 ) { parent = dir . substr ( 0 , dir . lastIndexOf ( path . sep ) ) ; } if ( parent === 's' ) { return 's' ; } else { return findProj ( parent ) ; } } } export function detectProjectRootAndElmVersion ( fileName , workspaceRootPath , ) : [ string , string ] { const proj = findProjAndElmVersion ( path . dirname ( fileName ) ) ; if ( proj [ 0 ] !== 's' ) { return [ path . dirname ( proj [ 0 ] ) , proj [ 0 ] ] ; } return [ workspaceRootPath , 's' ] ; } export function detectProjectRoot ( fileName ) { const proj = findProj ( path . dirname ( fileName ) ) ; if ( proj !== 's' ) { return path . dirname ( proj ) ; } return undefined ; } export function 0 ( elmVersion ) { return elmVersion === 's' ? true : false ; } export function getIndicesOf ( searchStr , str ) : number [ ] { let startIndex = 0 , searchStrLen = searchStr . length ; let index , indices = [ ] ; while ( ( index = str . indexOf ( searchStr , startIndex ) ) > - 0 ) { indices . push ( index ) ; startIndex = index + searchStrLen ; } return indices ; } function isPowershell ( ) { try { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const t = < string > config . get ( 's' ) ; return t . toLowerCase ( ) . includes ( 's' ) ; } catch ( error ) { return false ; } } export function getTerminalLaunchCommands ( command ) : [ string , string ] { if ( isWindows ) { if ( isPowershell ( ) ) { return [ `template` , 's' ] ; } else { return [ `template` , 's' ] ; } } else { return [ command , 's' ] ; } } export const pluginPath = vscode . extensions . getExtension ( 's' ) . extensionPath ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExecutingCmd$ O $string$ O $ExecCmdOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as utils from 's' ; import * as vscode from 's' ; import * as path from 's' ; export function fileIsTestFile ( filename ) { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const testMatcher = < string > ( config . get ( 's' ) ) ; const [ _ , elmVersion ] = utils . detectProjectRootAndElmVersion ( filename , vscode . workspace . rootPath , ) ; if ( utils . 0 ( elmVersion ) === false ) { return false ; } const pathFromRoot = path . relative ( vscode . workspace . rootPath , filename ) ; const pathParts = path . parse ( pathFromRoot ) ; const pathNormalized = path . posix . format ( pathParts ) ; const testMatcherParts = path . parse ( testMatcher ) ; const testMatcherNormalized = path . posix . format ( testMatcherParts ) ; const isTestFile = pathNormalized . includes ( testMatcherNormalized ) ; return isTestFile ; }	O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cp from 's' ; import * as readline from 's' ; import * as path from 's' ; import * as utils from 's' ; import * as vscode from 's' ; import * as elmTest from 's' ; import { ElmAnalyse } from 's' ; export interface IElmIssueRegion { start : { line : number ; column : number } ; end : { line : number ; column : number } ; } export interface IElmIssue { tag : string ; overview : string ; subregion : string ; details : string ; region : IElmIssueRegion ; type : string ; file : string ; } function severityStringToDiagnosticSeverity ( severity , ) : vscode . DiagnosticSeverity { switch ( severity ) { case 's' : return vscode . DiagnosticSeverity . Error ; case 's' : return vscode . DiagnosticSeverity . Warning ; default : return vscode . DiagnosticSeverity . Error ; } } function elmMakeIssueToDiagnostic ( issue ) : vscode . Diagnostic { let lineRange : vscode . Range = new vscode . Range ( issue . region . start . line - 0 , issue . region . start . column - 0 , issue . region . end . line - 0 , issue . region . end . column - 0 , ) ; return new vscode . Diagnostic ( lineRange , issue . overview + 's' + issue . details . replace ( "s" , 's' ) , severityStringToDiagnosticSeverity ( issue . type ) , ) ; } function 0 ( line ) { const returnLines = [ ] ; const errorObject = JSON . parse ( line ) ; if ( errorObject . type === 's' ) { errorObject . errors . forEach ( error => { const problems = error . problems . map ( problem => ( { tag : 's' , overview : problem . title , subregion : 's' , details : problem . message . map ( message => typeof message === 's' ? message : 's' + message . string + 's' , ) . join ( 's' ) , region : problem . region , type : 's' , file : error . path , } ) ) ; returnLines . push ( ... problems ) ; } ) ; } else if ( errorObject . type === 's' ) { const problem = { tag : 's' , overview : errorObject . title , subregion : 's' , details : errorObject . message . map ( message => ( typeof message === 's' ? message : message . string ) , ) . join ( 's' ) , region : { start : { line : 0 , column : 0 , } , end : { line : 0 , column : 0 , } , } , type : 's' , file : errorObject . path , } ; returnLines . push ( problem ) ; } return returnLines ; } function 0 ( line ) { if ( line . startsWith ( 's' ) ) { return [ ] ; } return < IElmIssue [ ] > JSON . parse ( line ) ; } function checkForErrors ( fullFilename ) < IElmIssue [ ] > { return new Promise ( ( resolve , reject ) => { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const 0 = < string > config . get ( 's' ) ; const compiler = < string > config . get ( 's' ) ; const elmTestCompiler = < string > config . get ( 's' ) ; const [ cwd , elmVersion ] = utils . detectProjectRootAndElmVersion ( fullFilename , vscode . workspace . rootPath , ) ; const specialFile = < string > config . get ( 's' ) ; const isTestFile = elmTest . fileIsTestFile ( fullFilename ) ; let make ; let filename = path . relative ( cwd , fullFilename ) ; if ( specialFile . length > 0 ) { filename = path . resolve ( cwd , specialFile ) ; } if ( utils . isWindows ) { filename = 's' + filename + 's' ; } const 0 = [ filename , 's' , 's' , 's' , 's' ] ; const 0 = [ 's' , filename , 's' , 's' , 's' , 's' , ] ; const args = utils . 0 ( elmVersion ) ? 0 : 0 ; const makeCommand = utils . 0 ( elmVersion ) ? isTestFile ? elmTestCompiler : compiler : 0 ; if ( utils . isWindows ) { make = cp . exec ( makeCommand + 's' + args . join ( 's' ) , { cwd : cwd } ) ; } else { make = cp . spawn ( makeCommand , args , { cwd : cwd } ) ; } const errorLinesFromElmMake = readline . createInterface ( { input : utils . 0 ( elmVersion ) ? make . stderr : make . stdout , output : undefined , } ) ; const lines = [ ] ; const 0 : Buffer [ ] = [ ] ; errorLinesFromElmMake . on ( 's' , line => { if ( utils . 0 ( elmVersion ) ) { const newLines = 0 ( line ) ; newLines . forEach ( l => lines . push ( l ) ) ; } else { const newLines = 0 ( line ) ; newLines . forEach ( l => lines . push ( l ) ) ; } } ) ; if ( utils . 0 ( elmVersion ) === false ) { make . stderr . on ( 's' , ( data ) => { if ( data ) { 0 . push ( data ) ; } } ) ; } make . on ( 's' , err => { errorLinesFromElmMake . close ( ) ; if ( err && err . code === 's' ) { vscode . window . showInformationMessage ( `template` , ) ; resolve ( [ ] ) ; } else { reject ( err ) ; } } ) ; make . on ( 's' , ( code , signal ) => { errorLinesFromElmMake . close ( ) ; if ( 0 . length ) { let errorResult = { tag : 's' , overview : 's' , subregion : 's' , details : 0 . join ( 's' ) , region : { start : { line : 0 , column : 0 , } , end : { line : 0 , column : 0 , } , } , type : 's' , file : filename , } ; resolve ( [ errorResult ] ) ; } else { resolve ( lines ) ; } } ) ; } ) ; } let compileErrors : vscode . DiagnosticCollection ; export function runLinter ( document : vscode . TextDocument , elmAnalyse , ) { if ( document . languageId !== 's' || document . uri . scheme !== 's' ) { return ; } let uri : vscode . Uri = document . uri ; if ( ! compileErrors ) { compileErrors = vscode . languages . createDiagnosticCollection ( 's' ) ; } else { compileErrors . clear ( ) ; } checkForErrors ( uri . fsPath ) . then ( ( compilerErrors : IElmIssue [ ] ) => { const cwd = utils . detectProjectRoot ( uri . fsPath ) || vscode . workspace . rootPath ; let splitCompilerErrors < string , IElmIssue [ ] > = new Map ( ) ; compilerErrors . forEach ( ( issue ) => { if ( issue . file . startsWith ( 's' ) ) { issue . file = cwd + issue . file . slice ( 0 ) ; } if ( splitCompilerErrors . has ( issue . file ) ) { splitCompilerErrors . get ( issue . file ) . push ( issue ) ; } else { splitCompilerErrors . set ( issue . file , [ issue ] ) ; } } ) ; splitCompilerErrors . forEach ( ( issue : IElmIssue [ ] , issuePath ) => { compileErrors . set ( vscode . Uri . file ( issuePath ) , issue . map ( error => elmMakeIssueToDiagnostic ( error ) ) , ) ; } ) ; } ) . catch ( error => { compileErrors . set ( document . uri , [ ] ) ; } ) ; if ( elmAnalyse . elmAnalyseIssues . length > 0 ) { let splitCompilerErrors < string , IElmIssue [ ] > = new Map ( ) ; elmAnalyse . elmAnalyseIssues . forEach ( ( issue ) => { if ( splitCompilerErrors . has ( issue . file ) ) { splitCompilerErrors . get ( issue . file ) . push ( issue ) ; } else { splitCompilerErrors . set ( issue . file , [ issue ] ) ; } splitCompilerErrors . forEach ( ( analyserIssue : IElmIssue [ ] , issuePath ) => { compileErrors . set ( vscode . Uri . file ( issuePath ) , analyserIssue . map ( error => elmMakeIssueToDiagnostic ( error ) ) , ) ; } , ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmIssue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmIssue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O $ElmAnalyse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $Map$ O O O O O O O O O O O O O O O O O O $IElmIssue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Map$ O O O O O O O O O O O O O O O O O O O O $IElmIssue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import * as vscode from 's' ; import { IElmIssue , IElmIssueRegion , runLinter } from 's' ; import { detectProjectRootAndElmVersion , execCmd , ExecutingCmd } from 's' ; import WebSocket = require ( 's' ) ; const request = require ( 's' ) ; enum ElmAnalyseServerState { NotRunning = 0 , PortInUse , Running , } interface IElmAnalyseMessage { type : string ; file : string ; data : IElmAnalyseMessageData ; } interface IElmAnalyseMessageData { description : string ; properties : | { range : number [ ] } | { 0 : number [ ] ; 0 : number [ ] } | { ranges : number [ ] [ ] } ; } interface IElmAnalyseMessageParseResult { success : boolean ; reason : string ; messageType : string ; } export class ElmAnalyse { private statusBarStopButton : vscode . StatusBarItem ; private statusBarInformation : vscode . StatusBarItem ; private analyseSocket : WebSocket ; private analyse : ExecutingCmd ; private updateLinterInterval ; private unprocessedMessage = false ; private cwd : string ; private version : string ; private oc : vscode . OutputChannel = vscode . window . createOutputChannel ( 's' , ) ; public constructor ( public elmAnalyseIssues : IElmIssue [ ] ) { this . statusBarStopButton = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , ) ; this . statusBarInformation = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , ) ; this . statusBarStopButton . text = 's' + 's' ; this . statusBarStopButton . command = 's' ; this . statusBarStopButton . tooltip = 's' ; this . analyse = { } as ExecutingCmd ; const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const enabledOnStartup = < boolean > config . get ( 's' ) ; if ( enabledOnStartup ) { this . execActivateAnalyseProcesses ( ) ; } } public activateAnalyse ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerTextEditorCommand ( 's' , ( ) => this . execActivateAnalyseProcesses ( ) , ) , vscode . commands . registerCommand ( 's' , ( ) => this . execStopAnalyse ( true ) , ) , ] ; } public deactivateAnalyse ( ) { this . execStopAnalyse ( false ) ; } private initSocketClient ( ) { try { const cwd = vscode . workspace . rootPath ; const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const port = < string > config . get ( 's' ) ; const wsPath = 's' + port + 's' ; if ( this . analyseSocket ) { this . analyseSocket . close ( ) ; } this . analyseSocket = new WebSocket ( wsPath ) ; this . analyseSocket . on ( 's' , ( ) => { this . analyseSocket . send ( 's' ) ; this . statusBarInformation . text = 's' + port ; } ) ; this . analyseSocket . on ( 's' , stateJson => { try { this . elmAnalyseIssues = [ ] ; const state = JSON . parse ( stateJson ) ; const messages : IElmAnalyseMessage [ ] = state . messages ; let failedMessages = messages . map ( message => this . parseMessage ( cwd , message ) ) . filter ( result => ! result . success ) ; if ( failedMessages . length > 0 ) { let items = failedMessages . map ( result => "s" + result . messageType + "s" + result . reason , ) ; let messageText = items . length + 's' + messages . length + 's' ; vscode . window . showErrorMessage ( messageText , 's' ) . then ( item => { if ( item === 's' ) { vscode . window . showErrorMessage ( messageText + 's' + items . join ( 's' ) , ) ; } } ) ; } this . unprocessedMessage = true ; } catch ( e ) { vscode . window . showErrorMessage ( 's' , ) ; } } ) ; this . analyseSocket . on ( 's' , e => { vscode . window . showErrorMessage ( 's' , ) ; } ) ; } catch ( e ) { vscode . window . showErrorMessage ( 's' , ) ; } } private parseMessage ( cwd , message , ) { function generateError ( reason ) { return { success : false , reason : reason , messageType : message . type || null , } ; } function generateMissingError ( path ) { return generateError ( path + 's' ) ; } try { if ( ! message . hasOwnProperty ( 's' ) ) { return generateMissingError ( 's' ) ; } if ( ! message . hasOwnProperty ( 's' ) ) { return generateMissingError ( 's' ) ; } if ( ! message . hasOwnProperty ( 's' ) ) { return generateMissingError ( 's' ) ; } if ( ! message . data . hasOwnProperty ( 's' ) ) { return generateMissingError ( 's' ) ; } if ( ! message . data . hasOwnProperty ( 's' ) ) { return generateMissingError ( 's' ) ; } const messageInfoFileRegions = this . parseMessageInfoFileRanges ( message . data , ) . map ( this . convertRangeToRegion ) ; messageInfoFileRegions . forEach ( messageInfoFileRegion => { const issue = { tag : 's' , overview : message . type , subregion : 's' , details : message . data . description , region : messageInfoFileRegion , type : 's' , file : path . join ( this . cwd , message . file ) , } ; this . elmAnalyseIssues . push ( issue ) ; } ) ; return { success : true , reason : null , messageType : null } ; } catch ( e ) { return generateError ( 's' ) ; } } private parseMessageInfoFileRanges ( messageInfoData ) { let messageInfoFileRanges : number [ ] [ ] ; let messageInfoProperties = < any > messageInfoData . properties ; if ( messageInfoProperties . hasOwnProperty ( 's' ) ) { messageInfoFileRanges = [ messageInfoProperties . range ] ; } else if ( messageInfoProperties . hasOwnProperty ( 's' ) && messageInfoProperties . hasOwnProperty ( 's' ) ) { messageInfoFileRanges = [ messageInfoProperties . 0 , messageInfoProperties . 0 , ] ; } else if ( messageInfoProperties . hasOwnProperty ( 's' ) ) { messageInfoFileRanges = messageInfoProperties . ranges ; } else { messageInfoFileRanges = [ [ 0 , 0 , 0 , 0 ] ] ; } return messageInfoFileRanges ; } private convertRangeToRegion ( range : number [ ] ) { return { start : { line : range [ 0 ] , column : range [ 0 ] , } , end : { line : range [ 0 ] , column : range [ 0 ] , } , } ; } private startAnalyseProcess ( analyseCommand , analysePort , fileName , forceRestart = false , ) < boolean > { const [ cwdCurrent , version ] = detectProjectRootAndElmVersion ( fileName , vscode . workspace . rootPath , ) ; this . cwd = cwdCurrent ; this . version = version ; if ( this . analyse . isRunning ) { vscode . window . showErrorMessage ( 's' , ) ; return Promise . resolve ( false ) ; } return checkElmAnalyseServerState ( analysePort ) . then ( state => { if ( state === ElmAnalyseServerState . Running ) { return true ; } else if ( state === ElmAnalyseServerState . PortInUse ) { vscode . window . showErrorMessage ( 's' , ) ; return false ; } else { this . analyse = execCmd ( analyseCommand , { fileName : fileName , cmdArguments : [ 's' , 's' , analysePort ] , showMessageOnError : true , onStart : ( ) => this . analyse . stdin . write . bind ( this . analyse . stdin ) , onStdout => { if ( data ) { let info = data . toString ( ) ; this . oc . append ( info ) ; } } , onStderr => { if ( data ) { this . oc . append ( data . toString ( ) ) ; } } , notFoundText : 's' , } ) ; this . oc . show ( vscode . ViewColumn . Three ) ; return true ; } } ) ; } private execActivateAnalyseProcesses ( ) { let editor = vscode . window . activeTextEditor ; if ( editor . document . languageId !== 's' ) { return ; } try { const cwd = vscode . workspace . rootPath ; const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const analyseCommand = < string > config . get ( 's' ) ; const analysePort = < string > config . get ( 's' ) ; this . startAnalyseProcess ( analyseCommand , analysePort , editor . document . fileName , ) . then ( processReady => { if ( processReady ) { this . statusBarInformation . text = 's' ; this . statusBarInformation . show ( ) ; setTimeout ( ( ) => { this . initSocketClient ( ) ; this . updateLinterInterval = setInterval ( ( ) => this . updateLinter ( ) , 0 , ) ; } , 0 ) ; } } ) ; } catch ( e ) { console . error ( 's' , e ) ; vscode . window . showErrorMessage ( 's' ) ; } } private execStopAnalyse ( notify ) { this . elmAnalyseIssues = [ ] ; if ( this . analyse . isRunning ) { this . analyse . kill ( ) ; if ( this . analyseSocket ) { this . analyseSocket . removeAllListeners ( ) ; this . analyseSocket . close ( ) ; } this . updateLinterInterval = clearInterval ( this . updateLinterInterval ) ; this . statusBarStopButton . hide ( ) ; this . statusBarInformation . hide ( ) ; this . oc . clear ( ) ; if ( notify ) { this . oc . appendLine ( 's' ) ; } this . oc . dispose ( ) ; } else { if ( notify ) { vscode . window . showErrorMessage ( 's' , ) ; } } } private updateLinter ( ) { if ( this . unprocessedMessage ) { runLinter ( vscode . window . activeTextEditor . document , this ) ; this . unprocessedMessage = false ; } } } function checkElmAnalyseServerState ( port , ) < ElmAnalyseServerState > { let result = getElmAnalyseServerInfo ( 's' + port ) . then ( info => { if ( info . match ( "s" ) ) { return ElmAnalyseServerState . Running ; } else { return ElmAnalyseServerState . PortInUse ; } } , err => { return ElmAnalyseServerState . NotRunning ; } , ) ; return result ; } function getElmAnalyseServerInfo ( url ) < any > { const titleRegex = "s" ; return new Promise ( ( resolve , reject ) => { request ( url , ( err , _ , body ) => { if ( err ) { reject ( err ) ; } else { let info = 's' ; try { const match = titleRegex . exec ( body ) ; if ( match && match [ 0 ] ) { console . log ( match [ 0 ] ) ; info = match [ 0 ] ; } } catch ( e ) { reject ( e ) ; } resolve ( info ) ; } } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmAnalyseMessageParseResult$ O $string$ O $IElmAnalyseMessage$ O O O O $IElmAnalyseMessageParseResult$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $IElmAnalyseMessageParseResult$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmIssue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmAnalyseMessageData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IElmIssueRegion$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $data$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $data$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; import * as path from 's' ; import * as vscode from 's' ; import { IOracleResult , OracleAction } from 's' ; import { detectProjectRoot , detectProjectRootAndElmVersion } from 's' ; interface Imports { module : string ; exposing : string [ ] ; filePath ? : string ; } const config = vscode . workspace . getConfiguration ( 's' ) ; let gSrcDirs = [ ] ; let gCwd = 's' ; let gImports = [ ] ; let gOriginalWord = 's' ; let gAllModules : Imports [ ] = [ ] ; function exposingList ( exposing ) : string [ ] { const separated = exposing . split ( 's' ) ; if ( separated . length === 0 ) { return [ exposing ] ; } else { return separated ; } } function toLowerOrHover ( action , text ) { return action === OracleAction . IsAutocomplete ? text . toLowerCase ( ) : text ; } function buildModulePaths ( fullDirPath ) : Imports [ ] { let modulePaths : Imports [ ] = [ ] ; fs . readdirSync ( fullDirPath ) . forEach ( file => { let stats = fs . statSync ( path . join ( fullDirPath , file ) ) ; if ( stats . isDirectory ( ) ) { modulePaths = [ ... modulePaths , ... buildModulePaths ( path . join ( fullDirPath , file ) ) , ] ; } else if ( file . substr ( - 0 ) === 's' ) { let fullText = fs . readFileSync ( path . join ( fullDirPath , file ) , 's' ) ; const lines : string [ ] = fullText . split ( "s" ) ; for ( let i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . match ( "s" ) ) { modulePaths . push ( { module : lines [ i ] . split ( 's' ) [ 0 ] , filePath : path . join ( fullDirPath , file ) , exposing : [ ] , } ) ; break ; } } } } ) ; return modulePaths ; } function getModuleNames ( cwd , srcDirs : string [ ] ) : Imports [ ] { let modulePaths : Imports [ ] = [ ] ; try { srcDirs . forEach ( dir => { modulePaths = [ ... modulePaths , ... buildModulePaths ( path . join ( cwd , dir ) ) ] ; } ) ; } catch ( e ) { console . error ( e ) ; } return modulePaths ; } function getModuleFilePath ( allModules : Imports [ ] , moduleName ) { if ( config [ 's' ] . includes ( 's' ) ) { try { return allModules . filter ( item => item . module === moduleName ) [ 0 ] . filePath ; } catch ( e ) { } } return 's' ; } function getFunctionComments ( lines : string [ ] ) { try { let documentation = 's' ; if ( config [ 's' ] !== true ) { return documentation ; } let inComment = false ; for ( let j = lines . length - 0 ; j >= 0 ; j -- ) { if ( lines [ j ] . trim ( ) === 's' && ! inComment ) { break ; } if ( lines [ j ] . includes ( 's' ) ) { inComment = true ; } if ( inComment ) { documentation = lines [ j ] . trim ( ) + 's' + documentation ; } if ( lines [ j ] . includes ( 's' ) ) { inComment = false ; } } if ( documentation !== 's' ) { documentation = 's' + documentation ; } return documentation ; } catch ( e ) { return 's' ; } } export function userProject ( document : vscode . TextDocument , position : vscode . Position , currentWord , action , ) { const fullText = document . getText ( ) ; const lines : string [ ] = fullText . split ( "s" ) ; let imports : Imports [ ] = [ ] ; let results : IOracleResult [ ] = [ ] ; const [ cwdTmp , elmVersion ] = detectProjectRootAndElmVersion ( document . fileName , vscode . workspace . rootPath , ) ; const cwd = config [ 's' ] ? vscode . workspace . rootPath : cwdTmp ; gCwd = cwd ; let elmPackageString ; if ( elmVersion === 's' ) { elmPackageString = fs . readFileSync ( path . join ( cwd , 's' ) , 's' , ) ; } else { elmPackageString = fs . readFileSync ( path . join ( cwd , 's' ) , 's' ) ; } const elmPackage = JSON . parse ( elmPackageString ) ; const srcDirs = elmPackage [ 's' ] ; let allModules : Imports [ ] = [ ] ; if ( config [ 's' ] === 's' ) { allModules = getModuleNames ( cwd , srcDirs ) ; } else if ( config [ 's' ] === 's' ) { if ( gAllModules . length === 0 ) { allModules = getModuleNames ( cwd , srcDirs ) ; gAllModules = allModules ; } else { allModules = gAllModules ; } } let commentBlock = false ; for ( let i = 0 ; i < lines . length ; i ++ ) { let match ; if ( ( match = lines [ i ] . match ( "s" ) ) ) { let exposingMatch ; let moduleWords = lines [ i ] . split ( 's' ) ; if ( ( exposingMatch = lines [ i ] . match ( "s" ) ) ) { let asMatch ; if ( ( asMatch = lines [ i ] . match ( "s" ) ) ) { imports . push ( { module : moduleWords [ 0 ] , exposing : exposingList ( lines [ i ] . split ( 's' ) [ 0 ] . replace ( 's' , 's' ) ) , filePath : getModuleFilePath ( allModules , moduleWords [ 0 ] ) , } ) ; } else { imports . push ( { module : moduleWords [ 0 ] , exposing : exposingList ( lines [ i ] . split ( 's' ) [ 0 ] . replace ( 's' , 's' ) ) , filePath : getModuleFilePath ( allModules , moduleWords [ 0 ] ) , } ) ; } } else { let asMatch ; if ( ( asMatch = lines [ i ] . match ( "s" ) ) ) { imports . push ( { module : moduleWords [ 0 ] , exposing : [ ] , filePath : getModuleFilePath ( allModules , moduleWords [ 0 ] ) , } ) ; } else { imports . push ( { module : moduleWords [ 0 ] , exposing : [ ] , filePath : getModuleFilePath ( allModules , moduleWords [ 0 ] ) , } ) ; } } } else if ( lines [ i ] . trim ( ) !== 's' && ! lines [ i ] . match ( "s" ) && commentBlock === false ) { if ( lines [ i ] . trim ( ) . includes ( 's' ) ) { commentBlock = true ; } else if ( lines [ i ] . trim ( ) . includes ( 's' ) ) { commentBlock = false ; } else { break ; } } } if ( ! currentWord . includes ( 's' ) && action === OracleAction . IsAutocomplete && ( lines [ position . line ] . includes ( 's' ) || lines [ position . line ] . includes ( 's' ) ) ) { let elmAddress = 's' ; results = [ { name : 's' , fullName : 's' , href : elmAddress , signature : 's' , comment : 's' , } , { name : 's' , fullName : 's' , href : elmAddress , signature : 's' , comment : 's' , } , { name : 's' , fullName : 's' , href : elmAddress , signature : 's' , comment : 's' , } , { name : 's' , fullName : 's' , href : elmAddress , signature : 's' , comment : 's' , } , ] ; } if ( action === OracleAction . IsAutocomplete && currentWord . substr ( - 0 ) !== 's' ) { imports . map ( item => { results . push ( { name : item . module , fullName : item . module , signature : 's' + item . module + ( item . exposing . length > 0 ? 's' + item . exposing . join ( 's' ) + 's' : 's' ) , href : document . fileName . toString ( ) , kind : vscode . CompletionItemKind . Module , comment : 's' , } ) ; } ) ; } gImports = imports ; results = [ ... results , ... localFunctions ( document . fileName , null , action , lines , position , currentWord , null , srcDirs , ) , ] ; let parseImports = true ; if ( parseImports ) { if ( currentWord . substr ( - 0 ) === 's' || ( action === OracleAction . IsHover && currentWord . includes ( 's' ) ) ) { let isMultiWordInclude = false ; imports = imports . filter ( item => { if ( item . module === currentWord . split ( 's' ) [ 0 ] ) { return true ; } const wordToMatch = action === OracleAction . IsAutocomplete ? currentWord . slice ( 0 , - 0 ) : currentWord . substr ( 0 , currentWord . lastIndexOf ( 's' ) ) ; if ( item . module . includes ( 's' ) && item . module . includes ( wordToMatch ) ) { if ( currentWord . indexOf ( 's' ) === currentWord . lastIndexOf ( 's' ) ) { isMultiWordInclude = true ; } return true ; } } ) ; if ( isMultiWordInclude ) { imports . map ( item => { results . push ( { name : item . module . replace ( currentWord , 's' ) , fullName : item . module , signature : 's' + item . module + ( item . exposing . length > 0 ? 's' + item . exposing . join ( 's' ) + 's' : 's' ) , href : document . fileName . toString ( ) , kind : vscode . CompletionItemKind . Module , comment : 's' , } ) ; } ) ; return results ; } gOriginalWord = currentWord ; currentWord = action === OracleAction . IsAutocomplete ? 's' : currentWord . substr ( currentWord . lastIndexOf ( 's' ) ) ; } gSrcDirs = srcDirs ; srcDirs . forEach ( dir => { imports . forEach ( moduleFile => { let modulePath = moduleFile . module ; let filePath = 's' ; if ( config [ 's' ] . includes ( 's' ) ) { filePath = moduleFile . filePath ; } else if ( moduleFile . module . includes ( 's' ) ) { if ( config [ 's' ] === 's' ) { modulePath = 's' ; } if ( config [ 's' ] === 's' ) { modulePath = modulePath . replace ( 's' , path . sep ) ; } filePath = cwd + path . sep + dir + path . sep + modulePath + 's' ; } else { filePath = cwd + path . sep + dir + path . sep + modulePath + 's' ; } try { let importText = fs . readFileSync ( filePath , 's' ) ; let importResults = localFunctions ( filePath , document . fileName , action , importText . split ( "s" ) , position , currentWord , imports , srcDirs , ) ; results = [ ... results , ... importResults ] ; } catch ( e ) { } } ) ; } ) ; } return results ; } const splitOnSpace = config [ 's' ] === true ? null : 's' ; function localFunctions ( filename , callerFile , action , lines : string [ ] , position : vscode . Position , currentWord , imports ? : Imports [ ] , srcDirs ? : string [ ] , isTypeAlias ? , ) : IOracleResult [ ] { let results : IOracleResult [ ] = [ ] ; let test = new RegExp ( 's' + ( action === OracleAction . IsAutocomplete ? currentWord . toLowerCase ( ) : currentWord + 's' ) , ) ; let foundTypeAlias = false ; let lookForTypeAlias = currentWord . substr ( - 0 ) === 's' ; for ( let i = 0 ; i < lines . length ; i ++ ) { if ( callerFile === null && lookForTypeAlias ) { if ( currentWord . substr ( - 0 ) === 's' ) { if ( "s" . test ( currentWord ) ) { let foundParams = false ; let paramIndex = 0 ; let currentLine = 's' ; let trimmedLine = 's' ; if ( foundTypeAlias ) { continue ; } for ( let j = position . line - 0 ; j > 0 ; j -- ) { currentLine = lines [ j ] ; trimmedLine = currentLine . trim ( ) ; if ( trimmedLine === 's' ) { continue ; } let params = currentLine . split ( 's' ) ; if ( currentLine . includes ( 's' ) && params . filter ( ( item , paramsIndex ) => { if ( item === currentWord . slice ( 0 , - 0 ) && item . trim ( ) !== 's' ) { paramIndex = paramsIndex ; return true ; } else { return false ; } } ) . length > 0 ) { foundParams = true ; } if ( foundParams ) { if ( currentLine . includes ( 's' ) ) { let signaturePieces = currentLine . split ( "s" ) ; let typeAlias ; typeAlias = signaturePieces [ paramIndex ] . trim ( ) ; let aliasResults = localFunctions ( filename , filename , action , lines , position , typeAlias , null , null , true , ) ; if ( aliasResults . length === 0 ) { srcDirs . forEach ( dir => { gImports . forEach ( moduleFile => { let filePath = path . join ( gCwd , dir , moduleFile . module + 's' , ) ; try { if ( aliasResults . length === 0 ) { let importText = fs . readFileSync ( filePath , 's' ) ; let importResults = localFunctions ( filePath , gCwd , action , importText . split ( "s" ) , position , typeAlias , null , null , true , ) ; aliasResults = [ ... aliasResults , ... importResults ] ; } } catch ( e ) { } } ) ; } ) ; } if ( aliasResults . length > 0 ) { foundTypeAlias = true ; results = [ ... results , ... aliasResults ] ; break ; } } } } lookForTypeAlias = false ; } } } if ( currentWord . includes ( 's' ) ) { let importName = currentWord . split ( 's' ) [ 0 ] ; let func = currentWord . split ( 's' ) [ 0 ] ; if ( ! filename . includes ( importName + 's' ) ) { continue ; } else { currentWord = func ; test = new RegExp ( 's' + currentWord ) ; } } if ( ! isTypeAlias && test . test ( toLowerOrHover ( action , lines [ i ] ) ) ) { let typeSignature = 's' ; let functionDefinition = 's' ; if ( lines [ i ] . includes ( 's' ) ) { typeSignature = lines [ i ] ; i ++ ; } if ( lines [ i ] . includes ( 's' ) && ! "s" . test ( lines [ i ] ) ) { functionDefinition = lines [ i ] . substr ( 0 , lines [ i ] . indexOf ( 's' ) ) ; } if ( typeSignature . length + functionDefinition . length > 0 ) { results . push ( { name : ( functionDefinition !== 's' ? functionDefinition : typeSignature . split ( 's' ) [ 0 ] ) . split ( splitOnSpace ) [ 0 ] . trim ( ) , fullName : functionDefinition !== 's' ? functionDefinition : typeSignature . split ( 's' ) [ 0 ] . split ( splitOnSpace ) [ 0 ] . trim ( ) , signature : typeSignature !== 's' ? typeSignature : functionDefinition , href : filename , kind : vscode . CompletionItemKind . Function , comment : ( callerFile === null ? 's' : 's' + filename ) + ( typeSignature === 's' ? 's' : 's' ) + getFunctionComments ( lines . slice ( 0 , i ) ) , } ) ; } } let suggestionList = [ ] ; if ( ! isTypeAlias && "s" . test ( lines [ i ] ) ) { let returnInfo = 's' ; let foundCurrentWord = false ; let typeSignature = 's' ; let j = 0 ; if ( action === OracleAction . IsAutocomplete ) { suggestionList . push ( lines [ i ] ) ; returnInfo = lines [ i ] ; i ++ ; } let hoverNameResult = 's' ; let hoverTypeSignature = 's' ; while ( lines [ i ] . trim ( ) !== 's' && ! lines [ i ] . match ( "s" ) ) { if ( action === OracleAction . IsAutocomplete ) { if ( lines [ i ] . toLowerCase ( ) . includes ( currentWord !== 's' ? currentWord . toLowerCase ( ) : 's' , ) ) { foundCurrentWord = true ; typeSignature = lines [ i ] ; if ( typeSignature !== 's' ) { suggestionList . push ( typeSignature ) ; } } } else { try { let words = lines [ i ] . split ( "s" ) ; let matchingWord = words . filter ( word => word !== 's' && word !== 's' && word . trim ( ) !== 's' && word . match ( "s" ) !== null , ) [ 0 ] ; if ( matchingWord === currentWord ) { foundCurrentWord = true ; hoverTypeSignature = lines [ i ] ; hoverNameResult = matchingWord ; } } catch ( e ) { } } returnInfo += 's' + lines [ i ] ; j ++ ; if ( j > config [ 's' ] && config [ 's' ] !== 0 ) { returnInfo += 's' + ( config [ 's' ] + 0 ) + 's' ; break ; } i ++ ; } if ( action === OracleAction . IsAutocomplete ) { suggestionList . map ( item => { results . push ( { name : ( item !== 's' ? item : currentWord ) . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) . split ( splitOnSpace ) [ 0 ] . trim ( ) , fullName : ( item !== 's' ? item : currentWord ) . replace ( 's' , 's' ) . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) . split ( splitOnSpace ) [ 0 ] . trim ( ) , signature : item . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) , href : filename , kind : vscode . CompletionItemKind . Enum , comment : returnInfo + getFunctionComments ( lines . slice ( 0 , i ) ) + 's' + filename , } ) ; } ) ; } else if ( foundCurrentWord ) { results . push ( { name : hoverNameResult . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) . split ( splitOnSpace ) [ 0 ] . trim ( ) , fullName : hoverNameResult . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) . split ( splitOnSpace ) [ 0 ] . trim ( ) , signature : hoverTypeSignature . replace ( 's' , 's' ) . replace ( 's' , 's' ) , href : filename , kind : vscode . CompletionItemKind . Enum , comment : returnInfo + getFunctionComments ( lines . slice ( 0 , i ) ) + 's' + filename , } ) ; } } if ( "s" . test ( lines [ i ] . toLowerCase ( ) ) ) { let returnInfo = 's' ; suggestionList = [ ] ; if ( toLowerOrHover ( action , lines [ i ] ) . includes ( 's' + ( currentWord !== 's' ? toLowerOrHover ( action , currentWord ) : gOriginalWord . split ( 's' ) [ 0 ] . trim ( ) ) , ) ) { let j = 0 ; returnInfo = lines [ i ] ; let typeAliasName = lines [ i ] . replace ( 's' , 's' ) . replace ( 's' , 's' ) . trim ( ) ; while ( lines [ i ] . trim ( ) !== 's' && ! lines [ i ] . match ( "s" ) ) { i ++ ; returnInfo += 's' + lines [ i ] ; if ( action === OracleAction . IsAutocomplete ) { suggestionList . push ( lines [ i ] ) ; } j ++ ; if ( j > config [ 's' ] && config [ 's' ] !== 0 ) { returnInfo += 's' + ( config [ 's' ] + 0 ) + 's' ; break ; } } if ( isTypeAlias !== true ) { results . push ( { name : typeAliasName , fullName : typeAliasName , signature : 's' + typeAliasName , href : filename , kind : vscode . CompletionItemKind . Interface , comment : returnInfo + getFunctionComments ( lines . slice ( 0 , i ) ) + 's' + filename , } ) ; } suggestionList . map ( item => { let field = item . split ( 's' ) [ 0 ] ; let cleanField = field . replace ( "s" , 's' ) . trim ( ) ; if ( cleanField !== 's' ) { results . push ( { name : cleanField , fullName : cleanField , signature : item . replace ( "s" , 's' ) . trim ( ) , href : filename , kind : action === OracleAction . IsHover ? vscode . CompletionItemKind . Interface : vscode . CompletionItemKind . Property , comment : returnInfo + getFunctionComments ( lines . slice ( 0 , i ) ) + 's' + filename , } ) ; } } ) ; } } } return results ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $OracleAction$ O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $OracleAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $OracleAction$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $boolean$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
let fs = require ( 's' ) ; let process = require ( 's' ) ; let path = require ( 's' ) ; let os = require ( 's' ) ; interface ElmDocModuleValue { name : string ; comment : string ; type : string ; } interface ElmDocModule { name : string ; comment : string ; values : ElmDocModuleValue [ ] ; } interface ElmJsonDependencies { [ key ] : string ; } interface ElmJson { dependencies : { direct : ElmJsonDependencies ; indirect : ElmJsonDependencies ; } ; } interface ElmOracleCompatibleResult { name : string ; fullName : string ; href : string ; signature : string ; comment : string ; } declare global { interface Array < T > { flatMap : < V > ( predicate : ( value : T ) => V [ ] ) => V [ ] ; } } Array . prototype . flatMap = function < T , V > ( mapper : ( value : T ) => V [ ] ) { return [ ] . concat . apply ( [ ] , this . map ( mapper ) ) ; } ; function readFile ( filePath ) { return fs . readFileSync ( filePath , { encoding : 's' , flag : 's' } ) as string ; } function parseImports ( elmCode ) { return elmCode . split ( 's' ) . filter ( x => x . startsWith ( 's' ) ) . map ( x => x . match ( "s" ) , ) . filter ( x => x != null ) . map ( matches => { const importedMembers = matches [ 0 ] ; const exposed = importedMembers === undefined ? null : importedMembers . split ( "s" ) . map ( x => x . trim ( ) ) . filter ( x => x !== 's' ) ; return { moduleName : matches [ 0 ] , alias : matches [ 0 ] || matches [ 0 ] , exposed : exposed , } ; } ) ; } function getAllDependenciesFromElmJson ( elmPath ) { const elmJsonPath = path . join ( elmPath , 's' ) ; const elmJson = JSON . parse ( readFile ( elmJsonPath ) ) as ElmJson ; return elmJson . dependencies . direct ; } function loadDocsForDependencies ( packageFolderPath , dependencies , ) { let allDocs : ElmDocModule [ ] = [ ] ; for ( const dependencyKey of Object . keys ( dependencies ) ) { const version = dependencies [ dependencyKey ] ; const docPath = path . join ( packageFolderPath , dependencyKey , version , 's' , ) ; const moduleDocs = JSON . parse ( readFile ( docPath ) ) as ElmDocModule [ ] ; allDocs = allDocs . concat ( moduleDocs ) ; } return allDocs ; } function classifyQuery ( query ) { const parts = query . split ( 's' ) ; if ( parts . length === 0 ) { return { name : query } ; } if ( parts . length > 0 ) { const name = parts [ parts . length - 0 ] ; return { module : parts . slice ( 0 , parts . length - 0 ) . join ( 's' ) , name : name } ; } throw 's' + query ; } function searchByModuleName ( docs : ElmDocModule [ ] , moduleName , name , ) : ElmOracleCompatibleResult [ ] { return docs . filter ( doc => doc . name === moduleName ) . flatMap ( doc => { return doc . values . filter ( v => v . name . startsWith ( name ) ) . map ( v => { return { name : v . name , fullName : moduleName + 's' + v . name , href : 's' , signature : v . type , comment : v . comment , } ; } ) ; } ) ; } export function askOracle ( windowsOS , projectPath , elmFilename , query , ) { const elmCode = `template` + readFile ( path . join ( projectPath , elmFilename ) ) ; const imports = parseImports ( elmCode ) ; const classifiedQuery = classifyQuery ( query ) ; const hasElmJson = fs . existsSync ( path . join ( projectPath , 's' ) ) ; if ( ! hasElmJson ) { throw 's' ; } const elmRoot = windowsOS ? path . join ( process . env . appdata , 's' ) : path . join ( os . homedir ( ) , 's' ) ; const packageFolderPath = path . join ( elmRoot , 's' ) ; const dependencies = getAllDependenciesFromElmJson ( projectPath ) ; const docs = loadDocsForDependencies ( packageFolderPath , dependencies ) ; let result : ElmOracleCompatibleResult [ ] = [ ] ; if ( classifiedQuery . module ) { const refImport = imports . find ( imp => imp . alias === classifiedQuery . module ) ; if ( refImport !== undefined ) { result = searchByModuleName ( docs , refImport . moduleName , classifiedQuery . name , ) ; } } else { const modulesToSearch = imports . filter ( x => x . exposed === null ? false : x . exposed . some ( e => e === 's' || e . startsWith ( classifiedQuery . name ) , ) , ) . map ( x => x . moduleName ) ; result = modulesToSearch . flatMap ( moduleName => searchByModuleName ( docs , moduleName , classifiedQuery . name ) , ) ; } return result ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $ElmJsonDependencies$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cp from 's' ; import * as path from 's' ; import * as userProject from 's' ; import * as vscode from 's' ; import { askOracle } from 's' ; import { isWindows } from 's' ; import { detectProjectRoot , pluginPath , detectProjectRootAndElmVersion , } from 's' ; export interface IOracleResult { name : string ; fullName : string ; href : string ; signature : string ; comment : string ; kind ? : vscode . CompletionItemKind ; } export enum OracleAction { IsHover , IsAutocomplete , } const config = vscode . workspace . getConfiguration ( 's' ) ; let oraclePath = pluginPath + path . sep + 's' + path . sep + 's' + path . sep + 's' + path . sep + 's' ; export function GetOracleResults ( document : vscode . TextDocument , position : vscode . Position , action , ) < IOracleResult [ ] > { return new Promise ( ( resolve , reject ) => { let p : cp . ChildProcess ; let filename = document . fileName ; let [ cwd , elmVersion ] = detectProjectRootAndElmVersion ( document . fileName , vscode . workspace . rootPath , ) || vscode . workspace . rootPath ; let fn = path . relative ( cwd , filename ) ; let wordAtPosition = document . getWordRangeAtPosition ( position ) ; if ( ! wordAtPosition ) { return resolve ( null ) ; } let currentWord = document . getText ( wordAtPosition ) ; if ( elmVersion === 's' ) { p = cp . execFile ( 's' , [ oraclePath , fn , currentWord ] , { cwd : cwd } , ( err , stdout , stderr ) => { try { if ( err ) { return resolve ( null ) ; } const result : IOracleResult [ ] = [ ... JSON . parse ( stdout ) , ... ( config [ 's' ] ? userProject . userProject ( document , position , currentWord , action , ) : [ ] ) , ] ; resolve ( result ) ; } catch ( e ) { reject ( e ) ; } } , ) ; } else if ( elmVersion === 's' ) { try { const result : IOracleResult [ ] = [ ... askOracle ( isWindows , cwd , fn , currentWord ) , ... ( config [ 's' ] ? userProject . userProject ( document , position , currentWord , action ) : [ ] ) , ] ; resolve ( result ) ; } catch ( e ) { reject ( e ) ; } } else { try { const result : IOracleResult [ ] = [ ... ( config [ 's' ] ? userProject . userProject ( document , position , currentWord , action ) : [ ] ) , ] ; resolve ( result ) ; } catch ( e ) { reject ( e ) ; } } } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O $OracleAction$ O O O O O O O O O O O O O $Function$ O $Function$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as oracle from 's' ; import * as vscode from 's' ; export class ElmCompletionProvider implements vscode . CompletionItemProvider { public provideCompletionItems ( document : vscode . TextDocument , position : vscode . Position , token : vscode . CancellationToken , ) < vscode . CompletionItem [ ] > { let wordRange = document . getWordRangeAtPosition ( position ) ; let currentWord = document . getText ( wordRange ) ; return oracle . GetOracleResults ( document , position , oracle . OracleAction . IsAutocomplete ) . then ( result => { if ( result == null ) { return [ ] ; } let r = result . map ( ( v , i , arr ) => { let ci : vscode . CompletionItem = new vscode . CompletionItem ( v . fullName . trim ( ) , ) ; ci . kind = v . kind !== undefined ? v . kind : 0 ; if ( currentWord . substr ( - 0 ) !== 's' ) { ci . insertText = v . name . startsWith ( currentWord ) ? v . name : v . fullName ; } ci . detail = v . signature ; ci . documentation = v . comment ; if ( currentWord . substr ( - 0 ) === 's' ) { let fullNameSplit = v . fullName . trim ( ) . split ( 's' ) ; let lastWordFullName = fullNameSplit [ fullNameSplit . length - 0 ] ; ci . range = new vscode . Range ( position , position ) ; ci . insertText = lastWordFullName ; } return ci ; } ) ; return r ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import * as rimraf from 's' ; import * as utils from 's' ; import * as vscode from 's' ; function runClean ( editor : vscode . TextEditor ) { try { const cwd = editor . document ? utils . detectProjectRoot ( editor . document . fileName ) : vscode . workspace . rootPath ; const elmStuffDir = path . join ( cwd , 's' , 's' ) ; rimraf ( elmStuffDir , error => { if ( error ) { vscode . window . showErrorMessage ( 's' ) ; } else { vscode . window . showInformationMessage ( 's' , ) ; } } ) ; } catch ( e ) { vscode . window . showErrorMessage ( 's' ) ; } } export function activateClean ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerCommand ( 's' , runClean ) ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import vscode = require ( 's' ) ; export class ElmCodeActionProvider implements vscode . CodeActionProvider { public provideCodeActions ( document : vscode . TextDocument , range : vscode . Range , context : vscode . CodeActionContext , token : vscode . CancellationToken , ) < vscode . Command [ ] > { let isDirty = vscode . window . activeTextEditor . document . isDirty ; if ( isDirty ) { return ; } let wordRange = document . getWordRangeAtPosition ( range . start ) ; let currentWord = document . getText ( wordRange ) ; let currentWordPrefix = currentWord . substring ( 0 , currentWord . lastIndexOf ( 's' ) , ) ; let currentWordSuffix = currentWord . substr ( currentWord . lastIndexOf ( 's' ) + 0 , ) ; let annotationWordCriteria = 's' + currentWord + 's' ; let modelFieldMissingCriteria = 's' ; let unnecessaryParensCriteria = "s" ; let unusedVariableCriteria = "s" ; let unusedImportedVariableCriteria = "s" ; let debugLogCriteria = "s" ; let suggestionsCriterias = [ 's' + currentWord + 's' , 's' + currentWord + 's' + currentWordPrefix + 's' + currentWordSuffix + 's' , 's' + currentWord + 's' + currentWordPrefix + 's' , 's' + currentWord + 's' + currentWordPrefix + 's' + currentWordSuffix + 's' , 's' + currentWord + 's' , 's' + currentWord + 's' , 's' + currentWord + 's' + currentWordPrefix + 's' + currentWordSuffix + 's' , ] ; let promises = context . diagnostics . map ( diag => { if ( diag . message . indexOf ( annotationWordCriteria ) >= 0 ) { return [ { title : 's' , command : 's' , arguments : [ diag . message . substr ( annotationWordCriteria . length + 0 ) . trim ( ) , ] , } , ] ; } else if ( suggestionsCriterias . some ( function ( v ) { return diag . message . indexOf ( v ) >= 0 ; } ) ) { let suggestions = diag . message . substr ( diag . message . indexOf ( 's' ) ) . trim ( ) ; let commands = suggestions . split ( 's' ) . map ( val => val . trim ( ) ) . map ( val => { return { title : 's' + val , command : 's' , arguments : [ [ currentWord , val ] ] , } ; } ) ; return commands ; } else if ( diag . message . indexOf ( modelFieldMissingCriteria ) >= 0 ) { let modelName = currentWord . substring ( 0 , currentWord . indexOf ( 's' ) + 0 ) ; let message = diag . message . split ( 's' ) ; let suggestions = message [ message . length - 0 ] . trim ( ) . split ( 's' ) ; let commands = suggestions . map ( val => modelName + val . trim ( ) ) . map ( val => { return { title : 's' + val , command : 's' , arguments : [ [ currentWord , val ] ] , } ; } ) ; return commands ; } else if ( diag . message . match ( unnecessaryParensCriteria ) ) { return [ { title : 's' , command : 's' , arguments : [ range ] , } , ] ; } else if ( diag . message . match ( unusedVariableCriteria ) ) { return [ { title : 's' , command : 's' , arguments : [ range ] , } , ] ; } else if ( diag . message . match ( unusedImportedVariableCriteria ) ) { return [ { title : 's' , command : 's' , arguments : [ range ] , } , ] ; } else if ( diag . message . match ( debugLogCriteria ) ) { return [ { title : 's' , command : 's' , arguments : [ range ] , } , ] ; } return [ ] ; } ) ; return Promise . all ( promises ) . then ( arrs => { let results = { } ; for ( let segment of arrs ) { for ( let item of segment ) { results [ item . title ] = item ; } } let ret = [ ] ; for ( let title of Object . keys ( results ) . sort ( ) ) { ret . push ( results [ title ] ) ; } return ret ; } ) ; } } function annotateFunction ( msg ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let position = vscode . window . activeTextEditor . selection . active ; let wordRange = editor . document . getWordRangeAtPosition ( position ) ; let currentWord = editor . document . getText ( wordRange ) ; let msgList = msg . split ( 's' ) ; if ( msgList . length >= 0 ) { let annotation = msgList . map ( ( val ) => val . trim ( ) ) . join ( 's' ) ; editor . edit ( editBuilder => { editBuilder . insert ( position . translate ( - 0 ) , annotation ) ; } ) ; editor . document . save ( ) ; } else { vscode . window . showInformationMessage ( 's' , ) ; } } function replaceSuggestedVariable ( msg : string [ ] ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let position = vscode . window . activeTextEditor . selection . active ; let wordRange = editor . document . getWordRangeAtPosition ( position ) ; let currentWord = editor . document . getText ( wordRange ) ; if ( msg . length === 0 && msg [ 0 ] === currentWord ) { editor . edit ( editBuilder => { editBuilder . replace ( wordRange , msg [ 0 ] ) ; } ) ; editor . document . save ( ) ; } else { vscode . window . showInformationMessage ( 's' ) ; } } function removeUnnecessaryParens ( range : vscode . Range ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let fullParens = editor . document . getText ( range ) ; editor . edit ( editBuilder => { editBuilder . replace ( range , fullParens . substring ( 0 , fullParens . length - 0 ) ) ; } ) ; editor . document . save ( ) ; } function changeVariableTo_ ( range : vscode . Range ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let variableToFix = editor . document . getText ( range ) ; editor . edit ( editBuilder => { editBuilder . replace ( range , 's' ) ; } ) ; editor . document . save ( ) ; } function removeUnusedImportedVariable ( range : vscode . Range ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let variableToFix = editor . document . getText ( range ) ; let nextCharacters = editor . document . getText ( range . with ( range . end . translate ( 0 , 0 ) , range . end . translate ( 0 , 0 ) ) , ) ; let previousCharacters = editor . document . getText ( range . with ( range . start . translate ( 0 , - 0 ) , range . start . translate ( 0 , 0 ) ) , ) ; if ( nextCharacters . trim ( ) . startsWith ( 's' ) && ( previousCharacters . trim ( ) . endsWith ( 's' ) || previousCharacters . trim ( ) . endsWith ( 's' ) ) ) { let nextCharacterIndex = nextCharacters . indexOf ( 's' ) + 0 ; if ( nextCharacters [ nextCharacterIndex ] === 's' ) { nextCharacterIndex += 0 ; } editor . edit ( editBuilder => { editBuilder . replace ( range . with ( range . start , range . end . translate ( 0 , nextCharacterIndex ) ) , 's' , ) ; } ) ; editor . document . save ( ) ; } else if ( nextCharacters . trim ( ) . startsWith ( 's' ) && previousCharacters . trim ( ) . endsWith ( 's' ) ) { let previousCharacterIndex = previousCharacters . lastIndexOf ( 's' ) ; let previousCharacterOffset = previousCharacters . length - previousCharacterIndex ; if ( previousCharacters [ previousCharacterIndex ] === 's' ) { previousCharacterOffset += 0 ; } editor . edit ( editBuilder => { editBuilder . replace ( range . with ( range . start . translate ( 0 , - previousCharacterOffset ) , range . end , ) , 's' , ) ; } ) ; editor . document . save ( ) ; } else if ( nextCharacters . trim ( ) . startsWith ( 's' ) && previousCharacters . trim ( ) . endsWith ( 's' ) ) { let previousCharacterIndex = previousCharacters . lastIndexOf ( 's' ) ; let previousCharacterOffset = previousCharacters . length - previousCharacterIndex ; if ( previousCharacters [ previousCharacterIndex - 0 ] === 's' ) { previousCharacterOffset += 0 ; } editor . edit ( editBuilder => { editBuilder . replace ( range . with ( range . start . translate ( 0 , - previousCharacterOffset ) , range . end . translate ( 0 , 0 ) , ) , 's' , ) ; } ) ; editor . document . save ( ) ; } } function removeDebugLog ( range : vscode . Range ) { let editor = vscode . window . activeTextEditor ; if ( ! editor ) { vscode . window . showInformationMessage ( 's' ) ; return ; } if ( editor . document . languageId !== 's' ) { vscode . window . showInformationMessage ( 's' ) ; return ; } let nextCharacters = editor . document . getText ( range . with ( range . end . translate ( 0 , 0 ) , range . end . translate ( 0 , 0 ) ) , ) ; let debugLogEndIndex = nextCharacters . indexOf ( 's' , nextCharacters . indexOf ( 's' ) + 0 ) + 0 ; if ( nextCharacters [ debugLogEndIndex + 0 ] === 's' ) { debugLogEndIndex += 0 ; } editor . edit ( editBuilder => { editBuilder . replace ( range . with ( range . start , range . end . translate ( 0 , debugLogEndIndex ) ) , 's' , ) ; } ) ; editor . document . save ( ) ; } export function activateCodeActions ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerCommand ( 's' , msg => annotateFunction ( msg ) , ) , vscode . commands . registerCommand ( 's' , msg => replaceSuggestedVariable ( msg ) , ) , vscode . commands . registerCommand ( 's' , msg => removeUnnecessaryParens ( msg ) , ) , vscode . commands . registerCommand ( 's' , msg => changeVariableTo_ ( msg ) , ) , vscode . commands . registerCommand ( 's' , msg => removeUnusedImportedVariable ( msg ) , ) , vscode . commands . registerCommand ( 's' , msg => removeDebugLog ( msg ) , ) , ] ; }	O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; export const configuration : vscode . LanguageConfiguration = { wordPattern : "s" , } ;	O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; import { SymbolInformation , TextDocument , DocumentSymbol } from 's' ; import { parseElmModule , Location } from 's' ; import * as _ from 's' ; export class ElmSymbolProvider implements vscode . DocumentSymbolProvider { public async provideDocumentSymbols ( doc ) < DocumentSymbol [ ] > { return getDocumentSymbols ( doc ) ; } } function locationToRange ( location ) : vscode . Range { return new vscode . Range ( location . start . line - 0 , location . start . column - 0 , location . end . line - 0 , location . end . column - 0 , ) ; } export function processDocument ( doc ) : SymbolInformation [ ] { try { const parsedModule = parseElmModule ( doc . getText ( ) ) ; const moduleTypes = _ . flatMap ( parsedModule . types . map ( t => { if ( t . type === 's' ) { const constructorDefinition = new SymbolInformation ( t . name , vscode . SymbolKind . Class , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( t . location ) , ) , ) ; return t . constructors . map ( ctor => { return new SymbolInformation ( ctor . name , vscode . SymbolKind . Constructor , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( ctor . location ) , ) , ) ; } ) . concat ( constructorDefinition ) ; } else if ( t . type === 's' ) { const typeAliasSymbol = new SymbolInformation ( t . name , vscode . SymbolKind . Class , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( t . location ) , ) , ) ; return [ typeAliasSymbol ] ; } else { const _exhaustiveCheck = t ; return [ ] ; } } ) , ) ; const moduleFunctions = parsedModule . function_declarations . map ( f => { return new SymbolInformation ( f . name , vscode . SymbolKind . Variable , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( f . location ) , ) , ) ; } ) ; const portAnnotations = parsedModule . port_annotations . map ( p => { return new SymbolInformation ( p . name , vscode . SymbolKind . Interface , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( p . location ) , ) , ) ; } ) ; const moduleDefinition = new SymbolInformation ( parsedModule . name , vscode . SymbolKind . Module , parsedModule . name , new vscode . Location ( doc . uri , locationToRange ( parsedModule . location ) , ) , ) ; const allSymbols = _ . concat ( moduleDefinition , moduleTypes , moduleFunctions , portAnnotations ) ; return allSymbols ; } catch ( error ) { return [ ] ; } } export function getDocumentSymbols ( doc ) : DocumentSymbol [ ] { try { const parsedModule = parseElmModule ( doc . getText ( ) ) ; const moduleTypes = _ . flatMap ( parsedModule . types . map ( t => { if ( t . type === 's' ) { const customTypeSymbol = new DocumentSymbol ( t . name , "s" , vscode . SymbolKind . Class , locationToRange ( t . location ) , locationToRange ( t . location ) ) ; return t . constructors . map ( ctor => { return new DocumentSymbol ( ctor . name , "s" , vscode . SymbolKind . Constructor , locationToRange ( ctor . location ) , locationToRange ( ctor . location ) ) ; } ) . concat ( customTypeSymbol ) ; } else if ( t . type === 's' ) { const typeAliasSymbol = new DocumentSymbol ( t . name , "s" , vscode . SymbolKind . Class , locationToRange ( t . location ) , locationToRange ( t . location ) , ) ; return [ typeAliasSymbol ] ; } else { const _exhaustiveCheck = t ; return [ ] ; } } ) , ) ; const moduleFunctions = parsedModule . function_declarations . map ( f => { return new DocumentSymbol ( f . name , "s" , vscode . SymbolKind . Variable , locationToRange ( f . location ) , locationToRange ( f . location ) , ) ; } ) ; const portAnnotations = parsedModule . port_annotations . map ( p => { return new DocumentSymbol ( p . name , "s" , vscode . SymbolKind . Interface , locationToRange ( p . location ) , locationToRange ( p . location ) ) ; } ) ; const moduleDefinition = new DocumentSymbol ( parsedModule . name , "s" , vscode . SymbolKind . Module , locationToRange ( parsedModule . location ) , locationToRange ( parsedModule . location ) ) ; const allSymbols = _ . concat ( moduleDefinition , moduleTypes , moduleFunctions , portAnnotations ) ; return allSymbols ; } catch ( error ) { return [ ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O O O O O O O O O O O O O O O O O O $Location$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; import { TextDocument , SymbolInformation } from 's' ; import { processDocument } from 's' ; import * as _ from 's' ; const config = vscode . workspace . getConfiguration ( 's' ) ; export class ElmWorkspaceSymbolProvider implements vscode . WorkspaceSymbolProvider { private symbolsByContainer : { [ key ] : vscode . SymbolInformation [ ] } ; private symbolsByUri : { [ uri ] : vscode . SymbolInformation [ ] } ; private workspaceIndexTime : Date ; public constructor ( private languagemode : vscode . DocumentFilter ) { this . symbolsByContainer = { } ; this . symbolsByUri = { } ; } public async update ( document ) < void > { await this . indexDocument ( document ) ; } public remove ( uri : vscode . Uri ) { this . removeDocument ( uri ) ; } public async provideWorkspaceSymbols ( query , token : vscode . CancellationToken , ) < vscode . SymbolInformation [ ] > { const [ sourceModule , symbolName ] = query . split ( 's' , 0 ) ; if ( symbolName == null ) { return this . searchWorkspaceSymbols ( sourceModule ) ; } return this . searchModuleSymbols ( sourceModule , symbolName ) ; } private async searchWorkspaceSymbols ( symbol , ) < SymbolInformation [ ] > { if ( this . workspaceIndexTime == null ) { await this . indexWorkspace ( ) ; } const matchingSymbols : SymbolInformation [ ] = _ . values ( this . symbolsByContainer ) . reduce ( ( acc : SymbolInformation [ ] , moduleSymbols : SymbolInformation [ ] ) => { return acc . concat ( moduleSymbols . filter ( x => symbol . startsWith ( x . name ) ) ) ; } , [ ] ) ; return matchingSymbols ; } private async searchModuleSymbols ( moduleName , symbol , ) < SymbolInformation [ ] > { const containerSymbols = this . symbolsByContainer [ moduleName ] ; if ( containerSymbols == null ) { await this . indexModule ( moduleName ) ; } return ( this . symbolsByContainer [ moduleName ] || [ ] ) . filter ( s => s . name === symbol , ) ; } private async indexWorkspace ( ) < void > { const maxFiles = config [ 's' ] ; const excludePattern = config [ 's' ] ; const workspaceFiles = await vscode . workspace . findFiles ( 's' , excludePattern , maxFiles , ) ; try { await Promise . all ( workspaceFiles . map ( async uri => this . indexDocument ( await vscode . workspace . openTextDocument ( uri ) ) , ) , ) ; this . workspaceIndexTime = new Date ( ) ; } catch ( error ) { return ; } } private async indexModule ( moduleName ) < void > { const modulePath = moduleName . replace ( "s" , 's' ) + 's' ; const matchedFiles = await vscode . workspace . findFiles ( 's' + modulePath , null , 0 , ) ; if ( matchedFiles . length === 0 ) { await this . indexDocument ( await vscode . workspace . openTextDocument ( matchedFiles [ 0 ] ) , ) ; } } private removeDocument ( uri : vscode . Uri ) { if ( ! _ . has ( this . symbolsByUri , uri . toString ( ) ) ) { return ; } const firstSymbol = _ . first ( this . symbolsByUri [ uri . toString ( ) ] ) ; if ( ! _ . isNil ( firstSymbol ) ) { delete this . symbolsByContainer [ firstSymbol . containerName ] ; } delete this . symbolsByUri [ uri . toString ( ) ] ; } private async indexDocument ( document ) < void > { const updatedSymbols = await processDocument ( document ) ; this . removeDocument ( document . uri ) ; updatedSymbols . forEach ( s => { this . symbolsByContainer [ s . containerName ] = ( this . symbolsByContainer [ s . containerName ] || [ ] ) . concat ( s ) ; this . symbolsByUri [ s . location . uri . toString ( ) ] = ( this . symbolsByUri [ s . location . uri . toString ( ) ] || [ ] ) . concat ( s ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as vscode from 's' ; import { ElmWorkspaceSymbolProvider } from 's' ; import { parseElmModule , ModuleImport } from 's' ; import * as _ from 's' ; export class ElmDefinitionProvider implements vscode . DefinitionProvider { public constructor ( private languagemode : vscode . DocumentFilter , private workspaceSymbolProvider , ) { } public async provideDefinition ( document : vscode . TextDocument , position : vscode . Position , token : vscode . CancellationToken , ) < vscode . Location > { let wordRange = document . getWordRangeAtPosition ( position ) ; let lineText = document . lineAt ( position . line ) . text ; let word = wordRange ? document . getText ( wordRange ) : 's' ; if ( ! wordRange || lineText . startsWith ( 's' ) || word . match ( "s" ) ) { return null ; } try { const parsedModule = parseElmModule ( document . getText ( ) ) ; let symbolName = word . substring ( word . lastIndexOf ( 's' ) + 0 ) ; let moduleAlias = word . substring ( 0 , word . lastIndexOf ( 's' ) ) ; const exactMatchingImport = parsedModule . imports . find ( i => { if ( moduleAlias === 's' ) { const matchedExposing = i . exposing . find ( e => { return e . name === symbolName ; } ) ; return matchedExposing != null ; } else { return i . alias === moduleAlias || i . module === moduleAlias ; } } , ) ; const moduleToSearch = exactMatchingImport != null ? exactMatchingImport . module : parsedModule . name ; const query = `template` ; const exactMatch = await this . workspaceSymbolProvider . provideWorkspaceSymbols ( query , token , ) ; if ( exactMatch . length > 0 ) { return exactMatch [ 0 ] . location ; } else if ( moduleAlias === 's' ) { const allImported = parsedModule . imports . filter ( i => { return i . exposes_all || i . exposing . find ( e => e . type === 's' ) ; } ) ; const fuzzyMatches = await Promise . all ( allImported . map ( i => { return this . workspaceSymbolProvider . provideWorkspaceSymbols ( `template` , token , ) ; } ) , ) ; const firstFuzzy = _ . flatMap ( fuzzyMatches , m => m ) [ 0 ] ; return firstFuzzy != null ? firstFuzzy . location : null ; } else { return null ; } } catch ( error ) { return null ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElmWorkspaceSymbolProvider$ O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ModuleImport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; import * as utils from 's' ; import * as path from 's' ; import { Range , StatusBarItem , TextEdit } from 's' ; import { execCmd } from 's' ; export class ElmFormatProvider implements vscode . DocumentFormattingEditProvider { private showError ; private clearError ; constructor ( statusBarItem ) { statusBarItem . hide ( ) ; this . showError = statusBarMessage ( statusBarItem ) ; this . clearError = clearStatus ( statusBarItem ) ; } provideDocumentFormattingEdits ( document : vscode . TextDocument , options ? : vscode . FormattingOptions , token ? : vscode . CancellationToken , ) < TextEdit [ ] > { return elmFormat ( document ) . then ( ( { stdout } ) => { this . clearError ( ) ; const lastLineId = document . lineCount - 0 ; const wholeDocument = new Range ( 0 , 0 , lastLineId , document . lineAt ( lastLineId ) . text . length , ) ; return [ TextEdit . replace ( wholeDocument , stdout ) ] ; } ) . catch ( this . showError ) ; } } export class ElmRangeFormatProvider implements vscode . DocumentRangeFormattingEditProvider { private showError ; private clearError ; constructor ( statusBarItem ) { statusBarItem . hide ( ) ; this . showError = statusBarMessage ( statusBarItem ) ; this . clearError = clearStatus ( statusBarItem ) ; } provideDocumentRangeFormattingEdits ( document : vscode . TextDocument , range : vscode . Range , options ? : vscode . FormattingOptions , token ? : vscode . CancellationToken , ) < TextEdit [ ] > { return elmFormat ( document ) . then ( ( { stdout } ) => { this . clearError ( ) ; const lastLineId = document . lineCount - 0 ; const wholeDocument = new Range ( 0 , 0 , lastLineId , document . lineAt ( lastLineId ) . text . length , ) ; return [ TextEdit . replace ( wholeDocument , stdout ) ] ; } ) . catch ( this . showError ) ; } } function elmFormat ( document : vscode . TextDocument ) { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const formatCommand = < string > config . get ( 's' ) ; const dummyPath = path . join ( vscode . workspace . rootPath , 's' ) ; const [ _ , elmVersion ] = utils . detectProjectRootAndElmVersion ( dummyPath , vscode . workspace . rootPath , ) ; const args = utils . 0 ( elmVersion ) ? [ 's' , 's' , 's' ] : [ 's' , 's' , 's' ] ; const options = { cmdArguments : args , notFoundText : 's' , } ; const format = execCmd ( formatCommand , options ) ; format . stdin . write ( document . getText ( ) ) ; format . stdin . end ( ) ; return format ; } function clearStatus ( statusBarItem ) { return function ( ) { statusBarItem . text = 's' ; statusBarItem . hide ( ) ; } ; } function statusBarMessage ( statusBarItem ) { return function ( err ) { const message = ( < string > err . message ) . includes ( 's' ) ? 's' : 's' + "s" ; let editor = vscode . window . activeTextEditor ; if ( editor ) { statusBarItem . text = message ; statusBarItem . show ( ) ; } return ; } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StatusBarItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StatusBarItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StatusBarItem$ O O O O O O O O O O O O O O O O O O O O O O O O O $StatusBarItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as oracle from 's' ; import * as vscode from 's' ; const config = vscode . workspace . getConfiguration ( 's' ) ; export class ElmHoverProvider implements vscode . HoverProvider { public provideHover ( document : vscode . TextDocument , position : vscode . Position , token : vscode . CancellationToken , ) < vscode . Hover > { return oracle . GetOracleResults ( document , position , oracle . OracleAction . IsHover ) . then ( result => { if ( result && result . length > 0 ) { if ( result . length > 0 ) { let wordAtPosition = document . getWordRangeAtPosition ( position ) ; if ( wordAtPosition ) { let currentWord = document . getText ( wordAtPosition ) ; let exactMatches = result . filter ( item => item . name === currentWord , ) ; if ( exactMatches . length > 0 ) { result = exactMatches ; } } } let text = this . formatSig ( result [ 0 ] . signature ) + 's' + result [ 0 ] . comment ; let hover = new vscode . Hover ( config [ 's' ] ? { language : 's' , value : text } : text , ) ; return hover ; } else { return null ; } } ) ; } private formatSig ( signature ) { return ( 's' + signature . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) + 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $String$ O $String$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cp from 's' ; import * as path from 's' ; import * as utils from 's' ; import * as vscode from 's' ; import { isWindows } from 's' ; let reactor : cp . ChildProcess ; let oc : vscode . OutputChannel = vscode . window . createOutputChannel ( 's' ) ; let statusBarStopButton : vscode . StatusBarItem ; function getReactorAndArguments ( host , port , subdir , ) : [ string , string , string [ ] ] { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const dummyPath = path . join ( vscode . workspace . rootPath , 's' ) ; const 0 = 's' ; const compiler = < string > config . get ( 's' ) ; const [ cwd , elmVersion ] = utils . detectProjectRootAndElmVersion ( dummyPath , vscode . workspace . rootPath , ) ; const 0 = [ 's' + host , 's' + port ] ; const 0 = [ 's' , 's' + port ] ; const cwdWithSubdir = path . join ( cwd , subdir ) ; const args = utils . 0 ( elmVersion ) ? 0 : 0 ; const reactorCommand = utils . 0 ( elmVersion ) ? compiler : 0 ; return [ cwdWithSubdir , reactorCommand , args ] ; } function startReactor ( ) { try { stopReactor ( false ) ; const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const host = < string > config . get ( 's' ) ; const port = < string > config . get ( 's' ) ; const subdir = < string > config . get ( 's' ) ; const [ cwd , reactorCommand , args ] = getReactorAndArguments ( host , port , subdir , ) ; if ( isWindows ) { reactor = cp . exec ( reactorCommand + 's' + args . join ( 's' ) , { cwd : cwd } ) ; } else { reactor = cp . spawn ( reactorCommand , args , { cwd : cwd , detached : true } ) ; } reactor . stdout . on ( 's' , ( data ) => { if ( data && data . toString ( ) . startsWith ( 's' ) === false ) { oc . append ( data . toString ( ) ) ; } } ) ; reactor . stderr . on ( 's' , ( data ) => { if ( data ) { oc . append ( data . toString ( ) ) ; } } ) ; oc . show ( vscode . ViewColumn . Three ) ; statusBarStopButton . show ( ) ; } catch ( e ) { console . error ( 's' , e ) ; vscode . window . showErrorMessage ( 's' ) ; } } function stopReactor ( notify ) { if ( reactor ) { if ( isWindows ) { cp . spawn ( 's' , [ 's' , reactor . pid . toString ( ) , 's' , 's' ] ) ; } else { process . kill ( - reactor . pid , 's' ) ; } reactor = null ; statusBarStopButton . hide ( ) ; oc . dispose ( ) ; oc . hide ( ) ; } else { if ( notify ) { vscode . window . showInformationMessage ( 's' ) ; } } } export function activateReactor ( ) : vscode . Disposable [ ] { statusBarStopButton = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , ) ; statusBarStopButton . text = 's' ; statusBarStopButton . command = 's' ; statusBarStopButton . tooltip = 's' ; return [ vscode . commands . registerCommand ( 's' , startReactor ) , vscode . commands . registerCommand ( 's' , ( ) => stopReactor ( true ) , ) , ] ; } export function deactivateReactor ( ) { stopReactor ( false ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O
import * as vscode from 's' ; import * as path from 's' ; import * as utils from 's' ; import { TextEditor , window , workspace } from 's' ; let replTerminal : vscode . Terminal ; function getElmRepl ( ) { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const dummyPath = path . join ( vscode . workspace . rootPath , 's' ) ; const 0 = 's' ; const compiler = < string > config . get ( 's' ) ; const [ cwd , elmVersion ] = utils . detectProjectRootAndElmVersion ( dummyPath , vscode . workspace . rootPath , ) ; const replCommand = utils . 0 ( elmVersion ) ? `template` : 0 ; return replCommand ; } function startRepl ( ) { try { let replCommand = getElmRepl ( ) ; if ( replTerminal !== undefined ) { replTerminal . dispose ( ) ; } replTerminal = window . createTerminal ( 's' ) ; let [ replLaunchCommand , clearCommand ] = utils . getTerminalLaunchCommands ( replCommand , ) ; replTerminal . sendText ( clearCommand , true ) ; replTerminal . sendText ( replLaunchCommand , true ) ; replTerminal . show ( true ) ; } catch ( error ) { vscode . window . showErrorMessage ( 's' + error ) ; } } function send ( editor , msg ) { if ( editor . document . languageId !== 's' ) { return ; } if ( replTerminal === undefined ) { startRepl ( ) ; } const inputMsg = msg . replace ( "s" , 's' ) + 's' ; replTerminal . sendText ( 's' , false ) ; replTerminal . sendText ( inputMsg , false ) ; } function sendLine ( editor ) { send ( editor , editor . document . lineAt ( editor . selection . start ) . text ) ; } function sendSelection ( editor : vscode . TextEditor ) { send ( editor , editor . document . getText ( editor . selection ) ) ; } function sendFile ( editor : vscode . TextEditor ) { send ( editor , editor . document . getText ( ) ) ; } vscode . window . onDidCloseTerminal ( terminal => { if ( terminal . name === 's' ) { replTerminal = undefined ; } } ) ; export function activateRepl ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerCommand ( 's' , ( ) => startRepl ( ) ) , vscode . commands . registerTextEditorCommand ( 's' , sendLine ) , vscode . commands . registerTextEditorCommand ( 's' , sendSelection , ) , vscode . commands . registerTextEditorCommand ( 's' , sendFile ) , ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextEditor$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextEditor$ O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cp from 's' ; import * as path from 's' ; import * as utils from 's' ; import * as elmTest from 's' ; import * as vscode from 's' ; let make : cp . ChildProcess ; let oc : vscode . OutputChannel = vscode . window . createOutputChannel ( 's' ) ; function getMakeAndArguments ( file , warn ) : [ string , string , string [ ] ] { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const name = < string > config . get ( 's' ) ; const 0 = < string > config . get ( 's' ) ; const compiler = < string > config . get ( 's' ) ; const elmTestCompiler = < string > config . get ( 's' ) ; const [ cwd , elmVersion ] = utils . detectProjectRootAndElmVersion ( file , vscode . workspace . rootPath , ) ; const specialFile = < string > config . get ( 's' ) ; const isTestFile = elmTest . fileIsTestFile ( file ) ; if ( specialFile . length > 0 ) { file = path . resolve ( cwd , specialFile ) ; } if ( utils . isWindows ) { file = 's' + file + 's' ; } const 0 = [ file , 's' , 's' + name ] ; if ( warn ) { 0 . push ( 's' ) ; } const 0 = [ 's' , file , 's' + name ] ; const args = utils . 0 ( elmVersion ) ? 0 : 0 ; const makeCommand = utils . 0 ( elmVersion ) ? isTestFile ? elmTestCompiler : compiler : 0 ; return [ cwd , makeCommand , args ] ; } function execMake ( editor : vscode . TextEditor , warn ) { try { if ( editor . document . languageId !== 's' ) { return ; } if ( make ) { make . kill ( ) ; oc . clear ( ) ; } let file = editor . document . fileName ; let [ cwd , makeCommand , args ] = getMakeAndArguments ( file , warn ) ; if ( utils . isWindows ) { make = cp . exec ( makeCommand + 's' + args . join ( 's' ) , { cwd : cwd } ) ; } else { make = cp . spawn ( makeCommand , args , { cwd : cwd } ) ; } make . stdout . on ( 's' , ( data ) => { if ( data ) { oc . append ( data . toString ( ) ) ; } } ) ; make . stderr . on ( 's' , ( data ) => { if ( data ) { oc . append ( data . toString ( ) ) ; } } ) ; oc . show ( vscode . ViewColumn . Three ) ; } catch ( e ) { console . error ( 's' , e ) ; vscode . window . showErrorMessage ( 's' ) ; } } function runMake ( editor : vscode . TextEditor ) { execMake ( editor , false ) ; } function runMakeWarn ( editor : vscode . TextEditor ) { execMake ( editor , true ) ; } export function activateMake ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerTextEditorCommand ( 's' , runMake ) , vscode . commands . registerTextEditorCommand ( 's' , runMakeWarn ) , ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; import * as path from 's' ; import * as utils from 's' ; const request = require ( 's' ) ; let packageTerminal : vscode . Terminal ; function getInstallPackageCommand ( packageName ) { const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const dummyPath = path . join ( vscode . workspace . rootPath , 's' ) ; const [ _ , elmVersion ] = utils . detectProjectRootAndElmVersion ( dummyPath , vscode . workspace . rootPath , ) ; const 0 = 's' + packageName + 's' ; const 0 = 's' + packageName ; const args = utils . 0 ( elmVersion ) ? 0 : 0 ; return args ; } function browsePackage ( ) < void > { const quickPickPackageOptions : vscode . QuickPickOptions = { matchOnDescription : true , placeHolder : 's' , } ; const quickPickVersionOptions : vscode . QuickPickOptions = { matchOnDescription : false , placeHolder : 's' , } ; return getJSON ( ) . then ( transformToPackageQuickPickItems ) . then ( packages => vscode . window . showQuickPick ( packages , quickPickPackageOptions ) , ) . then ( selectedPackage => { if ( selectedPackage === undefined ) { return ; } return vscode . window . showQuickPick ( transformToPackageVersionQuickPickItems ( selectedPackage ) , quickPickVersionOptions , ) . then ( selectedVersion => { let uri = selectedVersion ? vscode . Uri . parse ( 's' + selectedPackage . label + 's' + selectedVersion . label , ) : vscode . Uri . parse ( 's' + selectedPackage . label + 's' , ) ; vscode . commands . executeCommand ( 's' , uri ) ; } ) . then ( ( ) => { } ) ; } ) ; } interface ElmPackageQuickPickItem extends vscode . QuickPickItem { info : any ; } function transformToPackageQuickPickItems ( packages : any [ ] , ) : ElmPackageQuickPickItem [ ] { return Object . keys ( packages ) . map ( item => { return { label : item , description : item , info : packages [ item ] } ; } ) ; } function transformToPackageVersionQuickPickItems ( selectedPackage , ) : vscode . QuickPickItem [ ] { return selectedPackage . info . map ( version => { return { label : version , description : null } ; } ) ; } function runInstall ( ) < void > { const quickPickOptions : vscode . QuickPickOptions = { matchOnDescription : true , placeHolder : 's' , } ; return getJSON ( ) . then ( transformToQuickPickItems ) . then ( items => vscode . window . showQuickPick ( items , quickPickOptions ) ) . then ( value => { const packageName = value ? value . label : 's' ; return installPackageInTerminal ( packageName ) ; } ) ; } function installPackageInTerminal ( packageToInstall ) { try { let installPackageCommand = getInstallPackageCommand ( packageToInstall ) ; if ( packageTerminal !== undefined ) { packageTerminal . dispose ( ) ; } packageTerminal = vscode . window . createTerminal ( 's' ) ; let [ installPackageLaunchCommand , clearCommand , ] = utils . getTerminalLaunchCommands ( installPackageCommand ) ; packageTerminal . sendText ( clearCommand , true ) ; packageTerminal . sendText ( installPackageLaunchCommand , true ) ; packageTerminal . show ( false ) ; } catch ( error ) { vscode . window . showErrorMessage ( 's' + error , ) ; } } function getJSON ( ) < any [ ] > { return new Promise ( ( resolve , reject ) => { request ( 's' , ( err , _ , body ) => { if ( err ) { reject ( err ) ; } else { let json ; try { json = JSON . parse ( body ) ; } catch ( e ) { reject ( e ) ; } resolve ( json ) ; } } ) ; } ) ; } function transformToQuickPickItems ( packages : any [ ] ) : vscode . QuickPickItem [ ] { return Object . keys ( packages ) . map ( item => { return { label : item , description : 's' , info : packages [ item ] } ; } ) ; } vscode . window . onDidCloseTerminal ( terminal => { if ( terminal . name === 's' ) { packageTerminal = undefined ; } } ) ; export function activatePackage ( ) : vscode . Disposable [ ] { return [ vscode . commands . registerCommand ( 's' , runInstall ) , vscode . commands . registerCommand ( 's' , browsePackage ) , ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElmPackageQuickPickItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; import { ElmCodeActionProvider , activateCodeActions } from 's' ; import { ElmFormatProvider } from 's' ; import { ElmRangeFormatProvider } from 's' ; import { activateReactor , deactivateReactor } from 's' ; import { ElmCompletionProvider } from 's' ; import { runLinter , IElmIssue } from 's' ; import { activateRepl } from 's' ; import { activateMake } from 's' ; import { activatePackage } from 's' ; import { activateClean } from 's' ; import { ElmAnalyse } from 's' ; import { ElmDefinitionProvider } from 's' ; import { ElmHoverProvider } from 's' ; import { ElmSymbolProvider } from 's' ; import { ElmWorkspaceSymbolProvider } from 's' ; import { configuration } from 's' ; const ELM_MODE : vscode . DocumentFilter = { language : 's' , scheme : 's' } ; const config : vscode . WorkspaceConfiguration = vscode . workspace . getConfiguration ( 's' , ) ; const disableLinter = < boolean > config . get ( 's' ) ; const elmAnalyseIssues : IElmIssue [ ] = [ ] ; const elmAnalyse = new ElmAnalyse ( elmAnalyseIssues ) ; export function activate ( ctx : vscode . ExtensionContext ) { const elmFormatStatusBar = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , ) ; if ( ! disableLinter ) { ctx . subscriptions . push ( vscode . workspace . onDidSaveTextDocument ( ( document : vscode . TextDocument ) => { runLinter ( document , elmAnalyse ) ; } , ) , ) ; } activateRepl ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) ) ; activateReactor ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) , ) ; activateMake ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) ) ; activatePackage ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) , ) ; activateClean ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) ) ; activateCodeActions ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) , ) ; elmAnalyse . activateAnalyse ( ) . forEach ( ( d : vscode . Disposable ) => ctx . subscriptions . push ( d ) ) ; let workspaceProvider = new ElmWorkspaceSymbolProvider ( ELM_MODE ) ; ctx . subscriptions . push ( vscode . languages . setLanguageConfiguration ( 's' , configuration ) , ) ; ctx . subscriptions . push ( vscode . languages . registerHoverProvider ( ELM_MODE , new ElmHoverProvider ( ) ) , ) ; ctx . subscriptions . push ( vscode . languages . registerCompletionItemProvider ( ELM_MODE , new ElmCompletionProvider ( ) , 's' , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerDocumentSymbolProvider ( ELM_MODE , new ElmSymbolProvider ( ) , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerDefinitionProvider ( ELM_MODE , new ElmDefinitionProvider ( ELM_MODE , workspaceProvider ) , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerCodeActionsProvider ( ELM_MODE , new ElmCodeActionProvider ( ) , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerDocumentFormattingEditProvider ( ELM_MODE , new ElmFormatProvider ( elmFormatStatusBar ) , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerDocumentRangeFormattingEditProvider ( ELM_MODE , new ElmRangeFormatProvider ( elmFormatStatusBar ) , ) , ) ; ctx . subscriptions . push ( vscode . languages . registerWorkspaceSymbolProvider ( workspaceProvider ) , ) ; vscode . workspace . onDidSaveTextDocument ( ( document : vscode . TextDocument ) => { if ( document === vscode . window . activeTextEditor . document && document . languageId === ELM_MODE . language && document . uri . scheme === ELM_MODE . scheme ) { workspaceProvider . update ( document ) ; } } ) ; } export function deactivate ( ) { deactivateReactor ( ) ; elmAnalyse . deactivateAnalyse ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { execCmd , isWindows } from 's' ; import { commands } from 's' ; suite ( 's' , ( ) => { test ( 's' , function ( ) { this . timeout ( 0 ) ; return commands . executeCommand ( 's' ) . then ( wait ( 0 ) ) . then ( ( ) => checkForProcess ( 's' , true ) ) . then ( ( ) => commands . executeCommand ( 's' ) ) . then ( wait ( 0 ) ) . then ( ( ) => checkForProcess ( 's' , false ) ) ; } ) ; } ) ; const wait = ( ms ) => < T > ( value : T ) => new Promise < T > ( resolve => setTimeout ( ( ) => resolve ( value ) , ms ) ) ; function checkForProcess ( processName , isRunning ) { const cmd = isWindows ? 's' : 's' , expected = isRunning ? 0 : 0 ; return execCmd ( cmd ) . then ( ( { stdout } ) => { const matches = stdout . split ( 's' ) . filter ( line => line . startsWith ( processName ) ) . length ; assert . equal ( matches , expected , `template` ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' import { commands } from 's' ; import { execCmd , isWindows } from 's' ; suite ( "s" , ( ) => { test ( "s" , function ( ) { this . timeout ( 0 ) ; return commands . executeCommand ( 's' ) . then ( wait ( 0 ) ) . then ( ( ) => checkForProcess ( 's' , true ) ) } ) ; } ) ; const wait = ( ms ) => < T > ( value : T ) => new Promise < T > ( resolve => setTimeout ( ( ) => resolve ( value ) , ms ) ) ; function checkForProcess ( processName , isRunning ) { const cmd = isWindows ? 's' : 's' , expected = isRunning ? 0 : 0 ; return execCmd ( cmd ) . then ( ( { stdout } ) => { const matches = stdout . split ( 's' ) . filter ( line => line . startsWith ( processName ) ) . length ; assert . equal ( matches , expected , `template` ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as path from 's' ; import { Range , SymbolInformation , SymbolKind , workspace } from 's' ; import { ElmSymbolProvider } from 's' ; import * as _ from 's' ; suite ( 's' , ( ) => { const symbolProvider = new ElmSymbolProvider ( ) ; test ( 's' , async ( ) => { const filePath = path . join ( __dirname , 's' ) ; const textDocument = await workspace . openTextDocument ( filePath ) ; const actualSymbols = await symbolProvider . provideDocumentSymbols ( textDocument ) ; assert . deepEqual ( actualSymbols , [ ] ) ; } ) ; test ( 's' , async ( ) => { const filePath = path . join ( __dirname , 's' ) ; const textDocument = await workspace . openTextDocument ( filePath ) ; const expectedSymbols : SymbolInformation [ ] = [ new SymbolInformation ( 's' , SymbolKind . Module , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Class , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Class , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Constructor , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Constructor , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Variable , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Variable , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Interface , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , new SymbolInformation ( 's' , SymbolKind . Variable , new Range ( 0 , 0 , 0 , 0 ) , textDocument . uri , 's' ) , ] ; const actualSymbols = await symbolProvider . provideDocumentSymbols ( textDocument ) ; assert . deepEqual ( _ . orderBy ( actualSymbols , x => x . name ) , _ . orderBy ( expectedSymbols , x => x . name ) , ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as path from 's' ; import * as vscode from 's' ; import { execCmd , findProj } from 's' ; import { window } from 's' ; suite ( 's' , ( ) => { suite ( 's' , ( ) => { test ( 's' , ( ) => { return execCmd ( 's' ) . then ( ( ) => { assert . fail ( 0 , 0 , 's' , 's' ) ; } , ( ) => { } , ) ; } ) ; test ( 's' , ( done ) => { let shownMsg , _showErrorMessage = window . showErrorMessage ; window . showErrorMessage = function ( msg ) { shownMsg = msg ; return Promise . resolve ( undefined ) ; } ; execCmd ( 's' , { showMessageOnError : true } ) . then ( ( ) => { assert . fail ( 0 , 0 , 's' , 's' ) ; } , ( ) => { assert . fail ( 0 , 0 , 's' , 's' ) ; } , ) . catch ( e => { throw e ; } ) ; setTimeout ( ( ) => { assert . equal ( shownMsg , 's' ) ; window . showErrorMessage = _showErrorMessage ; done ( ) ; } , 0 ) ; } ) ; } ) ; } ) ; suite ( 's' , ( ) => { test ( 's' , ( ) => { let expected = path . join ( __dirname , 's' ) ; let check = ( p ) => { let resolvedDir = path . join ( __dirname , 's' , p ) ; return findProj ( resolvedDir ) ; } ; assert . equal ( check ( 's' ) , expected ) ; assert . equal ( check ( 's' ) , expected ) ; assert . equal ( check ( 's' ) , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
var testRunner = require ( 's' ) ; testRunner . configure ( { ui : 's' , useColors : true } ) ; module . exports = testRunner ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O