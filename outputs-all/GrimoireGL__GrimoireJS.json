'js' const fs = require ( "s" ) ; fs . readFile ( "s" , "s" , ( err , data ) => { if ( err ) { console . error ( err ) ; process . exit ( 0 ) ; } else { const version = JSON . parse ( data ) . version ; fs . readFile ( "s" , "s" , ( err , original ) => { if ( err ) { console . error ( err ) ; process . exit ( 0 ) ; } else { const replaced = original . replace ( "s" , `template` ) ; fs . writeFile ( "s" , replaced , ( err , data ) => { if ( err ) { console . error ( err ) ; process . exit ( 0 ) ; } } ) ; } } ) ; } } ) ;	O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $JSON$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O
class IDObject { public id : string ; public static getUniqueRandom ( length ) { return Math . random ( ) . toString ( 0 ) . slice ( - length ) ; } constructor ( ) { this . id = IDObject . getUniqueRandom ( 0 ) ; } public toString ( ) { return this . getTypeName ( ) ; } public getTypeName ( ) { const funcNameRegex = "s" ; const result = ( funcNameRegex ) . exec ( ( this ) . constructor . toString ( ) ) ; return ( result && result . length > 0 ) ? result [ 0 ] : "s" ; } } export default IDObject ;	O $any$ O O $string$ O O O O O $string$ O $number$ O O O $Math$ O $number$ O O O $string$ O O O O $string$ O O $number$ O O O O O O O O O $string$ O $any$ O $string$ O O O O O O $string$ O O O O O O $string$ O O O O O $string$ O O O O $RegExp$ O O O O $RegExpExecArray$ O O $RegExp$ O O $RegExpExecArray$ O O O O O $Function$ O $string$ O O O O O O $RegExpExecArray$ O $RegExpExecArray$ O $number$ O O O O $RegExpExecArray$ O O O O O O O O O O $any$ O
import { EventEmitter , ListenerFn } from "s" ; import IDObject from "s" ; class EEObject extends IDObject implements EventEmitter { public eventNames : ( ) => Array < string | symbol > ; public listeners : ( ( event : string | symbol , exists ) => Array < ListenerFn > | boolean ) & ( ( event : string | symbol ) => Array < ListenerFn > ) ; public emit : ( event : string | symbol , ... args < any > ) => boolean ; public on : ( event : string | symbol , fn , context ? ) => this ; public addListener : ( event : string | symbol , fn , context ? ) => this ; public once : ( event : string | symbol , fn , context ? ) => this ; public removeListener : ( event : string | symbol , fn ? , context ? , once ? ) => this ; public off : ( event : string | symbol , fn ? , context ? , once ? ) => this ; public removeAllListeners : ( event ? : string | symbol ) => this ; constructor ( ) { super ( ) ; EventEmitter . call ( this ) ; } } function applyMixins ( derivedCtor , baseCtors : any [ ] ) { baseCtors . forEach ( ( baseCtor ) => { Object . getOwnPropertyNames ( baseCtor . prototype ) . forEach ( ( name ) => { derivedCtor . prototype [ name ] = baseCtor . prototype [ name ] ; } ) ; } ) ; } applyMixins ( EEObject , [ EventEmitter ] ) ; export default EEObject ;	O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $complex$ O O O O $ArrayConstructor$ O O O O O O O $any[])$ O O O $complex$ O O O O O $boolean$ O O $ArrayConstructor$ O $any$ O O O O O O O $complex$ O O O O O O $ArrayConstructor$ O $any$ O O O O $boolean$ O O $complex$ O O O O O O $Array$ O O O O O O O O $this$ O O $complex$ O O O O O $ListenerFn$ O $any$ $any$ O O O O O $this$ O O $complex$ O O O O O $ListenerFn$ O $any$ $any$ O O O O O $this$ O O $complex$ O O O O O $ListenerFn$ O $any$ $any$ O O O O O $this$ O O $complex$ O O O O O $any$ $ListenerFn$ O $any$ $any$ O $boolean$ $boolean$ O O O O O $this$ O O $complex$ O O O O O $any$ $ListenerFn$ O $any$ $any$ O $boolean$ $boolean$ O O O O O $this$ O O $complex$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O $void$ O $any$ O $any[]$ O O O O O O $any[]$ O $void$ O O $any$ O O O $ObjectConstructor$ O $string[]$ O $any$ O $any$ O O $void$ O O $string$ O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O O O O $void$ O $any$ O O $any$ O O O O O $any$ O
import NSIdentity from "s" ; import Utility from "s" ; export default class Namespace { private _ns : string [ ] ; public static define ( ... name : string [ ] ) { return Namespace . defineByArray ( name ) ; } public static defineByArray ( name : string [ ] ) { return new Namespace ( Utility . flat ( name . map ( n => n . split ( "s" ) ) ) ) ; } public get hierarchy ( ) : string [ ] { return this . _ns ; } public get qualifiedName ( ) : string { return this . _ns . join ( "s" ) ; } public extend ( extension ) { return new Namespace ( this . _ns . concat ( [ extension ] ) ) ; } public for ( name ) { return NSIdentity . fromFQN ( this , name ) ; } public toString ( ) { return this . qualifiedName ; } private constructor ( names : string [ ] ) { this . _ns = names ; } }	O $any$ O O O O $any$ O O O O O O $any$ O O $string[]$ O O O O O O O $Namespace$ O O $string[]$ O O O O O O O $any$ O $Namespace$ O $string[]$ O O O O O $Namespace$ O $string[]$ O O O O O O O O $any$ O $any$ O $T[]$ O $string[]$ O $U[]$ O $string$ O $string$ O $complex$ O O O O O O O O O O $string[]$ O O O O O O O O O O $string[]$ O O O O $string$ O O O O O O O O $string[]$ O $string$ O O O O O O $Namespace$ O $string$ O O O O $any$ O O O $string[]$ O $complex$ O O $string$ O O O O O O $NSIdentity$ O $string$ O O O $any$ O $complex$ O O O $string$ O O O O $string$ O O O O O O $string$ O O O O O $string[]$ O O O O O O O O $string[]$ O $string[]$ O O O
import Namespace from "s" ; import NSIdentity from "s" ; export default class IdResolver { private _nameMap : { [ name ] : IdResolver } = { } ; private _FQNSet : Set < string > = new Set ( ) ; private _isTerminal = false ; public get count ( ) : number { return this . _FQNSet . size ; } public add ( id : string [ ] | NSIdentity ) { if ( ! id ) { throw new Error ( `template` ) ; } if ( id instanceof NSIdentity ) { id = id . ns . hierarchy . concat ( [ id . name ] ) ; } if ( id . length === 0 ) { return false ; } return this . _add ( id ) ; } public get ( ns : Namespace | string ) : string [ ] { if ( typeof ns === "s" ) { return this . get ( Namespace . defineByArray ( ns . split ( "s" ) ) ) ; } const name = ns . hierarchy ; let current_name = name [ name . length - 0 ] ; if ( ! this . _nameMap [ current_name ] ) { return [ ] ; } let pathes = this . _nameMap [ current_name ] . _get ( name . slice ( 0 , name . length - 0 ) ) ; const res = [ ] ; for ( let i = 0 ; i < pathes . length ; i ++ ) { let a = pathes [ i ] ; a . push ( current_name ) ; res . push ( a . join ( "s" ) ) ; } return res ; } public resolve ( name : Namespace | string ) { if ( typeof name === "s" ) { return this . resolve ( Namespace . defineByArray ( name . split ( "s" ) ) ) ; } let pathes = this . get ( name ) ; if ( pathes . length === 0 ) { throw new Error ( `template` ) ; } if ( pathes . length > 0 ) { throw new Error ( `template` ) ; } return pathes [ 0 ] ; } public has ( name ) { return ! ! this . _nameMap [ name ] ; } public remove ( name ) { const fqn = name . fqn . split ( "s" ) ; this . _remove ( fqn ) ; } public foreach ( callback : ( fqn ) => void ) { this . _FQNSet . forEach ( callback ) ; } private _remove ( name : string [ ] ) { if ( name . length === 0 ) { this . _nameMap [ name [ 0 ] ] . _isTerminal = false ; } else { const next = this . _nameMap [ name [ name . length - 0 ] ] ; next . _remove ( name . slice ( 0 , name . length - 0 ) ) ; } } private _get ( name : string [ ] ) : string [ ] [ ] { const res : string [ ] [ ] = [ ] ; if ( name . length === 0 ) { if ( this . count === 0 ) { return [ [ ] ] ; } for ( let key in this . _nameMap ) { let match = this . _nameMap [ key ] . _get ( [ ] ) ! ; for ( let i = 0 ; i < match . length ; i ++ ) { let m = match [ i ] ; m . push ( key ) ; res . push ( m ) ; } } if ( this . _isTerminal ) { res . push ( [ ] ) ; } return res ; } let current_name = name [ name . length - 0 ] ; for ( let key in this . _nameMap ) { let match = key === current_name ? this . _nameMap [ key ] . _get ( name . slice ( 0 , name . length - 0 ) ) : this . _nameMap [ key ] . _get ( name ) ; if ( match . length !== 0 ) { for ( let i = 0 ; i < match . length ; i ++ ) { let m = match [ i ] ; m . push ( key ) ; res . push ( m ) ; } } } return res ; } private _add ( id : string [ ] ) { const fqn = id . join ( "s" ) ; if ( this . _FQNSet . has ( fqn ) ) { return false ; } this . _FQNSet . add ( fqn ) ; if ( ! this . _nameMap [ id [ id . length - 0 ] ] ) { this . _nameMap [ id [ id . length - 0 ] ] = new IdResolver ( ) ; } const next = id . slice ( 0 , id . length - 0 ) ; if ( next . length === 0 ) { this . _nameMap [ id [ id . length - 0 ] ] . _isTerminal = true ; } else { this . _nameMap [ id [ id . length - 0 ] ] . add ( next ) ; } return true ; } }	O $any$ O O O O $any$ O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O $Set<string>$ O $SetConstructor$ O O O O O $SetConstructor$ O O O O $boolean$ O O O O O $number$ O O O O O O O O $Set<string>$ O $number$ O O O $boolean$ O $complex$ O O O O O $any$ O O O O O $complex$ O O O O $ErrorConstructor$ O O O O O O O $complex$ O $any$ O O $complex$ O $NSIdentity$ O $Namespace$ O $string[]$ O $complex$ O O $NSIdentity$ O $string$ O O O O O O $string[]$ O $number$ O O O O O O O O O O O $boolean$ O $string[]$ O O O O $string[]$ O $complex$ O $any$ O O O O O O O O O O O $complex$ O O O O O O O $string[]$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O O O $string[]$ O $Namespace$ O $string[]$ O O $string$ O $string[]$ O $string[]$ O $number$ O O O O O O O O O $complex$ O $string$ O O O O O O O O O $string[][]$ O O O $complex$ O $string$ O O $string[][]$ O $string[]$ O $string[]$ O O O $string[]$ O $number$ O O O O O O $any[]$ O O O O O O O $number$ O O O $number$ O $string[][]$ O $number$ O $number$ O O O O $string[]$ O $string[][]$ O $number$ O O $string[]$ O $number$ O $string$ O O $any[]$ O $number$ O $string[]$ O $string$ O O O O O O O $any[]$ O O O $string$ O $complex$ O $any$ O O O O O O O $complex$ O O O O O O O $string$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O O O $string[]$ O O O $string[]$ O $Namespace$ O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O $string[]$ O O O O O O $boolean$ O $string$ O O O O O O O $complex$ O $string$ O O O O $void$ O $NSIdentity$ O O O $string[]$ O $NSIdentity$ O $string$ O $complex$ O O O O O O $void$ O $string[]$ O O O O $void$ O $void$ O O $string$ O O O O O O O $Set<string>$ O O O $void$ O O O O $void$ O $string[]$ O O O O O O O O $string[]$ O $number$ O O O O O O $complex$ O $string[]$ O O O O O $boolean$ O O O O O O O $IdResolver$ O O O $complex$ O $string[]$ O $string[]$ O $number$ O O O O O $IdResolver$ O $void$ O $string[]$ O $string[]$ O O O $string[]$ O $number$ O O O O O O O O $string[][]$ O $string[]$ O O O O O O O O O O O O O $string[][]$ O O O O O O O O O O O O $string[]$ O $number$ O O O O O O O O $number$ O O O O O O O O O O O O O O $string$ O O O $complex$ O O O $string[][]$ O O O $complex$ O $string$ O O $string[][]$ O O O O O O O O O $number$ O O O $number$ O $string[][]$ O $number$ O $number$ O O O O $string[]$ O $string[][]$ O $number$ O O $string[]$ O $number$ O $string$ O O $string[][]$ O $number$ O $string[]$ O O O O O O O O $boolean$ O O $string[][]$ O $number$ O O O O O O O $string[][]$ O O O $string$ O $string[]$ O $string[]$ O $number$ O O O O O O O $string$ O O O $complex$ O O O $string[][]$ O $string$ O $string$ O O O $complex$ O $string$ O O $string[][]$ O $string[]$ O $string[]$ O O O $string[]$ O $number$ O O O O O O O $complex$ O $string$ O O $string[][]$ O $string[]$ O O O O $string[][]$ O $number$ O O O O O O O $number$ O O O $number$ O $string[][]$ O $number$ O $number$ O O O O $string[]$ O $string[][]$ O $number$ O O $string[]$ O $number$ O $string$ O O $string[][]$ O $number$ O $string[]$ O O O O O O $string[][]$ O O O $boolean$ O $string[]$ O O O O O O O $string$ O $string[]$ O $string$ O O O O O O O O $Set<string>$ O $boolean$ O $string$ O O O O O O O O O $Set<string>$ O $Set<string>$ O $string$ O O O O O O O $complex$ O $string[]$ O $string[]$ O $number$ O O O O O O O O $complex$ O $string[]$ O $string[]$ O $number$ O O O O O O $any$ O O O O O $string[]$ O $string[]$ O $string[]$ O O O $string[]$ O $number$ O O O O O O $string[]$ O $number$ O O O O O O $complex$ O $string[]$ O $string[]$ O $number$ O O O O O $boolean$ O O O O O O O O $complex$ O $string[]$ O $string[]$ O $number$ O O O O O $boolean$ O $string[]$ O O O O O O O O
import Namespace from "s" ; import IdResolver from "s" ; export default class NSIdentity { private static _instances : { [ fqn ] : NSIdentity } = { } ; private static _mapBackingField : IdResolver ; private static get _map ( ) : IdResolver { if ( this . _mapBackingField === void 0 ) { this . _mapBackingField = new IdResolver ( ) ; } return this . _mapBackingField ; } private _ns : Namespace ; private _name : string ; private _fqn : string ; public static fromFQN ( fqn ) ; public static fromFQN ( qn , name ) ; public static fromFQN ( fqn : string | Namespace , name ? ) { const hierarchy = NSIdentity . _ensureQNTobeArray ( fqn , name ) ; fqn = hierarchy . join ( "s" ) ; const inst = NSIdentity . _instances [ fqn ] ; if ( inst ) { return inst ; } const splitted = fqn . split ( "s" ) ; return new NSIdentity ( splitted ) ; } public static guess ( ... hierarchy : string [ ] ) { return NSIdentity . _from ( hierarchy ) ; } public static clear ( ) { NSIdentity . _instances = { } ; NSIdentity . _mapBackingField = new IdResolver ( ) ; } private static _from ( hierarchy : string [ ] ) { const fqn = hierarchy . join ( "s" ) ; const inst = NSIdentity . _instances [ fqn ] ; if ( inst ) { return inst ; } return NSIdentity . fromFQN ( NSIdentity . _map . resolve ( Namespace . defineByArray ( hierarchy ) ) ) ; } private static _ensureQNTobeArray ( 0 : string | string [ ] | Namespace , name ? ) : string [ ] { if ( name ) { return NSIdentity . _ensureQNTobeArray ( ( 0 as Namespace ) . extend ( name ) ) ; } if ( typeof 0 === "s" ) { return 0 . split ( "s" ) ; } if ( Array . isArray ( 0 ) ) { return 0 ; } return 0 . hierarchy ; } public constructor ( fqn : string | string [ ] ) ; public constructor ( qn : string [ ] , n ) ; public constructor ( qn : string | string [ ] , n ? ) { if ( typeof qn === "s" ) { qn = qn . split ( "s" ) ; } if ( n ) { this . _ns = Namespace . defineByArray ( qn ) ; this . _name = n ; } else { this . _name = qn [ qn . length - 0 ] ; qn = qn . slice ( 0 , qn . length - 0 ) ; this . _ns = Namespace . defineByArray ( qn ) ; } this . _fqn = this . ns . hierarchy . concat ( [ this . name ] ) . join ( "s" ) ; NSIdentity . _instances [ this . _fqn ] = this ; NSIdentity . _map . add ( qn . concat ( [ this . _name ] ) ) ; } public get ns ( ) : Namespace { return this . _ns ; } public get name ( ) : string { return this . _name ; } public get fqn ( ) : string { return this . _fqn ; } public toString ( ) { return this . fqn ; } }	O $any$ O O O O $any$ O O O O O O $any$ O O O $complex$ O O O $string$ O O $any$ O O O O O O O $IdResolver$ O $any$ O O O O $IdResolver$ O O O $any$ O O O O O $IdResolver$ O O O O O O O $IdResolver$ O O $any$ O O O O O O O $IdResolver$ O O O $Namespace$ O $any$ O O $string$ O O O O $string$ O O O O O $NSIdentity$ O $string$ O O O O $NSIdentity$ O $Namespace$ O $string$ O O O O $NSIdentity$ O $complex$ O O O $any$ O $string$ $string$ O O O $string[]$ O $any$ O O O $complex$ O $string$ O O $complex$ O $string[]$ O $string$ O O O O O $NSIdentity$ O $any$ O $complex$ O $string$ O O O O $NSIdentity$ O O O $NSIdentity$ O O O $string[]$ O $string$ O $complex$ O O O O O O $any$ O $string[]$ O O O O O $NSIdentity$ O O $string[]$ O O O O O O O $any$ O $NSIdentity$ O $string[]$ O O O O O $void$ O O O $any$ O $complex$ O O O O $any$ O $IdResolver$ O O $any$ O O O O O O $NSIdentity$ O $string[]$ O O O O O O O $string$ O $string[]$ O $string$ O O O O O $NSIdentity$ O $any$ O $complex$ O $string$ O O O O $NSIdentity$ O O O $NSIdentity$ O O O $any$ O $complex$ O $any$ O $IdResolver$ O $string$ O $any$ O $Namespace$ O $string[]$ O O O O O O O O O $complex$ O O O O O O O $any$ O $string$ $string$ O O O O O O O O $string$ O O O $any$ O O O O $complex$ O $any$ O O $Namespace$ O $string$ O O O O O O O $complex$ O O O O O $string$ O $complex$ O O O O O O O $ArrayConstructor$ O $complex$ O $complex$ O O O O $string[]$ O O O $Namespace$ O $string[]$ O O O O O $complex$ O O O O O O O O O O O $string[]$ O O O O O $string$ O O O O O $complex$ O O O O O O O $string$ $string$ O O O O O $complex$ O O O O $complex$ O $string$ O $complex$ O O O O O O O $string$ O O O O $Namespace$ O $any$ O $Namespace$ O $string[]$ O O O O $string$ O $string$ O O O O O O $string$ O $string[]$ O $string[]$ O $number$ O O O O $complex$ O $string[]$ O $string[]$ O O O $string[]$ O $number$ O O O O O O $Namespace$ O $any$ O $Namespace$ O $string[]$ O O O O O $string$ O O O $Namespace$ O $string[]$ O $complex$ O O O O $string$ O O O $string$ O O O O $any$ O $complex$ O O O $string$ O O O O $any$ O $IdResolver$ O $boolean$ O $string[]$ O $complex$ O O O O $string$ O O O O O O O $Namespace$ O O O $any$ O O O O $Namespace$ O O O O $string$ O O O O O O O O $string$ O O O O $string$ O O O O O O O O $string$ O O O $string$ O O O O O O $string$ O O O
export default class Constants { public static get defaultNamespace ( ) : string { return "s" ; } public static get x_gr_id ( ) : string { return "s" ; } }	O O O $any$ O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O
import { Nullable } from "s" ; class XMLReader { private static _parser : DOMParser = new DOMParser ( ) ; public static parseXML ( doc , rootElementName ? ) : Element [ ] { const parsed = XMLReader . _parser . parseFromString ( doc as string , "s" ) ; if ( ! parsed || parsed . getElementsByTagName ( "s" ) . length > 0 ) { const err = new XMLSerializer ( ) . serializeToString ( parsed ) ; throw new Error ( `template` ) ; } if ( rootElementName ) { if ( parsed . documentElement . tagName . toUpperCase ( ) !== rootElementName . toUpperCase ( ) ) { throw new Error ( "s" ) ; } } return [ parsed . documentElement ] ; } public static getElements ( elem , name ) : Element [ ] { const result : Element [ ] = [ ] ; const elems = elem . getElementsByTagName ( name ) ; for ( let i = 0 ; i < elems . length ; i ++ ) { result . push ( elems . item ( i ) ) ; } return result ; } public static getSingleElement ( elem , name , mandatory ? ) < Element > { const result = XMLReader . getElements ( elem , name ) ; if ( result . length === 0 ) { return result [ 0 ] ; } else if ( result . length === 0 ) { if ( mandatory ) { throw new Error ( `template` ) ; } else { return null ; } } else { throw new Error ( `template` ) ; } } public static getAttribute ( elem , name , mandatory ? ) < string > { const result = elem . attributes . getNamedItem ( name ) ; if ( result ) { return result . value ; } else if ( mandatory ) { throw new Error ( `template` ) ; } else { return null ; } } public static getAttributeFloat ( elem , name , mandatory ? ) < number > { const resultStr = XMLReader . getAttribute ( elem , name , mandatory ) ; return resultStr ? parseFloat ( resultStr ) : null ; } public static getAttributeInt ( elem , name , mandatory ? ) < number > { const resultStr = XMLReader . getAttribute ( elem , name , mandatory ) ; return resultStr ? parseInt ( resultStr , 0 ) : null ; } public static getChildElements ( elem ) : Element [ ] { const children = elem . childNodes ; const result : Element [ ] = [ ] ; for ( let i = 0 ; i < children . length ; i ++ ) { if ( children . item ( i ) instanceof Element ) { result . push ( children . item ( i ) as Element ) ; } } return result ; } public static getAttributes ( elem , ns ? ) : { [ key ] : string } { const result : { [ key ] : string } = { } ; const attrs = elem . attributes ; for ( let i = 0 ; i < attrs . length ; i ++ ) { const attr = attrs . item ( i ) ; if ( ! ns || attr . namespaceURI === ns ) { result [ attr . localName ! ] = attr . value ; } } return result ; } } export default XMLReader ;	O O $any$ O O O O O $any$ O O O $DOMParser$ O $complex$ O O $complex$ O O O O O $Element[]$ O $string$ O $string$ $string$ O O $complex$ O O O O $Document$ O $any$ O $DOMParser$ O $Document$ O $string$ O O O O O O O O O $Document$ O $Document$ O O O O O O $number$ O O O O O $string$ O O $complex$ O O O $string$ O $Document$ O O O O $ErrorConstructor$ O O O O O O O $string$ O O O O $Document$ O $HTMLElement$ O $string$ O $string$ O O O $string$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O $Document$ O $HTMLElement$ O O O O O $Element[]$ O $Element$ O $string$ O O $complex$ O O O O $Element[]$ O $complex$ O O O O O O O $HTMLCollectionOf<Element>$ O $Element$ O O O $string$ O O O O O $number$ O O O $number$ O $HTMLCollectionOf<Element>$ O $number$ O $number$ O O O $Element[]$ O $number$ O $HTMLCollectionOf<Element>$ O $Element$ O $number$ O O O O O $Element[]$ O O O O $Nullable$ O $Element$ O $string$ O $boolean$ $boolean$ O O $complex$ O O O $Element[]$ O $any$ O $Element[]$ O $Element$ O $string$ O O O O $Element[]$ O $number$ O O O O O $Element[]$ O O O O O O O O $Element[]$ O $number$ O O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O O O O O O O O O $ErrorConstructor$ O O O O O O O O $Nullable$ O $Element$ O $string$ O $boolean$ $boolean$ O O O O O O $Attr$ O $Element$ O $NamedNodeMap$ O $Attr$ O $string$ O O O O $Attr$ O O O $Attr$ O $string$ O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O O O O O O O $Nullable$ O $Element$ O $string$ O $boolean$ $boolean$ O O O O O O $string$ O $any$ O $string$ O $Element$ O $string$ O $boolean$ O O O $string$ O $number$ O $string$ O O O O O O O $Nullable$ O $Element$ O $string$ O $boolean$ $boolean$ O O O O O O $string$ O $any$ O $string$ O $Element$ O $string$ O $boolean$ O O O $string$ O $number$ O $string$ O O O O O O O O O $Element[]$ O $Element$ O O $complex$ O O O O $NodeListOf<ChildNode>$ O $Element$ O $NodeListOf<ChildNode>$ O O $Element[]$ O $complex$ O O O O O O O O O $number$ O O O $number$ O $NodeListOf<ChildNode>$ O $number$ O $number$ O O O O O $NodeListOf<ChildNode>$ O $ChildNode$ O $number$ O O $complex$ O O $Element[]$ O $number$ O $NodeListOf<ChildNode>$ O $ChildNode$ O $number$ O O $complex$ O O O O O $Element[]$ O O O O $complex$ O $Element$ O $string$ $string$ O O O O $string$ O O O O O O $complex$ O O O $string$ O O O O O O O O O $NamedNodeMap$ O $Element$ O $NamedNodeMap$ O O O O $number$ O O O $number$ O $NamedNodeMap$ O $number$ O $number$ O O O O $Attr$ O $NamedNodeMap$ O $Attr$ O $number$ O O O O O $string$ O $Attr$ O $string$ O $string$ O O $complex$ O $Attr$ O $string$ O O O $Attr$ O $string$ O O O O $complex$ O O O O O $any$ O
interface ITreeInitializedInfo { ownerScriptTag : HTMLScriptElement ; id : string ; } export default ITreeInitializedInfo ;	O $any$ O $HTMLScriptElement$ O $complex$ O $string$ O O O O O O $any$ O
class NodeUtility { public static getNodeListIndexByElementIndex ( targetElement , elementIndex ) { const nodeArray : Node [ ] = Array . prototype . slice . call ( targetElement . childNodes ) ; const elementArray = nodeArray . filter ( ( v ) => { return v . nodeType === 0 ; } ) ; elementIndex = elementIndex < 0 ? elementArray . length + elementIndex : elementIndex ; return nodeArray . indexOf ( elementArray [ elementIndex ] ) ; } public static getAttributes ( element ) : { [ key ] : string } { const attributes : { [ key ] : string } = { } ; const domAttr = element . attributes ; for ( let i = 0 ; i < domAttr . length ; i ++ ) { const attrNode = domAttr . item ( i ) ; if ( attrNode . name . startsWith ( "s" ) ) { continue ; } const name = attrNode . namespaceURI ? attrNode . namespaceURI + "s" + attrNode . localName ! : attrNode . localName ! ; attributes [ name ] = attrNode . value ; } return attributes ; } } export default NodeUtility ;	O $any$ O O O $number$ O $Element$ O $number$ O O O $Node[]$ O O O O O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $Element$ O $NodeListOf<ChildNode>$ O O O $Node[]$ O $Node[]$ O $complex$ O O $Node$ O O O O $Node$ O $number$ O O O O O O $number$ O $number$ O O O $Node[]$ O $number$ O $number$ O $number$ O O $Node[]$ O $number$ O $Node[]$ O $number$ O O O O O O $complex$ O $Element$ O O O O $string$ O O O O O O $complex$ O O O $string$ O O O O O O O O O $NamedNodeMap$ O $Element$ O $NamedNodeMap$ O O O O $number$ O O O $number$ O $NamedNodeMap$ O $number$ O $number$ O O O O $Attr$ O $NamedNodeMap$ O $Attr$ O $number$ O O O O $Attr$ O $string$ O $boolean$ O O O O O O O O O $string$ O $Attr$ O $string$ O $Attr$ O $string$ O O O $Attr$ O $string$ O O $Attr$ O $string$ O O $complex$ O $string$ O O $Attr$ O $string$ O O O $complex$ O O O O O $any$ O
import { Name } from "s" ; interface IAttributeDeclaration { converter : Name ; default : any ; [ parameters ] : any ; } export default IAttributeDeclaration ;	O O $any$ O O O O O $any$ O $Name$ O $any$ O $any$ O O O O $string$ O O O O O O O $any$ O
import ITreeInitializedInfo from "s" ; import Utility from "s" ; import Constants from "s" ; import NodeUtility from "s" ; import IAttributeDeclaration from "s" ; import Attribute from "s" ; import GomlNode from "s" ; import NSDictionary from "s" ; import NSIdentity from "s" ; import IDObject from "s" ; import Ensure from "s" ; import { GomlInterface , Nullable , Name } from "s" ; export default class Component extends IDObject { public name : NSIdentity ; public attributes : NSDictionary < Attribute > ; public node : GomlNode ; public element : Element ; public isDefaultComponent = false ; public disposed = false ; private _enabled = true ; private _awaked = false ; private _handlers : ( ( component ) => void ) [ ] = [ ] ; private _additionalAttributesNames : NSIdentity [ ] = [ ] ; private _initializedInfo : Nullable < ITreeInitializedInfo > = null ; public get enabled ( ) : boolean { return this . _enabled ; } public set enabled ( val ) { if ( this . _enabled === val ) { return ; } this . _enabled = val ; this . _handlers . forEach ( ( handler ) => { handler ( this ) ; } ) ; } public get companion ( ) : NSDictionary < any > { return this . node . companion ; } public get tree ( ) : GomlInterface { return this . node . tree ; } public get isActive ( ) : boolean { return this . enabled && ! ! this . node && this . node . isActive ; } public setAttribute ( name , value ) { if ( typeof name === "s" && Ensure . checkFQNString ( name ) ) { name = this . name . fqn + "s" + name ; } const attr = this . attributes . get ( name ) ; if ( attr ) { attr . Value = value ; } } public getAttribute ( name ) { if ( typeof name === "s" && Ensure . checkFQNString ( name ) ) { name = this . name . fqn + "s" + name ; } const attr = this . getAttributeRaw ( name ) ; if ( attr ) { return attr . Value ; } else { throw new Error ( `template` ) ; } } public getAttributeRaw ( name ) { if ( typeof name === "s" && Ensure . checkFQNString ( name ) ) { name = this . name . fqn + "s" + name ; } return this . attributes . get ( name ) ; } public addEnabledObserver ( observer : ( component ) => void ) { this . _handlers . push ( observer ) ; } public removeEnabledObserver ( observer : ( component ) => void ) { return Utility . remove ( this . _handlers , observer ) ; } public resolveDefaultAttributes ( nodeAttributes ? : { [ key ] : string ; } | null ) { const nodeAttr = nodeAttributes || { } ; if ( this . isDefaultComponent ) { this . attributes . forEach ( attr => attr . resolveDefaultValue ( nodeAttr ) ) ; } else { const attrs = NodeUtility . getAttributes ( this . element ) ; for ( let key in attrs ) { if ( key === Constants . x_gr_id ) { continue ; } } this . attributes . forEach ( attr => attr . resolveDefaultValue ( attrs ) ) ; } } public dispose ( ) { this . node . removeComponent ( this ) ; } public awake ( ) { if ( this . _awaked ) { return false ; } this . _awaked = true ; let method = ( this as any ) [ "s" ] ; if ( typeof method === "s" ) { method ( ) ; } return true ; } public initialized ( info ) { if ( this . _initializedInfo === info ) { return ; } this . _initializedInfo = info ; let method = ( this as any ) [ "s" ] ; if ( typeof method === "s" ) { method ( info ) ; } } protected __addAtribute ( name , attribute ) { console . warn ( `template` ) ; this . __addAttribute ( name , attribute ) ; } protected __addAttribute ( name , attribute ) { if ( ! attribute ) { throw new Error ( "s" ) ; } const attr = Attribute . generateAttributeForComponent ( name , attribute , this ) ; this . node . addAttribute ( attr ) ; if ( this . isDefaultComponent ) { attr . resolveDefaultValue ( NodeUtility . getAttributes ( this . node . element ) ) ; } else { const attrs = NodeUtility . getAttributes ( this . element ) ; attr . resolveDefaultValue ( attrs ) ; } this . _additionalAttributesNames . push ( attr . name ) ; return attr ; } protected __removeAttributes ( name ? ) { if ( name ) { const index = this . _additionalAttributesNames . findIndex ( id => id . name === name ) ; if ( index < 0 ) { throw new Error ( "s" + name ) ; } const attrId = this . _additionalAttributesNames [ index ] ; this . node . removeAttribute ( this . attributes . get ( attrId ) ) ; this . attributes . delete ( attrId ) ; this . _additionalAttributesNames . splice ( index , 0 ) ; } else { const arr = this . _additionalAttributesNames . concat ( ) ; arr . forEach ( id => { this . __removeAttributes ( id . name ) ; } ) ; } } protected __bindAttributes ( ) { this . attributes . forEach ( attr => { const name = attr . name . name ; attr . boundTo ( name ) ; } ) ; } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $NSIdentity$ O $any$ O O $NSDictionary<Attribute>$ O $any$ O $any$ O O O $GomlNode$ O $any$ O O $Element$ O $complex$ O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $void)[]$ O O O $Component$ O O O O O O O O O O O $NSIdentity[]$ O $any$ O O O O O O O $ITreeInitializedInfo$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O $boolean$ O O O O O O $boolean$ O $boolean$ O O O O O O O $boolean$ O $boolean$ O O O $void)[]$ O $void$ O O $void$ O O O $void$ O O O O O O O O O O $NSDictionary<any>$ O O O $any$ O O O O O O O $GomlNode$ O $NSDictionary<any>$ O O O O $GomlInterface$ O O O $any$ O O O O $GomlNode$ O $GomlInterface$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O O $GomlNode$ O O O $GomlNode$ O $boolean$ O O O $void$ O $Name$ O $any$ O O O O O $Name$ O O O $any$ O $boolean$ O $string$ O O O $Name$ O O O $NSIdentity$ O $string$ O O O $string$ O O O $Attribute$ O O O $NSDictionary<Attribute>$ O $complex$ O $Name$ O O O O $Attribute$ O O $Attribute$ O $any$ O $any$ O O O O $any$ O $Name$ O O O O O $Name$ O O O $any$ O $boolean$ O $string$ O O O $Name$ O O O $NSIdentity$ O $string$ O O O $string$ O O O $Attribute$ O O O $Attribute$ O $Name$ O O O O $Attribute$ O O O $Attribute$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $Attribute$ O $Name$ O O O O O $Name$ O O O $any$ O $boolean$ O $string$ O O O $Name$ O O O $NSIdentity$ O $string$ O O O $string$ O O O O O $NSDictionary<Attribute>$ O $complex$ O $Name$ O O O O $void$ O $void$ O O $Component$ O O O O O O O $void)[]$ O $number$ O $void$ O O O O $boolean$ O $void$ O O $Component$ O O O O O O $any$ O $boolean$ O O O $void)[]$ O $void$ O O O O $any$ O $complex$ O O O O $string$ O O O O O O O O O O $complex$ O $complex$ O O O O O O O O $boolean$ O O O O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O $Attribute$ O $void$ O $complex$ O O O O O O O $complex$ O $any$ O $complex$ O O O $Element$ O O O O O $string$ O $complex$ O O O O $string$ O $any$ O $string$ O O O O O O O O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O $Attribute$ O $void$ O $complex$ O O O O O O $void$ O O O O O $GomlNode$ O $boolean$ O O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O $void$ O $ITreeInitializedInfo$ O O O O O O $ITreeInitializedInfo$ O $ITreeInitializedInfo$ O O O O O O O $ITreeInitializedInfo$ O $ITreeInitializedInfo$ O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O $ITreeInitializedInfo$ O O O O O $void$ O $string$ O $IAttributeDeclaration$ O O $Console$ O $void$ O O O O O O $Attribute$ O $string$ O $IAttributeDeclaration$ O O O O $Attribute$ O $string$ O $IAttributeDeclaration$ O O O O O $IAttributeDeclaration$ O O O O $ErrorConstructor$ O O O O O O $Attribute$ O $any$ O $Attribute$ O $string$ O $IAttributeDeclaration$ O O O O O O $GomlNode$ O $Attribute$ O $Attribute$ O O O O O O $boolean$ O O $Attribute$ O $void$ O $any$ O $complex$ O O O $GomlNode$ O $Element$ O O O O O O O $complex$ O $any$ O $complex$ O O O $Element$ O O $Attribute$ O $void$ O $complex$ O O O O O $NSIdentity[]$ O $number$ O $Attribute$ O $NSIdentity$ O O O $Attribute$ O O O $void$ O $string$ $string$ O O O O $string$ O O O $number$ O O O $NSIdentity[]$ O $number$ O $NSIdentity$ O $NSIdentity$ O $string$ O $string$ O O O O $number$ O O O O O O $ErrorConstructor$ O O O $string$ O O O O $NSIdentity$ O O O $NSIdentity[]$ O $number$ O O O O $GomlNode$ O $boolean$ O O O $NSDictionary<Attribute>$ O $complex$ O $NSIdentity$ O O O O O $NSDictionary<Attribute>$ O $boolean$ O $NSIdentity$ O O O O $NSIdentity[]$ O $complex$ O $number$ O O O O O O O O $NSIdentity[]$ O O O $NSIdentity[]$ O $complex$ O O O $NSIdentity[]$ O $void$ O $NSIdentity$ O O O O $void$ O $NSIdentity$ O $string$ O O O O O O O O $void$ O O O O O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O O O $string$ O $Attribute$ O $NSIdentity$ O $string$ O $Attribute$ O $void$ O $string$ O O O O O O O
import NSIdentity from "s" ; export default class NSSet { private _content : { [ fqn ] : NSIdentity } = { } ; public static fromArray ( array : NSIdentity [ ] ) { const nSet = new NSSet ( ) ; nSet . pushArray ( array ) ; return nSet ; } constructor ( content ? : NSIdentity [ ] ) { if ( content ) { this . pushArray ( content ) ; } } public push ( item ) { if ( ! this . _content [ item . fqn ] ) { this . _content [ item . fqn ] = item ; return true ; } return false ; } public pushArray ( item : NSIdentity [ ] ) { item . forEach ( v => { this . push ( v ) ; } ) ; return this ; } public toArray ( ) : NSIdentity [ ] { const ret : NSIdentity [ ] = [ ] ; for ( let key in this . _content ) { ret . push ( this . _content [ key ] ) ; } return ret ; } public clone ( ) { const newSet = new NSSet ( ) ; for ( let key in this . _content ) { newSet . push ( this . _content [ key ] ) ; } return newSet ; } public merge ( other ) { this . pushArray ( other . toArray ( ) ) ; return this ; } public forEach ( func : ( name ) => void ) { for ( let key in this . _content ) { func ( this . _content [ key ] ) ; } return this ; } }	O $any$ O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O O $NSSet$ O $NSIdentity[]$ O $any$ O O O O O $NSSet$ O O $any$ O O O $NSSet$ O $NSSet$ O $NSIdentity[]$ O O O $NSSet$ O O O O $NSIdentity[]$ O O $any$ O O O O O O $NSIdentity[]$ O O O O $NSSet$ O $NSIdentity[]$ O O O O O $boolean$ O $NSIdentity$ O O O O O O O $complex$ O $NSIdentity$ O $string$ O O O O O $complex$ O $NSIdentity$ O $string$ O O $NSIdentity$ O O O O O O O O O O $NSSet$ O $NSIdentity[]$ O $any$ O O O O $NSIdentity[]$ O $void$ O $NSIdentity$ O O O O $boolean$ O $NSIdentity$ O O O O O O O O O O $NSIdentity[]$ O O O $any$ O O O O $NSIdentity[]$ O $any$ O O O O O O O O O $string$ O O O $complex$ O O $NSIdentity[]$ O $number$ O O O $complex$ O $string$ O O O O O $NSIdentity[]$ O O O $NSSet$ O O O O $NSSet$ O O $any$ O O O O O O $string$ O O O $complex$ O O $NSSet$ O $boolean$ O O O $complex$ O $string$ O O O O O $NSSet$ O O O $NSSet$ O $NSSet$ O O O O $NSSet$ O $NSSet$ O $NSIdentity[]$ O O O O O O O O O $NSSet$ O $void$ O O $NSIdentity$ O O O O O O O O $string$ O O O $complex$ O O $void$ O O O $complex$ O $string$ O O O O O O O O O
import Ensure from "s" ; import NSDictionary from "s" ; import NSSet from "s" ; import NSIdentity from "s" ; import IdResolver from "s" ; import GrimoireInterface from "s" ; import { Name } from "s" ; export default class NodeDeclaration { public defaultComponents : NSSet ; public defaultAttributes : NSDictionary < any > = new NSDictionary ( ) ; public superNode ? : NSIdentity ; public freezeAttributes : NSSet ; public idResolver = new IdResolver ( ) ; private _defaultComponentsActual : NSSet ; private _defaultAttributesActual : NSDictionary < any > ; private _resolvedDependency = false ; public get resolvedDependency ( ) { return this . _resolvedDependency ; } public get defaultComponentsActual ( ) : NSSet { if ( ! this . _resolvedDependency ) { throw new Error ( `template` ) ; } return this . _defaultComponentsActual ; } public get defaultAttributesActual ( ) : NSDictionary < any > { if ( ! this . _resolvedDependency ) { throw new Error ( `template` ) ; } return this . _defaultAttributesActual ; } constructor ( public name , private _defaultComponents : Name [ ] , private _defaultAttributes : { [ key ] : any } , private _superNode ? , private _freezeAttributes : Name [ ] = [ ] ) { if ( ! this . _superNode && this . name . name !== "s" ) { this . _superNode = new NSIdentity ( "s" ) ; } this . _freezeAttributes = this . _freezeAttributes || [ ] ; } public addDefaultComponent ( componentName ) { const componentId = Ensure . tobeNSIdentity ( componentName ) ; this . defaultComponents . push ( componentId ) ; if ( this . _defaultComponentsActual ) { this . _defaultComponentsActual . push ( componentId ) ; } } public resolveDependency ( ) { if ( this . _resolvedDependency ) { return false ; } this . defaultComponents = new NSSet ( this . _defaultComponents . map ( name => Ensure . tobeNSIdentity ( name ) ) ) ; for ( let key in this . _defaultAttributes ) { let value = this . _defaultAttributes [ key ] ; this . defaultAttributes . set ( NSIdentity . fromFQN ( key ) , value ) ; } this . superNode = this . _superNode ? Ensure . tobeNSIdentity ( this . _superNode ) : void 0 ; this . _resolveInherites ( ) ; this . _defaultComponentsActual . forEach ( id => { const dec = GrimoireInterface . componentDeclarations . get ( id ) ; dec . idResolver . foreach ( fqn => { this . idResolver . add ( NSIdentity . fromFQN ( fqn ) ) ; } ) ; } ) ; this . freezeAttributes = new NSSet ( this . _freezeAttributes . map ( name => Ensure . tobeNSIdentity ( name ) ) ) ; this . _resolvedDependency = true ; return true ; } private _resolveInherites ( ) { if ( ! this . superNode ) { this . _defaultComponentsActual = this . defaultComponents ; this . _defaultAttributesActual = this . defaultAttributes ; return ; } const superNode = GrimoireInterface . nodeDeclarations . get ( this . superNode ) ; superNode . resolveDependency ( ) ; const inheritedDefaultComponents = superNode . defaultComponentsActual ; const inheritedDefaultAttribute = superNode . defaultAttributesActual ; this . _defaultComponentsActual = inheritedDefaultComponents . clone ( ) . merge ( this . defaultComponents ) ; this . _defaultAttributesActual = inheritedDefaultAttribute . clone ( ) . pushDictionary ( this . defaultAttributes ) ; } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O O $any$ O O O O O O O $any$ O O $NSSet$ O $any$ O O $NSDictionary<any>$ O $any$ O O O O O $any$ O O O O $NSIdentity$ O O $any$ O O $NSSet$ O $any$ O O $IdResolver$ O O $any$ O O O O $NSSet$ O $any$ O O $NSDictionary<any>$ O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O O O $boolean$ O O O O $NSSet$ O O O $any$ O O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O $NSSet$ O O O O $NSDictionary<any>$ O O O $any$ O O O O O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O $NSDictionary<any>$ O O O O O $NSIdentity$ O O $Name[]$ O $any$ O O O O $complex$ O O O $string$ O O O O O O $Name$ $Name$ O O $Name[]$ O $any$ O O O O O O O O O O O O $Name$ O O O $NSIdentity$ O $string$ O O O O O O $Name$ O O $any$ O O O O O O O $Name[]$ O O O $Name[]$ O O O O O O $void$ O $Name$ O O O $NSIdentity$ O $any$ O $NSIdentity$ O $Name$ O O O O $NSSet$ O $boolean$ O $NSIdentity$ O O O O O O $NSSet$ O O O O $NSSet$ O $boolean$ O $NSIdentity$ O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O O O $NSSet$ O O $any$ O O O $Name[]$ O $U[]$ O $Name$ O $any$ O $NSIdentity$ O $Name$ O O O O O O O $string$ O O O $complex$ O O O $any$ O O O $complex$ O $string$ O O O O $NSDictionary<any>$ O $void$ O $any$ O $complex$ O $string$ O O $any$ O O O O O $NSIdentity$ O O O $Name$ O $any$ O $NSIdentity$ O O O $Name$ O O O O O O O $void$ O O O O O $NSSet$ O $NSSet$ O $NSIdentity$ O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O $NSIdentity$ O O $ComponentDeclaration$ O $IdResolver$ O $void$ O $string$ O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O $string$ O O O O O O O O O O O $NSSet$ O O $any$ O O O $Name[]$ O $U[]$ O $Name$ O $any$ O $NSIdentity$ O $Name$ O O O O O O $boolean$ O O O O O O O O $void$ O O O O O O O O $NSIdentity$ O O O O $NSSet$ O O O $NSSet$ O O O $NSDictionary<any>$ O O O $NSDictionary<any>$ O O O O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O $NSIdentity$ O O $NodeDeclaration$ O $boolean$ O O O O $NSSet$ O $NodeDeclaration$ O $NSSet$ O O $NSDictionary<any>$ O $NodeDeclaration$ O $NSDictionary<any>$ O O O $NSSet$ O $NSSet$ O $NSSet$ O O O $NSSet$ O O O $NSSet$ O O O O $NSDictionary<any>$ O $NSDictionary<any>$ O $NSDictionary<any>$ O O O $NSDictionary<any>$ O O O $NSDictionary<any>$ O O O O
import GomlNode from "s" ; import Component from "s" ; export default class MessageException extends Error { public handled = false ; private _isMessageException = true ; constructor ( public node , public component , public messageName , public error ) { super ( ) ; const isMessageException = ( error as MessageException ) . _isMessageException ; if ( ! isMessageException ) { const components = this . node . getComponents < Component > ( ) ; let componentMessage = "s" ; for ( let i = 0 ; i < components . length ; i ++ ) { const singleComponent = components [ i ] ; let marker = "s" ; if ( this . component === singleComponent ) { marker = "s" ; } componentMessage += `template` ; singleComponent . attributes . forEach ( a => { try { componentMessage += `template` ; } catch ( e ) { componentMessage += `template` ; } } ) ; componentMessage += "s" ; } this . message = `template` ; } else { this . message = `template` ; } this . stack = error . stack ; const proto = Object . getPrototypeOf ( this ) ; proto . name = "s" ; proto . message = this . message ; } public toString ( ) { return this . message ; } }	O $any$ O O O O $any$ O O O O O O $any$ O $ErrorConstructor$ O O $boolean$ O O O O $boolean$ O O O O O O $GomlNode$ O O $Component$ O O $string$ O O $Error$ O O O O O O O $boolean$ O O $Error$ O $any$ O O $boolean$ O O O O $boolean$ O O O $Component[]$ O O O $GomlNode$ O $T[]$ O $any$ O O O O O $string$ O O O O O O $number$ O O O $number$ O $Component[]$ O $number$ O $number$ O O O O $Component$ O $Component[]$ O $number$ O O O $string$ O O O O O O O $Component$ O $Component$ O O $string$ O O O O $string$ O O O $Component$ O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O O O O $string$ O O O O O O $any$ O O $string$ O O O O O O O $string$ O O O O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O $Error$ O $string$ O O $any$ O $ObjectConstructor$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O O $string$ O O O O O O $string$ O O O
import ITreeInitializedInfo from "s" ; import AttributeManager from "s" ; import Utility from "s" ; import Constants from "s" ; import GomlParser from "s" ; import XMLReader from "s" ; import GrimoireInterface from "s" ; import EEObject from "s" ; import Component from "s" ; import NodeDeclaration from "s" ; import NodeUtility from "s" ; import Attribute from "s" ; import NSDictionary from "s" ; import NSIdentity from "s" ; import Ensure from "s" ; import MessageException from "s" ; import { Name , GomlInterface , Nullable , Ctor } from "s" ; class GomlNode extends EEObject { public element : Element ; public nodeDeclaration : NodeDeclaration ; public children : GomlNode [ ] = [ ] ; public componentsElement : Element ; private _parent : Nullable < GomlNode > = null ; private _root : Nullable < GomlNode > = null ; private _components : Component [ ] ; private _tree : GomlInterface = GrimoireInterface ( [ this ] ) ; private _companion : NSDictionary < any > = new NSDictionary < any > ( ) ; private _attributeManager : AttributeManager ; private _isActive = false ; private _messageCache : { [ message ] : Component [ ] } = { } ; private _deleted = false ; private _mounted = false ; private _enabled = true ; private _defaultValueResolved = false ; private _initializedInfo : Nullable < ITreeInitializedInfo > = null ; public static fromElement ( elem ) { const id = elem . getAttribute ( Constants . x_gr_id ) ; if ( id ) { return GrimoireInterface . nodeDictionary [ id ] ; } else { throw new Error ( "s" ) ; } } public get name ( ) : NSIdentity { return this . nodeDeclaration . name ; } public get tree ( ) : GomlInterface { if ( ! this . mounted ) { throw new Error ( "s" ) ; } return this . _tree ; } public get deleted ( ) : boolean { return this . _deleted ; } public get isActive ( ) : boolean { return this . _isActive ; } public get enabled ( ) : boolean { return this . _enabled ; } public set enabled ( value ) { this . setAttribute ( "s" , value ) ; } public get companion ( ) : NSDictionary < any > { return this . _companion ; } public get parent ( ) : Nullable < GomlNode > { return this . _parent ; } public get hasChildren ( ) : boolean { return this . children . length > 0 ; } public get mounted ( ) : boolean { return this . _mounted ; } constructor ( recipe , element ? < Element > ) { super ( ) ; if ( ! recipe ) { throw new Error ( "s" ) ; } if ( ! recipe . resolvedDependency ) { recipe . resolveDependency ( ) ; } this . nodeDeclaration = recipe ; this . element = element ? element : document . createElementNS ( recipe . name . ns . qualifiedName , recipe . name . name ) ; this . componentsElement = document . createElement ( "s" ) ; this . _root = this ; this . _components = [ ] ; this . _attributeManager = new AttributeManager ( recipe . name . name ) ; this . element . setAttribute ( Constants . x_gr_id , this . id ) ; const defaultComponentNames = recipe . defaultComponentsActual ; defaultComponentNames . forEach ( id => { this . addComponent ( id , null , true ) ; } ) ; GrimoireInterface . nodeDictionary [ this . id ] = this ; } public getChildrenByClass ( className ) : GomlNode [ ] { const nodes = this . element . getElementsByClassName ( className ) ; const array = new Array ( nodes . length ) ; for ( let i = 0 ; i < nodes . length ; i ++ ) { array [ i ] = GomlNode . fromElement ( nodes . item ( i ) ) ; } return array ; } public queryChildren ( query ) : GomlNode [ ] { const nodes = this . element . querySelectorAll ( query ) ; const array = new Array ( nodes . length ) ; for ( let i = 0 ; i < nodes . length ; i ++ ) { array [ i ] = GomlNode . fromElement ( nodes . item ( i ) ) ; } return array ; } public getChildrenByNodeName ( nodeName ) : GomlNode [ ] { const nodes = this . element . getElementsByTagName ( nodeName ) ; const array = new Array ( nodes . length ) ; for ( let i = 0 ; i < nodes . length ; i ++ ) { array [ i ] = GomlNode . fromElement ( nodes . item ( i ) ) ; } return array ; } public remove ( ) { this . children . forEach ( ( c ) => { c . remove ( ) ; } ) ; this . _sendMessageForced ( "s" ) ; this . removeAllListeners ( ) ; delete GrimoireInterface . nodeDictionary [ this . id ] ; if ( this . _parent ) { this . _parent . detachChild ( this ) ; } else { this . setMounted ( false ) ; if ( this . element . parentNode ) { this . element . parentNode . removeChild ( this . element ) ; } } this . _deleted = true ; } public sendMessage ( message , args ? ) { if ( ! this . isActive ) { return false ; } message = Ensure . tobeMessage ( message ) ; this . _sendMessage ( message , args ) ; return true ; } public broadcastMessage ( range , name , args ? ) ; public broadcastMessage ( name , args ? ) ; public broadcastMessage ( 0 : number | string , 0 ? , 0 ? ) { if ( ! this . enabled || ! this . mounted ) { return ; } if ( typeof 0 === "s" ) { const range = 0 ; const message = Ensure . tobeMessage ( < string > 0 ) ; const args = 0 ; this . _broadcastMessage ( message , args , range ) ; } else { const message = Ensure . tobeMessage ( 0 ) ; const args = 0 ; this . _broadcastMessage ( message , args , - 0 ) ; } } public append ( tag ) : GomlNode [ ] { const elems = XMLReader . parseXML ( tag ) ; let ret : GomlNode [ ] = [ ] ; elems . forEach ( elem => { let child = GomlParser . parse ( elem ) ; this . addChild ( child ) ; ret . push ( child ) ; } ) ; return ret ; } public addChildByName ( nodeName , attributes : { [ attrName ] : any } ) { const nodeDec = GrimoireInterface . nodeDeclarations . get ( nodeName ) ; const node = new GomlNode ( nodeDec ) ; if ( attributes ) { for ( let key in attributes ) { node . setAttribute ( key , attributes [ key ] ) ; } } this . addChild ( node ) ; return node ; } public addChild ( child , index ? : number | null , elementSync = true ) { if ( child . _deleted ) { throw new Error ( "s" ) ; } if ( index != null && typeof index !== "s" ) { throw new Error ( "s" ) ; } const insertIndex = index == null ? this . children . length : index ; this . children . splice ( insertIndex , 0 , child ) ; child . _parent = this ; child . _tree = this . _tree ; child . _companion = this . _companion ; if ( elementSync ) { let referenceElement = ( this . element as any ) [ NodeUtility . getNodeListIndexByElementIndex ( this . element , insertIndex ) ] ; this . element . insertBefore ( child . element , referenceElement ) ; } if ( this . mounted ) { child . setMounted ( true ) ; } if ( this . _initializedInfo ) { child . sendInitializedMessage ( this . _initializedInfo ) ; } } public callRecursively < T > ( func : ( g ) => T ) : T [ ] { return this . _callRecursively ( func , ( n ) => n . children ) ; } public removeChild ( child ) { const node = this . detachChild ( child ) ; if ( node ) { node . remove ( ) ; } } public detachChild ( target ) < GomlNode > { const index = this . children . indexOf ( target ) ; if ( index === - 0 ) { return null ; } target . setMounted ( false ) ; target . _parent = null ; this . children . splice ( index , 0 ) ; this . element . removeChild ( target . element ) ; return target ; } public detach ( ) { if ( this . parent ) { this . parent . detachChild ( this ) ; } else { throw new Error ( "s" ) ; } } public getAttribute ( attrName ) { return this . _attributeManager . getAttribute ( attrName ) ; } public getAttributeRaw ( attrName ) { return this . _attributeManager . getAttributeRaw ( attrName ) ; } public setAttribute ( attrName , value , ignoireFreeze = false ) { let attrIds = this . _attributeManager . guess ( attrName ) ; if ( attrIds . length === 0 ) { this . _attributeManager . setAttribute ( typeof attrName === "s" ? attrName : attrName . fqn , value ) ; } for ( let i = 0 ; i < attrIds . length ; i ++ ) { let id = attrIds [ i ] ; if ( ! ignoireFreeze && this . isFreezeAttribute ( id . fqn ) ) { throw new Error ( `template` ) ; } this . _attributeManager . setAttribute ( id . fqn , value ) ; } } public addAttribute ( attr ) { return this . _attributeManager . addAttribute ( attr ) ; } public setMounted ( mounted ) { if ( this . _mounted === mounted ) { return ; } if ( mounted ) { this . _mount ( ) ; for ( let i = 0 ; i < this . children . length ; i ++ ) { this . children [ i ] . setMounted ( mounted ) ; } } else { for ( let i = 0 ; i < this . children . length ; i ++ ) { this . children [ i ] . setMounted ( mounted ) ; } this . _sendMessageForced ( "s" ) ; this . _isActive = false ; this . _tree = GrimoireInterface ( [ this ] ) ; this . _companion = new NSDictionary < any > ( ) ; this . _mounted = mounted ; } } public get index ( ) : number { if ( ! this . _parent ) { return - 0 ; } return this . _parent . children . indexOf ( this ) ; } public removeAttribute ( attr ) { return this . _attributeManager . removeAttribute ( attr ) ; } public addComponent ( component : Name | ( new ( ) => Component ) , attributes ? : { [ key ] : any } | null , isDefaultComponent = false ) { component = Ensure . tobeComponentIdentity ( component ) ; const declaration = GrimoireInterface . componentDeclarations . get ( component ) ; if ( ! declaration ) { throw new Error ( `template` ) ; } const instance = declaration . generateInstance ( ) ; attributes = attributes || { } ; for ( let key in attributes ) { instance . setAttribute ( key , attributes [ key ] ) ; } this . _addComponentDirectly ( instance , isDefaultComponent ) ; return instance ; } public _addComponentDirectly ( component , isDefaultComponent ) { if ( component . node || component . disposed ) { throw new Error ( "s" ) ; } this . _messageCache = { } ; component . isDefaultComponent = ! ! isDefaultComponent ; component . node = this ; let referenceElement = ( this . componentsElement as any ) [ NodeUtility . getNodeListIndexByElementIndex ( this . componentsElement , this . _components . length ) ] ; this . componentsElement . insertBefore ( component . element , referenceElement ) ; let propNames : string [ ] = [ ] ; let o = component ; while ( o ) { propNames = propNames . concat ( Object . getOwnPropertyNames ( o ) ) ; o = Object . getPrototypeOf ( o ) ; } propNames . filter ( name => name . startsWith ( "s" ) && typeof ( < any > component ) [ name ] === "s" ) . forEach ( method => { ( < any > component ) [ "s" + method ] = ( < any > component ) [ method ] . bind ( component ) ; } ) ; this . _components . push ( component ) ; component . attributes . forEach ( p => this . addAttribute ( p ) ) ; if ( this . _defaultValueResolved ) { component . attributes . forEach ( p => p . resolveDefaultValue ( NodeUtility . getAttributes ( this . element ) ) ) ; } if ( this . _mounted ) { component . resolveDefaultAttributes ( null ) ; this . _sendMessageForcedTo ( component , "s" ) ; this . _sendMessageForcedTo ( component , "s" ) ; } if ( this . _initializedInfo ) { component . initialized ( this . _initializedInfo ) ; } } public removeComponents ( component : Name | ( new ( ) => Component ) ) { let result = false ; const removeTargets = [ ] ; component = Ensure . tobeComponentIdentity ( component ) ; for ( let i = 0 ; i < this . _components . length ; i ++ ) { const c = this . _components [ i ] ; if ( c . name . fqn === component . fqn ) { removeTargets . push ( c ) ; } } removeTargets . forEach ( c => { let b = this . removeComponent ( c ) ; result = result || b ; } ) ; return result ; } public removeComponent ( component ) { const index = this . _components . indexOf ( component ) ; if ( index !== - 0 ) { this . _sendMessageForcedTo ( component , "s" ) ; this . _sendMessageForcedTo ( component , "s" ) ; this . componentsElement . removeChild ( component . element ) ; this . _components . splice ( index , 0 ) ; this . _messageCache = { } ; delete component . node ; component . disposed = true ; delete GrimoireInterface . componentDictionary [ component . id ] ; return true ; } return false ; } public getComponents < T > ( filter ? : Name | Ctor < T > ) : T [ ] { if ( ! filter ) { return this . _components as any as T [ ] ; } else { const ctor = Ensure . tobeComponentConstructor ( filter ) ; if ( ! ctor ) { return [ ] ; } return this . _components . filter ( c => c instanceof ctor ) as any as T [ ] ; } } public getComponent < T > ( name : Name | Ctor < T > ) : T { if ( ! name ) { throw new Error ( "s" ) ; } else if ( typeof name === "s" ) { return this . _components . find ( c => c instanceof name ) as any as T || null ; } else { const ctor = Ensure . tobeComponentConstructor ( name ) ; if ( ! ctor ) { throw new Error ( `template` ) ; } return this . getComponent < T > ( ctor as any as Ctor < T > ) ; } } public getComponentsInChildren < T > ( name : Name | Ctor < T > ) : T [ ] { if ( name == null ) { throw new Error ( "s" ) ; } return this . callRecursively ( node => node . getComponent < T > ( name ) ) . filter ( c => ! ! c ) ; } public getComponentInAncestor < T > ( name : Name | Ctor < T > ) < T > { if ( name == null ) { throw new Error ( "s" ) ; } if ( this . parent ) { return this . parent . _getComponentInAncestor ( name ) ; } return null ; } public sendInitializedMessage ( info ) { if ( this . _initializedInfo === info ) { return ; } let components = this . _components . concat ( ) ; for ( let i = 0 ; i < components . length ; i ++ ) { components [ i ] . initialized ( info ) ; } this . _initializedInfo = info ; let children = this . children . concat ( ) ; children . forEach ( child => { child . sendInitializedMessage ( info ) ; } ) ; } public resolveAttributesValue ( ) { this . _defaultValueResolved = true ; const attrs = NodeUtility . getAttributes ( this . element ) ; for ( let key in attrs ) { if ( key === Constants . x_gr_id ) { continue ; } if ( this . isFreezeAttribute ( key ) ) { throw new Error ( `template` ) ; } } this . _components . forEach ( ( component ) => { component . resolveDefaultAttributes ( attrs ) ; } ) ; } public isFreezeAttribute ( attributeName ) { return ! ! this . nodeDeclaration . freezeAttributes . toArray ( ) . find ( name => attributeName === name . fqn ) ; } public notifyActivenessUpdate ( activeness ) { if ( this . isActive !== activeness ) { this . _isActive = activeness ; this . children . forEach ( child => { child . notifyActivenessUpdate ( activeness && child . enabled ) ; } ) ; } } public watch ( attrName , watcher : ( ( newValue , oldValue , attr ) => void ) , immediate = false ) { this . _attributeManager . watch ( attrName , watcher , immediate ) ; } public toString ( ) { let name = this . name . fqn ; let id = this . getAttribute ( "s" ) ; if ( id !== null ) { name += `template` ; } let classValue = this . getAttribute ( "s" ) ; if ( classValue !== null ) { name += `template` ; } return name ; } public toStructualString ( message = "s" ) { if ( this . parent ) { return "s" + this . parent . _openTreeString ( ) + this . _currentSiblingsString ( this . _layer * 0 , `template` , true , message ) + this . parent . _closeTreeString ( ) ; } else { return "s" + this . _currentSiblingsString ( 0 , `template` , true , message ) ; } } private get _layer ( ) : number { if ( ! this . parent ) { return 0 ; } else { return this . parent . _layer + 0 ; } } private _openTreeString ( ) { let spaces = "s" ; for ( let i = 0 ; i < this . _layer * 0 ; i ++ ) { spaces += "s" ; } let ancestor = "s" ; let abbr = "s" ; if ( this . parent ) { ancestor = this . parent . _openTreeString ( ) ; if ( this . index !== 0 ) { abbr = `template` ; } } return `template` ; } private _closeTreeString ( ) { let spaces = "s" ; for ( let i = 0 ; i < this . _layer * 0 ; i ++ ) { spaces += "s" ; } let ancestor = "s" ; let abbr = "s" ; if ( this . parent ) { ancestor = this . parent . _closeTreeString ( ) ; if ( this . index !== this . parent . children . length - 0 ) { abbr = `template` ; } } return `template` ; } private _currentSiblingsString ( spaceCount , current , emphasis = false , message = "s" ) { let spaces = "s" ; for ( let i = 0 ; i < spaceCount ; i ++ ) { spaces += "s" ; } let emphasisStr = "s" ; if ( emphasis ) { emphasisStr = `template` ; for ( let i = 0 ; i < current . length ; i ++ ) { emphasisStr += "s" ; } } let targets : string [ ] = [ ] ; if ( ! this . parent ) { targets . push ( `template` ) ; if ( emphasis ) { targets . push ( emphasisStr + message ) ; } } else { let putDots = false ; for ( let i = 0 ; i < this . parent . children . length ; i ++ ) { if ( i === this . index ) { targets . push ( `template` ) ; if ( emphasis ) { targets . push ( emphasisStr + message ) ; } putDots = false ; } else if ( ( i > 0 && this . index - 0 > i ) || ( i > this . index + 0 && this . parent . children . length - 0 > i ) ) { if ( ! putDots ) { targets . push ( `template` ) ; putDots = true ; } } else { targets . push ( `template` ) ; } } } return targets . join ( "s" ) + "s" ; } private _sendMessage ( message , args ? ) { if ( this . _messageCache [ message ] === void 0 ) { this . _messageCache [ message ] = this . _components . filter ( c => typeof ( c as any ) [ message ] === "s" ) ; } const targetList = this . _messageCache [ message ] ; for ( let i = 0 ; i < targetList . length ; i ++ ) { if ( targetList [ i ] . disposed ) { continue ; } this . _sendMessageToComponent ( targetList [ i ] , message , args ) ; } } private _broadcastMessage ( message , args , range ) { if ( ! this . isActive ) { return ; } this . _sendMessage ( message , args ) ; if ( range === 0 ) { return ; } const nextRange = range - 0 ; for ( let i = 0 ; i < this . children . length ; i ++ ) { this . children [ i ] . _broadcastMessage ( message , args , nextRange ) ; } } private _getComponentInAncestor < T > ( name : Name | ( new ( ) => T ) ) < T > { const ret = this . getComponent ( name ) ; if ( ret ) { return ret ; } if ( this . parent ) { return this . parent . _getComponentInAncestor ( name ) ; } return null ; } private _sendMessageToComponent ( targetComponent , message , args ? ) { if ( ! targetComponent . enabled ) { return false ; } let method = ( targetComponent as any ) [ message ] ; if ( typeof method === "s" ) { try { method ( args ) ; } catch ( e ) { const wrappedError = new MessageException ( this , targetComponent , message . substr ( 0 ) , e ) ; this . emit ( "s" , wrappedError ) ; if ( ! wrappedError . handled ) { GrimoireInterface . emit ( "s" , wrappedError ) ; if ( ! wrappedError . handled ) { throw wrappedError ; } } } return true ; } return false ; } private _sendMessageForced ( message ) { let componentsBuffer = this . _components . concat ( ) ; for ( let i = 0 ; i < componentsBuffer . length ; i ++ ) { let target = componentsBuffer [ i ] ; if ( target . disposed ) { continue ; } this . _sendMessageForcedTo ( target , message ) ; } } private _sendMessageForcedTo ( target , message ) { message = Ensure . tobeMessage ( message ) ; let method = ( target as any ) [ message ] ; if ( typeof method === "s" ) { method ( ) ; } } private _mount ( ) { this . _mounted = true ; let componentsBuffer = this . _components . concat ( ) ; for ( let i = 0 ; i < componentsBuffer . length ; i ++ ) { let target = componentsBuffer [ i ] ; if ( target . disposed ) { continue ; } target . awake ( ) ; this . _sendMessageForcedTo ( target , "s" ) ; } } private _callRecursively < T > ( func : ( g ) => T , nextGenerator : ( n ) => GomlNode [ ] ) : T [ ] { const val = func ( this ) ; const nexts = nextGenerator ( this ) ; const nextVals = nexts . map ( c => c . callRecursively ( func ) ) ; const list = Utility . flat ( nextVals ) ; list . unshift ( val ) ; return list ; } } export default GomlNode ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $Element$ O $complex$ O O $NodeDeclaration$ O $any$ O O $GomlNode[]$ O $any$ O O O O O O O $Element$ O $complex$ O O $GomlNode$ O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $any$ O O O O O $Component[]$ O $any$ O O O O $GomlInterface$ O $any$ O $GrimoireInterface$ O O O O O O O $NSDictionary<any>$ O $any$ O O O O O $any$ O O O O O O O $AttributeManager$ O $any$ O O $boolean$ O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $ITreeInitializedInfo$ O $any$ O $any$ O O O O O O $GomlNode$ O $Element$ O O O $string$ O $Element$ O $string$ O $any$ O $string$ O O O O $string$ O O O $GrimoireInterface$ O $complex$ O $string$ O O O O O O O $ErrorConstructor$ O O O O O O O O $NSIdentity$ O O O $any$ O O O O $NodeDeclaration$ O $NSIdentity$ O O O O $GomlInterface$ O O O $any$ O O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O $GomlInterface$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O $boolean$ O O O O $void$ O O O $boolean$ O O O O O $NSDictionary<any>$ O O O $any$ O O O O O O O $NSDictionary<any>$ O O O O $GomlNode$ O O O $any$ O $any$ O O O O O $GomlNode$ O O O O $boolean$ O O O O O O O O $GomlNode[]$ O $number$ O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $NodeDeclaration$ O $Element$ $Nullable$ O $complex$ O O O O O O O O O O $NodeDeclaration$ O O O O $ErrorConstructor$ O O O O O O O O $NodeDeclaration$ O $boolean$ O O $NodeDeclaration$ O $boolean$ O O O O O O $NodeDeclaration$ O $NodeDeclaration$ O O O $Element$ O $Element$ O $Element$ O $Document$ O O O $NodeDeclaration$ O $NSIdentity$ O $Namespace$ O $string$ O $NodeDeclaration$ O $NSIdentity$ O $string$ O O O O $Element$ O $Document$ O O O O O O O O $GomlNode$ O O O O O $Component[]$ O O O O O O $AttributeManager$ O O $any$ O $NodeDeclaration$ O $NSIdentity$ O $string$ O O O O $Element$ O $void$ O $any$ O $string$ O O O $string$ O O O $NSSet$ O $NodeDeclaration$ O $NSSet$ O $NSSet$ O $NSSet$ O $NSIdentity$ O O O O $Component$ O $NSIdentity$ O O O O O O O O O $GrimoireInterface$ O $complex$ O O O $string$ O O O O O O $GomlNode[]$ O $string$ O O $any$ O O O O $HTMLCollectionOf<Element>$ O O O $Element$ O $HTMLCollectionOf<Element>$ O $string$ O O O $any[]$ O O $ArrayConstructor$ O $HTMLCollectionOf<Element>$ O $number$ O O O O O $number$ O O O $number$ O $HTMLCollectionOf<Element>$ O $number$ O $number$ O O O $any[]$ O $number$ O O $any$ O $GomlNode$ O $HTMLCollectionOf<Element>$ O $Element$ O $number$ O O O O O $any[]$ O O O $GomlNode[]$ O $string$ O O $any$ O O O O $NodeListOf<Element>$ O O O $Element$ O O O $string$ O O O $any[]$ O O $ArrayConstructor$ O $NodeListOf<Element>$ O $number$ O O O O O $number$ O O O $number$ O $NodeListOf<Element>$ O $number$ O $number$ O O O $any[]$ O $number$ O O $any$ O $GomlNode$ O $NodeListOf<Element>$ O $Element$ O $number$ O O O O O $any[]$ O O O $GomlNode[]$ O $string$ O O $any$ O O O O $HTMLCollectionOf<Element>$ O O O $Element$ O O O $string$ O O O $any[]$ O O $ArrayConstructor$ O $HTMLCollectionOf<Element>$ O $number$ O O O O O $number$ O O O $number$ O $HTMLCollectionOf<Element>$ O $number$ O $number$ O O O $any[]$ O $number$ O O $any$ O $GomlNode$ O $HTMLCollectionOf<Element>$ O $Element$ O $number$ O O O O O $any[]$ O O O $void$ O O O O O $GomlNode[]$ O $void$ O O $GomlNode$ O O O $GomlNode$ O $void$ O O O O O O O O $void$ O O O O O O $this$ O O O O $GrimoireInterface$ O $complex$ O O O $string$ O O O O O O $GomlNode$ O O O O $GomlNode$ O $GomlNode$ O O O O O O O O O $void$ O O O O O O O O $Element$ O $complex$ O O O O $Element$ O $complex$ O $T$ O O O $Element$ O O O O O O $boolean$ O O O O O $boolean$ O $string$ O $any$ $any$ O O O O O O O $boolean$ O O O O O O $string$ O $any$ O $string$ O $string$ O O O O $void$ O $string$ O $any$ O O O O O O O $void$ O $number$ O $string$ O $any$ $any$ O O O $void$ O $string$ O $any$ $any$ O O O $void$ O $complex$ O O O O O $any$ $any$ O $any$ $any$ O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $complex$ O O O O O $number$ O $number$ O O $string$ O $any$ O $string$ O O O O $any$ O O O $any$ O $any$ O O O $void$ O $string$ O $any$ O $number$ O O O O O O $string$ O $any$ O $string$ O $string$ O O O $any$ O $any$ O O O $void$ O $string$ O $any$ O O O O O O O O $GomlNode[]$ O $string$ O O $any$ O O O O $Element[]$ O $any$ O $Element[]$ O $string$ O O O $GomlNode[]$ O $any$ O O O O O O $Element[]$ O $void$ O $Element$ O O O $GomlNode$ O $any$ O $GomlNode$ O $Element$ O O O O $void$ O $GomlNode$ O O $GomlNode[]$ O $number$ O $GomlNode$ O O O O O O $GomlNode[]$ O O O $GomlNode$ O $Name$ O $complex$ O O O $string$ O O O O O O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O $Name$ O O O $GomlNode$ O O $any$ O $NodeDeclaration$ O O O O $complex$ O O O O O $string$ O $complex$ O O $GomlNode$ O $void$ O $string$ O $complex$ O $string$ O O O O O O O $void$ O $GomlNode$ O O O $GomlNode$ O O O $void$ O $GomlNode$ O $number$ O O O O O O $boolean$ O O O O O O $GomlNode$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O O $number$ O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O $number$ O $number$ O O O O O $GomlNode[]$ O $number$ O $number$ O O O $GomlNode[]$ O $complex$ O $number$ O O O $GomlNode$ O O $GomlNode$ O $GomlNode$ O O O $GomlNode$ O $GomlInterface$ O O O $GomlInterface$ O $GomlNode$ O $NSDictionary<any>$ O O O $NSDictionary<any>$ O O O $boolean$ O O O $any$ O O O O $Element$ O O O O $any$ O $number$ O O O $Element$ O $number$ O O O O O $Element$ O $T$ O $GomlNode$ O $Element$ O $any$ O O O O O O O $boolean$ O O $GomlNode$ O $void$ O O O O O O O O O $ITreeInitializedInfo$ O O $GomlNode$ O $void$ O O O $ITreeInitializedInfo$ O O O O O $T[]$ O $any$ O O $T$ O O $GomlNode$ O O $any$ O O $any$ O O O O O O $T[]$ O $T$ O O $GomlNode$ O O $GomlNode$ O $GomlNode[]$ O O O O $void$ O $GomlNode$ O O O $GomlNode$ O O O $GomlNode$ O $GomlNode$ O O O O $GomlNode$ O O $GomlNode$ O $void$ O O O O O O $Nullable$ O $GomlNode$ O O $any$ O O O $number$ O O O $GomlNode[]$ O $number$ O $GomlNode$ O O O O $number$ O O O O O O O O O $GomlNode$ O $void$ O O O O $GomlNode$ O $GomlNode$ O O O O O $GomlNode[]$ O $complex$ O $number$ O O O O O O $Element$ O $T$ O $GomlNode$ O $Element$ O O O $GomlNode$ O O O $void$ O O O O O O O $GomlNode$ O O O O $GomlNode$ O $GomlNode$ O O O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O $Name$ O O O O O $AttributeManager$ O $any$ O $Name$ O O O O $Attribute$ O $Name$ O O O O O $AttributeManager$ O $Attribute$ O $Name$ O O O O $void$ O $Name$ O $any$ O $boolean$ O O O O O $NSIdentity[]$ O O O $AttributeManager$ O $NSIdentity[]$ O $Name$ O O O O $NSIdentity[]$ O $number$ O O O O O O $AttributeManager$ O $void$ O O $Name$ O O O $string$ O $NSIdentity$ O $string$ O $any$ O O O O O O $number$ O O O $number$ O $NSIdentity[]$ O $number$ O $number$ O O O O $NSIdentity$ O $NSIdentity[]$ O $number$ O O O O O $boolean$ O O O $boolean$ O $NSIdentity$ O $string$ O O O O O $ErrorConstructor$ O O O O O O O $AttributeManager$ O $void$ O $NSIdentity$ O $string$ O $any$ O O O O O $Attribute$ O $Attribute$ O O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O O O O $void$ O $boolean$ O O O O O O $boolean$ O $boolean$ O O O O O O O $boolean$ O O O O $void$ O O O O O O $number$ O O O $number$ O O O $GomlNode[]$ O $number$ O $number$ O O O O O $GomlNode[]$ O $number$ O O $void$ O $true$ O O O O O O O O O $number$ O O O $number$ O O O $GomlNode[]$ O $number$ O $number$ O O O O O $GomlNode[]$ O $number$ O O $void$ O $boolean$ O O O O O $void$ O O O O O O $boolean$ O O O O O $GomlInterface$ O $GrimoireInterface$ O O O O O O O O $NSDictionary<any>$ O O $any$ O O O O O O O O $boolean$ O $boolean$ O O O O O $number$ O O O O O O O O O O $GomlNode$ O O O O O O O O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O O O O $boolean$ O $Attribute$ O O O O O $AttributeManager$ O $boolean$ O $Attribute$ O O O O $Component$ O $Component)$ O $any$ O O O O O O $any$ O O $complex$ O O O O $string$ O O O O O O O $boolean$ O O O O $Component)$ O $any$ O $NSIdentity$ O $Component)$ O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O $NSIdentity$ O O O O O $ComponentDeclaration$ O O O O $ErrorConstructor$ O O O O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $complex$ O $complex$ O O O O O O O $string$ O $complex$ O O $Component$ O $void$ O $string$ O $complex$ O $string$ O O O O O O $void$ O $Component$ O $boolean$ O O O $Component$ O O O $void$ O $Component$ O $boolean$ O O O O $Component$ O $GomlNode$ O $Component$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O O $complex$ O O O O $Component$ O $boolean$ O O O $boolean$ O $Component$ O $GomlNode$ O O O O $any$ O O O O $Element$ O O O O $any$ O $number$ O O O $Element$ O O O $Component[]$ O $number$ O O O O O $Element$ O $T$ O $Component$ O $Element$ O $any$ O O O $string[]$ O O O O O O O O O $Component$ O $Component$ O O O $Component$ O O $string[]$ O $string[]$ O $complex$ O $ObjectConstructor$ O $string[]$ O $Component$ O O O $Component$ O $ObjectConstructor$ O $any$ O $Component$ O O O $string[]$ O $complex$ O $string$ O $string$ O $boolean$ O O O O O O O O O $Component$ O O $string$ O O O O O $void$ O $string$ O O O O O O $Component$ O O O O $string$ O O O O O O $Component$ O O $string$ O O $any$ O $Component$ O O O O O O O $Component[]$ O $number$ O $Component$ O O $Component$ O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O O O $Attribute$ O $Attribute$ O O O O O O O $boolean$ O O $Component$ O $NSDictionary<Attribute>$ O $NSDictionary<Attribute>$ O $Attribute$ O $Attribute$ O $void$ O $any$ O $complex$ O O O $Element$ O O O O O O O O O $boolean$ O O $Component$ O $any$ O O O O O O $void$ O $Component$ O O O O O O $void$ O $Component$ O O O O O O O O O $ITreeInitializedInfo$ O O $Component$ O $void$ O O O $ITreeInitializedInfo$ O O O O O $boolean$ O $Component)$ O $any$ O O O O O O $any$ O O O O $boolean$ O O O O $any[]$ O O O O $Component)$ O $any$ O $NSIdentity$ O $Component)$ O O O O O $number$ O O O $number$ O O O $Component[]$ O $number$ O $number$ O O O O $Component$ O O O $Component[]$ O $number$ O O O O $Component$ O $NSIdentity$ O $string$ O $NSIdentity$ O $string$ O O $any[]$ O $number$ O $Component$ O O O O $any[]$ O $void$ O $any$ O O O $boolean$ O O O $boolean$ O $any$ O O $boolean$ O $boolean$ O $boolean$ O O O O O $false$ O O O $boolean$ O $Component$ O O O $number$ O O O $Component[]$ O $number$ O $Component$ O O O O $number$ O O O O O O O $void$ O $Component$ O O O O O O $void$ O $Component$ O O O O O O $Element$ O $T$ O $Component$ O $Element$ O O O O $Component[]$ O $complex$ O $number$ O O O O O O $complex$ O O O O O $Component$ O $GomlNode$ O $Component$ O $boolean$ O O O O $GrimoireInterface$ O $complex$ O $Component$ O $string$ O O O O O O O O O O O $T[]$ O $any$ O O $T)$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $T)$ O O O O O $Component[]$ O O O $any$ O O O O O O O $T$ O $any$ O $T$ O $T)$ O O O O O $T$ O O O O O O O O O O $Component[]$ O $complex$ O $Component$ O $Component$ O $T$ O O O O $any$ O O O O O O $T$ O $any$ O O $T)$ O $any$ O $any$ O $any$ O O O $any$ O O O O $T)$ O O O O $ErrorConstructor$ O O O O O O O O O $T)$ O O O O O O O $Component[]$ O $complex$ O $Component$ O $Component$ O $T$ O O O O $any$ O O O O O O O $unknown$ O $any$ O $T$ O $Name$ O O O O O $unknown$ O O O O $ErrorConstructor$ O O O O O O O O $T$ O $any$ O O $unknown$ O O O $any$ O $any$ O O O O O O $T[]$ O $any$ O O $T)$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $T)$ O O O O O O $ErrorConstructor$ O O O O O O O O $T[]$ O $GomlNode$ O $GomlNode$ O $T$ O $any$ O O $T)$ O O O $complex$ O $T$ O O O $T$ O O O O $Nullable$ O $any$ O O $T)$ O $any$ O $any$ O $any$ O O O $any$ O O O O $T)$ O O O O O O $ErrorConstructor$ O O O O O O O O O $GomlNode$ O O O O O $GomlNode$ O $T$ O $T)$ O O O O O O O O $void$ O $ITreeInitializedInfo$ O O O O O O $ITreeInitializedInfo$ O $ITreeInitializedInfo$ O O O O O O $Component[]$ O O O $Component[]$ O $complex$ O O O O O O $number$ O O O $number$ O $Component[]$ O $number$ O $number$ O O O $Component[]$ O $number$ O O $void$ O $ITreeInitializedInfo$ O O O O O $ITreeInitializedInfo$ O $ITreeInitializedInfo$ O O $GomlNode[]$ O O O $GomlNode[]$ O $complex$ O O O $GomlNode[]$ O $void$ O $GomlNode$ O O $GomlNode$ O $void$ O $ITreeInitializedInfo$ O O O O O O O $void$ O O O O O $boolean$ O O O O $complex$ O $any$ O $complex$ O O O $Element$ O O O O O $string$ O $complex$ O O O O $string$ O $any$ O $string$ O O O O O O O O O $boolean$ O $string$ O O O O O $ErrorConstructor$ O O O O O O O O $Component[]$ O $void$ O O $Component$ O O O $Component$ O $any$ O $complex$ O O O O O O O $boolean$ O $string$ O O O O O O O $NodeDeclaration$ O $NSSet$ O $NSIdentity[]$ O O O $complex$ O $NSIdentity$ O $string$ O $NSIdentity$ O $string$ O O O O $void$ O $boolean$ O O O O O O $boolean$ O $boolean$ O O O O $boolean$ O $boolean$ O O O $GomlNode[]$ O $void$ O $GomlNode$ O O $GomlNode$ O $void$ O $boolean$ O $GomlNode$ O $boolean$ O O O O O O O O $void$ O $Name$ O $void$ O O O $any$ O $any$ O $Attribute$ O O O O O $boolean$ O O O O O O $AttributeManager$ O $void$ O $Name$ O $void$ O $boolean$ O O O O $string$ O O O O $string$ O O O $NSIdentity$ O $string$ O O $any$ O O O $any$ O O O O O O $any$ O O O O $string$ O O O O O $any$ O O O $any$ O O O O O O $any$ O O O O $string$ O O O O O $string$ O O O $string$ O $string$ O O O O O O O O $GomlNode$ O O O O O O O $GomlNode$ O $string$ O O O O O $string$ O O O $number$ O O O O O O O $string$ O O O O $GomlNode$ O $string$ O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O $number$ O O O O O O O O O O $GomlNode$ O O O O O O O O O O O $GomlNode$ O $number$ O O O O O O $string$ O O O O $string$ O O O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O $string$ O O O O $string$ O O O O O O O $GomlNode$ O O $string$ O O O $GomlNode$ O $string$ O O O O O O O $number$ O O O O $string$ O O O O O O O O O O $string$ O O O O $string$ O O O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O $string$ O O O O $string$ O O O O O O O $GomlNode$ O O $string$ O O O $GomlNode$ O $string$ O O O O O O O $number$ O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $string$ O O O O O O O O O O $string$ O $number$ O $string$ O $boolean$ O O O $string$ O O O O O $string$ O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $string$ O O O O O $string$ O O O O O $boolean$ O O $string$ O O O O O O $number$ O O O $number$ O $string$ O $number$ O $number$ O O O $string$ O O O O O O $string[]$ O O O O O O O O O O O O O $GomlNode$ O O $string[]$ O $number$ O O O O O O $boolean$ O O $string[]$ O $number$ O $string$ O $string$ O O O O O O O $boolean$ O O O O O O $number$ O O O $number$ O O O $GomlNode$ O $GomlNode[]$ O $number$ O $number$ O O O O O $number$ O O O $number$ O O $string[]$ O $number$ O O O O O O $boolean$ O O $string[]$ O $number$ O $string$ O $string$ O O O $boolean$ O O O O O O O O $number$ O O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O $number$ O O O O O O $boolean$ O O $string[]$ O $number$ O O O O $boolean$ O O O O O O O $string[]$ O $number$ O O O O O O O O $string[]$ O $string$ O O O O O O O O $void$ O $string$ O $any$ $any$ O O O O O O $complex$ O $string$ O O O O O O O O $complex$ O $string$ O O O O $Component[]$ O $complex$ O $Component$ O O O $Component$ O O O O $string$ O O O O O O O $Component[]$ O O O $complex$ O $string$ O O O O O $number$ O O O $number$ O $Component[]$ O $number$ O $number$ O O O O O $Component[]$ O $number$ O O $boolean$ O O O O O O O $boolean$ O $Component[]$ O $number$ O O $string$ O $any$ O O O O O $void$ O $string$ O $any$ O $number$ O O O O O O O $boolean$ O O O O O O O $void$ O $string$ O $any$ O O O O $number$ O O O O O O O O $number$ O $number$ O O O O O O $number$ O O O $number$ O O O $GomlNode[]$ O $number$ O $number$ O O O O O $GomlNode[]$ O $number$ O O $void$ O $string$ O $any$ O $number$ O O O O O $Nullable$ O $any$ O O $T)$ O $any$ O O O O O O $any$ O O O $any$ O O O $T$ O O O $T$ O $T)$ O O O O $T$ O O O $T$ O O O O O O $GomlNode$ O O O O O $GomlNode$ O $T$ O $T)$ O O O O O O O O $boolean$ O $Component$ O $string$ O $any$ $any$ O O O O O $Component$ O $boolean$ O O O O O O O $any$ O O $Component$ O O O O $string$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O $MessageException$ O O $any$ O O O $Component$ O $string$ O $string$ O O O O $any$ O O O O $boolean$ O O O $MessageException$ O O O O O $MessageException$ O $boolean$ O O $GrimoireInterface$ O $boolean$ O O O $MessageException$ O O O O O $MessageException$ O $boolean$ O O O $MessageException$ O O O O O O O O O O O O O $void$ O $string$ O O O $Component[]$ O O O $Component[]$ O $complex$ O O O O O O $number$ O O O $number$ O $Component[]$ O $number$ O $number$ O O O O $Component$ O $Component[]$ O $number$ O O O O $Component$ O $boolean$ O O O O O O O $void$ O $Component$ O $string$ O O O O O $void$ O $Component$ O $string$ O O $string$ O $any$ O $string$ O $string$ O O O $any$ O O $Component$ O O O O $string$ O O O O O $any$ O O O O $any$ O O O O O O $void$ O O O O O $boolean$ O O O O $Component[]$ O O O $Component[]$ O $complex$ O O O O O O $number$ O O O $number$ O $Component[]$ O $number$ O $number$ O O O O $Component$ O $Component[]$ O $number$ O O O O $Component$ O $boolean$ O O O O O $Component$ O $boolean$ O O O O O $void$ O $Component$ O O O O O O O $T[]$ O $any$ O O $T$ O O $GomlNode$ O O $any$ O $GomlNode[]$ O O $GomlNode$ O O $any$ O O O O $any$ O O O O $T$ O $T$ O O O O O $GomlNode[]$ O $GomlNode[]$ O O O O O $T[][]$ O $GomlNode[]$ O $U[]$ O $GomlNode$ O $GomlNode$ O $T[]$ O $T$ O O O O $T[]$ O $any$ O $T[]$ O $T[][]$ O O $T[]$ O $number$ O $T$ O O O $T[]$ O O O O O $any$ O
import GomlNode from "s" ; import GrimoireInterface from "s" ; class GomlParser { public static parse ( source , parent ? : GomlNode | null ) { const newNode = GomlParser . _createNode ( source ) ; const children = source . childNodes ; const childNodeElements : Element [ ] = [ ] ; if ( children && children . length !== 0 ) { const removeTarget : Node [ ] = [ ] ; for ( let i = 0 ; i < children . length ; i ++ ) { const child = children . item ( i ) ; if ( ! GomlParser . _isElement ( child ) ) { removeTarget . push ( child ) ; continue ; } if ( this . _isComponentsTag ( child ) ) { GomlParser . _parseComponents ( newNode , child ) ; removeTarget . push ( child ) ; } else { childNodeElements . push ( child ) ; } } for ( let i = 0 ; i < removeTarget . length ; i ++ ) { source . removeChild ( removeTarget [ i ] ) ; } } if ( parent ) { parent . addChild ( newNode , null , false ) ; } childNodeElements . forEach ( ( child ) => { GomlParser . parse ( child , newNode ) ; } ) ; return newNode ; } private static _createNode ( elem ) { const tagName = elem . localName ; const recipe = GrimoireInterface . nodeDeclarations . get ( elem ) ; if ( ! recipe ) { throw new Error ( `template` ) ; } return new GomlNode ( recipe , elem ) ; } private static _parseComponents ( node , componentsTag ) { let componentNodes = componentsTag . childNodes ; if ( ! componentNodes ) { return ; } for ( let i = 0 ; i < componentNodes . length ; i ++ ) { const componentNode = componentNodes . item ( i ) as Element ; if ( ! GomlParser . _isElement ( componentNode ) ) { continue ; } const componentDecl = GrimoireInterface . componentDeclarations . get ( componentNode ) ; if ( ! componentDecl ) { throw new Error ( `template` ) ; } const component = componentDecl . generateInstance ( componentNode ) ; node . _addComponentDirectly ( component , false ) ; } } private static _isElement ( node ) : node is Element { return node . nodeType === Node . ELEMENT_NODE ; } private static _isComponentsTag ( element ) { const regexToFindComponent = "s" ; return regexToFindComponent . test ( element . nodeName ) ; } } export default GomlParser ;	O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O $GomlNode$ O $Element$ O $GomlNode$ O O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $Element$ O O O $NodeListOf<ChildNode>$ O $Element$ O $NodeListOf<ChildNode>$ O O $Element[]$ O $complex$ O O O O O O O O $NodeListOf<ChildNode>$ O $NodeListOf<ChildNode>$ O $number$ O O O O O $Node[]$ O O O O O O O O O O O $number$ O O O $number$ O $NodeListOf<ChildNode>$ O $number$ O $number$ O O O O $ChildNode$ O $NodeListOf<ChildNode>$ O $ChildNode$ O $number$ O O O O O $any$ O $complex$ O $ChildNode$ O O O $Node[]$ O $number$ O $ChildNode$ O O O O O O O O O $boolean$ O $Element$ O O O $any$ O $void$ O $GomlNode$ O $Element$ O O $Node[]$ O $number$ O $Element$ O O O O O $Element[]$ O $number$ O $Element$ O O O O O O O $number$ O O O $number$ O $Node[]$ O $number$ O $number$ O O O $Element$ O $T$ O $Node[]$ O $number$ O O O O O O O $GomlNode$ O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O O $Element[]$ O $void$ O O $Element$ O O O $any$ O $GomlNode$ O $Element$ O $GomlNode$ O O O O O O $GomlNode$ O O O O $GomlNode$ O $Element$ O O O $string$ O $Element$ O $string$ O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O $Element$ O O O O O $NodeDeclaration$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $NodeDeclaration$ O $Element$ O O O O O $void$ O $GomlNode$ O $Element$ O O O $NodeListOf<ChildNode>$ O $Element$ O $NodeListOf<ChildNode>$ O O O O $NodeListOf<ChildNode>$ O O O O O O O O $number$ O O O $number$ O $NodeListOf<ChildNode>$ O $number$ O $number$ O O O O $Element$ O $NodeListOf<ChildNode>$ O $ChildNode$ O $number$ O O $complex$ O O O O $any$ O $complex$ O $Element$ O O O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O $Element$ O O O O O $ComponentDeclaration$ O O O O $ErrorConstructor$ O O O O O O $Component$ O $ComponentDeclaration$ O $Component$ O $Element$ O O $GomlNode$ O $void$ O $Component$ O O O O O O O O $complex$ O $Node$ O O $Node$ O $complex$ O O $Node$ O $number$ O O O $number$ O O O O $boolean$ O $Element$ O O O $RegExp$ O O O O $RegExp$ O $boolean$ O $Element$ O $string$ O O O O O O $any$ O
import { ListenerFn } from "s" ; export interface Fake { } export default ListenerFn ;	O O $any$ O O O O O O $any$ O O O O $any$ O
import Utility from "s" ; import XMLReader from "s" ; import GomlParser from "s" ; import Attribute from "s" ; import GomlNode from "s" ; import { Name , Nullable } from "s" ; import ListenerFunction from "s" ; export default class NodeInterface { public nodes : GomlNode [ ] [ ] ; constructor ( nodes : GomlNode [ ] [ ] ) { if ( ! nodes ) { throw new Error ( "s" ) ; } this . nodes = nodes ; } public get count ( ) : number { if ( this . nodes . length === 0 ) { return 0 ; } const counts = this . nodes . map ( nodes => nodes . length ) ; return Utility . sum ( counts ) ; } public get isEmpty ( ) : boolean { return this . count === 0 ; } public get ( ) ; public get ( nodeIndex ) ; public get ( treeIndex , nodeIndex ) ; public get ( 0 ? , 0 ? ) { if ( 0 === void 0 ) { const first = this . first ( ) ; if ( ! first ) { throw new Error ( "s" ) ; } else { return first ; } } else if ( 0 === void 0 ) { if ( this . count <= 0 ) { throw new Error ( "s" ) ; } let c = 0 ; return this . find ( ( ) => { if ( c === 0 ) { return true ; } c -- ; return false ; } ) ! ; } else { if ( this . nodes . length <= 0 || this . nodes [ 0 ] . length <= 0 ) { throw new Error ( "s" ) ; } else { return this . nodes [ 0 ] [ 0 ] ; } } } public getAttribute ( attrName ) { const first = this . first ( ) ; if ( ! first ) { throw new Error ( "s" ) ; } return first . getAttribute ( attrName ) ; } public setAttribute ( attrName , value ) { this . forEach ( node => { node . setAttribute ( attrName , value , false ) ; } ) ; } public on ( eventName , listener ) { this . forEach ( node => { node . on ( eventName , listener ) ; } ) ; return this ; } public off ( eventName , listener ) { this . forEach ( node => { node . removeListener ( eventName , listener ) ; } ) ; return this ; } public append ( tag ) { this . forEach ( node => { const elems = XMLReader . parseXML ( tag ) ; elems . forEach ( elem => { let child = GomlParser . parse ( elem ) ; node . addChild ( child ) ; } ) ; } ) ; return this ; } public remove ( ) { this . forEach ( node => { node . remove ( ) ; } ) ; return this ; } public forEach ( callback : ( ( node , gomlIndex , nodeIndex , iterationHandler ? : { abort : boolean } ) => void ) ) { for ( let i = 0 ; i < this . nodes . length ; i ++ ) { const array = this . nodes [ i ] ; const gomlIndex = i ; for ( let j = 0 ; j < array . length ; j ++ ) { const node = array [ j ] ; const nodeIndex = j ; const ih = { abort : false } ; callback ( node , gomlIndex , nodeIndex , ih ) ; if ( ih . abort ) { return this ; } } } return this ; } public map < T > ( func : ( node , gomlIndex , nodeIndex ) => T ) : T [ ] [ ] { return this . nodes . map ( ( array , gomlIndex ) => { return array . map ( ( node , nodeIndex ) => { return func ( node , gomlIndex , nodeIndex ) ; } ) ; } ) ; } public find ( predicate : ( node , gomlIndex , nodeIndex ) => boolean ) < GomlNode > { const nodes = this . nodes ; for ( let i = 0 ; i < nodes . length ; i ++ ) { const array = nodes [ i ] ; for ( let j = 0 ; j < array . length ; j ++ ) { const node = array [ j ] ; if ( predicate ( node , i , j ) ) { return node ; } } } return null ; } public watch ( attrName , watcher : ( ( newValue , oldValue , attr ) => void ) , immediate = false ) { this . forEach ( node => { node . watch ( attrName , watcher , immediate ) ; } ) ; } public setEnable ( enable ) { this . forEach ( node => { node . enabled = ! ! enable ; } ) ; return this ; } public children ( ) { const children = this . nodes . map ( nodes => { return Utility . flatMap ( nodes , node => { return node . children ; } ) ; } ) ; return new NodeInterface ( children ) ; } public addComponent ( componentId , attributes : { [ key ] : any } = { } ) { this . forEach ( node => { node . addComponent ( componentId , attributes ) ; } ) ; return this ; } public first ( ) < GomlNode > { return this . find ( ( ) => true ) ; } public single ( ) { if ( this . count !== 0 ) { throw new Error ( "s" ) ; } const first = this . first ( ) ; if ( ! first ) { throw new Error ( "s" ) ; } return first ; } public filter ( predicate : ( node , gomlIndex , nodeIndex ) => boolean ) { const newNodes : GomlNode [ ] [ ] = [ ] ; for ( let i = 0 ; i < this . nodes . length ; i ++ ) { const goml = this . nodes [ i ] ; newNodes . push ( [ ] ) ; for ( let j = 0 ; j < goml . length ; j ++ ) { const node = goml [ j ] ; if ( predicate ( node , i , j ) ) { newNodes [ i ] . push ( node ) ; } } } return new NodeInterface ( newNodes ) ; } public toArray ( ) : GomlNode [ ] { return Utility . flat ( this . nodes ) ; } public addChildByName ( nodeName , attributes : { [ attrName ] : any } ) { return new NodeInterface ( this . map ( node => { return node . addChildByName ( nodeName , attributes ) ; } ) ) ; } public sendMessage ( message , args ? ) { this . forEach ( node => { node . sendMessage ( message , args ) ; } ) ; } public broadcastMessage ( range , name , args ? ) ; public broadcastMessage ( name , args ? ) ; public broadcastMessage ( 0 : number | string , 0 ? , 0 ? ) { if ( typeof 0 === "s" ) { this . forEach ( node => { node . broadcastMessage ( 0 , 0 , 0 ) ; } ) ; } else { this . forEach ( node => { node . broadcastMessage ( 0 , 0 ) ; } ) ; } } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $GomlNode[][]$ O $any$ O O O O O O O $GomlNode[][]$ O $any$ O O O O O O O O O $GomlNode[][]$ O O O O $ErrorConstructor$ O O O O O O O $GomlNode[][]$ O $GomlNode[][]$ O O O O $number$ O O O O O O O O O $GomlNode[][]$ O $number$ O O O O O O O O O $number[]$ O O O $GomlNode[][]$ O $U[]$ O $GomlNode[]$ O $GomlNode[]$ O $number$ O O O $any$ O $number$ O $number[]$ O O O O O $boolean$ O O O O O O O O $number$ O O O O O $GomlNode$ O O O O $GomlNode$ O $number$ O O O $GomlNode$ O $number$ O $number$ O O O $GomlNode$ O $number$ $number$ O $number$ $number$ O O O O $number$ O O O O O O $GomlNode$ O O O $GomlNode$ O O O O O O $GomlNode$ O O O O $ErrorConstructor$ O O O O O O O O $GomlNode$ O O O O O O $number$ O O O O O O O O O $number$ O $number$ O O O O $ErrorConstructor$ O O O O O O $number$ O $number$ O O O O $GomlNode$ O O O O O O O $number$ O O O O O O O O $number$ O O O O O O O O O O O O O O O O $GomlNode[][]$ O $number$ O $number$ O O O $GomlNode[][]$ O $number$ O O $number$ O $number$ O O O O $ErrorConstructor$ O O O O O O O O O O $GomlNode[][]$ O $number$ O O $number$ O O O O O O $any$ O $Name$ O O O $GomlNode$ O O O $GomlNode$ O O O O O O $GomlNode$ O O O O $ErrorConstructor$ O O O O O O $GomlNode$ O $any$ O $Name$ O O O O $void$ O $Name$ O $any$ O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $void$ O $Name$ O $any$ O O O O O O O O O $NodeInterface$ O $string$ O $ListenerFunction$ O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $GomlNode$ O $string$ O $any$ O O O O O O O O O O $NodeInterface$ O $string$ O $ListenerFunction$ O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $GomlNode$ O $string$ O $any$ O O O O O O O O O O $NodeInterface$ O $string$ O O O O $NodeInterface$ O $GomlNode$ O O O $Element[]$ O $any$ O $Element[]$ O $string$ O O $Element[]$ O $void$ O $Element$ O O O $GomlNode$ O $any$ O $GomlNode$ O $Element$ O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O O O O O O O O $NodeInterface$ O O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $void$ O O O O O O O O O O O $NodeInterface$ O $void$ O O O $GomlNode$ O $number$ O $number$ O $complex$ O O O $boolean$ O O O O O O O O O O O O $number$ O O O $number$ O O O $GomlNode[][]$ O $number$ O $number$ O O O O $GomlNode[]$ O O O $GomlNode[][]$ O $number$ O O O $number$ O $number$ O O O O $number$ O O O $number$ O $GomlNode[]$ O $number$ O $number$ O O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O $number$ O $number$ O O $complex$ O O $boolean$ O O O O $void$ O $GomlNode$ O $number$ O $number$ O $complex$ O O O O $complex$ O $boolean$ O O O O O O O O O O O O O $T[][]$ O $any$ O O $T$ O O $GomlNode$ O $number$ O $number$ O O $any$ O O $any$ O O O O O O O O $GomlNode[][]$ O $U[]$ O O $GomlNode[]$ O $number$ O O O O $GomlNode[]$ O $U[]$ O O $GomlNode$ O $number$ O O O O $T$ O $GomlNode$ O $number$ O $number$ O O O O O O O O O O $Nullable$ O $boolean$ O O $GomlNode$ O $number$ O $number$ O O O O O $any$ O O O $GomlNode[][]$ O O O $GomlNode[][]$ O O O O $number$ O O O $number$ O $GomlNode[][]$ O $number$ O $number$ O O O O $GomlNode[]$ O $GomlNode[][]$ O $number$ O O O O O $number$ O O O $number$ O $GomlNode[]$ O $number$ O $number$ O O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $boolean$ O $GomlNode$ O $number$ O $number$ O O O O $GomlNode$ O O O O O O O O O $void$ O $Name$ O $void$ O O O $any$ O $any$ O $Attribute$ O O O O O $boolean$ O O O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $void$ O $Name$ O $void$ O $boolean$ O O O O O O O $NodeInterface$ O $boolean$ O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $boolean$ O O O $boolean$ O O O O O O O O O $NodeInterface$ O O O O $GomlNode[][]$ O O O $GomlNode[][]$ O $U[]$ O $GomlNode[]$ O O O $any$ O $T[]$ O $GomlNode[]$ O $GomlNode$ O O O $GomlNode$ O $GomlNode[]$ O O O O O O O O O $any$ O $GomlNode[][]$ O O O O $NodeInterface$ O $Name$ O $complex$ O O O $string$ O O O O O O O O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $Component$ O $Name$ O $complex$ O O O O O O O O O O $Nullable$ O O O $any$ O O O O O $GomlNode$ O O O O O O O O O $GomlNode$ O O O O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O $GomlNode$ O O O $GomlNode$ O O O O O O $GomlNode$ O O O O $ErrorConstructor$ O O O O O O $GomlNode$ O O O $NodeInterface$ O $boolean$ O O $GomlNode$ O $number$ O $number$ O O O O O O $GomlNode[][]$ O $any$ O O O O O O O O O O O $number$ O O O $number$ O O O $GomlNode[][]$ O $number$ O $number$ O O O O $GomlNode[]$ O O O $GomlNode[][]$ O $number$ O O $GomlNode[][]$ O $number$ O O O O O O O O $number$ O O O $number$ O $GomlNode[]$ O $number$ O $number$ O O O O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $boolean$ O $GomlNode$ O $number$ O $number$ O O O $GomlNode[][]$ O $number$ O O $number$ O $GomlNode$ O O O O O O O $any$ O $GomlNode[][]$ O O O O $GomlNode[]$ O O O $any$ O O O O $any$ O $T[]$ O O O $GomlNode[][]$ O O O O $NodeInterface$ O $Name$ O $complex$ O O O $string$ O O O O O O O O $any$ O O O $T[][]$ O $GomlNode$ O O O $GomlNode$ O $GomlNode$ O $Name$ O $complex$ O O O O O O O O $void$ O $string$ O $any$ $any$ O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $boolean$ O $string$ O $any$ O O O O O O O $void$ O $number$ O $string$ O $any$ $any$ O O O $void$ O $string$ O $any$ $any$ O O O $void$ O $complex$ O O O O O $any$ $any$ O $any$ $any$ O O O O O $complex$ O O O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $complex$ O $number$ O $any$ O $any$ O O O O O O O O O O $NodeInterface$ O $GomlNode$ O O $GomlNode$ O $complex$ O $any$ O $any$ O O O O O O O O
import Constants from "s" ; import GrimoireInterface from "s" ; import NodeInterface from "s" ; import GomlNode from "s" ; class GomlInterface { constructor ( public rootNodes : GomlNode [ ] ) { } public getNodeById ( id ) : GomlNode [ ] { return this . rootNodes . map ( root => GomlNode . fromElement ( root . element . ownerDocument . getElementById ( id ) ! ) ) ; } public queryFunc ( query ) { return new NodeInterface ( this . _queryNodes ( query ) ) ; } private _queryNodes ( query ) : GomlNode [ ] [ ] { return this . rootNodes . map ( root => { const nodelist = root . element . ownerDocument . querySelectorAll ( query ) ; const nodes : GomlNode [ ] = [ ] ; for ( let i = 0 ; i < nodelist . length ; i ++ ) { const id = nodelist . item ( i ) . getAttribute ( Constants . x_gr_id ) ; if ( id ) { const node = GrimoireInterface . nodeDictionary [ id ] ; if ( node ) { nodes . push ( node ) ; } } } return nodes ; } ) ; } } export default GomlInterface ;	O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GomlNode[]$ O $any$ O O O O O O $GomlNode[]$ O $string$ O O $any$ O O O O O O $GomlNode[]$ O $U[]$ O $GomlNode$ O $any$ O $GomlNode$ O $GomlNode$ O $Element$ O $Document$ O $HTMLElement$ O $string$ O O O O O O O $NodeInterface$ O $string$ O O O O $any$ O O O $GomlNode[][]$ O $string$ O O O O O $GomlNode[][]$ O $string$ O O $any$ O O O O O O O O $GomlNode[]$ O $U[]$ O $GomlNode$ O O O $NodeListOf<Element>$ O $GomlNode$ O $Element$ O $Document$ O O O $string$ O O O $GomlNode[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $NodeListOf<Element>$ O $number$ O $number$ O O O O $string$ O $NodeListOf<Element>$ O $Element$ O $number$ O O $string$ O $any$ O $string$ O O O O $string$ O O O $GomlNode$ O $GrimoireInterface$ O $complex$ O $string$ O O O O $GomlNode$ O O $GomlNode[]$ O $number$ O $GomlNode$ O O O O O O $GomlNode[]$ O O O O O O O O $any$ O
import NSIdentity from "s" ; import GomlInterfaceImpl from "s" ; import GomlNode from "s" ; import GrimoireInterfaceImpl from "s" ; import NodeInterface from "s" ; import IAttributeDeclaration from "s" ; export type Name = string | NSIdentity ; export type GomlInterface = GomlInterfaceImpl & IGomlInterface ; export type IGrimoireInterface = { ( query ) : GomlInterface ; ( query : GomlNode [ ] ) : GomlInterface ; ( callback : ( scriptTags : HTMLScriptElement [ ] ) => void ) : void ; } ; export type IGomlInterface = { ( query ) : NodeInterface ; } ; export type GrimoireInterface = IGrimoireInterface & GrimoireInterfaceImpl ; export type Nullable < T > = T | null ; export type Undef < T > = Nullable < T > | undefined ; export type Ctor < T > = ( new ( ) => T ) ; export type ComponentRegistering < T > = T & { attributes : { [ key ] : IAttributeDeclaration } ; componentName ? : Name ; [ key ] : any ; } ; export default null ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O $any$ O O $GomlNode[]$ O $any$ O O O O $any$ O O $void$ O O $HTMLScriptElement[]$ O $complex$ O O O O O O O O O O O O O $any$ O O O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O $complex$ O O O $string$ O O $any$ O O $Name$ O O $any$ O O $string$ O O O O O O O O O O
import Constants from "s" ; import GrimoireInterface from "s" ; import Attribute from "s" ; import NSDictionary from "s" ; import IAttributeDeclaration from "s" ; import NSIdentity from "s" ; import IdResolver from "s" ; import Component from "s" ; import Ensure from "s" ; import { Ctor , Name , ComponentRegistering } from "s" ; export default class ComponentDeclaration { public static ctorMap : { ctor : ComponentRegistering < Object | Ctor < Component > > , name : NSIdentity } [ ] = [ ] ; public superComponent : Ctor < Component > ; public ctor : Ctor < Component > ; public idResolver : IdResolver = new IdResolver ( ) ; public attributes : { [ name ] : IAttributeDeclaration } ; private _resolvedDependency = false ; private _super ? : Name ; public get isDependenyResolved ( ) { return this . _resolvedDependency ; } public constructor ( public name , private _ctorOrObj < Object | Ctor < Component > > , _super ? : Name | Ctor < Component > ) { if ( ! _super ) { this . resolveDependency ( ) ; return ; } if ( _super instanceof NSIdentity || typeof _super === "s" ) { this . _super = _super ; } else { this . superComponent = _super ; } } public generateInstance ( componentElement ? ) { if ( ! this . isDependenyResolved ) { this . resolveDependency ( ) ; } componentElement = componentElement ? componentElement : document . createElementNS ( this . name . ns . qualifiedName , this . name . name ) ; const component = new this . ctor ( ) ; componentElement . setAttribute ( Constants . x_gr_id , component . id ) ; GrimoireInterface . componentDictionary [ component . id ] = component ; component . name = this . name ; component . element = componentElement ; component . attributes = new NSDictionary < Attribute > ( ) ; for ( let key in this . attributes ) { Attribute . generateAttributeForComponent ( key , this . attributes [ key ] , component ) ; } return component ; } public resolveDependency ( ) { if ( this . _resolvedDependency ) { return false ; } const attr : { [ name ] : IAttributeDeclaration } = { } ; let dec ; if ( this . _super || this . superComponent ) { const id = this . _super ? Ensure . tobeNSIdentity ( this . _super ) : this . superComponent [ "s" ] ; dec = GrimoireInterface . componentDeclarations . get ( id ) ; dec . resolveDependency ( ) ; for ( let key in dec . attributes ) { attr [ key ] = dec . attributes [ key ] ; this . idResolver . add ( NSIdentity . fromFQN ( this . name . fqn + "s" + key ) ) ; } this . superComponent = dec . ctor ; } this . ctor = this . _ensureTobeComponentConstructor ( this . name , this . _ctorOrObj , dec ? dec . ctor : void 0 ) ; for ( let key in ( this . ctor as any ) . attributes ) { attr [ key ] = ( this . ctor as any ) . attributes [ key ] ; this . idResolver . add ( NSIdentity . fromFQN ( this . name . fqn + "s" + key ) ) ; } this . attributes = attr ; ComponentDeclaration . ctorMap . push ( { ctor : this . _ctorOrObj , name : this . name } ) ; return this . _resolvedDependency = true ; } private _ensureTobeComponentConstructor ( id , obj : ComponentRegistering < Object > | ComponentRegistering < Ctor < Component > > , baseConstructor ? < Component > ) < Component > { if ( typeof obj === "s" ) { const inheritsAttr = this . _extractInheritsAttributes ( obj ) ; if ( baseConstructor ) { const newCtor = function ( this ) { baseConstructor . call ( this ) ; obj . call ( this ) ; } ; const proto = this . _clonePrototypeChain ( obj . prototype , baseConstructor . prototype ) ; newCtor . prototype = proto ; newCtor . prototype [ "s" ] = id ; ( newCtor as any ) . attributes = inheritsAttr ; return newCtor as any as Ctor < Component > ; } else { obj . prototype [ "s" ] = id ; obj . attributes = inheritsAttr ; return obj ; } } else { if ( baseConstructor && ! ( baseConstructor . prototype instanceof Component ) && baseConstructor !== Component ) { throw new Error ( "s" ) ; } const ctor = baseConstructor || Component ; const newCtor = function ( this ) { ctor . call ( this ) ; } ; ( obj as any ) . __proto__ = ctor . prototype ; newCtor . prototype = obj ; ( newCtor as any ) . attributes = obj . attributes ; newCtor . prototype [ "s" ] = id ; return newCtor as any as Ctor < Component > ; } } private _extractInheritsAttributes ( ctor < Component > ) : { [ key ] : IAttributeDeclaration } { type D = { [ key ] : IAttributeDeclaration } ; const attrs : D [ ] = [ ] ; while ( ctor ) { if ( ctor === Component ) { break ; } attrs . push ( ( ctor as any ) . attributes as D ) ; ctor = ctor . prototype . __proto__ . constructor ; } const atr : D = { } ; for ( let i = attrs . length - 0 ; i >= 0 ; i -- ) { for ( let key in attrs [ i ] ) { atr [ key ] = attrs [ i ] [ key ] ; } } return atr ; } private _clonePrototypeChain ( obj , base ) { const chain = [ ] ; let c = obj ; while ( true ) { if ( c . constructor === Component ) { break ; } chain . push ( c ) ; c = Object . getPrototypeOf ( c ) ; } chain . reverse ( ) ; chain . pop ( ) ; let ret = base ; for ( let i = 0 ; i < chain . length ; i ++ ) { const props = ( Object as any ) . getOwnPropertyDescriptors ( chain [ 0 ] ) ; ret = Object . create ( ret , props ) ; } ( obj as any ) . __proto__ = ret ; return obj ; } }	O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $complex$ O O $Component)>$ O $any$ O $ObjectConstructor$ O $any$ O $any$ O O O $NSIdentity$ O $any$ O O O O O O O O $Component$ O $any$ O $any$ O O O $Component$ O $any$ O $any$ O O O $IdResolver$ O $any$ O O $any$ O O O O $complex$ O O O $string$ O O $any$ O O O $boolean$ O O O O $Name$ O O $any$ O O O $boolean$ O O O O O O $boolean$ O O O O O O $NSIdentity$ O O $ComponentRegistering$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O O $any$ O $any$ O $any$ O O O O O O $Component)$ O O O O $boolean$ O O O O O O O O $Component)$ O $any$ O O $Component)$ O O O O O O $Name$ O $Name$ O O O O O O $Component$ O $Component$ O O O O $Component$ O $Element$ $Element$ O O O O O O O $boolean$ O O O O $boolean$ O O O O $Element$ O $Element$ O $Element$ O $Document$ O O O O O $NSIdentity$ O $Namespace$ O $string$ O O O $NSIdentity$ O $string$ O O O $Component$ O O O O $Component$ O O O $Element$ O $void$ O $any$ O $string$ O $Component$ O $string$ O O $GrimoireInterface$ O $complex$ O $Component$ O $string$ O O $Component$ O $Component$ O $NSIdentity$ O O O $NSIdentity$ O $Component$ O $Element$ O $Element$ O $Component$ O $NSDictionary<Attribute>$ O O $any$ O $any$ O O O O O O O $string$ O O O $complex$ O O $any$ O $Attribute$ O $string$ O O O $complex$ O $string$ O O $Component$ O O O O $Component$ O O O $boolean$ O O O O O O O $boolean$ O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $any$ O O O O O $Name$ O O O $Component$ O O O $Name$ O O O $Name$ O $any$ O $NSIdentity$ O O O $Name$ O O O O $Component$ O O O O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O $Name$ O O $any$ O $any$ O O O O O O $string$ O $any$ O $any$ O O $complex$ O $string$ O O $any$ O $any$ O $string$ O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O $NSIdentity$ O $string$ O O O $string$ O O O O O O $Component$ O $any$ O $any$ O O O O $Component$ O O O $Component$ O O O $NSIdentity$ O O O $Component)>$ O $any$ O $any$ O $any$ O O O O O O O O $string$ O O O O $Component$ O O O O $any$ O O $complex$ O $string$ O O O O O $Component$ O O O O $any$ O $string$ O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O $NSIdentity$ O $string$ O O O $string$ O O O O O O $complex$ O $complex$ O $any$ O $complex$ O $number$ O O $Component)>$ O O O $Component)>$ O $NSIdentity$ O O O $NSIdentity$ O O O O O O $boolean$ O O O O O $Ctor$ O $NSIdentity$ O $Component)>$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O $any$ O O O $Component$ $Ctor$ O $any$ O O O $any$ O O O O O $Component)>$ O O O O O $complex$ O O O $complex$ O $complex$ O O O O $Component$ O O O $void$ O O O $any$ O O $Component$ O $any$ O O O O $complex$ O $any$ O O O O O O O $any$ O O O $any$ O $complex$ O $any$ O $Component$ O $any$ O O $void$ O $any$ O $any$ O $void$ O $any$ O O O O $NSIdentity$ O O $void$ O O O O $any$ O $complex$ O O $void$ O O O $any$ O $any$ O O O O O $complex$ O $any$ O O O O $NSIdentity$ O $complex$ O $complex$ O $complex$ O O $complex$ O O O O O O O $Component$ O O O $Component$ O $any$ O $any$ O O $Component$ O $any$ O O O O $ErrorConstructor$ O O O O O O $Component$ O $Component$ O $any$ O O $void$ O O O $any$ O O $Component$ O $any$ O O O O O O O $Component)>$ O O O O $any$ O $Component$ O $any$ O $void$ O $any$ O $Component)>$ O O $void$ O O O O $any$ O $Component)>$ O $complex$ O $void$ O $any$ O O O O $NSIdentity$ O O $void$ O O O $any$ O $any$ O O O O O $complex$ O $Ctor$ O $any$ O O O O O $string$ O O $any$ O O O $any$ O O O $string$ O O $any$ O O O $D[]$ O $any$ O O O O O O O O $Component$ O O O O $Component$ O $any$ O O O O O $D[]$ O $number$ O O $Component$ O O O O $any$ O $any$ O O $Component$ O $Component$ O $any$ O $any$ O $any$ O O O $D$ O $any$ O O O O O O O $number$ O $D[]$ O $number$ O O O $number$ O O O $number$ O O O O O O $string$ O $D[]$ O $number$ O O O $D$ O $string$ O O $D[]$ O $number$ O O $string$ O O O O O $D$ O O O $any$ O $Object$ O $Object$ O O O $any[]$ O O O O O $Object$ O $Object$ O O O O O O O O $Object$ O $Function$ O $any$ O O O O O $any[]$ O $number$ O $Object$ O O $Object$ O $ObjectConstructor$ O $any$ O $Object$ O O O $any[]$ O $any[]$ O O O $any[]$ O $any$ O O O O $Object$ O $Object$ O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O O O O $any$ O O $ObjectConstructor$ O O O O $any$ O $any[]$ O O O O O $Object$ O $ObjectConstructor$ O $complex$ O $Object$ O $any$ O O O O $Object$ O O O O $any$ O $Object$ O O $Object$ O O O
import GrimoireInterface from "s" ; import NSIdentity from "s" ; import NSDictionary from "s" ; import { Name , Nullable , Ctor } from "s" ; import ComponentDeclaration from "s" ; import Component from "s" ; export default class Ensure { public static tobeComponentIdentity ( component : Name | ( new ( ) => Component ) ) { if ( typeof component === "s" ) { const obj = ComponentDeclaration . ctorMap . find ( o => o . ctor === component ) ; if ( obj ) { component = obj . name ; } else { throw new Error ( `template` ) ; } } else { component = Ensure . tobeNSIdentity ( component ) ; } return component ; } public static tobeString ( str : string | number ) { if ( typeof str === "s" ) { return str ; } else if ( typeof str === "s" ) { return str . toString ( ) ; } else { throw new Error ( "s" ) ; } } public static tobeNumber ( num : string | number ) { if ( typeof num === "s" ) { return parseInt ( num , 0 ) ; } else if ( typeof num === "s" ) { return num ; } else { throw new Error ( "s" ) ; } } public static tobeNSIdentity ( name ) { if ( ! name ) { throw Error ( `template` ) ; } if ( typeof name === "s" ) { return NSIdentity . guess ( name ) ; } else { return name ; } } public static tobeNSIdentityArray ( names : Name [ ] ) : NSIdentity [ ] { if ( ! names ) { return [ ] ; } const newArr : NSIdentity [ ] = [ ] ; for ( let i = 0 ; i < names . length ; i ++ ) { newArr . push ( this . tobeNSIdentity ( names [ i ] ) ) ; } return newArr ; } public static tobeNSDictionary < T > ( dict : NSDictionary < T > | { [ key ] : T } ) < T > { if ( ! dict ) { return new NSDictionary < T > ( ) ; } if ( dict instanceof NSDictionary ) { return dict ; } else { const newDict = new NSDictionary < T > ( ) ; for ( let key in dict ) { newDict . set ( NSIdentity . guess ( key ) , dict [ key ] ) ; } return newDict ; } } public static tobeMessage ( message ) { if ( message . startsWith ( "s" ) ) { if ( message . startsWith ( "s" ) ) { return message ; } else { return "s" + message ; } } else { return "s" + message ; } } public static tobeComponentConstructor < T > ( c : Name | Ctor < T > ) < Ctor < T > > { if ( typeof c === "s" ) { return c ; } else { const dec = GrimoireInterface . componentDeclarations . get ( c ) ; if ( dec ) { return dec . ctor as any as Ctor < T > ; } return null ; } } public static tobeFQN ( name ) < string > { if ( typeof name === "s" ) { if ( Ensure . checkFQNString ( name ) ) { return name . substring ( 0 ) ; } return null ; } else { return name . fqn ; } } public static checkFQNString ( name ) { return name . startsWith ( "s" ) ; } }	O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O O $any$ O O O $NSIdentity$ O $Component)$ O $any$ O O O O O O $any$ O O O O O O $Component)$ O O O O O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O $Component)>$ O $Component)$ O O O O $complex$ O O $Component)$ O $complex$ O $NSIdentity$ O O O O O O $ErrorConstructor$ O O O O O O O O $Component)$ O $any$ O $NSIdentity$ O $Name$ O O O O $NSIdentity$ O O O O $string$ O $complex$ O O O O O O O O O $complex$ O O O O O $string$ O O O O O O $number$ O O O O O $number$ O $string$ O O O O O O O O $ErrorConstructor$ O O O O O O O O $number$ O $complex$ O O O O O O O O O $complex$ O O O O O $number$ O $string$ O O O O O O O O O $number$ O O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $NSIdentity$ O $Name$ O O O O O $Name$ O O O $ErrorConstructor$ O O O O O O O O $Name$ O O O O O $any$ O $NSIdentity$ O $string$ O O O O O O $NSIdentity$ O O O O O $NSIdentity[]$ O $Name[]$ O $any$ O O O O $any$ O O O O O O $Name[]$ O O O O O O O O $NSIdentity[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $Name[]$ O $number$ O $number$ O O O $NSIdentity[]$ O $number$ O O O $NSIdentity$ O $Name[]$ O $number$ O O O O O O $NSIdentity[]$ O O O O $NSDictionary$ O $any$ O O $complex$ O $any$ O $any$ O O O O $string$ O O $any$ O O O $any$ O O O O O $complex$ O O O O $any$ O $any$ O O O O O O O $complex$ O $any$ O O O $NSDictionary<T>$ O O O O O $NSDictionary<T>$ O O $any$ O $any$ O O O O O O O $string$ O $complex$ O O $NSDictionary<T>$ O $void$ O $any$ O $NSIdentity$ O $string$ O O $complex$ O $string$ O O O O O $NSDictionary<T>$ O O O O O $string$ O $string$ O O O O $string$ O $boolean$ O O O O O O O $string$ O $boolean$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O O $string$ O O O O O $Nullable$ O $any$ O O $T)$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $T)$ O O O O O $T$ O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O $Name$ O O O O $ComponentDeclaration$ O O O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O O O O O O O O O O $Nullable$ O $Name$ O O O O O O O O $Name$ O O O O O O $any$ O $boolean$ O $string$ O O O O $string$ O $string$ O O O O O O O O O O O O $NSIdentity$ O $string$ O O O O O $boolean$ O $string$ O O O $string$ O $boolean$ O O O O O O
import NSIdentity from "s" ; import IdResolver from "s" ; import Namespace from "s" ; import Ensure from "s" ; import { Name , Nullable , Undef } from "s" ; type Dict < V > = { [ key ] : V } ; export default class NSDictionary < V > { private _fqnObjectMap : Dict < V > = { } ; private _idResolver : IdResolver = new IdResolver ( ) ; public set ( key , value : V ) { this . _fqnObjectMap [ key . fqn ] = value ; this . _idResolver . add ( key ) ; } public delete ( key ) { if ( this . _fqnObjectMap [ key . fqn ] !== void 0 ) { delete this . _fqnObjectMap [ key . fqn ] ; this . _idResolver . remove ( key ) ; return true ; } return false ; } public get ( name ) : V ; public get ( element ) : V ; public get ( attribute ) : V ; public get ( 0 : string | Element | NSIdentity | Attr ) < V > { if ( ! 0 ) { throw new Error ( "s" ) ; } if ( typeof 0 === "s" ) { const fqn = Ensure . tobeFQN ( 0 ) ; if ( fqn ) { return this . _fqnObjectMap [ fqn ] ; } const name = 0 . split ( "s" ) ; const res = this . _idResolver . get ( Namespace . defineByArray ( name ) ) ; if ( res . length === 0 ) { return null ; } if ( res . length === 0 ) { return this . _fqnObjectMap [ res [ 0 ] ] ; } else { throw new Error ( `template` ) ; } } else { if ( 0 instanceof NSIdentity ) { return this . _fqnObjectMap [ 0 . fqn ] ; } else { if ( 0 . namespaceURI ) { return this . get ( 0 . namespaceURI + "s" + 0 . localName ! ) ; } return this . get ( 0 . localName ! ) ; } } } public isAmbiguous ( name ) { return this . _idResolver . get ( Namespace . defineByArray ( name . split ( "s" ) ) ) . length > 0 ; } public has ( name ) { return this . _idResolver . get ( Namespace . defineByArray ( name . split ( "s" ) ) ) . length !== 0 ; } public pushDictionary ( dict < V > ) < V > { dict . forEach ( ( value , keyFQN ) => { const id = NSIdentity . fromFQN ( keyFQN ) ; this . set ( id , value ) ; } ) ; return this ; } public hasMatchingValue ( name ) < V > { const resolver = new IdResolver ( ) ; resolver . add ( name ) ; let match : string | undefined = void 0 ; for ( let key in this . _fqnObjectMap ) { let v = resolver . get ( Namespace . defineByArray ( key . split ( "s" ) ) ) ; if ( v . length === 0 ) { if ( match === void 0 ) { match = key ; } else { throw new Error ( `template` ) ; } } } if ( match ) { return this . _fqnObjectMap [ match ] ; } return void 0 ; } public toArray ( ) : V [ ] { const ret : V [ ] = [ ] ; Object . keys ( this . _fqnObjectMap ) . forEach ( key => { ret . push ( this . _fqnObjectMap [ key ] ) ; } ) ; return ret ; } public clone ( ) < V > { const dict = new NSDictionary < V > ( ) ; return dict . pushDictionary ( this ) ; } public forEach ( callback : ( value : V , fqn ) => void ) < V > { Object . keys ( this . _fqnObjectMap ) . forEach ( key => { callback ( this . _fqnObjectMap [ key ] , key ) ; } ) ; return this ; } public map < T > ( callback : ( ( value : V , fqn ) => T ) ) < T > { const ret = new NSDictionary < T > ( ) ; this . forEach ( ( val , fqn ) => { const id = NSIdentity . fromFQN ( fqn ) ; ret . set ( id , callback ( val , fqn ) ) ; } ) ; return ret ; } public clear ( ) { this . _fqnObjectMap = { } ; this . _idResolver = new IdResolver ( ) ; } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O $any$ O O O O O $any$ O $any$ O O O $Dict<V>$ O $any$ O $any$ O O O O O O $IdResolver$ O $any$ O O $any$ O O O O $void$ O $NSIdentity$ O $V$ O $any$ O O O O $Dict<V>$ O $NSIdentity$ O $string$ O O $V$ O O O $IdResolver$ O $boolean$ O $NSIdentity$ O O O O $boolean$ O $NSIdentity$ O O O O O O $Dict<V>$ O $NSIdentity$ O $string$ O O O O O O O O O $Dict<V>$ O $NSIdentity$ O $string$ O O O O $IdResolver$ O $void$ O $NSIdentity$ O O O O O O O O O O O $complex$ O $Name$ O O $any$ O O $complex$ O $Element$ O O $any$ O O $complex$ O $Attr$ O O $any$ O O $Nullable$ O $complex$ O O O $complex$ O $any$ O $complex$ O O $any$ O O O O O $complex$ O O O O $ErrorConstructor$ O O O O O O O O $complex$ O O O O O $string$ O $any$ O $string$ O $string$ O O O O $string$ O O O O O $Dict<V>$ O $string$ O O O O $string[]$ O $string$ O $complex$ O O O O O $string[]$ O O O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O $string[]$ O O O O O $string[]$ O $number$ O O O O O O O O O O $string[]$ O $number$ O O O O O O O $Dict<V>$ O $string[]$ O O O O O O O O O O $ErrorConstructor$ O O O O O O O O O O $complex$ O $any$ O O O O O $Dict<V>$ O $NSIdentity$ O $string$ O O O O O O O $complex$ O $string$ O O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $string$ O O O O O O O $complex$ O $complex$ O $string$ O O O O O O O $boolean$ O $string$ O O O O O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O $number$ O O O O O $boolean$ O $string$ O O O O O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O $number$ O O O O O $NSDictionary$ O $NSDictionary$ O $any$ O O O $any$ O O $NSDictionary<V>$ O $NSDictionary<V>$ O O $V$ O $string$ O O O O $NSIdentity$ O $any$ O $complex$ O $string$ O O O O $void$ O $NSIdentity$ O $V$ O O O O O O O O O O $Undef$ O $NSIdentity$ O O $any$ O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $NSIdentity$ O O O $string$ O O O O O O O O O O O $string$ O O O $Dict<V>$ O O O $string[]$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O O O $string[]$ O $number$ O O O O O O $string$ O O O O O $string$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O O $string$ O O O O O $Dict<V>$ O $string$ O O O O O O O O O $V[]$ O O O $any$ O O O O $V[]$ O $any$ O O O O O O $ObjectConstructor$ O $complex$ O O O $Dict<V>$ O O $void$ O $string$ O O $V[]$ O $number$ O O O $Dict<V>$ O $string$ O O O O O O O $V[]$ O O O $NSDictionary$ O O O $any$ O O O $NSDictionary<V>$ O O $any$ O $any$ O O O O O $NSDictionary<V>$ O $NSDictionary<V>$ O O O O O O $NSDictionary$ O $void$ O O $V$ O $any$ O $string$ O O O O O $any$ O O $ObjectConstructor$ O $complex$ O O O $Dict<V>$ O O $void$ O $string$ O O $void$ O O O $Dict<V>$ O $string$ O O $string$ O O O O O O O O O O $NSDictionary$ O $any$ O O $T$ O O O $V$ O $any$ O $string$ O O $any$ O O O $any$ O O O $NSDictionary<T>$ O O $any$ O $any$ O O O O O O $NSDictionary<V>$ O O $V$ O $string$ O O O O $NSIdentity$ O $any$ O $complex$ O $string$ O O $NSDictionary<T>$ O $void$ O $NSIdentity$ O $T$ O $V$ O $string$ O O O O O O O $NSDictionary<T>$ O O O $void$ O O O O O $Dict<V>$ O O O O O O $IdResolver$ O O $any$ O O O O O
import IAttributeConverterDeclaration from "s" ; import NSDictionary from "s" ; import Ensure from "s" ; import IAttributeDeclaration from "s" ; import NSIdentity from "s" ; import IdResolver from "s" ; import GrimoireInterface from "s" ; import Component from "s" ; import { GomlInterface , Name , Nullable } from "s" ; export default class Attribute { public name : NSIdentity ; public declaration : IAttributeDeclaration ; public converter : IAttributeConverterDeclaration ; public component : Component ; public convertContext : any = { } ; private _value : any ; private _lastValuete : any ; private _observers : ( ( newValue , oldValue , attr ) => void ) [ ] = [ ] ; private _ignoireActivenessObservers : ( ( newValue , oldValue , attr ) => void ) [ ] = [ ] ; public get tree ( ) : Nullable < GomlInterface > { return this . component . tree ; } public get companion ( ) : Nullable < NSDictionary < any > > { return this . component . companion ; } public get Value ( ) : any { if ( this . _value === void 0 ) { const node = this . component . node ; throw new Error ( `template` ) ; } return this . _valuate ( this . _value ) ; } public set Value ( val ) { if ( this . _value === val ) { return ; } this . _value = val ; this . _notifyChange ( val ) ; } public static convert ( converter , self , val ) { const cname = Ensure . tobeNSIdentity ( converter ) ; const conv = GrimoireInterface . converters . get ( cname ) ; if ( ! conv ) { throw new Error ( `template` ) ; } return conv . convert ( val , self ) ; } public static generateAttributeForComponent ( name , declaration , component ) { const attr = new Attribute ( ) ; attr . name = NSIdentity . fromFQN ( component . name . fqn + "s" + name ) ; attr . component = component ; attr . declaration = declaration ; const converterName = Ensure . tobeNSIdentity ( declaration . converter ) ; attr . converter = GrimoireInterface . converters . get ( converterName ) ; if ( attr . converter === void 0 ) { throw new Error ( `template` ) ; } attr . component . attributes . set ( attr . name , attr ) ; attr . converter . verify ( attr ) ; return attr ; } public watch ( watcher : ( newValue , oldValue , attr ) => void , immedateCalls = false , ignoireActiveness = false ) { if ( ignoireActiveness ) { this . _ignoireActivenessObservers . push ( watcher ) ; } else { this . _observers . push ( watcher ) ; } if ( immedateCalls ) { watcher ( this . Value , void 0 , this ) ; } } public unwatch ( target : ( newValue , oldValue , attr ) => void ) { let index = this . _observers . findIndex ( f => f === target ) ; if ( index >= 0 ) { this . _observers . splice ( index , 0 ) ; return ; } index = this . _ignoireActivenessObservers . findIndex ( f => f === target ) ; if ( index >= 0 ) { this . _ignoireActivenessObservers . splice ( index , 0 ) ; return ; } } public boundTo ( variableName , targetObject = this . component ) { if ( targetObject [ variableName ] ) { console . warn ( `template` ) ; } if ( this . converter [ "s" ] ) { Object . defineProperty ( targetObject , variableName , { get : ( ) => this . Value , set : ( val ) => { this . Value = val ; } , enumerable : true , configurable : true } ) ; } else { let backing ; this . watch ( v => { backing = v ; } , true ) ; Object . defineProperty ( targetObject , variableName , { get : ( ) => backing , set : ( val ) => { this . Value = val ; } , enumerable : true , configurable : true } ) ; } } public resolveDefaultValue ( domValues : { [ key ] : string } ) { if ( this . _value !== void 0 ) { return ; } const resolver = new IdResolver ( ) ; resolver . add ( this . name ) ; let tagAttrKey ; for ( let key in domValues ) { if ( Ensure . checkFQNString ( key ) ) { if ( this . name . fqn === key . substring ( 0 ) ) { this . Value = domValues [ key ] ; return ; } continue ; } let get = resolver . get ( key ) ; if ( get . length > 0 ) { if ( tagAttrKey === void 0 ) { tagAttrKey = key ; } else { throw new Error ( `template` ) ; } } } if ( tagAttrKey !== void 0 ) { this . Value = domValues [ tagAttrKey ] ; return ; } const nodeDefaultValue = this . component . node ! . nodeDeclaration . defaultAttributesActual . hasMatchingValue ( this . name ) ; if ( nodeDefaultValue !== void 0 ) { this . Value = nodeDefaultValue ; return ; } this . Value = this . declaration . default ; } private _valuate ( raw ) { const v = this . converter . convert ( raw , this ) ; if ( v === void 0 ) { const errorMessage = `template` ; throw new Error ( errorMessage ) ; } this . _lastValuete = v ; return v ; } private _notifyChange ( newValue ) { const lastvalue = this . _lastValuete ; if ( ! this . component . isActive ) { if ( this . _ignoireActivenessObservers . length === 0 ) { return ; } const convertedNewValue = this . _valuate ( newValue ) ; this . _ignoireActivenessObservers . forEach ( ( watcher ) => { watcher ( convertedNewValue , lastvalue , this ) ; } ) ; } else { const convertedNewValue = this . _valuate ( newValue ) ; this . _observers . forEach ( ( watcher ) => { watcher ( convertedNewValue , lastvalue , this ) ; } ) ; this . _ignoireActivenessObservers . forEach ( ( watcher ) => { watcher ( convertedNewValue , lastvalue , this ) ; } ) ; } } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $NSIdentity$ O $any$ O O $IAttributeDeclaration$ O $any$ O O $IAttributeConverterDeclaration$ O $any$ O O $Component$ O $any$ O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $void)[]$ O O O $any$ O $any$ O $Attribute$ O O O O O O O O O O O $void)[]$ O O O $any$ O $any$ O $Attribute$ O O O O O O O O O O O O $GomlInterface$ O O O $any$ O $any$ O O O O O $Component$ O $GomlInterface$ O O O O $NSDictionary<any>$ O O O $any$ O $any$ O O O O O O O O $Component$ O $NSDictionary<any>$ O O O O $any$ O O O O O O O O O $any$ O O O O O O $GomlNode$ O O O $Component$ O $GomlNode$ O O O $ErrorConstructor$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $void$ O $any$ O O O O O $any$ O $Name$ O $Attribute$ O $any$ O O O $NSIdentity$ O $any$ O $NSIdentity$ O $Name$ O O O $IAttributeConverterDeclaration$ O $GrimoireInterface$ O $NSDictionary<IAttributeConverterDeclaration>$ O $complex$ O $NSIdentity$ O O O O O $IAttributeConverterDeclaration$ O O O O $ErrorConstructor$ O O O O O O $IAttributeConverterDeclaration$ O $any$ O $any$ O $Attribute$ O O O O O $Attribute$ O $string$ O $IAttributeDeclaration$ O $Component$ O O O $Attribute$ O O $any$ O O O $Attribute$ O $NSIdentity$ O $any$ O $complex$ O $Component$ O $NSIdentity$ O $string$ O O O $string$ O O $Attribute$ O $Component$ O $Component$ O $Attribute$ O $IAttributeDeclaration$ O $IAttributeDeclaration$ O O $NSIdentity$ O $any$ O $NSIdentity$ O $IAttributeDeclaration$ O $Name$ O O $Attribute$ O $IAttributeConverterDeclaration$ O $GrimoireInterface$ O $NSDictionary<IAttributeConverterDeclaration>$ O $complex$ O $NSIdentity$ O O O O $Attribute$ O $IAttributeConverterDeclaration$ O O O O O O O $ErrorConstructor$ O O O O O $Attribute$ O $Component$ O $NSDictionary<Attribute>$ O $void$ O $Attribute$ O $NSIdentity$ O $Attribute$ O O $Attribute$ O $IAttributeConverterDeclaration$ O $void$ O $Attribute$ O O O $Attribute$ O O O $void$ O $void$ O O $any$ O $any$ O $Attribute$ O O O O $boolean$ O O O $boolean$ O O O O O O $boolean$ O O O O $void)[]$ O $number$ O $void$ O O O O O O O $void)[]$ O $number$ O $void$ O O O O O $boolean$ O O $void$ O O O $any$ O O O O O O O O O O $void$ O $void$ O O $any$ O $any$ O $Attribute$ O O O O O O $number$ O O O $void)[]$ O $number$ O $void$ O $void$ O $void$ O O O O $number$ O O O O O O $void)[]$ O $complex$ O $number$ O O O O O O O $number$ O O O $void)[]$ O $number$ O $void$ O $void$ O $void$ O O O O $number$ O O O O O O $void)[]$ O $complex$ O $number$ O O O O O O O O O $void$ O $string$ O $any$ O O O $Component$ O O O O $any$ O $string$ O O O $Console$ O $void$ O O O O O O O O O $IAttributeConverterDeclaration$ O O O O O $ObjectConstructor$ O $any$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $void$ O O $any$ O O O O O $any$ O $any$ O O O $true$ O O O $true$ O O O O O O O O O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O O O O O $ObjectConstructor$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O $void$ O O $any$ O O O O O $any$ O $any$ O O O $true$ O O O $true$ O O O O O O O O $void$ O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O O O O O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O O O $NSIdentity$ O O O $any$ O O O O $string$ O $complex$ O O O O $any$ O $boolean$ O $string$ O O O O O O O $NSIdentity$ O $string$ O $string$ O $string$ O O O O O O O $any$ O $complex$ O $string$ O O O O O O O O O $string[]$ O $IdResolver$ O $string[]$ O $string$ O O O O $string[]$ O $number$ O O O O O O $any$ O O O O O $any$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O O O O $any$ O $complex$ O $any$ O O O O O O $any$ O O O $Component$ O $GomlNode$ O O $NodeDeclaration$ O $NSDictionary<any>$ O $any$ O O O $NSIdentity$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O $IAttributeDeclaration$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $IAttributeConverterDeclaration$ O $any$ O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $ErrorConstructor$ O $string$ O O O O O $any$ O $any$ O O $any$ O O O $void$ O $any$ O O O $any$ O O O $any$ O O O O O O $Component$ O $boolean$ O O O O O O $void)[]$ O $number$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O $void)[]$ O $void$ O O $void$ O O O $void$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $void)[]$ O $void$ O O $void$ O O O $void$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $void$ O O $void$ O O O $void$ O $any$ O $any$ O O O O O O O O O O
import Attribute from "s" ; import { Name } from "s" ; interface IAttributeConverterDeclaration { name : Name ; [ params ] : any ; verify ( attr ) : void ; convert ( val , attr ) : any ; } export default IAttributeConverterDeclaration ;	O $any$ O O O O O $any$ O O O O O $any$ O $Name$ O $any$ O O $string$ O O O O $void$ O $Attribute$ O O O O $any$ O $any$ O $Attribute$ O O O O O O O $any$ O
export default class XMLHttpRequestAsync { public static send ( xhr , data ? : Document | string ) < Event > { return new Promise ( ( resolve , reject ) => { xhr . onload = ( e ) => { resolve ( e ) ; } ; xhr . onerror = ( e ) => { reject ( e ) ; } ; xhr . send ( data ) ; } ) ; } }	O O O $any$ O O O $Promise$ O $XMLHttpRequest$ O $complex$ O O $complex$ O O O O $complex$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $XMLHttpRequest$ O $any$ O O $ProgressEvent<EventTarget>$ O O O $void$ O $ProgressEvent<EventTarget>$ O O O O $XMLHttpRequest$ O $any$ O O $ProgressEvent<EventTarget>$ O O O $void$ O $ProgressEvent<EventTarget>$ O O O O $XMLHttpRequest$ O O O $complex$ O O O O O O O
import Attribute from "s" ; export default { name : "s" , verify : function ( attr ) { if ( ! attr . declaration [ "s" ] ) { throw new Error ( "s" ) ; } } , convert : function ( val , attr ) { if ( typeof val === "s" ) { return val ; } if ( typeof val === "s" ) { const result = attr . declaration [ "s" ] [ val ] ; if ( ! result ) { throw new Error ( "s" ) ; } return result ; } } } ;	O $any$ O O O O O O $string$ O O O $void$ O O O $Attribute$ O O O O O $Attribute$ O $IAttributeDeclaration$ O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O O O $any$ O $Attribute$ O O O O O $any$ O O O O O $number$ O O O O O $any$ O O O O O $any$ O $Attribute$ O $IAttributeDeclaration$ O O O O $string$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O O O O O
export default function NumberArrayConverter ( val ) { if ( val instanceof Array ) { return val ; } if ( typeof val === "s" ) { const splitted = val . split ( "s" ) ; return splitted . map ( s => Number . parseFloat ( s ) ) ; } }	O O O $any$ O $any$ O O O O $any$ O $ArrayConstructor$ O O O $any[]$ O O O O O $any$ O O O O O $string[]$ O $string$ O $complex$ O O O O O $string[]$ O $U[]$ O $string$ O $NumberConstructor$ O $number$ O $string$ O O O O O
import Ensure from "s" ; import Component from "s" ; import GomlNode from "s" ; import Attribute from "s" ; export default { name : "s" , verify : function ( attr ) { if ( ! attr . declaration [ "s" ] ) { throw new Error ( "s" ) ; } } , convert : function ( val , attr ) { if ( val === null ) { return null ; } if ( val instanceof GomlNode ) { return val . getComponent ( attr . declaration [ "s" ] ) ; } else if ( val instanceof Component ) { if ( val . name . fqn === Ensure . tobeNSIdentity ( attr . declaration [ "s" ] ) . fqn ) { return val ; } else { throw new Error ( `template` ) ; } } else { const n = attr . tree ! ( val ) . first ( ) ; if ( n ) { return n . getComponent ( attr . declaration [ "s" ] ) ; } return null ; } } } ;	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $string$ O O O $void$ O O O $Attribute$ O O O O O $Attribute$ O $IAttributeDeclaration$ O O O O O O O $ErrorConstructor$ O O O O O O O $unknown$ O O O $any$ O $Attribute$ O O O O $any$ O O O O O O O O O O $any$ O $any$ O O O $GomlNode$ O $T$ O $Attribute$ O $IAttributeDeclaration$ O O O O O O O O O $any$ O $any$ O O O O $Component$ O $NSIdentity$ O $string$ O $any$ O $NSIdentity$ O $Attribute$ O $IAttributeDeclaration$ O O O O O $string$ O O O $Component$ O O O O O O $ErrorConstructor$ O O O O O O O O O $GomlNode$ O $Attribute$ O $GomlInterface$ O O $any$ O O $GomlNode$ O O O O O $GomlNode$ O O O $GomlNode$ O $T$ O $Attribute$ O $IAttributeDeclaration$ O O O O O O O O O O O O O
import { Nullable , Undef } from "s" ; export default function NumberConverter ( val : Nullable < number > | string | Array < number > ) < number > { if ( typeof val === "s" ) { return val ; } else if ( typeof val === "s" ) { return Number . parseFloat ( val ) ; } else if ( val === null ) { return null ; } else if ( Array . isArray ( val ) && val . length === 0 ) { return val [ 0 ] ; } return undefined ; }	O O $any$ O $any$ O O O O O O O $Undef$ O $complex$ O $any$ O O O O O O $ArrayConstructor$ O O O O O O O O O O O $complex$ O O O O O $number$ O O O O O O $complex$ O O O O O $NumberConstructor$ O $number$ O $string$ O O O O O O $number[]$ O O O O O O O O O O O $ArrayConstructor$ O $complex$ O $number[]$ O O $number[]$ O $number$ O O O O O $number[]$ O O O O O O $undefined$ O O
export default function ObjectConverter ( val ) { return val ; }	O O O $any$ O $any$ O O O $any$ O O
import GrimoireInterface from "s" ; import Attribute from "s" ; const splitter = "s" ; const escape = "s" ; export default { name : "s" , verify : function ( attr ) { if ( ! attr . declaration [ "s" ] ) { throw new Error ( "s" ) ; } } , convert : function ( val , attr ) { let converter = GrimoireInterface . converters . get ( attr . declaration [ "s" ] ) ; if ( ! converter ) { throw new Error ( `template` ) ; } if ( Array . isArray ( val ) ) { return val . map ( v => converter . convert ( v , attr ) ) ; } if ( typeof val === "s" ) { let ar = val . split ( splitter ) ; for ( let i = 0 ; i < ar . length ; i ++ ) { let s = ar [ i ] ; if ( s [ s . length - 0 ] === escape ) { if ( i === ar . length - 0 ) { ar [ i ] = s . substring ( 0 , s . length - escape . length ) + splitter ; } else { ar [ i ] = s . substring ( 0 , s . length - escape . length ) + splitter + ar [ i + 0 ] ; ar . splice ( i + 0 , 0 ) ; } } } return ar . map ( v => converter . convert ( v , attr ) ) ; } return null ; } } ;	O $GrimoireInterface$ O O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O $void$ O O O $Attribute$ O O O O O $Attribute$ O $IAttributeDeclaration$ O O O O O O O $ErrorConstructor$ O O O O O O O $any[]$ O O O $any$ O $Attribute$ O O O $IAttributeConverterDeclaration$ O $GrimoireInterface$ O $NSDictionary<IAttributeConverterDeclaration>$ O $complex$ O $Attribute$ O $IAttributeDeclaration$ O O O O O O O O $IAttributeConverterDeclaration$ O O O O $ErrorConstructor$ O O O O O O O $ArrayConstructor$ O $complex$ O $any$ O O O O $any[]$ O $U[]$ O $any$ O $IAttributeConverterDeclaration$ O $any$ O $any$ O $Attribute$ O O O O O O O $any$ O O O O O $string[]$ O $string$ O $complex$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O $string$ O $string$ O $number$ O O O O O O O O O $number$ O $string[]$ O $number$ O O O O $string[]$ O $number$ O O $string$ O $string$ O O O $string$ O $number$ O O O $number$ O O O O O O O $string[]$ O $number$ O O $string$ O $string$ O O O $string$ O $number$ O O O $number$ O O O O $string[]$ O $number$ O O O O $string[]$ O $complex$ O $number$ O O O O O O O O O O $string[]$ O $U[]$ O $string$ O $IAttributeConverterDeclaration$ O $any$ O $string$ O $Attribute$ O O O O O O O O O O
export default function BooleanConverter ( val ) { if ( typeof val === "s" ) { return val ; } else if ( typeof val === "s" ) { switch ( val ) { case "s" : return true ; case "s" : return false ; } } }	O O O $any$ O $any$ O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O O O O O O $string$ O O O O O O O O O O O O O O O O O
import IAttributeDeclaration from "s" ; import Component from "s" ; export default class GrimoireComponent extends Component { public static componentName = "s" ; public static attributes : { [ key ] : IAttributeDeclaration } = { id : { converter : "s" , default : null } , class : { converter : "s" , default : null } , enabled : { converter : "s" , default : true } } ; public $awake ( ) { const node = this . node ! ; node . resolveAttributesValue ( ) ; this . getAttributeRaw ( "s" ) . watch ( ( attr ) => { node . element . id = attr ? attr : "s" ; } , true , true ) ; this . getAttributeRaw ( "s" ) . watch ( ( attr ) => { node . element . className = Array . isArray ( attr ) ? attr . join ( "s" ) : "s" ; } , true , true ) ; this . getAttributeRaw ( "s" ) . watch ( attr => { node [ "s" ] = attr ; const p = node . parent ; node . notifyActivenessUpdate ( p ? p . isActive && node . enabled : node . enabled ) ; } , false , true ) ; node [ "s" ] = this . getAttribute ( "s" ) ; node [ "s" ] = node . parent ? node . parent . isActive && node . enabled : node . enabled ; } }	O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O O O $complex$ O O O $string$ O O $any$ O O O $complex$ O O $string$ O O O $null$ O O O O $complex$ O O $string$ O O O $null$ O O O O $complex$ O O $string$ O O O $boolean$ O O O O O O $void$ O O O O $GomlNode$ O O O $GomlNode$ O O $GomlNode$ O $void$ O O O O O $Attribute$ O O O O $void$ O O $any$ O O O $GomlNode$ O $Element$ O $string$ O $any$ O $any$ O O O O O O O O O O O O $Attribute$ O O O O $void$ O O $any$ O O O $GomlNode$ O $Element$ O $string$ O $ArrayConstructor$ O $complex$ O $any$ O O $any[]$ O $string$ O O O O O O O O O O O O O O O $Attribute$ O O O O $void$ O $any$ O O $GomlNode$ O O O O $any$ O O $GomlNode$ O $GomlNode$ O $GomlNode$ O $GomlNode$ O $void$ O $GomlNode$ O $GomlNode$ O $boolean$ O $GomlNode$ O $boolean$ O $GomlNode$ O $boolean$ O O O O O O O O O $GomlNode$ O O O O O O $any$ O O O O $GomlNode$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode$ O $GomlNode$ O $boolean$ O $GomlNode$ O $boolean$ O $GomlNode$ O $boolean$ O O O
export default function StringArrayConverter ( val ) { if ( Array . isArray ( val ) || ! val ) { return val ; } if ( typeof val === "s" ) { return val . split ( "s" ) ; } }	O O O $any$ O $any$ O O O O $ArrayConstructor$ O $complex$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O O O O O $string$ O $complex$ O O O O O O
export default function StringConverter ( val ) { if ( typeof val === "s" ) { return val ; } else if ( ! val ) { return val ; } else if ( typeof val . toString === "s" ) { return val . toString ( ) ; } }	O O O $any$ O $any$ O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O
import EEObject from "s" ; import IAttributeConverterDeclaration from "s" ; import GomlLoader from "s" ; import EnumConverter from "s" ; import NumberArrayConverter from "s" ; import ComponentConverter from "s" ; import NumberConverter from "s" ; import ObjectConverter from "s" ; import ArrayConverter from "s" ; import NodeInterface from "s" ; import Utility from "s" ; import GomlInterfaceImpl from "s" ; import BooleanConverter from "s" ; import GrimoireComponent from "s" ; import StringArrayConverter from "s" ; import StringConverter from "s" ; import Attribute from "s" ; import Constants from "s" ; import ITreeInitializedInfo from "s" ; import GomlNode from "s" ; import ComponentDeclaration from "s" ; import Component from "s" ; import NodeDeclaration from "s" ; import NSIdentity from "s" ; import Namespace from "s" ; import NSDictionary from "s" ; import Ensure from "s" ; import { Name , Nullable , Ctor , ComponentRegistering } from "s" ; export default class GrimoireInterfaceImpl extends EEObject { public nodeDeclarations : NSDictionary < NodeDeclaration > = new NSDictionary < NodeDeclaration > ( ) ; public converters : NSDictionary < IAttributeConverterDeclaration > = new NSDictionary < IAttributeConverterDeclaration > ( ) ; public componentDeclarations : NSDictionary < ComponentDeclaration > = new NSDictionary < ComponentDeclaration > ( ) ; public rootNodes : { [ rootNodeId ] : GomlNode } = { } ; public loadTasks : ( { ns : string , task : ( ) => Promise < void > } ) [ ] = [ ] ; public lib : { [ key ] : { __VERSION__ : string ; __NAME__ : string ; [ key ] : any ; } } = { } ; public nodeDictionary : { [ nodeId ] : GomlNode } = { } ; public componentDictionary : { [ componentId ] : Component } = { } ; public libraryPreference ? : { [ preference ] : any } ; public debug = true ; public noConflictPreserve : any ; private _registeringPluginNamespace : string ; private _registrationContext : string = Constants . defaultNamespace ; public get initializedEventHandler ( ) : ( ( scriptTags : HTMLScriptElement [ ] ) => void ) [ ] { return GomlLoader . initializedEventHandlers ; } public get callInitializedAlready ( ) : boolean { return GomlLoader . callInitializedAlready ; } public ns ( ns ) : ( name ) => NSIdentity { return ( name ) => Namespace . define ( ns ) . for ( name ) ; } public initialize ( ) { this . registerConverter ( "s" , StringConverter ) ; this . registerConverter ( "s" , StringArrayConverter ) ; this . registerConverter ( "s" , BooleanConverter ) ; this . registerConverter ( ArrayConverter ) ; this . registerConverter ( "s" , ObjectConverter ) ; this . registerConverter ( EnumConverter ) ; this . registerConverter ( "s" , NumberConverter ) ; this . registerConverter ( ComponentConverter ) ; this . registerConverter ( "s" , NumberArrayConverter ) ; this . registerComponent ( GrimoireComponent ) ; this . registerNode ( "s" , [ "s" ] ) ; } public register ( loadTask : ( ) => Promise < void > ) { this . loadTasks . push ( { ns : this . _registeringPluginNamespace , task : loadTask } ) ; this . _registeringPluginNamespace = Constants . defaultNamespace ; } public async resolvePlugins ( ) < void > { for ( let i = 0 ; i < this . loadTasks . length ; i ++ ) { const obj = this . loadTasks [ i ] ; this . _registrationContext = obj . ns ; try { await obj . task ( ) ; } catch ( e ) { console . error ( `template` ) ; console . error ( e ) ; } } this . _registrationContext = Constants . defaultNamespace ; this . componentDeclarations . forEach ( dec => { dec . resolveDependency ( ) ; } ) ; this . nodeDeclarations . forEach ( dec => { dec . resolveDependency ( ) ; } ) ; } public registerComponent ( obj < Object | Ctor < Component > > , superComponent ? : Name | Ctor < Component > ) ; public registerComponent ( name , obj < Object | Ctor < Component > > , superComponent ? : Name | Ctor < Component > ) ; public registerComponent ( 0 : Name | ComponentRegistering < Object | Ctor < Component > > , 0 ? : Name | Ctor < Component > | ComponentRegistering < Object | Ctor < Component > > , 0 ? : Name | Ctor < Component > ) { let name ; let obj < Object | Ctor < Component > > ; let superComponent : Name | Ctor < Component > | undefined ; if ( typeof 0 === "s" || 0 instanceof NSIdentity ) { name = 0 ; obj = 0 as ComponentRegistering < Object | Ctor < Component > > ; superComponent = 0 ; } else { obj = 0 as ComponentRegistering < Object | Ctor < Component > > ; superComponent = 0 as Name | Ctor < Component > ; if ( obj . componentName == null ) { throw new Error ( `template` ) ; } name = obj . componentName ; } name = this . _ensureTobeNSIdentityOnRegister ( name ) ; if ( this . componentDeclarations . get ( name ) ) { throw new Error ( `template` ) ; } if ( typeof obj === "s" && ! ( obj . prototype instanceof Component ) ) { throw new Error ( `template` ) ; } if ( this . debug && ! Utility . isCamelCase ( name . name ) ) { console . warn ( `template` ) ; } const attrs = obj . attributes ; if ( ! attrs ) { throw new Error ( "s" ) ; } for ( let key in attrs ) { if ( attrs [ key ] . default === void 0 ) { throw new Error ( `template` ) ; } } const dec = new ComponentDeclaration ( name , obj , superComponent ) ; this . componentDeclarations . set ( name , dec ) ; return dec ; } public registerNode ( name , requiredComponents : Name [ ] = [ ] , defaults ? : { [ key ] : any } | NSDictionary < any > , superNode ? , freezeAttributes ? : Name [ ] ) { const registerId = this . _ensureTobeNSIdentityOnRegister ( name ) ; if ( this . nodeDeclarations . get ( registerId ) ) { throw new Error ( `template` ) ; } if ( this . debug && ! Utility . isSnakeCase ( registerId . name ) ) { console . warn ( `template` ) ; } const declaration = new NodeDeclaration ( registerId , requiredComponents || [ ] , defaults || { } , superNode , freezeAttributes ) ; this . nodeDeclarations . set ( registerId , declaration ) ; return declaration ; } public getCompanion ( scriptTag ) < any > { const root = this . getRootNode ( scriptTag ) ; if ( root ) { return root . companion ; } else { throw new Error ( "s" ) ; } } public addRootNode ( tag , rootNode ) { if ( ! rootNode ) { throw new Error ( "s" ) ; } tag . setAttribute ( "s" , rootNode . id ) ; this . rootNodes [ rootNode . id ] = rootNode ; rootNode . companion . set ( this . ns ( Constants . defaultNamespace ) ( "s" ) , tag ) ; rootNode . setMounted ( true ) ; rootNode . broadcastMessage ( "s" , < ITreeInitializedInfo > { ownerScriptTag : tag , id : rootNode . id } ) ; rootNode . sendInitializedMessage ( < ITreeInitializedInfo > { ownerScriptTag : tag , id : rootNode . id } ) ; this . emit ( "s" , { ownerScriptTag : tag , rootNode : rootNode } ) ; return rootNode . id ; } public getRootNode ( scriptTag ) < GomlNode > { const id = scriptTag . getAttribute ( "s" ) ; if ( id ) { let ret = this . rootNodes [ id ] ; if ( ! ret ) { throw new Error ( `template` ) ; } return ret ; } else { return null ; } } public noConflict ( ) { ( window as any ) [ "s" ] = this . noConflictPreserve ; } public queryRootNodes ( query ) : GomlNode [ ] { const scriptTags = document . querySelectorAll ( query ) ; const nodes : GomlNode [ ] = [ ] ; for ( let i = 0 ; i < scriptTags . length ; i ++ ) { const node = this . getRootNode ( scriptTags . item ( i ) ) ; if ( node ) { nodes . push ( node ) ; } } return nodes ; } public registerConverter ( name , converter : ( ( val , attr ) => any ) ) ; public registerConverter ( declaration ) ; public registerConverter ( 0 : Name | IAttributeConverterDeclaration , converter ? : ( ( val , attr ) => any ) ) { if ( converter ) { this . registerConverter ( { name : this . _ensureTobeNSIdentityOnRegister ( 0 as any ) , verify : ( ) => true , convert : converter } ) ; return ; } const dec = 0 as IAttributeConverterDeclaration ; this . converters . set ( this . _ensureTobeNSIdentityOnRegister ( dec . name ) , dec ) ; } public overrideDeclaration ( targetDeclaration , additionalComponents : Name [ ] ) ; public overrideDeclaration ( targetDeclaration , defaults : { [ attrName ] : any } ) ; public overrideDeclaration ( targetDeclaration , additionalComponents : Name [ ] , defaults : { [ attrName ] : any } ) ; public overrideDeclaration ( targetDeclaration , 0 : Name [ ] | { [ attrName ] : any } , defaults ? : { [ attrName ] : any } ) { const dec = this . nodeDeclarations . get ( targetDeclaration ) ; if ( ! dec ) { throw new Error ( `template` ) ; } if ( ! dec . resolvedDependency ) { dec . resolveDependency ( ) ; } if ( defaults ) { const additionalC = 0 as Name [ ] ; for ( let i = 0 ; i < additionalC . length ; i ++ ) { dec . addDefaultComponent ( additionalC [ i ] ) ; } dec . defaultAttributes . pushDictionary ( Ensure . tobeNSDictionary ( defaults ) ) ; } else if ( Array . isArray ( 0 ) ) { for ( let i = 0 ; i < 0 . length ; i ++ ) { dec . addDefaultComponent ( 0 [ i ] ) ; } } else { dec . defaultAttributes . pushDictionary ( Ensure . tobeNSDictionary ( 0 ) ) ; } return dec ; } public clear ( ) { this . nodeDeclarations . clear ( ) ; this . componentDeclarations . clear ( ) ; this . converters . clear ( ) ; for ( let key in this . rootNodes ) { delete this . rootNodes [ key ] ; } for ( let key in this . nodeDictionary ) { delete this . nodeDictionary [ key ] ; } for ( let key in this . componentDictionary ) { delete this . componentDictionary [ key ] ; } this . loadTasks . splice ( 0 , this . loadTasks . length ) ; this . _registeringPluginNamespace = Constants . defaultNamespace ; this . initialize ( ) ; } public extendGrimoireInterface ( name , func ) { if ( ( < any > this ) [ name ] ) { throw new Error ( `template` ) ; } ( < any > this ) [ name ] = func . bind ( this ) ; } public extendGomlInterface ( name , func ) { if ( ( GomlInterfaceImpl as any ) [ name ] ) { throw new Error ( `template` ) ; } ( GomlInterfaceImpl as any ) [ name ] = func . bind ( this ) ; } public extendNodeInterface ( name , func ) { if ( ( NodeInterface as any ) [ name ] ) { throw new Error ( `template` ) ; } ( NodeInterface as any ) [ name ] = func . bind ( this ) ; } public notifyRegisteringPlugin ( namespace ) { let res = "s" . exec ( namespace ) ; if ( res ) { namespace = res [ 0 ] ; } this . _registeringPluginNamespace = namespace ; } private _ensureNameTobeConstructor ( component : Name | Ctor < Component > ) < Ctor < Component > > { if ( ! component ) { return null ; } if ( typeof component === "s" ) { return component ; } else if ( typeof component === "s" ) { return this . _ensureNameTobeConstructor ( Ensure . tobeNSIdentity ( component ) ) ; } else { let c = this . componentDeclarations . get ( component ) ; if ( ! c ) { return null ; } return c . ctor ; } } private _ensureTobeNSIdentityOnRegister ( name ) ; private _ensureTobeNSIdentityOnRegister ( name : null | undefined ) ; private _ensureTobeNSIdentityOnRegister ( name : Name | null | undefined ) < NSIdentity > { if ( ! name ) { return null ; } if ( typeof name === "s" ) { if ( name . indexOf ( "s" ) !== - 0 ) { return NSIdentity . fromFQN ( name ) ; } return NSIdentity . fromFQN ( Namespace . define ( this . _registrationContext ) , name ) ; } else { return name ; } } }	O $any$ O O O O $any$ O O O O $any$ O O O O $complex$ O O O O $any$ O O O O $complex$ O O O O $number$ O O O O $any$ O O O O $complex$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $NSDictionary<NodeDeclaration>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $NSDictionary<IAttributeConverterDeclaration>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $NSDictionary<ComponentDeclaration>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $complex$ O O O $string$ O O O $Promise<void>$ O O O O $PromiseConstructor$ O O O O O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O $string$ O O O O O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $complex$ O O O O $string$ O O O O O O $boolean$ O O O O $any$ O O O O $string$ O O O O $string$ O O O $any$ O $string$ O O O $void)[]$ O O O O O $HTMLScriptElement[]$ O $complex$ O O O O O O O O O O $any$ O $void)[]$ O O O O $boolean$ O O O O O O $any$ O $boolean$ O O O $NSIdentity$ O $string$ O O O $string$ O O $any$ O O O $string$ O O $any$ O $Namespace$ O $string$ O O $NSIdentity$ O $string$ O O O O $void$ O O O O O $complex$ O O O $any$ O O O O $complex$ O O O $any$ O O O O $complex$ O O O $any$ O O O O $complex$ O $complex$ O O O O $complex$ O O O $any$ O O O O $complex$ O $complex$ O O O O $complex$ O O O $number$ O O O O $complex$ O $complex$ O O O O $complex$ O O O $any$ O O O O O O $any$ O O O O $NodeDeclaration$ O O O O O O O O O O $void$ O $Promise<void>$ O O O O $PromiseConstructor$ O O O O O O O $complex$ O $number$ O O $string$ O O O $string$ O $Promise<void>$ O $Promise<void>$ O O O O O $string$ O $any$ O $string$ O O O O $Promise$ O O O O O O O O O $number$ O O O $number$ O O O $complex$ O $number$ O $number$ O O O O $complex$ O O O $complex$ O $number$ O O O O $string$ O $complex$ O $string$ O O O O $complex$ O $Promise<void>$ O O O O O O $any$ O O $Console$ O $void$ O O O O $Console$ O $void$ O $any$ O O O O O O $string$ O $any$ O $string$ O O O $NSDictionary<ComponentDeclaration>$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration$ O O $ComponentDeclaration$ O $boolean$ O O O O O O O O $NSDictionary<NodeDeclaration>$ O $NSDictionary<NodeDeclaration>$ O $NodeDeclaration$ O O $NodeDeclaration$ O $boolean$ O O O O O O O O $ComponentDeclaration$ O $ComponentRegistering$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O O $any$ O $any$ O $any$ O O O O $ComponentDeclaration$ O $Name$ O $ComponentRegistering$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O O $any$ O $any$ O $any$ O O O O $ComponentDeclaration$ O $complex$ O $any$ O $any$ O $ObjectConstructor$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O O $any$ O $any$ O $any$ O O O O $Name$ O O $ComponentRegistering$ O $ObjectConstructor$ O $any$ O $any$ O O O O $Component)$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O O $complex$ O $any$ O O $Name$ O $Name$ O $Component)>$ O $complex$ O $any$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O $Component)$ O O O O $Component)>$ O $Component)>$ O $any$ O $ObjectConstructor$ O $any$ O $any$ O O O $Component)$ O $complex$ O $any$ O $any$ O $any$ O O O O $Component)>$ O $Name$ O O O O O O $ErrorConstructor$ O O O O O $Name$ O $Component)>$ O $Name$ O O $Name$ O O O $complex$ O $Name$ O O O O O O $NSDictionary<ComponentDeclaration>$ O $complex$ O $NSIdentity$ O O O O O $ErrorConstructor$ O O O O O O O O $Component)>$ O O O O O $complex$ O $any$ O $any$ O O O O O $ErrorConstructor$ O O O O O O O O O $boolean$ O O $any$ O $boolean$ O $NSIdentity$ O $string$ O O O $Console$ O $void$ O O O O O O $complex$ O $Component)>$ O $complex$ O O O O $complex$ O O O O $ErrorConstructor$ O O O O O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O $ComponentDeclaration$ O O $any$ O $NSIdentity$ O $Component)>$ O $Component)$ O O O O $NSDictionary<ComponentDeclaration>$ O $void$ O $NSIdentity$ O $ComponentDeclaration$ O O O $ComponentDeclaration$ O O O $NodeDeclaration$ O $Name$ O $Name[]$ O $any$ O O O O O O $complex$ O O O O $string$ O O O O O $any$ O O O O $Name$ $Name$ O $Name[]$ O O $any$ O O O O O $NSIdentity$ O O O $complex$ O $Name$ O O O O O O $NSDictionary<NodeDeclaration>$ O $complex$ O $NSIdentity$ O O O O O $ErrorConstructor$ O O O O O O O O O $boolean$ O O $any$ O $boolean$ O $NSIdentity$ O $string$ O O O $Console$ O $void$ O O O O O O $NodeDeclaration$ O O $any$ O $NSIdentity$ O $Name[]$ O O O O $complex$ O O O O $Name$ O $Name[]$ O O O O $NSDictionary<NodeDeclaration>$ O $void$ O $NSIdentity$ O $NodeDeclaration$ O O O $NodeDeclaration$ O O O $NSDictionary$ O $Element$ O O O O O O $GomlNode$ O O O $GomlNode$ O $Element$ O O O O $GomlNode$ O O O $GomlNode$ O $NSDictionary<any>$ O O O O O O $ErrorConstructor$ O O O O O O O $string$ O $HTMLScriptElement$ O $GomlNode$ O O O O O $GomlNode$ O O O O $ErrorConstructor$ O O O O O $HTMLScriptElement$ O $void$ O O O $GomlNode$ O $string$ O O O O $complex$ O $GomlNode$ O $string$ O O $GomlNode$ O $GomlNode$ O $NSDictionary<any>$ O $void$ O O O $NSIdentity$ O $any$ O $string$ O O O O O $HTMLScriptElement$ O O $GomlNode$ O $void$ O O O O $GomlNode$ O $complex$ O O O O $any$ O O $HTMLScriptElement$ O $HTMLScriptElement$ O $string$ O $GomlNode$ O $string$ O O O $GomlNode$ O $void$ O O $any$ O O $HTMLScriptElement$ O $HTMLScriptElement$ O $string$ O $GomlNode$ O $string$ O O O O O $boolean$ O O O O $HTMLScriptElement$ O $HTMLScriptElement$ O $GomlNode$ O $GomlNode$ O O O O $GomlNode$ O $string$ O O O $Nullable$ O $Element$ O O $any$ O O O $string$ O $Element$ O $string$ O O O O O O $string$ O O O $GomlNode$ O O O $complex$ O $string$ O O O O O $GomlNode$ O O O O $ErrorConstructor$ O O O O O O $GomlNode$ O O O O O O O O O O $void$ O O O O $complex$ O O O O O O O O O $any$ O O O $GomlNode[]$ O $string$ O O $any$ O O O O $NodeListOf<Element>$ O $Document$ O O O $string$ O O O $GomlNode[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O $NodeListOf<Element>$ O $number$ O $number$ O O O O $GomlNode$ O O O $GomlNode$ O $NodeListOf<Element>$ O $Element$ O $number$ O O O O O $GomlNode$ O O $GomlNode[]$ O $number$ O $GomlNode$ O O O O O $GomlNode[]$ O O O $void$ O $Name$ O $any$ O O O $any$ O $Attribute$ O O O O O O O $void$ O $IAttributeConverterDeclaration$ O O O $void$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O $Attribute$ O O O O O O O O $any$ O O O O $complex$ O O $NSIdentity$ O O O $complex$ O $complex$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O O $IAttributeConverterDeclaration$ O $complex$ O $any$ O O O $NSDictionary<IAttributeConverterDeclaration>$ O $void$ O O O $complex$ O $IAttributeConverterDeclaration$ O $Name$ O O $IAttributeConverterDeclaration$ O O O O $NodeDeclaration$ O $Name$ O $Name[]$ O $any$ O O O O O $NodeDeclaration$ O $Name$ O $complex$ O O O $string$ O O O O O O O $NodeDeclaration$ O $Name$ O $Name[]$ O $any$ O O O $complex$ O O O $string$ O O O O O O O $NodeDeclaration$ O $Name$ O $complex$ O $any$ O O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O $NodeDeclaration$ O O O $NSDictionary<NodeDeclaration>$ O $complex$ O $Name$ O O O O O $NodeDeclaration$ O O O O $ErrorConstructor$ O O O O O O O O $NodeDeclaration$ O $boolean$ O O $NodeDeclaration$ O $boolean$ O O O O O O $complex$ O O O $Name[]$ O $complex$ O $any$ O O O O O O $number$ O O O $number$ O $Name[]$ O $number$ O $number$ O O O $NodeDeclaration$ O $void$ O $Name[]$ O $number$ O O O O $NodeDeclaration$ O $NSDictionary<any>$ O $NSDictionary<any>$ O $any$ O $NSDictionary<T>$ O $complex$ O O O O O O O $ArrayConstructor$ O $complex$ O $complex$ O O O O O O $number$ O O O $number$ O $Name[]$ O $number$ O $number$ O O O $NodeDeclaration$ O $void$ O $Name[]$ O $number$ O O O O O O O $NodeDeclaration$ O $NSDictionary<any>$ O $NSDictionary<any>$ O $any$ O $NSDictionary<T>$ O $complex$ O O O O O $NodeDeclaration$ O O O $void$ O O O O O $NSDictionary<NodeDeclaration>$ O $void$ O O O O O $NSDictionary<ComponentDeclaration>$ O $void$ O O O O O $NSDictionary<IAttributeConverterDeclaration>$ O $void$ O O O O O O $string$ O O O $complex$ O O O O O $complex$ O $string$ O O O O O O $string$ O O O $complex$ O O O O O $complex$ O $string$ O O O O O O $string$ O O O $complex$ O O O O O $complex$ O $string$ O O O O O $complex$ O $complex$ O O O O O $complex$ O $number$ O O O O $string$ O $any$ O $string$ O O O $void$ O O O O O $void$ O $string$ O $Function$ O O O O O O O O O O O $string$ O O O O O $ErrorConstructor$ O O O O O O O O O O O O $string$ O O $Function$ O $any$ O O O O O O $void$ O $string$ O $Function$ O O O O O $any$ O O O O $string$ O O O O O $ErrorConstructor$ O O O O O O $any$ O O O O $string$ O O $Function$ O $any$ O O O O O O $void$ O $string$ O $Function$ O O O O O $any$ O O O O $string$ O O O O O $ErrorConstructor$ O O O O O O $any$ O O O O $string$ O O $Function$ O $any$ O O O O O O $void$ O $string$ O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O $string$ O $RegExpExecArray$ O O O O O O O $string$ O $string$ O O O $Nullable$ O $Component)$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $Component)$ O O O O O O O O O $Component)$ O O O O O $Component$ O O O O O O $Name$ O O O O O O O $Component$ O $any$ O $NSIdentity$ O $string$ O O O O O O O $ComponentDeclaration$ O O O $NSDictionary<ComponentDeclaration>$ O $complex$ O $NSIdentity$ O O O O O $ComponentDeclaration$ O O O O O O O $ComponentDeclaration$ O $Component$ O O O O $NSIdentity$ O $Name$ O O O $null$ O $null$ O O O O O O O $Nullable$ O $Name$ O $any$ O O O O O O $any$ O O O O O $Name$ O O O O O O O O O $Name$ O O O O O O $string$ O $number$ O O O O O O O O O $any$ O $complex$ O $string$ O O O O $any$ O $complex$ O $any$ O $Namespace$ O O O $string$ O O $string$ O O O O O O $NSIdentity$ O O O O
import GrimoireInterfaceImpl from "s" ; import GomlInterfaceImpl from "s" ; import GomlNode from "s" ; import { GomlInterface , GrimoireInterface } from "s" ; const context = new GrimoireInterfaceImpl ( ) ; function obtainGomlInterface ( query ) ; function obtainGomlInterface ( query : GomlNode [ ] ) ; function obtainGomlInterface ( callback : ( ) => void ) ; function obtainGomlInterface ( query : string | GomlNode [ ] | ( ( ) => void ) ) : void | GomlInterface { if ( typeof query === "s" ) { const gomlContext = new GomlInterfaceImpl ( context . queryRootNodes ( query ) ) ; const queryFunc = gomlContext . queryFunc . bind ( gomlContext ) ; Object . setPrototypeOf ( queryFunc , gomlContext ) ; return queryFunc ; } else if ( typeof query === "s" ) { if ( context . callInitializedAlready ) { query ( ) ; } else { context . initializedEventHandler . push ( query ) ; } } else { const gomlContext = new GomlInterfaceImpl ( query ) ; const queryFunc = gomlContext . queryFunc . bind ( gomlContext ) ; Object . setPrototypeOf ( queryFunc , gomlContext ) ; return queryFunc ; } } Object . setPrototypeOf ( obtainGomlInterface , context ) ; export default obtainGomlInterface as GrimoireInterface ;	O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $GrimoireInterfaceImpl$ O O $any$ O O O O $GomlInterface$ O $string$ O O O $GomlInterface$ O $GomlNode[]$ O $any$ O O O O O $void$ O $void$ O O O O O O O O $complex$ O $void)$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O $void)$ O O O O O $GomlInterface$ O O $any$ O $GrimoireInterfaceImpl$ O $GomlNode[]$ O $string$ O O O O $any$ O $GomlInterface$ O $NodeInterface$ O $any$ O $GomlInterface$ O O $ObjectConstructor$ O $any$ O $any$ O $GomlInterface$ O O O $any$ O O O O O O $void)$ O O O O O O $GrimoireInterfaceImpl$ O $boolean$ O O $void$ O O O O O O $GrimoireInterfaceImpl$ O $void)[]$ O $number$ O $void$ O O O O O O O $GomlInterface$ O O $any$ O $GomlNode[]$ O O O $any$ O $GomlInterface$ O $NodeInterface$ O $any$ O $GomlInterface$ O O $ObjectConstructor$ O $any$ O $any$ O $GomlInterface$ O O O $any$ O O O $ObjectConstructor$ O $any$ O $complex$ O $GrimoireInterfaceImpl$ O O O O $complex$ O $any$ O
import GrimoireInterface from "s" ; export default class Utility { public static w ( message ) { if ( GrimoireInterface . debug ) { console . warn ( message ) ; } } public static isCamelCase ( str ) { return "s" . test ( str ) ; } public static isSnakeCase ( str ) { return "s" . test ( str ) ; } public static flat < T > ( array : T [ ] [ ] ) : T [ ] { let count = 0 ; for ( let i = 0 ; i < array . length ; i ++ ) { count += array [ i ] . length ; } const ret = new Array < T > ( count ) ; count = 0 ; for ( let i = 0 ; i < array . length ; i ++ ) { const ar = array [ i ] ; for ( let j = 0 ; j < ar . length ; j ++ ) { ret [ count ] = ar [ j ] ; count ++ ; } } return ret ; } public static flatMap < T > ( source : T [ ] , map : ( a : T ) => T [ ] ) : T [ ] { const c = new Array < T [ ] > ( source . length ) ; for ( let i = 0 ; i < source . length ; i ++ ) { c [ i ] = map ( source [ i ] ) ; } return Utility . flat ( c ) ; } public static sum ( array : number [ ] ) { let total = 0 ; for ( let i = 0 ; i < array . length ; i ++ ) { total += array [ i ] ; } return total ; } public static remove < T > ( array : T [ ] , target : T ) { let index = - 0 ; for ( let i = 0 ; i < array . length ; i ++ ) { if ( target === array [ i ] ) { index = i ; break ; } } if ( index < 0 ) { return false ; } array . splice ( index , 0 ) ; return true ; } public static checkOverlap < T > ( array : T [ ] ) { const list = [ ] ; for ( let i = 0 ; i < array . length ; i ++ ) { const item = array [ i ] ; if ( list . indexOf ( item ) !== - 0 ) { return false ; } list . push ( item ) ; } return true ; } }	O $GrimoireInterface$ O O O O O O $any$ O O O $void$ O $string$ O O O O $GrimoireInterface$ O $boolean$ O O $Console$ O $void$ O $string$ O O O O O O $boolean$ O $string$ O O O O O $boolean$ O $string$ O O O O O $boolean$ O $string$ O O O O O $boolean$ O $string$ O O O O O $T[]$ O $any$ O O $T[][]$ O $any$ O O O O O O $any$ O O O O $number$ O O O O O O $number$ O O O $number$ O $T[][]$ O $number$ O $number$ O O O $number$ O $T[][]$ O $number$ O O $number$ O O O $T[]$ O O $ArrayConstructor$ O $any$ O O $number$ O O $number$ O O O O O O $number$ O O O $number$ O $T[][]$ O $number$ O $number$ O O O O $T[]$ O $T[][]$ O $number$ O O O O O $number$ O O O $number$ O $T[]$ O $number$ O $number$ O O O $T[]$ O $number$ O O $T[]$ O $number$ O O $number$ O O O O O $T[]$ O O O O $T[]$ O $any$ O O $T[]$ O $any$ O O O $T[]$ O O $T$ O $any$ O O $any$ O O O O $any$ O O O O $T[][]$ O O $ArrayConstructor$ O $any$ O O O O $T[]$ O $number$ O O O O O $number$ O O O $number$ O $T[]$ O $number$ O $number$ O O O $T[][]$ O $number$ O O $T[]$ O $T[]$ O $number$ O O O O O $any$ O $T[]$ O $T[][]$ O O O O O $number$ O $number[]$ O O O O O O O $number$ O O O O O O $number$ O O O $number$ O $number[]$ O $number$ O $number$ O O O $number$ O $number[]$ O $number$ O O O O $number$ O O O O $boolean$ O $any$ O O $T[]$ O $any$ O O O $T$ O $any$ O O O $number$ O O O O O O O $number$ O O O $number$ O $T[]$ O $number$ O $number$ O O O O O $T$ O $T[]$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O O O O O O O O $T[]$ O $complex$ O $number$ O O O O O O O O O O $boolean$ O $any$ O O $T[]$ O $any$ O O O O O $any[]$ O O O O O O O $number$ O O O $number$ O $T[]$ O $number$ O $number$ O O O O $T$ O $T[]$ O $number$ O O O O $any[]$ O $number$ O $T$ O O O O O O O O O O $any[]$ O $number$ O $T$ O O O O O O O O
import Utility from "s" ; import Attribute from "s" ; import IdResolver from "s" ; import Namespace from "s" ; import NSIdentity from "s" ; import Ensure from "s" ; import { Name , Undef } from "s" ; type NameValPair < T > = { fqn : string , val : T } ; class AttributeBuffer < T > { private _fqnList : NameValPair < T > [ ] = [ ] ; public add ( fqn , val : T ) { for ( let i = 0 ; i < this . _fqnList . length ; i ++ ) { const c = this . _fqnList [ i ] ; if ( c . fqn === fqn ) { c . val = val ; this . _fqnList . splice ( i , 0 ) ; this . _fqnList . push ( c ) ; return ; } } const obj = { fqn , val } ; this . _fqnList . push ( obj ) ; } public resolve ( fqn , remove ) < T > { const guess = this . guess ( fqn , remove ) ; return guess . length === 0 ? void 0 : guess [ guess . length - 0 ] ; } public guess ( fqn , remove ) : T [ ] { const resolver = new IdResolver ( ) ; resolver . add ( fqn . split ( "s" ) ) ; const ret : T [ ] = [ ] ; for ( let i = 0 ; i < this . _fqnList . length ; i ++ ) { const name = this . _fqnList [ i ] . fqn ; const r = resolver . get ( name ) ; if ( r . length > 0 ) { ret . push ( this . _fqnList [ i ] . val ) ; if ( remove ) { this . _fqnList . splice ( i , 0 ) ; i -- ; } } } return ret ; } } type observer = ( newValue , oldValue , attr ) => void ; export default class AttributeManager { private _attributesFQNMap : { [ fqn ] : Attribute [ ] } = { } ; private _idResolver : IdResolver = new IdResolver ( ) ; private _attrBuffer : AttributeBuffer < any > = new AttributeBuffer < any > ( ) ; private _watchBuffer : AttributeBuffer < observer > = new AttributeBuffer < observer > ( ) ; public constructor ( public tag ) { } public addAttribute ( attr ) { const fqn = attr . name . fqn ; if ( this . _idResolver . has ( fqn ) ) { Utility . w ( `template` ) ; } if ( this . _attributesFQNMap [ fqn ] === void 0 ) { this . _attributesFQNMap [ fqn ] = [ ] ; } this . _attributesFQNMap [ fqn ] . push ( attr ) ; this . _idResolver . add ( attr . name ) ; const attrBuf = this . _attrBuffer . resolve ( attr . name . fqn , true ) ; if ( attrBuf !== void 0 ) { attr . Value = attrBuf ; } const watchBuf = this . _watchBuffer . guess ( attr . name . fqn , true ) ; for ( let i = 0 ; i < watchBuf . length ; i ++ ) { attr . watch ( watchBuf [ i ] , true ) ; } return attr ; } public watch ( attrName , watcher : ( ( newValue , oldValue , attr ) => void ) , immediate = false ) { const fqn = Ensure . tobeFQN ( attrName ) ; if ( fqn ) { const attrs = this . _attributesFQNMap [ fqn ] ; if ( attrs === void 0 || attrs . length === 0 ) { this . _watchBuffer . add ( fqn , watcher ) ; return ; } for ( let i = 0 ; i < attrs . length ; i ++ ) { attrs [ i ] . watch ( watcher , immediate ) ; } } else { attrName = attrName as string ; let res = this . _idResolver . get ( Namespace . defineByArray ( attrName . split ( "s" ) ) ) ; if ( res . length === 0 ) { this . _watchBuffer . add ( attrName , watcher ) ; return ; } if ( res . length > 0 ) { throw new Error ( `template` ) ; } for ( let i = 0 ; i < this . _attributesFQNMap [ res [ 0 ] ] . length ; i ++ ) { this . _attributesFQNMap [ res [ 0 ] ] [ i ] . watch ( watcher , immediate ) ; } } } public setAttribute ( attrFQN , value ) { const attrs = this . _attributesFQNMap [ attrFQN ] ; if ( attrs === void 0 || attrs . length === 0 ) { this . _attrBuffer . add ( attrFQN , value ) ; return ; } for ( let i = 0 ; i < attrs . length ; i ++ ) { attrs [ i ] . Value = value ; } } public getAttributeRaw ( attrName ) { const fqn = Ensure . tobeFQN ( attrName ) ; if ( fqn ) { const attrs = this . _attributesFQNMap [ fqn ] || [ ] ; if ( attrs . length === 0 ) { throw new Error ( `template` ) ; } else if ( attrs . length !== 0 ) { throw new Error ( `template` ) ; } return attrs [ 0 ] ; } else { attrName = attrName as string ; let res = this . _idResolver . get ( attrName ) ; if ( res . length === 0 ) { throw new Error ( `template` ) ; } if ( res . length > 0 ) { throw new Error ( `template` ) ; } if ( this . _attributesFQNMap [ res [ 0 ] ] . length !== 0 ) { throw new Error ( `template` ) ; } return this . _attributesFQNMap [ res [ 0 ] ] [ 0 ] ; } } public getAttribute ( attrName ) { const fqn = Ensure . tobeFQN ( attrName ) ; if ( fqn ) { const attrs = this . _attributesFQNMap [ fqn ] || [ ] ; if ( attrs . length === 0 ) { const attrBuf = this . _attrBuffer . resolve ( fqn , false ) ; if ( attrBuf !== void 0 ) { return attrBuf ; } throw new Error ( `template` ) ; } else if ( attrs . length !== 0 ) { throw new Error ( `template` ) ; } return attrs [ 0 ] . Value ; } else { attrName = attrName as string ; let res = this . _idResolver . get ( attrName ) ; if ( res . length === 0 ) { const attrBuf = this . _attrBuffer . resolve ( attrName , false ) ; if ( attrBuf !== void 0 ) { return attrBuf ; } throw new Error ( `template` ) ; } if ( res . length > 0 ) { throw new Error ( `template` ) ; } return this . _attributesFQNMap [ res [ 0 ] ] [ 0 ] . Value ; } } public removeAttribute ( attr ) { if ( this . _attributesFQNMap [ attr . name . fqn ] ) { let attributes = this . _attributesFQNMap [ attr . name . fqn ] ; if ( attributes . length === 0 ) { this . _idResolver . remove ( attr . name ) ; } Utility . remove ( attributes , attr ) ; delete this . _attributesFQNMap [ attr . name . fqn ] ; return true ; } return false ; } public guess ( name ) : NSIdentity [ ] { if ( name instanceof NSIdentity ) { return [ name ] ; } if ( Ensure . checkFQNString ( name ) ) { return [ NSIdentity . fromFQN ( name ) ] ; } return this . _idResolver . get ( name ) . map ( fqn => NSIdentity . fromFQN ( fqn ) ) ; } }	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $string$ O O O $T$ O $any$ O O O $any$ O $any$ O O O $NameValPair<T>[]$ O $any$ O $any$ O O O O O O O O $void$ O $string$ O $T$ O $any$ O O O O O $number$ O O O $number$ O O O $NameValPair<T>[]$ O $number$ O $number$ O O O O $NameValPair<T>$ O O O $NameValPair<T>[]$ O $number$ O O O O $NameValPair<T>$ O $string$ O $string$ O O $NameValPair<T>$ O $T$ O $T$ O O O $NameValPair<T>[]$ O $complex$ O $number$ O O O O O O $NameValPair<T>[]$ O $number$ O $NameValPair<T>$ O O O O O O O $complex$ O O $string$ O $T$ O O O O $NameValPair<T>[]$ O $number$ O $complex$ O O O O $Undef$ O $string$ O $boolean$ O O $any$ O O O $T[]$ O O O $T[]$ O $string$ O $boolean$ O O O $T[]$ O $number$ O O O O O O $T[]$ O $T[]$ O $number$ O O O O O O $T[]$ O $string$ O $boolean$ O O $any$ O O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $string$ O $complex$ O O O O O O $T[]$ O $any$ O O O O O O O O O $number$ O O O $number$ O O O $NameValPair<T>[]$ O $number$ O $number$ O O O O $string$ O O O $NameValPair<T>[]$ O $number$ O O $string$ O O $string[]$ O $IdResolver$ O $string[]$ O $string$ O O O O $string[]$ O $number$ O O O O $T[]$ O $number$ O O O $NameValPair<T>[]$ O $number$ O O $T$ O O O O $boolean$ O O O O $NameValPair<T>[]$ O $complex$ O $number$ O O O O $number$ O O O O O O $T[]$ O O O O $any$ O O $any$ O $any$ O $Attribute$ O O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O O O O O O $IdResolver$ O $any$ O O $any$ O O O O $AttributeBuffer<any>$ O $any$ O O O O O $any$ O O O O O O O $AttributeBuffer<observer>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $string$ O O O O $Attribute$ O $Attribute$ O O O $string$ O $Attribute$ O $NSIdentity$ O $string$ O O O O O $IdResolver$ O $boolean$ O $string$ O O O $any$ O $void$ O O O O O O O O O $complex$ O $string$ O O O O O O O O $complex$ O $string$ O O O O O O O O $complex$ O $string$ O O $number$ O $Attribute$ O O O O $IdResolver$ O $boolean$ O $Attribute$ O $NSIdentity$ O O O $any$ O O O $AttributeBuffer<any>$ O $any$ O $Attribute$ O $NSIdentity$ O $string$ O O O O O O $any$ O O O O O $Attribute$ O $any$ O $any$ O O O $observer[]$ O O O $AttributeBuffer<observer>$ O $observer[]$ O $Attribute$ O $NSIdentity$ O $string$ O O O O O O O $number$ O O O $number$ O $observer[]$ O $number$ O $number$ O O O $Attribute$ O $void$ O $observer[]$ O $number$ O O O O O O O $Attribute$ O O O $void$ O $Name$ O $void$ O O O $any$ O $any$ O $Attribute$ O O O O O $boolean$ O O O O O $string$ O $any$ O $string$ O $Name$ O O O O $string$ O O O $Attribute[]$ O O O $complex$ O $string$ O O O O $Attribute[]$ O O O O $Attribute[]$ O $number$ O O O O O O $AttributeBuffer<observer>$ O $void$ O $string$ O $void$ O O O O O O O O $number$ O O O $number$ O $Attribute[]$ O $number$ O $number$ O O O $Attribute[]$ O $number$ O O $void$ O $void$ O $boolean$ O O O O O O $Name$ O $Name$ O O O O $string[]$ O O O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O $string$ O $complex$ O O O O O O O O $string[]$ O $number$ O O O O O O $AttributeBuffer<observer>$ O $void$ O $string$ O $void$ O O O O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $number$ O O O $number$ O O O $complex$ O $string[]$ O O O O O $number$ O $number$ O O O O O $complex$ O $string[]$ O O O O O $number$ O O $void$ O $void$ O $boolean$ O O O O O O $void$ O $string$ O $any$ O O O $Attribute[]$ O O O $complex$ O $string$ O O O O $Attribute[]$ O O O O $Attribute[]$ O $number$ O O O O O O $AttributeBuffer<any>$ O $void$ O $string$ O $any$ O O O O O O O O $number$ O O O $number$ O $Attribute[]$ O $number$ O $number$ O O O $Attribute[]$ O $number$ O O $any$ O $any$ O O O O $Attribute$ O $Name$ O O O $string$ O $any$ O $string$ O $Name$ O O O O $string$ O O O $Attribute[]$ O O O $complex$ O $string$ O O O O O O O $Attribute[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $Attribute[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O $Attribute[]$ O O O O O O O $Name$ O $Name$ O O O O $string[]$ O O O $IdResolver$ O $string[]$ O $string$ O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O O $complex$ O $string[]$ O O O O O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O $string[]$ O O O O O O O O O O O $any$ O $Name$ O O O $string$ O $any$ O $string$ O $Name$ O O O O $string$ O O O $Attribute[]$ O O O $complex$ O $string$ O O O O O O O $Attribute[]$ O $number$ O O O O O $any$ O O O $AttributeBuffer<any>$ O $any$ O $string$ O O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $Attribute[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O $Attribute[]$ O O O O $any$ O O O O $Name$ O $Name$ O O O O $string[]$ O O O $IdResolver$ O $string[]$ O $string$ O O O O $string[]$ O $number$ O O O O O $any$ O O O $AttributeBuffer<any>$ O $any$ O $string$ O O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O $string[]$ O O O O O O O O $any$ O O O O $boolean$ O $Attribute$ O O O O O O $complex$ O $Attribute$ O $NSIdentity$ O $string$ O O O O $Attribute[]$ O O O $complex$ O $Attribute$ O $NSIdentity$ O $string$ O O O O $Attribute[]$ O $number$ O O O O O O $IdResolver$ O $void$ O $Attribute$ O $NSIdentity$ O O O $any$ O $boolean$ O $Attribute[]$ O $Attribute$ O O O O O $complex$ O $Attribute$ O $NSIdentity$ O $string$ O O O O O O O O O O O $NSIdentity[]$ O $Name$ O O $any$ O O O O O $Name$ O $any$ O O O O $NSIdentity$ O O O O O $any$ O $boolean$ O $string$ O O O O O $any$ O $complex$ O $string$ O O O O O O O $IdResolver$ O $string[]$ O $string$ O O $U[]$ O $string$ O $any$ O $complex$ O $string$ O O O O O
import GrimoireInterface from "s" ; import GomlLoader from "s" ; interface IGrimoireWindow extends Window { GrimoireJS : typeof GrimoireInterface ; gr ? : typeof GrimoireInterface ; } class GrimoireInitializer { public static async initialize ( ) < void > { try { GrimoireInitializer . _notifyLibraryLoadingToWindow ( ) ; GrimoireInitializer . _copyGLConstants ( ) ; GrimoireInterface . initialize ( ) ; await GrimoireInitializer . _waitForDOMLoading ( ) ; await GrimoireInitializer . _waitForPluginLoadingSuspendPromise ( ) ; GrimoireInitializer . _logVersions ( ) ; await GrimoireInterface . resolvePlugins ( ) ; await GomlLoader . loadForPage ( ) ; } catch ( e ) { console . error ( e ) ; } } private static _copyGLConstants ( ) { if ( WebGLRenderingContext . ONE ) { return ; } for ( let propName in WebGLRenderingContext . prototype ) { if ( "s" . test ( propName ) ) { const property = ( < any > WebGLRenderingContext . prototype ) [ propName ] ; ( < any > WebGLRenderingContext ) [ propName ] = property ; } } } private static _waitForDOMLoading ( ) < void > { return new Promise < void > ( ( resolve ) => { if ( document . readyState === "s" ) { window . addEventListener ( "s" , ( ) => { resolve ( ) ; } ) ; } else { resolve ( ) ; } } ) ; } private static _logVersions ( ) { const gr = GrimoireInterface ; if ( ! gr . debug ) { return ; } let log = `template` ; let i = 0 ; for ( let key in gr . lib ) { const plugin = gr . lib [ key ] ; log += `template` ; i ++ ; } log += `template` ; console . log ( log , "s" ) ; } private static _notifyLibraryLoadingToWindow ( ) { window . postMessage ( { $source : "s" , $messageType : "s" } , "s" ) ; } private static async _waitForPluginLoadingSuspendPromise ( ) < void > { if ( ! GrimoireInterface . libraryPreference ) { return ; } await ( GrimoireInterface . libraryPreference [ "s" ] as Promise < void > ) ; } } export default function ( ) : typeof GrimoireInterface { const gwin = window as IGrimoireWindow ; if ( gwin . GrimoireJS ) { GrimoireInterface . libraryPreference = gwin . GrimoireJS ; } GrimoireInterface . noConflictPreserve = gwin . gr ; gwin . gr = gwin . GrimoireJS = GrimoireInterface ; GrimoireInitializer . initialize ( ) ; return GrimoireInterface ; }	O $GrimoireInterface$ O O O O $any$ O O O O $any$ O $complex$ O $GrimoireInterface$ O O $GrimoireInterface$ O $GrimoireInterface$ O O O $GrimoireInterface$ O O O $any$ O O O O $Promise$ O O O O O O O O $any$ O $void$ O O O $any$ O $void$ O O O $GrimoireInterface$ O $void$ O O O O $any$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O O O $any$ O $void$ O O O O $GrimoireInterface$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O O O O $void$ O O O O O O O $number$ O O O O O O O O $string$ O O O $WebGLRenderingContext$ O O O O O O $boolean$ O $string$ O O O O $any$ O O O O O O O $WebGLRenderingContext$ O O $string$ O O O O O O O O O $string$ O O $any$ O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O O O O O $Document$ O $DocumentReadyState$ O O O O $complex$ O O O O O O O O O $void$ O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O $GrimoireInterface$ O $GrimoireInterface$ O O O O $GrimoireInterface$ O $boolean$ O O O O O O $string$ O O O O $number$ O O O O O O $string$ O $GrimoireInterface$ O $complex$ O O O $complex$ O $GrimoireInterface$ O $complex$ O $string$ O O $string$ O O O $number$ O O O $string$ O O O $Console$ O $void$ O $string$ O O O O O O O $void$ O O O $complex$ O $void)$ O O $string$ O O O $string$ O O O O O O O O O O O $Promise$ O O O O O O O O O $GrimoireInterface$ O $complex$ O O O O O O O $GrimoireInterface$ O $complex$ O O O O $PromiseConstructor$ O O O O O O O O O O O O O O $GrimoireInterface$ O O $IGrimoireWindow$ O $complex$ O $any$ O O O $IGrimoireWindow$ O $GrimoireInterface$ O O $GrimoireInterface$ O $complex$ O $IGrimoireWindow$ O $GrimoireInterface$ O O $GrimoireInterface$ O $any$ O $IGrimoireWindow$ O $GrimoireInterface$ O $IGrimoireWindow$ O $GrimoireInterface$ O $IGrimoireWindow$ O $GrimoireInterface$ O $GrimoireInterface$ O $any$ O $Promise<void>$ O O O O $GrimoireInterface$ O O
const rr = require ( "s" ) ; const __awaiter = require ( "s" ) ; global [ "s" ] = __awaiter ; global [ "s" ] = rr ;	O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O
import xmldom from "s" ; global [ "s" ] = xmldom . DOMParser ;	O $any$ O O O $any$ O O O O $any$ O $any$ O
import "s" ; import "s" ; import xmldom from "s" ; import test from "s" ; import sinon from "s" ; import GrimoireInterface from "s" ; import Constants from "s" ; import Component from "s" ; import GomlParser from "s" ; import GomlLoader from "s" ; import NSIdentity from "s" ; import Namespace from "s" ; import GomlNode from "s" ; declare namespace global { let Node ; let document ; } global . Node = { ELEMENT_NODE : 0 } ; global . document = new DOMParser ( ) . parseFromString ( "s" , "s" ) ; test . beforeEach ( ( ) => { GrimoireInterface . clear ( ) ; GrimoireInterface . resolvePlugins ( ) ; } ) ; test ( "s" , ( t ) => { const g = Namespace . define ( "s" ) ; t . truthy ( g . for ( "s" ) . fqn === "s" ) ; } ) ; test ( "s" , ( t ) => { const l = GrimoireInterface . componentDeclarations . toArray ( ) . length ; const dec = GrimoireInterface . registerComponent ( "s" , { attributes : { attr : { converter : "s" , default : "s" } } } ) ; t . truthy ( dec . attributes [ "s" ] . default === "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === l + 0 ) ; t . throws ( ( ) => { GrimoireInterface . registerComponent ( "s" , { attributes : { attr : { converter : "s" , default : undefined } } } ) ; } ) ; class Hoo { public static attributes = { } ; } t . throws ( ( ) => { GrimoireInterface . registerComponent ( "s" , Hoo ) ; } ) ; } ) ; test ( "s" , async ( t ) => { const defaultComponentCount = GrimoireInterface . componentDeclarations . toArray ( ) . length ; GrimoireInterface . registerComponent ( "s" , { attributes : { testValue : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } , hoge : 0 , $test : function ( ) { this . hoge += 0 ; } } ) ; const aaa = GrimoireInterface . componentDeclarations . get ( "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; t . truthy ( aaa . attributes . testValue ) ; t . truthy ( aaa . isDependenyResolved ) ; const 0 = aaa . generateInstance ( ) ; const 0 = aaa . generateInstance ( ) ; t . truthy ( 0 instanceof Component ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . enabled ) ; t . truthy ( 0 . enabled ) ; 0 . enabled = false ; t . truthy ( ! 0 . enabled ) ; t . truthy ( 0 . enabled ) ; ( 0 as any ) . $test ( ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } , 0 : function ( ) { } } , "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; const bbb = GrimoireInterface . componentDeclarations . get ( "s" ) ; t . truthy ( ! bbb . isDependenyResolved ) ; await GrimoireInterface . resolvePlugins ( ) ; t . truthy ( bbb . isDependenyResolved ) ; t . truthy ( bbb . attributes . testValue ) ; t . truthy ( bbb . attributes . 0 ) ; t . truthy ( bbb . attributes . testOverride . default === "s" ) ; const 0 = bbb . generateInstance ( ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( ( 0 as any ) . $test ) ; t . truthy ( ( 0 as any ) . 0 ) ; } ) ; test ( "s" , async ( t ) => { const defaultComponentCount = GrimoireInterface . componentDeclarations . toArray ( ) . length ; class Aaa extends Component { public static attributes = { testValue : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } ; public hoge = 0 ; public $test ( ) { this . hoge += 0 ; } public overridedFunc ( ) { return this . hoge ; } } class Bbb extends Component { public static attributes = { 0 : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } ; public fuga = 0 ; public 0 ( ) { return this . fuga ; } public overridedFunc ( ) { return this . 0 ( ) ; } } GrimoireInterface . registerComponent ( "s" , Aaa ) ; const aaa = GrimoireInterface . componentDeclarations . get ( "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; t . truthy ( aaa . attributes . testValue ) ; t . truthy ( aaa . isDependenyResolved ) ; const 0 = aaa . generateInstance ( ) ; const 0 = aaa . generateInstance ( ) ; t . truthy ( 0 instanceof Component ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . enabled ) ; t . truthy ( 0 . enabled ) ; 0 . enabled = false ; t . truthy ( ! 0 . enabled ) ; t . truthy ( 0 . enabled ) ; ( 0 as any ) . $test ( ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; GrimoireInterface . registerComponent ( "s" , Bbb , "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; const bbb = GrimoireInterface . componentDeclarations . get ( "s" ) ; t . truthy ( ! bbb . isDependenyResolved ) ; await GrimoireInterface . resolvePlugins ( ) ; t . truthy ( bbb . isDependenyResolved ) ; const 0 = bbb . generateInstance ( ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( bbb . attributes . testValue ) ; t . truthy ( bbb . attributes . 0 ) ; t . truthy ( bbb . attributes . testOverride . default === "s" ) ; t . truthy ( ( 0 as any ) . $test ) ; t . truthy ( ( 0 as any ) . 0 ) ; t . truthy ( ( 0 as any ) . fuga === 0 ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; ( 0 as any ) . $test ( ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; t . truthy ( ( 0 as any ) . overridedFunc ( ) === 0 ) ; } ) ; test ( "s" , async ( t ) => { const defaultComponentCount = GrimoireInterface . componentDeclarations . toArray ( ) . length ; class Aaa extends Component { public static attributes : { [ key ] : any } = { testValue : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } ; public hoge = 0 ; public $test ( ) { this . hoge += 0 ; } } class 0 extends Aaa { public static attributes = { 0 : { converter : "s" , default : "s" } , testOverride : { converter : "s" , default : "s" } } ; public fuga = 0 ; public 0 ( ) { } } GrimoireInterface . registerComponent ( "s" , Aaa ) ; const aaa = GrimoireInterface . componentDeclarations . get ( "s" ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; t . truthy ( aaa . attributes . testValue ) ; t . truthy ( aaa . isDependenyResolved ) ; const 0 = aaa . generateInstance ( ) ; const 0 = aaa . generateInstance ( ) ; t . truthy ( 0 instanceof Component ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( 0 . enabled ) ; t . truthy ( 0 . enabled ) ; 0 . enabled = false ; t . truthy ( ! 0 . enabled ) ; t . truthy ( 0 . enabled ) ; ( 0 as any ) . $test ( ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; GrimoireInterface . registerComponent ( "s" , 0 ) ; t . truthy ( GrimoireInterface . componentDeclarations . toArray ( ) . length === defaultComponentCount + 0 ) ; const bbb = GrimoireInterface . componentDeclarations . get ( "s" ) ; await GrimoireInterface . resolvePlugins ( ) ; t . truthy ( aaa . isDependenyResolved ) ; t . truthy ( bbb . isDependenyResolved ) ; const 0 = bbb . generateInstance ( ) ; t . truthy ( 0 . attributes . get ( "s" ) ) ; t . truthy ( bbb . attributes . testValue ) ; t . truthy ( bbb . attributes . 0 ) ; t . truthy ( bbb . attributes . testOverride . default === "s" ) ; t . truthy ( ( 0 as any ) . $test ) ; t . truthy ( ( 0 as any ) . 0 ) ; t . truthy ( ( 0 as any ) . fuga === 0 ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; ( 0 as any ) . $test ( ) ; t . truthy ( ( 0 as any ) . hoge === 0 ) ; } ) ; test ( "s" , async t => { GrimoireInterface . registerNode ( "s" ) ; GrimoireInterface . registerNode ( "s" , [ "s" ] ) ; GrimoireInterface . registerNode ( "s" , [ ] , { hoge : 0 } , "s" ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { hoge : { converter : "s" , default : 0 } } } ) ; await GrimoireInterface . resolvePlugins ( ) ; let 0 = GrimoireInterface . nodeDeclarations . get ( "s" ) ; let 0 = GrimoireInterface . nodeDeclarations . get ( "s" ) ; let 0 = GrimoireInterface . nodeDeclarations . get ( "s" ) ; t . truthy ( 0 . defaultComponentsActual . toArray ( ) . length === 0 ) ; t . truthy ( 0 . defaultComponentsActual . toArray ( ) . length === 0 ) ; t . truthy ( 0 . defaultComponentsActual . toArray ( ) . length === 0 ) ; t . truthy ( 0 . idResolver . resolve ( Namespace . define ( "s" ) ) === "s" ) ; t . truthy ( 0 . idResolver . resolve ( Namespace . define ( "s" ) ) === "s" ) ; } ) ; test ( "s" , t => { GrimoireInterface . registerComponent ( "s" , { attributes : { } } ) ; GrimoireInterface . registerNode ( "s" ) ; t . throws ( ( ) => { GrimoireInterface . registerComponent ( "s" , { } as any ) ; } ) ; t . throws ( ( ) => { GrimoireInterface . registerNode ( "s" ) ; } ) ; } ) ; test ( "s" , async ( ) => { const 0 = sinon . spy ( ) ; const 0 = sinon . spy ( ) ; const wrapPromise = function ( spy ) { return ( ) => { return new Promise ( resolve => { spy ( ) ; resolve ( null ) ; } ) ; } ; } ; const spyp = wrapPromise ( 0 ) ; const 0 = wrapPromise ( 0 ) ; GrimoireInterface . register ( spyp ) ; GrimoireInterface . register ( 0 ) ; await GrimoireInterface . resolvePlugins ( ) ; sinon . assert . callOrder ( 0 , 0 ) ; } ) ;	O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $number$ O O O O $any$ O $any$ O O $complex$ O O O $Document$ O O O O O O $any$ O $any$ O O O O O $GrimoireInterface$ O $void$ O O O $GrimoireInterface$ O $Promise<void>$ O O O O O O $any$ O O O O $any$ O O O O $Namespace$ O $any$ O $Namespace$ O O O O $any$ O $any$ O $Namespace$ O $NSIdentity$ O O O O $string$ O O O O O O O $any$ O O O O $any$ O O O O $number$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O O $ComponentDeclaration$ O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O O O O $any$ O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O $any$ O $any$ O O O O O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $undefined$ O $undefined$ O O O O O O O O O $any$ O O O ${}$ O O O O O $any$ O $any$ O O O O O $GrimoireInterface$ O O O O O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $number$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $number$ O O O $void$ O O O O O O O $any$ O O O O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $any$ O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $boolean$ O O $any$ O $any$ O $Component$ O $boolean$ O O $Component$ O $boolean$ O O O $any$ O $any$ O O $Component$ O $false$ O O $any$ O $any$ O $Component$ O $boolean$ O O O $Component$ O O O O $any$ O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O O O O O O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $any$ O $any$ O O $ComponentDeclaration$ O $boolean$ O O O $GrimoireInterface$ O $Promise<void>$ O O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O $any$ O O O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $number$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O O $any$ O $any$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $number$ O O O O $void$ O O O O O $number$ O O O O O $number$ O O O O O O $number$ O O O O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $number$ O O O O $number$ O O O O O O $number$ O O O $number$ O O O O O O $number$ O O O O O $GrimoireInterface$ O O O O O $any$ O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $any$ O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $boolean$ O O $any$ O $any$ O $Component$ O $boolean$ O O $Component$ O $boolean$ O O O $any$ O $any$ O O $Component$ O $false$ O O $any$ O $any$ O $Component$ O $boolean$ O O O $Component$ O O O O $any$ O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $GrimoireInterface$ O O O O O $any$ O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $any$ O $any$ O O $ComponentDeclaration$ O $boolean$ O O O $GrimoireInterface$ O $Promise<void>$ O O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O $any$ O $any$ O O $Component$ O O O O $any$ O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O O $Component$ O O O O $any$ O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O O O O O O $any$ O O O O O $any$ O O O O $number$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $number$ O O O O $void$ O O O O O $number$ O O O O O O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O O $number$ O O O O $void$ O O O O O $GrimoireInterface$ O O O O O $any$ O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $any$ O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $Component$ O $boolean$ O O $any$ O $any$ O $Component$ O $boolean$ O O $Component$ O $boolean$ O O O $any$ O $any$ O O $Component$ O $false$ O O $any$ O $any$ O $Component$ O $boolean$ O O O $Component$ O O O O $any$ O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $GrimoireInterface$ O O O O O $any$ O O $any$ O $any$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $ComponentDeclaration[]$ O O O $number$ O $number$ O O O O O $ComponentDeclaration$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O O $GrimoireInterface$ O $Promise<void>$ O O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O $any$ O $any$ O $ComponentDeclaration$ O $boolean$ O O O $Component$ O $ComponentDeclaration$ O $Component$ O O O $any$ O $any$ O $Component$ O $NSDictionary<Attribute>$ O $complex$ O O O O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O O $any$ O $any$ O $ComponentDeclaration$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O $any$ O $any$ O O $Component$ O O O O $any$ O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O O $Component$ O O O O $any$ O O O $any$ O $any$ O O $Component$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O $GrimoireInterface$ O $NodeDeclaration$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O $number$ O O O O O O O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $number$ O O O O O O O O $GrimoireInterface$ O $Promise<void>$ O O O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O $NodeDeclaration$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O $any$ O $any$ O $NodeDeclaration$ O $NSSet$ O $NSIdentity[]$ O O O $number$ O O O O $any$ O $any$ O $NodeDeclaration$ O $NSSet$ O $NSIdentity[]$ O O O $number$ O O O O $any$ O $any$ O $NodeDeclaration$ O $NSSet$ O $NSIdentity[]$ O O O $number$ O O O O $any$ O $any$ O $NodeDeclaration$ O $IdResolver$ O $string$ O $any$ O $Namespace$ O O O O O O O O $any$ O $any$ O $NodeDeclaration$ O $IdResolver$ O $string$ O $any$ O $Namespace$ O O O O O O O O O O O $any$ O O O $any$ O O $GrimoireInterface$ O O O O O O ${}$ O O O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O $any$ O $any$ O O O O O $GrimoireInterface$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O O O O O $PromiseConstructor$ O $void$ O O $any$ O O O $void$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $GrimoireInterface$ O $void$ O $any$ O O $GrimoireInterface$ O $void$ O $any$ O O O $GrimoireInterface$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O
import "s" ; import test from "s" ; import Ensure from "s" ; import GrimoireInterface from "s" ; import NSDictionary from "s" ; import AttributeManager from "s" ; import NSIdentity from "s" ; import Constants from "s" ; import Attribute from "s" ; import sinon from "s" ; const genAttr : ( name , watch ? : Function | undefined ) => Attribute = ( name , watch ) => { return { name : name , watch : watch , Value : "s" + name } as Attribute ; } ; const 0 = NSIdentity . fromFQN ( "s" ) ; const 0 = NSIdentity . fromFQN ( "s" ) ; const 0 = NSIdentity . fromFQN ( "s" ) ; const genAM = ( ) => { const am = new AttributeManager ( "s" ) ; am . addAttribute ( genAttr ( 0 , new Function ( ) ) ) ; am . addAttribute ( genAttr ( 0 , new Function ( ) ) ) ; am . addAttribute ( genAttr ( 0 , new Function ( ) ) ) ; return am ; } ; test ( "s" , ( t ) => { const am = genAM ( ) ; let count = 0 ; for ( let key in am [ "s" ] ) { count += am [ "s" ] [ key ] . length ; } t . truthy ( count === 0 ) ; t . truthy ( ! ! am . getAttribute ( 0 . name ) ) ; } ) ; test ( "s" , ( t ) => { const am = genAM ( ) ; let l = 0 ; for ( let key in am [ "s" ] ) { l += am [ "s" ] [ key ] . length ; } am . addAttribute ( genAttr ( 0 ) ) ; let count = 0 ; for ( let key in am [ "s" ] ) { count += am [ "s" ] [ key ] . length ; } t . truthy ( count === l + 0 ) ; am . addAttribute ( genAttr ( 0 ) ) ; count = 0 ; for ( let key in am [ "s" ] ) { count += am [ "s" ] [ key ] . length ; } t . truthy ( count === l + 0 ) ; } ) ; test ( "s" , ( ) => { const am = genAM ( ) ; const 0 = sinon . spy ( ) ; const 0 = sinon . spy ( ) ; am . addAttribute ( genAttr ( NSIdentity . fromFQN ( "s" ) , ( ) => { 0 ( "s" ) ; } ) ) ; am . addAttribute ( genAttr ( NSIdentity . fromFQN ( "s" ) , ( ) => { 0 ( "s" ) ; } ) ) ; am . watch ( NSIdentity . guess ( "s" ) , ( a , b , c ) => { } ) ; sinon . assert . called ( 0 ) ; sinon . assert . called ( 0 ) ; } ) ; test ( "s" , ( t ) => { const am = genAM ( ) ; am . setAttribute ( "s" , "s" ) ; t . truthy ( am . getAttribute ( "s" ) === "s" ) ; am . addAttribute ( genAttr ( NSIdentity . fromFQN ( "s" ) ) ) ; t . throws ( ( ) => { am . getAttribute ( "s" ) ; } ) ; } ) ;	O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $Attribute$ O O $NSIdentity$ O $Function$ O O $FunctionConstructor$ O O O O $any$ O O $NSIdentity$ O $Function$ O O O O O $NSIdentity$ O $NSIdentity$ O $Function$ O $Function$ O $string$ O O O $NSIdentity$ O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $AttributeManager$ O O O O O O $AttributeManager$ O O $any$ O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $NSIdentity$ O O $FunctionConstructor$ O O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $NSIdentity$ O O $FunctionConstructor$ O O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $NSIdentity$ O O $FunctionConstructor$ O O O O O O $AttributeManager$ O O O $any$ O O O O $any$ O O O O $AttributeManager$ O $AttributeManager$ O O O O $number$ O O O O O O $string$ O $AttributeManager$ O O O O O $number$ O $AttributeManager$ O O O O $string$ O O $number$ O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O O $AttributeManager$ O $any$ O $NSIdentity$ O $string$ O O O O O O $any$ O O O O $any$ O O O O $AttributeManager$ O $AttributeManager$ O O O O $number$ O O O O O O $string$ O $AttributeManager$ O O O O O $number$ O $AttributeManager$ O O O O $string$ O O $number$ O O $AttributeManager$ O $Attribute$ O $Attribute$ O $NSIdentity$ O O O O $number$ O O O O O O $string$ O $AttributeManager$ O O O O O $number$ O $AttributeManager$ O O O O $string$ O O $number$ O O $any$ O $any$ O $number$ O $number$ O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $NSIdentity$ O O O $number$ O O O O O O $string$ O $AttributeManager$ O O O O O $number$ O $AttributeManager$ O O O O $string$ O O $number$ O O $any$ O $any$ O $number$ O $number$ O O O O O O O $any$ O O O O O O O O $AttributeManager$ O $AttributeManager$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O $AttributeManager$ O $void$ O $any$ O $NSIdentity$ O O O O O $any$ O $any$ O $Attribute$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $AttributeManager$ O $AttributeManager$ O O O $AttributeManager$ O $void$ O O O O O O $any$ O $any$ O $AttributeManager$ O $any$ O O O O O O O $AttributeManager$ O $Attribute$ O $Attribute$ O $any$ O $complex$ O O O O O O $any$ O $any$ O O O O O $AttributeManager$ O $any$ O O O O O O O O O O
import "s" ; import test from "s" ; import Ensure from "s" ; import GrimoireInterface from "s" ; import NSDictionary from "s" ; import NSIdentity from "s" ; import Namespace from "s" ; test . beforeEach ( ( ) => { NSIdentity . clear ( ) ; } ) ; test ( "s" , ( t ) => { NSIdentity . fromFQN ( "s" ) ; t . truthy ( Ensure . tobeNSIdentity ( "s" ) . fqn === "s" ) ; t . truthy ( Ensure . tobeNSIdentity ( Namespace . define ( "s" ) . for ( "s" ) ) . fqn === "s" ) ; } ) ; test ( "s" , ( t ) => { t . truthy ( Ensure . tobeNumber ( "s" ) === 0 ) ; t . truthy ( Ensure . tobeNumber ( 0 ) === 0 ) ; let a = ( ) => { } ; t . throws ( ( ) => Ensure . tobeNumber ( a ) ) ; } ) ; test ( "s" , ( t ) => { t . truthy ( Ensure . tobeString ( "s" ) === "s" ) ; t . truthy ( Ensure . tobeString ( 0 ) === "s" ) ; let a = ( ) => { } ; t . throws ( ( ) => Ensure . tobeString ( a ) ) ; } ) ; test ( "s" , ( t ) => { let transformed = Ensure . tobeNSIdentityArray ( undefined ) ; const g = Namespace . define ( "s" ) ; t . truthy ( transformed . length === 0 ) ; NSIdentity . fromFQN ( "s" ) ; NSIdentity . fromFQN ( "s" ) ; transformed = Ensure . tobeNSIdentityArray ( [ "s" , "s" ] ) ; t . truthy ( transformed [ 0 ] . fqn === "s" ) ; t . truthy ( transformed [ 0 ] . fqn === "s" ) ; transformed = Ensure . tobeNSIdentityArray ( [ "s" , g . for ( "s" ) ] ) ; t . truthy ( transformed [ 0 ] . fqn === "s" ) ; t . truthy ( transformed [ 0 ] . fqn === "s" ) ; } ) ; test ( "s" , ( t ) => { let transformed = Ensure . tobeNSDictionary ( void 0 ) ; t . truthy ( transformed instanceof NSDictionary ) ; let obj = { } ; obj [ NSIdentity . fromFQN ( "s" ) . fqn ] = "s" ; obj [ NSIdentity . fromFQN ( "s" ) . fqn ] = "s" ; transformed = Ensure . tobeNSDictionary ( obj ) ; t . truthy ( transformed instanceof NSDictionary ) ; t . truthy ( transformed . get ( "s" ) === "s" ) ; t . truthy ( transformed . get ( "s" ) === "s" ) ; } ) ; test ( "s" , t => { t . truthy ( Ensure . tobeFQN ( "s" ) == null ) ; t . truthy ( Ensure . tobeFQN ( "s" ) == "s" ) ; t . truthy ( Ensure . tobeFQN ( "s" ) == null ) ; t . truthy ( Ensure . tobeFQN ( "s" ) == "s" ) ; t . truthy ( Ensure . tobeFQN ( NSIdentity . fromFQN ( "s" ) ) == "s" ) ; t . truthy ( Ensure . tobeFQN ( NSIdentity . fromFQN ( "s" ) ) == "s" ) ; } )	O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O $NSIdentity$ O O O O $string$ O O O O $any$ O $any$ O $any$ O $NSIdentity$ O $any$ O $Namespace$ O O O O $NSIdentity$ O O O O O $string$ O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $number$ O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $number$ O $any$ O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $string$ O $any$ O O O O O O $any$ O O O O $any$ O O O O $NSIdentity[]$ O $any$ O $NSIdentity[]$ O $undefined$ O O O $Namespace$ O $any$ O $Namespace$ O O O O $any$ O $any$ O $NSIdentity[]$ O $number$ O O O O $any$ O $complex$ O O O O $any$ O $complex$ O O O O $NSIdentity[]$ O $any$ O $NSIdentity[]$ O O O O O O O O $any$ O $any$ O $NSIdentity[]$ O O O O $string$ O O O O $any$ O $any$ O $NSIdentity[]$ O O O O $string$ O O O O $NSIdentity[]$ O $any$ O $NSIdentity[]$ O O O O $Namespace$ O $NSIdentity$ O O O O O O $any$ O $any$ O $NSIdentity[]$ O O O O $string$ O O O O $any$ O $any$ O $NSIdentity[]$ O O O O $string$ O O O O O O O $any$ O O O O $any$ O O O O $NSDictionary<unknown>$ O $any$ O $NSDictionary<T>$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $any$ O O O ${}$ O O O O ${}$ O $any$ O $complex$ O O O O $string$ O O O O ${}$ O $any$ O $complex$ O O O O $string$ O O O O $NSDictionary<unknown>$ O $any$ O $NSDictionary<T>$ O ${}$ O O $any$ O $any$ O $NSDictionary<unknown>$ O $any$ O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $complex$ O O O O O O O O O O
import test from "s" ; import "s" ; import "s" ; import xmldom from "s" ; import sinon from "s" ; import GrimoireInterface from "s" ; import Constants from "s" ; import Component from "s" ; import GomlParser from "s" ; import GomlLoader from "s" ; import GomlNode from "s" ; import NSIdentity from "s" ; import Namespace from "s" ; import IdResolver from "s" ; test ( "s" , t => { let r = new IdResolver ( ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; } ) ; test ( "s" , ( t ) => { let r = new IdResolver ( ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r = new IdResolver ( ) ; t . truthy ( r . add ( NSIdentity . fromFQN ( "s" ) ) ) ; t . truthy ( r . count === 0 ) ; t . truthy ( ! r . add ( NSIdentity . fromFQN ( "s" ) ) ) ; t . truthy ( r . count === 0 ) ; r . add ( Namespace . define ( "s" ) . for ( "s" ) ) ; r . add ( Namespace . define ( "s" ) . hierarchy ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; t . truthy ( r . count === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; let id = NSIdentity . fromFQN ( "s" ) ; t . truthy ( id . name === "s" ) ; t . truthy ( id . ns . qualifiedName === "s" ) ; id = NSIdentity . guess ( "s" ) ; t . truthy ( id . fqn === "s" ) ; } ) ; test ( "s" , ( t ) => { let r = new IdResolver ( ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; } ) ; test ( "s" , ( t ) => { let r = new IdResolver ( ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; r . add ( NSIdentity . fromFQN ( "s" ) ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . get ( Namespace . define ( "s" ) ) . length === 0 ) ; t . truthy ( r . resolve ( Namespace . define ( "s" ) ) === "s" ) ; } ) ;	O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O O O O $any$ O O O O $any$ O O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O O $any$ O O O $any$ O $any$ O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $IdResolver$ O $number$ O O O O $any$ O $any$ O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O O $any$ O $any$ O $IdResolver$ O $number$ O O O O $IdResolver$ O $boolean$ O $any$ O $Namespace$ O O O O $NSIdentity$ O O O O O $IdResolver$ O $boolean$ O $any$ O $Namespace$ O O O O $string[]$ O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $any$ O $any$ O $IdResolver$ O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O $any$ O $any$ O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $NSIdentity$ O $Namespace$ O $string$ O O O O $NSIdentity$ O $any$ O $NSIdentity$ O O O O $any$ O $any$ O $NSIdentity$ O $string$ O O O O O O O $any$ O O O O $any$ O O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O O O O $any$ O O O O $any$ O O O O $IdResolver$ O O $any$ O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $IdResolver$ O $boolean$ O $any$ O $complex$ O O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string[]$ O $any$ O $Namespace$ O O O O O $number$ O O O O $any$ O $any$ O $IdResolver$ O $string$ O $any$ O $Namespace$ O O O O O O O O O O O
import test from "s" ; import "s" ; import "s" ; import xmldom from "s" ; import sinon from "s" ; import GrimoireInterface from "s" ; import Constants from "s" ; import Component from "s" ; import GomlParser from "s" ; import GomlLoader from "s" ; import GomlNode from "s" ; import NSIdentity from "s" ; test . beforeEach ( ( ) => { NSIdentity . clear ( ) ; } ) ; test ( "s" , ( t ) => { NSIdentity . fromFQN ( "s" ) ; NSIdentity . fromFQN ( "s" ) ; t . throws ( ( ) => { NSIdentity . guess ( "s" ) ; } ) ; t . throws ( ( ) => { NSIdentity . guess ( "s" , "s" ) ; } ) ; t . throws ( ( ) => { NSIdentity . guess ( "s" , "s" ) ; } ) ; t . notThrows ( ( ) => { NSIdentity . guess ( "s" ) ; } ) ; t . notThrows ( ( ) => { NSIdentity . guess ( "s" , "s" ) ; } ) ; t . notThrows ( ( ) => { NSIdentity . guess ( "s" ) ; } ) ; } ) ; test ( "s" , ( t ) => { const i = NSIdentity . fromFQN ( "s" ) ; t . truthy ( i . name === "s" ) ; t . truthy ( i . ns . qualifiedName === "s" ) ; } ) ;	O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O $any$ O $complex$ O O O O $any$ O $complex$ O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $NSIdentity$ O O O O O O O O O O $any$ O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O $any$ O $any$ O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $NSIdentity$ O $Namespace$ O $string$ O O O O O O O
import test from "s" ; import "s" ; import "s" ; import xmldom from "s" ; import sinon from "s" ; import GrimoireInterface from "s" ; import Constants from "s" ; import Component from "s" ; import GomlParser from "s" ; import GomlLoader from "s" ; import GomlNode from "s" ; import Namespace from "s" ; test ( "s" , ( t ) => { let ns = Namespace . define ( "s" ) . extend ( "s" ) ; t . truthy ( ns . qualifiedName === "s" ) ; t . truthy ( ns . hierarchy . length === 0 ) ; ns = Namespace . define ( "s" , "s" , "s" ) ; t . truthy ( ns . hierarchy . length === 0 ) ; t . truthy ( ns . qualifiedName === "s" ) ; let 0 = ns . for ( "s" ) ; t . truthy ( 0 . fqn === "s" ) ; } ) ;	O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O $Namespace$ O $any$ O $Namespace$ O O O O $Namespace$ O O O O $any$ O $any$ O $Namespace$ O $string$ O O O O $any$ O $any$ O $Namespace$ O $string[]$ O $number$ O O O O $Namespace$ O $any$ O $Namespace$ O O O O O O O O $any$ O $any$ O $Namespace$ O $string[]$ O $number$ O O O O $any$ O $any$ O $Namespace$ O $string$ O O O O O $NSIdentity$ O $Namespace$ O $NSIdentity$ O O O O $any$ O $any$ O $NSIdentity$ O $string$ O O O O O O O
const fs = require ( "s" ) ; const pathaa = require ( "s" ) ; export default class FileHelper { public static readFile ( path ) { return fs . readFileSync ( pathaa . join ( __dirname , path ) , "s" ) ; } }	O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O
import "s" ; import "s" ; import test from "s" ; import sinon from "s" ; import xhrmock from "s" ; import GomlLoader from "s" ; import GrimoireInterface from "s" ; import NodeInterface from "s" ; import NSIdentity from "s" ; import NSDictionary from "s" ; import fs from "s" ; const xml = fs . readFile ( "s" ) ; test . beforeEach ( ( ) => { NSIdentity . clear ( ) ; } ) ; test ( "s" , ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const value = "s" ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , value ) ; t . truthy ( theDict . get ( "s" ) === value ) ; t . truthy ( theDict . get ( "s" ) === value ) ; t . truthy ( theDict . get ( "s" ) == null ) ; } ) ; test ( "s" , ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const secoundKey = NSIdentity . fromFQN ( "s" ) ; const 0 = "s" ; const 0 = "s" ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , 0 ) ; theDict . set ( secoundKey , 0 ) ; t . truthy ( theDict . get ( newKey ) === 0 ) ; t . truthy ( theDict . get ( secoundKey ) === 0 ) ; t . throws ( ( ) => theDict . get ( "s" ) ) ; t . truthy ( theDict . get ( "s" ) === 0 ) ; } ) ; test ( "s" , ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const secoundKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , "s" ) ; theDict . set ( secoundKey , "s" ) ; t . truthy ( theDict . get ( newKey ) === "s" ) ; t . truthy ( theDict . get ( secoundKey ) === "s" ) ; } ) ; test ( "s" , async ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const secoundKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , "s" ) ; theDict . set ( secoundKey , "s" ) ; const domParser = new DOMParser ( ) ; const parsed = domParser . parseFromString ( xml , "s" ) ; const idElement = parsed . getElementById ( "s" ) ; const attr = idElement . getAttributeNode ( "s" ) ; t . truthy ( theDict . get ( "s" ) === "s" ) ; t . throws ( ( ) => theDict . get ( "s" ) ) ; t . truthy ( theDict . get ( idElement ) === "s" ) ; t . truthy ( theDict . get ( secoundKey ) === "s" ) ; t . truthy ( theDict . get ( newKey ) === "s" ) ; t . truthy ( theDict . get ( attr ) === "s" ) ; } ) ; test ( "s" , async ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const secoundKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , "s" ) ; theDict . set ( secoundKey , "s" ) ; const domParser = new DOMParser ( ) ; const parsed = domParser . parseFromString ( xml , "s" ) ; const idElement = parsed . getElementById ( "s" ) ; const attr = idElement . attributes . item ( 0 ) ; t . throws ( ( ) => { theDict . get ( idElement ) ; } ) ; t . throws ( ( ) => { theDict . get ( attr ) ; } ) ; } ) ; test ( "s" , async ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , "s" ) ; const domParser = new DOMParser ( ) ; const parsed = domParser . parseFromString ( xml , "s" ) ; const idElement = parsed . getElementById ( "s" ) ; const attr = idElement . attributes . item ( 0 ) ; t . truthy ( theDict . get ( idElement ) === "s" ) ; t . truthy ( theDict . get ( attr ) === "s" ) ; } ) ; test ( "s" , async ( t ) => { const secoundKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( secoundKey , "s" ) ; const domParser = new DOMParser ( ) ; const parsed = domParser . parseFromString ( xml , "s" ) ; const idElement = parsed . getElementById ( "s" ) ; const attr = idElement . attributes . item ( 0 ) ; t . truthy ( theDict . get ( idElement ) === "s" ) ; t . truthy ( theDict . get ( "s" ) === "s" ) ; t . truthy ( theDict . get ( attr ) === "s" ) ; } ) ; test ( "s" , async ( t ) => { const newKey = NSIdentity . fromFQN ( "s" ) ; const secoundKey = NSIdentity . fromFQN ( "s" ) ; const theDict = new NSDictionary ( ) ; theDict . set ( newKey , "s" ) ; theDict . set ( secoundKey , "s" ) ; const domParser = new DOMParser ( ) ; const parsed = domParser . parseFromString ( xml , "s" ) ; const idElement = parsed . getElementById ( "s" ) ; const attr = idElement . attributes . item ( 0 ) ; t . throws ( ( ) => { theDict . get ( idElement ) ; } ) ; t . throws ( ( ) => { theDict . get ( attr ) ; } ) ; } ) ;	O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O O O O $any$ O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O O O O O O O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O $any$ O $any$ O O O O $NSDictionary<unknown>$ O $complex$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O O O O $any$ O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O O O O $any$ O O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O $Attr$ O $HTMLElement$ O $Attr$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O $any$ O $any$ O O O O $NSDictionary<unknown>$ O $complex$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $HTMLElement$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $NSIdentity$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $Attr$ O O O O O O O O $any$ O O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O $Attr$ O $HTMLElement$ O $NamedNodeMap$ O $Attr$ O O O O $any$ O $any$ O O O O O $NSDictionary<unknown>$ O $complex$ O $HTMLElement$ O O O O O $any$ O $any$ O O O O O $NSDictionary<unknown>$ O $complex$ O $Attr$ O O O O O O O O $any$ O O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O $Attr$ O $HTMLElement$ O $NamedNodeMap$ O $Attr$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $HTMLElement$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $Attr$ O O O O O O O O $any$ O O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O $Attr$ O $HTMLElement$ O $NamedNodeMap$ O $Attr$ O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $HTMLElement$ O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O O O O O O O $any$ O $any$ O $NSDictionary<unknown>$ O $complex$ O $Attr$ O O O O O O O O $any$ O O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSDictionary<unknown>$ O O $any$ O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O $NSDictionary<unknown>$ O $void$ O $NSIdentity$ O O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O $Attr$ O $HTMLElement$ O $NamedNodeMap$ O $Attr$ O O O O $any$ O $any$ O O O O O $NSDictionary<unknown>$ O $complex$ O $HTMLElement$ O O O O O $any$ O $any$ O O O O O $NSDictionary<unknown>$ O $complex$ O $Attr$ O O O O O O O O
import "s" ; import test from "s" ; import Utility from "s" ; test ( "s" , t => { t . truthy ( Utility . isCamelCase ( "s" ) ) ; t . truthy ( Utility . isCamelCase ( "s" ) ) ; t . truthy ( ! Utility . isCamelCase ( "s" ) ) ; t . truthy ( ! Utility . isCamelCase ( "s" ) ) ; t . truthy ( ! Utility . isCamelCase ( "s" ) ) ; } ) ; test ( "s" , t => { t . truthy ( Utility . isSnakeCase ( "s" ) ) ; t . truthy ( Utility . isSnakeCase ( "s" ) ) ; t . truthy ( Utility . isSnakeCase ( "s" ) ) ; t . truthy ( ! Utility . isSnakeCase ( "s" ) ) ; t . truthy ( ! Utility . isSnakeCase ( "s" ) ) ; t . truthy ( ! Utility . isSnakeCase ( "s" ) ) ; } ) ;	O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O O O O
import "s" ; import test from "s" ; import xmldom from "s" ; import XMLReader from "s" ; import fs from "s" ; const xml = fs . readFile ( "s" ) ; test ( "s" , t => { const parsedDocument = XMLReader . parseXML ( xml , "s" ) ; t . truthy ( parsedDocument [ 0 ] . localName === "s" ) ; t . throws ( ( ) => { XMLReader . parseXML ( "s" , "s" ) ; } ) ; } ) ;	O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O $any$ O $string$ O O O O $any$ O O O $any$ O O O $Element[]$ O $any$ O $Element[]$ O $string$ O O O O $any$ O $any$ O $Element[]$ O O O O $string$ O O O O $any$ O $any$ O O O O O $any$ O $Element[]$ O O O O O O O O O O O O
import test from "s" ; import StringConverter from "s" ; test ( "s" , t => { t . truthy ( StringConverter ( "s" ) === "s" ) ; } ) ;	O $any$ O O O O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O
import GrimoireInterface from "s" ; import sinon from "s" ; export function 0 ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : null } , hoge : { converter : "s" , default : "s" } } , $onTest : function ( arg ) { spy ( "s" , arg ) ; } , $mount : function ( arg ) { spy ( "s" , arg ) ; } , $unmount : function ( arg ) { spy ( "s" , arg ) ; } , $awake : function ( arg ) { spy ( "s" , arg ) ; } } ) ; return spy ; } export function 0 ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } , $onTest : function ( arg ) { spy ( "s" , arg ) ; } , $mount : function ( arg ) { spy ( "s" , arg ) ; } , $unmount : function ( arg ) { spy ( "s" , arg ) ; } , $awake : function ( arg ) { spy ( "s" , arg ) ; } } ) ; return spy ; } export function 0 ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } , hogehoge : { converter : "s" , default : "s" } , hoge : { converter : "s" , default : "s" } } , $onTest : function ( arg ) { spy ( "s" , arg ) ; } , $mount : function ( arg ) { spy ( "s" , arg ) ; } , $unmount : function ( arg ) { spy ( "s" , arg ) ; } , $awake : function ( arg ) { spy ( "s" , arg ) ; } } ) ; return spy ; } export function testComponentBase ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { inheritAttr : { converter : "s" , default : "s" } } , $onTest : function ( arg ) { spy ( "s" , arg ) ; } , $mount : function ( arg ) { spy ( "s" , arg ) ; } , $unmount : function ( arg ) { spy ( "s" , arg ) ; } , $awake : function ( arg ) { spy ( "s" , arg ) ; } } ) ; return spy ; } export function testComponentOptional ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { value : { converter : "s" , default : "s" } } , $onTest : function ( arg ) { spy ( "s" , arg ) ; } , $mount : function ( arg ) { spy ( "s" , arg ) ; } , $unmount : function ( arg ) { spy ( "s" , arg ) ; } , $awake : function ( arg ) { spy ( "s" , arg ) ; } } ) ; return spy ; } export function 0 ( ) { const spy = sinon . spy ( ) ; const ns = GrimoireInterface . ns ( "s" ) ; GrimoireInterface . registerComponent ( ns ( "s" ) , { attributes : { value : { converter : "s" , default : "s" } } , $onTest : function ( ) { spy ( this . attributes . get ( "s" ) . Value ) ; } } ) ; return spy ; } export function 0 ( ) { const spy = sinon . spy ( ) ; const ns = GrimoireInterface . ns ( "s" ) ; GrimoireInterface . registerComponent ( ns ( "s" ) , { attributes : { value : { converter : "s" , default : "s" } } , $onTest : function ( ) { spy ( this . attributes . get ( "s" ) . Value ) ; } } ) ; return spy ; } export function goml ( ) { GrimoireInterface . registerNode ( "s" ) ; } export function 0 ( ) { GrimoireInterface . registerNode ( "s" , [ "s" ] ) ; } export function 0 ( ) { GrimoireInterface . registerNode ( "s" , [ "s" ] , null , "s" ) ; } export function 0 ( ) { GrimoireInterface . registerNode ( "s" , [ "s" ] , { hoge : "s" } ) ; } export function testNodeBase ( ) { GrimoireInterface . registerNode ( "s" , [ "s" ] ) ; } export function 0 ( ) { const ns = GrimoireInterface . ns ( "s" ) ; GrimoireInterface . registerNode ( ns ( "s" ) , [ "s" ] , { 0 : "s" } , null , null ) ; } export function 0 ( ) { const ns = GrimoireInterface . ns ( "s" ) ; GrimoireInterface . registerNode ( ns ( "s" ) , [ "s" ] , { 0 : "s" } , null , null ) ; } export function stringConverter ( ) { const spy = sinon . spy ( ) ; GrimoireInterface . registerConverter ( "s" , ( arg ) => { spy ( arg ) ; if ( typeof arg === "s" || ! arg ) { return arg ; } throw new Error ( "s" + arg ) ; } ) ; return spy ; }	O $GrimoireInterface$ O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $null$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O $void$ O O O $any$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $NSIdentity$ O $GrimoireInterface$ O $NSIdentity$ O O O O $GrimoireInterface$ O O O $NSIdentity$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $NSIdentity$ O $GrimoireInterface$ O $NSIdentity$ O O O O $GrimoireInterface$ O O O $NSIdentity$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O $void$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O O O O O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O $string$ O O O O O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O O O O $void$ O O O O $NSIdentity$ O $GrimoireInterface$ O $NSIdentity$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O $NSIdentity$ O O O O O O O O O $string$ O O O O O O O O O O O O $void$ O O O O $NSIdentity$ O $GrimoireInterface$ O $NSIdentity$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O $NSIdentity$ O O O O O O O O O $string$ O O O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $GrimoireInterface$ O $complex$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O O O O $ErrorConstructor$ O O O $any$ O O O O O O $any$ O O
import "s" ; import "s" ; import test from "s" ; import sinon from "s" ; import xmldom from "s" ; import xhrmock from "s" ; import * as _ from "s" ; import { goml , stringConverter , 0 , 0 , 0 , testComponentBase , testComponentOptional , 0 , 0 , 0 , testNodeBase , 0 , 0 , 0 , 0 } from "s" ; import GomlLoader from "s" ; import GrimoireInterface from "s" ; import fs from "s" ; const 0 = fs . readFile ( "s" ) ; const 0 = fs . readFile ( "s" ) ; xhrmock . setup ( ) ; xhrmock . get ( "s" , ( req , res ) => { return res . status ( 0 ) . body ( 0 ) ; } ) ; let stringConverterSpy , 0 , 0 , 0 , testComponentBaseSpy , testComponentOptionalSpy , 0 , 0 ; function resetSpies ( ) { stringConverterSpy . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; testComponentBaseSpy . reset ( ) ; testComponentOptionalSpy . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; } declare namespace global { let document ; let Node ; } test . beforeEach ( async ( ) => { GrimoireInterface . clear ( ) ; const parser = new DOMParser ( ) ; const htmlDoc = parser . parseFromString ( 0 , "s" ) ; global . document = htmlDoc ; global . document . querySelectorAll = function ( selector ) { return global . document . getElementsByTagName ( "s" ) ; } ; global . Node = { ELEMENT_NODE : 0 } ; goml ( ) ; 0 ( ) ; 0 ( ) ; 0 ( ) ; testNodeBase ( ) ; 0 ( ) ; 0 ( ) ; stringConverterSpy = stringConverter ( ) ; 0 = 0 ( ) ; 0 = 0 ( ) ; 0 = 0 ( ) ; testComponentBaseSpy = testComponentBase ( ) ; testComponentOptionalSpy = testComponentOptional ( ) ; 0 = 0 ( ) ; 0 = 0 ( ) ; await GrimoireInterface . resolvePlugins ( ) ; await GomlLoader . loadForPage ( ) ; global [ "s" ] = _ . values ( GrimoireInterface . rootNodes ) [ 0 ] ; global [ "s" ] . element . ownerDocument = global [ "s" ] ; } ) ; test ( "s" , ( t ) => { const ni = GrimoireInterface ( "s" ) ( "s" ) ; t . truthy ( true ) ; } ) ;	O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $any$ O $any$ O O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $string$ O $any$ O $string$ O O O O O $string$ O $any$ O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O O $GrimoireInterface$ O $void$ O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O $any$ O $any$ O $Document$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $number$ O O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $GrimoireInterface$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O O O $any$ O O O O $any$ O $any$ O $GrimoireInterface$ O $complex$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O $NodeInterface$ O $GrimoireInterface$ O O O O O O O $any$ O $any$ O O O O O O O
import "s" ; import "s" ; import prequire from "s" ; import jsdomAsync from "s" ; import test from "s" ; import sinon from "s" ; import xhrmock from "s" ; import XMLReader from "s" ; import GrimoireInterface from "s" ; import GomlParser from "s" ; import fs from "s" ; import { goml , stringConverter , 0 , 0 , 0 , testComponentBase , testComponentOptional , 0 , 0 , 0 , testNodeBase , 0 , 0 , 0 , 0 } from "s" ; declare namespace global { let Node ; let document ; } const 0 = fs . readFile ( "s" ) ; const 0 = fs . readFile ( "s" ) ; const 0 = fs . readFile ( "s" ) ; const 0 = fs . readFile ( "s" ) ; xhrmock . setup ( ) ; xhrmock . get ( "s" , ( req , res ) => { return res . status ( 0 ) . body ( "s" ) ; } ) ; xhrmock . get ( "s" , ( req , res ) => { return res . status ( 0 ) . body ( "s" ) ; } ) ; xhrmock . get ( "s" , ( req , res ) => { return res . status ( 0 ) . body ( "s" ) ; } ) ; function mockXMLParse ( func ) { return prequire ( "s" , { "s" : { default : { parseXML : ( srcHtml ) => { func ( srcHtml ) ; return XMLReader . parseXML ( srcHtml ) ; } } } } ) . default ; } test . beforeEach ( async ( ) => { GrimoireInterface . clear ( ) ; global . Node = { ELEMENT_NODE : 0 } ; goml ( ) ; 0 ( ) ; 0 ( ) ; 0 ( ) ; 0 ( ) ; testNodeBase ( ) ; testComponentBase ( ) ; await GrimoireInterface . resolvePlugins ( ) ; } ) ; test ( "s" , async ( t ) => { const window = await jsdomAsync ( 0 , [ ] ) ; global . document = window . document ; const scriptTags = window . document . querySelectorAll ( "s" ) ; const spy = sinon . spy ( ) ; const mockedParseXML = mockXMLParse ( xml => { spy ( xml . replace ( "s" , "s" ) ) ; } ) ; await mockedParseXML . loadFromScriptTag ( scriptTags . item ( 0 ) ) ; t . truthy ( spy . calledWith ( `template` ) ) ; } ) ; test ( "s" , async ( t ) => { const src = 0 ; const window = await jsdomAsync ( src , [ ] ) ; global . document = window . document ; const scriptTags = window . document . querySelectorAll ( "s" ) ; const spy = sinon . spy ( ) ; const mockedParseXML = mockXMLParse ( xml => { spy ( xml . replace ( "s" , "s" ) ) ; } ) ; await mockedParseXML . loadFromScriptTag ( scriptTags . item ( 0 ) ) ; t . truthy ( spy . calledWith ( `template` ) ) ; } ) ; test ( "s" , async ( t ) => { const src = 0 ; const window = await jsdomAsync ( src , [ ] ) ; global . document = window . document ; const scriptTags = window . document . querySelectorAll ( "s" ) ; const spy = sinon . spy ( ) ; const mockedParseXML = mockXMLParse ( xml => { spy ( xml . replace ( "s" , "s" ) ) ; } ) ; await mockedParseXML . loadFromScriptTag ( scriptTags . item ( 0 ) ) ; t . truthy ( spy . calledWith ( `template` ) ) ; } ) ; test ( "s" , async ( t ) => { const src = 0 ; const window = await jsdomAsync ( src , [ ] ) ; global . document = window . document ; const spy = sinon . spy ( ) ; const mockedParseXML = mockXMLParse ( xml => { spy ( xml . trim ( ) ) ; } ) ; await mockedParseXML . loadFromQuery ( "s" ) ; t . truthy ( spy . calledWith ( "s" ) ) ; } ) ; test ( "s" , async ( t ) => { const src = 0 ; const window = await jsdomAsync ( src , [ ] ) ; global . document = window . document ; const spy = sinon . spy ( ) ; const mockedParseXML = mockXMLParse ( xml => { spy ( xml . trim ( ) ) ; } ) ; await mockedParseXML . loadForPage ( ) ; t . truthy ( spy . calledWith ( "s" ) ) ; } ) ;	O O O O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O O O $string$ O $any$ O $string$ O O O O O $string$ O $any$ O $string$ O O O O O $string$ O $any$ O $string$ O O O O O $string$ O $any$ O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $complex$ O O $Element[]$ O O $any$ O O O $any$ O $any$ O O O $any$ O $Element[]$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O O $GrimoireInterface$ O $void$ O O O $any$ O $any$ O O $number$ O O O O $void$ O O O $void$ O O O $void$ O O O $any$ O O O $any$ O O O $void$ O O O $any$ O O O O $GrimoireInterface$ O $Promise<void>$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O $Promise<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $string$ O $string$ O O $any$ O O $Promise<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $string$ O $string$ O O $any$ O O $Promise<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $string$ O $string$ O O $any$ O O $Promise<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O O O O $string$ O $string$ O O $any$ O O $Promise<any>$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O
import GrimoireInterface from "s" ; import GomlLoader from "s" ; import xhrmock from "s" ; import { goml , stringConverter , 0 , 0 , 0 , testComponentBase , testComponentOptional , 0 , 0 , 0 , testNodeBase , 0 , 0 , 0 , 0 } from "s" ; declare namespace global { let Node ; let document ; } export default class PageLoadingHelper { public static async reset ( gr : typeof GrimoireInterface , html ) < any > { gr . clear ( ) ; const parser = new DOMParser ( ) ; const htmlDoc = parser . parseFromString ( html , "s" ) ; global . document = htmlDoc ; global . document . querySelectorAll = function ( ) { return global . document . getElementsByTagName ( "s" ) ; } ; global . Node = { ELEMENT_NODE : 0 } ; goml ( ) ; 0 ( ) ; 0 ( ) ; 0 ( ) ; testNodeBase ( ) ; 0 ( ) ; 0 ( ) ; const spys = { } ; spys . stringConverterSpy = stringConverter ( ) ; spys . 0 = 0 ( ) ; spys . 0 = 0 ( ) ; spys . 0 = 0 ( ) ; spys . testComponentBaseSpy = testComponentBase ( ) ; spys . testComponentOptionalSpy = testComponentOptional ( ) ; spys . 0 = 0 ( ) ; spys . 0 = 0 ( ) ; await gr . resolvePlugins ( ) ; await GomlLoader . loadForPage ( ) ; return spys ; } public static mockSetup ( ) { xhrmock . setup ( ) ; } public static mock ( path , content ) { xhrmock . get ( path , ( req , res ) => { let aa = res . status ( 0 ) . body ( content ) ; return aa ; } ) ; } }	O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $Promise$ O $GrimoireInterface$ O O $GrimoireInterface$ O $string$ O O O O O $GrimoireInterface$ O $void$ O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O $string$ O O O O $any$ O $any$ O $Document$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $number$ O O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $GrimoireInterface$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O O O O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O $void$ O $string$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O $any$ O O O O O O
import "s" ; import "s" ; import test from "s" ; import sinon from "s" ; import xmldom from "s" ; import * as _ from "s" ; import { goml , stringConverter , 0 , 0 , 0 , testComponentBase , testComponentOptional , 0 , 0 , 0 , testNodeBase , 0 , 0 , 0 , 0 } from "s" ; import GomlLoader from "s" ; import GomlNode from "s" ; import Component from "s" ; import Attribute from "s" ; import NSIdentity from "s" ; import GrimoireComponent from "s" ; import GrimoireInterface from "s" ; import fs from "s" ; import PLH from "s" ; const 0 = fs . readFile ( "s" ) ; const 0 = fs . readFile ( "s" ) ; PLH . mockSetup ( ) ; PLH . mock ( "s" , 0 ) ; let stringConverterSpy , 0 , 0 , 0 , testComponentBaseSpy , testComponentOptionalSpy , 0 , 0 ; function resetSpies ( ) { stringConverterSpy . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; testComponentBaseSpy . reset ( ) ; testComponentOptionalSpy . reset ( ) ; 0 . reset ( ) ; 0 . reset ( ) ; } let rootNode ; test . beforeEach ( async ( ) => { let spys = await PLH . reset ( GrimoireInterface , 0 ) ; stringConverterSpy = spys . stringConverterSpy ; 0 = spys . 0 ; 0 = spys . 0 ; testComponentBaseSpy = spys . 0 ; 0 = spys . 0 ; testComponentBaseSpy = spys . testComponentBaseSpy ; testComponentOptionalSpy = spys . testComponentOptionalSpy ; 0 = spys . 0 ; 0 = spys . 0 ; rootNode = _ . values ( GrimoireInterface . rootNodes ) [ 0 ] ; } ) ; test ( "s" , ( t ) => { t . truthy ( _ . isNull ( rootNode . parent ) ) ; } ) ; test ( "s" , ( t ) => { const companion = rootNode . companion ; t . truthy ( companion ) ; rootNode . callRecursively ( ( n ) => { t . truthy ( companion === n . companion ) ; } ) ; } ) ; test ( "s" , ( t ) => { const tree = rootNode . tree ; t . truthy ( tree ) ; rootNode . callRecursively ( ( n ) => { t . truthy ( tree === n . tree ) ; } ) ; } ) ; test ( "s" , t => { const 0 = rootNode . children [ 0 ] ; const a = 0 . getAttribute ( "s" ) ; t . truthy ( a === "s" ) ; const b = 0 . getAttribute ( "s" ) ; t . truthy ( b === "s" ) ; t . truthy ( 0 . getAttribute ( "s" ) === "s" ) ; t . truthy ( 0 . getAttribute ( "s" ) === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . enabled = true ; const order = [ 0 , 0 , testComponentOptionalSpy , 0 ] ; sinon . assert . callOrder ( 0 , 0 , testComponentOptionalSpy , 0 ) ; order . forEach ( v => { t . truthy ( v . getCall ( 0 ) . args [ 0 ] === "s" ) ; } ) ; } ) ; test ( "s" , ( t ) => { const order = [ 0 , 0 , testComponentOptionalSpy , 0 ] ; order . forEach ( v => { t . truthy ( v . getCall ( 0 ) . args [ 0 ] === "s" ) ; t . truthy ( v . getCall ( 0 ) . args [ 0 ] === "s" ) ; } ) ; } ) ; test ( "s" , ( t ) => { t . truthy ( rootNode . mounted ) ; rootNode . callRecursively ( ( n ) => { t . truthy ( n . mounted ) ; } ) ; } ) ; test ( "s" , ( t ) => { t . truthy ( rootNode . getAttribute ( "s" ) !== void 0 ) ; t . truthy ( rootNode . getAttribute ( "s" ) === null ) ; } ) ; test ( "s" , ( t ) => { const idAttr = rootNode . getAttributeRaw ( "s" ) ; const spy = sinon . spy ( ) ; const watcher = ( newValue , oldValue , attr ) => { spy ( newValue ) ; } ; idAttr . watch ( watcher ) ; idAttr . Value = "s" ; t . truthy ( spy . getCall ( 0 ) . args [ 0 ] === "s" ) ; spy . reset ( ) ; rootNode . enabled = false ; idAttr . Value = "s" ; sinon . assert . notCalled ( spy ) ; } ) ; test ( "s" , ( t ) => { const idAttr = rootNode . getAttributeRaw ( "s" ) ; const spy = sinon . spy ( ) ; const watcher = ( newValue , oldValue , attr ) => { spy ( newValue ) ; } ; idAttr . watch ( watcher ) ; idAttr . unwatch ( watcher ) ; idAttr . Value = "s" ; sinon . assert . notCalled ( spy ) ; idAttr . watch ( watcher , false , true ) ; rootNode . enabled = false ; idAttr . Value = "s" ; t . truthy ( spy . getCall ( 0 ) . args [ 0 ] === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; const 0 = 0 . children [ 0 ] ; t . truthy ( rootNode . enabled ) ; t . truthy ( rootNode . isActive ) ; t . truthy ( ! 0 . enabled ) ; t . truthy ( ! 0 . isActive ) ; t . truthy ( 0 . enabled ) ; t . truthy ( ! 0 . isActive ) ; 0 . enabled = true ; t . truthy ( 0 . enabled ) ; t . truthy ( 0 . isActive ) ; t . truthy ( 0 . enabled ) ; t . truthy ( 0 . isActive ) ; 0 . enabled = false ; t . truthy ( ! 0 . enabled ) ; t . truthy ( ! 0 . isActive ) ; rootNode . enabled = false ; t . truthy ( ! rootNode . enabled ) ; t . truthy ( ! rootNode . isActive ) ; t . truthy ( 0 . enabled ) ; t . truthy ( ! 0 . isActive ) ; t . truthy ( ! 0 . enabled ) ; t . truthy ( ! 0 . isActive ) ; } ) ; test ( "s" , ( t ) => { sinon . assert . callOrder ( 0 , 0 , testComponentOptionalSpy , 0 ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; resetSpies ( ) ; 0 . enabled = true ; rootNode . broadcastMessage ( 0 , "s" ) ; sinon . assert . called ( 0 ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; sinon . assert . notCalled ( 0 ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; const 0 = 0 . children [ 0 ] ; resetSpies ( ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; sinon . assert . notCalled ( 0 ) ; resetSpies ( ) ; rootNode . broadcastMessage ( "s" ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; sinon . assert . notCalled ( 0 ) ; resetSpies ( ) ; 0 . enabled = true ; 0 . enabled = false ; rootNode . broadcastMessage ( "s" ) ; sinon . assert . called ( 0 ) ; sinon . assert . notCalled ( 0 ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; sinon . assert . called ( 0 ) ; resetSpies ( ) ; 0 . enabled = true ; rootNode . broadcastMessage ( "s" ) ; sinon . assert . called ( 0 ) ; sinon . assert . called ( 0 ) ; sinon . assert . called ( testComponentOptionalSpy ) ; sinon . assert . called ( 0 ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] . children [ 0 ] ; 0 . sendMessage ( "s" ) ; sinon . assert . callOrder ( 0 , testComponentOptionalSpy ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . enabled = true ; resetSpies ( ) ; 0 . detach ( ) ; const called = [ 0 , testComponentOptionalSpy , 0 , 0 ] ; sinon . assert . callOrder . apply ( sinon . assert , called ) ; called . forEach ( ( v ) => { t . truthy ( v . getCall ( 0 ) . args [ 0 ] === "s" ) ; } ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . enabled = true ; resetSpies ( ) ; 0 . remove ( ) ; const called = [ 0 , testComponentOptionalSpy , 0 , 0 ] ; sinon . assert . callOrder . apply ( sinon . assert , called ) ; called . forEach ( ( v ) => { t . truthy ( v . getCall ( 0 ) . args [ 0 ] === "s" ) ; } ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] . children [ 0 ] ; t . truthy ( ! 0 . getComponent ( "s" ) ) ; t . truthy ( 0 . getComponent ( "s" ) ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . enabled = true ; resetSpies ( ) ; const optionalComponent = rootNode . children [ 0 ] . children [ 0 ] . getComponent < Component > ( "s" ) ; optionalComponent . enabled = false ; rootNode . broadcastMessage ( "s" ) ; const called = [ 0 , 0 , 0 ] ; sinon . assert . callOrder . apply ( sinon . assert , called ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . enabled = true ; resetSpies ( ) ; const 0 = rootNode . children [ 0 ] . children [ 0 ] ; 0 . enabled = false ; rootNode . broadcastMessage ( "s" ) ; const called = [ 0 , 0 ] ; sinon . assert . callOrder . apply ( sinon . assert , called ) ; sinon . assert . notCalled ( testComponentOptionalSpy ) ; sinon . assert . notCalled ( 0 ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; let classes = 0 . getAttribute ( "s" ) ; t . truthy ( classes . length === 0 ) ; t . truthy ( classes [ 0 ] === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; t . truthy ( 0 . getAttribute ( "s" ) === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; t . truthy ( 0 . getAttribute ( "s" ) === false ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; const id = 0 . getAttribute ( "s" ) ; 0 . setAttribute ( "s" , "s" ) ; t . truthy ( 0 . element . id === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . setAttribute ( "s" , "s" ) ; t . truthy ( 0 . element . className === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] ; 0 . addComponent ( "s" ) ; t . truthy ( 0 . getComponent ( "s" ) ) ; } ) ; test ( "s" , t => { t . throws ( ( ) => { rootNode . getAttribute ( "s" ) ; } ) ; rootNode . setAttribute ( "s" , "s" ) ; const att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; const att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; const att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; const att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; let att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; att = rootNode . getAttribute ( NSIdentity . fromFQN ( c . name . fqn + "s" ) ) ; t . truthy ( att === "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; att = rootNode . getAttribute ( NSIdentity . fromFQN ( c . name . fqn + "s" ) ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; const att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; let att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; t . throws ( ( ) => { rootNode . getAttribute ( "s" ) ; } ) ; att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; att = rootNode . getAttribute ( NSIdentity . fromFQN ( c . name . fqn + "s" ) ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , t => { const c = rootNode . getComponent < Component > ( "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; rootNode . setAttribute ( "s" , "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; let att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; t . throws ( ( ) => { rootNode . getAttribute ( "s" ) ; } ) ; att = rootNode . getAttribute ( "s" ) ; t . truthy ( att === "s" ) ; ( c as any ) . __addAttribute ( "s" , { converter : "s" , default : "s" } ) ; att = rootNode . getAttribute ( NSIdentity . fromFQN ( c . name . fqn + "s" ) ) ; t . truthy ( att === "s" ) ; } ) ; test ( "s" , ( t ) => { const 0 = rootNode . children [ 0 ] . children [ 0 ] ; 0 . addChildByName ( "s" , { 0 : "s" , id : "s" } ) ; const child = 0 . children [ 0 ] ; t . truthy ( child . name . name === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === "s" ) ; t . truthy ( child . element . id === "s" ) ; t . truthy ( child . getComponent ( GrimoireComponent ) . getAttribute ( "s" ) === "s" ) ; } ) ; test ( "s" , async ( t ) => { const 0 = rootNode . children [ 0 ] . children [ 0 ] ; 0 . addChildByName ( "s" , { 0 : "s" , id : null , class : null } ) ; const child = 0 . children [ 0 ] ; t . truthy ( child . name . name === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === null ) ; t . truthy ( child . element . id === "s" ) ; t . truthy ( child . getComponent ( GrimoireComponent ) . getAttribute ( "s" ) === null ) ; t . truthy ( child . getAttribute ( "s" ) === null ) ; t . truthy ( child . element . className === "s" ) ; t . truthy ( child . getComponent ( GrimoireComponent ) . getAttribute ( "s" ) === null ) ; } ) ; test ( "s" , async ( t ) => { const 0 = rootNode . children [ 0 ] . children [ 0 ] ; 0 . addChildByName ( "s" , { 0 : "s" , id : null , class : null } ) ; const child = 0 . children [ 0 ] ; t . truthy ( child . name . name === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === "s" ) ; t . truthy ( child . getAttribute ( "s" ) === null ) ; t . truthy ( child . element . id === "s" ) ; t . truthy ( child . getComponent ( GrimoireComponent ) . getAttribute ( "s" ) === null ) ; t . truthy ( child . getAttribute ( "s" ) === null ) ; t . truthy ( child . element . className === "s" ) ; t . truthy ( child . getComponent ( GrimoireComponent ) . getAttribute ( "s" ) === null ) ; } ) ; test ( "s" , t => { const gi = GrimoireInterface ( "s" ) ; t . truthy ( gi . rootNodes . length === 0 ) ; } ) ;	O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $string$ O $any$ O $string$ O O O O O $string$ O $any$ O $string$ O O O O $any$ O $void$ O O O $any$ O $void$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $Promise<any>$ O $GrimoireInterface$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $GomlNode$ O $any$ O $any$ O $GrimoireInterface$ O $complex$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $GomlNode$ O $GomlNode$ O O O O O O $any$ O O O O $any$ O O O O $NSDictionary<any>$ O $GomlNode$ O $NSDictionary<any>$ O $any$ O $any$ O $NSDictionary<any>$ O O $GomlNode$ O $T[]$ O O $GomlNode$ O O O $any$ O $any$ O $NSDictionary<any>$ O $GomlNode$ O $NSDictionary<any>$ O O O O O O O O $any$ O O O O $any$ O O O O $GomlInterface$ O $GomlNode$ O $GomlInterface$ O $any$ O $any$ O $GomlInterface$ O O $GomlNode$ O $T[]$ O O $GomlNode$ O O O $any$ O $any$ O $GomlInterface$ O $GomlNode$ O $GomlInterface$ O O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $GomlNode$ O $T[]$ O O $GomlNode$ O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $Attribute$ O $GomlNode$ O $Attribute$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $Attribute$ O $void$ O $void$ O O $Attribute$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O $GomlNode$ O $boolean$ O O O $Attribute$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $Attribute$ O $GomlNode$ O $Attribute$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $Attribute$ O $void$ O $void$ O O $Attribute$ O $void$ O $void$ O O $Attribute$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $Attribute$ O $void$ O $void$ O O O O O O $GomlNode$ O $boolean$ O O O $Attribute$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $GomlNode$ O $boolean$ O O O $any$ O $any$ O $GomlNode$ O $true$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O $GomlNode$ O $boolean$ O O O $any$ O $any$ O O $GomlNode$ O $false$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $GomlNode$ O $boolean$ O O O $any$ O $any$ O O $GomlNode$ O $false$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $any$ O $any$ O $GomlNode$ O $true$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O $any$ O $any$ O O $GomlNode$ O $false$ O O $any$ O $any$ O O $GomlNode$ O $boolean$ O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $void$ O O O $GomlNode$ O $boolean$ O O O $GomlNode$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $void$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $void$ O O O $GomlNode$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $void$ O O O $GomlNode$ O $boolean$ O O O $GomlNode$ O $boolean$ O O O $GomlNode$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $void$ O O O $GomlNode$ O $boolean$ O O O $GomlNode$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O $void$ O O O $GomlNode$ O $void$ O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any[]$ O $void$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O $void$ O O O $GomlNode$ O $void$ O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any[]$ O $void$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $any$ O $any$ O O $GomlNode$ O $T$ O O O O O $any$ O $any$ O $GomlNode$ O $T$ O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O $void$ O O O O $Component$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $T$ O $any$ O O O O O $Component$ O $boolean$ O O O $GomlNode$ O $complex$ O O O O O $any[]$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O $void$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $GomlNode$ O $boolean$ O O O $GomlNode$ O $complex$ O O O O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O O $any$ O $GomlNode$ O $any$ O O O O $GomlNode$ O $void$ O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $void$ O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $Component$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O O O O O O O $GomlNode$ O $void$ O O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O $GomlNode$ O $void$ O O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $GomlNode$ O $any$ O $any$ O $complex$ O $Component$ O $NSIdentity$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O $GomlNode$ O $void$ O O O O O O $GomlNode$ O $void$ O O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $GomlNode$ O $any$ O $any$ O $complex$ O $Component$ O $NSIdentity$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O $GomlNode$ O $void$ O O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $GomlNode$ O $any$ O $any$ O $complex$ O $Component$ O $NSIdentity$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $Component$ O $GomlNode$ O $T$ O $any$ O O O O O $GomlNode$ O $void$ O O O O O O $GomlNode$ O $void$ O O O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O O O O O O O $any$ O $GomlNode$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Component$ O O O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $GomlNode$ O $any$ O $any$ O $complex$ O $Component$ O $NSIdentity$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $GomlNode$ O $GomlNode$ O O O O $string$ O O O $string$ O O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $GomlNode$ O $GomlNode$ O O O O $string$ O O O $null$ O O O $null$ O O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O $any$ O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $GomlNode$ O $GomlNode$ O O O O $string$ O O O $null$ O O O $null$ O O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $Element$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O $any$ O O O $GomlInterface$ O $GrimoireInterface$ O O O O $any$ O $any$ O $GomlInterface$ O $GomlNode[]$ O $number$ O O O O O O O
import "s" ; import "s" ; import xmldom from "s" ; import test from "s" ; import sinon from "s" ; import GrimoireInterface from "s" ; import Constants from "s" ; import Component from "s" ; import GomlParser from "s" ; import GomlLoader from "s" ; import NSIdentity from "s" ; import GomlNode from "s" ; import Attribute from "s" ; declare namespace global { let Node ; let document ; let rootNode ; } global . Node = { ELEMENT_NODE : 0 } ; test . beforeEach ( async ( ) => { GrimoireInterface . clear ( ) ; const parser = new DOMParser ( ) ; const htmlDoc = parser . parseFromString ( "s" , "s" ) ; global . document = htmlDoc ; GrimoireInterface . registerNode ( "s" ) ; GrimoireInterface . registerNode ( "s" ) ; GrimoireInterface . registerNode ( "s" ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { } , valueTest : "s" } ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { } , valueTest : "s" } ) ; await GrimoireInterface . resolvePlugins ( ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; t . truthy ( node . getComponents ( "s" ) . length === 0 ) ; t . truthy ( node . getComponents ( "s" ) . length === 0 ) ; const a = node . getComponent ( "s" ) as any ; t . truthy ( a . valueTest === "s" ) ; const b = node . getComponent ( "s" ) as any ; t . truthy ( b . valueTest === "s" ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; const a = node . getComponent ( "s" ) as any ; node . removeComponent ( a ) ; t . truthy ( node . getComponent ( "s" ) ) ; t . truthy ( node . getComponents ( "s" ) . length === 0 ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; t . truthy ( node . getComponents ( "s" ) . length === 0 ) ; node . removeComponents ( "s" ) ; t . truthy ( node . getComponents ( "s" ) . length === 0 ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; node . addChild ( 0 , null , null ) ; t . truthy ( node . children [ 0 ] . id === 0 . id ) ; t . truthy ( node . children . length === 0 ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; 0 . addChild ( 0 , null , null ) ; 0 . remove ( ) ; t . truthy ( node . children . length === 0 ) ; t . truthy ( 0 . parent === null ) ; t . truthy ( 0 . deleted === true ) ; t . truthy ( 0 . deleted === true ) ; t . truthy ( 0 . parent === null ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; 0 . addChild ( 0 , null , null ) ; node . removeChild ( 0 ) ; t . truthy ( 0 . deleted === true ) ; t . truthy ( 0 . deleted === true ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; 0 . addChild ( 0 , null , null ) ; node . detachChild ( 0 ) ; t . truthy ( node . children . length === 0 ) ; t . truthy ( 0 . deleted === false ) ; t . truthy ( 0 . parent . id === 0 . id ) ; t . truthy ( 0 . deleted === false ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; 0 . addChild ( 0 , null , null ) ; 0 . detach ( ) ; try { node . detach ( ) ; } catch ( err ) { t . truthy ( err . message === "s" ) ; } t . truthy ( node . children . length === 0 ) ; t . truthy ( 0 . deleted === false ) ; t . truthy ( 0 . parent . id === 0 . id ) ; t . truthy ( 0 . deleted === false ) ; } ) ; test ( "s" , t => { GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; GrimoireInterface . registerNode ( "s" , [ "s" ] ) ; const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const components = node . getComponents ( ) ; t . truthy ( components . length === 0 ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; 0 . addChild ( 0 , null , null ) ; node . setMounted ( true ) ; t . truthy ( node . mounted === true ) ; t . truthy ( 0 . mounted === true ) ; t . truthy ( 0 . mounted === true ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 ) ; t . truthy ( 0 . index === 0 ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; const component = GrimoireInterface . componentDeclarations . get ( "s" ) . generateInstance ( ) ; node . _addComponentDirectly ( component , true ) ; const components = node . getComponents < Component > ( ) ; t . truthy ( components . length === 0 ) ; t . truthy ( components [ 0 ] . name . name === "s" ) ; t . truthy ( component . isDefaultComponent ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; const component = node . addComponent ( "s" , { 0 : "s" } ) ; const components = node . getComponents < Component > ( ) ; t . truthy ( components . length === 0 ) ; t . truthy ( components [ 0 ] . name . name === "s" ) ; t . truthy ( components [ 0 ] . getAttribute ( "s" ) === "s" ) ; t . truthy ( component . isDefaultComponent === false ) ; } ) ; test ( "s" , async t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } , "s" ) ; await GrimoireInterface . resolvePlugins ( ) ; node . addComponent ( "s" ) ; t . truthy ( node . getComponent < Component > ( "s" ) . name . name === "s" ) ; t . truthy ( node . getComponent < Component > ( "s" ) . name . name === "s" ) ; } ) ; test ( "s" , t => { const node = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; const 0 = new GomlNode ( GrimoireInterface . nodeDeclarations . get ( "s" ) , null ) ; node . addChild ( 0 , null , null ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; GrimoireInterface . registerComponent ( "s" , { attributes : { 0 : { converter : "s" , default : "s" } } } ) ; node . addComponent ( "s" ) ; node . addComponent ( "s" ) ; const components = node . getComponents ( ) ; t . truthy ( components . length === 0 ) ; } ) ;	O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O $number$ O O O O $any$ O $any$ O O O O O O $GrimoireInterface$ O $void$ O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O O O O O O $any$ O $any$ O $Document$ O $GrimoireInterface$ O $NodeDeclaration$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O $GrimoireInterface$ O O O O O O ${}$ O O O O $string$ O O O O O $GrimoireInterface$ O O O O O O ${}$ O O O O $string$ O O O O O O $GrimoireInterface$ O $Promise<void>$ O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O $any$ O $any$ O $GomlNode$ O $T[]$ O O O O $number$ O O O O $any$ O $any$ O $GomlNode$ O $T[]$ O O O O $number$ O O O O O $any$ O $GomlNode$ O $T$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $GomlNode$ O $T$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O O $any$ O $GomlNode$ O $T$ O O O O O O $GomlNode$ O $boolean$ O $any$ O O $any$ O $any$ O $GomlNode$ O $T$ O O O O O $any$ O $any$ O $GomlNode$ O $T[]$ O O O O $number$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O $any$ O $any$ O $GomlNode$ O $T[]$ O O O O $number$ O O O O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $T[]$ O O O O $number$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $string$ O $GomlNode$ O $string$ O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $GomlNode$ O $GomlNode$ O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O $string$ O $GomlNode$ O $string$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O O O O O $GomlNode$ O $void$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O $string$ O $GomlNode$ O $string$ O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O O O O $any$ O O O $any$ O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $unknown[]$ O $GomlNode$ O $T[]$ O O O $any$ O $any$ O $unknown[]$ O $number$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GomlNode$ O $void$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O $any$ O $any$ O $GomlNode$ O $boolean$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O $any$ O $any$ O $GomlNode$ O $number$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $Component$ O $GrimoireInterface$ O $NSDictionary<ComponentDeclaration>$ O $complex$ O O O O $Component$ O O O $GomlNode$ O $void$ O $Component$ O O O O O $Component[]$ O $GomlNode$ O $T[]$ O $any$ O O O O $any$ O $any$ O $Component[]$ O $number$ O O O O $any$ O $any$ O $Component[]$ O O O O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $Component$ O $boolean$ O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $Component$ O $GomlNode$ O $Component$ O O O O $string$ O O O O O O $Component[]$ O $GomlNode$ O $T[]$ O $any$ O O O O $any$ O $any$ O $Component[]$ O $number$ O O O O $any$ O $any$ O $Component[]$ O O O O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $Component[]$ O O O O $any$ O O O O O O O $any$ O $any$ O $Component$ O $boolean$ O O O O O O O $any$ O O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O O $GrimoireInterface$ O $Promise<void>$ O O O $GomlNode$ O $Component$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O O O O $NSIdentity$ O $string$ O O O O $any$ O $any$ O $GomlNode$ O $T$ O $any$ O O O O O $NSIdentity$ O $string$ O O O O O O O $any$ O O O $any$ O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O O $GomlNode$ O O $any$ O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $complex$ O O O O O O O $GomlNode$ O $void$ O $GomlNode$ O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $GrimoireInterface$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O $GomlNode$ O $Component$ O O O O $GomlNode$ O $Component$ O O O O O $unknown[]$ O $GomlNode$ O $T[]$ O O O $any$ O $any$ O $unknown[]$ O $number$ O O O O O O O
require ( "s" ) ; import "s" ; import test from "s" ; import sinon from "s" ; import GomlParser from "s" ; import xmldom from "s" ; import GrimoireInterface from "s" ; import NSIdentity from "s" ; import Namespace from "s" ; import fs from "s" ; import { goml , stringConverter , 0 , 0 , testComponentBase , testComponentOptional , 0 , 0 , testNodeBase , 0 , 0 , 0 , 0 } from "s" ; declare namespace global { let Node ; let document ; let rootNode ; } function obtainElementTag ( path ) { const DOMParser = xmldom . DOMParser ; global . Node = { ELEMENT_NODE : 0 } ; const parser = new DOMParser ( ) ; return parser . parseFromString ( fs . readFile ( path ) , "s" ) . documentElement ; } let stringConverterSpy , 0 , 0 , testComponentBaseSpy , testComponentOptionalSpy , 0 , 0 ; test . beforeEach ( async ( ) => { GrimoireInterface . clear ( ) ; const parser = new DOMParser ( ) ; const htmlDoc = parser . parseFromString ( "s" , "s" ) ; global . document = htmlDoc ; goml ( ) ; 0 ( ) ; 0 ( ) ; testNodeBase ( ) ; 0 ( ) ; 0 ( ) ; stringConverterSpy = stringConverter ( ) ; 0 = 0 ( ) ; 0 = 0 ( ) ; testComponentBaseSpy = testComponentBase ( ) ; testComponentOptionalSpy = testComponentOptional ( ) ; 0 = 0 ( ) ; 0 = 0 ( ) ; registerUserPlugin ( ) ; await GrimoireInterface . resolvePlugins ( ) ; } ) ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; function registerUserPlugin ( ) { GrimoireInterface . registerNode ( "s" ) ; GrimoireInterface . registerNode ( "s" ) ; } test ( "s" , t => { GrimoireInterface . nodeDeclarations . forEach ( nm => { t . truthy ( nm . resolvedDependency ) ; } ) ; } ) ; test ( "s" , async t => { await GrimoireInterface . resolvePlugins ( ) ; GrimoireInterface . nodeDeclarations . forEach ( nm => { t . truthy ( nm . resolvedDependency ) ; } ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; t . truthy ( node . parent === null ) ; t . truthy ( node . children . length === 0 ) ; const c = node . children [ 0 ] ; t . truthy ( c . parent === node ) ; t . truthy ( c . children . length === 0 ) ; t . truthy ( c . children [ 0 ] . children . length === 0 ) ; t . truthy ( c . children [ 0 ] . parent === c ) ; t . truthy ( c . children [ 0 ] . children . length === 0 ) ; t . truthy ( c . children [ 0 ] . parent === c ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; t . truthy ( node . parent === null ) ; sinon . assert . notCalled ( stringConverterSpy ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; node . setMounted ( true ) ; t . truthy ( node . children . length === 0 ) ; t . truthy ( node . children [ 0 ] . getAttribute ( "s" ) === "s" ) ; t . truthy ( node . children [ 0 ] . getAttribute ( "s" ) === "s" ) ; t . truthy ( node . children [ 0 ] . children . length === 0 ) ; t . truthy ( node . children [ 0 ] . children [ 0 ] . getAttribute ( "s" ) === "s" ) ; node . broadcastMessage ( "s" , "s" ) ; sinon . assert . neverCalledWith ( 0 , "s" ) ; sinon . assert . neverCalledWith ( 0 , "s" ) ; sinon . assert . neverCalledWith ( testComponentOptionalSpy , "s" ) ; t . truthy ( "s" === testComponentBaseSpy . args [ 0 ] [ 0 ] ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; node . setMounted ( true ) ; node . broadcastMessage ( "s" , "s" ) ; sinon . assert . calledWith ( 0 , "s" ) ; sinon . assert . calledWith ( 0 , "s" ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; const components = node . children [ 0 ] . getComponents < any > ( ) ; const 0 = NSIdentity . fromFQN ( "s" ) ; const 0 = NSIdentity . fromFQN ( "s" ) ; const 0 = components . find ( ( comp ) => 0 . fqn === comp . name . fqn ) ; const 0 = components . find ( ( comp ) => 0 . fqn === comp . name . fqn ) ; t . truthy ( 0 . companion === 0 . companion ) ; } ) ; test ( "s" , ( t ) => { const element = obtainElementTag ( 0 ) ; const node = GomlParser . parse ( element ) ; const original = node [ "s" ] ; node . callRecursively ( v => { t . truthy ( original === v [ "s" ] ) ; } ) ; } ) ;	$any$ O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $GrimoireInterface$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $GrimoireInterface$ O $void$ O O O O $DOMParser$ O O $complex$ O O O O $Document$ O $DOMParser$ O $Document$ O O O O O O $any$ O $any$ O $Document$ O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O O $GrimoireInterface$ O $Promise<void>$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O $GrimoireInterface$ O $NodeDeclaration$ O O O O O $any$ O O O $any$ O O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $NSDictionary<NodeDeclaration>$ O $NodeDeclaration$ O O $any$ O $any$ O $NodeDeclaration$ O $boolean$ O O O O O O O O $any$ O O O O $any$ O O O $GrimoireInterface$ O $Promise<void>$ O O O $GrimoireInterface$ O $NSDictionary<NodeDeclaration>$ O $NSDictionary<NodeDeclaration>$ O $NodeDeclaration$ O O $any$ O $any$ O $NodeDeclaration$ O $boolean$ O O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O O $GomlNode$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O $GomlNode$ O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $GomlNode$ O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode$ O $GomlNode$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O $any$ O $any$ O $GomlNode$ O $GomlNode$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O $GomlNode$ O $void$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $any$ O O O O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O $number$ O O O O $any$ O $any$ O $GomlNode$ O $GomlNode[]$ O O O O $GomlNode[]$ O O O O $any$ O O O O O O O $GomlNode$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O $GomlNode$ O $void$ O O O O $GomlNode$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O O $any[]$ O $GomlNode$ O $GomlNode[]$ O O O O $T[]$ O O O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $NSIdentity$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $NSIdentity$ O $string$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O $GomlNode$ O $any$ O $GomlNode$ O $any$ O O O $any$ O $GomlNode$ O O O O $GomlNode$ O $T[]$ O $GomlNode$ O O $any$ O $any$ O $any$ O $GomlNode$ O O O O O O O O O O O
import "s" ; import test from "s" ; import GomlParser from "s" ; import xmldom from "s" ; import NSSet from "s" ; import NSIdentity from "s" ; test ( "s" , ( t ) => { const name = NSIdentity . fromFQN ( "s" ) ; const set = new NSSet ( ) ; set . push ( name ) ; const array = set . toArray ( ) ; t . truthy ( array . length === 0 ) ; t . truthy ( array [ 0 ] . name === "s" ) ; } ) ;	O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O $NSIdentity$ O $any$ O $complex$ O O O O O $NSSet$ O O $any$ O O O $NSSet$ O $boolean$ O $NSIdentity$ O O O $NSIdentity[]$ O $NSSet$ O $NSIdentity[]$ O O O $any$ O $any$ O $NSIdentity[]$ O $number$ O O O O $any$ O $any$ O $NSIdentity[]$ O O O O $string$ O O O O O O O
'js' const path = require ( "s" ) ; const webpack = require ( "s" ) ; const fs = require ( "s" ) ; const fnPrefix = JSON . parse ( fs . readFileSync ( path . resolve ( __dirname , "s" ) , "s" ) ) . name . replace ( "s" , "s" ) ; class CopyPlugin { constructor ( copyFrom , copyTo ) { this . copyFrom = copyFrom ; this . copyTo = copyTo ; } apply ( compiler ) { compiler . plugin ( "s" , ( compiler , callback ) => { fs . createReadStream ( this . copyFrom ) . pipe ( fs . createWriteStream ( this . copyTo ) ) ; callback ( ) ; } ) ; } } class CauldronPlugin { apply ( compiler ) { compiler . plugin ( "s" , ( ) => { try { console . log ( require ( 's' ) . execSync ( 's' ) . toString ( ) ) ; } catch ( e ) { console . log ( e ) ; } } ) ; compiler . plugin ( 's' , ( compiler , callback ) => { try { console . log ( require ( 's' ) . execSync ( 's' ) . toString ( ) ) ; } catch ( e ) { console . log ( e ) ; } finally { callback ( ) ; } } ) ; } } const getBuildTask = ( fileName , plugins , needPolyfill ) => { return { cache : true , entry : needPolyfill ? [ 's' , path . resolve ( __dirname , "s" ) ] : path . resolve ( __dirname , "s" ) , output : { path : __dirname , filename : "s" + fileName , libraryTarget : "s" } , module : { loaders : [ { test : "s" , exclude : "s" , loader : "s" } ] } , resolve : { extensions : [ 's' , 's' ] } , plugins : plugins , devtool : 's' } } ; module . exports = ( env = { } ) => { let includeCore = true ; if ( ! env . browser && ! env . npm && ! env . prod ) { env . browser = true ; } const productPlugins = [ new webpack . optimize . UglifyJsPlugin ( { compress : { warnings : false } } ) , new webpack . optimize . OccurrenceOrderPlugin ( ) , new webpack . optimize . AggressiveMergingPlugin ( ) ] ; let buildTasks = [ ] ; let skipIndex = false ; let cauldron = new CauldronPlugin ( ) ; if ( env . browser || env . prod ) { const plugins = [ ] ; if ( ! includeCore && ( env . prod || env . npm ) ) { plugins . push ( new CopyPlugin ( `template` , 's' ) ) ; plugins . push ( new CopyPlugin ( `template` , 's' ) ) ; skipIndex = true ; console . log ( `template` ) ; } buildTasks . push ( getBuildTask ( `template` , [ cauldron , ... plugins ] , includeCore ) ) ; console . log ( `template` ) ; } if ( ! skipIndex && ( env . npm || env . prod ) ) { buildTasks . push ( getBuildTask ( "s" , [ cauldron ] , false ) ) ; console . log ( `template` ) ; } if ( env . prod ) { buildTasks . push ( getBuildTask ( fnPrefix + "s" , [ cauldron , ... productPlugins ] , includeCore ) ) ; console . log ( `template` ) ; } return buildTasks ; } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $JSON$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $void$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O O O $any$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O O $Console$ O $void$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Console$ O $void$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O O O $any$ O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $string$ O O O $any$ O $string$ O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $RegExp$ O O O $string$ O O O O O O $complex$ O O $string[]$ O O O O O O O O $any$ O $any$ O $string$ O O O O O $complex$ O $complex$ O O ${}$ O O O O O O O $boolean$ O O O O O O ${}$ O $any$ O O ${}$ O $any$ O O ${}$ O $any$ O O ${}$ O $any$ O O O O O $any[]$ O O O $any$ O $any$ O $any$ O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O O $boolean$ O O O O $CauldronPlugin$ O O $any$ O O O O O ${}$ O $any$ O ${}$ O $any$ O O O $any[]$ O O O O O O O $true$ O O ${}$ O $any$ O ${}$ O $any$ O O O $any[]$ O $number$ O O $any$ O O O O O O O $any[]$ O $number$ O O $any$ O O O O O O O $boolean$ O O O $Console$ O $void$ O O O O O $any[]$ O $number$ O $complex$ O O O O $CauldronPlugin$ O O $CopyPlugin[]$ O O $true$ O O O $Console$ O $void$ O O O O O O O O $boolean$ O O ${}$ O $any$ O ${}$ O $any$ O O O $any[]$ O $number$ O $complex$ O O O O $CauldronPlugin$ O O O O O O $Console$ O $void$ O O O O O O O ${}$ O $any$ O O $any[]$ O $number$ O $complex$ O $any$ O O O O $CauldronPlugin$ O O $any[]$ O O $true$ O O O $Console$ O $void$ O O O O O O $complex$ O O O