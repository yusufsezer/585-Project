export interface FormDataEntry { key : string ; value : string | Blob | Buffer ; fileName ? : string ; } export class FormData { private _entries : FormDataEntry [ ] = [ ] ; append ( key , value : string | Blob | Buffer , fileName ? ) { this . _entries . push ( { key , value , fileName } ) ; } } export function getFormDataEntries ( fd ) : FormDataEntry [ ] { return ( fd as any ) . _entries ; }	O O $any$ O $string$ O O O $any$ O O O $complex$ O $any$ O $string$ O O O O O O O $any$ O O $FormDataEntry[]$ O $any$ O O O O O O $void$ O $string$ O $any$ O O O $complex$ O $any$ O $string$ $string$ O O O O $FormDataEntry[]$ O $number$ O O $string$ O $any$ O $string$ O O O O O O O $FormDataEntry[]$ O $FormData$ O O $any$ O O O O O $FormData$ O O O O $any$ O O
import { Options as AsyncOptions } from 's' ; import { FormData , FormDataEntry } from 's' ; export interface BaseOptions extends Pick < AsyncOptions , | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' > { agent ? : boolean ; cache ? : 's' ; retry ? : boolean ; retryDelay ? : number ; socketTimeout ? : number ; timeout ? : number ; body ? : string | Buffer ; } export interface Options extends BaseOptions { form ? : FormData ; } export interface MessageOptions extends BaseOptions { form ? : FormDataEntry [ ] ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $FormData$ O O $any$ O O O O $any$ O $any$ O $FormDataEntry[]$ O O $any$ O O O O
import { URL } from 's' ; import { HttpVerb , Response } from 's' ; import handleQs from 's' ; import { Options } from 's' ; import GenericResponse = require ( 's' ) ; const fd = FormData as any ; export { fd as FormData } ; export default function doRequest ( method , url : string | URL , options ? ) { var xhr = new XMLHttpRequest ( ) ; if ( typeof method !== 's' ) { throw new TypeError ( 's' ) ; } if ( url && typeof url === 's' ) { url = url . href ; } if ( typeof url !== 's' ) { throw new TypeError ( 's' ) ; } if ( options === null || options === undefined ) { options = { } ; } if ( typeof options !== 's' ) { throw new TypeError ( 's' ) ; } method = method . toUpperCase ( ) as any ; options . headers = options . headers || { } ; var match ; var crossDomain = ! ! ( ( match = "s" . exec ( url ) ) && match [ 0 ] != location . host ) ; if ( ! crossDomain ) options . headers [ 's' ] = 's' ; if ( options . qs ) { url = handleQs ( url , options . qs ) ; } if ( options . json ) { options . body = JSON . stringify ( options . json ) ; options . headers [ 's' ] = 's' ; } if ( options . form ) { options . body = options . form as any ; } xhr . open ( method , url , false ) ; for ( var name in options . headers ) { xhr . setRequestHeader ( name . toLowerCase ( ) , 's' + options . headers [ name ] ) ; } xhr . send ( options . body ? options . body : null ) ; var headers = { } ; xhr . getAllResponseHeaders ( ) . split ( 's' ) . forEach ( function ( header ) { var h = header . split ( 's' ) ; if ( h . length > 0 ) { ( headers as any ) [ h [ 0 ] . toLowerCase ( ) ] = h . slice ( 0 ) . join ( 's' ) . trim ( ) ; } } ) ; return new GenericResponse < string > ( xhr . status , headers , xhr . responseText , url ) ; } module . exports = doRequest ; module . exports . default = doRequest ; module . exports . FormData = fd ;	O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O $any$ O $any$ O O O O O $Response$ O $HttpVerb$ O $any$ O O O $any$ O $Options$ $Options$ O O O $XMLHttpRequest$ O O $complex$ O O O O O O $any$ O O O O O O $TypeErrorConstructor$ O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $TypeErrorConstructor$ O O O O O O O $Options$ O O O $Options$ O $undefined$ O O $Options$ O O O O O O O O $Options$ O O O O O O $TypeErrorConstructor$ O O O O O $any$ O $string$ O $string$ O O O O O $Options$ O $any$ O $Options$ O $any$ O O O O O $any$ O O $boolean$ O O O O O $any$ O O O $RegExpExecArray$ O $string$ O O O $any$ O O O O $Location$ O $string$ O O O O O $boolean$ O $Options$ O $any$ O O O O O O O O $Options$ O $any$ O O $any$ O $any$ O $string$ O $Options$ O $any$ O O O O O $Options$ O $any$ O O $Options$ O $any$ O $JSON$ O $complex$ O $Options$ O $any$ O O $Options$ O $any$ O O O O O O O O O $Options$ O $FormData$ O O $Options$ O $any$ O $Options$ O $FormData$ O O O O $XMLHttpRequest$ O $complex$ O $any$ O $any$ O O O O O O O $string$ O $Options$ O $any$ O O $XMLHttpRequest$ O $void$ O $string$ O $string$ O O O O O $Options$ O $any$ O $string$ O O O O $XMLHttpRequest$ O O O $Options$ O $any$ O $Options$ O $any$ O O O O O ${}$ O O O O $XMLHttpRequest$ O $string$ O O O $complex$ O O O O $void$ O O O $string$ O O O $string[]$ O $string$ O $complex$ O O O O O O $string[]$ O $number$ O O O O O ${}$ O O O O $string[]$ O O O O $string$ O O O O $string[]$ O $string[]$ O O O O $string$ O O O O $string$ O O O O O O O O O $any$ O O O O $XMLHttpRequest$ O $number$ O ${}$ O $XMLHttpRequest$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O
import { Response , HttpVerb } from 's' ; import { MessageOptions } from 's' ; export type Req = { m : HttpVerb ; u : string ; o ? : MessageOptions ; } ; export interface Res { s : Response [ 's' ] ; h : Response [ 's' ] ; b : Response [ 's' ] ; u : Response [ 's' ] ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O $string$ O O O $MessageOptions$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O
import { HttpVerb , Response } from 's' ; import GenericResponse = require ( 's' ) ; import { URL } from 's' ; import { Req , Res } from 's' ; import { FormData , getFormDataEntries } from 's' ; import { Options , MessageOptions } from 's' ; const init = require ( 's' ) ; const remote = init ( require . resolve ( 's' ) ) ; export { HttpVerb , Response , Options } ; export { FormData } ; export default function request ( method , url : string | URL , options ? ) { const { form , ... o } = options || { form : undefined } ; const opts = o ; if ( form ) { opts . form = getFormDataEntries ( form ) ; } const req = { m : method , u : url && typeof url === 's' ? url . href : ( url as string ) , o : opts , } ; const res = remote ( req ) ; return new GenericResponse ( res . s , res . h , res . b , res . u ) ; } module . exports = request ; module . exports . default = request ; module . exports . FormData = FormData ;	O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $FormDataEntry[]$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Response$ O $HttpVerb$ O $any$ O O O $any$ O $Options$ $Options$ O O O O $FormData$ O O $complex$ O O $Options$ O O $undefined$ O $undefined$ O O O $MessageOptions$ O $complex$ O O O $FormData$ O O $MessageOptions$ O $FormDataEntry[]$ O $FormDataEntry[]$ O $FormData$ O O O O $Req$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O $MessageOptions$ O $MessageOptions$ O O O O $Res$ O $any$ O $Req$ O O O O $any$ O $Res$ O $any$ O $Res$ O $any$ O $Res$ O $any$ O $Res$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O
import request , { Options , FormData } from 's' ; import { Req , Res } from 's' ; function init ( ) { return ( req ) : Promise < Res > => { const { form , ... o } = req . o || { form : undefined } ; const opts = o ; if ( form ) { const fd = new FormData ( ) ; form . forEach ( entry => { fd . append ( entry . key , entry . value , entry . fileName ) ; } ) ; opts . form = fd ; } return request ( req . m , req . u , opts ) . then ( response => ( { s : response . statusCode , h : response . headers , b : response . body , u : response . url , } ) ) ; } ; } module . exports = init ;	O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $Promise<Res>$ O O O O O $Req$ O O $PromiseConstructor$ O $any$ O O O O O $FormDataEntry[]$ O O $complex$ O O $Req$ O $MessageOptions$ O O $undefined$ O $undefined$ O O O $Options$ O $complex$ O O O $FormDataEntry[]$ O O O $any$ O O $any$ O O O $FormDataEntry[]$ O $void$ O $FormDataEntry$ O O $any$ O $any$ O $FormDataEntry$ O $string$ O $FormDataEntry$ O $any$ O $FormDataEntry$ O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $Req$ O $any$ O $Req$ O $string$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $Promise<Res>$ O
'js' 's' ; const http = require ( 's' ) ; http . createServer ( function ( req , res , next ) { res . end ( 's' ) ; } ) . listen ( 0 ) ;	O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O
'js' 's' ; const spawn = require ( 's' ) . spawn ; const spawnSync = require ( 's' ) . spawnSync ; const thenRequest = require ( 's' ) ; const syncRequest = require ( 's' ) ; const server = spawn ( process . execPath , [ require . resolve ( 's' ) ] ) ; setTimeout ( ( ) => { let asyncDuration , syncDuration ; let ready = Promise . resolve ( null ) ; const startAsync = Date . now ( ) ; for ( let i = 0 ; i < 0 ; i ++ ) { ready = ready . then ( function ( ) { return thenRequest ( 's' , 's' ) ; } ) ; } ready . then ( function ( ) { const endAsync = Date . now ( ) ; asyncDuration = endAsync - startAsync ; console . log ( 's' + asyncDuration ) ; const startSync = Date . now ( ) ; for ( let i = 0 ; i < 0 ; i ++ ) { syncRequest ( 's' , 's' ) ; } const endSync = Date . now ( ) ; syncDuration = endSync - startSync ; console . log ( 's' + syncDuration ) ; } ) . then ( ( ) => { server . kill ( ) ; if ( syncDuration > ( asyncDuration * 0 ) ) { console . error ( 's' ) ; process . exit ( 0 ) ; } process . exit ( 0 ) ; } , function ( err ) { console . error ( err . stack ) ; process . exit ( 0 ) ; } ) ; ready = null ; } , 0 ) ;	O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $number$ O O O O O O $any$ O $any$ O O $Promise<any>$ O $PromiseConstructor$ O $complex$ O O O O O $number$ O $DateConstructor$ O $number$ O O O O O O $number$ O O O $number$ O O O $number$ O O O $Promise<any>$ O $Promise<any>$ O O O O O O O O $any$ O O O O O O O O O O $Promise<any>$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O $any$ O $number$ O $number$ O $Console$ O $void$ O O O $number$ O O O $number$ O $DateConstructor$ O $number$ O O O O O O $number$ O O O $number$ O O O $number$ O O O $any$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O $any$ O $number$ O $number$ O $Console$ O $void$ O O O $number$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $Promise<any>$ O O O O O O O O
'js' var request = require ( 's' ) ; var FormData = request . FormData ; test ( 's' , ( ) => { var res = request ( 's' , 's' ) ; expect ( res . statusCode ) . toBe ( 0 ) ; expect ( res . url ) . toBe ( 's' ) ; } ) ; test ( 's' , ( ) => { var res = JSON . parse ( request ( 's' , 's' , { body : 's' , } ) . getBody ( 's' ) ) ; delete res . origin ; expect ( res ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var res = JSON . parse ( request ( 's' , 's' , { json : { foo : 's' } , } ) . getBody ( 's' ) ) ; delete res . origin ; expect ( res ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var fd = new FormData ( ) ; fd . append ( 's' , 's' ) ; var res = JSON . parse ( request ( 's' , 's' , { form : fd , } ) . getBody ( 's' ) ) ; delete res . headers [ 's' ] ; delete res . origin ; expect ( res ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var errored = false ; try { var res = request ( 's' , 's' ) ; } catch ( ex ) { return ; } throw new Error ( 's' ) ; } ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $JSON$ O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $JSON$ O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $JSON$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O
'js' 's' ; var express = require ( 's' ) , bodyParser = require ( 's' ) , morgan = require ( 's' ) , PORT = 0 ; var app = express ( ) ; app . use ( bodyParser . urlencoded ( { extended : false } ) ) ; app . use ( bodyParser . json ( ) ) ; app . use ( morgan ( 's' ) ) ; var started = false ; exports . isStarted = function ( ) { return started ; } ; var server ; process . on ( 's' , function ( m ) { if ( m === 's' ) { server = app . listen ( PORT , function ( ) { started = true ; return process . send ( 's' ) ; } ) ; } else { server . close ( function ( ) { started = false ; return process . send ( 's' ) && process . exit ( 0 ) ; } ) ; } } ) ; [ 's' , 's' , 's' , 's' ] . forEach ( function ( method ) { app . route ( 's' ) [ method ] ( function ( req , res ) { res . send ( 's' ) ; } ) ; } ) ;	O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $number$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O $boolean$ O $boolean$ O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O O O O $boolean$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $void$ O O O $string$ O O $any$ O $any$ O O O O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O
'js' 's' ; if ( process . env . SYNC_REQUEST_LEGACY ) { process . env . PATH = 's' ; } var request = require ( 's' ) ; var FormData = request . FormData ; const fork = require ( 's' ) . fork ; var server = fork ( __dirname + 's' , { stdio : 's' } ) ; test ( 's' , ( ) => { return new Promise ( resolve => { server . on ( 's' , m => { if ( m === 's' ) { resolve ( ) ; } } ) ; server . send ( 's' ) ; } ) ; } ) ; test ( 's' , ( ) => { var res = request ( 's' , 's' , { timeout : 0 , } ) ; expect ( res . statusCode ) . toBe ( 0 ) ; expect ( res . getBody ( 's' ) ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var res = request ( 's' , 's' , { timeout : 0 , body : 's' , } ) ; expect ( res . statusCode ) . toBe ( 0 ) ; expect ( res . getBody ( 's' ) ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var res = request ( 's' , 's' , { timeout : 0 , body : 's' , } ) ; expect ( res . statusCode ) . toBe ( 0 ) ; expect ( res . getBody ( 's' ) ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { var res = request ( 's' , 's' , { timeout : 0 , } ) ; expect ( res . statusCode ) . toBe ( 0 ) ; expect ( res . getBody ( 's' ) ) . toMatchSnapshot ( ) ; } ) ; test ( 's' , ( ) => { server . send ( 's' ) ; } ) ;	O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O O O O O O O O O $PromiseConstructor$ O $void$ O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $void$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O