export const CLEAR_RESULTS = 's' ; export const LOGENTRY_ITEM_HEIGHT_CALCULATED = 's' ; export const COMMITS_RENDERED = 's' ; export const SELECT_COMMITTED_FILE = 's' ; export const SELECT_COMMIT = 's' ; export const LOGVIEW_SIZE_CALCULATED = 's' ; export const SET_APPEND_RESULTS = 's' ; export const ADD_RESULT = 's' ; export const FETCHED_COMMITS = 's' ; export const GO_TO_NEXT_PAGE = 's' ; export const GO_TO_PREVIOUS_PAGE = 's' ; export const FETCH_LOG_ALL_BRANCHES_ENTRIES = 's' ; export const IS_LOADING_COMMITS = 's' ; export const IS_FETCHING_COMMIT = 's' ; export const FETCH_COMMIT = 's' ; export const FETCHED_COMMIT = 's' ; export const CLEAR_SELECTED_COMMIT = 's' ; export const IS_FETCHING_BRANCHES = 's' ; export const FETCHED_BRANCHES = 's' ; export const FETCH_BRANCHES = 's' ; export const FETCHED_AVATARS = 's' ; export const FETCHED_AUTHORS = 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class EnumEx { public static getNamesAndValues < T extends number > ( e ) { return EnumEx . getNames ( e ) . map ( n => ( { name : n , value : e [ n ] as T } ) ) ; } public static getNames ( e ) { return EnumEx . getObjValues ( e ) . filter ( v => typeof v === "s" ) as string [ ] ; } public static getValues < T extends number > ( e ) { return EnumEx . getObjValues ( e ) . filter ( v => typeof v === 's' ) as T [ ] ; } private static getObjValues ( e ) : ( number | string ) [ ] { return Object . keys ( e ) . map ( k => e [ k ] ) ; } }	O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EnumEx } from 's' ; import { CommitInfo } from 's' ; export class Helpers { public static GetLogArguments ( ) { const args : string [ ] = [ ] ; for ( const item of EnumEx . getValues < CommitInfo > ( CommitInfo ) ) { if ( item !== CommitInfo . NewLine ) { args . push ( Helpers . GetCommitInfoFormatCode ( item ) ) ; } } return args ; } public static GetCommitInfoFormatCode ( info ) { switch ( info ) { case CommitInfo . FullHash : { return 's' ; } case CommitInfo . ShortHash : { return 's' ; } case CommitInfo . TreeFullHash : { return 's' ; } case CommitInfo . TreeShortHash : { return 's' ; } case CommitInfo . ParentFullHash : { return 's' ; } case CommitInfo . ParentShortHash : { return 's' ; } case CommitInfo . AuthorName : { return 's' ; } case CommitInfo . AuthorEmail : { return 's' ; } case CommitInfo . AuthorDateUnixTime : { return 's' ; } case CommitInfo . CommitterName : { return 's' ; } case CommitInfo . CommitterEmail : { return 's' ; } case CommitInfo . CommitterDateUnixTime : { return 's' ; } case CommitInfo . RefsNames : { return 's' ; } case CommitInfo . Subject : { return 's' ; } case CommitInfo . Body : { return 's' ; } case CommitInfo . Notes : { return 's' ; } case CommitInfo . NewLine : { return 's' ; } default : { throw new Error ( `template` ) ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $CommitInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CommitInfo } from 's' ; import { Helpers } from 's' ; export const LOG_ENTRY_SEPARATOR = 's' ; export const ITEM_ENTRY_SEPARATOR = 's' ; export const STATS_SEPARATOR = 's' ; export const LOG_FORMAT_ARGS = Helpers . GetLogArguments ( ) ; export const newLineFormatCode = Helpers . GetCommitInfoFormatCode ( CommitInfo . NewLine ) ; export const LOG_FORMAT = `template` ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type GitLogArgs = { logArgs : string [ ] ; fileStatArgs : string [ ] ; counterArgs : string [ ] ; } ; export const IGitArgsService = Symbol ( 's' ) ; export interface IGitArgsService { getGitRootArgs ( ) : string [ ] ; getAuthorsArgs ( ) : string [ ] ; getCurrentBranchArgs ( ) : string [ ] ; getCommitDateArgs ( hash ) : string [ ] ; getCommitArgs ( hash ) : string [ ] ; getCommitParentHashesArgs ( hash ) : string [ ] ; getCommitWithNumStatArgs ( hash ) : string [ ] ; getCommitNameStatusArgs ( hash ) : string [ ] ; getCommitWithNumStatArgsForMerge ( hash ) : string [ ] ; getCommitNameStatusArgsForMerge ( hash ) : string [ ] ; getObjectHashArgs ( object ) : string [ ] ; getRefsContainingCommitArgs ( hash ) : string [ ] ; getLogArgs ( pageIndex ? , pageSize ? , branch ? , searchText ? , relativeFilePath ? , lineNumber ? , author ? ) : GitLogArgs ; getDiffCommitWithNumStatArgs ( 0 , 0 ) : string [ ] ; getDiffCommitNameStatusArgs ( 0 , 0 ) : string [ ] ; getPreviousCommitHashForFileArgs ( hash , file ) : string [ ] ; } export enum GitOriginType { any = 0 , github = 0 , bitbucket = 0 , tfs = 0 , vsts = 0 , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O $number$ O O $number$ O O $string$ O O $string$ O O $string$ O O $number$ O O $string$ O O O O O O $string$ O $string$ O O O O O O O O $string$ O $string$ O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { Command , Uri } from 's' ; import { BranchSelection , CommittedFile , LogEntry } from 's' ; export const ILogService = Symbol ( 's' ) ; export interface ILogService { log ( ... args : any [ ] ) : void ; trace ( ... args : any [ ] ) : void ; error ( ... args : any [ ] ) : void ; } export const IUiService = Symbol ( 's' ) ; export interface IUiService { getBranchSelection ( ) : Promise < BranchSelection | undefined > ; getWorkspaceFolder ( uri ? ) : Promise < { workspaceFolder : string ; gitRoot : string } | undefined > ; selectFileCommitCommandAction ( fileCommit ) : Promise < ICommand < FileCommitDetails > | undefined > ; selectCommitCommandAction ( commit ) : Promise < ICommand < CommitDetails > | undefined > ; } export enum CallContextSource { viewer = 0 , commandPalette = 0 } export class CallContext < T > { constructor ( public readonly source , public readonly data : T ) { } } export class BranchDetails { constructor ( public readonly workspaceFolder , public readonly branch ) { } } export class CommitDetails extends BranchDetails { constructor ( workspaceFolder , branch , public readonly logEntry < LogEntry > ) { super ( workspaceFolder , branch ) ; } } export class CompareCommitDetails extends CommitDetails { constructor ( leftCommit , public readonly rightCommit , public readonly committedFiles : CommittedFile [ ] ) { super ( leftCommit . workspaceFolder , leftCommit . branch , leftCommit . logEntry ) ; } } export class FileCommitDetails extends CommitDetails { constructor ( workspaceFolder , branch , logEntry , public readonly committedFile < CommittedFile > ) { super ( workspaceFolder , branch , logEntry ) ; } } export class CompareFileCommitDetails extends FileCommitDetails { constructor ( leftCommit , public readonly rightCommit , public readonly committedFile < CommittedFile > ) { super ( leftCommit . workspaceFolder , leftCommit . branch , leftCommit . logEntry , committedFile ) ; } } export interface ICommand < T > extends Command { data : T ; label : string ; description : string ; detail ? : string ; preExecute ( ) : Promise < boolean > ; execute ( ) : void | Promise < any > | Thenable < any > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Uri$ O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CallContextSource$ O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O $string$ O $string$ O O O $Readonly$ O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $LogEntry$ O O O $Readonly$ O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O $CommitDetails$ O O O $Readonly$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Uri } from 's' ; import { GitOriginType } from 's' ; import { CommitDetails } from 's' ; export enum BranchSelection { Current = 0 , All = 0 } export type FsUri = Readonly < { scheme : string ; authority : string ; path : string ; query : string ; fragment : string ; fsPath : string ; } > ; export enum RefType { Head , RemoteHead , Tag } export type Ref = { type : RefType ; name ? : string ; } ; export type Remote = { name : string ; url : string ; } ; export type Branch = { gitRoot : string ; name : string ; current : boolean ; } ; export type CommittedFile = { uri : FsUri ; oldUri ? : FsUri ; oldRelativePath ? : string ; relativePath : string ; status : Status ; additions ? : number ; deletions ? : number ; } ; export type AvatarResponse = { items : Avatar [ ] ; timestamp : number ; } export type Avatar = { login : string ; name : string ; email : string ; url ? : string ; avatarUrl ? : string ; avatarFilePath ? : FsUri ; } ; export type ActionedUser = { name : string ; email : string ; } ; export type ActionedDetails = ActionedUser & { date : Date ; } ; export type LogEntriesResponse = { items : LogEntry [ ] ; count : number ; pageIndex ? : number ; pageSize ? : number ; branch ? : string ; lineNumber ? : number ; author ? : string ; searchText ? : string ; file ? : FsUri ; branchSelection ? : BranchSelection ; selected ? : LogEntry ; } ; export type LogEntries = { items : LogEntry [ ] ; count : number ; } ; export type LogEntry = { gitRoot : string ; author ? : ActionedDetails ; committer ? : ActionedDetails ; parents : Hash [ ] ; hash : Hash ; tree : Hash ; refs : Ref [ ] ; subject : string ; body : string ; notes : string ; committedFiles ? : CommittedFile [ ] ; isLastCommit ? : boolean ; isThisLastCommitMerged ? : boolean ; } ; export type CherryPickEntry = { branch : string ; hash : string ; } ; export type Hash = { full : string ; short : string ; } ; export enum Status { Modified , Added , Deleted , Renamed , Copied , Unmerged , Unknown , Broken , TypeChanged } export const IGitService = Symbol ( 's' ) ; export const IOutputChannel = Symbol ( 's' ) ; export interface IGitService { getGitRoot ( ) : Promise < string > ; getGitRoots ( rootDirectory ? ) : Promise < string [ ] > ; getGitRelativePath ( file ) : Promise < string > ; getHeadHashes ( ) : Promise < { ref : string ; hash : string } [ ] > ; getAuthors ( ) : Promise < ActionedUser [ ] > ; getBranches ( ) : Promise < Branch [ ] > ; getCurrentBranch ( ) : Promise < string > ; getObjectHash ( object ) : Promise < string > ; getHash ( hash ) : Promise < Hash > ; getRefsContainingCommit ( hash ) : Promise < string [ ] > ; getLogEntries ( pageIndex ? , pageSize ? , branch ? , searchText ? , file ? , lineNumber ? , author ? ) : Promise < LogEntries > ; getPreviousCommitHashForFile ( hash , file ) : Promise < Hash > ; getCommitDate ( hash ) : Promise < Date | undefined > ; getCommit ( hash ) : Promise < LogEntry | undefined > ; revertCommit ( hash ) : Promise < void > ; getCommitFile ( hash , file : FsUri | string ) : Promise < FsUri > ; getCommitFileContent ( hash , file : FsUri | string ) : Promise < string > ; getDifferences ( 0 , 0 ) : Promise < CommittedFile [ ] > ; cherryPick ( hash ) : Promise < void > ; checkout ( hash ) : Promise < void > ; createBranch ( branchName , hash ) : Promise < void > ; getOriginType ( ) : Promise < GitOriginType | undefined > ; getOriginUrl ( ) : Promise < string > ; merge ( hash ) : Promise < void > ; rebase ( hash ) : Promise < void > ; } export type CommitComparison = { leftCommit : CommitDetails ; rightCommit : CommitDetails ; differences : CommittedFile [ ] ; } ; export const IGitServiceFactory = Symbol ( 's' ) ; export interface IGitServiceFactory { createGitService ( workspaceRoot , resource ? : Uri | string ) : Promise < IGitService > ; } export enum CommitInfo { ParentFullHash , ParentShortHash , RefsNames , AuthorName , AuthorEmail , AuthorDateUnixTime , CommitterName , CommitterEmail , CommitterDateUnixTime , Body , Notes , FullHash , ShortHash , TreeFullHash , TreeShortHash , Subject , NewLine }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $FsUri$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O $number$ O O $number$ O O $string$ O O $string$ O O $FsUri$ O O $number$ O O $string$ O O O O O O O O O $string$ O $FsUri$ O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ;	O O O O O
export * from 's' ; import { BranchSelection } from 's' ; export interface ISettings { selectedBranchType ? : BranchSelection ; selectedBranchName ? : string ; pageIndex ? : number ; searchText ? : string ; file ? : string ; id ? : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const UPDATE_SEARCH_CRITERIA = 's' ; export const RESET_SEARCH_CRITERIA = 's' ;	O O O O O O O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; import { AuthorsState } from 's' ; const initialState = [ ] ; export default handleActions < AuthorsState , any > ( { [ Actions . FETCHED_AUTHORS ] : ( state , action : ReduxActions . Action < AuthorsState > ) => { return [ ... action . payload ] ; } } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O $AuthorsState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; import { Avatar } from 's' ; import { AvatarsState } from 's' ; const initialState = [ ] ; export default handleActions < AvatarsState , any > ( { [ Actions . FETCHED_AVATARS ] : ( state , action : ReduxActions . Action < Avatar [ ] > ) => { return [ ... state , ... action . payload ] ; } } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AvatarsState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; import { BranchesState } from 's' ; const initialState = [ ] ; export default handleActions < BranchesState , any > ( { [ Actions . FETCHED_BRANCHES ] : ( state , action : ReduxActions . Action < BranchesState > ) => { return [ ... action . payload ] ; } , [ Actions . IS_FETCHING_BRANCHES ] : ( state , action ) => { return [ ... state ] ; } , [ Actions . FETCH_BRANCHES ] : ( state , action : ReduxActions . Action < void > ) => { return [ ... state ] ; } , } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O $BranchesState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; export interface IGraphState { height ? : string ; width ? : string ; itemHeight ? : number ; updateTick ? : number ; } const initialState = { } ; export default handleActions < IGraphState , any > ( { [ Actions . LOGENTRY_ITEM_HEIGHT_CALCULATED ] : ( state , action : ReduxActions . Action < number > ) => { return { ... state , itemHeight : action . payload } as IGraphState ; } , [ Actions . COMMITS_RENDERED ] : ( state , action ) => { return { ... state , updateTick : new Date ( ) . getTime ( ) } as IGraphState ; } , [ Actions . LOGVIEW_SIZE_CALCULATED ] : ( state , action : ReduxActions . Action < { height : string , widht : string } > ) => { return { ... state , ... action . payload } as IGraphState ; } } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IGraphState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; import { LogEntry } from 's' ; import { LogEntriesResponse } from 's' ; import { LogEntriesState } from 's' ; const initialState = { count : 0 , isLoading : false , isLoadingCommit : false , items : [ ] , pageIndex : 0 } ; export default handleActions < LogEntriesState , any > ( { [ Actions . FETCHED_COMMITS ] : ( state , action : ReduxActions . Action < LogEntriesResponse > ) => { return { ... state , ... action . payload ! , selected : action . payload ? action . payload . selected : undefined , isLoading : false , searchText : action . payload ? action . payload . searchText : undefined , author : action . payload ? action . payload . author : undefined } ; } , [ Actions . FETCHED_COMMIT ] : ( state , action : ReduxActions . Action < LogEntry > ) => { const items = state . items . slice ( ) ; const index = items . findIndex ( item => item . hash . full === action . payload . hash . full ) ; if ( index >= 0 ) { items . splice ( index , 0 , action . payload ) ; } return { ... state , items , isLoadingCommit : false , selected : action . payload } ; } , [ Actions . IS_FETCHING_COMMIT ] : ( state , action ) => { return { ... state , isLoadingCommit : true } as LogEntriesState ; } , [ Actions . CLEAR_RESULTS ] : ( state , action ) => { return { ... state , items : [ ] , count : 0 , pageIndex : 0 , isLoading : false } as LogEntriesState ; } , [ Actions . SELECT_COMMIT ] : ( state , action : ReduxActions . Action < LogEntry > ) => { return { ... state , selected : action . payload } as LogEntriesState ; } , [ Actions . CLEAR_SELECTED_COMMIT ] : ( state , action ) => { return { ... state , selected : undefined } as LogEntriesState ; } , [ Actions . IS_LOADING_COMMITS ] : ( state , action ) => { return { ... state , isLoading : true } as LogEntriesState ; } } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntriesState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ISearchCriteria } from 's' ; import { handleActions } from 's' ; import * as Actions from 's' ; const initialState = [ ] ; export default handleActions < ISearchCriteria , Partial < ISearchCriteria > > ( { [ Actions . UPDATE_SEARCH_CRITERIA ] : ( state , action ) => { return { ... state , ... action . payload } ; } , [ Actions . RESET_SEARCH_CRITERIA ] : ( state , action ) => { return { } as ISearchCriteria ; } } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; import * as Actions from 's' ; const initialState = { appendResults : true } ; export default handleActions < any , any > ( { [ Actions . SET_APPEND_RESULTS ] : ( state , action ) => { return { ... state , appendResults : action . payload } ; } } , initialState ) ;	O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { handleActions } from 's' ; export type IVSCodeSettings = { theme ? : string ; locale ? : string ; } ; const initialState = { } ; export default handleActions < IVSCodeSettings , any > ( { 's' : ( state , action : ReduxActions . Action < number > ) => { return { ... state } ; } , } , initialState ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { routerReducer as routing } from 's' ; import { combineReducers } from 's' ; import { ActionedUser , Avatar , Branch , ISettings , LogEntriesResponse } from 's' ; import authors from 's' ; import avatars from 's' ; import branches from 's' ; import { default as graph , IGraphState } from 's' ; import logEntries from 's' ; import searchCriteria from 's' ; import settings from 's' ; import vscode , { IVSCodeSettings } from 's' ; export type LogEntriesState = LogEntriesResponse & { isLoading : boolean ; isLoadingCommit : boolean ; } ; export type BranchesState = { name : string ; current : boolean } [ ] ; export type AuthorsState = ActionedUser [ ] ; export type AvatarsState = Avatar [ ] ; export type RootState = { vscode : IVSCodeSettings ; logEntries ? : LogEntriesState ; branches ? : BranchesState ; avatars ? : AvatarsState ; authors ? : AuthorsState ; settings ? : ISettings ; searchCriteria : ISearchCriteria ; graph : IGraphState ; } export interface ISearchCriteria { selectedBranchType ? : Branch ; selectedBranchName ? : string ; pageIndex ? : number ; searchText ? : string ; } export default combineReducers < RootState > ( { routing , avatars , authors , logEntries , branches , settings , searchCriteria , graph , vscode } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import axios from 's' ; import { Dispatch } from 's' ; import { createAction } from 's' ; import * as Actions from 's' ; import { ActionedUser , Avatar , CommittedFile , LogEntriesResponse , LogEntry } from 's' ; import { BranchesState , RootState } from 's' ; export const clearResults = createAction ( Actions . CLEAR_RESULTS ) ; export const addResult = createAction < any > ( Actions . ADD_RESULT ) ; export const addResults = createAction < Partial < LogEntriesResponse > > ( Actions . FETCHED_COMMITS ) ; export const updateCommit = createAction < LogEntry > ( Actions . FETCHED_COMMIT ) ; export const updateBranchList = createAction < BranchesState > ( Actions . FETCHED_BRANCHES ) ; export const clearCommitSelection = createAction ( Actions . CLEAR_SELECTED_COMMIT ) ; export const setAppendResults = createAction < boolean > ( Actions . SET_APPEND_RESULTS ) ; export const goToPreviousPage = createAction < void > ( Actions . GO_TO_PREVIOUS_PAGE ) ; export const goToNextPage = createAction < void > ( Actions . GO_TO_NEXT_PAGE ) ; export const notifyIsLoading = createAction ( Actions . IS_LOADING_COMMITS ) ; export const notifyIsFetchingCommit = createAction ( Actions . IS_FETCHING_COMMIT ) ; export const fetchedAvatar = createAction < Avatar [ ] > ( Actions . FETCHED_AVATARS ) ; export const fetchedAuthors = createAction < ActionedUser [ ] > ( Actions . FETCHED_AUTHORS ) ; function getQueryUrl ( store , baseUrl , args : string [ ] = [ ] ) { const id = store . settings . id || 's' ; const queryArgs = args . concat ( [ `template` ] ) ; return `template` ; } export const actionACommit = ( logEntry ) => { return async ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const url = getQueryUrl ( state , `template` ) ; return axios . post ( url , logEntry ) ; } ; } ; export const fetchAvatars = async ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const url = getQueryUrl ( state , 's' ) ; axios . post ( url ) . then ( result => { dispatch ( fetchedAvatar ( result . data as Avatar [ ] ) ) ; } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } ; export const selectCommittedFile = ( logEntry , committedFile ) => { return async ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const url = getQueryUrl ( state , `template` ) ; await axios . post ( url , { logEntry , committedFile } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } ; } ; export const closeCommitView = ( ) => { return async ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const url = getQueryUrl ( state , 's' ) ; await axios . post ( url ) ; await dispatch ( clearCommitSelection ( ) ) ; } ; } ; export const selectCommit = ( hash ? ) => { return async ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; if ( hash ) { await fetchCommit ( dispatch , state , hash ) ; } else { const url = getQueryUrl ( state , 's' ) ; await axios . get ( url ) ; await dispatch ( clearCommitSelection ( ) ) ; } } ; } ; export const getNextCommits = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const pageIndex = state . logEntries . pageIndex + 0 ; return fetchCommits ( dispatch , state , pageIndex , undefined , undefined ) ; } ; } ; export const getPreviousCommits = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; const pageIndex = state . logEntries . pageIndex - 0 ; return fetchCommits ( dispatch , state , pageIndex , undefined , undefined ) ; } ; } ; export const search = ( searchText ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state , 0 , undefined , searchText , true , undefined , 's' ) ; } ; } ; export const clearSearch = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state , 0 , undefined , 's' , true , undefined , 's' ) ; } ; } ; export const selectBranch = ( branchName ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state , 0 , undefined , 's' , true , branchName ) ; } ; } ; export const selectAuthor = ( authorName ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state , 0 , undefined , undefined , true , undefined , authorName ) ; } ; } ; export const refresh = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state , undefined , undefined , undefined , true ) ; } ; } ; export const getCommits = ( id ? ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchCommits ( dispatch , state ) ; } ; } ; export const getBranches = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchBranches ( dispatch , state ) ; } ; } ; export const getAuthors = ( ) => { return ( dispatch < any > , getState : ( ) => RootState ) => { const state = getState ( ) ; return fetchAuthors ( dispatch , state ) ; } ; } ; function fixDates ( logEntry ) { if ( logEntry . author && typeof logEntry . author . date === 's' ) { logEntry . author . date = new Date ( logEntry . author . date ) ; } if ( logEntry . committer && typeof logEntry . committer . date === 's' ) { logEntry . committer . date = new Date ( logEntry . committer . date ) ; } } function fetchCommits ( dispatch < any > , store , pageIndex ? , pageSize ? , searchText ? , refreshData ? , branchName ? , author ? ) { const id = store . settings . id || 's' ; const queryParts = [ ] ; queryParts . push ( `template` ) ; if ( typeof branchName === 's' ) { queryParts . push ( `template` ) ; } if ( typeof searchText === 's' ) { queryParts . push ( `template` ) ; } if ( refreshData === true ) { queryParts . push ( 's' ) ; } if ( typeof pageIndex === 's' ) { queryParts . push ( `template` ) ; } if ( typeof author === 's' ) { queryParts . push ( `template` ) ; } if ( pageSize ) { queryParts . push ( `template` ) ; } dispatch ( notifyIsLoading ( ) ) ; return axios . get ( `template` ) . then ( ( result : { data : LogEntriesResponse } ) => { if ( Array . isArray ( result . data . items ) ) { result . data . items . forEach ( item => { fixDates ( item ) ; } ) ; } dispatch ( addResults ( result . data ) ) ; fetchAvatars ( dispatch , ( ) => store ) ; } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } function fetchCommit ( dispatch < any > , store , hash ) { dispatch ( notifyIsFetchingCommit ( ) ) ; const id = store . settings . id || 's' ; return axios . get ( `template` ) . then ( ( result : { data : LogEntry } ) => { if ( result . data ) { fixDates ( result . data ) ; } dispatch ( updateCommit ( result . data ) ) ; fetchAvatars ( dispatch , ( ) => store ) ; } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } function fetchBranches ( dispatch < any > , store ) { const id = store . settings . id || 's' ; return axios . get ( `template` ) . then ( result => { dispatch ( updateBranchList ( result . data ) ) ; } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } function fetchAuthors ( dispatch < any > , store ) { const id = store . settings . id || 's' ; return axios . get ( `template` ) . then ( result => { dispatch ( fetchedAuthors ( result . data ) ) ; } ) . catch ( err => { console . error ( 's' ) ; console . error ( err ) ; } ) ; } export const logViewSizeCalculated = createAction < { height : string ; width : string } > ( Actions . LOGVIEW_SIZE_CALCULATED ) ; export const logEntryHeightCalculated = createAction < number > ( Actions . LOGENTRY_ITEM_HEIGHT_CALCULATED ) ; export const commitsRendered = createAction ( Actions . COMMITS_RENDERED ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $RootState$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntry$ O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntry$ O $CommittedFile$ O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntry$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O $RootState$ O O $number$ O O $number$ O O $string$ O O $boolean$ O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O $RootState$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O $RootState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O $RootState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const emojis = require ( 's' ) ; type Gitmoji = { code : string ; emoji : string ; } ; const gitmojis : Gitmoji [ ] = [ ] ; emojis . forEach ( ( e ) => e . aliases . forEach ( ( alias ) => gitmojis . push ( { code : `template` , emoji : e . emoji } ) ) ) ; export function gitmojify ( message ) { gitmojis . forEach ( ( gitmoji ) => message = message . replace ( gitmoji . code , gitmoji . emoji ) ) ; return message ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $Gitmoji$ O O O O O O O O O O O O O O O O O O O O O O
export default function loggerMiddleware ( store ) { return next => action => { console . log ( action ) ; return next ( action ) ; } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import logger from 's' ; export { logger } ;	O O O O O O O O O O
import { createStore , applyMiddleware , Store } from 's' ; import { logger } from 's' ; import rootReducer , { RootState } from 's' ; import thunk from 's' ; export default function configureStore ( initialState ? ) < RootState > { const create = window . devToolsExtension ? window . devToolsExtension ( ) ( createStore ) : createStore ; const createStoreWithMiddleware = applyMiddleware ( thunk , logger ) < RootState > ( create ) ; const store = createStoreWithMiddleware ( rootReducer , initialState ) as Store < RootState > ; if ( ( module as any ) . hot ) { ( module as any ) . hot . accept ( 's' , ( ) => { const nextReducer = require ( 's' ) ; store . replaceReducer ( nextReducer ) ; } ) ; } return store ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Store$ O O $RootState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const gulp = require ( 's' ) ; const filter = require ( 's' ) ; const es = require ( 's' ) ; const tsfmt = require ( 's' ) ; const tslint = require ( 's' ) ; const relative = require ( 's' ) ; const ts = require ( 's' ) ; const cp = require ( 's' ) ; const colors = require ( 's' ) ; const gitmodified = require ( 's' ) ; const path = require ( 's' ) ; const debounce = require ( 's' ) ; const jeditor = require ( "s" ) ; const del = require ( 's' ) ; const codecov = require ( 's' ) ; const all = [ 's' , 's' , 's' ] ; const indentationFilter = [ 's' , 's' , ] ; const tslintFilter = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] ; gulp . task ( 's' , ( ) => run ( { mode : 's' , skipFormatCheck : true , skipIndentationCheck : true } ) ) ; gulp . task ( 's' , ( ) => run ( { mode : 's' , skipFormatCheck : true , skipIndentationCheck : true , skipLinter : true } ) ) ; gulp . task ( 's' , [ 's' , 's' ] ) ; gulp . task ( 's' , ( ) => gulp . watch ( all , debounce ( ( ) => run ( { mode : 's' } ) , 0 ) ) ) ; gulp . task ( 's' , [ 's' ] , ( ) => run ( { mode : 's' } ) ) ; gulp . task ( 's' , [ 's' , 's' ] , ( ) => { } ) ; gulp . task ( 's' , ( ) => gulp . src ( 's' ) . pipe ( codecov ( ) ) ) ; gulp . task ( 's' , ( ) => del ( 's' ) ) ; gulp . task ( 's' , ( ) => del ( 's' ) ) ; gulp . task ( 's' , ( ) => { return gulp . src ( "s" ) . pipe ( jeditor ( ( json ) => { json . enabled = true ; return json ; } ) ) . pipe ( gulp . dest ( "s" , { 's' : true } ) ) ; } ) ; gulp . task ( 's' , ( ) => { return gulp . src ( "s" ) . pipe ( jeditor ( ( json ) => { json . enabled = true ; return json ; } ) ) . pipe ( gulp . dest ( "s" , { 's' : true } ) ) ; } ) ; const hygiene = ( options ) => { options = options || { } ; let errorCount = 0 ; const indentation = es . through ( function ( file ) { file . contents . toString ( 's' ) . split ( "s" ) . forEach ( ( line , i ) => { if ( "s" . test ( line ) || "s" . test ( line ) ) { } else if ( "s" . test ( line ) ) { } else if ( "s" . test ( line ) ) { console . error ( file . relative + 's' + ( i + 0 ) + 's' ) ; errorCount ++ ; } } ) ; this . emit ( 's' , file ) ; } ) ; const formatOptions = { verify : true , tsconfig : true , tslint : true , editorconfig : true , tsfmt : true } ; const formatting = es . map ( function ( file , cb ) { tsfmt . processString ( file . path , file . contents . toString ( 's' ) , formatOptions ) . then ( result => { if ( result . error ) { let message = result . message . trim ( ) ; let formattedMessage = 's' ; if ( message . startsWith ( __dirname ) ) { message = message . substr ( __dirname . length ) ; message = message . startsWith ( path . sep ) ? message . substr ( 0 ) : message ; const index = message . indexOf ( 's' ) ; if ( index === - 0 ) { formattedMessage = colors . red ( message ) ; } else { const file = message . substr ( 0 , index + 0 ) ; const errorMessage = message . substr ( index + 0 ) . trim ( ) ; formattedMessage = `template` ; } } else { formattedMessage = colors . red ( message ) ; } console . error ( formattedMessage ) ; errorCount ++ ; } cb ( null , file ) ; } ) . catch ( cb ) ; } ) ; let reportedLinterFailures = [ ] ; function reportLinterFailures ( failures ) { failures . map ( failure => { const name = failure . name || failure . fileName ; const position = failure . startPosition ; const line = position . lineAndCharacter ? position . lineAndCharacter . line : position . line ; const character = position . lineAndCharacter ? position . lineAndCharacter . character : position . character ; const message = `template` ; if ( reportedLinterFailures . indexOf ( message ) === - 0 ) { console . error ( message ) ; reportedLinterFailures . push ( message ) ; return true ; } else { return false ; } } ) . filter ( reported => reported === true ) . length > 0 ; } const configuration = tslint . Configuration . findConfiguration ( null , 's' ) ; const program = tslint . Linter . createProgram ( 's' ) ; const linter = new tslint . Linter ( { formatter : 's' } , program ) ; const tsl = es . through ( function ( file ) { const contents = file . contents . toString ( 's' ) ; const oldWarn = console . warn ; console . warn = ( ) => { } ; linter . lint ( file . relative , contents , configuration . results ) ; console . warn = oldWarn ; const result = linter . getResult ( ) ; if ( result . failureCount > 0 || result . errorCount > 0 ) { const reported = reportLinterFailures ( result . failures ) ; if ( result . failureCount && reported ) { errorCount += result . failureCount ; } if ( result . errorCount && reported ) { errorCount += result . errorCount ; } } this . emit ( 's' , file ) ; } ) ; const tsFiles = [ ] ; const tscFilesTracker = es . through ( function ( file ) { tsFiles . push ( file . path . replace ( "s" , 's' ) ) ; tsFiles . push ( file . path ) ; this . emit ( 's' , file ) ; } ) ; const tsOptions = options . mode === 's' ? undefined : { strict : true , noImplicitAny : false , noImplicitThis : false } ; const tsProject = ts . createProject ( 's' , tsOptions ) ; const tsc = function ( ) { function customReporter ( ) { return { error : function ( error ) { const fullFilename = error . fullFilename || 's' ; const relativeFilename = error . relativeFilename || 's' ; if ( tsFiles . findIndex ( file => fullFilename === file || relativeFilename === file ) === - 0 ) { return ; } errorCount += 0 ; console . error ( error . message ) ; } , finish : function ( ) { } } ; } const reporter = customReporter ( ) ; return tsProject ( reporter ) ; } const files = options . mode === 's' ? tsProject . src ( ) : getFilesToProcess ( options ) ; const dest = options . mode === 's' ? 's' : 's' ; let result = files . pipe ( filter ( f => ! f . stat . isDirectory ( ) ) ) ; if ( ! options . skipIndentationCheck ) { result = result . pipe ( filter ( indentationFilter ) ) . pipe ( indentation ) ; } result = result . pipe ( filter ( tslintFilter ) ) ; if ( ! options . skipFormatCheck ) { } if ( ! options . skipLinter ) { result = result . pipe ( tsl ) ; } result = result . pipe ( tscFilesTracker ) . pipe ( tsc ( ) ) . js . pipe ( gulp . dest ( dest ) ) . pipe ( es . through ( null , function ( ) { if ( errorCount > 0 ) { const errorMessage = `template` ; console . error ( colors . red ( errorMessage ) ) ; exitHandler ( options ) ; } else { console . log ( colors . green ( 's' ) ) ; } errorCount = 0 ; reportedLinterFailures = [ ] ; this . emit ( 's' ) ; } ) ) . on ( 's' , exitHandler . bind ( this , options ) ) ; } ; function exitHandler ( options , ex ) { console . error ( ) ; if ( ex ) { console . error ( ex ) ; console . error ( colors . red ( ex ) ) ; } if ( options . exitOnError ) { console . log ( 's' ) ; process . exit ( 0 ) ; } } function run ( options ) { options = options ? options : { } ; process . once ( 's' , ( reason , p ) => { console . log ( 's' , p , 's' , reason ) ; exitHandler ( options ) ; } ) ; return hygiene ( options ) ; } function getStagedFilesSync ( ) { const out = cp . execSync ( 's' , { encoding : 's' } ) ; const some = out . split ( "s" ) . filter ( l => ! ! l ) ; return some ; } function getFilesToProcess ( options ) { const mode = options ? options . mode : 's' ; const gulpSrcOptions = { base : 's' } ; if ( options && options . mode === 's' ) { return gulp . src ( all , gulpSrcOptions ) . pipe ( gitmodified ( [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ) ) ; } if ( options && options . mode === 's' ) { return gulp . src ( getStagedFilesSync ( ) , gulpSrcOptions ) ; } return gulp . src ( all , gulpSrcOptions ) ; } exports . hygiene = hygiene ; if ( require . main === module ) { run ( { exitOnError : true , mode : 's' } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface IStateStore { has ( key ) : boolean ; set < T > ( key , data : T ) : Promise < void > ; get < T > ( key ) : Promise < T | undefined > ; } export const IStateStoreFactory = Symbol ( 's' ) ; export const GlobalStateStore = 's' ; export const WorkspaceStateStore = 's' ; export interface IStateStoreFactory { createStore ( ) : IStateStore ; }	O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CancellationToken , ConfigurationChangeEvent , Event , FileSystemWatcher , GlobPattern , Uri , WorkspaceConfiguration , WorkspaceFolder , WorkspaceFoldersChangeEvent } from 's' ; export const IWorkspaceService = Symbol ( 's' ) ; export interface IWorkspaceService { readonly rootPath : string | undefined ; readonly workspaceFolders : WorkspaceFolder [ ] | undefined ; readonly onDidChangeWorkspaceFolders : Event < WorkspaceFoldersChangeEvent > ; readonly onDidChangeConfiguration : Event < ConfigurationChangeEvent > ; getWorkspaceFolder ( uri ) : WorkspaceFolder | undefined ; asRelativePath ( pathOrUri : string | Uri , includeWorkspaceFolder ? ) : string ; createFileSystemWatcher ( globPattern , ignoreCreateEvents ? , ignoreChangeEvents ? , ignoreDeleteEvents ? ) : FileSystemWatcher ; findFiles ( include , exclude ? , maxResults ? , token ? ) : Thenable < Uri [ ] > ; getConfiguration ( section ? , resource ? ) : WorkspaceConfiguration ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Uri$ O O O O O O O O O O O O O O O $boolean$ O O O O O O $GlobPattern$ O O $boolean$ O O $boolean$ O O $boolean$ O O O O O O $GlobPattern$ O O $GlobPattern$ O O $number$ O O $CancellationToken$ O O O O O O O O O O O O $string$ O O $Uri$ O O O O O
export interface Newable < T > { new ( ... args : any [ ] ) : T ; } export interface Abstract < T > { prototype : T ; } export type ServiceIdentifier < T > = ( string | symbol | Newable < T > | Abstract < T > ) ; export type ClassType < T > = { new ( ... args : any [ ] ) : T ; } ; export const IServiceManager = Symbol ( 's' ) ; export interface IServiceManager { add < T > ( serviceIdentifier < T > , constructor < T > , name ? : string | number | symbol ) : void ; addSingleton < T > ( serviceIdentifier < T > , constructor < T > , name ? : string | number | symbol ) : void ; addSingletonInstance < T > ( serviceIdentifier < T > , instance : T , name ? : string | number | symbol ) : void ; get < T > ( serviceIdentifier < T > , name ? : string | number | symbol ) : T ; getAll < T > ( serviceIdentifier < T > , name ? : string | number | symbol ) : T [ ] ; } export const IServiceContainer = Symbol ( 's' ) ; export interface IServiceContainer { get < T > ( serviceIdentifier < T > , name ? : string | number | symbol ) : T ; getAll < T > ( serviceIdentifier < T > , name ? : string | number | symbol ) : T [ ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O $ClassType$ O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O $ClassType$ O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O O O O O O O O O O O O O O O O O O $ServiceIdentifier$ O O O O O O O O O O O O O O O O O O O
import { Avatar , IGitService } from 's' ; import { GitOriginType } from 's' ; export const IAvatarProvider = Symbol ( 's' ) ; export interface IAvatarProvider { supported ( remoteRepo ) : boolean ; getAvatars ( repository ) : Promise < Avatar [ ] > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GitOriginType$ O O O O O O $IGitService$ O O O O O O O O O O
import { injectable , unmanaged } from 's' ; import { IStateStore , IStateStoreFactory } from 's' ; import { IWorkspaceService } from 's' ; import { IServiceContainer } from 's' ; import { Avatar , AvatarResponse , IGitService } from 's' ; import { GitOriginType } from 's' ; import { IAvatarProvider } from 's' ; @ injectable ( ) export abstract class BaseAvatarProvider implements IAvatarProvider { protected readonly httpProxy : string ; private readonly avatarStateStore : IStateStore ; public constructor ( protected serviceContainer , @ unmanaged ( ) private remoteRepoType ) { const workspace = this . serviceContainer . get < IWorkspaceService > ( IWorkspaceService ) ; this . httpProxy = workspace . getConfiguration ( 's' ) . get ( 's' , 's' ) ; const stateStoreFactory = this . serviceContainer . get < IStateStoreFactory > ( IStateStoreFactory ) ; this . avatarStateStore = stateStoreFactory . createStore ( ) ; } public async getAvatars ( repository ) < Avatar [ ] > { const workspace = this . serviceContainer . get < IWorkspaceService > ( IWorkspaceService ) ; const cacheExpiration = workspace . getConfiguration ( 's' ) . get < number > ( 's' , 0 ) ; const remoteUrl = await repository . getOriginUrl ( ) ; const key = `template` ; const cachedAvatars = await this . avatarStateStore . get < AvatarResponse > ( key ) ; const retry = cacheExpiration === 0 || ! cachedAvatars || ( cachedAvatars && cachedAvatars . timestamp && ( cachedAvatars . timestamp + ( cacheExpiration * 0 * 0 ) ) < new Date ( ) . getTime ( ) ) ; if ( retry ) { const avatars = await this . getAvatarsImplementation ( repository ) ; await this . avatarStateStore . set < AvatarResponse > ( key , { timestamp : new Date ( ) . getTime ( ) , items : avatars } ) ; return avatars ; } else if ( cachedAvatars ) { return cachedAvatars . items ; } return [ ] ; } public supported ( remoteRepo ) { return remoteRepo === this . remoteRepoType ; } protected abstract getAvatarsImplementation ( repository ) < Avatar [ ] > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O $GitOriginType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $IGitService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $GitOriginType$ O O O O O O O O O O O O $Promise$ O $IGitService$ O O O O O O O O
import axios , { AxiosProxyConfig } from 's' ; import { inject , injectable } from 's' ; import { IStateStore , IStateStoreFactory } from 's' ; import { IServiceContainer } from 's' ; import { Avatar , IGitService } from 's' ; import { GitOriginType } from 's' ; import { BaseAvatarProvider } from 's' ; import { IAvatarProvider } from 's' ; const { URL } = require ( 's' ) ; type GithubUserSearchResponseItem = { 's' : string ; 's' : number ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : boolean ; 's' : number ; } ; type GithubUserResponse = { 's' : string ; 's' : number ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : boolean ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : string ; 's' : boolean ; 's' : string ; 's' : number ; 's' : number ; 's' : number ; 's' : number ; 's' : string ; 's' : string ; 's' : string ; } ; @ injectable ( ) export class GithubAvatarProvider extends BaseAvatarProvider implements IAvatarProvider { protected readonly httpProxy : string = 's' ; private readonly stateStore : IStateStore ; private get proxy ( ) : AxiosProxyConfig | undefined { let proxy : AxiosProxyConfig | undefined ; if ( this . httpProxy . length > 0 ) { const proxyUri = new URL ( this . httpProxy ) ; proxy = { host : proxyUri . hostname , port : proxyUri . port } ; } return proxy ; } public constructor ( @ inject ( IServiceContainer ) serviceContainer ) { super ( serviceContainer , GitOriginType . github ) ; const stateStoreFactory = this . serviceContainer . get < IStateStoreFactory > ( IStateStoreFactory ) ; this . stateStore = stateStoreFactory . createStore ( ) ; } protected async getAvatarsImplementation ( repository ) < Avatar [ ] > { const remoteUrl = await repository . getOriginUrl ( ) ; const remoteRepoPath = remoteUrl . replace ( "s" , 's' ) ; const contributors = await this . getContributors ( remoteRepoPath ) ; const githubUsers = await Promise . all ( contributors . map ( async user => { const u = await this . getUserByLogin ( user . login ) ; return u ; } ) ) ; let avatars : Avatar [ ] = [ ] ; githubUsers . forEach ( user => { if ( ! user ) return ; avatars . push ( { login : user . login , name : user . name , email : user . email , url : user . url , avatarUrl : user . avatar_url } ) ; } ) ; return avatars ; } private async getUserByLogin ( loginName ) { const key = `template` ; const cachedUser = await this . stateStore . get < GithubUserResponse > ( key ) ; let headers = { } ; if ( cachedUser ) { headers = { 's' : cachedUser . last_modified } ; } const proxy = this . proxy ; const info = await axios . get ( `template` , { proxy , headers } ) . then ( ( result : { headers : any , data : GithubUserResponse } ) => { if ( ! result . data || ( ! result . data . name && ! result . data . login ) ) { return ; } else { result . data . last_modified = result . headers [ 's' ] ; return result . data ; } } ) . catch ( ( ) => { } ) ; if ( info ) { await this . stateStore . set ( key , info ) ; return info ; } else { return cachedUser ; } } private async getContributors ( repoPath ) { const proxy = this . proxy ; const info = await axios . get ( `template` , { proxy } ) . then ( ( result : { data : GithubUserSearchResponseItem [ ] } ) => { return result . data ; } ) ; return info ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $IGitService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as gravatar from 's' ; import { inject , injectable } from 's' ; import { IServiceContainer } from 's' ; import { Avatar , IGitService } from 's' ; import { GitOriginType } from 's' ; import { BaseAvatarProvider } from 's' ; import { IAvatarProvider } from 's' ; @ injectable ( ) export class GravatarAvatarProvider extends BaseAvatarProvider implements IAvatarProvider { public constructor ( @ inject ( IServiceContainer ) serviceContainer ) { super ( serviceContainer , GitOriginType . any ) ; } protected async getAvatarsImplementation ( repository ) < Avatar [ ] > { const authors = await repository . getAuthors ( ) ; return authors . map ( user => { return { login : user . name , url : 's' , avatarUrl : gravatar . url ( user . email ) , name : user . name , email : user . email } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O O O O O O O O $Promise$ O $IGitService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; export class StopWatch { private started : number = Date . now ( ) ; public get elapsedTime ( ) { return Date . now ( ) - this . started ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Writable } from 's' ; export const IGitCommandExecutor = Symbol ( 's' ) ; export interface IGitCommandExecutor { exec ( cwd , ... args : string [ ] ) : Promise < string > ; exec ( options : { cwd : string ; shell ? : boolean } , ... args : string [ ] ) : Promise < string > ; exec ( options : { cwd : string ; shell ? : boolean ; encoding : 's' } , destination , ... args : string [ ] ) : Promise < void > ; }	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Writable$ O O O O O O O O O O O O O O O
import { spawn } from 's' ; import * as iconv from 's' ; import { injectable , multiInject } from 's' ; import { Writable } from 's' ; import { Disposable , extensions , Extension } from 's' ; import { StopWatch } from 's' ; import { ILogService } from 's' ; import { IGitCommandExecutor } from 's' ; const DEFAULT_ENCODING = 's' ; const isWindows = "s" . test ( process . platform ) ; @ injectable ( ) export class GitCommandExecutor implements IGitCommandExecutor { private gitExtension : Extension < any > | undefined ; private gitApi : any ; private gitExecutablePath : string ; constructor ( @ multiInject ( ILogService ) private loggers : ILogService [ ] ) { this . gitExtension = extensions . getExtension ( 's' ) ; this . gitApi = this . gitExtension ! . exports . getAPI ( 0 ) ; this . gitExecutablePath = this . gitApi . git . path ; } public async exec ( cwd , ... args : string [ ] ) < string > ; public async exec ( options : { cwd : string ; shell ? : boolean } , ... args : string [ ] ) < string > ; public async exec ( options : { cwd : string ; encoding : 's' } , destination , ... args : string [ ] ) < void > ; public async exec ( options , ... args : any [ ] ) < any > { let gitPath = this . gitExecutablePath ; gitPath = isWindows ? gitPath . replace ( "s" , 's' ) : gitPath ; const childProcOptions = typeof options === 's' ? { cwd : options , encoding : DEFAULT_ENCODING } : options ; if ( typeof childProcOptions . encoding !== 's' || childProcOptions . encoding . length === 0 ) { childProcOptions . encoding = DEFAULT_ENCODING ; } const binaryOuput = childProcOptions . encoding === 's' ; const destination = binaryOuput ? args . shift ( ) ! : undefined ; const gitPathCommand = childProcOptions . shell && gitPath . indexOf ( 's' ) > 0 ? `template` : gitPath ; const stopWatch = new StopWatch ( ) ; const gitShow = spawn ( gitPathCommand , args , childProcOptions ) ; if ( binaryOuput ) { gitShow . stdout . pipe ( destination ) ; } const disposables : Disposable [ ] = [ ] ; const on = ( ee : NodeJS . EventEmitter , name , fn ) => { ee . on ( name , fn ) ; disposables . push ( { dispose : ( ) => ee . removeListener ( name , fn ) } ) ; } ; const buffers : Buffer [ ] = [ ] ; if ( ! binaryOuput ) { on ( gitShow . stdout , 's' , ( data ) => buffers . push ( data ) ) ; } const errBuffers : Buffer [ ] = [ ] ; on ( gitShow . stderr , 's' , ( data ) => errBuffers . push ( data ) ) ; return new Promise < any > ( ( resolve , reject ) => { gitShow . once ( 's' , ( ) => { if ( errBuffers . length > 0 ) { let stdErr = decode ( errBuffers , childProcOptions . encoding ) ; stdErr = stdErr . startsWith ( 's' ) ? stdErr . substring ( 's' . length ) : stdErr ; this . loggers . forEach ( logger => { logger . log ( 's' , ... args , `template` ) ; logger . error ( stdErr ) ; } ) ; reject ( stdErr ) ; } else { const stdOut = binaryOuput ? undefined : decode ( buffers , childProcOptions . encoding ) ; this . loggers . forEach ( logger => { logger . log ( 's' , ... args , `template` ) ; logger . trace ( binaryOuput ? 's' : stdOut ) ; } ) ; resolve ( stdOut ) ; } disposables . forEach ( disposable => disposable . dispose ( ) ) ; } ) ; gitShow . once ( 's' , ex => { reject ( ex ) ; this . loggers . forEach ( logger => { logger . log ( 's' , ... args , `template` ) ; logger . error ( ex ) ; } ) ; disposables . forEach ( disposable => disposable . dispose ( ) ) ; } ) ; } ) ; } } function decode ( buffers : Buffer [ ] , encoding ) { return iconv . decode ( Buffer . concat ( buffers ) , encoding ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O $Writable$ O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Writable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
export * from 's' ;	O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { ActionedDetails , CommittedFile , LogEntry , Ref , Status } from 's' ; export const IRefsParser = Symbol ( 's' ) ; export interface IRefsParser { parse ( refsContent ) : Ref [ ] ; } export const IFileStatParser = 's' ; export interface IFileStatParser { parse ( gitRootPath , filesWithNumStat : string [ ] , filesWithStats : string [ ] ) : CommittedFile [ ] ; } export const IFileStatStatusParser = Symbol ( 's' ) ; export interface IFileStatStatusParser { canParse ( status ) : boolean ; parse ( status ) : Status | undefined ; } export const IActionDetailsParser = Symbol ( 's' ) ; export interface IActionDetailsParser { parse ( name , email , unixTime ) : ActionedDetails | undefined ; } export const ILogParser = Symbol ( 's' ) ; export interface ILogParser { parse ( gitRepoPath , summaryEntry , itemEntrySeparator , logFormatArgs : string [ ] , filesWithNumStat ? , filesWithNameStatus ? ) : LogEntry ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O $string$ O O $string$ O O O O O
import { injectable } from 's' ; import { ActionedDetails } from 's' ; import { IActionDetailsParser } from 's' ; @ injectable ( ) export class ActionDetailsParser implements IActionDetailsParser { public parse ( name , email , unixTime ) : ActionedDetails | undefined { name = ( name || 's' ) . trim ( ) ; unixTime = ( unixTime || 's' ) . trim ( ) ; if ( unixTime . length === 0 ) { return ; } const time = parseInt ( unixTime , 0 ) ; const date = new Date ( time * 0 ) ; return { date , email , name } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as path from 's' ; import { Uri } from 's' ; import { IServiceContainer } from 's' ; import { CommittedFile , Status } from 's' ; import { IFileStatParser , IFileStatStatusParser } from 's' ; @ injectable ( ) export class FileStatParser implements IFileStatParser { constructor ( @ inject ( IServiceContainer ) private serviceContainer ) { } private static parseFileMovement ( fileInfo ) : { original : string , current : string } | undefined { const diffSeparator = [ 's' , 's' ] . reduce < string | undefined > ( ( separator , item ) => { if ( typeof separator === 's' ) { return separator ; } return fileInfo . indexOf ( item ) === - 0 ? undefined : item ; } , undefined ) ; if ( ! diffSeparator ) { console . error ( `template` ) ; return ; } const startIndex = fileInfo . indexOf ( 's' ) ; const endIndex = fileInfo . lastIndexOf ( 's' ) ; if ( startIndex === - 0 || endIndex === - 0 ) { const parts = fileInfo . split ( diffSeparator ) ; return { original : parts [ 0 ] , current : parts [ 0 ] } ; } else { const partWithDifference = fileInfo . substring ( startIndex , endIndex + 0 ) ; if ( ! partWithDifference . startsWith ( 's' ) || ! partWithDifference . endsWith ( 's' ) ) { console . error ( `template` ) ; return ; } const parts = partWithDifference . split ( diffSeparator ) . map ( part => part . startsWith ( 's' ) ? part . substring ( 0 ) : part ) . map ( part => part . endsWith ( 's' ) ? part . substring ( 0 , part . length - 0 ) : part ) . map ( part => part . trim ( ) ) ; if ( parts . length !== 0 ) { console . error ( `template` ) ; } const original = fileInfo . replace ( partWithDifference , parts [ 0 ] ) ; const originalPathParts = original . split ( "s" ) . filter ( part => part . length > 0 ) ; const current = fileInfo . replace ( partWithDifference , parts [ 0 ] ) ; const currentPathParts = current . split ( "s" ) . filter ( part => part . length > 0 ) ; return { original : path . join ( ... originalPathParts ) , current : path . join ( ... currentPathParts ) } ; } } private static getNewAndOldFileNameFromNumStatLine ( line , status ) : { original ? : string , current : string } | undefined { const statusParts = line . split ( 's' ) ; const fileName = statusParts [ 0 ] . trim ( ) ; if ( status === Status . Renamed || status === Status . Copied ) { return FileStatParser . parseFileMovement ( line . substring ( line . indexOf ( fileName ) ) ) ; } return { current : fileName } ; } private static getAdditionsAndDeletionsFromNumStatLine ( line ) : { additions ? : number ; deletions ? : number ; fileName : string } | undefined { const numStatParts = line . split ( 's' ) . map ( part => part . trim ( ) ) . filter ( part => part . length > 0 ) ; if ( numStatParts . length < 0 ) { console . error ( `template` ) ; return ; } let additions = numStatParts [ 0 ] === 's' ? undefined : parseInt ( numStatParts [ 0 ] , 0 ) ; additions = isNaN ( additions ! ) ? undefined : additions ; let deletions = numStatParts [ 0 ] === 's' ? undefined : parseInt ( numStatParts [ 0 ] , 0 ) ; deletions = isNaN ( deletions ! ) ? undefined : deletions ; return { additions , deletions , fileName : numStatParts [ 0 ] } ; } public parse ( gitRootPath , filesWithNumStat : string [ ] , filesWithNameStat : string [ ] ) : CommittedFile [ ] { return filesWithNameStat . map ( ( line , index ) => { if ( line . trim ( ) . length === 0 && filesWithNumStat . length > index && filesWithNumStat [ index ] . trim ( ) . length === 0 ) { return ; } const numStatParts = FileStatParser . getAdditionsAndDeletionsFromNumStatLine ( filesWithNumStat [ index ] ) ; const additions = numStatParts ? numStatParts . additions : undefined ; const deletions = numStatParts ? numStatParts . deletions : undefined ; const statusParts = line . split ( 's' ) ; const statusCode = statusParts [ 0 ] . trim ( ) ; const statusParser = this . serviceContainer . get < IFileStatStatusParser > ( IFileStatStatusParser ) ; if ( ! statusParser . canParse ( statusCode ) ) { return ; } const status = statusParser . parse ( statusCode ) ! ; const currentAndOriginalFile = FileStatParser . getNewAndOldFileNameFromNumStatLine ( line , status ) ! ; const oldRelativePath = currentAndOriginalFile ? currentAndOriginalFile . original : undefined ; const relativePath = currentAndOriginalFile . current ; const oldUri = oldRelativePath ? Uri . file ( path . join ( gitRootPath , oldRelativePath ) ) : undefined ; const fileInfo = { additions , deletions , status , relativePath , oldRelativePath , uri : Uri . file ( path . join ( gitRootPath , relativePath ) ) , oldUri } ; fileInfo . uri . fsPath ; if ( fileInfo . oldUri !== undefined ) { fileInfo . oldUri . fsPath ; } return fileInfo ; } ) . filter ( commitFile => commitFile !== undefined ) . map ( commitFile => commitFile ! ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Status$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommittedFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable , multiInject } from 's' ; import { ILogService } from 's' ; import { Status } from 's' ; import { IFileStatStatusParser } from 's' ; @ injectable ( ) export class FileStatStatusParser implements IFileStatStatusParser { constructor ( @ multiInject ( ILogService ) private loggers : ILogService [ ] ) { } public canParse ( status ) { const parsedStatus = this . parse ( status ) ; return parsedStatus !== undefined && parsedStatus !== null ; } public parse ( status ) : Status | undefined { status = status || 's' ; status = status . length === 0 ? 's' : status . trim ( ) . substring ( 0 , 0 ) ; switch ( status ) { case 's' : return Status . Added ; case 's' : return Status . Modified ; case 's' : return Status . Deleted ; case 's' : return Status . Copied ; case 's' : return Status . Renamed ; case 's' : return Status . TypeChanged ; case 's' : return Status . Unknown ; case 's' : return Status . Unmerged ; case 's' : return Status . Broken ; default : { this . loggers . forEach ( logger => logger . error ( `template` ) ) ; return ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ;	O O O O O
import { inject , injectable } from 's' ; import { IServiceContainer } from 's' ; import { CommitInfo , CommittedFile , LogEntry } from 's' ; import { Helpers } from 's' ; import { IActionDetailsParser , IFileStatParser , ILogParser , IRefsParser } from 's' ; @ injectable ( ) export class LogParser implements ILogParser { constructor ( @ inject ( IRefsParser ) private refsparser , @ inject ( IServiceContainer ) private serviceContainer , @ inject ( IActionDetailsParser ) private actionDetailsParser ) { } public parse ( gitRepoPath , summaryEntry , itemEntrySeparator , logFormatArgs : string [ ] , filesWithNumStat ? , filesWithNameStatus ? ) { const logItems = summaryEntry . split ( itemEntrySeparator ) ; const fullParentHash = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . ParentFullHash ) . split ( 's' ) . filter ( hash => hash . trim ( ) . length > 0 ) ; const shortParentHash = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . ParentShortHash ) . split ( 's' ) . filter ( hash => hash . trim ( ) . length > 0 ) ; const parents = fullParentHash . map ( ( hash , index ) => { return { full : hash , short : shortParentHash [ index ] } ; } ) ; const committedFiles = this . parserCommittedFiles ( gitRepoPath , filesWithNumStat , filesWithNameStatus ) ; return { gitRoot : gitRepoPath , refs : this . refsparser . parse ( this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . RefsNames ) ) , author : this . getAuthorInfo ( logItems , logFormatArgs ) , committer : this . getCommitterInfo ( logItems , logFormatArgs ) , body : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . Body ) , notes : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . Notes ) , parents , committedFiles , hash : { full : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . FullHash ) , short : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . ShortHash ) } , tree : { full : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . TreeFullHash ) , short : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . TreeShortHash ) } , subject : this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . Subject ) } ; } private parserCommittedFiles ( gitRepoPath , filesWithNumStat ? , filesWithNameStatus ? ) : CommittedFile [ ] { if ( filesWithNumStat && filesWithNumStat . length > 0 ) { const numStatFiles = filesWithNumStat . split ( "s" ) . map ( entry => entry . trim ( ) ) . filter ( entry => entry . length > 0 ) ; const nameStatusFiles = filesWithNameStatus ! . split ( "s" ) . map ( entry => entry . trim ( ) ) . filter ( entry => entry . length > 0 ) ; const fileStatParserFactory = this . serviceContainer . get < IFileStatParser > ( IFileStatParser ) ; return fileStatParserFactory . parse ( gitRepoPath , numStatFiles , nameStatusFiles ) ; } else { return [ ] ; } } private getCommitInfo ( logItems : string [ ] , logFormatArgs : string [ ] , info ) { const commitInfoFormatCode = Helpers . GetCommitInfoFormatCode ( info ) ; const indexInArgs = logFormatArgs . indexOf ( commitInfoFormatCode ) ; if ( indexInArgs === - 0 ) { throw new Error ( `template` ) ; } return logItems [ indexInArgs ] ; } private getAuthorInfo ( logItems : string [ ] , logFormatArgs : string [ ] ) { const name = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . AuthorName ) ; const email = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . AuthorEmail ) ; const dateTime = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . AuthorDateUnixTime ) ; return this . actionDetailsParser . parse ( name , email , dateTime ) ; } private getCommitterInfo ( logItems : string [ ] , logFormatArgs : string [ ] ) { const name = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . CommitterName ) ; const email = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . CommitterEmail ) ; const dateTime = this . getCommitInfo ( logItems , logFormatArgs , CommitInfo . CommitterDateUnixTime ) ; return this . actionDetailsParser . parse ( name , email , dateTime ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRefsParser$ O O O O O O O $IServiceContainer$ O O O O O O O $IActionDetailsParser$ O O O O $LogEntry$ O $string$ O $string$ O $string$ O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $CommitInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const HEAD_REF_PREFIXES = [ 's' , 's' ] ; export const REMOTE_REF_PREFIXES = [ 's' , 's' , 's' ] ; export const TAG_REF_PREFIXES = [ 's' , 's' ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { REMOTE_REF_PREFIXES } from 's' ; export function isRemoteHead ( ref ) { return typeof ref === 's' && REMOTE_REF_PREFIXES . filter ( item => ref . startsWith ( item ) ) . length > 0 ; } export function getRemoteHeadName ( ref ) { ref = ref || 's' ; const prefix = REMOTE_REF_PREFIXES . find ( item => ref . startsWith ( item ) ) ! ; return prefix ? ref . substring ( prefix . length ) : 's' ; }	O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Ref } from 's' ; export const IRefParser = Symbol ( 's' ) ; export interface IRefParser { canParse ( refContent ) : boolean ; parse ( refContent ) : Ref ; }	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O
export * from 's' ; import { injectable , multiInject } from 's' ; import { ILogService } from 's' ; import { Ref } from 's' ; import { IRefsParser } from 's' ; import { IRefParser } from 's' ; @ injectable ( ) export class RefsParser implements IRefsParser { constructor ( @ multiInject ( IRefParser ) private parsers : IRefParser [ ] , @ multiInject ( ILogService ) private loggers : ILogService [ ] ) { } public parse ( refContent ) : Ref [ ] { return ( refContent || 's' ) . split ( 's' ) . map ( ref => ref . trim ( ) ) . filter ( line => line . length > 0 ) . map ( ref => { const parser = this . parsers . find ( item => item . canParse ( ref ) ) ; if ( ! parser ) { this . loggers . forEach ( logger => logger . error ( `template` ) ) ; return ; } return parser . parse ( ref ) ; } ) . filter ( ref => ref !== undefined && ref !== null ) . map ( ref => ref ! ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Ref , RefType } from 's' ; import { HEAD_REF_PREFIXES } from 's' ; import { IRefParser } from 's' ; @ injectable ( ) export class HeadRefParser implements IRefParser { public canParse ( refContent ) { return typeof refContent === 's' && HEAD_REF_PREFIXES . filter ( prefix => refContent . startsWith ( prefix ) ) . length > 0 ; } public parse ( refContent ) { const prefix = HEAD_REF_PREFIXES . filter ( item => refContent . startsWith ( item ) ) [ 0 ] ; const ref = { name : refContent . substring ( prefix . length ) , type : RefType . Head } ; return ref ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Ref$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O $Ref$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Ref , RefType } from 's' ; import { getRemoteHeadName , isRemoteHead } from 's' ; import { IRefParser } from 's' ; @ injectable ( ) export class RemoteHeadParser implements IRefParser { public canParse ( refContent ) { return typeof refContent === 's' && isRemoteHead ( refContent ) ; } public parse ( refContent ) { const ref = { name : getRemoteHeadName ( refContent ) , type : RefType . RemoteHead } ; return ref ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O $Ref$ O $string$ O O O $Ref$ O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Ref , RefType } from 's' ; import { TAG_REF_PREFIXES } from 's' ; import { IRefParser } from 's' ; @ injectable ( ) export class TagRefParser implements IRefParser { public canParse ( refContent ) { return typeof refContent === 's' && TAG_REF_PREFIXES . filter ( prefix => refContent . startsWith ( prefix ) ) . length > 0 ; } public parse ( refContent ) { const prefix = TAG_REF_PREFIXES . find ( item => refContent . startsWith ( item ) ) ! ; const ref = { name : refContent . substring ( prefix . length ) , type : RefType . Tag } ; return ref ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Ref$ O $string$ O O O O O O O O O O O O O O O O O O O O O $Ref$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { ActionDetailsParser } from 's' ; import { FileStatParser } from 's' ; import { FileStatStatusParser } from 's' ; import { LogParser } from 's' ; import { RefsParser } from 's' ; import { HeadRefParser } from 's' ; import { RemoteHeadParser } from 's' ; import { TagRefParser } from 's' ; import { IRefParser } from 's' ; import { IActionDetailsParser , IFileStatParser , IFileStatStatusParser , ILogParser , IRefsParser } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . addSingleton < IRefParser > ( IRefParser , HeadRefParser ) ; serviceManager . addSingleton < IRefParser > ( IRefParser , RemoteHeadParser ) ; serviceManager . addSingleton < IRefParser > ( IRefParser , TagRefParser ) ; serviceManager . addSingleton < IRefsParser > ( IRefsParser , RefsParser ) ; serviceManager . add < IActionDetailsParser > ( IActionDetailsParser , ActionDetailsParser ) ; serviceManager . add < IFileStatStatusParser > ( IFileStatStatusParser , FileStatStatusParser ) ; serviceManager . add < IFileStatParser > ( IFileStatParser , FileStatParser ) ; serviceManager . add < ILogParser > ( ILogParser , LogParser ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Disposable } from 's' ; const MAX_CACHE_ITEMS = 0 ; type CacheStore = Map < string , { expiryTime ? : number ; data : any } > ; const CacheItemUsageFrequency < string , number > = new Map < string , number > ( ) ; const CacheStores = new Map < string , CacheStore > ( ) ; export class CacheRegister implements Disposable { public static get < T > ( storageKey , key ) : { data : T } | undefined { const storage = CacheStores . get ( storageKey ) ! ; if ( storage && storage . has ( key ) ) { const entry = storage . get ( key ) ! ; if ( ! entry . expiryTime || entry . expiryTime < new Date ( ) . getTime ( ) ) { return { data : entry . data } ; } storage . delete ( key ) ; } return ; } public static add < T > ( storageKey , key , data : T , expiryMs ? ) { if ( ! CacheStores . has ( storageKey ) ) { CacheStores . set ( storageKey , new Map < string , { expiryTime ? : number ; data : any } > ( ) ) ; } const storage = CacheStores . get ( storageKey ) ! ; const counter = CacheItemUsageFrequency . has ( key ) ? CacheItemUsageFrequency . get ( key ) ! : 0 ; CacheItemUsageFrequency . set ( key , counter + 0 ) ; const expiryTime = typeof expiryMs === 's' ? new Date ( ) . getTime ( ) + expiryMs : undefined ; storage . set ( key , { data , expiryTime } ) ; setTimeout ( ( ) => CacheRegister . reclaimSpace ( ) , 0 ) ; } private static reclaimSpace ( ) { CacheStores . forEach ( storage => { if ( storage . size <= MAX_CACHE_ITEMS ) { return ; } const keyWithCounters : { key : string ; counter : number } [ ] = [ ] ; for ( const key of storage . keys ( ) ) { const counter = CacheItemUsageFrequency . get ( key ) ! ; keyWithCounters . push ( { key , counter } ) ; } keyWithCounters . sort ( ( a , b ) => a . counter - b . counter ) ; while ( storage . size > MAX_CACHE_ITEMS ) { const key = keyWithCounters . shift ( ) ! . key ; storage . delete ( key ) ; } } ) ; } public dispose ( ) { CacheStores . clear ( ) ; } } type Fn = ( ... args : any [ ] ) => any ; export function cache ( storageKey ) ; export function cache ( storageKey , expiryMs ) ; export function cache ( storageKey , cacheKeyPrefix ) ; export function cache ( storageKey , cacheKeyPrefix , expiryMs ) ; export function cache ( storageKey , 0 ? , 0 ? ) { return function ( _target , propertyKey , descriptor < Fn > ) { const oldFn = descriptor . value ! ; descriptor . value = async function ( ... args : any [ ] ) { const expiryMs = typeof 0 === 's' ? 0 : ( typeof 0 === 's' ? 0 : - 0 ) ; const cacheKeyPrefix = typeof 0 === 's' ? 0 : ( typeof 0 === 's' ? 0 : 's' ) ; storageKey = typeof this . getHashCode === 's' ? `template` as string : storageKey ; const key = `template` ; const entry = CacheRegister . get ( storageKey , key ) ! ; if ( entry ) { return entry . data ; } const result = oldFn ! . apply ( this , args ) ; if ( result && result . then && result . catch ) { result . then ( ( value ) => { CacheRegister . add ( storageKey , key , value , expiryMs ) ; } ) ; } return result ; } ; return descriptor ; } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Map$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $string$ O $string$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O $any$ O $string$ O $number$ O O O O $any$ O $string$ O $string$ O O O O $any$ O $string$ O $string$ O $number$ O O O O O O $string$ O O $any$ O O $any$ O O O O O $Object$ O $string$ O $TypedPropertyDescriptor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const tmp = require ( 's' ) ; export async function createTemporaryFile ( extension , temporaryDirectory ? ) < { filePath : string ; cleanupCallback : Function } > { const options : { postfix : string ; dir ? : string } = { postfix : extension } ; if ( temporaryDirectory ) { options . dir = temporaryDirectory ; } return new Promise < { filePath : string ; cleanupCallback : Function } > ( ( resolve , reject ) => { tmp . file ( options , ( err , tmpFile , _fd , cleanupCallback ) => { if ( err ) { return reject ( err ) ; } resolve ( { filePath : tmpFile , cleanupCallback : cleanupCallback } ) ; } ) ; } ) ; } export function formatDate ( date ) { const lang = process . env . language ; const dateOptions = { weekday : 's' , day : 's' , month : 's' , year : 's' , hour : 's' , minute : 's' } ; return date . toLocaleString ( lang , dateOptions ) ; } export async function asyncFilter < T > ( arr : T [ ] , callback ) < T [ ] > { return ( await Promise . all ( arr . map ( async item => ( await callback ( item ) ) ? item : undefined ) ) ) . filter ( i => i !== undefined ) as T [ ] ; }	O O O O O O O O O O O $Promise$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O $string$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; import { inject , injectable } from 's' ; import * as path from 's' ; import { Writable } from 's' ; import * as tmp from 's' ; import { Uri } from 's' ; import { IWorkspaceService } from 's' ; import { cache } from 's' ; import { IServiceContainer } from 's' ; import { ActionedUser , Branch , CommittedFile , FsUri , Hash , IGitService , LogEntries , LogEntry } from 's' ; import { IGitCommandExecutor } from 's' ; import { IFileStatParser , ILogParser } from 's' ; import { ITEM_ENTRY_SEPARATOR , LOG_ENTRY_SEPARATOR , LOG_FORMAT_ARGS } from 's' ; import { GitOriginType } from 's' ; import { IGitArgsService } from 's' ; import { asyncFilter } from 's' ; @ injectable ( ) export class Git implements IGitService { private gitRootPath : string | undefined ; private knownGitRoots : Set < string > ; constructor ( @ inject ( IServiceContainer ) private serviceContainer , private workspaceRoot , private resource , @ inject ( IGitCommandExecutor ) private gitCmdExecutor , @ inject ( ILogParser ) private logParser , @ inject ( IGitArgsService ) private gitArgsService ) { this . knownGitRoots = new Set < string > ( ) ; } public getHashCode ( ) { return this . workspaceRoot ; } @ cache ( 's' ) public async getGitRoot ( ) < string > { if ( this . gitRootPath ) { return this . gitRootPath ; } const gitRootPath = await this . gitCmdExecutor . exec ( this . resource . fsPath , ... this . gitArgsService . getGitRootArgs ( ) ) ; return this . gitRootPath = gitRootPath . split ( "s" ) [ 0 ] . trim ( ) ; } @ cache ( 's' , 0 * 0 * 0 ) public async getGitRoots ( rootDirectory ? ) < string [ ] > { if ( rootDirectory && ( this . knownGitRoots . has ( rootDirectory ) || this . knownGitRoots . has ( Uri . file ( rootDirectory ) . fsPath ) ) ) { return [ rootDirectory ] ; } const rootDirectories : string [ ] = [ ] ; if ( rootDirectory ) { rootDirectories . push ( rootDirectory ) ; } else { const workspace = this . serviceContainer . get < IWorkspaceService > ( IWorkspaceService ) ; const workspaceFolders = Array . isArray ( workspace . workspaceFolders ) ? workspace . workspaceFolders . map ( item => item . uri . fsPath ) : [ ] ; rootDirectories . push ( ... workspaceFolders ) ; } if ( rootDirectories . length === 0 ) { return [ ] ; } const gitFoldersList = await Promise . all ( rootDirectories . map ( item => this . getGitReposInFolder ( item ) ) ) ; const gitRoots = new Set < string > ( ) ; gitFoldersList . reduce < string [ ] > ( ( aggregate , items ) => { aggregate . push ( ... items ) ; return aggregate ; } , [ ] ) . forEach ( item => { gitRoots . add ( item ) ; this . knownGitRoots . add ( item ) ; } ) ; return Array . from ( gitRoots . values ( ) ) ; } public async getGitRelativePath ( file : Uri | FsUri ) { if ( ! path . isAbsolute ( file . fsPath ) ) { return file . fsPath ; } const gitRoot = await this . getGitRoot ( ) ; return path . relative ( gitRoot , file . fsPath ) . replace ( "s" , 's' ) ; } @ cache ( 's' , 0 * 0 ) public async getHeadHashes ( ) < { ref : string ; hash : string } [ ] > { const fullHashArgs = [ 's' ] ; const fullHashRefsOutput = await this . exec ( ... fullHashArgs ) ; return fullHashRefsOutput . split ( "s" ) . filter ( line => line . length > 0 ) . filter ( line => line . indexOf ( 's' ) > 0 || line . indexOf ( 's' ) > 0 ) . map ( line => line . trim ( ) . split ( 's' ) ) . filter ( lineParts => lineParts . length > 0 ) . map ( hashAndRef => { return { ref : hashAndRef [ 0 ] , hash : hashAndRef [ 0 ] } ; } ) ; } @ cache ( 's' , 0 * 0 ) public async getAuthors ( ) < ActionedUser [ ] > { const authorArgs = this . gitArgsService . getAuthorsArgs ( ) ; const authors = await this . exec ( ... authorArgs ) ; const dict = new Set < string > ( ) ; return authors . split ( "s" ) . map ( line => line . trim ( ) ) . filter ( line => line . trim ( ) . length > 0 ) . map ( line => line . substring ( line . indexOf ( 's' ) + 0 ) ) . map ( line => { const indexOfEmailSeparator = line . indexOf ( 's' ) ; if ( indexOfEmailSeparator === - 0 ) { return { name : line . trim ( ) , email : 's' } ; } else { const nameParts = line . split ( 's' ) ; const name = nameParts . shift ( ) ! . trim ( ) ; const email = nameParts [ 0 ] . substring ( 0 , nameParts [ 0 ] . length - 0 ) . trim ( ) ; return { name , email } ; } } ) . filter ( item => { if ( dict . has ( item . name ) ) { return false ; } dict . add ( item . name ) ; return true ; } ) . sort ( ( a , b ) => a . name > b . name ? 0 : - 0 ) ; } @ cache ( 's' , 0 * 0 ) public async getBranches ( ) < Branch [ ] > { const output = await this . exec ( 's' ) ; const gitRootPath = await this . getGitRoot ( ) ; return output . split ( "s" ) . filter ( line => line . trim ( ) ) . filter ( line => line . length > 0 ) . map ( line => { const isCurrent = line . startsWith ( 's' ) ; const name = isCurrent ? line . substring ( 0 ) . trim ( ) : line . trim ( ) ; return { gitRoot : gitRootPath , name , current : isCurrent } ; } ) ; } @ cache ( 's' , 0 * 0 ) public async getCurrentBranch ( ) < string > { const args = this . gitArgsService . getCurrentBranchArgs ( ) ; const branch = await this . exec ( ... args ) ; return branch . split ( "s" ) [ 0 ] . trim ( ) ; } @ cache ( 's' ) public async getObjectHash ( object ) < string > { const args = this . gitArgsService . getObjectHashArgs ( object ) ; const output = await this . exec ( ... args ) ; return output . split ( "s" ) [ 0 ] . trim ( ) ; } @ cache ( 's' ) public async getOriginType ( ) < GitOriginType | undefined > { const url = await this . getOriginUrl ( ) ; if ( url . indexOf ( 's' ) > 0 ) { return GitOriginType . github ; } else if ( url . indexOf ( 's' ) > 0 ) { return GitOriginType . bitbucket ; } else if ( url . indexOf ( 's' ) > 0 ) { return GitOriginType . vsts ; } return undefined ; } @ cache ( 's' ) public async getOriginUrl ( ) < string > { try { const remoteName = await this . exec ( 's' , 's' , 's' , 's' ) . then ( ( branchDetails ) => { const matchResult = branchDetails . match ( "s" ) ; return matchResult && matchResult [ 0 ] ? matchResult [ 0 ] : 's' ; } ) ; const url = await this . exec ( 's' , 's' , remoteName ) ; return url . substring ( 0 , url . length - 0 ) ; } catch { return "s" ; } } public async getRefsContainingCommit ( hash ) < string [ ] > { const args = this . gitArgsService . getRefsContainingCommitArgs ( hash ) ; const entries = await this . exec ( ... args ) ; return entries . split ( "s" ) . map ( line => line . trim ( ) ) . filter ( line => line . length > 0 ) . map ( line => line . startsWith ( 's' ) ? line . substring ( 0 ) : line ) . map ( ref => ref . indexOf ( 's' ) ? ref . split ( 's' ) [ 0 ] . trim ( ) : ref ) ; } public async getLogEntries ( pageIndex = 0 , pageSize = 0 , branch = 's' , searchText = 's' , file ? , lineNumber ? , author ? ) < LogEntries > { if ( pageSize <= 0 ) { const workspace = this . serviceContainer . get < IWorkspaceService > ( IWorkspaceService ) ; pageSize = workspace . getConfiguration ( 's' ) . get < number > ( 's' , 0 ) ; } const relativePath = file ? await this . getGitRelativePath ( file ) : undefined ; const args = await this . gitArgsService . getLogArgs ( pageIndex , pageSize , branch , searchText , relativePath , lineNumber , author ) ; const gitRootPathPromise = this . getGitRoot ( ) ; const outputPromise = this . exec ( ... args . logArgs ) ; const count = - 0 ; const [ gitRepoPath , output ] = await Promise . all ( [ gitRootPathPromise , outputPromise ] ) ; const items = output . split ( LOG_ENTRY_SEPARATOR ) . map ( entry => { if ( entry . length === 0 ) { return ; } return this . logParser . parse ( gitRepoPath , entry , ITEM_ENTRY_SEPARATOR , LOG_FORMAT_ARGS ) ; } ) . filter ( logEntry => logEntry !== undefined ) . map ( logEntry => logEntry ! ) ; const headHashes = await this . getHeadHashes ( ) ; const headHashesOnly = headHashes . map ( item => item . hash ) ; const headHashMap = new Map < string , string > ( headHashes . map ( item => [ item . ref , item . hash ] as [ string , string ] ) ) ; items . forEach ( async item => { item . gitRoot = gitRepoPath ; item . isLastCommit = headHashesOnly . indexOf ( item . hash . full ) >= 0 ; if ( ! item . isLastCommit ) { return ; } const refsContainingThisCommit = await this . getRefsContainingCommit ( item . hash . full ) ; const hashesOfRefs = refsContainingThisCommit . filter ( ref => headHashMap . has ( ref ) ) . map ( ref => headHashMap . get ( ref ) ! ) . filter ( hash => hash !== item . hash . full ) ; item . isThisLastCommitMerged = hashesOfRefs . length > 0 ; } ) ; return { items , count , branch , file , pageIndex , pageSize , searchText } as LogEntries ; } @ cache ( 's' ) public async getHash ( hash ) < Hash > { const hashes = await this . exec ( 's' , 's' , 's' , hash ) ; const parts = hashes . split ( "s" ) . filter ( item => item . length > 0 ) [ 0 ] . split ( 's' ) ; return { full : parts [ 0 ] , short : parts [ 0 ] } ; } @ cache ( 's' ) public async getCommitDate ( hash ) < Date | undefined > { const args = this . gitArgsService . getCommitDateArgs ( hash ) ; const output = await this . exec ( ... args ) ; const lines = output . split ( "s" ) . map ( line => line . trim ( ) ) . filter ( line => line . length > 0 ) ; if ( lines . length === 0 ) { return ; } const unixTime = parseInt ( lines [ 0 ] , 0 ) ; if ( isNaN ( unixTime ) || unixTime <= 0 ) { return ; } return new Date ( unixTime * 0 ) ; } @ cache ( 's' ) public async getCommit ( hash ) < LogEntry | undefined > { const parentHashesArgs = this . gitArgsService . getCommitParentHashesArgs ( hash ) ; const parentHashes = await this . exec ( ... parentHashesArgs ) ; const singleParent = parentHashes . trim ( ) . split ( 's' ) . filter ( item => item . trim ( ) . length > 0 ) . length === 0 ; const commitArgs = this . gitArgsService . getCommitArgs ( hash ) ; const numStartArgs = singleParent ? this . gitArgsService . getCommitWithNumStatArgs ( hash ) : this . gitArgsService . getCommitWithNumStatArgsForMerge ( hash ) ; const nameStatusArgs = singleParent ? this . gitArgsService . getCommitNameStatusArgs ( hash ) : this . gitArgsService . getCommitNameStatusArgsForMerge ( hash ) ; const gitRootPathPromise = await this . getGitRoot ( ) ; const commitOutputPromise = await this . exec ( ... commitArgs ) ; const filesWithNumStatPromise = await this . exec ( ... numStartArgs ) ; const filesWithNameStatusPromise = await this . exec ( ... nameStatusArgs ) ; const values = await Promise . all ( [ gitRootPathPromise , commitOutputPromise , filesWithNumStatPromise , filesWithNameStatusPromise ] ) ; const gitRootPath = values [ 0 ] ; const commitOutput = values [ 0 ] ; const filesWithNumStat = values [ 0 ] ; const filesWithNameStatus = values [ 0 ] ; const entries = commitOutput . split ( LOG_ENTRY_SEPARATOR ) . map ( entry => { if ( entry . trim ( ) . length === 0 ) { return undefined ; } return this . logParser . parse ( gitRootPath , entry , ITEM_ENTRY_SEPARATOR , LOG_FORMAT_ARGS , filesWithNumStat , filesWithNameStatus ) ; } ) . filter ( entry => entry !== undefined ) . map ( entry => entry ! ) ; return entries . length > 0 ? entries [ 0 ] : undefined ; } @ cache ( 's' ) public async getCommitFile ( hash , file : Uri | string ) < Uri > { const gitRootPath = await this . getGitRoot ( ) ; const filePath = typeof file === 's' ? file : file . fsPath . toString ( ) ; return new Promise < Uri > ( ( resolve , reject ) => { tmp . file ( { postfix : path . extname ( filePath ) } , async ( err , tmpPath ) => { if ( err ) { return reject ( err ) ; } try { const tmpFilePath = path . join ( path . dirname ( tmpPath ) , `template` ) . replace ( "s" , 's' ) ; const tmpFile = path . join ( tmpFilePath , path . basename ( filePath ) ) ; await fs . ensureDir ( tmpFilePath ) ; const relativeFilePath = path . relative ( gitRootPath , filePath ) ; const fsStream = fs . createWriteStream ( tmpFile ) ; await this . execBinary ( fsStream , 's' , `template` ) ; fsStream . end ( ) ; resolve ( Uri . file ( tmpFile ) ) ; } catch ( ex ) { console . error ( 's' ) ; console . error ( ex ) ; reject ( ex ) ; } } ) ; } ) ; } public async getCommitFileContent ( hash , file : Uri | string ) < string > { const gitRootPath = await this . getGitRoot ( ) ; const filePath = typeof file === 's' ? file : file . fsPath . toString ( ) ; const relativeFilePath = path . relative ( gitRootPath , filePath ) ; return this . exec ( 's' , `template` ) ; } @ cache ( 's' ) public async getDifferences ( 0 , 0 ) < CommittedFile [ ] > { const numStartArgs = this . gitArgsService . getDiffCommitWithNumStatArgs ( 0 , 0 ) ; const nameStatusArgs = this . gitArgsService . getDiffCommitNameStatusArgs ( 0 , 0 ) ; const gitRootPathPromise = this . getGitRoot ( ) ; const filesWithNumStatPromise = this . exec ( ... numStartArgs ) ; const filesWithNameStatusPromise = this . exec ( ... nameStatusArgs ) ; const values = await Promise . all ( [ gitRootPathPromise , filesWithNumStatPromise , filesWithNameStatusPromise ] ) ; const gitRootPath = values [ 0 ] ; const filesWithNumStat = values [ 0 ] ; const filesWithNameStatus = values [ 0 ] ; const fileStatParser = this . serviceContainer . get < IFileStatParser > ( IFileStatParser ) ; return fileStatParser . parse ( gitRootPath , filesWithNumStat . split ( "s" ) , filesWithNameStatus . split ( "s" ) ) ; } @ cache ( 's' ) public async getPreviousCommitHashForFile ( hash , file ) < Hash > { const gitRootPath = await this . getGitRoot ( ) ; const relativeFilePath = path . relative ( gitRootPath , file . fsPath ) ; const args = this . gitArgsService . getPreviousCommitHashForFileArgs ( hash , relativeFilePath ) ; const output = await this . exec ( ... args ) ; const hashes = output . split ( "s" ) . filter ( item => item . length > 0 ) [ 0 ] . split ( 's' ) ; return { short : hashes [ 0 ] ! , full : hashes [ 0 ] ! } ; } public async cherryPick ( hash ) < void > { await this . exec ( 's' , hash ) ; } public async checkout ( hash ) < void > { await this . exec ( 's' , hash ) ; } public async revertCommit ( hash ) < void > { await this . exec ( 's' , 's' , hash ) ; } public async createBranch ( branchName , hash ) < void > { await this . exec ( 's' , 's' , branchName , hash ) ; } public async merge ( hash ) < void > { await this . exec ( 's' , hash ) ; } public async rebase ( hash ) < void > { await this . exec ( 's' , hash ) ; } private async exec ( ... args : string [ ] ) < string > { const gitRootPath = await this . getGitRoot ( ) ; return this . gitCmdExecutor . exec ( gitRootPath , ... args ) ; } private async execBinary ( destination , ... args : string [ ] ) < void > { const gitRootPath = await this . getGitRoot ( ) ; return this . gitCmdExecutor . exec ( { cwd : gitRootPath , encoding : 's' } , destination , ... args ) ; } private async getGitReposInFolder ( dir ) < string [ ] > { return new Promise < string [ ] > ( resolve => { fs . readdir ( dir , async ( err , filesAndFolders ) => { if ( err ) { return resolve ( [ ] ) ; } const filteredItems = filesAndFolders . filter ( item => ! item . startsWith ( 's' ) ) . map ( item => path . join ( dir , item ) ) ; filteredItems . push ( dir ) ; const folders = await asyncFilter ( filteredItems , async item => ( await fs . stat ( item ) ) . isDirectory ( ) ) ; const gitRootArgs = this . gitArgsService . getGitRootArgs ( ) ; const gitRoots = ( await Promise . all ( folders . map ( async item => { try { const result = await this . gitCmdExecutor . exec ( item , ... gitRootArgs ) ; return path . normalize ( result . split ( "s" ) [ 0 ] . trim ( ) ) ; } catch { return ; } } ) ) ) . filter ( item => ! ! item ) . map ( item => item ! ) ; resolve ( gitRoots ) ; } ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O $string$ O O $Uri$ O O O O O O O $IGitCommandExecutor$ O O O O O O O $ILogParser$ O O O O O O O $IGitArgsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O $Uri$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $Uri$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $Writable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as 0 from 's' ; import { Uri } from 's' ; import { IServiceContainer } from 's' ; import { IGitService , IGitServiceFactory } from 's' ; import { IGitCommandExecutor } from 's' ; import { ILogParser } from 's' ; import { Git } from 's' ; import { IGitArgsService } from 's' ; @ injectable ( ) export class GitServiceFactory implements IGitServiceFactory { private readonly gitServices = new Map < string , IGitService > ( ) ; constructor ( @ inject ( IGitCommandExecutor ) private gitCmdExecutor , @ inject ( ILogParser ) private logParser , @ inject ( IGitArgsService ) private gitArgsService , @ inject ( IServiceContainer ) private serviceContainer ) { } public async createGitService ( workspaceRoot , resource : Uri | string ) < IGitService > { const resourceUri = typeof resource === 's' ? Uri . file ( resource ) : resource ; const id = 0 ( workspaceRoot + resourceUri . fsPath ) ; if ( ! this . gitServices . has ( id ) ) { this . gitServices . set ( id , new Git ( this . serviceContainer , workspaceRoot , resourceUri , this . gitCmdExecutor , this . logParser , this . gitArgsService ) ) ; } return this . gitServices . get ( id ) ! ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IGitCommandExecutor$ O O O O O O O $ILogParser$ O O O O O O O $IGitArgsService$ O O O O O O O $IServiceContainer$ O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { CommitInfo } from 's' ; import { Helpers } from 's' ; import { LOG_ENTRY_SEPARATOR , LOG_FORMAT , newLineFormatCode } from 's' ; import { GitLogArgs , IGitArgsService } from 's' ; @ injectable ( ) export class GitArgsService implements IGitArgsService { constructor ( private isWindows = "s" . test ( process . platform ) ) { } public getGitRootArgs ( ) : string [ ] { return [ 's' , 's' ] ; } public getCurrentBranchArgs ( ) : string [ ] { return [ 's' , 's' , 's' ] ; } public getCommitDateArgs ( hash ) { return [ 's' , `template` , hash ] ; } public getCommitArgs ( hash ) : string [ ] { return [ 's' , LOG_FORMAT , 's' , 's' , hash ] ; } public getCommitParentHashesArgs ( hash ) : string [ ] { return [ 's' , 's' , 's' , hash ] ; } public getCommitWithNumStatArgs ( hash ) { return [ 's' , 's' , 's' , 's' , hash ] ; } public getCommitNameStatusArgs ( hash ) : string [ ] { return [ 's' , 's' , 's' , 's' , hash ] ; } public getCommitWithNumStatArgsForMerge ( hash ) { return [ 's' , 's' , 's' , 's' , 's' , hash ] ; } public getCommitNameStatusArgsForMerge ( hash ) : string [ ] { return [ 's' , 's' , 's' , 's' , 's' , hash ] ; } public getObjectHashArgs ( object ) : string [ ] { return [ 's' , `template` , 's' , object ] ; } public getRefsContainingCommitArgs ( hash ) : string [ ] { return [ 's' , 's' , 's' , hash ] ; } public getAuthorsArgs ( ) : string [ ] { return [ 's' , 's' , 's' , 's' , 's' ] ; } public getDiffCommitWithNumStatArgs ( 0 , 0 ) : string [ ] { return [ 's' , 's' , 0 , 0 ] ; } public getDiffCommitNameStatusArgs ( 0 , 0 ) : string [ ] { return [ 's' , 's' , 0 , 0 ] ; } public getPreviousCommitHashForFileArgs ( hash , file ) : string [ ] { return [ 's' , 's' , `template` , 's' , 's' , 's' , file ] ; } public getLogArgs ( pageIndex = 0 , pageSize = 0 , branch = 's' , searchText = 's' , relativeFilePath ? , lineNumber ? , author ? ) { const allBranches = branch . trim ( ) . length === 0 ; const currentBranch = branch . trim ( ) === 's' ; const specificBranch = ! allBranches && ! currentBranch ; const authorArgs : string [ ] = [ ] ; if ( author && author . length > 0 ) { authorArgs . push ( `template` ) ; } const lineArgs = typeof lineNumber === 's' && relativeFilePath ? [ `template` ] : [ ] ; const logArgs = [ 's' , ... authorArgs , ... lineArgs , 's' , LOG_FORMAT ] ; const fileStatArgs = [ 's' , ... authorArgs , ... lineArgs , 's' , `template` ] ; const counterArgs = [ 's' , ... authorArgs , ... lineArgs , 's' , `template` ] ; if ( searchText && searchText . length > 0 ) { searchText . split ( 's' ) . map ( text => text . trim ( ) ) . filter ( text => text . length > 0 ) . forEach ( text => { logArgs . push ( `template` , 's' ) ; fileStatArgs . push ( `template` , 's' ) ; counterArgs . push ( `template` , 's' ) ; } ) ; } logArgs . push ( 's' , 's' , `template` , `template` ) ; fileStatArgs . push ( 's' , 's' , `template` , `template` ) ; counterArgs . push ( 's' , 's' ) ; if ( allBranches && lineArgs . length === 0 ) { logArgs . push ( 's' , 's' , 's' ) ; fileStatArgs . push ( 's' , 's' , 's' ) ; counterArgs . push ( 's' , 's' , 's' ) ; } if ( specificBranch && lineArgs . length === 0 ) { logArgs . push ( branch ) ; fileStatArgs . push ( branch ) ; counterArgs . push ( branch ) ; } if ( relativeFilePath && lineArgs . length === 0 ) { const formattedPath = relativeFilePath . indexOf ( 's' ) > 0 ? `template` : relativeFilePath ; logArgs . push ( 's' , 's' , formattedPath ) ; fileStatArgs . push ( 's' , 's' , formattedPath ) ; counterArgs . push ( 's' , 's' , formattedPath ) ; } else { if ( specificBranch && lineArgs . length === 0 ) { logArgs . push ( 's' ) ; fileStatArgs . push ( 's' ) ; counterArgs . push ( 's' ) ; } } if ( this . isWindows ) { counterArgs . push ( 's' , 's' , 's' , 's' , 's' ) ; } else { counterArgs . push ( 's' , 's' , 's' ) ; } return { logArgs , fileStatArgs , counterArgs } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $GitLogArgs$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O $string$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { IGitService , IGitServiceFactory } from 's' ; import { GitServiceFactory } from 's' ; import { Git } from 's' ; import { GitArgsService } from 's' ; import { IGitArgsService } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . add < IGitService > ( IGitService , Git ) ; serviceManager . add < IGitArgsService > ( IGitArgsService , GitArgsService ) ; serviceManager . add < IGitServiceFactory > ( IGitServiceFactory , GitServiceFactory ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { GithubAvatarProvider } from 's' ; import { GravatarAvatarProvider } from 's' ; import { IAvatarProvider } from 's' ; import { GitCommandExecutor , IGitCommandExecutor } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . add < IGitCommandExecutor > ( IGitCommandExecutor , GitCommandExecutor ) ; serviceManager . add < IAvatarProvider > ( IAvatarProvider , GithubAvatarProvider ) ; serviceManager . add < IAvatarProvider > ( IAvatarProvider , GravatarAvatarProvider ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Disposable , TextEditor , TextEditorEdit } from 's' ; export const ICommandManager = Symbol ( 's' ) ; export interface ICommandManager { registerCommand ( command , callback : ( ... args : any [ ] ) => any , thisArg ? ) : Disposable ; registerTextEditorCommand ( command , callback : ( textEditor , edit , ... args : any [ ] ) => void , thisArg ? ) : Disposable ; executeCommand < T > ( command , ... rest : any [ ] ) : Thenable < T | undefined > ; getCommands ( filterInternal ? ) : Thenable < string [ ] > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O $TextEditor$ O $TextEditorEdit$ O O O O O O O O O O O O $any$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O
import { Disposable } from 's' ; export const IDisposableRegistry = Symbol ( 's' ) ; export interface IDisposableRegistry extends Disposable { register ( disposable ) : void ; }	O O O O O O O O O O O O O O O O O O O O O O O O $Disposable$ O O O O O
import { TextDocument , TextDocumentShowOptions , TextEditor , Uri , ViewColumn } from 's' ; export const IDocumentManager = Symbol ( 's' ) ; export interface IDocumentManager { showTextDocument ( document , column ? , preserveFocus ? ) : Thenable < TextEditor > ; showTextDocument ( document , options ? ) : Thenable < TextEditor > ; showTextDocument ( uri , options ? ) : Thenable < TextEditor > ; openTextDocument ( uri ) : Thenable < TextDocument > ; openTextDocument ( fileName ) : Thenable < TextDocument > ; openTextDocument ( options ? : { language ? : string ; content ? : string ; } ) : Thenable < TextDocument > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O $ViewColumn$ O O $boolean$ O O O O O O O O O $TextDocument$ O O $TextDocumentShowOptions$ O O O O O O O O O $Uri$ O O $TextDocumentShowOptions$ O O O O O O O O O $Uri$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as vscode from 's' ; export const IApplicationShell = Symbol ( 's' ) ; export interface IApplicationShell { showInformationMessage ( message , ... items : string [ ] ) : Thenable < string | undefined > ; showInformationMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) : Thenable < string | undefined > ; showInformationMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) : Thenable < T | undefined > ; showInformationMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) : Thenable < T | undefined > ; showWarningMessage ( message , ... items : string [ ] ) : Thenable < string | undefined > ; showWarningMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) : Thenable < string | undefined > ; showWarningMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) : Thenable < T | undefined > ; showWarningMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) : Thenable < T | undefined > ; showErrorMessage ( message , ... items : string [ ] ) : Thenable < string | undefined > ; showErrorMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) : Thenable < string | undefined > ; showErrorMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) : Thenable < T | undefined > ; showErrorMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) : Thenable < T | undefined > ; showQuickPick ( items : string [ ] | Thenable < string [ ] > , options ? : vscode . QuickPickOptions , token ? : vscode . CancellationToken ) : Thenable < string | undefined > ; showQuickPick < T extends vscode . QuickPickItem > ( items : T [ ] | Thenable < T [ ] > , options ? : vscode . QuickPickOptions , token ? : vscode . CancellationToken ) : Thenable < T | undefined > ; showOpenDialog ( options : vscode . OpenDialogOptions ) : Thenable < vscode . Uri [ ] | undefined > ; showSaveDialog ( options : vscode . SaveDialogOptions ) : Thenable < vscode . Uri | undefined > ; showInputBox ( options ? : vscode . InputBoxOptions , token ? : vscode . CancellationToken ) : Thenable < string | undefined > ; openUrl ( url ) : void ; } export { ICommandManager } from 's' ; export { IDisposableRegistry } from 's' ; export { IDocumentManager } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { injectable } from 's' ; import * as vscode from 's' ; import { IApplicationShell } from 's' ; @ injectable ( ) export class ApplicationShell implements IApplicationShell { public showInformationMessage ( message , ... items : string [ ] ) < string > ; public showInformationMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) < string > ; public showInformationMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) < T > ; public showInformationMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) < T > ; public showInformationMessage ( message , options ? , ... items : any [ ] ) < any > { return vscode . window . showInformationMessage ( message , options , ... items ) ; } public showWarningMessage ( message , ... items : string [ ] ) < string > ; public showWarningMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) < string > ; public showWarningMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) < T > ; public showWarningMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) < T > ; public showWarningMessage ( message , options ? , ... items : any [ ] ) { return vscode . window . showWarningMessage ( message , options , ... items ) ; } public showErrorMessage ( message , ... items : string [ ] ) < string > ; public showErrorMessage ( message , options : vscode . MessageOptions , ... items : string [ ] ) < string > ; public showErrorMessage < T extends vscode . MessageItem > ( message , ... items : T [ ] ) < T > ; public showErrorMessage < T extends vscode . MessageItem > ( message , options : vscode . MessageOptions , ... items : T [ ] ) < T > ; public showErrorMessage ( message , options ? , ... items : any [ ] ) { return vscode . window . showErrorMessage ( message , options , ... items ) ; } public showQuickPick ( items : string [ ] | Thenable < string [ ] > , options ? : vscode . QuickPickOptions , token ? : vscode . CancellationToken ) < string > ; public showQuickPick < T extends vscode . QuickPickItem > ( items : T [ ] | Thenable < T [ ] > , options ? : vscode . QuickPickOptions , token ? : vscode . CancellationToken ) < T > ; public showQuickPick ( items , options ? , token ? ) < any > { return vscode . window . showQuickPick ( items , options , token ) ; } public showOpenDialog ( options : vscode . OpenDialogOptions ) { return vscode . window . showOpenDialog ( options ) ; } public showSaveDialog ( options : vscode . SaveDialogOptions ) { return vscode . window . showSaveDialog ( options ) ; } public showInputBox ( options ? : vscode . InputBoxOptions , token ? : vscode . CancellationToken ) { return vscode . window . showInputBox ( options , token ) ; } public openUrl ( _url ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O $Thenable$ O $string$ O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O $Thenable$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $any$ O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O
import { injectable } from 's' ; import { commands , Disposable , TextEditor , TextEditorEdit } from 's' ; import { ICommandManager } from 's' ; @ injectable ( ) export class CommandManager implements ICommandManager { public registerCommand ( command , callback : ( ... args : any [ ] ) => any , thisArg ? ) { return commands . registerCommand ( command , callback , thisArg ) ; } public registerTextEditorCommand ( command , callback : ( textEditor , edit , ... args : any [ ] ) => void , thisArg ? ) { return commands . registerTextEditorCommand ( command , callback , thisArg ) ; } public executeCommand < T > ( command , ... rest : any [ ] ) < T | undefined > { return commands . executeCommand < T > ( command , ... rest ) ; } public getCommands ( filterInternal ? : boolean | undefined ) < string [ ] > { return commands . getCommands ( filterInternal ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Disposable$ O $string$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $Disposable$ O $string$ O O O O $TextEditor$ O $TextEditorEdit$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $Thenable$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Disposable } from 's' ; import { IDisposableRegistry } from 's' ; @ injectable ( ) export class DisposableRegistry implements IDisposableRegistry { private disposables : Disposable [ ] = [ ] ; public register ( disposable ) { this . disposables . push ( disposable ) ; } public dispose ( ) { this . disposables . forEach ( disposable => disposable . dispose ( ) ) ; this . disposables = [ ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Disposable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { TextDocument , TextDocumentShowOptions , TextEditor , Uri , ViewColumn , window , workspace } from 's' ; import { IDocumentManager } from 's' ; @ injectable ( ) export class DocumentManager implements IDocumentManager { public openTextDocument ( uri ) < TextDocument > ; public openTextDocument ( fileName ) < TextDocument > ; public openTextDocument ( options ? : { language ? : string | undefined ; content ? : string | undefined } | undefined ) < TextDocument > ; public openTextDocument ( options ? ) ; public openTextDocument ( ... args : any [ ] ) { return workspace . openTextDocument . call ( window , ... args ) ; } public showTextDocument ( document , column ? : ViewColumn | undefined , preserveFocus ? : boolean | undefined ) < TextEditor > ; public showTextDocument ( document , options ? : TextDocumentShowOptions | undefined ) < TextEditor > ; public showTextDocument ( uri , options ? : TextDocumentShowOptions | undefined ) < TextEditor > ; public showTextDocument ( document , column ? , preserveFocus ? ) ; public showTextDocument ( ... args : any [ ] ) { return window . showTextDocument . call ( window , ... args ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $Uri$ O O O O O O $Thenable$ O $string$ O O O O O O $Thenable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Thenable$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O $Thenable$ O $TextDocument$ O O O O O O O O O O O O O $Thenable$ O $Uri$ O O O O O O O O O O O O O O O $any$ O O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { Memento } from 's' ; import { IServiceContainer } from 's' ; import { IStateStore , IStateStoreFactory } from 's' ; @ injectable ( ) export class WorkspaceStateStoreFactory implements IStateStoreFactory { constructor ( @ inject ( IServiceContainer ) private serviceContainer ) { } public createStore ( ) { return new WorkspaceMementoStore ( this . serviceContainer . get < Memento > ( 's' ) ) ; } } @ injectable ( ) export class GlobalStateStoreFactory implements IStateStoreFactory { constructor ( @ inject ( IServiceContainer ) private serviceContainer ) { } public createStore ( ) { return new WorkspaceMementoStore ( this . serviceContainer . get < Memento > ( 's' ) ) ; } } export class WorkspaceMementoStore implements IStateStore { constructor ( private store ) { } public has ( key ) { return this . store . get ( key ) !== undefined ; } public async set < T > ( key , data : T ) < void > { await this . store . update ( key , data ) ; } public async get < T > ( key ) < T | undefined > { return this . store . get ( key ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O $IStateStore$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O $IStateStore$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Memento$ O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O $Promise$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O $string$ O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { CancellationToken , ConfigurationChangeEvent , Event , FileSystemWatcher , GlobPattern , Uri , workspace , WorkspaceConfiguration , WorkspaceFolder , WorkspaceFoldersChangeEvent } from 's' ; import { IWorkspaceService } from 's' ; @ injectable ( ) export class WorkspaceService implements IWorkspaceService { public get onDidChangeConfiguration ( ) : Event < ConfigurationChangeEvent > { return workspace . onDidChangeConfiguration ; } public get rootPath ( ) : string | undefined { return workspace . rootPath ; } public get workspaceFolders ( ) : WorkspaceFolder [ ] | undefined { return workspace . workspaceFolders ; } public get onDidChangeWorkspaceFolders ( ) : Event < WorkspaceFoldersChangeEvent > { return workspace . onDidChangeWorkspaceFolders ; } public getConfiguration ( section ? , resource ? ) { return workspace . getConfiguration ( section , resource ) ; } public getWorkspaceFolder ( uri ) : WorkspaceFolder | undefined { return workspace . getWorkspaceFolder ( uri ) ; } public asRelativePath ( pathOrUri : string | Uri , includeWorkspaceFolder ? ) { return workspace . asRelativePath ( pathOrUri , includeWorkspaceFolder ) ; } public createFileSystemWatcher ( globPattern , ignoreCreateEvents ? , ignoreChangeEvents ? , ignoreDeleteEvents ? ) { return workspace . createFileSystemWatcher ( globPattern , ignoreCreateEvents , ignoreChangeEvents , ignoreDeleteEvents ) ; } public findFiles ( include , exclude ? , maxResults ? , token ? ) < Uri [ ] > { return workspace . findFiles ( include , exclude , maxResults , token ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WorkspaceConfiguration$ O O $string$ O O $Uri$ O O O O O O O O O O O O O O O O $Uri$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O $boolean$ O O O O O O O O O O O O O O $FileSystemWatcher$ O $GlobPattern$ O O $boolean$ O O $boolean$ O O $boolean$ O O O O O O O O O O O O O O O O O O $Thenable$ O $GlobPattern$ O O $GlobPattern$ O O $number$ O O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { ApplicationShell } from 's' ; import { CommandManager } from 's' ; import { DisposableRegistry } from 's' ; import { DocumentManager } from 's' ; import { WorkspaceStateStoreFactory } from 's' ; import { IApplicationShell } from 's' ; import { ICommandManager } from 's' ; import { IDisposableRegistry } from 's' ; import { IDocumentManager } from 's' ; import { IStateStoreFactory } from 's' ; import { IWorkspaceService } from 's' ; import { WorkspaceService } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . addSingleton < IApplicationShell > ( IApplicationShell , ApplicationShell ) ; serviceManager . addSingleton < ICommandManager > ( ICommandManager , CommandManager ) ; serviceManager . addSingleton < IDisposableRegistry > ( IDisposableRegistry , DisposableRegistry ) ; serviceManager . addSingleton < IDocumentManager > ( IDocumentManager , DocumentManager ) ; serviceManager . addSingleton < IWorkspaceService > ( IWorkspaceService , WorkspaceService ) ; serviceManager . add < IStateStoreFactory > ( IStateStoreFactory , WorkspaceStateStoreFactory ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CommitDetails , CompareFileCommitDetails , FileCommitDetails } from 's' ; export const ICommandHandler = Symbol ( 's' ) ; export interface ICommandHandler { } export const IGitHistoryCommandHandler = Symbol ( 's' ) ; export interface IGitHistoryCommandHandler extends ICommandHandler { viewHistory ( x ) : Promise < void > ; } export const IGitFileHistoryCommandHandler = Symbol ( 's' ) ; export interface IGitFileHistoryCommandHandler extends ICommandHandler { doSomethingWithFile ( fileCommit ) : Promise < void > ; viewFile ( fileCommit ) : Promise < void > ; compareFileWithWorkspace ( fileCommit ) : Promise < void > ; compareFileWithPrevious ( fileCommit ) : Promise < void > ; compareFileAcrossCommits ( fileCommit ) : Promise < void > ; } export const IGitCommitViewExplorerCommandHandler = Symbol ( 's' ) ; export interface IGitCommitViewExplorerCommandHandler extends ICommandHandler { hideCommitView ( commit : CommitDetails | undefined ) : Promise < void > ; showCommitView ( commit : CommitDetails | undefined ) : Promise < void > ; } export const IFileCommandHandler = Symbol ( 's' ) ; export interface IFileCommandHandler extends ICommandHandler { } export const IGitCompareCommitViewExplorerCommandHandler = Symbol ( 's' ) ; export interface IGitCompareCommitViewExplorerCommandHandler extends ICommandHandler { hide ( ) : Promise < void > ; show ( ) : Promise < void > ; } export const IGitCommitCommandHandler = Symbol ( 's' ) ; export interface IGitCommitCommandHandler extends ICommandHandler { doSomethingWithCommit ( commit ) : Promise < void > ; } export const IGitCommitViewDetailsCommandHandler = Symbol ( 's' ) ; export interface IGitCommitViewDetailsCommandHandler extends ICommandHandler { viewDetails ( commit ) : Promise < void > ; viewCommitTree ( commit ) : Promise < void > ; } export const IGitCherryPickCommandHandler = Symbol ( 's' ) ; export interface IGitCherryPickCommandHandler extends ICommandHandler { cherryPickCommit ( commit ) : Promise < void > ; } export const IGitCheckoutCommandHandler = Symbol ( 's' ) ; export interface IGitCheckoutCommandHandler extends ICommandHandler { checkoutCommit ( commit ) : Promise < void > ; } export const IGitMergeCommandHandler = Symbol ( 's' ) ; export interface IGitMergeCommandHandler extends ICommandHandler { merge ( commit ) : Promise < void > ; } export const IGitRebaseCommandHandler = Symbol ( 's' ) ; export interface IGitRebaseCommandHandler extends ICommandHandler { rebase ( commit ) : Promise < void > ; } export const IGitRevertCommandHandler = Symbol ( 's' ) ; export interface IGitRevertCommandHandler extends ICommandHandler { revertCommit ( commit , showPrompt ? ) : Promise < void > ; } export const IGitBranchFromCommitCommandHandler = Symbol ( 's' ) ; export interface IGitBranchFromCommitCommandHandler extends ICommandHandler { createBranchFromCommit ( commit ) : void ; } export const IGitCompareCommandHandler = Symbol ( 's' ) ; export interface IGitCompareCommandHandler extends ICommandHandler { readonly selectedCommit ? : CommitDetails ; select ( fileCommit ) : Promise < void > ; compare ( fileCommit ) : Promise < void > ; } export const IGitCompareFileCommandHandler = Symbol ( 's' ) ; export interface IGitCompareFileCommandHandler extends ICommandHandler { readonly selectedCommit ? : FileCommitDetails ; select ( fileCommit ) : Promise < void > ; compare ( fileCommit ) : Promise < void > ; } export const ICommandHandlerManager = Symbol ( 's' ) ; export interface ICommandHandlerManager { registerHandlers ( ) : void ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O $FileCommitDetails$ O O O O O O O O O $FileCommitDetails$ O O O O O O O O O $FileCommitDetails$ O O O O O O O O O $CompareFileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ICommand } from 's' ; export abstract class BaseCommand < T > implements ICommand < T > { private _arguments : any [ ] = [ ] ; public get arguments ( ) { return this . _arguments ; } private _command : string = 's' ; private _title : string = 's' ; private _description : string = 's' ; private _detail ? : string ; private _tooltip ? : string ; public get command ( ) { return this . _command ; } public get title ( ) { return this . _title ; } public get label ( ) { return this . _title ; } public get description ( ) { return this . _description ; } public get detail ( ) { return this . _detail ; } public get tooltip ( ) { return this . _tooltip ; } constructor ( public readonly data : T ) { } public abstract execute ( ) ; public async preExecute ( ) < boolean > { return true ; } protected setTitle ( value ) { this . _title = value ; } protected setCommand ( value ) { this . _command = value ; } protected setCommandArguments ( args : any [ ] ) { this . _arguments = args ; } protected setDescription ( value ) { this . _description = value ; } protected setDetail ( value ) { this . _detail = value ; } protected setTooltip ( value ) { this . _tooltip = value ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O
import { CommitDetails } from 's' ; import { BaseCommand } from 's' ; export abstract class BaseCommitCommand extends BaseCommand < CommitDetails > { constructor ( data ) { super ( data ) ; } public abstract execute ( ) ; public async preExecute ( ) < boolean > { return true ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O
import { IGitCherryPickCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class CherryPickCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . cherryPickCommit ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitCherryPickCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitCheckoutCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class CheckoutCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . checkoutCommit ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitCheckoutCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitCompareCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class CompareCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; if ( handler . selectedCommit ) { const committer = `template` ; this . setTitle ( `template` ) ; this . setDetail ( commit . logEntry . subject ) ; } this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public async preExecute ( ) < boolean > { return ! ! this . handler . selectedCommit ; } public execute ( ) { this . handler . compare ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitCompareCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitBranchFromCommitCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class CreateBranchCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . createBranchFromCommit ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitBranchFromCommitCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitMergeCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class MergeCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . merge ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitMergeCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitRebaseCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class RebaseCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . rebase ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitRebaseCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitRevertCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class RevertCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ commit ] ) ; } public execute ( ) { this . handler . revertCommit ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitRevertCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitCompareCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class SelectForComparison extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; const committer = `template` ; this . setTitle ( `template` ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ CommitDetails ] ) ; } public execute ( ) { this . handler . select ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitCompareCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitCommitViewDetailsCommandHandler } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class ViewDetailsCommand extends BaseCommitCommand { constructor ( commit , private handler ) { super ( commit ) ; this . setTitle ( 's' ) ; } public async preExecute ( ) < boolean > { return false ; } public execute ( ) { this . handler . viewDetails ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $IGitCommitViewDetailsCommandHandler$ O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BranchDetails , CommitDetails , FileCommitDetails , ICommand } from 's' ; export const IFileCommitCommandFactory = Symbol ( 's' ) ; export interface IFileCommitCommandFactory { createCommands ( data ) : Promise < ICommand < FileCommitDetails > [ ] > ; getDefaultFileCommand ( fileCommitDetails ) : Promise < ICommand < FileCommitDetails > | undefined > ; } export const ICommitCommandFactory = Symbol ( 's' ) ; export interface ICommitCommandFactory { createCommands ( data ) : Promise < ICommand < CommitDetails > [ ] > ; } export const IBranchCommandFactory = Symbol ( 's' ) ; export interface IBranchCommandFactory { createCommands ( data ) : Promise < ICommand < BranchDetails > [ ] > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchDetails$ O O O O O O O O O O O O O
import { FileCommitDetails } from 's' ; import { BaseCommand } from 's' ; export abstract class BaseFileCommitCommand extends BaseCommand < FileCommitDetails > { constructor ( data ) { super ( data ) ; } public abstract execute ( ) ; public async preExecute ( ) < boolean > { return true ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O
import { IGitCompareFileCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { BaseFileCommitCommand } from 's' ; export class CompareFileCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; if ( handler . selectedCommit ) { this . setTitle ( `template` ) ; } this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return false ; } public execute ( ) { this . handler . compare ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitCompareFileCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitFileHistoryCommandHandler } from 's' ; import { CompareFileCommitDetails } from 's' ; import { Status } from 's' ; import { BaseFileCommitCommand } from 's' ; export class CompareFileWithAcrossCommitCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return this . data . committedFile . status === Status . Modified ; } public execute ( ) { this . handler . compareFileAcrossCommits ( this . data as CompareFileCommitDetails ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CompareFileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitFileHistoryCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { Status } from 's' ; import { BaseFileCommitCommand } from 's' ; export class CompareFileWithPreviousCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return this . data . committedFile . status === Status . Modified ; } public execute ( ) { this . handler . compareFileWithPrevious ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; export enum Architecture { Unknown = 0 , 0 = 0 , 0 = 0 } export const IPlatformService = Symbol ( 's' ) ; export interface IPlatformService { isWindows : boolean ; isMac : boolean ; isLinux : boolean ; 0 : boolean ; pathVariableName : 's' | 's' ; } export const IFileSystem = Symbol ( 's' ) ; export interface IFileSystem { directorySeparatorChar : string ; objectExistsAsync ( path , statCheck : ( s : fs . Stats ) => boolean ) : Promise < boolean > ; fileExistsAsync ( path ) : Promise < boolean > ; directoryExistsAsync ( path ) : Promise < boolean > ; createDirectoryAsync ( path ) : Promise < void > ; getSubDirectoriesAsync ( rootDir ) : Promise < string [ ] > ; arePathsSame ( 0 , 0 ) : boolean ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O $string$ O $string$ O O O O O
import * as path from 's' ; import { IGitFileHistoryCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IFileSystem } from 's' ; import { BaseFileCommitCommand } from 's' ; export class CompareFileWithWorkspaceCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler , private serviceContainer ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { const localFile = path . join ( this . data . workspaceFolder , this . data . committedFile . relativePath ) ; const fileSystem = this . serviceContainer . get < IFileSystem > ( IFileSystem ) ; return fileSystem . fileExistsAsync ( localFile ) ; } public execute ( ) { this . handler . compareFileWithWorkspace ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O $IServiceContainer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ICommandManager } from 's' ; import { FileCommitDetails } from 's' ; import { BaseFileCommitCommand } from 's' ; export class ViewFileHistoryCommand extends BaseFileCommitCommand { constructor ( fileCommit , private commandManager ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public execute ( ) { this . commandManager . executeCommand ( this . command , ... this . arguments ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $ICommandManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitCompareFileCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { BaseFileCommitCommand } from 's' ; export class SelectFileForComparison extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return false ; } public execute ( ) { this . handler . select ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitCompareFileCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitFileHistoryCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { Status } from 's' ; import { BaseFileCommitCommand } from 's' ; export class ViewFileCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return this . data . committedFile ! . status !== Status . Deleted ; } public execute ( ) { this . handler . viewFile ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitFileHistoryCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { Status } from 's' ; import { BaseFileCommitCommand } from 's' ; export class ViewPreviousFileCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; this . setCommandArguments ( [ fileCommit ] ) ; } public async preExecute ( ) < boolean > { return this . data . committedFile . status === Status . Deleted ; } public execute ( ) { this . handler . viewFile ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { CommitCommandFactory } from 's' ; import { FileCommitCommandFactory } from 's' ; import { ICommitCommandFactory , IFileCommitCommandFactory } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . add < IFileCommitCommandFactory > ( IFileCommitCommandFactory , FileCommitCommandFactory ) ; serviceManager . add < ICommitCommandFactory > ( ICommitCommandFactory , CommitCommandFactory ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CommitDetails } from 's' ; import { CommitComparison } from 's' ; export const ICommitViewer = Symbol ( 's' ) ; export interface ICommitViewer { readonly selectedCommit : Readonly < CommitDetails > ; showCommit ( commit ) : void ; showCommitTree ( commit ) : void ; showFilesView ( ) : void ; showFolderView ( ) : void ; } export const ICompareCommitViewer = Symbol ( 's' ) ; export interface ICompareCommitViewer { readonly comparison : Readonly < CommitComparison > ; showComparisonTree ( comparison ) : void ; showFilesView ( ) : void ; showFolderView ( ) : void ; } export const ICommitViewerFactory = Symbol ( 's' ) ; export interface ICommitViewerFactory { getCommitViewer ( ) : ICommitViewer ; getCompareCommitViewer ( ) : ICommitViewer ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitComparison$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { interfaces } from 's' ; import { Disposable } from 's' ; import { ICommandHandler } from 's' ; type CommandHandler = ( ... args : any [ ] ) => any ; type CommandHandlerInfo = { commandName : string ; handlerMethodName : string } ; export class CommandHandlerRegister implements Disposable { private static Handlers = new Map < interfaces . ServiceIdentifier < ICommandHandler > , CommandHandlerInfo [ ] > ( ) ; public static register ( commandName , handlerMethodName , serviceIdentifier : interfaces . ServiceIdentifier < ICommandHandler > ) { if ( ! CommandHandlerRegister . Handlers . has ( serviceIdentifier ) ) { CommandHandlerRegister . Handlers . set ( serviceIdentifier , [ ] ) ; } const commandList = CommandHandlerRegister . Handlers . get ( serviceIdentifier ) ! ; commandList . push ( { commandName , handlerMethodName } ) ; CommandHandlerRegister . Handlers . set ( serviceIdentifier , commandList ) ; } public static getHandlers ( ) < [ interfaces . ServiceIdentifier < ICommandHandler > , CommandHandlerInfo [ ] ] > { return CommandHandlerRegister . Handlers . entries ( ) ; } public dispose ( ) { CommandHandlerRegister . Handlers . clear ( ) ; } } export function command ( commandName , serviceIdentifier : interfaces . ServiceIdentifier < ICommandHandler > ) { return function ( _target , propertyKey , descriptor < CommandHandler > ) { CommandHandlerRegister . register ( commandName , propertyKey , serviceIdentifier ) ; return descriptor ; } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IterableIterator$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $ICommandHandler$ O $string$ O $TypedPropertyDescriptor$ O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { ICommandManager } from 's' ; import { CommitDetails } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCommitViewExplorerCommandHandler } from 's' ; @ injectable ( ) export class GitCommitViewExplorerCommandHandler implements IGitCommitViewExplorerCommandHandler { constructor ( @ inject ( ICommandManager ) private commandManager , @ inject ( ICommitViewerFactory ) private commitViewerFactory ) { } @ command ( 's' , IGitCommitViewExplorerCommandHandler ) public async hideCommitView ( _commit ) { await this . commandManager . executeCommand ( 's' , 's' , false ) ; } @ command ( 's' , IGitCommitViewExplorerCommandHandler ) public async showCommitView ( _commit ) { await this . commandManager . executeCommand ( 's' , 's' , true ) ; } @ command ( 's' , IGitCommitViewExplorerCommandHandler ) public async showFilesView ( _commit ) { this . commitViewerFactory . getCommitViewer ( ) . showFilesView ( ) ; } @ command ( 's' , IGitCommitViewExplorerCommandHandler ) public async showFolderView ( _commit ) { this . commitViewerFactory . getCommitViewer ( ) . showFolderView ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ICommandManager$ O O O O O O O $ICommitViewerFactory$ O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell , ICommandManager } from 's' ; import { CommitDetails , CompareCommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCompareCommandHandler } from 's' ; @ injectable ( ) export class GitCompareCommitCommandHandler implements IGitCompareCommandHandler { private _previouslySelectedCommit ? : CommitDetails ; constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommandManager ) private commandManager , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private application ) { } public get selectedCommit ( ) : CommitDetails | undefined { return this . _previouslySelectedCommit ; } @ command ( 's' , IGitCompareCommandHandler ) public async select ( commit ) < void > { await this . commandManager . executeCommand ( 's' , 's' , true ) ; this . _previouslySelectedCommit = commit ; } @ command ( 's' , IGitCompareCommandHandler ) public async compare ( commit ) < void > { if ( ! this . selectedCommit ) { await this . application . showErrorMessage ( 's' ) ; return ; } await this . commandManager . executeCommand ( 's' , 's' , true ) ; await this . commandManager . executeCommand ( 's' , 's' , true ) ; await this . commandManager . executeCommand ( 's' ) ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; const fileDiffs = await gitService . getDifferences ( this . selectedCommit ! . logEntry . hash . full , commit . logEntry . hash . full ) ; const compareCommit = new CompareCommitDetails ( this . selectedCommit , commit , fileDiffs ) ; this . commitViewerFactory . getCompareCommitViewer ( ) . showCommitTree ( compareCommit ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommandManager$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { ICommandManager } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCompareCommitViewExplorerCommandHandler } from 's' ; @ injectable ( ) export class GitCompareCommitViewExplorerCommandHandler implements IGitCompareCommitViewExplorerCommandHandler { constructor ( @ inject ( ICommandManager ) private commandManager , @ inject ( ICommitViewerFactory ) private commitViewerFactory ) { } @ command ( 's' , IGitCompareCommitViewExplorerCommandHandler ) public async hide ( ) { await this . commandManager . executeCommand ( 's' , 's' , false ) ; } @ command ( 's' , IGitCompareCommitViewExplorerCommandHandler ) public async show ( ) { await this . commandManager . executeCommand ( 's' , 's' , true ) ; } @ command ( 's' , IGitCompareCommitViewExplorerCommandHandler ) public async showFilesView ( ) { this . commitViewerFactory . getCommitViewer ( ) . showFilesView ( ) ; } @ command ( 's' , IGitCompareCommitViewExplorerCommandHandler ) public async showFolderView ( ) { this . commitViewerFactory . getCommitViewer ( ) . showFolderView ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ICommandManager$ O O O O O O O $ICommitViewerFactory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitBranchFromCommitCommandHandler } from 's' ; @ injectable ( ) export class GitBranchFromCommitCommandHandler implements IGitBranchFromCommitCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitBranchFromCommitCommandHandler ) public async createBranchFromCommit ( commit , newBranchName ? ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const msg = 's' ; const description = 's' ; newBranchName = ( typeof newBranchName !== 's' || newBranchName . trim ( ) . length === 0 ) ? await this . applicationShell . showInputBox ( { placeHolder : msg , prompt : description } ) : newBranchName ; if ( typeof newBranchName !== 's' || newBranchName . length === 0 ) { return ; } const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; gitService . createBranch ( newBranchName , commit . logEntry . hash . full ) . catch ( async err => { const currentBranchName = await gitService . getCurrentBranch ( ) ; if ( typeof err === 's' && currentBranchName !== newBranchName ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCheckoutCommandHandler } from 's' ; @ injectable ( ) export class GitCheckoutCommandHandler implements IGitCheckoutCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitCheckoutCommandHandler ) public async checkoutCommit ( commit ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; gitService . checkout ( commit . logEntry . hash . full ) . catch ( err => { if ( typeof err === 's' ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCherryPickCommandHandler } from 's' ; @ injectable ( ) export class GitCherryPickCommandHandler implements IGitCherryPickCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitCherryPickCommandHandler ) public async cherryPickCommit ( commit , showPrompt = true ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; const currentBranch = await gitService . getCurrentBranch ( ) ; const msg = `template` ; const yesNo = showPrompt ? await this . applicationShell . showQuickPick ( [ 's' , 's' ] , { placeHolder : msg } ) : 's' ; if ( yesNo === undefined || yesNo === 's' ) { return ; } gitService . cherryPick ( commit . logEntry . hash . full ) . catch ( err => { if ( typeof err === 's' ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { CommitDetails , IUiService } from 's' ; import { IServiceContainer } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitCommitCommandHandler } from 's' ; @ injectable ( ) export class GitCommitCommandHandler implements IGitCommitCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory ) { } @ command ( 's' , IGitCommitCommandHandler ) public async doSomethingWithCommit ( commit ) { const cmd = await this . serviceContainer . get < IUiService > ( IUiService ) . selectCommitCommandAction ( commit ) ; if ( cmd ) { return cmd . execute ( ) ; } } @ command ( 's' , IGitCommitCommandHandler ) public onCommitSelected ( commit ) { const viewer = this . commitViewerFactory . getCommitViewer ( ) ; viewer . showCommit ( commit ) ; viewer . showCommitTree ( commit ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { ICommandManager } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { ICommitViewerFactory } from 's' ; import { IGitCommitViewDetailsCommandHandler } from 's' ; @ injectable ( ) export class GitCommitViewDetailsCommandHandler implements IGitCommitViewDetailsCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommandManager ) private commandManager ) { } public async viewDetails ( commit ) { await this . commandManager . executeCommand ( 's' , 's' , true ) ; this . serviceContainer . get < ICommitViewerFactory > ( ICommitViewerFactory ) . getCommitViewer ( ) . showCommit ( commit ) ; } public async viewCommitTree ( commit ) { await this . commandManager . executeCommand ( 's' , 's' , true ) ; this . serviceContainer . get < ICommitViewerFactory > ( ICommitViewerFactory ) . getCommitViewer ( ) . showCommitTree ( commit ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommandManager$ O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitMergeCommandHandler } from 's' ; @ injectable ( ) export class GitMergeCommandHandler implements IGitMergeCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitMergeCommandHandler ) public async merge ( commit , showPrompt = true ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; const currentBranch = await gitService . getCurrentBranch ( ) ; const commitBranches = ( await gitService . getRefsContainingCommit ( commit . logEntry . hash . full ) ) . filter ( value => value . length > 0 ) ; const branchMsg = `template` ; const rev = await this . applicationShell . showQuickPick ( [ commit . logEntry . hash . full , ... commitBranches ] , { placeHolder : branchMsg } ) ; let type ; if ( rev === undefined || rev . length === 0 ) { return ; } if ( rev === commit . logEntry . hash . full ) { type = 's' ; } else { type = 's' ; } const msg = `template` ; const yesNo = showPrompt ? await this . applicationShell . showQuickPick ( [ 's' , 's' ] , { placeHolder : msg } ) : 's' ; if ( yesNo === undefined || yesNo === 's' ) { return ; } gitService . merge ( rev ) . catch ( err => { if ( typeof err === 's' ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitRebaseCommandHandler } from 's' ; @ injectable ( ) export class GitRebaseCommandHandler implements IGitRebaseCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitRebaseCommandHandler ) public async rebase ( commit , showPrompt = true ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; const currentBranch = await gitService . getCurrentBranch ( ) ; const msg = `template` ; const yesNo = showPrompt ? await this . applicationShell . showQuickPick ( [ 's' , 's' ] , { placeHolder : msg } ) : 's' ; if ( yesNo === undefined || yesNo === 's' ) { return ; } gitService . rebase ( commit . logEntry . hash . full ) . catch ( err => { if ( typeof err === 's' ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell } from 's' ; import { CommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ICommitViewerFactory } from 's' ; import { command } from 's' ; import { IGitRevertCommandHandler } from 's' ; @ injectable ( ) export class GitRevertCommandHandler implements IGitRevertCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommitViewerFactory ) private commitViewerFactory , @ inject ( IApplicationShell ) private applicationShell ) { } @ command ( 's' , IGitRevertCommandHandler ) public async revertCommit ( commit , showPrompt = true ) { commit = commit ? commit : this . commitViewerFactory . getCommitViewer ( ) . selectedCommit ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( commit . workspaceFolder , commit . logEntry . gitRoot ) ; const msg = `template` ; const yesNo = showPrompt ? await this . applicationShell . showQuickPick ( [ 's' , 's' ] , { placeHolder : msg } ) : 's' ; if ( yesNo === undefined || yesNo === 's' ) { return ; } gitService . revertCommit ( commit . logEntry . hash . full ) . catch ( err => { if ( typeof err === 's' ) { this . applicationShell . showErrorMessage ( err ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommitViewerFactory$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O $CommitDetails$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import { Uri } from 's' ; type MapExtToMediaMimes = { [ index ] : string ; } ; const mapExtToMediaMimes = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } ; export function isTextFile ( file ) { const extension = path . extname ( file . fsPath ) ; return ! mapExtToMediaMimes [ extension ] ; }	O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $MapExtToMediaMimes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Uri$ O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { Uri } from 's' ; import { ICommandManager , IDocumentManager } from 's' ; import { command } from 's' ; import { IFileCommandHandler } from 's' ; import { isTextFile } from 's' ; @ injectable ( ) export class FileCommandHandler implements IFileCommandHandler { constructor ( @ inject ( ICommandManager ) private commandManager , @ inject ( IDocumentManager ) private documentManager ) { } @ command ( 's' , IFileCommandHandler ) public async openFile ( file ) < void > { if ( isTextFile ( file ) ) { const doc = await this . documentManager . openTextDocument ( file ) ; await this . documentManager . showTextDocument ( doc , { preview : true } ) ; } else { await this . commandManager . executeCommand ( 's' , file ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ICommandManager$ O O O O O O O $IDocumentManager$ O O O O O O O O O O O O $Promise$ O $Uri$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TreeItem , TreeItemCollapsibleState } from 's' ; import { DirectoryNode , FileNode } from 's' ; export class DirectoryTreeItem extends TreeItem { constructor ( public readonly data ) { super ( data . label , TreeItemCollapsibleState . Collapsed ) ; this . contextValue = 's' ; } } export class FileTreeItem extends TreeItem { constructor ( public readonly data ) { super ( data . label , TreeItemCollapsibleState . None ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DirectoryNode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileNode$ O O O O O O O O O O O O O O O
import * as path from 's' ; import { Uri } from 's' ; import { CommitDetails , FileCommitDetails } from 's' ; import { CommittedFile } from 's' ; import { DirectoryTreeItem , FileTreeItem } from 's' ; import { INode } from 's' ; export interface INode < T > { readonly label : string ; readonly resource : Uri ; readonly data ? : T ; readonly children : INode < T > [ ] ; } export abstract class AbstractCommitNode < T > implements INode < T > { public children : AbstractCommitNode < T > [ ] = [ ] ; private _label : string ; private _resource : Uri ; public get label ( ) { return this . _label ; } public get resource ( ) { return this . _resource ; } constructor ( public readonly data : T | undefined ) { } protected setLabel ( value ) { this . _label = value ; } protected setResoruce ( value : string | Uri ) { this . _resource = typeof value === 's' ? Uri . file ( value as string ) : value as Uri ; } } export class DirectoryNode extends AbstractCommitNode < CommitDetails | FileCommitDetails > { constructor ( commit , relativePath ) { super ( commit ) ; const folderName = path . basename ( relativePath ) ; this . setLabel ( folderName ) ; this . setResoruce ( relativePath ) ; } } export class FileNode extends AbstractCommitNode < FileCommitDetails > { constructor ( commit ) { super ( commit ) ; const fileName = path . basename ( commit . committedFile . relativePath ) ; this . setLabel ( fileName ) ; this . setResoruce ( commit . committedFile . relativePath ) ; } } export const INodeFactory = Symbol ( 's' ) ; export interface INodeFactory { createDirectoryNode ( commit , relativePath ) : DirectoryNode ; createFileNode ( commit , committedFile ) : FileNode ; } export const INodeBuilder = Symbol ( 's' ) ; export interface INodeBuilder { buildTree ( commit , committedFiles : CommittedFile [ ] ) : ( DirectoryNode | FileNode ) [ ] ; buildList ( commit , committedFiles : CommittedFile [ ] ) : FileNode [ ] ; getTreeItem ( node : DirectoryNode | FileNode ) : Promise < DirectoryTreeItem | FileTreeItem > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O $string$ O O O O O O $CommitDetails$ O $CommittedFile$ O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { IApplicationShell , ICommandManager } from 's' ; import { FileCommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { FileNode } from 's' ; import { IGitServiceFactory } from 's' ; import { command } from 's' ; import { IGitCompareFileCommandHandler } from 's' ; @ injectable ( ) export class GitCompareFileCommitCommandHandler implements IGitCompareFileCommandHandler { private _previouslySelectedCommit ? : FileCommitDetails ; constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommandManager ) private commandManager , @ inject ( IApplicationShell ) private application ) { } public get selectedCommit ( ) : FileCommitDetails | undefined { return this . _previouslySelectedCommit ; } @ command ( 's' , IGitCompareFileCommandHandler ) public async select ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; await this . commandManager . executeCommand ( 's' , 's' , true ) ; this . _previouslySelectedCommit = fileCommit ; } @ command ( 's' , IGitCompareFileCommandHandler ) public async compare ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { if ( ! this . selectedCommit ) { await this . application . showErrorMessage ( 's' ) ; return ; } const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; const fileDiffs = await gitService . getDifferences ( this . selectedCommit ! . logEntry . hash . full , fileCommit . logEntry . hash . full ) ; await this . commandManager . executeCommand ( 's' , this . selectedCommit ! , fileCommit , fileDiffs ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommandManager$ O O O O O O O $IApplicationShell$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as path from 's' ; import { Uri } from 's' ; import { IApplicationShell } from 's' ; import { ICommandManager } from 's' ; import { CompareFileCommitDetails , FileCommitDetails , IUiService } from 's' ; import { IServiceContainer } from 's' ; import { FileNode } from 's' ; import { IFileSystem } from 's' ; import { Hash , IGitServiceFactory , Status } from 's' ; import { command } from 's' ; import { IGitFileHistoryCommandHandler } from 's' ; @ injectable ( ) export class GitFileHistoryCommandHandler implements IGitFileHistoryCommandHandler { constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( ICommandManager ) private commandManager , @ inject ( IApplicationShell ) private applicationShell , @ inject ( IFileSystem ) private fileSystem ) { } @ command ( 's' , IGitFileHistoryCommandHandler ) public async doSomethingWithFile ( fileCommit ) { const cmd = await this . serviceContainer . get < IUiService > ( IUiService ) . selectFileCommitCommandAction ( fileCommit ) ; if ( ! cmd ) { return ; } return cmd . execute ( ) ; } @ command ( 's' , IGitFileHistoryCommandHandler ) public async viewFile ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; if ( fileCommit . committedFile . status === Status . Deleted ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } const tmpFile = await gitService . getCommitFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile . uri ) ; await this . commandManager . executeCommand ( 's' , tmpFile ) ; } @ command ( 's' , IGitFileHistoryCommandHandler ) public async compareFileWithWorkspace ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; if ( fileCommit . committedFile . status === Status . Deleted ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } if ( ! await this . fileSystem . fileExistsAsync ( fileCommit . committedFile . uri . fsPath ) ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } const tmpFile = await gitService . getCommitFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile . uri ) ; const fileName = path . basename ( fileCommit . committedFile . uri . fsPath ) ; const title = `template` ; await this . commandManager . executeCommand ( 's' , Uri . file ( fileCommit . committedFile . uri . fsPath ) , Uri . file ( tmpFile . fsPath ) , title , { preview : true } ) ; } @ command ( 's' , IGitFileHistoryCommandHandler ) public async compareFileWithPrevious ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; if ( fileCommit . committedFile . status === Status . Deleted ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } if ( fileCommit . committedFile . status === Status . Added ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } const tmpFilePromise = gitService . getCommitFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile ! . uri ) ; const previousCommitHashPromise = gitService . getPreviousCommitHashForFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile ! . uri ) ; const values = await Promise . all ( [ tmpFilePromise , previousCommitHashPromise ] ) ; const tmpFile = values [ 0 ] ; const previousCommitHash = values [ 0 ] ; const previousFile = fileCommit . committedFile ! . oldUri ? fileCommit . committedFile ! . oldUri ! : fileCommit . committedFile ! . uri ; const previousTmpFile = await gitService . getCommitFile ( previousCommitHash . full , previousFile ) ; const title = this . getComparisonTitle ( { file : Uri . file ( fileCommit . committedFile ! . uri . fsPath ) , hash : fileCommit . logEntry . hash } , { file : Uri . file ( previousFile . fsPath ) , hash : previousCommitHash } ) ; await this . commandManager . executeCommand ( 's' , previousTmpFile , tmpFile , title , { preview : true } ) ; } @ command ( 's' , IGitFileHistoryCommandHandler ) public async viewPreviousFile ( nodeOrFileCommit : FileNode | FileCommitDetails ) < void > { const fileCommit = nodeOrFileCommit instanceof FileCommitDetails ? nodeOrFileCommit : nodeOrFileCommit . data ! ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; if ( fileCommit . committedFile . status === Status . Added ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } const previousCommitHash = await gitService . getPreviousCommitHashForFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile ! . uri ) ; const previousFile = fileCommit . committedFile ! . oldUri ? fileCommit . committedFile ! . oldUri ! : fileCommit . committedFile ! . uri ; const previousTmpFile = await gitService . getCommitFile ( previousCommitHash . full , previousFile ) ; await this . commandManager . executeCommand ( 's' , Uri . file ( previousTmpFile . fsPath ) ) ; } @ command ( 's' , IGitFileHistoryCommandHandler ) public async compareFileAcrossCommits ( fileCommit ) < void > { const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( fileCommit . workspaceFolder , fileCommit . logEntry . gitRoot ) ; if ( fileCommit . committedFile . status === Status . Deleted ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } if ( fileCommit . committedFile . status === Status . Added ) { return this . applicationShell . showErrorMessage ( 's' ) . then ( ( ) => void 0 ) ; } const leftFilePromise = gitService . getCommitFile ( fileCommit . logEntry . hash . full , fileCommit . committedFile ! . uri ) ; const rightFilePromise = gitService . getCommitFile ( fileCommit . rightCommit . logEntry . hash . full , fileCommit . committedFile ! . uri ) ; const [ leftFile , rightFile ] = await Promise . all ( [ leftFilePromise , rightFilePromise ] ) ; const title = this . getComparisonTitle ( { file : Uri . file ( fileCommit . committedFile ! . uri . fsPath ) , hash : fileCommit . logEntry . hash } , { file : Uri . file ( fileCommit . committedFile ! . uri . fsPath ) , hash : fileCommit . rightCommit . logEntry . hash } ) ; await this . commandManager . executeCommand ( 's' , leftFile , rightFile , title , { preview : true } ) ; } private getComparisonTitle ( left : { file : Uri ; hash : Hash } , right : { file : Uri ; hash : Hash } ) { const leftFileName = path . basename ( left . file . fsPath ) ; const rightFileName = path . basename ( right . file . fsPath ) ; if ( leftFileName === rightFileName ) { return `template` ; } else { return `template` ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $ICommandManager$ O O O O O O O $IApplicationShell$ O O O O O O O $IFileSystem$ O O O O O O O O O O O O O O $FileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $CompareFileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Uri } from 's' ; export const gitHistorySchema = 's' ; export const gitHistoryFileViewerSchema = 's' ; export const previewUri = Uri . parse ( `template` ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Request , Response } from 's' ; import { Disposable , Uri } from 's' ; import { BranchSelection , LogEntries , LogEntry } from 's' ; export type ThemeDetails = { theme : string ; backgroundColor : string ; color : string ; fontFamily : string ; fontSize : string ; fontWeight ? : string ; } ; export const IThemeService = Symbol ( 's' ) ; export interface IThemeService { getThemeDetails ( theme , backgroundColor , color ) : ThemeDetails ; } export const IApiRouteHandler = Symbol ( 's' ) ; export interface IApiRouteHandler extends Disposable { getLogEntries ( request , response ) : void ; getBranches ( request , response ) : void ; getCommit ( request , response ) : void ; doSomethingWithCommit ( request , response ) : void ; selectCommittedFile ( request , response ) : void ; } export type StartupInfo = { port : number ; } ; export const IServerHost = Symbol ( 's' ) ; export interface IServerHost extends Disposable { start ( workspaceFolder ) : Promise < StartupInfo > ; } export type State = { workspaceFolder : string ; gitRoot : string ; pageIndex ? : number ; author ? : string ; lineNumber ? : number ; pageSize ? : number ; branch ? : string ; searchText ? : string ; file ? : Uri ; entries ? : Promise < LogEntries > ; lastFetchedHash ? : string ; lastFetchedCommit ? : Promise < LogEntry | undefined > ; branchSelection ? : BranchSelection ; } ; export const IWorkspaceQueryStateStore = Symbol ( 's' ) ; export interface IWorkspaceQueryStateStore extends Disposable { initialize ( id , workspaceFolder , gitRoot , branchName , branchSelection , searchText ? , file ? , lineNumber ? , author ? ) : Promise < void > ; updateEntries ( id , entries < LogEntries > , pageIndex ? , pageSize ? , branch ? , searchText ? , file ? , branchSelection ? , lineNumber ? , author ? ) : Promise < void > ; updateLastHashCommit ( id , hash , commit < LogEntry | undefined > ) : Promise < void > ; clearLastHashCommit ( id ) : Promise < void > ; getState ( id ) : Readonly < State > | undefined ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O $Request$ O $Response$ O O O O O O $Request$ O $Response$ O O O O O O $Request$ O $Response$ O O O O O O $Request$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O $BranchSelection$ O O $string$ O O $Uri$ O O $number$ O O $string$ O O O O O O O O O $string$ O $Promise$ O O O O O $number$ O O $number$ O O $string$ O O $string$ O O $Uri$ O O $BranchSelection$ O O $number$ O O $string$ O O O O O O O O O $string$ O $string$ O $Promise$ O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O
import { inject , injectable } from 's' ; import * as 0 from 's' ; import * as osLocale from 's' ; import * as path from 's' ; import { Uri , ViewColumn , window } from 's' ; import { ICommandManager } from 's' ; import { IDisposableRegistry } from 's' ; import { FileCommitDetails , IUiService } from 's' ; import { previewUri } from 's' ; import { IServiceContainer } from 's' ; import { FileNode } from 's' ; import { IServerHost , IWorkspaceQueryStateStore } from 's' ; import { BranchSelection , IGitServiceFactory } from 's' ; import { command } from 's' ; import { IGitHistoryCommandHandler } from 's' ; @ injectable ( ) export class GitHistoryCommandHandler implements IGitHistoryCommandHandler { private _server ? : IServerHost ; private get server ( ) : IServerHost { if ( ! this . _server ) { this . _server = this . serviceContainer . get < IServerHost > ( IServerHost ) ; this . disposableRegistry . register ( this . _server ) ; } return this . _server ! ; } constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( IDisposableRegistry ) private disposableRegistry , @ inject ( ICommandManager ) private commandManager ) { } @ command ( 's' , IGitHistoryCommandHandler ) public async viewFileHistory ( info ? : FileCommitDetails | Uri ) < void > { let fileUri : Uri | undefined ; if ( info ) { if ( info instanceof FileCommitDetails ) { const committedFile = info . committedFile ; fileUri = committedFile . uri ? Uri . file ( committedFile . uri ! . fsPath ! ) : Uri . file ( committedFile . oldUri ! . fsPath ) ; } else if ( info instanceof FileNode ) { const committedFile = info . data ! . committedFile ; fileUri = committedFile . uri ? Uri . file ( committedFile . uri ! . fsPath ! ) : Uri . file ( committedFile . oldUri ! . fsPath ) ; } else if ( info instanceof Uri ) { fileUri = info ; } else if ( ( info as any ) . resourceUri ) { fileUri = ( info as any ) . resourceUri as Uri ; } } else { const activeTextEditor = window . activeTextEditor ! ; if ( ! activeTextEditor || activeTextEditor . document . isUntitled ) { return ; } fileUri = activeTextEditor . document . uri ; } return this . viewHistory ( fileUri ) ; } @ command ( 's' , IGitHistoryCommandHandler ) public async viewLineHistory ( ) < void > { let fileUri : Uri | undefined ; const activeTextEditor = window . activeTextEditor ! ; if ( ! activeTextEditor || activeTextEditor . document . isUntitled ) { return ; } fileUri = activeTextEditor . document . uri ; const currentLineNumber = activeTextEditor . selection . start . line + 0 ; return this . viewHistory ( fileUri , currentLineNumber ) ; } @ command ( 's' , IGitHistoryCommandHandler ) public async viewBranchHistory ( ) < void > { return this . viewHistory ( ) ; } public async viewHistory ( fileUri ? , lineNumber ? ) < void > { const uiService = this . serviceContainer . get < IUiService > ( IUiService ) ; const selection = await uiService . getWorkspaceFolder ( fileUri ) ; if ( ! selection ) { return undefined ; } const workspaceFolder = selection . workspaceFolder ; const gitRoot = selection . gitRoot ; const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( workspaceFolder , gitRoot ) ; const branchNamePromise = gitService . getCurrentBranch ( ) ; const startupInfoPromise = this . server ! . start ( workspaceFolder ) ; const localePromise = osLocale ( ) ; const gitRootsUnderWorkspacePromise = gitService . getGitRoots ( workspaceFolder ) ; const [ branchName , startupInfo , locale , gitRootsUnderWorkspace ] = await Promise . all ( [ branchNamePromise , startupInfoPromise , localePromise , gitRootsUnderWorkspacePromise ] ) ; const fullId = `template` ; const id = 0 ( fullId ) ; await this . serviceContainer . get < IWorkspaceQueryStateStore > ( IWorkspaceQueryStateStore ) . initialize ( id , workspaceFolder , gitRoot , branchName , BranchSelection . Current , 's' , fileUri , lineNumber ) ; const queryArgs = [ `template` , `template` , `template` , `template` , `template` ] ; queryArgs . push ( `template` ) ; const uri = `template` ; const repoName = gitRootsUnderWorkspace . length > 0 ? `template` : 's' ; let title = fileUri ? `template` : `template` ; if ( fileUri && typeof lineNumber === 's' ) { title = `template` ; } this . commandManager . executeCommand ( 's' , uri , ViewColumn . One , title ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $IDisposableRegistry$ O O O O O O O $ICommandManager$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O $Promise$ O O $Uri$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import { ICommandManager } from 's' ; import { IDisposableRegistry } from 's' ; import { IServiceContainer } from 's' ; import { CommandHandlerRegister } from 's' ; import { ICommandHandler , ICommandHandlerManager } from 's' ; @ injectable ( ) export class CommandHandlerManager implements ICommandHandlerManager { constructor ( @ inject ( IDisposableRegistry ) private disposableRegistry , @ inject ( ICommandManager ) private commandManager , @ inject ( IServiceContainer ) private serviceContainer ) { } public registerHandlers ( ) { for ( const item of CommandHandlerRegister . getHandlers ( ) ) { const serviceIdentifier = item [ 0 ] ; const handlers = item [ 0 ] ; const target = this . serviceContainer . get < ICommandHandler > ( serviceIdentifier ) ; handlers . forEach ( handlerInfo => this . registerCommand ( handlerInfo . commandName , handlerInfo . handlerMethodName , target ) ) ; } } private registerCommand ( commandName , handlerMethodName , target ) { const handler = target [ handlerMethodName ] as ( ... args : any [ ] ) => void ; const disposable = this . commandManager . registerCommand ( commandName , ( ... args : any [ ] ) => { handler . apply ( target , args ) ; } ) ; this . disposableRegistry . register ( disposable ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IDisposableRegistry$ O O O O O O O $ICommandManager$ O O O O O O O $IServiceContainer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $ICommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { GitCommitViewExplorerCommandHandler } from 's' ; import { GitCompareCommitCommandHandler } from 's' ; import { GitCompareCommitViewExplorerCommandHandler } from 's' ; import { GitBranchFromCommitCommandHandler } from 's' ; import { GitCherryPickCommandHandler } from 's' ; import { GitCheckoutCommandHandler } from 's' ; import { GitCommitCommandHandler } from 's' ; import { GitCommitViewDetailsCommandHandler } from 's' ; import { GitMergeCommandHandler } from 's' ; import { GitRebaseCommandHandler } from 's' ; import { GitRevertCommandHandler } from 's' ; import { FileCommandHandler } from 's' ; import { GitCompareFileCommitCommandHandler } from 's' ; import { GitFileHistoryCommandHandler } from 's' ; import { GitHistoryCommandHandler } from 's' ; import { CommandHandlerManager } from 's' ; import { ICommandHandler , ICommandHandlerManager , IFileCommandHandler , IGitBranchFromCommitCommandHandler , IGitCheckoutCommandHandler , IGitCherryPickCommandHandler , IGitCommitCommandHandler , IGitCommitViewDetailsCommandHandler , IGitCommitViewExplorerCommandHandler , IGitCompareCommandHandler , IGitCompareCommitViewExplorerCommandHandler , IGitCompareFileCommandHandler , IGitFileHistoryCommandHandler , IGitHistoryCommandHandler , IGitMergeCommandHandler , IGitRebaseCommandHandler , IGitRevertCommandHandler } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . addSingleton < IGitFileHistoryCommandHandler > ( IGitFileHistoryCommandHandler , GitFileHistoryCommandHandler ) ; serviceManager . addSingleton < IGitBranchFromCommitCommandHandler > ( IGitBranchFromCommitCommandHandler , GitBranchFromCommitCommandHandler ) ; serviceManager . addSingleton < IGitHistoryCommandHandler > ( IGitHistoryCommandHandler , GitHistoryCommandHandler ) ; serviceManager . addSingleton < IGitCommitCommandHandler > ( IGitCommitCommandHandler , GitCommitCommandHandler ) ; serviceManager . addSingleton < IGitCommitViewDetailsCommandHandler > ( IGitCommitViewDetailsCommandHandler , GitCommitViewDetailsCommandHandler ) ; serviceManager . addSingleton < IGitCherryPickCommandHandler > ( IGitCherryPickCommandHandler , GitCherryPickCommandHandler ) ; serviceManager . addSingleton < IGitCheckoutCommandHandler > ( IGitCheckoutCommandHandler , GitCheckoutCommandHandler ) ; serviceManager . addSingleton < IGitCompareFileCommandHandler > ( IGitCompareFileCommandHandler , GitCompareFileCommitCommandHandler ) ; serviceManager . addSingleton < IGitCommitViewExplorerCommandHandler > ( IGitCommitViewExplorerCommandHandler , GitCommitViewExplorerCommandHandler ) ; serviceManager . addSingleton < IGitCompareCommandHandler > ( IGitCompareCommandHandler , GitCompareCommitCommandHandler ) ; serviceManager . addSingleton < IGitCompareCommitViewExplorerCommandHandler > ( IGitCompareCommitViewExplorerCommandHandler , GitCompareCommitViewExplorerCommandHandler ) ; serviceManager . addSingleton < IFileCommandHandler > ( IFileCommandHandler , FileCommandHandler ) ; serviceManager . addSingleton < IGitMergeCommandHandler > ( IGitMergeCommandHandler , GitMergeCommandHandler ) ; serviceManager . addSingleton < IGitRebaseCommandHandler > ( IGitRebaseCommandHandler , GitRebaseCommandHandler ) ; serviceManager . addSingleton < IGitRevertCommandHandler > ( IGitRevertCommandHandler , GitRevertCommandHandler ) ; [ IGitFileHistoryCommandHandler , IGitBranchFromCommitCommandHandler , IGitHistoryCommandHandler , IGitCommitCommandHandler , IGitCherryPickCommandHandler , IGitCompareFileCommandHandler , IGitCommitViewExplorerCommandHandler , IGitCompareCommitViewExplorerCommandHandler , IFileCommandHandler , IGitMergeCommandHandler , IGitRebaseCommandHandler , IGitRevertCommandHandler ] . forEach ( serviceIdentifier => { const instance = serviceManager . get < ICommandHandler > ( serviceIdentifier ) ; serviceManager . addSingletonInstance < ICommandHandler > ( ICommandHandler , instance ) ; } ) ; serviceManager . addSingleton < ICommandHandlerManager > ( ICommandHandlerManager , CommandHandlerManager ) ; const handlerManager = serviceManager . get < ICommandHandlerManager > ( ICommandHandlerManager ) ; handlerManager . registerHandlers ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ICommandManager } from 's' ; import { CommitDetails } from 's' ; import { BaseCommitCommand } from 's' ; export class HideCommitViewExplorerCommand extends BaseCommitCommand { constructor ( commit , private commandManager ) { super ( commit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; } public execute ( ) { this . commandManager . executeCommand ( this . command ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O $ICommandManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IGitFileHistoryCommandHandler } from 's' ; import { FileCommitDetails } from 's' ; import { BaseFileCommitCommand } from 's' ; export class DoSomethingWithFileCommitCommand extends BaseFileCommitCommand { constructor ( fileCommit , private handler ) { super ( fileCommit ) ; this . setTitle ( 's' ) ; this . setCommand ( 's' ) ; } public execute ( ) { this . handler . doSomethingWithFile ( this . data ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FileCommitDetails$ O O $IGitFileHistoryCommandHandler$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function isTestEnvironment ( ) { return process . env . VSC_GITHISTORY_CI_TEST === 's' ; }	O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Disposable , workspace } from 's' ; import { ILogService } from 's' ; @ injectable ( ) export class Logger implements ILogService { private _enabled : boolean = false ; private disposable : Disposable ; private get enabled ( ) : boolean { return this . _enabled ; } constructor ( ) { this . updateEnabledFlag ( ) ; this . disposable = workspace . onDidChangeConfiguration ( ( ) => this . updateEnabledFlag ( ) ) ; } public dispose ( ) { this . disposable . dispose ( ) ; } public log ( ... args : any [ ] ) { if ( ! this . enabled ) { return ; } console . log ( ... args ) ; } public error ( ... args : any [ ] ) { if ( ! this . enabled ) { return ; } console . error ( ... args ) ; } public trace ( ... args : any [ ] ) { if ( ! this . enabled ) { return ; } console . warn ( ... args ) ; } private updateEnabledFlag ( ) { this . _enabled = workspace . getConfiguration ( 's' ) . get < string > ( 's' , 's' ) === 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface IDeferred < T > { readonly promise : Promise < T > ; readonly resolved : boolean ; readonly rejected : boolean ; readonly completed : boolean ; resolve ( value ? : T | PromiseLike < T > ) : void ; reject ( reason ? ) : void ; } class DeferredImpl < T > implements IDeferred < T > { private _resolve : ( value ? : T | PromiseLike < T > ) => void ; private _reject : ( reason ? ) => void ; private _resolved : boolean = false ; private _rejected : boolean = false ; private _promise : Promise < T > ; constructor ( private scope = null ) { this . _promise = new Promise < T > ( ( res , rej ) => { this . _resolve = res ; this . _reject = rej ; } ) ; } public resolve ( _value ? : T | PromiseLike < T > ) { this . _resolve . apply ( this . scope ? this . scope : this , arguments ) ; this . _resolved = true ; } public reject ( _reason ? ) { this . _reject . apply ( this . scope ? this . scope : this , arguments ) ; this . _rejected = true ; } get promise ( ) : Promise < T > { return this . _promise ; } get resolved ( ) : boolean { return this . _resolved ; } get rejected ( ) : boolean { return this . _rejected ; } get completed ( ) : boolean { return this . _rejected || this . _resolved ; } } export function createDeferred < T > ( scope = null ) < T > { return new DeferredImpl < T > ( scope ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IDeferred$ O O O O $any$ O O O O O O O O O O O O O O O O O O
import * as vscode from 's' ; let outInfoChannel : vscode . OutputChannel ; let outLogChannel : vscode . OutputChannel ; const logLevel = < string > vscode . workspace . getConfiguration ( 's' ) . get ( 's' ) ; function getInfoChannel ( ) { if ( outInfoChannel === undefined ) { outInfoChannel = vscode . window . createOutputChannel ( 's' ) ; } return outInfoChannel ; } export function getLogChannel ( ) { if ( outLogChannel === undefined ) { outLogChannel = vscode . window . createOutputChannel ( 's' ) ; } return outLogChannel ; } export function logError ( error ) { getLogChannel ( ) . appendLine ( `template` . replace ( "s" , 's' ) ) ; getLogChannel ( ) . show ( ) ; vscode . window . showErrorMessage ( 's' ) ; } export function logInfo ( message ) { if ( logLevel === 's' || logLevel === 's' ) { getLogChannel ( ) . appendLine ( `template` ) ; } } export function logDebug ( message ) { if ( logLevel === 's' ) { getLogChannel ( ) . appendLine ( `template` ) ; } } function getTimeAndms ( ) { const time = new Date ( ) ; const hours = `template` . slice ( - 0 ) ; const minutes = `template` . slice ( - 0 ) ; const seconds = `template` . slice ( - 0 ) ; const milliSeconds = `template` . slice ( - 0 ) ; return `template` ; } export function showInfo ( message ) { getInfoChannel ( ) . clear ( ) ; getInfoChannel ( ) . appendLine ( message ) ; getInfoChannel ( ) . show ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { OutputChannel , workspace } from 's' ; import { getLogChannel } from 's' ; import { ILogService } from 's' ; @ injectable ( ) export class OutputPanelLogger implements ILogService { private readonly outputChannel : OutputChannel ; private readonly traceEnabled : boolean ; constructor ( ) { this . outputChannel = getLogChannel ( ) ; const logLevel = workspace . getConfiguration ( 's' ) . get < string > ( 's' ) ; this . traceEnabled = ( typeof logLevel === 's' && logLevel . toUpperCase ( ) === 's' ) ; } public log ( ... args : any [ ] ) { const formattedText = this . formatArgs ( ... args ) ; this . outputChannel . appendLine ( formattedText ) ; } public error ( ... args : any [ ] ) { const formattedText = this . formatArgs ( ... args ) ; this . outputChannel . appendLine ( formattedText ) ; this . outputChannel . show ( ) ; } public trace ( ... args : any [ ] ) { if ( ! this . traceEnabled ) { return ; } const formattedText = this . formatArgs ( ... args ) ; this . outputChannel . appendLine ( formattedText ) ; } public formatArgs ( ... args : any [ ] ) { return args . map ( arg => { if ( arg instanceof Error ) { const error : { [ key ] : any } = { } ; Object . getOwnPropertyNames ( arg ) . forEach ( key => { error [ key ] = arg [ key ] ; } ) ; return JSON . stringify ( error ) ; } else if ( arg !== null && arg !== undefined && typeof arg === 's' ) { return JSON . stringify ( arg ) ; } else if ( typeof arg === 's' && arg . startsWith ( 's' ) ) { return 's' ; } else { return `template` ; } } ) . join ( 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as path from 's' ; import { CancellationTokenSource , QuickPickItem , Uri } from 's' ; import { IApplicationShell } from 's' ; import { IWorkspaceService } from 's' ; import { ICommitCommandFactory , IFileCommitCommandFactory } from 's' ; import { IServiceContainer } from 's' ; import { BranchSelection , IGitServiceFactory } from 's' ; import { CommitDetails , FileCommitDetails , ICommand , IUiService } from 's' ; const allBranches = 's' ; const currentBranch = 's' ; type WorkspaceGitRoot = { workspaceFolder : string ; gitRoot : string } ; @ injectable ( ) export class UiService implements IUiService { private selectionActionToken ? : CancellationTokenSource ; constructor ( @ inject ( IServiceContainer ) private serviceContainer , @ inject ( IApplicationShell ) private application ) { } public async getBranchSelection ( ) < BranchSelection | undefined > { const itemPickList : QuickPickItem [ ] = [ ] ; itemPickList . push ( { label : currentBranch , description : 's' } ) ; itemPickList . push ( { label : allBranches , description : 's' } ) ; const modeChoice = await this . application . showQuickPick ( itemPickList , { placeHolder : 's' , matchOnDescription : true } ) ; if ( ! modeChoice ) { return ; } return modeChoice . label === allBranches ? BranchSelection . All : BranchSelection . Current ; } public async getWorkspaceFolder ( uri ? ) < WorkspaceGitRoot | undefined > { let workspaceFolder : Uri | undefined ; const workspaceService = this . serviceContainer . get < IWorkspaceService > ( IWorkspaceService ) ; if ( uri ) { const workspaceFolderUri = workspaceService . getWorkspaceFolder ( uri ) ; if ( workspaceFolderUri ) { workspaceFolder = workspaceFolderUri . uri ; } } if ( ! Array . isArray ( workspaceService . workspaceFolders ) || workspaceService . workspaceFolders . length === 0 ) { this . serviceContainer . get < IApplicationShell > ( IApplicationShell ) . showInformationMessage ( 's' ) ; return ; } const firstWorkspaceFolder = workspaceService . workspaceFolders [ 0 ] . uri . fsPath ; const folders = workspaceFolder ? [ workspaceFolder ] : workspaceService . workspaceFolders . map ( item => item . uri ) ; const gitServices = await Promise . all ( folders . map ( async folder => { const gitService = await this . serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( folder . fsPath , folder ) ; return gitService . getGitRoots ( folder . fsPath ) ; } ) ) ; const flattendGitServices = gitServices . reduce ( ( a , b ) => a . concat ( b ) , [ ] ) ; const filteredGitRoots = flattendGitServices . map ( gitRoot => { const workspaceFolderUri = workspaceService . getWorkspaceFolder ( Uri . file ( gitRoot ) ) ; if ( workspaceFolderUri ) { return { workspaceFolder : workspaceFolderUri . uri . fsPath , gitRoot } ; } return ; } ) . filter ( item => ! ! item ) . map ( item => item ! ) ; switch ( filteredGitRoots . length ) { case 0 : { return { workspaceFolder : firstWorkspaceFolder , gitRoot : firstWorkspaceFolder } ; } case 0 : { return filteredGitRoots [ 0 ] ! ; } default : { return this . selectGitRoot ( filteredGitRoots ) ; } } } public async selectFileCommitCommandAction ( fileCommit ) < ICommand < FileCommitDetails > | undefined > { if ( this . selectionActionToken ) { this . selectionActionToken . cancel ( ) ; } this . selectionActionToken = new CancellationTokenSource ( ) ; const commands = await this . serviceContainer . get < IFileCommitCommandFactory > ( IFileCommitCommandFactory ) . createCommands ( fileCommit ) ; const options = { matchOnDescription : true , matchOnDetail : true , token : this . selectionActionToken . token } ; return this . application . showQuickPick ( commands , options ) ; } public async selectCommitCommandAction ( commit ) < ICommand < CommitDetails > | undefined > { if ( this . selectionActionToken ) { this . selectionActionToken . cancel ( ) ; } this . selectionActionToken = new CancellationTokenSource ( ) ; const commands = await this . serviceContainer . get < ICommitCommandFactory > ( ICommitCommandFactory ) . createCommands ( commit ) ; const options = { matchOnDescription : true , matchOnDetail : true , token : this . selectionActionToken . token } ; return this . application . showQuickPick ( commands , options ) ; } private async selectGitRoot ( workspaceGitRoots : WorkspaceGitRoot [ ] ) { const app = this . serviceContainer . get < IApplicationShell > ( IApplicationShell ) ; type itemType = QuickPickItem & WorkspaceGitRoot ; const pickList : itemType [ ] = workspaceGitRoots . map ( item => { return { ... item , label : path . basename ( item . gitRoot ) , detail : item . gitRoot } ; } ) ; const options = { canPickMany : false , matchOnDescription : true , matchOnDetail : true , placeHolder : 's' } ; const selectedItem = await app . showQuickPick ( pickList , options ) ; if ( selectedItem ) { return selectedItem ; } return ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O $IApplicationShell$ O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $Uri$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $FileCommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { LogEntry } from 's' ; export const ICommitViewFormatter = Symbol ( 's' ) ; export interface ICommitViewFormatter { format ( logEntry ) : string ; formatAuthor ( logEntry ) : string ; }	O O O O O O O O O O O O O O O O O O O O O O $LogEntry$ O O O O O O $LogEntry$ O O O O O
import { injectable } from 's' ; import { EOL } from 's' ; import { LogEntry } from 's' ; import { ICommitViewFormatter } from 's' ; @ injectable ( ) export class CommitViewFormatter implements ICommitViewFormatter { public format ( item ) { const sb : string [ ] = [ ] ; if ( item . hash && item . hash . full ) { sb . push ( `template` ) ; } if ( item . author ) { sb . push ( this . formatAuthor ( item ) ) ; } if ( item . author && item . author . date ) { const authorDate = item . author ! . date ! . toLocaleString ( ) ; sb . push ( `template` ) ; } if ( item . committer ) { sb . push ( `template` ) ; } if ( item . committer && item . committer . date ) { const committerDate = item . committer ! . date ! . toLocaleString ( ) ; sb . push ( `template` ) ; } if ( item . subject ) { sb . push ( `template` ) ; } if ( item . body ) { sb . push ( `template` ) ; } if ( item . notes ) { sb . push ( `template` ) ; } return sb . join ( EOL ) ; } public formatAuthor ( logEntry ) { return `template` ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $LogEntry$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $LogEntry$ O O O O O O O
import { Container , injectable , interfaces } from 's' ; import { Abstract , IServiceContainer , Newable } from 's' ; @ injectable ( ) export class ServiceContainer implements IServiceContainer { constructor ( private container ) { } public get < T > ( serviceIdentifier : interfaces . ServiceIdentifier < T > ) : T { return this . container . get < T > ( serviceIdentifier ) ; } public getAll < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , name ? : string | number | symbol | undefined ) : T [ ] { return name ? this . container . getAllNamed < T > ( serviceIdentifier , name ) : this . container . getAll < T > ( serviceIdentifier ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Container$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceContainer } from 's' ; let container ; export function getServiceContainer ( ) { return container ; } export function setServiceContainer ( serviceContainer ) { container = serviceContainer ; }	O O O O O O O O $IServiceContainer$ O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O
import { Container } from 's' ; import { Abstract , IServiceManager , Newable } from 's' ; export class ServiceManager implements IServiceManager { constructor ( private container ) { } public add < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , constructor : new ( ... args : any [ ] ) => T , name ? : string | number | symbol | undefined ) { if ( name ) { this . container . bind < T > ( serviceIdentifier ) . to ( constructor ) . inSingletonScope ( ) . whenTargetNamed ( name ) ; } else { this . container . bind < T > ( serviceIdentifier ) . to ( constructor ) . inSingletonScope ( ) ; } } public addSingleton < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , constructor : new ( ... args : any [ ] ) => T , name ? : string | number | symbol | undefined ) { if ( name ) { this . container . bind < T > ( serviceIdentifier ) . to ( constructor ) . inSingletonScope ( ) . whenTargetNamed ( name ) ; } else { this . container . bind < T > ( serviceIdentifier ) . to ( constructor ) . inSingletonScope ( ) ; } } public addSingletonInstance < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , instance : T , name ? : string | number | symbol | undefined ) { if ( name ) { this . container . bind < T > ( serviceIdentifier ) . toConstantValue ( instance ) . whenTargetNamed ( name ) ; } else { this . container . bind < T > ( serviceIdentifier ) . toConstantValue ( instance ) ; } } public get < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , name ? : string | number | symbol | undefined ) : T { return name ? this . container . getNamed < T > ( serviceIdentifier , name ) : this . container . get < T > ( serviceIdentifier ) ; } public getAll < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , name ? : string | number | symbol | undefined ) : T [ ] { return name ? this . container . getAllNamed < T > ( serviceIdentifier , name ) : this . container . getAll < T > ( serviceIdentifier ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $Container$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { CommitDetails , CompareCommitDetails , CompareFileCommitDetails , FileCommitDetails } from 's' ; import { CommittedFile } from 's' ; import { DirectoryNode , FileNode , INodeFactory } from 's' ; @ injectable ( ) export class StandardNodeFactory implements INodeFactory { public createDirectoryNode ( commit , relativePath ) { return new DirectoryNode ( commit , relativePath ) ; } public createFileNode ( commit , committedFile ) { return new FileNode ( new FileCommitDetails ( commit . workspaceFolder , commit . branch , commit . logEntry , committedFile ) ) ; } } @ injectable ( ) export class ComparisonNodeFactory implements INodeFactory { public createDirectoryNode ( commit , relativePath ) { return new DirectoryNode ( commit , relativePath ) ; } public createFileNode ( commit , committedFile ) { const compareCommit = commit as CompareCommitDetails ; return new FileNode ( new CompareFileCommitDetails ( compareCommit , compareCommit . rightCommit , committedFile ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O $string$ O O O O O O O O O O O O O O O $CommitDetails$ O $CommittedFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O $string$ O O O O O O O O O O O O O O O $CommitDetails$ O $CommittedFile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { ComparisonNodeFactory , StandardNodeFactory } from 's' ; import { INodeFactory } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . addSingleton < INodeFactory > ( INodeFactory , StandardNodeFactory , 's' ) ; serviceManager . addSingleton < INodeFactory > ( INodeFactory , ComparisonNodeFactory , 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as fs from 's' ; import * as fse from 's' ; import { inject , injectable } from 's' ; import * as path from 's' ; import { IFileSystem , IPlatformService } from 's' ; @ injectable ( ) export class FileSystem implements IFileSystem { constructor ( @ inject ( IPlatformService ) private platformService ) { } public get directorySeparatorChar ( ) : string { return path . sep ; } public objectExistsAsync ( filePath , statCheck : ( s : fs . Stats ) => boolean ) < boolean > { return new Promise < boolean > ( resolve => { fse . stat ( filePath , ( error , stats ) => { if ( error ) { return resolve ( false ) ; } return resolve ( statCheck ( stats ) ) ; } ) ; } ) ; } public fileExistsAsync ( filePath ) < boolean > { return this . objectExistsAsync ( filePath , ( stats ) => stats . isFile ( ) ) ; } public directoryExistsAsync ( filePath ) < boolean > { return this . objectExistsAsync ( filePath , ( stats ) => stats . isDirectory ( ) ) ; } public createDirectoryAsync ( directoryPath ) < void > { return fse . mkdirp ( directoryPath ) ; } public getSubDirectoriesAsync ( rootDir ) < string [ ] > { return new Promise < string [ ] > ( resolve => { fs . readdir ( rootDir , ( error , files ) => { if ( error ) { return resolve ( [ ] ) ; } const subDirs : string [ ] = [ ] ; files . forEach ( name => { const fullPath = path . join ( rootDir , name ) ; try { if ( fs . statSync ( fullPath ) . isDirectory ( ) ) { subDirs . push ( fullPath ) ; } } catch ( ex ) { } } ) ; resolve ( subDirs ) ; } ) ; } ) ; } public arePathsSame ( 0 , 0 ) { const 0 = path . normalize ( 0 ) ; const 0 = path . normalize ( 0 ) ; if ( this . platformService . isWindows ) { return 0 . toUpperCase ( ) === 0 . toUpperCase ( ) ; } else { return 0 === 0 ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPlatformService$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { injectable } from 's' ; import { arch } from 's' ; import { IPlatformService } from 's' ; @ injectable ( ) export class PlatformService implements IPlatformService { private _isWindows : boolean ; private _isMac : boolean ; constructor ( ) { this . _isWindows = "s" . test ( process . platform ) ; this . _isMac = "s" . test ( process . platform ) ; } public get isWindows ( ) : boolean { return this . _isWindows ; } public get isMac ( ) : boolean { return this . _isMac ; } public get isLinux ( ) : boolean { return ! ( this . isWindows || this . isMac ) ; } public get 0 ( ) : boolean { return arch ( ) === 's' ; } public get pathVariableName ( ) { return this . isWindows ? 's' : 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { FileSystem } from 's' ; import { PlatformService } from 's' ; import { IFileSystem , IPlatformService } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . add < IPlatformService > ( IPlatformService , PlatformService ) ; serviceManager . add < IFileSystem > ( IFileSystem , FileSystem ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as querystring from 's' ; import { CancellationToken , TextDocumentContentProvider , Uri } from 's' ; import { ILogService } from 's' ; import { IServiceContainer } from 's' ; import { BranchSelection } from 's' ; export class ContentProvider implements TextDocumentContentProvider { constructor ( private serviceContainer ) { } public provideTextDocumentContent ( uri , _token ) { const query = querystring . parse ( uri . query . toString ( ) ) ! ; const port = parseInt ( query . port ! . toString ( ) , 0 ) ; const id = query . id ! as string ; const branchName : string | undefined = query . branchName ? decodeURIComponent ( query . branchName ! as string ) : 's' ; const branchSelection = parseInt ( query . branchSelection ! . toString ( ) , 0 ) as BranchSelection ; const locale = decodeURIComponent ( query . locale ! . toString ( ) ) as string ; const file = decodeURIComponent ( query . file ! . toString ( ) ) as string ; return this . generateResultsView ( port , id , branchName , branchSelection , locale , file ) ; } private generateResultsView ( port , id , branchName , branchSelection , locale , file ) { const timeNow = 's' ; const queryArgs = [ `template` , `template` , `template` , 's' , `template` , `template` ] ; const uri = `template` ; this . serviceContainer . getAll < ILogService > ( ILogService ) . forEach ( logger => { logger . log ( `template` ) ; } ) ; return `template` ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O $string$ O $Uri$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchSelection$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $string$ O $string$ O $BranchSelection$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject } from 's' ; import { Disposable , Uri , ViewColumn , Webview , WebviewPanel } from 's' ; import { window } from 's' ; import { ICommandManager } from 's' ; import { IServiceContainer } from 's' ; import { ContentProvider } from 's' ; export class HtmlViewer { private readonly disposable : Disposable [ ] = [ ] ; private readonly contentProvider : ContentProvider ; private readonly htmlView : Map < string , WebviewPanel > ; constructor ( @ inject ( IServiceContainer ) serviceContainer ) { this . htmlView = new Map < string , WebviewPanel > ( ) ; const commandManager = serviceContainer . get < ICommandManager > ( ICommandManager ) ; this . disposable . push ( commandManager . registerCommand ( 's' , this . onPreviewHtml ) ) ; this . contentProvider = new ContentProvider ( serviceContainer ) ; } public dispose ( ) { this . disposable . forEach ( disposable => disposable . dispose ( ) ) ; } private onPreviewHtml = ( uri , column , title ) => { return this . getHtmlView ( Uri . parse ( uri ) , column , title ) ; } private getHtmlView ( uri , column , title ) { if ( this . htmlView . has ( uri . toString ( ) ) ) { return this . htmlView . get ( uri . toString ( ) ) ! . webview ; } const htmlContent = this . contentProvider . provideTextDocumentContent ( uri , undefined as any ) ; const webviewPanel = window . createWebviewPanel ( 's' , title , column , { enableScripts : true , retainContextWhenHidden : true } ) ; this . htmlView . set ( uri . toString ( ) , webviewPanel ) ; webviewPanel . onDidDispose ( ( ) => { if ( this . htmlView . has ( uri . toString ( ) ) ) { this . htmlView . delete ( uri . toString ( ) ) ; } } ) ; webviewPanel . webview . html = htmlContent ; return webviewPanel . webview ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $ViewColumn$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $Webview$ O $Uri$ O $ViewColumn$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Express , Request , Response } from 's' ; import { injectable } from 's' ; import { Uri } from 's' ; import { IAvatarProvider } from 's' ; import { GitOriginType } from 's' ; import { ICommandManager } from 's' ; import { IGitCommitViewDetailsCommandHandler } from 's' ; import { CommitDetails , FileCommitDetails } from 's' ; import { IServiceContainer } from 's' ; import { BranchSelection , CommittedFile , IGitService , IGitServiceFactory , LogEntries , LogEntriesResponse , LogEntry , Avatar } from 's' ; import { IApiRouteHandler , IWorkspaceQueryStateStore } from 's' ; @ injectable ( ) export class ApiController implements IApiRouteHandler { private readonly commitViewer : IGitCommitViewDetailsCommandHandler ; constructor ( private app , private gitServiceFactory , private serviceContainer , private stateStore , private commandManager ) { this . commitViewer = this . serviceContainer . get < IGitCommitViewDetailsCommandHandler > ( IGitCommitViewDetailsCommandHandler ) ; this . app . get ( 's' , this . handleRequest ( this . getLogEntries . bind ( this ) ) ) ; this . app . get ( 's' , this . handleRequest ( this . getBranches . bind ( this ) ) ) ; this . app . get ( 's' , this . handleRequest ( this . getCommit . bind ( this ) ) ) ; this . app . post ( 's' , this . handleRequest ( this . clearSelectedCommit . bind ( this ) ) ) ; this . app . post ( 's' , this . handleRequest ( this . doSomethingWithCommit . bind ( this ) ) ) ; this . app . post ( 's' , this . handleRequest ( this . selectCommittedFile . bind ( this ) ) ) ; this . app . post ( 's' , this . handleRequest ( this . getAvatars . bind ( this ) ) ) ; this . app . get ( 's' , this . handleRequest ( this . getAuthors . bind ( this ) ) ) ; } public dispose ( ) { } public getLogEntries = async ( request , response ) => { const id = decodeURIComponent ( request . query . id ) ; const currentState = this . stateStore . getState ( id ) ; const refresh = request . query . refresh === 's' ; let searchText = request . query . searchText ; if ( currentState && currentState . searchText && typeof searchText !== 's' ) { searchText = currentState . searchText ; } searchText = typeof searchText === 's' && searchText . length === 0 ? undefined : searchText ; let pageIndex : number | undefined = request . query . pageIndex ? parseInt ( request . query . pageIndex , 0 ) : undefined ; if ( currentState && currentState . pageIndex && typeof pageIndex !== 's' ) { pageIndex = currentState . pageIndex ; } let author : string | undefined = typeof request . query . author === 's' ? request . query . author : undefined ; if ( currentState && currentState . author && typeof author !== 's' ) { author = currentState . author ; } let lineNumber : number | undefined = request . query . lineNumber ? parseInt ( request . query . lineNumber , 0 ) : undefined ; if ( currentState && currentState . lineNumber && typeof lineNumber !== 's' ) { lineNumber = currentState . lineNumber ; } let branch = request . query . branch ; if ( currentState && currentState . branch && typeof branch !== 's' ) { branch = currentState . branch ; } let pageSize : number | undefined = request . query . pageSize ? parseInt ( request . query . pageSize , 0 ) : undefined ; if ( currentState && currentState . pageSize && ( typeof pageSize !== 's' || pageSize === 0 ) ) { pageSize = currentState . pageSize ; } if ( typeof lineNumber === 's' ) { pageSize = 0 ; } const filePath : string | undefined = request . query . file ; let file = filePath ? Uri . file ( filePath ) : undefined ; if ( currentState && currentState . file && ! file ) { file = currentState . file ; } let branchSelection = request . query . pageSize ? parseInt ( request . query . branchSelection , 0 ) as BranchSelection : undefined ; if ( currentState && currentState . branchSelection && typeof branchSelection !== 's' ) { branchSelection = currentState . branchSelection ; } let promise < LogEntries > ; const branchesMatch = currentState && ( currentState . branch === branch ) ; const noBranchDefinedByClient = ! currentState ; if ( ! refresh && searchText === undefined && pageIndex === undefined && pageSize === undefined && ( file === undefined || ( currentState && currentState . file && currentState . file . fsPath === file . fsPath ) ) && ( author === undefined || ( currentState && currentState . author === author ) ) && currentState && currentState . entries && ( branchesMatch || noBranchDefinedByClient ) ) { let selected : LogEntry | undefined ; if ( currentState . lastFetchedCommit ) { selected = await currentState . lastFetchedCommit ; } promise = currentState . entries . then ( data => { const entriesResponse = { ... data , branch : currentState . branch , author : currentState . author , lineNumber : currentState . lineNumber , branchSelection : currentState . branchSelection , file : currentState . file , pageIndex : currentState . pageIndex , pageSize : currentState . pageSize , searchText : currentState . searchText , selected : selected } ; return entriesResponse ; } ) ; } else if ( ! refresh && currentState && ( currentState . searchText === ( searchText || 's' ) ) && currentState . pageIndex === pageIndex && ( typeof branch === 's' && currentState . branch === branch ) && currentState . pageSize === pageSize && currentState . file === file && currentState . author === author && currentState . lineNumber === lineNumber && currentState . entries ) { promise = currentState . entries ; } else { promise = ( await this . getRepository ( decodeURIComponent ( request . query . id ) ) ) . getLogEntries ( pageIndex , pageSize , branch , searchText , file , lineNumber , author ) . then ( data => { const entriesResponse = { ... data , branch , author , branchSelection , file , pageIndex , pageSize , searchText , selected : undefined } ; return entriesResponse ; } ) ; this . stateStore . updateEntries ( id , promise , pageIndex , pageSize , branch , searchText , file , branchSelection , lineNumber , author ) ; } try { const data = await promise ; response . send ( data ) ; } catch ( err ) { response . status ( 0 ) . send ( err ) ; } } public getBranches = async ( request , response ) => { const id = decodeURIComponent ( request . query . id ) ; ( await this . getRepository ( id ) ) . getBranches ( ) . then ( data => response . send ( data ) ) . catch ( err => response . status ( 0 ) . send ( err ) ) ; } public getAuthors = async ( request , response ) => { const id = decodeURIComponent ( request . query . id ) ; ( await this . getRepository ( id ) ) . getAuthors ( ) . then ( data => response . send ( data ) ) . catch ( err => response . status ( 0 ) . send ( err ) ) ; } public getCommit = async ( request , response ) => { const id = decodeURIComponent ( request . query . id ) ; const hash = request . params . hash ; const currentState = this . stateStore . getState ( id ) ; let commitPromise < LogEntry | undefined > ; if ( currentState && currentState . lastFetchedHash === hash && currentState . lastFetchedCommit ) { commitPromise = currentState . lastFetchedCommit ; } else { commitPromise = ( await this . getRepository ( id ) ) . getCommit ( hash ) ; this . stateStore . updateLastHashCommit ( id , hash , commitPromise ) ; } commitPromise . then ( data => { response . send ( data ) ; if ( data && currentState ) { this . commitViewer . viewCommitTree ( new CommitDetails ( currentState ! . workspaceFolder , currentState ! . branch ! , data ! ) ) ; } } ) . catch ( err => { response . status ( 0 ) . send ( err ) ; } ) ; } public getAvatars = async ( request , response ) : Promise < any | void > => { const id = decodeURIComponent ( request . query . id ) ; try { const repo = await this . getRepository ( id ) ; const originType = await repo . getOriginType ( ) ; if ( ! originType ) { return response . send ( ) ; } const providers = this . serviceContainer . getAll < IAvatarProvider > ( IAvatarProvider ) ; const provider = providers . find ( item => item . supported ( originType ) ) ; const genericProvider = providers . find ( item => item . supported ( GitOriginType . any ) ) ! ; let avatars : Avatar [ ] ; if ( provider ) { avatars = await provider . getAvatars ( repo ) ; } else { avatars = await genericProvider . getAvatars ( repo ) ; } response . send ( avatars ) ; } catch ( err ) { response . status ( 0 ) . send ( err ) ; } } public clearSelectedCommit = async ( request , response ) => { const id = decodeURIComponent ( request . query . id ) ; await this . stateStore . clearLastHashCommit ( id ) ; response . send ( 's' ) ; } public doSomethingWithCommit = async ( request , response ) => { response . status ( 0 ) . send ( 's' ) ; const id = decodeURIComponent ( request . query . id ) ; const workspaceFolder = this . getWorkspace ( id ) ; const currentState = this . stateStore . getState ( id ) ! ; const logEntry = request . body as LogEntry ; this . commandManager . executeCommand ( 's' , new CommitDetails ( workspaceFolder , currentState . branch ! , logEntry ) ) ; } public selectCommittedFile = async ( request , response ) => { response . status ( 0 ) . send ( 's' ) ; const id = decodeURIComponent ( request . query . id ) ; const body = request . body as { logEntry : LogEntry ; committedFile : CommittedFile } ; const workspaceFolder = this . getWorkspace ( id ) ; const currentState = this . stateStore . getState ( id ) ! ; this . commandManager . executeCommand ( 's' , new FileCommitDetails ( workspaceFolder , currentState . branch ! , body . logEntry , body . committedFile ) ) ; } private handleRequest = ( handler : ( request , response ) => void ) => { return async ( request , response ) => { try { await handler ( request , response ) ; } catch ( err ) { response . status ( 0 ) . send ( err ) ; } } ; } private getWorkspace ( id ) { return this . stateStore . getState ( id ) ! . workspaceFolder ; } private getGitRoot ( id ) { return this . stateStore . getState ( id ) ! . gitRoot ; } private async getRepository ( id ) < IGitService > { const workspaceFolder = this . getWorkspace ( id ) ; return this . gitServiceFactory . createGitService ( workspaceFolder , Uri . file ( this . getGitRoot ( id ) ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Express$ O O $IGitServiceFactory$ O O $IServiceContainer$ O O $IWorkspaceQueryStateStore$ O O $ICommandManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntriesResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogEntriesResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O $string$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O O O O O O O $Request$ O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as bodyParser from 's' ; import * as cors from 's' ; import { EventEmitter } from 's' ; import { Express , Request , Response } from 's' ; import * as express from 's' ; import * as http from 's' ; import { inject } from 's' ; import * as path from 's' ; import { ICommandManager } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; import { ApiController } from 's' ; import { IServerHost , IThemeService , IWorkspaceQueryStateStore , StartupInfo } from 's' ; export class ServerHost extends EventEmitter implements IServerHost { private app ? : Express ; private httpServer ? : http . Server ; private apiController : ApiController ; private port ? : number ; private startPromise : Promise < StartupInfo > ; constructor ( @ inject ( IThemeService ) private themeService , @ inject ( IGitServiceFactory ) private gitServiceFactory , @ inject ( IServiceContainer ) private serviceContainer , @ inject ( IWorkspaceQueryStateStore ) private stateStore ) { super ( ) ; } public dispose ( ) { this . app = undefined ; this . port = undefined ; if ( this . httpServer ) { this . httpServer . close ( ) ; this . httpServer = undefined ; } if ( this . apiController ) { this . apiController . dispose ( ) ; } } public async start ( _workspaceFolder ) < StartupInfo > { if ( this . startPromise ) { return this . startPromise ; } this . app = express ( ) ; this . httpServer = http . createServer ( this . app as any ) ; const rootDirectory = path . join ( __dirname , 's' , 's' , 's' ) ; const node_modulesDirectory = path . join ( __dirname , 's' , 's' , 's' , 's' ) ; this . app . use ( bodyParser . urlencoded ( { extended : false } ) ) ; this . app . use ( bodyParser . json ( ) ) ; this . app . use ( express . static ( rootDirectory ) ) ; this . app . use ( express . static ( path . join ( __dirname , 's' , 's' , 's' , 's' ) , { extensions : [ 's' , 's' , 's' , 's' ] } ) ) ; this . app . use ( express . static ( path . join ( node_modulesDirectory , 's' , 's' ) ) ) ; this . app . use ( express . static ( path . join ( node_modulesDirectory , 's' ) ) ) ; this . app . use ( express . static ( path . join ( node_modulesDirectory , 's' ) ) ) ; this . app . use ( express . static ( path . join ( node_modulesDirectory , 's' ) ) ) ; this . app . use ( express . static ( path . join ( node_modulesDirectory , 's' , 's' , 's' ) ) ) ; this . app . use ( cors ( ) ) ; this . app . get ( 's' , ( req , res ) => { this . rootRequestHandler ( req , res ) ; } ) ; return this . startPromise = new Promise < StartupInfo > ( ( resolve , reject ) => { const commandManager = this . serviceContainer . get < ICommandManager > ( ICommandManager ) ; this . apiController = new ApiController ( this . app ! , this . gitServiceFactory , this . serviceContainer , this . stateStore , commandManager ) ; this . httpServer ! . listen ( 0 , ( ) => { this . port = this . httpServer ! . address ( ) . port ; resolve ( { port : this . port } ) ; } ) ; this . httpServer ! . on ( 's' , error => { if ( ! this . port ) { reject ( error ) ; } } ) ; } ) ; } public rootRequestHandler ( req , res ) { const theme = req . query . theme ; const backgroundColor = req . query . backgroundColor ; const color = req . query . color ; const themeDetails = this . themeService . getThemeDetails ( theme , backgroundColor , color ) ; res . render ( path . join ( __dirname , 's' , 's' , 's' , 's' ) , themeDetails ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IThemeService$ O O O O O O O $IGitServiceFactory$ O O O O O O O $IServiceContainer$ O O O O O O O $IWorkspaceQueryStateStore$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O $Response$ O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { Uri } from 's' ; import { BranchSelection , LogEntries , LogEntry } from 's' ; import { IWorkspaceQueryStateStore , State } from 's' ; @ injectable ( ) export class StateStore implements IWorkspaceQueryStateStore { private storesPerWorkspace = new Map < string , State > ( ) ; public async initialize ( id , workspaceFolder , gitRoot , branch , branchSelection , searchText ? , file ? , lineNumber ? , author ? ) < void > { this . storesPerWorkspace . set ( id , { gitRoot : gitRoot , branch , branchSelection , workspaceFolder , searchText , file , lineNumber , author } ) ; } public async updateEntries ( id , entries ? < LogEntries > , pageIndex ? , pageSize ? , branch ? , searchText ? , file ? , branchSelection ? , lineNumber ? , author ? ) < void > { const state = this . storesPerWorkspace . get ( id ) ! ; state . branch = branch ; state . entries = entries ; state . author = author ; state . pageIndex = pageIndex ; state . lineNumber = lineNumber ; state . pageSize = pageSize ; state . searchText = searchText ; state . file = file ; state . branchSelection = branchSelection ; this . storesPerWorkspace . set ( id , state ) ; } public async updateLastHashCommit ( id , hash , commit < LogEntry > ) < void > { const state = this . storesPerWorkspace . get ( id ) ! ; state . lastFetchedHash = hash ; state . lastFetchedCommit = commit ; this . storesPerWorkspace . set ( id , state ) ; } public async clearLastHashCommit ( id ) < void > { const state = this . storesPerWorkspace . get ( id ) ! ; state . lastFetchedHash = undefined ; state . lastFetchedCommit = undefined ; this . storesPerWorkspace . set ( id , state ) ; } public getState ( id ) : Readonly < State > | undefined { return this . storesPerWorkspace . get ( id ) ; } public dispose ( ) { this . storesPerWorkspace . clear ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O $string$ O $string$ O $BranchSelection$ O O $string$ O O $Uri$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O $Promise$ O O O O O $number$ O O $number$ O O $string$ O O $string$ O O $Uri$ O O $BranchSelection$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { injectable } from 's' ; import { workspace } from 's' ; import { IThemeService , ThemeDetails } from 's' ; @ injectable ( ) export class ThemeService implements IThemeService { public getThemeDetails ( theme , backgroundColor , color ) { const editorConfig = workspace . getConfiguration ( 's' ) ; const fontFamily = editorConfig . get < string > ( 's' ) ! . split ( 's' ) . join ( 's' ) . split ( 's' ) . join ( 's' ) ; const fontSize = `template` ; const fontWeight = editorConfig . get < string > ( 's' ) ; return { theme : theme , backgroundColor : backgroundColor , color : color , fontFamily : fontFamily , fontSize : fontSize , fontWeight : fontWeight } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ThemeDetails$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as querystring from 's' ; import { CancellationToken , TextDocumentContentProvider , Uri } from 's' ; import { IServiceContainer } from 's' ; import { IGitServiceFactory } from 's' ; export class CommitFileViewerProvider implements TextDocumentContentProvider { constructor ( private svcContainer ) { } public async provideTextDocumentContent ( uri , _token ) < string > { const query = querystring . parse ( uri . query ) as { workspaceFolder : string ; hash : string ; fsPath : string } ; const gitService = await this . svcContainer . get < IGitServiceFactory > ( IGitServiceFactory ) . createGitService ( query . workspaceFolder , Uri . parse ( query . fsPath ) ) ; return gitService . getCommitFileContent ( query . hash , Uri . file ( query . fsPath ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O $Promise$ O $Uri$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; const resourcesPath = path . join ( __dirname , 's' , 's' , 's' , 's' ) ; export const GitCommitIcon = { dark : path . join ( resourcesPath , 's' , 's' ) , light : path . join ( resourcesPath , 's' , 's' , 's' ) } ; export const FolderIcon = { dark : path . join ( resourcesPath , 's' , 's' ) , light : path . join ( resourcesPath , 's' , 's' ) } ; export const AddedIcon = { light : path . join ( resourcesPath , 's' , 's' , 's' ) , dark : path . join ( resourcesPath , 's' , 's' , 's' ) } ; export const RemovedIcon = { light : path . join ( resourcesPath , 's' , 's' , 's' ) , dark : path . join ( resourcesPath , 's' , 's' , 's' ) } ; export const ModifiedIcon = { light : path . join ( resourcesPath , 's' , 's' , 's' ) , dark : path . join ( resourcesPath , 's' , 's' , 's' ) } ; export const FileIcon = { dark : path . join ( resourcesPath , 's' , 's' ) , light : path . join ( resourcesPath , 's' , 's' ) } ; export const RenameIcon = { light : path . join ( resourcesPath , 's' , 's' , 's' ) , dark : path . join ( resourcesPath , 's' , 's' , 's' ) } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as path from 's' ; import { IFileCommitCommandFactory } from 's' ; import { CommitDetails } from 's' ; import { IPlatformService } from 's' ; import { CommittedFile , Status } from 's' ; import { AddedIcon , FileIcon , FolderIcon , ModifiedIcon , RemovedIcon } from 's' ; import { DirectoryTreeItem , FileTreeItem } from 's' ; import { DirectoryNode , FileNode , INodeBuilder , INodeFactory } from 's' ; @ injectable ( ) export class NodeBuilder implements INodeBuilder { constructor ( @ inject ( IFileCommitCommandFactory ) private fileCommandFactory , private nodeFactory , @ inject ( IPlatformService ) private platform ) { } public buildTree ( commit , committedFiles : CommittedFile [ ] ) : ( DirectoryNode | FileNode ) [ ] { const sortedFiles = committedFiles ! . sort ( ( a , b ) => a . uri . fsPath . toUpperCase ( ) > b . uri . fsPath . toUpperCase ( ) ? 0 : - 0 ) ; const commitFileDetails = new Map < string , CommittedFile > ( ) ; sortedFiles . forEach ( item => commitFileDetails . set ( item . uri . fsPath , item ) ) ; const nodes = new Map < string , DirectoryNode | FileNode > ( ) ; const roots : ( DirectoryNode | FileNode ) [ ] = [ ] ; sortedFiles . forEach ( file => { const dirName = path . dirname ( file . relativePath ) ; const dirNode = dirName . split ( path . sep ) . reduce < DirectoryNode | undefined > ( ( parent , folderName , index ) => { if ( folderName === 's' && index === 0 ) { return undefined ; } const currentPath = parent ? path . join ( parent ! . resource . fsPath , folderName ) : folderName ; const nodeExists = nodes . has ( currentPath ) ; if ( nodes . has ( currentPath ) ) { return nodes . get ( currentPath ) ! ; } const folderNode = this . nodeFactory . createDirectoryNode ( commit , currentPath ) ; nodes . set ( currentPath , folderNode ) ; if ( parent ) { parent ! . children . push ( folderNode ) ; } if ( index === 0 && ! nodeExists ) { roots . push ( folderNode ) ; } return folderNode ; } , undefined as any ) ; const fileNode = this . nodeFactory . createFileNode ( commit , file ) ; if ( dirNode ) { dirNode ! . children . push ( fileNode ) ; } else { roots . push ( fileNode ) ; } } ) ; nodes . forEach ( node => node . children = this . sortNodes ( node . children ) ) ; return this . sortNodes ( roots ) ; } public buildList ( commit , committedFiles : CommittedFile [ ] ) : FileNode [ ] { const nodes = committedFiles . map ( file => this . nodeFactory . createFileNode ( commit , file ) ) ; return this . sortFileNodes ( nodes ) ; } public async getTreeItem ( element : DirectoryNode | FileNode ) < DirectoryTreeItem | FileTreeItem > { if ( element instanceof DirectoryNode ) { return this . buildDirectoryTreeItem ( element as DirectoryNode ) ; } else { return this . buildFileTreeItem ( element ) ; } } public buildDirectoryTreeItem ( element ) { const treeItem = new DirectoryTreeItem ( element as DirectoryNode ) ; treeItem . iconPath = FolderIcon ; treeItem . contextValue = 's' ; if ( treeItem . command ) { treeItem . command ! . tooltip = 's' ; } return treeItem ; } public async buildFileTreeItem ( element ) < FileTreeItem > { const treeItem = new FileTreeItem ( element ) ; switch ( element . data ! . committedFile . status ) { case Status . Added : { treeItem . iconPath = AddedIcon ; break ; } case Status . Modified : { treeItem . iconPath = ModifiedIcon ; break ; } case Status . Deleted : { treeItem . iconPath = RemovedIcon ; break ; } case Status . Renamed : { treeItem . iconPath = RemovedIcon ; break ; } default : { treeItem . iconPath = FileIcon ; } } treeItem . contextValue = 's' ; treeItem . command = await this . fileCommandFactory . getDefaultFileCommand ( element . data ! ) ; return treeItem ; } private sortNodes ( nodes : ( DirectoryNode | FileNode ) [ ] ) : ( DirectoryNode | FileNode ) [ ] { let directoryNodes = nodes . filter ( node => node instanceof DirectoryNode ) . map ( node => node as DirectoryNode ) ; let fileNodes = nodes . filter ( node => node instanceof FileNode ) . map ( node => node as FileNode ) ; if ( this . platform . isWindows ) { directoryNodes = directoryNodes . sort ( ( a , b ) => a . label . toUpperCase ( ) > b . label . toUpperCase ( ) ? 0 : - 0 ) ; fileNodes = fileNodes . sort ( ( a , b ) => a . label . toUpperCase ( ) > b . label . toUpperCase ( ) ? 0 : - 0 ) ; } else { directoryNodes = directoryNodes . sort ( ( a , b ) => a . label > b . label ? 0 : - 0 ) ; fileNodes = fileNodes . sort ( ( a , b ) => a . label > b . label ? 0 : - 0 ) ; } return this . sortDirectoryNodes ( directoryNodes ) . concat ( this . sortFileNodes ( fileNodes ) ) ; } private sortDirectoryNodes ( nodes : DirectoryNode [ ] ) : DirectoryNode [ ] { const directoryNodes = nodes . filter ( node => node instanceof DirectoryNode ) . map ( node => node as DirectoryNode ) ; if ( this . platform . isWindows ) { return directoryNodes . sort ( ( a , b ) => a . label . toUpperCase ( ) > b . label . toUpperCase ( ) ? 0 : - 0 ) ; } else { return directoryNodes . sort ( ( a , b ) => a . label > b . label ? 0 : - 0 ) ; } } private sortFileNodes ( nodes : FileNode [ ] ) : FileNode [ ] { const fileNodes = nodes . filter ( node => node instanceof FileNode ) . map ( node => node as FileNode ) ; if ( this . platform . isWindows ) { return fileNodes . sort ( ( a , b ) => a . label . toUpperCase ( ) > b . label . toUpperCase ( ) ? 0 : - 0 ) ; } else { return fileNodes . sort ( ( a , b ) => a . label > b . label ? 0 : - 0 ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IFileCommitCommandFactory$ O O $INodeFactory$ O O O O O O O $IPlatformService$ O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DirectoryTreeItem$ O $DirectoryNode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $FileNode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable } from 's' ; import * as path from 's' ; import { EventEmitter , TreeDataProvider , TreeItemCollapsibleState , window } from 's' ; import { Event , OutputChannel , TreeItem } from 's' ; import { ICommandManager } from 's' ; import { CommitDetails , CompareCommitDetails } from 's' ; import { ICommitViewFormatter } from 's' ; import { DirectoryTreeItem } from 's' ; import { DirectoryNode , FileNode , INodeBuilder } from 's' ; import { IOutputChannel } from 's' ; import { ICommitViewer } from 's' ; @ injectable ( ) export class CommitViewer implements ICommitViewer , TreeDataProvider < DirectoryNode | FileNode > { private registered : boolean = false ; private commit ? : CommitDetails ; private _onDidChangeTreeData = new EventEmitter < DirectoryNode | FileNode > ( ) ; private fileView : boolean = false ; public get onDidChangeTreeData ( ) : Event < DirectoryNode | FileNode > { return this . _onDidChangeTreeData . event ; } public get selectedCommit ( ) : Readonly < CommitDetails > { return this . commit ! ; } constructor ( @ inject ( IOutputChannel ) private outputChannel , @ inject ( ICommitViewFormatter ) private commitFormatter , @ inject ( ICommandManager ) private commandManager , private nodeBuilder , private treeId , private visibilityContextVariable ) { } public showCommitTree ( commit ) { this . commit = commit ; if ( ! this . registered ) { this . registered = true ; window . registerTreeDataProvider ( this . treeId , this ) ; } this . _onDidChangeTreeData . fire ( ) ; this . commandManager . executeCommand ( 's' , this . visibilityContextVariable , true ) ; } public showCommit ( commit ) { const output = this . commitFormatter . format ( commit . logEntry ) ; this . outputChannel . appendLine ( output ) ; this . outputChannel . show ( ) ; } public showFilesView ( ) { this . fileView = true ; this . _onDidChangeTreeData . fire ( ) ; } public showFolderView ( ) { this . fileView = false ; this . _onDidChangeTreeData . fire ( ) ; } public async getTreeItem ( element : DirectoryNode | FileNode ) < TreeItem > { const treeItem = await this . nodeBuilder . getTreeItem ( element ) ; if ( treeItem instanceof DirectoryTreeItem ) { treeItem . collapsibleState = TreeItemCollapsibleState . Expanded ; } if ( this . fileView ) { const fileDirectory = path . dirname ( element . resource . fsPath ) ; const isEmptyPath = fileDirectory === path . sep ; treeItem . label = `template` . trim ( ) ; } return treeItem ; } public async getChildren ( element ? : DirectoryNode | FileNode | undefined ) < ( DirectoryNode | FileNode ) [ ] > { if ( ! element ) { const committedFiles = this . treeId === 's' ? this . commit ! . logEntry . committedFiles ! : ( this . commit as CompareCommitDetails ) . committedFiles ; return this . fileView ? this . nodeBuilder . buildList ( this . commit ! , committedFiles ) : this . nodeBuilder . buildTree ( this . commit ! , committedFiles ) ; } if ( element ! instanceof DirectoryNode ) { return ( element as DirectoryNode ) . children ; } return [ ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OutputChannel$ O O O O O O O $ICommitViewFormatter$ O O O O O O O $ICommandManager$ O O $INodeBuilder$ O O $string$ O O $string$ O O O O O O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $CommitDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { inject , injectable , named } from 's' ; import { OutputChannel } from 's' ; import { ICommandManager } from 's' ; import { IFileCommitCommandFactory } from 's' ; import { ICommitViewFormatter } from 's' ; import { NodeBuilder } from 's' ; import { INodeFactory } from 's' ; import { IPlatformService } from 's' ; import { IOutputChannel } from 's' ; import { CommitViewer } from 's' ; import { ICommitViewer , ICommitViewerFactory } from 's' ; @ injectable ( ) export class CommitViewerFactory implements ICommitViewerFactory { private commitViewer : ICommitViewer ; private compareViewer : ICommitViewer ; constructor ( @ inject ( IOutputChannel ) private outputChannel , @ inject ( ICommitViewFormatter ) private commitFormatter , @ inject ( ICommandManager ) private commandManager , @ inject ( IPlatformService ) private platformService , @ inject ( IFileCommitCommandFactory ) private fileCommitFactory , @ inject ( INodeFactory ) @ named ( 's' ) private standardNodeFactory , @ inject ( INodeFactory ) @ named ( 's' ) private compareNodeFactory ) { } public getCommitViewer ( ) { if ( this . commitViewer ) { return this . commitViewer ; } return this . commitViewer = new CommitViewer ( this . outputChannel , this . commitFormatter , this . commandManager , new NodeBuilder ( this . fileCommitFactory , this . standardNodeFactory , this . platformService ) , 's' , 's' ) ; } public getCompareCommitViewer ( ) { if ( this . compareViewer ) { return this . compareViewer ; } return this . compareViewer = new CommitViewer ( this . outputChannel , this . commitFormatter , this . commandManager , new NodeBuilder ( this . fileCommitFactory , this . compareNodeFactory , this . platformService ) , 's' , 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OutputChannel$ O O O O O O O $ICommitViewFormatter$ O O O O O O O $ICommandManager$ O O O O O O O $IPlatformService$ O O O O O O O $IFileCommitCommandFactory$ O O O O O O O O O O O O $INodeFactory$ O O O O O O O O O O O O $INodeFactory$ O O O O $ICommitViewer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ICommitViewer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IServiceManager } from 's' ; import { CommitViewerFactory } from 's' ; import { ICommitViewerFactory } from 's' ; export function registerTypes ( serviceManager ) { serviceManager . addSingleton < ICommitViewerFactory > ( ICommitViewerFactory , CommitViewerFactory ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceManager$ O O O O O O O O O O O O O O O
if ( ( Reflect as any ) . metadata === undefined ) { require ( 's' ) ; } import { Container } from 's' ; import * as vscode from 's' ; import { Memento , OutputChannel } from 's' ; import { registerTypes as registerParserTypes } from 's' ; import { registerTypes as registerRepositoryTypes } from 's' ; import { registerTypes as registerAdapterTypes } from 's' ; import { registerTypes as registerApplicationTypes } from 's' ; import { ICommandManager } from 's' ; import { IDisposableRegistry } from 's' ; import { registerTypes as registerCommandFactoryTypes } from 's' ; import { registerTypes as registerCommandTypes } from 's' ; import { Logger } from 's' ; import { ILogService , IUiService } from 's' ; import { OutputPanelLogger } from 's' ; import { UiService } from 's' ; import { gitHistoryFileViewerSchema , gitHistorySchema } from 's' ; import { CommitViewFormatter } from 's' ; import { ICommitViewFormatter } from 's' ; import { ServiceContainer } from 's' ; import { setServiceContainer } from 's' ; import { ServiceManager } from 's' ; import { IServiceContainer } from 's' ; import { getLogChannel } from 's' ; import { registerTypes as registerNodeBuilderTypes } from 's' ; import { registerTypes as registerPlatformTypes } from 's' ; import { ContentProvider } from 's' ; import { HtmlViewer } from 's' ; import { ServerHost } from 's' ; import { StateStore } from 's' ; import { ThemeService } from 's' ; import { IServerHost , IThemeService , IWorkspaceQueryStateStore } from 's' ; import { IGitServiceFactory , IOutputChannel } from 's' ; import { CommitFileViewerProvider } from 's' ; import { registerTypes as registerViewerTypes } from 's' ; let cont ; let serviceManager ; let serviceContainer ; export async function activate ( context : vscode . ExtensionContext ) < any > { cont = new Container ( ) ; serviceManager = new ServiceManager ( cont ) ; serviceContainer = new ServiceContainer ( cont ) ; cont . bind < IServiceContainer > ( IServiceContainer ) . toConstantValue ( serviceContainer ) ; cont . bind < ILogService > ( ILogService ) . to ( Logger ) . inSingletonScope ( ) ; cont . bind < ILogService > ( ILogService ) . to ( OutputPanelLogger ) . inSingletonScope ( ) ; cont . bind < IUiService > ( IUiService ) . to ( UiService ) . inSingletonScope ( ) ; cont . bind < IThemeService > ( IThemeService ) . to ( ThemeService ) . inSingletonScope ( ) ; cont . bind < ICommitViewFormatter > ( ICommitViewFormatter ) . to ( CommitViewFormatter ) . inSingletonScope ( ) ; cont . bind < IWorkspaceQueryStateStore > ( IWorkspaceQueryStateStore ) . to ( StateStore ) . inSingletonScope ( ) ; cont . bind < OutputChannel > ( IOutputChannel ) . toConstantValue ( getLogChannel ( ) ) ; cont . bind < Memento > ( 's' ) . toConstantValue ( context . globalState ) ; cont . bind < Memento > ( 's' ) . toConstantValue ( context . workspaceState ) ; registerParserTypes ( serviceManager ) ; registerRepositoryTypes ( serviceManager ) ; registerAdapterTypes ( serviceManager ) ; registerApplicationTypes ( serviceManager ) ; registerPlatformTypes ( serviceManager ) ; registerCommandFactoryTypes ( serviceManager ) ; registerNodeBuilderTypes ( serviceManager ) ; registerViewerTypes ( serviceManager ) ; setServiceContainer ( serviceContainer ) ; const themeService = serviceContainer . get < IThemeService > ( IThemeService ) ; const gitServiceFactory = serviceContainer . get < IGitServiceFactory > ( IGitServiceFactory ) ; const workspaceQuerySessionStore = serviceContainer . get < IWorkspaceQueryStateStore > ( IWorkspaceQueryStateStore ) ; serviceManager . addSingletonInstance ( IServerHost , new ServerHost ( themeService , gitServiceFactory , serviceContainer , workspaceQuerySessionStore ) ) ; registerCommandTypes ( serviceManager ) ; let disposable = vscode . workspace . registerTextDocumentContentProvider ( gitHistorySchema , new ContentProvider ( serviceContainer ) ) ; context . subscriptions . push ( disposable ) ; disposable = vscode . workspace . registerTextDocumentContentProvider ( gitHistoryFileViewerSchema , new CommitFileViewerProvider ( serviceContainer ) ) ; context . subscriptions . push ( disposable ) ; context . subscriptions . push ( serviceManager . get < IDisposableRegistry > ( IDisposableRegistry ) ) ; const commandManager = serviceContainer . get < ICommandManager > ( ICommandManager ) ; commandManager . executeCommand ( 's' , 's' , true ) ; context . subscriptions . push ( new HtmlViewer ( serviceContainer ) ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Container$ O O $ServiceManager$ O O $ServiceContainer$ O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { expect } from 's' ; import { ActionDetailsParser } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const date = new Date ( ) ; const name = `template` ; const email = `template` ; const unixTime = ( date . getTime ( ) / 0 ) . toString ( ) ; const info = new ActionDetailsParser ( ) . parse ( name , email , unixTime ) ! ; expect ( info ) . to . have . property ( 's' , email , 's' ) ; expect ( info ) . to . have . property ( 's' , name , 's' ) ; expect ( info . date . toLocaleDateString ( ) ) . is . equal ( date . toLocaleDateString ( ) , 's' ) ; } ) ; it ( 's' , ( ) => { const info = new ActionDetailsParser ( ) . parse ( 's' , 's' , 's' ) ! ; expect ( info ) . to . be . an ( 's' , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { ActionDetailsParser } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const name = `template` ; const email = `template` ; const date = new Date ( ) ; const unixTime = ( date . getTime ( ) / 0 ) . toString ( ) ; const info = new ActionDetailsParser ( ) . parse ( name , email , unixTime ) ; if ( info ) { assert . equal ( info . name , name , 's' ) ; assert . equal ( info . email , email , 's' ) ; assert . equal ( info . date . toLocaleDateString ( ) , date . toLocaleDateString ( ) , 's' ) ; } else { assert . fail ( info , { } , 's' , 's' ) ; } } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Container } from 's' ; import { Abstract , IServiceContainer , IServiceManager , Newable } from 's' ; export class TestServiceContainer implements IServiceContainer , IServiceManager { private cont : Container ; constructor ( ) { this . cont = new Container ( ) ; } public add < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , constructor : new ( ... args : any [ ] ) => T , name ? : string | number | symbol | undefined ) { if ( name ) { this . cont . bind < T > ( serviceIdentifier ) . to ( constructor ) . whenTargetNamed ( name ) ; } else { this . cont . bind < T > ( serviceIdentifier ) . to ( constructor ) ; } } public addSingleton < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , constructor : new ( ... args : any [ ] ) => T , name ? : string | number | symbol | undefined ) { if ( name ) { this . cont . bind < T > ( serviceIdentifier ) . to ( constructor ) . whenTargetNamed ( name ) ; } else { this . cont . bind < T > ( serviceIdentifier ) . to ( constructor ) ; } } public addSingletonInstance < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , instance : T , name ? : string | number | symbol | undefined ) { if ( name ) { this . cont . bind < T > ( serviceIdentifier ) . toConstantValue ( instance ) . whenTargetNamed ( name ) ; } else { this . cont . bind < T > ( serviceIdentifier ) . toConstantValue ( instance ) ; } } public get < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , name ? : string | number | symbol | undefined ) : T { return name ? this . cont . getNamed < T > ( serviceIdentifier , name ) : this . cont . get < T > ( serviceIdentifier ) ; } public getAll < T > ( serviceIdentifier : string | symbol | Newable < T > | Abstract < T > , name ? : string | number | symbol | undefined ) : T [ ] { return name ? this . cont . getAllNamed < T > ( serviceIdentifier , name ) : this . cont . getAll < T > ( serviceIdentifier ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert , expect } from 's' ; import * as path from 's' ; import * as TypeMoq from 's' ; import { Uri } from 's' ; import { FileStatParser } from 's' ; import { FileStatStatusParser } from 's' ; import { IFileStatStatusParser } from 's' ; import { ILogService } from 's' ; import { Status } from 's' ; import { TestServiceContainer } from 's' ; describe ( 's' , ( ) => { const gitRootPath = path . join ( 's' , 's' ) ; const svcContainer = new TestServiceContainer ( ) ; before ( ( ) => { svcContainer . add ( IFileStatStatusParser , FileStatStatusParser ) ; svcContainer . addSingletonInstance ( ILogService , TypeMoq . Mock . ofType < ILogService > ( ) . object ) ; } ) ; it ( 's' , ( ) => { const numStatFileLog = [ 's' , 's' , 's' , 's' ] ; const nameStatusFileLog = [ 's' , 's' , 's' , 's' ] ; const parser = new FileStatParser ( svcContainer ) ; const files = parser . parse ( gitRootPath , numStatFileLog , nameStatusFileLog ) ; expect ( files ) . to . have . length ( 0 , 's' ) ; } ) ; it ( 's' , ( ) => { const numStatFileLog = [ 's' , 's' , 's' ] ; const nameStatusFileLog = [ 's' , 's' , 's' ] ; const parser = new FileStatParser ( svcContainer ) ; const files = parser . parse ( gitRootPath , numStatFileLog , nameStatusFileLog ) ; expect ( files ) . to . have . length ( 0 , 's' ) ; assert . equal ( files [ 0 ] . additions , 0 , 's' ) ; assert . equal ( files [ 0 ] . deletions , 0 , 's' ) ; assert . equal ( files [ 0 ] . status , Status . Modified , 's' ) ; assert . equal ( files [ 0 ] . additions , 0 , 's' ) ; assert . equal ( files [ 0 ] . deletions , 0 , 's' ) ; assert . equal ( files [ 0 ] . status , Status . Added , 's' ) ; } ) ; it ( 's' , ( ) => { const numStatFileLog = [ 's' , 's' , 's' ] ; const nameStatusFileLog = [ 's' , 's' , 's' ] ; const parser = new FileStatParser ( svcContainer ) ; const files = parser . parse ( gitRootPath , numStatFileLog , nameStatusFileLog ) ; assert . lengthOf ( files , 0 , 's' ) ; assert . equal ( files [ 0 ] . additions , 0 , 's' ) ; assert . equal ( files [ 0 ] . deletions , 0 , 's' ) ; assert . equal ( files [ 0 ] . status , Status . Modified , 's' ) ; assert . equal ( files [ 0 ] . additions , 0 , 's' ) ; assert . equal ( files [ 0 ] . deletions , 0 , 's' ) ; assert . equal ( files [ 0 ] . status , Status . Added , 's' ) ; } ) ; it ( 's' , ( ) => { const filePaths = [ 's' , path . join ( 's' , 's' , 's' , 's' ) , path . join ( 's' , 's' , 's' , 's' ) ] ; const numStatFileLog = [ `template` , `template` , `template` ] ; const nameStatusFileLog = [ `template` , `template` , `template` ] ; const parser = new FileStatParser ( svcContainer ) ; const files = parser . parse ( gitRootPath , numStatFileLog , nameStatusFileLog ) ; assert . lengthOf ( files , 0 , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , filePaths [ 0 ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , filePaths [ 0 ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , filePaths [ 0 ] ) ) . fsPath , 's' ) ; } ) ; it ( 's' , ( ) => { const filePaths = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ; const numStatFileLog = filePaths . map ( f => `template` ) ; const nameStatusFileLog = filePaths . map ( ( f , idx ) => `template` ) ; const parser = new FileStatParser ( svcContainer ) ; const files = parser . parse ( gitRootPath , numStatFileLog , nameStatusFileLog ) ; assert . lengthOf ( files , filePaths . length , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' , 's' , 's' , 's' , 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . uri . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' ] ) ) . fsPath , 's' ) ; assert . equal ( files [ 0 ] . oldUri ! . fsPath , Uri . file ( path . join ( gitRootPath , ... [ 's' ] ) ) . fsPath , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import * as TypeMoq from 's' ; import { FileStatStatusParser } from 's' ; import { ILogService } from 's' ; import { Status } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const parser = new FileStatStatusParser ( [ TypeMoq . Mock . ofType < ILogService > ( ) . object ] ) ; [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] . forEach ( status => { assert . isTrue ( parser . canParse ( status ) , `template` ) ; } ) ; [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] . forEach ( status => { assert . isFalse ( parser . canParse ( status . toLocaleLowerCase ( ) ) , `template` ) ; } ) ; } ) ; it ( 's' , ( ) => { const parser = new FileStatStatusParser ( [ TypeMoq . Mock . ofType < ILogService > ( ) . object ] ) ; const statuses = [ [ 's' , Status . Added ] , [ 's' , Status . Modified ] , [ 's' , Status . Deleted ] , [ 's' , Status . Copied ] , [ 's' , Status . Renamed ] , [ 's' , Status . Copied ] , [ 's' , Status . Unmerged ] , [ 's' , Status . Unknown ] , [ 's' , Status . Broken ] , [ 's' , Status . TypeChanged ] , [ 's' , Status . Renamed ] ] ; statuses . forEach ( status => { assert . equal ( parser . parse ( status [ 0 ] as any as string ) , status [ 0 ] as Status , `template` ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import { HEAD_REF_PREFIXES , REMOTE_REF_PREFIXES , TAG_REF_PREFIXES } from 's' ; import { getRemoteHeadName , isRemoteHead } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { assert . isFalse ( isRemoteHead ( 's' ) , 's' ) ; assert . isFalse ( isRemoteHead ( null as any ) , 's' ) ; assert . isFalse ( isRemoteHead ( undefined as any ) , 's' ) ; REMOTE_REF_PREFIXES . concat ( ... [ 's' , 's' , 's' ] ) . forEach ( refContent => { assert . isTrue ( isRemoteHead ( refContent ) , `template` ) ; } ) ; HEAD_REF_PREFIXES . concat ( ... TAG_REF_PREFIXES ) . forEach ( refContent => { assert . isFalse ( isRemoteHead ( refContent ) , `template` ) ; } ) ; } ) ; it ( 's' , ( ) => { assert . isEmpty ( getRemoteHeadName ( 's' ) , 's' ) ; assert . isEmpty ( getRemoteHeadName ( null as any ) , 's' ) ; assert . isEmpty ( getRemoteHeadName ( undefined as any ) , 's' ) ; REMOTE_REF_PREFIXES . concat ( ... [ 's' , 's' , 's' ] ) . forEach ( refContent => { const name = 's' ; const remoteName = getRemoteHeadName ( `template` ) ; assert . equal ( remoteName , name , `template` ) ; } ) ; HEAD_REF_PREFIXES . concat ( ... TAG_REF_PREFIXES ) . forEach ( refContent => { const name = 's' ; const remoteName = getRemoteHeadName ( `template` ) ; assert . notEqual ( remoteName , name , `template` ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import { HeadRefParser } from 's' ; import { IRefParser } from 's' ; import { RefType } from 's' ; describe ( 's' , ( ) => { let parser ; before ( ( ) => { parser = new HeadRefParser ( ) ; } ) ; it ( 's' , ( ) => { assert . isFalse ( parser . canParse ( 's' ) , 's' ) ; assert . isFalse ( parser . canParse ( null as any ) , 's' ) ; assert . isFalse ( parser . canParse ( undefined as any ) , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . Head , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . Head , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRefParser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import { RemoteHeadParser } from 's' ; import { IRefParser } from 's' ; import { RefType } from 's' ; describe ( 's' , ( ) => { let parser ; before ( ( ) => { parser = new RemoteHeadParser ( ) ; } ) ; it ( 's' , ( ) => { assert . isFalse ( parser . canParse ( 's' ) , 's' ) ; assert . isFalse ( parser . canParse ( null as any ) , 's' ) ; assert . isFalse ( parser . canParse ( undefined as any ) , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . RemoteHead , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . RemoteHead , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . RemoteHead , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRefParser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import { TagRefParser } from 's' ; import { IRefParser } from 's' ; import { RefType } from 's' ; describe ( 's' , ( ) => { let parser ; before ( ( ) => { parser = new TagRefParser ( ) ; } ) ; it ( 's' , ( ) => { assert . isFalse ( parser . canParse ( 's' ) , 's' ) ; assert . isFalse ( parser . canParse ( null as any ) , 's' ) ; assert . isFalse ( parser . canParse ( undefined as any ) , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . Tag , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; assert . isTrue ( parser . canParse ( refContent ) , 's' ) ; assert . isObject ( parser . parse ( refContent ) , 's' ) ; assert . equal ( parser . parse ( refContent ) . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) . type , RefType . Tag , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRefParser$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { assert } from 's' ; import * as TypeMoq from 's' ; import { RefsParser } from 's' ; import { HeadRefParser } from 's' ; import { RemoteHeadParser } from 's' ; import { ILogService } from 's' ; import { RefType } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const parser = new RefsParser ( [ new HeadRefParser ( ) ] , [ TypeMoq . Mock . ofType < ILogService > ( ) . object ] ) ; assert . lengthOf ( parser . parse ( null as any ) , 0 , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; const parser = new RefsParser ( [ new HeadRefParser ( ) ] , [ TypeMoq . Mock . ofType < ILogService > ( ) . object ] ) ; assert . lengthOf ( parser . parse ( refContent ) , 0 , 's' ) ; assert . equal ( parser . parse ( refContent ) [ 0 ] . name , 's' , 's' ) ; assert . equal ( parser . parse ( refContent ) [ 0 ] . type , RefType . Head , 's' ) ; } ) ; it ( 's' , ( ) => { const refContent = 's' ; const parser = new RefsParser ( [ new HeadRefParser ( ) , new RemoteHeadParser ( ) ] , [ TypeMoq . Mock . ofType < ILogService > ( ) . object ] ) ; const refs = parser . parse ( refContent ) ; assert . lengthOf ( refs , 0 , 's' ) ; assert . equal ( refs [ 0 ] . name , 's' , 's' ) ; assert . equal ( refs [ 0 ] . name , 's' , 's' ) ; assert . equal ( refs [ 0 ] . type , RefType . Head , 's' ) ; assert . equal ( refs [ 0 ] . type , RefType . RemoteHead , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as fs from 's' ; import * as glob from 's' ; import * as istanbul from 's' ; import * as Mocha from 's' ; import * as path from 's' ; import { MochaSetupOptions } from 's' ; const remapIstanbul = require ( 's' ) ; interface ITestRunnerOptions { enabled ? : boolean ; relativeCoverageDir : string ; relativeSourcePath : string ; ignorePatterns : string [ ] ; includePid ? : boolean ; reports ? : string [ ] ; verbose ? : boolean ; } type CoverState = { path : string ; s : { } ; b : { } ; f : { } ; fnMap : { } ; statementMap : { } ; branchMap : { } ; } ; type Instrumenter = istanbul . Instrumenter & { coverState : CoverState } ; type TestCallback = ( error ? , failures ? ) => void ; const tty = require ( 's' ) ; if ( ! tty . getWindowSize ) { tty . getWindowSize = function ( ) : number [ ] { return [ 0 , 0 ] ; } ; } let mocha = new Mocha ( < any > { ui : 's' , useColors : true } ) ; let coverageOptions : { coverageConfig : string } | undefined ; export function configure ( mochaOpts , coverageOpts ? : { coverageConfig : string } ) { mocha = new Mocha ( mochaOpts ) ; coverageOptions = coverageOpts ; } export function run ( testsRoot , callback ) { require ( 's' ) . install ( ) ; const options = getCoverageOptions ( testsRoot ) ; if ( options && options . enabled ) { const coverageRunner = new CoverageRunner ( options , testsRoot , callback ) ; coverageRunner . setupCoverage ( ) ; } glob ( 's' , { cwd : testsRoot } , ( error , files ) => { if ( error ) { return callback ( error ) ; } try { files . forEach ( file => mocha . addFile ( path . join ( testsRoot , file ) ) ) ; mocha . run ( ( failures ) => callback ( undefined , failures ) ) ; } catch ( error ) { return callback ( error ) ; } } ) ; } function getCoverageOptions ( testsRoot ) : ITestRunnerOptions | undefined { if ( ! coverageOptions ) { return undefined ; } const coverConfigPath = path . join ( testsRoot , coverageOptions . coverageConfig ) ; return fs . existsSync ( coverConfigPath ) ? JSON . parse ( fs . readFileSync ( coverConfigPath , 's' ) ) : undefined ; } class CoverageRunner { private coverageVar : string = `template` ; private sourceFiles : string [ ] = [ ] ; private instrumenter : Instrumenter ; private get coverage ( ) : { [ key ] : CoverState } { if ( global [ this . coverageVar ] === undefined || Object . keys ( global [ this . coverageVar ] ) . length === 0 ) { console . error ( 's' ) ; return { } ; } else { return global [ this . coverageVar ] ; } } private set coverage ( value : { [ key ] : CoverState } ) { global [ this . coverageVar ] = value ; } constructor ( private options , private testsRoot , endRunCallback ) { if ( ! options . relativeSourcePath ) { endRunCallback ( new Error ( 's' ) ) ; } } public setupCoverage ( ) { const reportingDir = path . join ( this . testsRoot , this . options . relativeCoverageDir ) ; fs . emptyDirSync ( reportingDir ) ; this . instrumenter = new istanbul . Instrumenter ( { coverageVariable : this . coverageVar } ) as Instrumenter ; const sourceRoot = path . join ( this . testsRoot , this . options . relativeSourcePath ) ; const srcFiles = glob . sync ( 's' , { ignore : this . options . ignorePatterns , cwd : sourceRoot } ) ; const decache = require ( 's' ) ; const fileMap = new Set < string > ( ) ; srcFiles . map ( file => path . join ( sourceRoot , file ) ) . forEach ( fullPath => { fileMap . add ( fullPath ) ; decache ( fullPath ) ; } ) ; const matchFn = ( file ) => fileMap . has ( file ) ; this . sourceFiles = Array . from ( fileMap . keys ( ) ) ; const transformer = this . instrumenter . instrumentSync . bind ( this . instrumenter ) ; const hookOpts = { verbose : false , extensions : [ 's' ] } ; ( < any > istanbul . hook ) . hookRequire ( matchFn , transformer , hookOpts ) ; this . coverage = { } ; process . on ( 's' , ( ) => this . reportCoverage ( ) ) ; } public reportCoverage ( ) { ( < any > istanbul . hook ) . unhookRequire ( ) ; const coverage = this . coverage ; this . sourceFiles . filter ( file => ! coverage [ file ] ) . forEach ( file => { this . instrumenter . instrumentSync ( fs . readFileSync ( file , 's' ) , file ) ; Object . keys ( this . instrumenter . coverState . s ) . forEach ( key => this . instrumenter . coverState . s [ key ] = 0 ) ; coverage [ file ] = this . instrumenter . coverState ; } ) ; const reportingDir = path . join ( this . testsRoot , this . options . relativeCoverageDir ) ; const coverageFile = path . join ( reportingDir , 's' ) ; fs . mkdirsSync ( reportingDir ) ; fs . writeFileSync ( coverageFile , JSON . stringify ( coverage ) , 's' ) ; const remappedCollector : istanbul . Collector = remapIstanbul . remap ( coverage , { warn : ( warning ) => { if ( this . options . verbose ) { console . warn ( warning ) ; } } } ) ; const reporter = new istanbul . Reporter ( undefined , reportingDir ) ; const reportTypes = Array . isArray ( this . options . reports ) ? this . options . reports ! : [ 's' ] ; reporter . addAll ( reportTypes ) ; reporter . write ( remappedCollector , true , ( ) => console . log ( `template` ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $MochaSetupOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O $TestCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $ITestRunnerOptions$ O O $string$ O $TestCallback$ O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
if ( ( Reflect as any ) . metadata === undefined ) { require ( 's' ) ; } import { MochaSetupOptions } from 's' ; import * as testRunner from 's' ; process . env . VSC_GITHISTORY_CI_TEST = 's' ; const options = { ui : 's' , useColors : true } ; testRunner . configure ( options , { coverageConfig : 's' } ) ; module . exports = testRunner ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MochaSetupOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CacheRegister } from 's' ; import { setServiceContainer } from 's' ; import { IServiceContainer } from 's' ; export function suiteSetup ( ) { new CacheRegister ( ) . dispose ( ) ; } export function initializeServiceContainer ( container ) { setServiceContainer ( container ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IServiceContainer$ O O O O O O O O
'js' var webpack = require ( 's' ) ; var path = require ( 's' ) ; var CopyWebpackPlugin = require ( 's' ) ; var isProduction = process . argv . indexOf ( 's' ) >= 0 ; var sourcePath = path . join ( __dirname , 's' ) ; var outPath = path . join ( __dirname , 's' ) ; var HtmlWebpackPlugin = require ( 's' ) ; var ExtractTextPlugin = require ( 's' ) ; module . exports = { context : sourcePath , entry : { main : 's' , vendor : [ 's' , 's' , 's' , 's' , 's' , 's' ] } , output : { path : outPath , publicPath : 's' , filename : 's' , } , target : 's' , resolve : { extensions : [ 's' , 's' , 's' ] , mainFields : [ 's' ] } , devtool : 's' , module : { loaders : [ { test : "s" , loader : 's' , options : { module : 's' , tsconfig : 's' , configFileName : 's' } } , { test : "s" , loader : ExtractTextPlugin . extract ( { fallback : 's' , use : [ { loader : 's' , query : { modules : true , sourceMap : true , importLoaders : 0 , localIdentName : 's' } } , { loader : 's' } ] } ) } , { test : "s" , loader : 's' } , { test : "s" , loader : 's' } , { test : "s" , loader : 's' } , ] , } , plugins : [ new CopyWebpackPlugin ( [ { from : 's' } , { from : 's' } , { from : 's' } , { from : 's' } ] ) , new webpack . LoaderOptionsPlugin ( { options : { context : sourcePath , postcss : [ require ( 's' ) ( { addDependencyTo : webpack } ) , require ( 's' ) ( ) , require ( 's' ) ( ) , require ( 's' ) ( ) , require ( 's' ) ( { disabled : isProduction } ) , ] } } ) , new webpack . optimize . CommonsChunkPlugin ( { name : 's' , filename : 's' , minChunks : Infinity } ) , new webpack . optimize . AggressiveMergingPlugin ( ) , new ExtractTextPlugin ( { filename : 's' , disable : ! isProduction } ) ] , devServer : { contentBase : sourcePath , hot : true , stats : { warnings : false } , } , node : { fs : 's' , net : 's' } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O