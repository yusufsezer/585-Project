import { Observable , Observer } from 's' const stream < number > = Observable . create ( ( observer < number > ) => { let i = 0 const intervalId = setInterval ( ( ) => { observer . next ( ++ i ) } , 0 ) return ( ) => clearInterval ( intervalId ) } ) function createIntervalObservable ( base ) < number > { let i = 0 return Observable . create ( ( observer < string > ) => { const intervalId = setInterval ( ( ) => { observer . next ( `template` ) } , 0 ) return ( ) => { clearInterval ( intervalId ) console . log ( `template` ) } } ) } stream . switchMap ( createIntervalObservable ) . subscribe ( result => console . log ( result ) )	O O O O O O O O O $Observable$ O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $number$ O O O O O O O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Koa from 's' import * as KoaRouter from 's' type ValidType = 's' | 's' | 's' | 's' type RouterConfig = { path : string method : ValidType } | string class Router { private static koaRouter = new KoaRouter ( ) private static routerMap = new Map < any , RouterConfig > ( ) private static routerSet = new Set < Function > ( ) constructor ( ) { const allowMethod = 's' Router . koaRouter . options ( 's' , async ( ctx : KoaRouter . IRouterContext , next ) => { ctx . status = 0 ctx . res . setHeader ( 's' , allowMethod ) ctx . body = allowMethod await next ( ) } ) } root ( path ) { return this . decorator ( path ) } get ( path ) { return this . decorator ( { path , method : 's' } ) } post ( path ) { return this . decorator ( { path , method : 's' } ) } put ( path ) { return this . decorator ( { path , method : 's' } ) } delete ( path ) { return this . decorator ( { path , method : 's' } ) } setRouters ( app ) { Router . routerMap . forEach ( ( _ , RouterClass ) => new RouterClass ( ) ) Router . routerSet . forEach ( Func => Func ( ) ) app . use ( Router . koaRouter . routes ( ) ) app . use ( ctx => { ctx . res . setHeader ( 's' , ctx . request . header . origin || 's' ) ctx . res . setHeader ( 's' , 's' ) ctx . res . setHeader ( 's' , 's' ) ctx . res . setHeader ( 's' , 's' ) } ) } private decorator ( config ) { if ( typeof config === 's' ) { return function ( target ) { Router . routerMap . set ( target , config ) } } else { return function ( target , _key , desc ) { let path = config [ 's' ] const method = config [ 's' ] Router . routerSet . add ( ( ) => { const constructor = target . constructor const parentPath = Router . routerMap . get ( constructor ) if ( typeof parentPath !== 's' ) { path = parentPath + path } Router . koaRouter [ method ] ( path , async ( ctx : KoaRouter . IRouterContext , next ) => { let result try { result = await desc . value . call ( target , ctx , next ) } catch ( e ) { console . error ( e ) ctx . throw ( 0 , e ) } return result } ) } ) } } } } export default new Router	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $void$ O $Koa$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O $RouterConfig$ O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $string$ O $PropertyDescriptor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as crypto from 's' const os = require ( 's' ) const FINGERMARK = JSON . stringify ( require ( 's' ) . networkInterfaces ( ) ) const TIMESTAMP = 0 const PERIOD = 0 * 0 * 0 * 0 let keyCount = 0 interface FileMeta { fileName : string fileSize : number , chunkSize : number chunks : number created : Date 0 : string lastUpdated : string } export function genKey ( fileMeta < FileMeta > , sampleFileBuffer ) { const now = Date . now ( ) const metaBuf = new Buffer ( FINGERMARK + ( ++ keyCount ) + JSON . stringify ( fileMeta ) + now ) const time = Math . floor ( ( now - TIMESTAMP ) / PERIOD ) . toString ( 0 ) const key = 's' + time return key + crypto . createHash ( 's' ) . update ( metaBuf ) . update ( sampleFileBuffer ) . digest ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as crypto from 's' import * as fs from 's' import { join } from 's' import * as rawBody from 's' import Router from 's' import { IRouterContext } from 's' import { genKey } from 's' const config = require ( 's' ) interface FileMeta { name : string chunks : number } @ Router . root ( 's' ) export class Blls { private static fileKeyPairs = new Map < string , FileMeta > ( ) @ Router . post ( 's' ) async getChunksMeta ( ctx , next ) { const { fileSize , 0 , lastUpdated , fileName } = ctx . request . body const fileInfo = { fileSize , 0 , lastUpdated , fileName } const chunkSize = config . CHUNK_SIZE const chunks = Math . ceil ( fileSize / chunkSize ) const buffer = Buffer . concat ( [ new Buffer ( JSON . stringify ( fileInfo ) ) , crypto . randomBytes ( 0 ) ] ) const fileKey = genKey ( fileInfo , buffer ) Blls . fileKeyPairs . set ( fileKey , { name : fileName , chunks } ) ctx . body = { chunkSize , chunks , fileKey , fileSize : parseInt ( fileSize ) } await next ( ) } @ Router . post ( 's' ) upload ( ctx , next ) { const { chunk , chunks } = ctx . request . query if ( chunk && chunks ) { return this . uploadChunk ( ctx , next ) } else if ( ! chunk && ! chunks ) { return this . settle ( ctx , next ) } else { ctx . body = 's' ctx . status = 0 return next ( ) } } async uploadChunk ( ctx , next ) { const { fileKey } = ctx . params const { chunk , chunks } = ctx . request . query const raw = await new Promise ( ( resolve , reject ) => { rawBody ( ctx . req , { length : ctx . req . headers [ 's' ] } , ( err , body ) => { if ( err ) { reject ( err ) } resolve ( body ) } ) } ) try { await new Promise ( ( resolve , reject ) => { const fileName = `template` const dir = join ( process . cwd ( ) , `template` ) if ( ! fs . existsSync ( dir ) ) { fs . mkdirSync ( dir ) } fs . writeFile ( `template` , raw , ( err ) => { if ( err ) { reject ( err ) } resolve ( ) } ) } ) } catch ( e ) { ctx . body = e . message ? e . message : e ctx . status = 0 await next ( e ) } ctx . body = 's' await next ( ) } async settle ( ctx , next ) { const { fileKey } = ctx . params const { name , chunks } = Blls . fileKeyPairs . get ( fileKey ) const dir = join ( process . cwd ( ) , `template` ) const promises : Promise < any > [ ] = [ ] let blob for ( let i = 0 ; i <= chunks ; i ++ ) { const path = `template` const promise = this . readFileAsPromise ( path ) . then ( newBlob => { blob = ! blob ? newBlob : Buffer . concat ( [ blob , newBlob ] ) return this . deleteFileAsPromise ( path ) } ) promises . push ( promise ) } try { await Promise . all ( promises ) await this . writeFileAsPromise ( `template` , blob ) } catch ( e ) { ctx . status = 0 ctx . body = e . message ? e . message : e return await next ( e ) } ctx . body = 's' await next ( ) } private writeFileAsPromise ( path , blob ) { return new Promise ( ( resolve , reject ) => { fs . writeFile ( path , blob , ( err ) => { if ( err ) { reject ( err ) } resolve ( ) } ) } ) } private readFileAsPromise ( path ) { return new Promise < Buffer > ( ( resolve , reject ) => { fs . readFile ( path , ( err , data ) => { if ( err ) { reject ( err ) } resolve ( data ) } ) } ) } private deleteFileAsPromise ( path ) { return new Promise ( ( resolve , reject ) => { fs . unlink ( path , ( err ) => { if ( err ) { reject ( err ) } resolve ( ) } ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRouterContext$ O $KoaNext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRouterContext$ O $KoaNext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRouterContext$ O $KoaNext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IRouterContext$ O $KoaNext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Koa from 's' import * as bodyParser from 's' import Router from 's' import 's' const config = require ( 's' ) const app = new Koa app . use ( bodyParser ( ) ) Router . setRouters ( app ) app . listen ( config . port ) console . log ( `template` )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Subscriber , Subject } from 's' const 0 = require ( 's' ) const $attachment = document . querySelector ( 's' ) const $progressBar = document . querySelector ( 's' ) as HTMLElement const apiHost = 's' interface FileInfo { fileSize : number 0 : string lastUpdated : string fileName : string } interface ChunkMeta { fileSize : number chunkSize : number chunks : number fileKey : string } type Action = 's' | 's' | 's' | 's' export class FileUploader { private file$ = Observable . fromEvent ( $attachment , 's' ) . map ( ( r ) => ( r . target as HTMLInputElement ) . files [ 0 ] ) . filter ( f => ! ! f ) private click$ = Observable . fromEvent ( $attachment , 's' ) . map ( ( e ) => e . target ) . filter ( ( e ) => e === $attachment ) . scan ( ( acc , val ) => { if ( val . classList . contains ( 's' ) ) { return 0 } if ( acc === 0 ) { return 0 } return 0 } , 0 ) . filter ( v => v !== 0 ) . do ( ( v ) => { if ( v === 0 ) { this . action$ . next ( { name : 's' } ) $attachment . classList . remove ( 's' ) $attachment . classList . add ( 's' ) } else { this . action$ . next ( { name : 's' } ) this . buildPauseIcon ( ) } } ) . map ( v => ( { action : v === 0 ? 's' : 's' , payload : null } ) ) private action$ = new Subject < { name : Action payload ? : any } > ( ) private pause$ = this . action$ . filter ( ac => ac . name === 's' ) private resume$ = this . action$ . filter ( ac => ac . name === 's' ) private progress$ = this . action$ . filter ( action => action . name === 's' ) . map ( action => action . payload ) . distinctUntilChanged ( ( x , y ) => x - y >= 0 ) . do ( ( r ) => { const percent = Math . round ( r * 0 ) $progressBar . style . width = `template` $progressBar . firstElementChild . textContent = `template` } ) . map ( r => ( { action : 's' , payload : r } ) ) uploadStream$ = this . file$ . switchMap ( this . readFileInfo ) . switchMap ( i => Observable . ajax . post ( `template` , i . fileinfo ) . map ( ( r ) => { const blobs = this . slice ( i . file , r . response . chunks , r . response . chunkSize ) return { blobs , chunkMeta : r . response , file : i . file } } ) ) . do ( ( ) => this . buildPauseIcon ( ) ) . switchMap ( ( { blobs , chunkMeta , file } ) => { const uploaded : number [ ] = [ ] const dists = blobs . map ( ( blob , index ) => { let currentLoaded = 0 return this . uploadChunk ( chunkMeta , index , blob ) . do ( r => { currentLoaded = r . loaded / file . size uploaded [ index ] = currentLoaded const percent = uploaded . reduce ( ( acc , val ) => acc + ( val ? val : 0 ) ) this . action$ . next ( { name : 's' , payload : percent } ) } ) } ) const uploadStream = Observable . from ( dists ) . mergeAll ( this . concurrency ) return Observable . forkJoin ( uploadStream ) . mapTo ( chunkMeta ) } ) . switchMap ( ( r ) => Observable . ajax . post ( `template` ) . mapTo ( { action : 's' , payload : r } ) ) . do ( ( ) => { $progressBar . firstElementChild . textContent = 's' $attachment . classList . remove ( 's' ) $attachment . classList . add ( 's' ) ; ( $attachment . firstElementChild as HTMLInputElement ) . disabled = false } ) . merge ( this . progress$ , this . click$ ) constructor ( private concurrency = 0 ) { } private buildPauseIcon ( ) { $attachment . classList . remove ( 's' ) $attachment . classList . add ( 's' ) ; ( $attachment . firstElementChild as HTMLInputElement ) . disabled = true } private readFileInfo ( file ) < { file : File , fileinfo : FileInfo } > { const reader = new FileReader ( ) const spark = new 0 . ArrayBuffer ( ) reader . readAsArrayBuffer ( file ) return Observable . create ( ( observer < { file : File , fileinfo : FileInfo } > ) => { reader . onload = ( e ) => { spark . append ( ( e . target as FileReader ) . result ) const 0 = spark . end ( ) observer . next ( { file , fileinfo : { 0 , fileSize : file . size , lastUpdated : file . lastModifiedDate . toISOString ( ) , fileName : file . name } } ) observer . complete ( ) } return ( ) => { if ( ! reader . result ) { console . warn ( 's' ) reader . abort ( ) } } } ) } private slice ( file , n , chunkSize ) : Blob [ ] { const result : Blob [ ] = [ ] for ( let i = 0 ; i < n ; i ++ ) { const startSize = i * chunkSize const slice = file . slice ( startSize , i === n - 0 ? startSize + ( file . size - startSize ) : ( i + 0 ) * chunkSize ) result . push ( slice ) } return result } private uploadChunk ( meta , index , blob ) < ProgressEvent > { const host = `template` return Observable . create ( ( subscriber < ProgressEvent > ) => { const ajax$ = Observable . ajax ( { url : host , body : blob , method : 's' , crossDomain : true , headers : { 's' : 's' } , progressSubscriber : subscriber } ) . takeUntil ( this . pause$ ) . repeatWhen ( ( ) => this . resume$ ) const subscription = ajax$ . subscribe ( ) return ( ) => subscription . unsubscribe ( ) } ) . retryWhen ( ( ) => this . resume$ ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O $HTMLElement$ O O O O O O O O O O $number$ O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ChunkMeta$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $File$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Subscriber$ O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $File$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $ChunkMeta$ O $number$ O $Blob$ O O O O O O O O O O O O O O O $Subscriber$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Observer } from 's' let dbIndex = 0 const searchStorage = new Map < number , HttpResponse > ( ) export interface HttpResponse { _id : number value : string isDone : boolean } const random = ( begin , end ) => { return begin + Math . floor ( ( end - begin ) * Math . random ( ) ) + 0 } export const search = ( inputValue ) : Observable < HttpResponse | null > => { return Observable . create ( ( observer < HttpResponse | null > ) => { let status = 's' const timmer = setTimeout ( ( ) => { let result = null for ( const [ key , data ] of searchStorage ) { if ( data . value === inputValue ) { result = data break } } status = 's' observer . next ( result ) observer . complete ( ) } , random ( 0 , 0 ) ) return ( ) => { clearTimeout ( timmer ) if ( status === 's' ) { console . warn ( 's' ) } } } ) } export const mockHttpPost = ( value ) : Observable < HttpResponse > => { return Observable . create ( ( observer < HttpResponse > ) => { let status = 's' const timmer = setTimeout ( ( ) => { const result = { _id : ++ dbIndex , value , isDone : false } searchStorage . set ( result . _id , result ) status = 's' observer . next ( result ) observer . complete ( ) } , random ( 0 , 0 ) ) return ( ) => { clearTimeout ( timmer ) if ( status === 's' ) { console . warn ( 's' ) } } } ) } export const mockToggle = ( id , isDone ) : Observable < HttpResponse > => { return Observable . create ( ( observer < HttpResponse > ) => { let status = 's' const timmer = setTimeout ( ( ) => { const result = searchStorage . get ( parseInt ( id ) ) result . isDone = ! isDone searchStorage . set ( result . _id , result ) status = 's' observer . next ( result ) observer . complete ( ) } , random ( 0 , 0 ) ) return ( ) => { clearTimeout ( timmer ) if ( status === 's' ) { console . warn ( 's' ) } } } ) } export const mockDelete = ( id ) : Observable < boolean > => { return Observable . create ( ( observer < boolean > ) => { let status = 's' const timmer = setTimeout ( ( ) => { searchStorage . delete ( id ) status = 's' observer . next ( true ) observer . complete ( ) } , random ( 0 , 0 ) ) return ( ) => { clearTimeout ( timmer ) if ( status === 's' ) { console . warn ( 's' ) } } } ) } export const createTodoItem = ( data ) => { const result = < HTMLLIElement > document . createElement ( 's' ) result . classList . add ( 's' , `template` ) result . setAttribute ( 's' , `template` ) const innerHTML = `template` result . innerHTML = innerHTML return result }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O $Observer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Observer , Subject } from 's' import { createTodoItem , mockToggle , mockHttpPost , search , HttpResponse } from 's' import { FileUploader } from 's' const $input = < HTMLInputElement > document . querySelector ( 's' ) const $list = < HTMLUListElement > document . querySelector ( 's' ) const $add = document . querySelector ( 's' ) const type$ = Observable . fromEvent < KeyboardEvent > ( $input , 's' ) . publish ( ) . refCount ( ) const enter$ = type$ . filter ( r => r . keyCode === 0 ) const clickAdd$ = Observable . fromEvent < MouseEvent > ( $add , 's' ) const input$ = enter$ . merge ( clickAdd$ ) const clearInputSubject$ = new Subject < void > ( ) const item$ = input$ . map ( ( ) => $input . value ) . filter ( r => r !== 's' ) . distinct ( null , clearInputSubject$ ) . switchMap ( mockHttpPost ) . map ( createTodoItem ) . do ( ( ele ) => { $list . appendChild ( ele ) $input . value = 's' clearInputSubject$ . next ( ) } ) . publishReplay ( 0 ) . refCount ( ) const toggle$ = item$ . mergeMap ( $todoItem => { return Observable . fromEvent < MouseEvent > ( $todoItem , 's' ) . debounceTime ( 0 ) . filter ( e => e . target === $todoItem ) . mapTo ( { data : { _id : $todoItem . dataset [ 's' ] , isDone : $todoItem . classList . contains ( 's' ) } , $todoItem } ) } ) . switchMap ( result => { return mockToggle ( result . data . _id , result . data . isDone ) . mapTo ( result . $todoItem ) } ) . do ( ( $todoItem ) => { if ( $todoItem . classList . contains ( 's' ) ) { $todoItem . classList . remove ( 's' ) } else { $todoItem . classList . add ( 's' ) } } ) const remove$ = item$ . mergeMap ( $todoItem => { const $removeButton = $todoItem . querySelector ( 's' ) return Observable . fromEvent ( $removeButton , 's' ) . mapTo ( $todoItem ) } ) . do ( ( $todoItem ) => { const $parent = $todoItem . parentNode $parent . removeChild ( $todoItem ) } ) const search$ = type$ . debounceTime ( 0 ) . filter ( evt => evt . keyCode !== 0 ) . map ( result => ( < HTMLInputElement > result . target ) . value ) . switchMap ( search ) . do ( ( result : HttpResponse | null ) => { const actived = document . querySelectorAll ( 's' ) Array . prototype . forEach . call ( actived , ( item ) => { item . classList . remove ( 's' ) } ) if ( result ) { const item = document . querySelector ( `template` ) item . classList . add ( 's' ) } } ) const uploader = new FileUploader ( ) const app$ = toggle$ . merge ( remove$ , search$ , uploader . uploadStream$ ) . do ( r => { console . log ( r ) } ) app$ . subscribe ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLLIElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' require ( 's' ) require ( 's' )	O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) const path = require ( 's' ) const HtmlWebpackPlugin = require ( 's' ) const { CheckerPlugin } = require ( 's' ) const webpackConfig = { entry : { 's' : 's' } , output : { filename : 's' , path : path . join ( __dirname , 's' ) , publicPath : 's' } , plugins : [ new CheckerPlugin ( ) , new webpack . HotModuleReplacementPlugin ( ) , new HtmlWebpackPlugin ( { filename : 's' , template : 's' , inject : true } ) , new webpack . ProvidePlugin ( { jQuery : 's' , $ : 's' } ) ] , mode : 's' , module : { rules : [ { test : "s" , exclude : "s" , loader : 's' , options : { typeCheck : true } , enforce : 's' , } , { test : "s" , loader : 's' , include : "s" , enforce : 's' , } , { test : "s" , use : 's' } , { test : "s" , loaders : [ 's' , 's' , ] } , { test : "s" , use : 's' } , { test : "s" , use : 's' } ] } } const defaultConfig = { devtool : 's' , cache : true , resolve : { modules : [ path . join ( __dirname , 's' ) , 's' ] , extensions : [ 's' , 's' ] , alias : { 's' : path . join ( process . cwd ( ) , 's' ) } } , devServer : { historyApiFallback : true , watchOptions : { aggregateTimeout : 0 , poll : 0 } } , node : { global : true , crypto : false , module : false , Buffer : false , clearImmediate : false , setImmediate : false } } const webpackMerge = require ( 's' ) module . exports = webpackMerge ( defaultConfig , webpackConfig )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O