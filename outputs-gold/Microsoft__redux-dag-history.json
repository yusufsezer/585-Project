import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's'	O O O O O O O O O O O O O O O O O O
'js' const { configure } = require ( 's' ) function loadStories ( ) { require ( 's' ) } configure ( loadStories , module )	O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) const lodash = require ( 's' ) const get = lodash . get const tsxRule = { test : "s" , loaders : [ 's' ] , } const cssRule = { test : "s" , loaders : [ 's' , 's' ] , } module . exports = ( baseConfig , env ) => { const rules = get ( baseConfig , 's' , [ ] ) const extensions = get ( baseConfig , 's' , [ 's' ] ) const config = Object . assign ( { } , baseConfig , { resolve : Object . assign ( { } , get ( baseConfig , 's' , { } ) , { extensions : extensions . concat ( 's' , 's' ) , } ) , module : Object . assign ( { } , get ( baseConfig , 's' , { } ) , { rules : rules . concat ( tsxRule , cssRule ) , } ) , } ) return config }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' import styled , { StyledComponentClass } from 's' const white = 's' const highlight = 's' const background = 's' const selectedBackground = 's' const gray = 's' const charcoal = 's' const black = 's' export const Dragged = `template` export const Container = `template` const DetailsBase = `template` export const DetailsContainer = `template` export const Details = `template` export const Title = `template` export const Annotation = `template` export const DetailsEditable = `template` export const EditableTitleContainer = `template` export const EditAnnotation = `template` export const ControlsContainer = `template` export const DiscoveryTrailLabel = `template` export const DiscoveryTrailInfoButton = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Bookmarks = `template` export const NoBookmarkText = `template`	O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const black = 's' const white = 's' const highlight = 's' const charcoal = 's' export const Container = `template` export const Details = `template` export const Name = `template` export const ProfileContainer = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Container = `template` export const Branches = `template`	O O O O O O O O O O O O O O O O O O O O O O O O
import * as debug from 's' const log = debug ( 's' ) export class Span { constructor ( public start , public end , public type ) { } public toString ( ) { return `template` } get length ( ) { return this . end - this . start } public areBoundsEqual ( other ) { return other . start === this . start && other . end === this . end } public contains ( index ) { return index >= this . start && index <= this . end } } export function initialSpans ( start , max , type = 's' , ) { return [ new Span ( start , max + 0 , type ) ] } function replaceSpan ( spans : Span [ ] , newSpan , i ) { return spans . slice ( 0 , i ) . concat ( [ newSpan ] ) . concat ( spans . slice ( i + 0 ) ) } function insertSpanAtTail ( spans : Span [ ] , newSpan , i ) { const span = spans [ i ] return spans . slice ( 0 , i ) . concat ( [ new Span ( span . start , newSpan . start , span . type ) , newSpan ] ) . concat ( spans . slice ( i + 0 ) ) . filter ( t => t . end > t . start ) } function insertBridgingSpan ( spans : Span [ ] , newSpan , i ) { const left = spans [ i ] const right = spans [ i + 0 ] return spans . slice ( 0 , i ) . concat ( [ new Span ( left . start , newSpan . start , left . type ) , newSpan , new Span ( newSpan . end , right . end , right . type ) , ] ) . concat ( spans . slice ( i + 0 ) ) . filter ( t => t . end > t . start ) } function insertSplittingSpan ( spans : Span [ ] , newSpan , i ) { const span = spans [ i ] return spans . slice ( 0 , i ) . concat ( [ new Span ( span . start , newSpan . start , span . type ) , newSpan , new Span ( newSpan . end , span . end , span . type ) , ] ) . concat ( spans . slice ( i + 0 ) ) . filter ( t => t . end > t . start ) } export function insertSpan ( spans : Span [ ] , newSpan ) { if ( ! newSpan ) { throw new Error ( 's' ) } for ( let i = 0 ; i < spans . length ; i += 0 ) { const span = spans [ i ] if ( span . areBoundsEqual ( newSpan ) ) { return replaceSpan ( spans , newSpan , i ) } if ( span . contains ( newSpan . start ) ) { if ( newSpan . end === span . end ) { return insertSpanAtTail ( spans , newSpan , i ) } else if ( newSpan . end > span . end ) { return insertBridgingSpan ( spans , newSpan , i ) } return insertSplittingSpan ( spans , newSpan , i ) } } log ( `template` ) return spans }	O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { initialSpans , insertSpan , Span } from 's' const isNumber = ( d ) => ! isNaN ( d ) && d !== null const convertArg = ( arg : number | undefined , offset ) => arg !== null && arg !== undefined ? arg - offset : arg export default function calculateSpans ( type , max , startArg , endArg , branchStartArg , branchEndArg , activeIndexArg , ) { const offset = startArg const start = startArg - offset const end = endArg - offset const branchStart = branchStartArg - offset const branchEnd = branchEndArg - offset const activeIndex = convertArg ( activeIndexArg , offset ) let spans = initialSpans ( start , max ) const isCurrent = type === 's' spans = insertSpan ( spans , new Span ( start , end + 0 , 's' ) ) if ( isNumber ( branchStart ) && isNumber ( branchEnd ) && branchStart >= 0 && branchEnd >= 0 ) { const color = isCurrent ? 's' : 's' const span = new Span ( branchStart , branchEnd + 0 , color ) spans = insertSpan ( spans , span ) } if ( isNumber ( activeIndex ) ) { const color = isCurrent ? 's' : 's' const span = new Span ( activeIndex , activeIndex + 0 , color ) spans = insertSpan ( spans , span ) } return spans }	O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Container = `template`	O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const grey = 's' export const Container = `template`	O O O O O O O O O O O O O O O O O O O O O O O
import { initialSpans , insertSpan , Span } from 's' const isNumber = ( d : number | null | undefined ) => ! isNaN ( d ) && d !== null export default function calculateSpans ( depth , highlight , leadIn , active , ) : Span [ ] { if ( depth < 0 ) { return [ ] } let spans = initialSpans ( 0 , depth , 's' ) if ( isNumber ( leadIn ) && leadIn !== 0 ) { spans = insertSpan ( spans , new Span ( depth - leadIn , depth + 0 , 's' ) ) } if ( active && depth > 0 ) { const type = active ? 's' : 's' const highlightDepth = highlight || depth spans = insertSpan ( spans , new Span ( highlightDepth , highlightDepth + 0 , type ) , ) } return spans }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const minPagerWidth = 's' const emptyStateColor = 's' const highlightedStateInactiveBookmarkColor = 's' const highlightedStateColor = 's' const leadInStateColor = 's' const emptyBookmarkColor = 's' const highlightedBookmarkInactiveBookmarkColor = 's' const highlightedBookmarkColor = 's' const leadInBookmarkColor = 's' const statePagerBorderColor = 's' export const PagerState = `template` const Pager = ( borderColor , highlightedColor , highlightedInactiveColor , leadInColor , emptyColor , ) => `template` export const StatePager = Pager ( statePagerBorderColor , highlightedStateColor , highlightedStateInactiveBookmarkColor , leadInStateColor , emptyStateColor , ) export const BookmarkPager = Pager ( statePagerBorderColor , highlightedBookmarkColor , highlightedBookmarkInactiveBookmarkColor , leadInBookmarkColor , emptyBookmarkColor , )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { StateId } from 's' export interface Bookmark { stateId : StateId name : string data : { [ name ] : any } } export enum BranchType { CURRENT = 's' , LEGACY = 's' , UNRELATED = 's' , } export enum HistoryType { BRANCHED = 's' , CHRONOLOGICAL = 's' , } export enum ComponentView { HISTORY = 's' , STORYBOARDING = 's' , }	O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BranchId , DagHistory , StateId } from 's' import { Bookmark , HistoryType , ComponentView } from 's' export interface HistoryContainerSharedProps { history : DagHistory < any > pinnedStateId ? : StateId mainView : ComponentView historyType : HistoryType dragIndex ? : number hoverIndex ? : number bookmarkEditIndex ? : number branchContainerExpanded ? : boolean selectedBookmark ? : number selectedBookmarkDepth ? : number isPlayingBack ? : boolean bookmarks : Bookmark [ ] getSourceFromState : Function bookmarksEnabled ? : boolean controlBar ? : { onSaveHistory : Function onLoadHistory : Function onConfirmClear : Function } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const BranchListContainerEl = `template` export const HistoryControlBarTitle = `template` export const HistoryControlBar = `template` export const DropdownOptionRow = `template` export const ColumnContainer = `template` export const DropdownContainer = `template` export const PlaybackContainer = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const Flexy = `template` const HistoryContainer = `template` export default HistoryContainer	O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import 's' import styled , { StyledComponentClass } from 's' import { Tab as TabRaw , TabList as TabListRaw , TabPanel as TabPanelRaw , Tabs as TabsRaw , TabProps , TabListProps , TabPanelProps , TabsProps , } from 's' const Flexy = `template` export const Container = `template` export const Tab = `template` export const TabList = `template` export const TabPanel = `template` export const Tabs = `template` export const OptionMenu = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const DropdownOptionRow = `template`	O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const { default : DropdownRaw , DropdownTrigger : DropdownTriggerRaw , DropdownContent : DropdownContentRaw , } = require ( 's' ) import 's' const white = 's' const black = 's' const shadow = 's' export const DropdownTrigger = `template` export const TriggerContent = `template` export const DropdownContent = `template` export const OptionList = `template` export const ListItem = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Container = `template` export const Paged = `template` export const Pane = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DagHistory , StateId , DagGraph } from 's' import { BranchType } from 's' export interface StateProps { id : StateId active ? : boolean renderBookmarks ? : boolean pinned ? : boolean successor ? : boolean state ? : any source ? : string label : string numChildren ? : number bookmarked ? : boolean showContinuation ? : boolean branchType ? : BranchType onBookmarkClick ? : ( state ) => void onClick ? : ( state ) => void onContinuationClick ? : ( state ) => void style ? : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O $StateId$ O O O O O O O $StateId$ O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' const white = 's' const highlight = 's' const black = 's' const charcoal = 's' export const ContinuationContainer = `template` export const Container = `template` export const Detail = `template` export const Source = `template` export const Name = `template`	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Container = `template`	O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const Container = `template`	O O O O O O O O O O O O O O O O O O O
import * as react from 's' import styled , { StyledComponentClass } from 's' export const StateListContainer = `template`	O O O O O O O O O O O O O O O O O O O
function action ( name ) { return `template` } export const SELECT_MAIN_VIEW = action ( 's' ) export const SELECT_HISTORY_TYPE = action ( 's' ) export const SELECT_BOOKMARK_DEPTH = action ( 's' ) export const TOGGLE_BRANCH_CONTAINER = action ( 's' ) export const START_PLAYBACK = action ( 's' ) export const STOP_PLAYBACK = action ( 's' ) export const BOOKMARK_DRAG_START = action ( 's' ) export const BOOKMARK_DRAG_HOVER = action ( 's' ) export const BOOKMARK_DRAG_DROP = action ( 's' ) export const BOOKMARK_DRAG_CANCEL = action ( 's' ) export const BOOKMARK_EDIT = action ( 's' ) export const BOOKMARK_EDIT_DONE = action ( 's' ) export const PIN_STATE = action ( 's' ) export const ADD_BOOKMARK = action ( 's' ) export const REMOVE_BOOKMARK = action ( 's' ) export const RENAME_BOOKMARK = action ( 's' ) export const CHANGE_BOOKMARK = action ( 's' ) export const MOVE_BOOKMARK = action ( 's' )	O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { StateId , ActionCreators as DagHistoryActions , } from 's' import * as ReduxActions from 's' import { Dispatch } from 's' import * as Types from 's' import { HistoryType , ComponentView } from 's' const { createAction } = ReduxActions const { jumpToState } = DagHistoryActions const doSelectBookmarkDepth = createAction < BookmarkDepthSelection > ( Types . SELECT_BOOKMARK_DEPTH , ) const doBookmarkDragDrop = createAction ( Types . BOOKMARK_DRAG_DROP ) export const doStartPlayback = createAction < StartPlaybackPayload > ( Types . START_PLAYBACK , ) export const selectMainView = createAction < ComponentView > ( Types . SELECT_MAIN_VIEW , ) export const selectHistoryType = createAction < HistoryType > ( Types . SELECT_HISTORY_TYPE , ) export const toggleBranchContainer = createAction < { index : number } > ( Types . TOGGLE_BRANCH_CONTAINER , ) export const stopPlayback = createAction ( Types . STOP_PLAYBACK ) export const bookmarkDragStart = createAction < BookmarkDragStartPayload > ( Types . BOOKMARK_DRAG_START , ) export const bookmarkDragHover = createAction < BookmarkDragHoverPayload > ( Types . BOOKMARK_DRAG_HOVER , ) export const bookmarkDragCancel = createAction ( Types . BOOKMARK_DRAG_CANCEL ) export const addBookmark = createAction < AddBookmarkPayload > ( Types . ADD_BOOKMARK ) export const removeBookmark = createAction < StateId > ( Types . REMOVE_BOOKMARK ) export const renameBookmark = createAction < RenameBookmarkPayload > ( Types . RENAME_BOOKMARK , ) export const doChangeBookmark = createAction < ChangeBookmarkPayload > ( Types . CHANGE_BOOKMARK , ) export const moveBookmark = createAction < MoveBookmarkPayload > ( Types . MOVE_BOOKMARK , ) export const pinState = createAction < StateId > ( Types . PIN_STATE ) export const bookmarkEdit = createAction < number > ( Types . BOOKMARK_EDIT ) export const bookmarkEditDone = createAction ( Types . BOOKMARK_EDIT_DONE ) export function changeBookmark ( payload ) { return ( dispatch < any > ) => { dispatch ( doChangeBookmark ( payload ) ) dispatch ( bookmarkEditDone ( ) ) } } export function startPlayback ( payload ) { return ( dispatch < any > ) => { dispatch ( DagHistoryActions . jumpToState ( payload . stateId ) ) dispatch ( doStartPlayback ( payload ) ) } } export function bookmarkDragDrop ( payload ) { return ( dispatch < any > ) => { dispatch ( doBookmarkDragDrop ( ) ) if ( payload . droppedOn >= 0 ) { dispatch ( moveBookmark ( { from : payload . index , to : payload . droppedOn , } ) , ) } } } export const selectBookmarkDepth = ( payload , ) => { const { bookmarkIndex , depth , state } = payload return ( dispatch : Redux . Dispatch < any > ) => { dispatch ( doSelectBookmarkDepth ( { bookmarkIndex , depth } ) ) dispatch ( jumpToState ( state ) ) } } export const selectBookmark = ( bookmarkIndex , state ) => selectBookmarkDepth ( { bookmarkIndex , depth : undefined , state , } ) export interface StartPlaybackPayload { initialDepth : number stateId : StateId } export interface AddBookmarkPayload { stateId : StateId name : string data ? : { [ name ] : any } } export interface BookmarkDragStartPayload { index : number key : string } export interface BookmarkDragHoverPayload { index : number } export interface BookmarkDragDropPayload { index : number droppedOn : number } export interface BookmarkDepthSelection { bookmarkIndex ? : number depth ? : number } export interface BookmarkDepthAndStateSelection { bookmarkIndex : number depth : number state : StateId } export interface RenameBookmarkPayload { stateId : StateId name : string } export interface MoveBookmarkPayload { from : number to : number } export interface ChangeBookmarkPayload { stateId : StateId name : string data : any }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ChangeBookmarkPayload$ O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O $StartPlaybackPayload$ O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BookmarkDragDropPayload$ O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BookmarkDepthAndStateSelection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Configuration } from 's' import { ComponentView , HistoryType } from 's' export interface ComponentConfiguration < T > extends Configuration < T > { initialViewState : { mainView ? : ComponentView historyType ? : HistoryType branchContainerExpanded ? : boolean } } export type RawComponentConfiguration < T > = { [ P in keyof ComponentConfiguration < T > ] ? : ComponentConfiguration < T > [ P ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ConfigurationImpl } from 's' import { ComponentView , HistoryType } from 's' import { ComponentConfiguration , RawComponentConfiguration } from 's' export default class ComponentConfigurationImpl < T > extends ConfigurationImpl < T > implements ComponentConfiguration < T > { constructor ( rawConfig < T > = { } ) { super ( rawConfig as any ) } private get config ( ) { return this . rawConfig as ComponentConfiguration < T > } public get initialViewState ( ) { return this . config . initialViewState || { } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RawComponentConfiguration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' export default function isHistoryAction ( action : ReduxActions . Action < any > , ) { return ! ! ( action && action . type && action . type . startsWith ( 's' ) ) }	O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' export type ConfigurableReducer < STATE , CONFIG > = ( state , action < any > , config , ) => STATE export default function makeReducer < STATE , CONFIG > ( reducer < STATE , CONFIG > , ) { return ( config ) => ( state , action < any > ) => reducer ( state , action , config ) }	O O O O O O O O O O O O O O O O $STATE$ O $Action$ O O O O $CONFIG$ O O O O O O O O O O O O O O $ConfigurableReducer$ O O O O O O O O O O $CONFIG$ O O O $STATE$ O $Action$ O O O O O O O O O O O O O O
import { Action } from 's' import { Configuration } from 's' import { BOOKMARK_EDIT , MOVE_BOOKMARK , BOOKMARK_EDIT_DONE , } from 's' import isHistoryAction from 's' import makeReducer from 's' export interface State { editIndex : number } const INITIAL_STATE = { editIndex : undefined , } function reducer ( state = INITIAL_STATE , action : ReduxActions . Action < any > , config < any > , ) { if ( action . type === BOOKMARK_EDIT ) { return { editIndex : action . payload } } else if ( action . type === MOVE_BOOKMARK && action . payload . from === state . editIndex ) { return { editIndex : action . payload . to } } else if ( action . type === BOOKMARK_EDIT_DONE || ( ! isHistoryAction ( action ) && config . actionFilter ( action . type ) ) ) { return INITIAL_STATE } return state } export default makeReducer ( reducer )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O $State$ O O O O O O O O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Configuration } from 's' import { ADD_BOOKMARK , CHANGE_BOOKMARK , MOVE_BOOKMARK , REMOVE_BOOKMARK , RENAME_BOOKMARK , } from 's' import { Bookmark } from 's' import { Action } from 's' export type State = Bookmark [ ] export const INITIAL_STATE = [ ] export default function reduce ( state = INITIAL_STATE , action : ReduxActions . Action < any > , ) { switch ( action . type ) { case ADD_BOOKMARK : { const { name , stateId , data } = action . payload const newBookmark = { name , stateId , data : data || { } } return [ ... state , newBookmark ] } case REMOVE_BOOKMARK : { const stateId = action . payload return state . filter ( element => element . stateId !== stateId ) } case RENAME_BOOKMARK : { const { stateId , name : newName } = action . payload return state . map ( b => { const isTarget = b . stateId === stateId const name = isTarget ? newName : b . name return { ... b , name } } ) } case CHANGE_BOOKMARK : { const { stateId , name , data } = action . payload return state . map ( b => { const isTarget = b . stateId === stateId return isTarget ? { name , stateId , data } : b } ) } case MOVE_BOOKMARK : { const { from , to } = action . payload const bookmarks = [ ... state ] const moved = bookmarks [ from ] if ( from !== to ) { bookmarks . splice ( from , 0 ) bookmarks . splice ( to , 0 , moved ) } return bookmarks } default : { return state } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' import { Configuration } from 's' import { BOOKMARK_DRAG_CANCEL , BOOKMARK_DRAG_DROP , BOOKMARK_DRAG_HOVER , BOOKMARK_DRAG_START , } from 's' import makeReducer from 's' export interface State { sourceIndex ? : number sourceKey ? : string hoverIndex ? : number } export const INITIAL_STATE = { sourceIndex : undefined , sourceKey : undefined , hoverIndex : undefined , } function reducer ( state = INITIAL_STATE , action : ReduxActions . Action < any > , config < any > , ) { let result = state if ( action . type === BOOKMARK_DRAG_START ) { result = { ... state , sourceIndex : action . payload . index , sourceKey : action . payload . key , } } else if ( action . type === BOOKMARK_DRAG_HOVER ) { const hoverIndex = action . payload . index result = { ... state , hoverIndex , } } else if ( action . type === BOOKMARK_DRAG_DROP ) { result = INITIAL_STATE } else if ( action . type === BOOKMARK_DRAG_CANCEL ) { result = INITIAL_STATE } else if ( action . type . indexOf ( 's' ) !== 0 && config . actionFilter ( action . type ) ) { result = INITIAL_STATE } return result } export default makeReducer ( reducer )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Configuration , StateId } from 's' import { PIN_STATE } from 's' import { Action } from 's' import makeReducer from 's' export interface State { id ? : StateId } export const INITIAL_STATE = { } function reduce ( state = INITIAL_STATE , action : ReduxActions . Action < any > , config < any > , ) { let result = state if ( action . type === PIN_STATE ) { const stateId = action . payload result = { ... state , id : state . id === stateId ? undefined : stateId , } } else if ( action . type . indexOf ( 's' ) !== 0 && config . actionFilter ( action . type ) ) { result = INITIAL_STATE } return result } export default makeReducer ( reduce )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Configuration } from 's' import { SELECT_BOOKMARK_DEPTH , START_PLAYBACK , STOP_PLAYBACK , } from 's' import isHistoryAction from 's' import { Action } from 's' import makeReducer from 's' export interface State { isPlayingBack : boolean bookmark ? : number depth ? : number } export const INITIAL_STATE = { isPlayingBack : false , bookmark : undefined , depth : undefined , } function reduce ( state = INITIAL_STATE , action : ReduxActions . Action < any > , config < any > , ) { let result = state if ( action . type === START_PLAYBACK ) { const { initialDepth } = action . payload result = { ... state , isPlayingBack : true , bookmark : 0 , depth : initialDepth , } } else if ( action . type === STOP_PLAYBACK ) { result = INITIAL_STATE } else if ( action . type === SELECT_BOOKMARK_DEPTH ) { const { depth , bookmarkIndex } = action . payload result = { ... state , bookmark : bookmarkIndex === undefined ? state . bookmark : bookmarkIndex , depth , } } else if ( ! isHistoryAction ( action ) && config . actionFilter ( action . type ) ) { result = { ... state , isPlayingBack : false , bookmark : undefined , depth : undefined , } } return result } export default makeReducer ( reduce )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { SELECT_HISTORY_TYPE , SELECT_MAIN_VIEW , TOGGLE_BRANCH_CONTAINER , } from 's' import { HistoryType , ComponentView } from 's' import { ComponentConfiguration } from 's' import isHistoryAction from 's' import { Action } from 's' import makeReducer from 's' export interface State { mainView : ComponentView historyType : HistoryType branchContainerExpanded : boolean } export const INITIAL_STATE = { mainView : ComponentView . HISTORY , historyType : HistoryType . BRANCHED , branchContainerExpanded : true , } function reduce ( state , action : ReduxActions . Action < any > , config < any > , ) { if ( ! state ) { state = { ... INITIAL_STATE , ... config . initialViewState , } } let result = state if ( action . type === SELECT_MAIN_VIEW ) { result = { ... state , mainView : action . payload , } } else if ( action . type === SELECT_HISTORY_TYPE ) { result = { ... state , historyType : action . payload , } } else if ( action . type === TOGGLE_BRANCH_CONTAINER ) { result = { ... state , branchContainerExpanded : ! state . branchContainerExpanded , } } else if ( ! isHistoryAction ( action ) && config . actionFilter ( action . type ) ) { result = { ... state , mainView : ComponentView . HISTORY , } } return result } export default makeReducer ( reduce )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O $ComponentConfiguration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as redux from 's' import bookmarkEdit from 's' import bookmarks from 's' import dragDrop from 's' import pinnedState from 's' import playback from 's' import views from 's' import { ComponentConfiguration } from 's' export default function createReducer < T > ( config < T > ) { return redux . combineReducers ( { bookmarkEdit : bookmarkEdit ( config ) , dragDrop : dragDrop ( config ) , views : views ( config ) , playback : playback ( config ) , pinnedState : pinnedState ( config ) , bookmarks , } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentConfiguration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Actions from 's' import * as ActionTypes from 's' import Configuration from 's' import reducer from 's' export { Actions , ActionTypes , reducer }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import createHistoryContainer from 's' import History from 's' import * as state from 's' export { History , createHistoryContainer , state }	O O O O O O O O O O O O O O O O O O O O O O
const colors : { [ key ] : string } = { NONE : 's' , CURRENT_ACTIVE : 's' , LEGACY_ACTIVE : 's' , CURRENT : 's' , ANCESTOR : 's' , UNRELATED_UNIQUE : 's' , UNRELATED : 's' , CONT_ACTIVE : 's' , CONT_BLANK : 's' , CONT_PINNED : 's' , } export default colors	O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DagGraph } from 's' import { Bookmark as BookmarkData } from 's' export default class Bookmark { constructor ( private bookmark , private graph < any > ) { } public get numLeadInStates ( ) { const bookmark = this . bookmark return bookmark && bookmark . data && bookmark . data . numLeadInStates } public get annotation ( ) { const bookmark = this . bookmark return bookmark && bookmark . data && bookmark . data . annotation } public get name ( ) { const bookmark = this . bookmark return bookmark . name } public get stateId ( ) { const bookmark = this . bookmark return bookmark . stateId } public get slideText ( ) { return this . annotation || this . name || 's' } public get commitPath ( ) { return this . graph . shortestCommitPath ( this . stateId ) } public get presentedPath ( ) { return this . commitPath . slice ( this . hiddenPathLength ) } public get commitPathLength ( ) { return this . commitPath . length } public get presentedPathLength ( ) { return ( this . numLeadInStates || 0 ) + 0 } public get hiddenPathLength ( ) { return this . commitPathLength - this . presentedPathLength } public startingDepth ( ) { const isLeadInDefined = this . numLeadInStates !== undefined return isLeadInDefined ? this . hiddenPathLength : undefined } public isDepthAtEnd ( depth ) { return depth === undefined || depth >= this . commitPathLength - 0 } public isDepthAtStart ( depth ) { if ( depth === 0 ) { return true } if ( depth === undefined ) { return this . startingDepth === undefined } let startingDepth = this . startingDepth ( ) if ( startingDepth === undefined ) { startingDepth = this . commitPath . length - 0 } return depth === startingDepth } public getStateAtDepth ( depth ? ) { if ( depth === undefined ) { return this . commitPath [ this . commitPath . length - 0 ] } return this . commitPath [ depth ] } public sanitizeDepth ( depth ? ) { if ( depth !== undefined ) { return depth } const commitPathLength = this . commitPathLength return commitPathLength - 0 } }	O O O O O O O O O O O O O O O O O O O O O O $BookmarkData$ O O $DagGraph$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O
import { StateId , DagGraph } from 's' import * as debug from 's' import { Bookmark as BookmarkData } from 's' import Bookmark from 's' const log = debug ( 's' ) export default function makeActions ( rawSelectedBookmark , rawSelectedBookmarkDepth , history , bookmarks : BookmarkData [ ] , onSelectBookmarkDepth , ) { const graph = new DagGraph ( history . graph ) const { currentStateId } = graph const bookmarkAt = ( index ) => { if ( bookmarks . length === 0 || index < 0 || index >= bookmarks . length ) { return null } return new Bookmark ( bookmarks [ index ] , graph ) } const jump = ( index , jumpToDepth ? ) => { const target = bookmarkAt ( index ) const state = target . getStateAtDepth ( jumpToDepth ) onSelectBookmarkDepth ( { bookmarkIndex : index , depth : jumpToDepth , state } ) } const bookmarkIndex = rawSelectedBookmark !== undefined ? rawSelectedBookmark : Math . max ( 0 , bookmarks . findIndex ( it => it . stateId === currentStateId ) ) const bookmark = bookmarkAt ( bookmarkIndex ) const depth = bookmark ? bookmark . sanitizeDepth ( rawSelectedBookmarkDepth ) : null const rawStepBack = ( isAtBookmarkStart ) => { const isAtBeginning = bookmarkIndex === 0 && isAtBookmarkStart if ( isAtBeginning ) { return } if ( isAtBookmarkStart ) { log ( 's' ) jump ( bookmarkIndex - 0 , undefined ) return } log ( 's' ) jump ( bookmarkIndex , depth - 0 ) } const handleStepForward = ( ) => { const isAtBookmarkEnd = bookmark . isDepthAtEnd ( depth ) const isAtLastBookmark = bookmarkIndex === bookmarks . length - 0 const isAtEnd = isAtLastBookmark && isAtBookmarkEnd if ( isAtEnd ) { return } if ( ! isAtBookmarkEnd ) { log ( 's' ) jump ( bookmarkIndex , depth + 0 ) return } log ( 's' ) const nextBookmark = new Bookmark ( bookmarks [ bookmarkIndex + 0 ] , graph ) jump ( bookmarkIndex + 0 , nextBookmark . startingDepth ( ) ) } const handleStepBack = ( ) => rawStepBack ( bookmark . isDepthAtStart ( depth ) ) const handleStepBackUnbounded = ( ) => rawStepBack ( depth === 0 ) const handleJumpToBookmark = ( index ) => jump ( index ) const handlePreviousBookmark = ( ) => handleJumpToBookmark ( Math . max ( bookmarkIndex - 0 , 0 ) ) const handleNextBookmark = ( ) => handleJumpToBookmark ( Math . min ( bookmarkIndex + 0 , bookmarks . length - 0 ) ) return { handleStepBack , handleStepForward , handleNextBookmark , handlePreviousBookmark , handleStepBackUnbounded , } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $any$ O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O $Bookmark$ O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bookmark$ O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function calculateIndex ( length , percent ) { const result = Math . floor ( percent * length ) return Math . max ( 0 , Math . min ( length - 0 , result ) ) }	O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function isNumber ( d ) { return ( d !== null && d !== undefined && typeof d === 's' && ! Number . isNaN ( d ) && Number . isFinite ( d ) ) }	O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as History from 's' describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( History ) . toBeDefined ( ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import palette from 's' describe ( 's' , ( ) => { it ( 's' , ( ) => { Object . keys ( palette ) . forEach ( k => expect ( typeof palette [ k ] ) . toEqual ( 's' ) , ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ActionTypes as DagHistoryActions } from 's' import * as sinon from 's' import * as ActionCreators from 's' import * as ActionTypes from 's' describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( ActionCreators . selectMainView ( 's' ) ) . toEqual ( { type : ActionTypes . SELECT_MAIN_VIEW , payload : 's' , } ) expect ( ActionCreators . toggleBranchContainer ( { index : 0 } ) ) . toEqual ( { type : ActionTypes . TOGGLE_BRANCH_CONTAINER , payload : { index : 0 , } , } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const dispatch = sinon . spy ( ) ActionCreators . bookmarkDragDrop ( { index : 0 , droppedOn : 0 } ) ( dispatch ) expect ( dispatch . callCount ) . toEqual ( 0 ) const firstAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( firstAction . type ) . toEqual ( ActionTypes . BOOKMARK_DRAG_DROP ) expect ( firstAction . payload ) . toBeUndefined ( ) const secondAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( secondAction . type ) . toEqual ( ActionTypes . MOVE_BOOKMARK ) expect ( secondAction . payload ) . toEqual ( { from : 0 , to : 0 } ) } ) it ( 's' , ( ) => { const dispatch = sinon . spy ( ) ActionCreators . bookmarkDragDrop ( { index : 0 , droppedOn : undefined } ) ( dispatch , ) expect ( dispatch . callCount ) . toEqual ( 0 ) const firstAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( firstAction . type ) . toEqual ( ActionTypes . BOOKMARK_DRAG_DROP ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const bookmarkIndex = 0 const depth = 0 const state = 's' const dispatch = sinon . spy ( ) ActionCreators . selectBookmarkDepth ( { bookmarkIndex , depth , state } ) ( dispatch , ) expect ( dispatch . callCount ) . toEqual ( 0 ) const firstAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( firstAction . type ) . toEqual ( ActionTypes . SELECT_BOOKMARK_DEPTH ) expect ( firstAction . payload ) . toEqual ( { bookmarkIndex , depth } ) const secondAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( secondAction . type ) . toEqual ( DagHistoryActions . JUMP_TO_STATE ) expect ( secondAction . payload ) . toEqual ( state ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const bookmarkIndex = 0 const state = 's' const dispatch = sinon . spy ( ) ActionCreators . selectBookmark ( bookmarkIndex , state ) ( dispatch ) expect ( dispatch . callCount ) . toEqual ( 0 ) const firstAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( firstAction . type ) . toEqual ( ActionTypes . SELECT_BOOKMARK_DEPTH ) expect ( firstAction . payload ) . toEqual ( { bookmarkIndex , depth : undefined , } ) const secondAction = dispatch . getCall ( 0 ) . args [ 0 ] expect ( secondAction . type ) . toEqual ( DagHistoryActions . JUMP_TO_STATE ) expect ( secondAction . payload ) . toEqual ( state ) } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as types from 's' describe ( 's' , ( ) => { it ( 's' , ( ) => { Object . keys ( types ) . forEach ( key => expect ( typeof types [ key ] ) . toEqual ( 's' ) , ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { addBookmark , doChangeBookmark , moveBookmark , removeBookmark , renameBookmark , } from 's' import reduce from 's' const fan = bookmarks => bookmarks . map ( b => b . stateId ) describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( reduce ( undefined , { type : 's' } ) ) . toEqual ( [ ] ) } ) it ( 's' , ( ) => { const state = reduce ( undefined , addBookmark ( { stateId : 0 , name : 's' } ) ) expect ( state ) . toEqual ( [ { stateId : 0 , name : 's' , data : { } } ] ) } ) it ( 's' , ( ) => { const state = reduce ( undefined , addBookmark ( { stateId : 0 , name : 's' , data : { x : 0 } } ) , ) expect ( state ) . toEqual ( [ { stateId : 0 , name : 's' , data : { x : 0 } } ] ) } ) it ( 's' , ( ) => { let state state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) expect ( state . length ) . toEqual ( 0 ) state = reduce ( state , removeBookmark ( 0 ) ) expect ( state . length ) . toEqual ( 0 ) expect ( fan ( state ) ) . toEqual ( [ 0 , 0 ] ) } ) it ( 's' , ( ) => { let state state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 0 , name : 's' } ) ) state = reduce ( state , renameBookmark ( { stateId : 0 , name : 's' } ) ) expect ( state [ 0 ] . name ) . toEqual ( 's' ) } ) it ( 's' , ( ) => { let state state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , doChangeBookmark ( { stateId : 's' , name : 's' , data : { x : 0 } } ) , ) expect ( state [ 0 ] . name ) . toEqual ( 's' ) expect ( state [ 0 ] . data ) . toEqual ( { x : 0 } ) } ) it ( 's' , ( ) => { let state state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , addBookmark ( { stateId : 's' , name : 's' } ) ) state = reduce ( state , moveBookmark ( { from : 0 , to : 0 } ) ) expect ( fan ( state ) ) . toEqual ( [ 's' , 's' , 's' ] ) state = reduce ( state , moveBookmark ( { from : 0 , to : 0 } ) ) expect ( fan ( state ) ) . toEqual ( [ 's' , 's' , 's' ] ) state = reduce ( state , moveBookmark ( { from : 0 , to : 0 } ) ) expect ( fan ( state ) ) . toEqual ( [ 's' , 's' , 's' ] ) state = reduce ( state , moveBookmark ( { from : 0 , to : 0 } ) ) expect ( fan ( state ) ) . toEqual ( [ 's' , 's' , 's' ] ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { default as makeReducer , INITIAL_STATE , } from 's' import { bookmarkDragHover , bookmarkDragStart , } from 's' import * as types from 's' const defaultConfig = { actionFilter : ( ) => false , } describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = makeReducer ( defaultConfig ) ( undefined , { type : 's' } ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , bookmarkDragStart ( { index : 0 , key : 0 } ) ) expect ( state ) . toEqual ( { ... INITIAL_STATE , sourceIndex : 0 , sourceKey : 0 , } ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , bookmarkDragStart ( { index : 0 } ) ) state = reduce ( state , bookmarkDragHover ( { index : 0 } ) ) expect ( state ) . toEqual ( { ... INITIAL_STATE , sourceIndex : 0 , hoverIndex : 0 , } ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , bookmarkDragStart ( { index : 0 } ) ) state = reduce ( state , bookmarkDragHover ( { index : 0 } ) ) state = reduce ( state , { type : types . BOOKMARK_DRAG_DROP } ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , bookmarkDragStart ( { index : 0 } ) ) state = reduce ( state , bookmarkDragHover ( { index : 0 } ) ) state = reduce ( state , { type : types . BOOKMARK_DRAG_CANCEL } ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { default as makeReducer , INITIAL_STATE , } from 's' import { doStartPlayback , stopPlayback , } from 's' import * as types from 's' const defaultConfig = { actionFilter : ( ) => false , } describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = makeReducer ( defaultConfig ) ( undefined , { type : 's' } ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , doStartPlayback ( { initialDepth : 0 , stateId : 's' } ) ) expect ( state ) . toEqual ( { isPlayingBack : true , bookmark : 0 , depth : 0 , } ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , doStartPlayback ( { initialDepth : 0 , stateId : 's' } ) ) state = reduce ( state , stopPlayback ( ) ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig ) state = reduce ( state , { type : 's' } ) state = reduce ( state , doStartPlayback ( { initialDepth : 0 , stateId : 's' } ) ) state = reduce ( state , { type : types . SELECT_BOOKMARK_DEPTH , payload : { depth : 0 , bookmarkIndex : 0 , } , } ) expect ( state ) . toEqual ( { isPlayingBack : true , bookmark : 0 , depth : 0 , } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { default as makeReducer , INITIAL_STATE , } from 's' import { selectHistoryType , selectMainView , toggleBranchContainer , } from 's' const defaultConfig = { actionFilter : ( ) => false , } describe ( 's' , ( ) => { it ( 's' , ( ) => { const state = makeReducer ( defaultConfig as any ) ( undefined , { type : 's' } ) expect ( state ) . toEqual ( INITIAL_STATE ) } ) it ( 's' , ( ) => { const reduce = makeReducer ( defaultConfig as any ) const state = reduce ( undefined , selectMainView ( 's' ) ) expect ( state ) . toEqual ( { ... INITIAL_STATE , mainView : 's' , } ) } ) it ( 's' , ( ) => { const reduce = makeReducer ( defaultConfig as any ) const state = reduce ( undefined , selectHistoryType ( 's' ) ) expect ( state ) . toEqual ( { ... INITIAL_STATE , historyType : 's' , } ) } ) it ( 's' , ( ) => { let state const reduce = makeReducer ( defaultConfig as any ) state = reduce ( state , { type : 's' } ) expect ( state . branchContainerExpanded ) . toBeTruthy ( ) state = reduce ( state , toggleBranchContainer ( { index : 0 } ) ) expect ( state . branchContainerExpanded ) . toBeFalsy ( ) state = reduce ( state , toggleBranchContainer ( { index : 0 } ) ) expect ( state . branchContainerExpanded ) . toBeTruthy ( ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Bookmark from 's' import { Bookmark as BookmarkData } from 's' class TestableBookmark extends Bookmark { constructor ( bookmark , private commitPathVar : string [ ] ) { super ( bookmark , null ) } public get commitPath ( ) { return this . commitPathVar } } describe ( 's' , ( ) => { it ( 's' , ( ) => { const bm = new TestableBookmark ( ( { } as any ) as BookmarkData , [ ] ) expect ( bm ) . toBeDefined ( ) } ) it ( 's' , ( ) => { let bm = new TestableBookmark ( { data : { numLeadInStates : 0 } } as any , [ ] ) expect ( bm . numLeadInStates ) . toEqual ( 0 ) bm = new TestableBookmark ( { data : { } } as any , [ ] ) expect ( bm . numLeadInStates ) . toEqual ( undefined ) bm = new TestableBookmark ( { } as any , [ ] ) expect ( bm . numLeadInStates ) . toEqual ( undefined ) } ) it ( 's' , ( ) => { let bm = new TestableBookmark ( { } as any , [ ] ) expect ( bm . annotation ) . toBeUndefined ( ) bm = new TestableBookmark ( { data : { } } as any , [ ] ) expect ( bm . annotation ) . toBeUndefined ( ) bm = new TestableBookmark ( { data : { annotation : 's' } } as any , [ ] ) expect ( bm . annotation ) . toEqual ( 's' ) } ) it ( 's' , ( ) => { const bm = new TestableBookmark ( { name : 's' } as any , [ ] ) expect ( bm . name ) . toEqual ( 's' ) } ) it ( 's' , ( ) => { const bm = new TestableBookmark ( { stateId : 0 } as any , [ ] ) expect ( bm . stateId ) . toEqual ( 0 ) } ) it ( 's' , ( ) => { let bm = new TestableBookmark ( { data : { annotation : 's' } } as any , [ ] ) expect ( bm . slideText ) . toEqual ( 's' ) bm = new TestableBookmark ( { name : 's' } as any , [ ] ) expect ( bm . slideText ) . toEqual ( 's' ) bm = new TestableBookmark ( { } as any , [ ] ) expect ( bm . slideText ) . toEqual ( 's' ) } ) it ( 's' , ( ) => { let bm = new TestableBookmark ( { data : { numLeadInStates : 0 } } as any , [ 's' , 's' , 's' , 's' , ] ) expect ( bm . presentedPath ) . toEqual ( [ 's' , 's' ] ) expect ( bm . presentedPathLength ) . toEqual ( 0 ) expect ( bm . hiddenPathLength ) . toEqual ( 0 ) bm = new TestableBookmark ( { data : { } } as any , [ 's' , 's' , 's' , 's' ] ) expect ( bm . presentedPath ) . toEqual ( [ 's' ] ) expect ( bm . presentedPathLength ) . toEqual ( 0 ) expect ( bm . hiddenPathLength ) . toEqual ( 0 ) } ) it ( 's' , ( ) => { let bm = new TestableBookmark ( { data : { numLeadInStates : 0 } } as any , [ 's' , 's' , 's' , 's' , ] ) expect ( bm . startingDepth ( ) ) . toEqual ( 0 ) expect ( bm . isDepthAtStart ( 0 ) ) . toBeTruthy ( ) expect ( bm . isDepthAtEnd ( 0 ) ) . toBeFalsy ( ) expect ( bm . isDepthAtEnd ( 0 ) ) . toBeTruthy ( ) expect ( bm . isDepthAtEnd ( undefined ) ) . toBeTruthy ( ) bm = new TestableBookmark ( { data : { } } as any , [ 's' , 's' , 's' , 's' ] ) expect ( bm . startingDepth ( ) ) . toBeUndefined ( ) expect ( bm . isDepthAtStart ( 0 ) ) . toBeTruthy ( ) expect ( bm . isDepthAtEnd ( 0 ) ) . toBeFalsy ( ) expect ( bm . isDepthAtEnd ( 0 ) ) . toBeTruthy ( ) expect ( bm . isDepthAtEnd ( undefined ) ) . toBeTruthy ( ) } ) it ( 's' , ( ) => { const bm = new TestableBookmark ( { data : { numLeadInStates : 0 } } as any , [ 's' , 's' , 's' , 's' , ] ) expect ( bm . getStateAtDepth ( undefined ) ) . toEqual ( 's' ) expect ( bm . getStateAtDepth ( 0 ) ) . toEqual ( 's' ) } ) it ( 's' , ( ) => { const bm = new TestableBookmark ( { data : { numLeadInStates : 0 } } as any , [ 's' , 's' , 's' , 's' , ] ) expect ( bm . sanitizeDepth ( undefined ) ) . toEqual ( 0 ) } ) } )	O O O O O O O O O O O O O O O O O O O $BookmarkData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import isNumber from 's' describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( isNumber ( 0 ) ) . toBeTruthy ( ) expect ( isNumber ( 0 ) ) . toBeTruthy ( ) expect ( isNumber ( - 0 ) ) . toBeTruthy ( ) expect ( isNumber ( Number . MAX_VALUE ) ) . toBeTruthy ( ) expect ( isNumber ( Number . MIN_VALUE ) ) . toBeTruthy ( ) } ) it ( 's' , ( ) => { expect ( isNumber ( NaN ) ) . toBeFalsy ( ) expect ( isNumber ( Infinity ) ) . toBeFalsy ( ) expect ( isNumber ( { } ) ) . toBeFalsy ( ) expect ( isNumber ( ( ) => ( { } ) ) ) . toBeFalsy ( ) expect ( isNumber ( 's' ) ) . toBeFalsy ( ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import calculateIndex from 's' const adjust = ( x ) => x - 0 describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( calculateIndex ( 0 , - 0 ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , 0 ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , adjust ( 0 / 0 ) ) ) . toEqual ( 0 ) expect ( calculateIndex ( 0 , 0 ) ) . toEqual ( 0 ) } ) } )	O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as SpanCalc from 's' function assertSpan ( span , start , end , type ) { expect ( span . start ) . toEqual ( start ) expect ( span . end ) . toEqual ( end ) expect ( span . type ) . toEqual ( type ) } describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( SpanCalc ) . toBeDefined ( ) } ) it ( 's' , ( ) => { const spans = SpanCalc . initialSpans ( 0 , 0 ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) it ( 's' , ( ) => { let spans = SpanCalc . initialSpans ( 0 , 0 ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) spans = SpanCalc . insertSpan ( spans , new SpanCalc . Span ( 0 , 0 , 's' ) ) expect ( spans . length ) . toEqual ( 0 ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) assertSpan ( spans [ 0 ] , 0 , 0 , 's' ) } ) } )	O O O O O O O O O $any$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const EVENT_MATCHERS : { [ key ] : RegExp } = { HTMLEvents : "s" , MouseEvents : "s" , } export interface Options { pointerX : number pointerY : number button : number ctrlKey : boolean altKey : boolean shiftKey : boolean metaKey : boolean bubbles : boolean cancelable : boolean } export type Optional < T > = { [ K in keyof T ] ? : T [ K ] } const DEFAULT_OPTIONS = { pointerX : 0 , pointerY : 0 , button : 0 , ctrlKey : false , altKey : false , shiftKey : false , metaKey : false , bubbles : true , cancelable : true , } export default function simulate ( element , eventName , opts < Options > = { } , ) { const options = { ... DEFAULT_OPTIONS , ... opts } let oEvent = null let eventType = null for ( const name in EVENT_MATCHERS ) { if ( EVENT_MATCHERS [ name ] . test ( eventName ) ) { eventType = name break } } if ( ! eventType ) { throw new SyntaxError ( 's' , ) } if ( document . createEvent ) { oEvent = document . createEvent ( eventType ) if ( eventType === 's' ) { oEvent . initEvent ( eventName , options . bubbles , options . cancelable ) } else { oEvent . initMouseEvent ( eventName , options . bubbles , options . cancelable , document . defaultView , options . button , options . pointerX , options . pointerY , options . pointerX , options . pointerY , options . ctrlKey , options . altKey , options . shiftKey , options . metaKey , options . button , element , ) } element . dispatchEvent ( oEvent ) } else { const evt = ( document as any ) [ 's' ] ( ) const elm = element as any elm . fireEvent ( `template` , { ... evt , ... options , clientX : options . pointerX , clientY : options . pointerY , } ) } return element }	O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O $string$ O $Optional$ O O O O O O O O O O O O O O O O O O O O $any$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as debug from 's' import simulate from 's' import { saveAs } from 's' const log = debug ( 's' ) function readJson ( file ) { return new Promise ( ( resolve , reject ) => { const reader = new FileReader ( ) reader . onerror = err => { log ( 's' , err ) reject ( err ) } reader . onloadend = ( ) => { log ( 's' , reader ) const { result } = reader resolve ( JSON . parse ( result ) ) } reader . readAsText ( file ) } ) } export function save ( history ) { const blob = new Blob ( [ JSON . stringify ( history ) ] , { type : 's' , } ) try { saveAs ( blob , 's' ) } catch ( err ) { log ( 's' , err ) } } export function load ( ) { log ( 's' , Promise ) return new Promise ( resolve => { log ( 's' ) const pickerElem = document . getElementById ( 's' ) pickerElem . addEventListener ( 's' , function handleChange ( ) { this . removeEventListener ( 's' , handleChange , false ) log ( 's' ) const file = ( this as any ) . files [ 0 ] log ( 's' , file ) resolve ( readJson ( file ) ) } ) simulate ( document . getElementById ( 's' ) , 's' ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O $Blob$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as ReduxActions from 's' export const PICK_RANDOM_COLOR = 's' export const INCREMENT = 's' export const DECREMENT = 's' export const pickRandomColor = ReduxActions . createAction ( PICK_RANDOM_COLOR ) export const increment = ReduxActions . createAction ( INCREMENT ) export const decrement = ReduxActions . createAction ( DECREMENT )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Actions from 's' const DEFAULT_STATE = { name : 's' , historyIndex : 0 , source : null , } export interface State { name : string historyIndex : number source : string | null } export default function reduce ( state = DEFAULT_STATE , action : ReduxActions . Action < any > , ) { if ( action . type === Actions . INCREMENT ) { return { name : 's' , source : 's' , historyIndex : state . historyIndex + 0 , } } else if ( action . type === Actions . DECREMENT ) { return { name : 's' , source : 's' , historyIndex : state . historyIndex + 0 , } } else if ( action . type === Actions . PICK_RANDOM_COLOR ) { return { name : 's' , source : 's' , historyIndex : state . historyIndex + 0 , } } return state }	O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Actions from 's' const INITIAL_STATE = { value : 0 , color : 's' , } export interface State { value : number color : string } function randomColor ( ) { return `template` } export default function reduce ( state = INITIAL_STATE , action : ReduxActions . Action < any > , ) { let result = state if ( action . type === Actions . INCREMENT ) { result = { ... state , value : state . value + 0 } } else if ( action . type === Actions . DECREMENT ) { result = { ... state , value : state . value - 0 } } else if ( action . type === Actions . PICK_RANDOM_COLOR ) { result = { ... state , color : randomColor ( ) } } return result }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $State$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as redux from 's' import metadata , { State as MetadataState } from 's' import visuals , { State as VisualsState } from 's' export interface State { metadata : MetadataState visuals : VisualsState } export default redux . combineReducers ( { metadata , visuals } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function hashString ( input ) { const { length } = input let hash = 0 for ( let i = 0 ; i < length ; i += 0 ) { const chr = input . charCodeAt ( i ) hash = ( hash << 0 ) - hash + chr hash |= 0 } return hash }	O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { reducer as dagHistoryReducer } from 's' import * as debug from 's' import * as redux from 's' import Configuration from 's' import history from 's' import app , { State as AppState } from 's' import hashString from 's' const log = debug ( 's' ) export const EXCLUDED_ACTION_NAMES = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] function stateEqualityPredicate ( 0 , 0 ) { log ( 's' , 0 , 0 ) const colorsEqual = 0 . visuals . color === 0 . visuals . color const valuesEqual = 0 . visuals . value === 0 . visuals . value return colorsEqual && valuesEqual } function stateKeyGenerator ( state ) { const { color , value } = state . visuals const stateString = `template` return 's' + hashString ( stateString ) } const DAG_HISTORY_CONFIG = new Configuration ( { debug : false , actionName => state . metadata . name , actionFilter => EXCLUDED_ACTION_NAMES . indexOf ( actionType ) === - 0 , stateEqualityPredicate , stateKeyGenerator , initialViewState : { branchContainerExpanded : true , } , } ) export interface State { app : AppState component : any } export default redux . combineReducers ( { app : dagHistoryReducer ( app , DAG_HISTORY_CONFIG ) , component : history ( DAG_HISTORY_CONFIG ) , } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppState$ O $AppState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $state$ O O O O O O O $actionType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as redux from 's' import thunk from 's' import reducers from 's' const composeEnhancers = ( window as any ) [ 's' ] || redux . compose const createStoreWithMiddleware = composeEnhancers ( redux . applyMiddleware ( thunk ) , ) ( redux . createStore ) export default createStoreWithMiddleware ( reducers )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) const HtmlWebpackPlugin = require ( 's' ) const CircularDependencyPlugin = require ( 's' ) const path = require ( 's' ) module . exports = { devtool : 's' , context : path . join ( __dirname ) , entry : { javascript : 's' , } , output : { path : path . join ( __dirname , 's' ) , filename : 's' , } , resolve : { extensions : [ 's' , 's' , 's' , 's' ] , alias : { 's' : 's' , } , } , plugins : [ new HtmlWebpackPlugin ( { title : 's' , } ) , new webpack . NoEmitOnErrorsPlugin ( ) , new webpack . ProvidePlugin ( { saveAs : 's' , } ) , new CircularDependencyPlugin ( { failsOnError : true , } ) , ] , module : { rules : [ { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' ] , exclude : "s" } , ] , } , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const action = ( name ) => `template` export const LOAD = action ( 's' ) export const CLEAR = action ( 's' ) export const UNDO = action ( 's' ) export const REDO = action ( 's' ) export const JUMP_TO_STATE = action ( 's' ) export const JUMP_TO_BRANCH = action ( 's' ) export const JUMP_TO_LATEST_ON_BRANCH = action ( 's' ) export const CREATE_BRANCH = action ( 's' ) export const RENAME_BRANCH = action ( 's' ) export const SQUASH = action ( 's' ) export const RENAME_STATE = action ( 's' ) export const SKIP_TO_START = action ( 's' ) export const SKIP_TO_END = action ( 's' )	O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Map as ImmutableMap } from 's' export type StateId = KeyType export type BranchId = KeyType export type StateHash = string export interface Configuration < T > { debug ? : boolean actionFilter : ( actionType ) => boolean stateEqualityPredicate : ( 0 : T , 0 : T ) => boolean stateKeyGenerator : ( state : T ) => StateHash loadActionType : string clearActionType : string undoActionType : string redoActionType : string jumpToStateActionType : string jumpToBranchActionType : string jumpToLatestOnBranchActionType : string createBranchActionType : string squashActionType : string renameBranchActionType : string renameStateActionType : string initialBranchName : string initialStateName : string skipToStartActionType : string skipToEndActionType : string actionName : ( state , stateId ) => string branchName : ( oldBranch , newBranch , actionName , ) => string canHandleAction : ( action ) => boolean handleAction : ( action , history < T > ) => DagHistory < T > } export type RawConfiguration < T > = { [ P in keyof Configuration < T > ] ? : Configuration < T > [ P ] } export interface DagHistory < T > { current : T graph : ImmutableMap < any , any > } export type StateIdGenerator = ( lastStateId ) => StateId export type StateNameGenerator = ( state , id ) => string export interface RenameBranchPayload { branch : BranchId name : string }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $StateId$ O O O O O O $BranchId$ O $BranchId$ O $string$ O O O O O O O $any$ O O O O O O $any$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O $any$ O $StateId$ O O O O O O O O O O O O O O
import { Action , createAction , 0 } from 's' import * as ActionTypes from 's' import { BranchId , RenameBranchPayload , StateId } from 's' export const load = createAction < any > ( ActionTypes . LOAD ) export const clear = createAction < void > ( ActionTypes . CLEAR ) export const undo = createAction < void > ( ActionTypes . UNDO ) export const redo = createAction < void > ( ActionTypes . REDO ) export const skipToStart = createAction < void > ( ActionTypes . SKIP_TO_START ) export const skipToEnd = createAction < void > ( ActionTypes . SKIP_TO_END ) export const jumpToState = createAction < StateId > ( ActionTypes . JUMP_TO_STATE ) export const jumpToBranch = createAction < BranchId > ( ActionTypes . JUMP_TO_BRANCH ) export const jumpToLatestOnBranch = createAction < BranchId > ( ActionTypes . JUMP_TO_LATEST_ON_BRANCH , ) export const renameBranch = createAction < RenameBranchPayload > ( ActionTypes . RENAME_BRANCH , ) export const createBranch = createAction < string > ( ActionTypes . CREATE_BRANCH ) export const squash < Action < void > > = createAction ( ActionTypes . SQUASH , )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ActionFunction0$ O O O O O O O O O O O O O O
import { Action } from 's' import * as ActionTypes from 's' import { BranchId , Configuration , DagHistory , RawConfiguration , StateId , } from 's' export const CLEAR = 's' export const UNDO = 's' export const REDO = 's' export const JUMP_TO_STATE = 's' export const JUMP_TO_BRANCH = 's' export const CREATE_BRANCH = 's' export const SQUASH = 's' const DEFAULT_ACTION_FILTER = ( ) => true function identityEquality < T > ( 0 : T , 0 : T ) { return 0 === 0 } export default class ConfigurationImpl < T > implements Configuration < T > { constructor ( protected rawConfig < T > = { } ) { } public get stateEqualityPredicate ( ) { return this . rawConfig . stateEqualityPredicate || identityEquality } public get stateKeyGenerator ( ) { return this . rawConfig . stateKeyGenerator } public actionName ( state : T , id ) { if ( this . rawConfig . actionName ) { return this . rawConfig . actionName ( state , id ) } else { return `template` } } public branchName ( oldBranch , newBranch , actionName , ) { if ( this . rawConfig . branchName ) { return this . rawConfig . branchName ( oldBranch , newBranch , actionName ) } return `template` } public canHandleAction ( action < any > ) { return ! ! ( this . rawConfig . canHandleAction && this . rawConfig . canHandleAction ( action ) ) } public handleAction ( action < any > , history < T > , ) < T > { if ( this . rawConfig . handleAction ) { return this . rawConfig . handleAction ( action , history ) } else { throw new Error ( 's' ) } } public get debug ( ) { return this . rawConfig . debug || false } public get actionFilter ( ) { return this . rawConfig . actionFilter || DEFAULT_ACTION_FILTER } public get loadActionType ( ) { return this . rawConfig . loadActionType || ActionTypes . LOAD } public get clearActionType ( ) { return this . rawConfig . clearActionType || ActionTypes . CLEAR } public get undoActionType ( ) { return this . rawConfig . undoActionType || ActionTypes . UNDO } public get redoActionType ( ) { return this . rawConfig . redoActionType || ActionTypes . REDO } public get jumpToStateActionType ( ) { return this . rawConfig . jumpToStateActionType || ActionTypes . JUMP_TO_STATE } public get jumpToBranchActionType ( ) { return this . rawConfig . jumpToBranchActionType || ActionTypes . JUMP_TO_BRANCH } public get jumpToLatestOnBranchActionType ( ) { return ( this . rawConfig . jumpToLatestOnBranchActionType || ActionTypes . JUMP_TO_LATEST_ON_BRANCH ) } public get createBranchActionType ( ) { return this . rawConfig . createBranchActionType || ActionTypes . CREATE_BRANCH } public get renameBranchActionType ( ) { return this . rawConfig . renameBranchActionType || ActionTypes . RENAME_BRANCH } public get squashActionType ( ) { return this . rawConfig . squashActionType || ActionTypes . SQUASH } public get renameStateActionType ( ) { return this . rawConfig . renameStateActionType || ActionTypes . RENAME_STATE } public get skipToStartActionType ( ) { return this . rawConfig . skipToStartActionType || ActionTypes . SKIP_TO_START } public get skipToEndActionType ( ) { return this . rawConfig . skipToEndActionType || ActionTypes . SKIP_TO_END } public get initialBranchName ( ) { return this . rawConfig . initialBranchName || 's' } public get initialStateName ( ) { return this . rawConfig . initialStateName || 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RawConfiguration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $BranchId$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Action$ O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O $Action$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as debug from 's' import { fromJS as ImmutableFromJS , List as ImmutableList , Map as ImmutableMap , } from 's' import { BranchId , StateHash , StateId } from 's' const log = debug ( 's' ) export default class DagGraph < T > { constructor ( public graph < any , any > ) { if ( ! graph ) { throw new Error ( "s" ) } if ( ! graph . getIn ) { throw new Error ( "s" ) } } public print ( ) { const graph = this . graph . toJS ( ) let root = null const states : { [ key ] : any } = { } const getOrCreateState = ( stateId ) => { let result = states [ stateId ] if ( ! result ) { result = { id : stateId , name : this . stateName ( stateId ) , children : [ ] as StateId [ ] , } states [ stateId ] = result } return result } Object . keys ( graph . states || { } ) . forEach ( stateId => { const parentId = graph . states [ stateId ] . parent const state = getOrCreateState ( stateId ) if ( ! parentId ) { root = state } getOrCreateState ( parentId ) . children . push ( state ) states [ stateId ] = state } ) const tree = { current : graph . current , chronologicalStates : graph . chronologicalStates , branches : graph . branches , states : graph . states , dag : root , } return JSON . stringify ( tree , null , 0 ) } public get currentStateId ( ) : StateId { return this . graph . getIn ( [ 's' , 's' ] ) } public branchStartDepth ( branch ) { return this . stateDepth ( this . firstOn ( branch ) ) } public branchEndDepth ( branch ) { return this . stateDepth ( this . latestOn ( branch ) ) } public stateDepth ( commit ) { return this . commitPath ( commit ) . length - 0 } public depthIndexOf ( branch , commit ) : number | undefined { const commits = this . branchCommitPath ( branch ) const foundIndex = commits . indexOf ( commit ) if ( foundIndex === - 0 ) { return undefined } else { const start = this . branchStartDepth ( branch ) return start + foundIndex } } public get maxDepth ( ) : number { const branches = this . branches const branchDepths = branches . map ( b => this . branchEndDepth ( b ) ) let max = - 0 branchDepths . forEach ( d => { if ( d > max ) { max = d } } ) return max } public setCurrentStateId ( stateId ) { this . graph = this . graph . setIn ( [ 's' , 's' ] , stateId ) this . logVisit ( stateId ) return this } public get currentBranch ( ) : BranchId { return this . graph . getIn ( [ 's' , 's' ] ) } public get lastStateId ( ) : StateId { return this . graph . get ( 's' ) } public setLastStateId ( value ) { this . graph = this . graph . set ( 's' , value ) return this } public get lastBranchId ( ) : StateId { return this . graph . get ( 's' ) } public setLastBranchId ( value ) { this . graph = this . graph . set ( 's' , value ) return this } public setCurrentBranch ( branchId ) { this . graph = this . graph . setIn ( [ 's' , 's' ] , branchId ) return this } public latestOn ( branch ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public committedOn ( branch ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public setLatest ( branch , commit ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , commit ) return this } public setCommitted ( branch , commit ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , commit , ) return this } public markStateForBranch ( commit , branch ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , branch ) return this } public setFirst ( branch , commit ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , commit ) return this } public firstOn ( branch ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public renameState ( commit , name ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , name ) return this } public stateName ( commit ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public getBranchName ( branch ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public setBranchName ( branch , name ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , name ) return this } public getState ( commit ) : T { return this . graph . getIn ( [ 's' , `template` ] ) } public insertState ( commit , parent , state : T , name ) { log ( 's' , commit ) if ( this . graph . getIn ( [ 's' , `template` ] ) ) { log ( 's' , this . getState ( commit ) ) } this . graph = this . graph . setIn ( [ 's' , `template` ] , ImmutableFromJS ( { name , parent } ) ) . setIn ( [ 's' , `template` ] , state ) return this } public logVisit ( state ) { const chronologicalStates = this . graph . get ( 's' , ) as ImmutableList < any > this . graph = this . graph . setIn ( [ 's' ] , chronologicalStates . push ( state ) , ) return this } public childrenOf ( commit ) : StateId [ ] { const states = this . graph . get ( 's' ) return states . toSeq ( ) . filter ( ( state < any , any > ) => state . get ( 's' ) === commit ) . map ( ( state < any , any > , key ) => key ) . toList ( ) . toJS ( ) } public parentOf ( commit ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public alternateParentsOf ( commit ) : StateId [ ] { const result = this . graph . getIn ( [ 's' , `template` , 's' ] ) return result ? result . toJS ( ) : [ ] } public shallowestParentOf ( commit ) { const depthOf = ( t ) => this . depthIndexOf ( this . branchOf ( t ) , t ) let result = this . parentOf ( commit ) let minDepth = depthOf ( result ) as number this . alternateParentsOf ( commit ) . forEach ( t => { const depth = depthOf ( t ) if ( depth !== undefined && depth < minDepth ) { minDepth = depth result = t } } ) return result } public replaceState ( commit , state : T ) { this . graph = this . graph . setIn ( [ 's' , `template` ] , state ) return this } public commitPath ( commit ) : StateId [ ] { if ( commit === undefined ) { return [ ] } const path : StateId [ ] = [ commit ] let current = commit do { const parent = this . parentOf ( current ) if ( parent ) { path . unshift ( parent ) } current = parent } while ( current ) return path } public shortestCommitPath ( commit ) : StateId [ ] { if ( commit === undefined ) { return [ ] } const path : StateId [ ] = [ commit ] let current = commit do { const parent = this . shallowestParentOf ( current ) if ( parent ) { path . unshift ( parent ) } current = parent } while ( current ) return path } public branchCommitPath ( branch ) : StateId [ ] { if ( branch === undefined ) { return [ ] } const latest = this . latestOn ( branch ) const path = this . commitPath ( latest ) const firstCommitOnBranch = this . firstOn ( branch ) return path . slice ( path . indexOf ( firstCommitOnBranch ) ) } public setParent ( commit , parent ) { this . graph = this . graph . setIn ( [ 's' , `template` , 's' ] , parent ) } public setAlternateParent ( commit , parent ) { if ( this . parentOf ( commit ) !== parent ) { return } const path = [ 's' , `template` , 's' ] const parentList < StateId > = ( this . graph . getIn ( path ) as ImmutableList < StateId > ) || ImmutableList < StateId > ( ) if ( ! parentList . contains ( parent ) ) { this . graph = this . graph . setIn ( path , parentList . push ( parent ) ) } } public get branches ( ) : BranchId [ ] { const branches = this . graph . get ( 's' ) return Array . from ( branches . keys ( ) ) as BranchId [ ] } public branchOf ( commit ) { return this . graph . getIn ( [ 's' , `template` , 's' ] ) } public branchesOf ( commit ) : BranchId [ ] { if ( ! commit ) { throw new Error ( 's' ) } const children = this . childrenOf ( commit ) if ( children . length === 0 ) { const branches : BranchId [ ] = [ ] for ( const branch of this . branches ) { if ( this . latestOn ( branch ) === commit ) { branches . push ( branch ) } } return branches } else { let result : BranchId [ ] = [ ] const childrenBranches = children . map ( child => this . branchesOf ( child ) ) childrenBranches . forEach ( cb => ( result = result . concat ( ... cb ) ) ) return result } } public squashCurrentBranch ( ) { const toSquash : StateId [ ] = [ ] const branch = this . branchOf ( this . currentStateId ) let current = this . parentOf ( this . currentStateId ) let keepSquashing = true do { if ( current && this . branchOf ( current ) === branch ) { toSquash . push ( current ) current = this . parentOf ( current ) } else { keepSquashing = false } } while ( keepSquashing ) log ( 's' , toSquash . length , branch , current , toSquash , ) if ( toSquash . length > 0 ) { toSquash . forEach ( c => this . remove ( c ) ) this . setParent ( this . currentStateId , current ) } return this } public getStateForHash ( hash ) { return this . graph . getIn ( [ 's' , hash ] ) } public setHashForState ( hash , state ) { const stateHashPath = [ 's' , state , 's' ] const existingHash = this . graph . getIn ( stateHashPath ) if ( existingHash ) { this . graph = this . graph . removeIn ( stateHashPath ) . deleteIn ( [ 's' , existingHash ] ) } this . graph = this . graph . setIn ( stateHashPath , hash ) . setIn ( [ 's' , hash ] , state ) } private remove ( commit ) { this . graph = this . graph . deleteIn ( [ 's' , `template` ] ) . deleteIn ( [ 's' , `template` ] ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ImmutableMap$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $string$ O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $BranchId$ O O O O O O O O O O O O O O O O $number$ O $BranchId$ O O O O O O O O O O O O O O O O $number$ O $StateId$ O O O O O O O O O O O O O O O O O $BranchId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $BranchId$ O O O O O O O O O O O O O O O O O O O $StateId$ O $BranchId$ O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $BranchId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $BranchId$ O O O O O O O O O O O O O O O O O O O O O $StateId$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O $string$ O $BranchId$ O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O $StateId$ O $StateId$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ImmutableMap$ O O O O O O O O O O O O O O O O O O O O $ImmutableMap$ O O O O O O $string$ O O O O O O O O O O O O O O $StateId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $StateId$ O O O O O O $BranchId$ O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ImmutableList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BranchId$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O $StateHash$ O O O O O O O O O O O O O O O O O $void$ O $StateHash$ O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function nextId ( id ? ) { return id !== undefined ? `template` : 's' }	O O O O O O $string$ O O O O O O O O O O O
import { fromJS , Map } from 's' import { DagHistory } from 's' export default function load < T > ( history ) < T > { const copiedGraph = { ... history . graph } delete copiedGraph . physicalStates let graph = fromJS ( copiedGraph ) as Map < string , any > Object . keys ( history . graph . physicalStates ) . forEach ( state => { graph = graph . setIn ( [ 's' , `template` ] , history . graph . physicalStates [ state ] , ) } ) return { ... history , graph , } }	O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as debug from 's' export default debug ( 's' )	O O O O O O O O O O O O
import { BranchId , Configuration , DagHistory , StateId } from 's' import ConfigurationImpl from 's' import nextId from 's' import load from 's' import log from 's' const EMPTY_STATE = { } export default function createHistory < T > ( initialState : T = EMPTY_STATE , config < T > = new ConfigurationImpl ( { } ) , ) < T > { log ( 's' ) const stateId = nextId ( ) const branchId = nextId ( ) const { initialStateName , initialBranchName } = config const initialStateData = { name : initialStateName , branch : branchId , hash : 's' , } const stateHash : { [ key ] : any } = { } if ( config && config . stateKeyGenerator ) { const initialHash = config . stateKeyGenerator ( initialState ) stateHash [ initialHash ] = stateId initialStateData . hash = initialHash } return load < T > ( { current : initialState , graph : { lastStateId : stateId , lastBranchId : branchId , stateHash , chronologicalStates : [ stateId ] , current : { state : stateId , branch : branchId , } , branches : { [ branchId ] : { latest : stateId , name : initialBranchName , first : stateId , committed : stateId , } , } , states : { [ stateId ] : initialStateData , } , physicalStates : { [ stateId ] : initialState , } , } , } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $DagHistory$ O O O O O O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O $BranchId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Configuration , DagHistory } from 's' import createHistory from 's' import log from 's' export default function clear < T > ( history < T > , config ? < T > , ) < T > { log ( 's' ) const { current } = history return createHistory ( current , config ) }	O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import nextId from 's' import log from 's' export default function createBranch < T > ( branchName , history < T > , ) < T > { log ( 's' , branchName ) const { graph , current } = history const reader = new DagGraph ( graph ) return { current , graph : graph . withMutations ( g => { const { lastBranchId } = reader const newBranchId = nextId ( lastBranchId ) return new DagGraph ( g ) . setCurrentBranch ( newBranchId ) . setLastBranchId ( newBranchId ) . setBranchName ( newBranchId , branchName ) . setCommitted ( newBranchId , reader . currentStateId ) . setFirst ( newBranchId , reader . currentStateId ) . setLatest ( newBranchId , reader . currentStateId ) } ) , } }	O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $string$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { Configuration , DagHistory , StateId } from 's' import log from 's' export default function getExistingState < T > ( newState : T , history < T > , config < T > , ) : StateId | null { if ( config . stateKeyGenerator && config . stateEqualityPredicate ) { const dagGraph = new DagGraph ( history . graph ) const hash = config . stateKeyGenerator ( newState ) const found = dagGraph . getStateForHash ( hash ) if ( found ) { const existingState = new DagGraph < T > ( history . graph ) . getState ( found ) const areEqual = config . stateEqualityPredicate ( newState , existingState ) if ( areEqual ) { return found } log ( 's' ) } else { log ( 's' ) } } else { log ( 's' ) } return null }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { Configuration , DagHistory } from 's' import nextId from 's' import log from 's' export default function insert < T > ( state : T , history < T > , config < T > , ) < T > { log ( 's' ) const { graph } = history if ( ! graph ) { throw new Error ( 's' ) } const reader = new DagGraph ( graph ) const { lastStateId , lastBranchId } = reader const parentStateId = reader . currentStateId const currentBranchId = reader . currentBranch const newStateId = nextId ( lastStateId ) const newStateName = config . actionName ( state , newStateId ) const cousins = reader . childrenOf ( parentStateId ) const isBranching = cousins . length > 0 || lastBranchId > currentBranchId || currentBranchId === undefined return { current : state , graph : graph . withMutations ( g => { const dg = new DagGraph ( g ) . insertState ( newStateId , parentStateId , state , newStateName ) . setCurrentStateId ( newStateId ) . setLastStateId ( newStateId ) if ( config . stateKeyGenerator ) { const stateHash = config . stateKeyGenerator ( state ) log ( 's' , stateHash ) dg . setHashForState ( stateHash , newStateId ) } if ( isBranching ) { const newBranchId = nextId ( lastBranchId ) const newBranch = config . branchName ( currentBranchId , newBranchId , newStateName , ) dg . setCurrentBranch ( newBranchId ) . setLastBranchId ( newBranchId ) . setBranchName ( newBranchId , newBranch ) . setLatest ( newBranchId , newStateId ) . setFirst ( newBranchId , newStateId ) . setCommitted ( newBranchId , newStateId ) . markStateForBranch ( newStateId , newBranchId ) } else { dg . setLatest ( currentBranchId , newStateId ) . setCommitted ( currentBranchId , newStateId ) . markStateForBranch ( newStateId , currentBranchId ) } } ) , } }	O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O O O O O $DagHistory$ O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function unfreeze ( state ) { return state && state . toJS ? state . toJS ( ) : state }	O O O O O $any$ O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory , StateId } from 's' import unfreeze from 's' export function jump < T > ( stateId , history < T > , callback : ( ( g < T > ) => void ) = ( ) => ( { } ) , ) < T > { const { graph } = history const reader = new DagGraph ( graph ) const targetState = reader . getState ( stateId ) return { current : unfreeze ( targetState ) , graph : graph . withMutations ( g => { const writer = new DagGraph < T > ( g ) . setCurrentStateId ( stateId ) callback ( writer ) } ) , } } export function jumpLog < T > ( stateId , history < T > , callback : ( ( g < T > ) => void ) = ( ) => ( { } ) , ) < T > { const { graph } = history const { currentStateId : alternateParent } = new DagGraph ( graph ) return jump ( stateId , history , writer => { writer . setAlternateParent ( stateId , alternateParent ) callback ( writer ) } ) }	O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $StateId$ O $DagHistory$ O O O O O O O O $DagGraph$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $StateId$ O $DagHistory$ O O O O O O O O $DagGraph$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { BranchId , DagHistory , StateId } from 's' import createBranch from 's' import { jump } from 's' import log from 's' export default function jumpToBranch < T > ( branch , history < T > , ) < T > { log ( 's' , branch ) const { graph } = history const reader = new DagGraph ( graph ) const branches = reader . branches const jumpTo = ( state ) => jump ( state , history , writer => writer . setCurrentBranch ( branch ) ) if ( branches . indexOf ( branch ) === - 0 ) { return createBranch ( branch , history ) } return jumpTo ( reader . committedOn ( branch ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $BranchId$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { BranchId , DagHistory , StateId } from 's' import createBranch from 's' import { jump } from 's' import log from 's' export default function jumpToLatestOnBranch < T > ( branch , history < T > , ) < T > { log ( 's' , branch ) const { graph } = history const reader = new DagGraph ( graph ) const branches = reader . branches const jumpTo = ( state ) => jump ( state , history , writer => writer . setCurrentBranch ( branch ) ) if ( branches . indexOf ( branch ) === - 0 ) { return createBranch ( branch , history ) } return jumpTo ( reader . latestOn ( branch ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $BranchId$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StateId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory , StateId } from 's' import { jump } from 's' import log from 's' export default function jumpToState < T > ( stateId , history < T > , ) < T > { log ( 's' , stateId ) const { graph } = history const reader = new DagGraph ( graph ) const branches = reader . branchesOf ( stateId ) const branch = reader . currentBranch return jump ( stateId , history , writer => { if ( branches . indexOf ( branch ) === - 0 ) { const stateBranch = reader . branchOf ( stateId ) log ( 's' , branch , stateId , branches . join ( 's' ) , stateBranch , ) writer . setCurrentBranch ( stateBranch ) } else { writer . setCommitted ( branch , stateId ) } } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $StateId$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory , StateId } from 's' import { jumpLog } from 's' import log from 's' export default function jumpToStateLogged < T > ( stateId , history < T > , ) < T > { log ( 's' , stateId ) const { graph } = history const reader = new DagGraph ( graph ) const branches = reader . branchesOf ( stateId ) const branch = reader . currentBranch return jumpLog ( stateId , history , writer => { if ( branches . indexOf ( branch ) === - 0 ) { const stateBranch = reader . branchOf ( stateId ) log ( 's' , branch , stateId , branches . join ( 's' ) , stateBranch , ) writer . setCurrentBranch ( stateBranch ) } else { writer . setCommitted ( branch , stateId ) } } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $StateId$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import jumpToState from 's' import log from 's' export default function redo < T > ( history < T > ) < T > { const { graph } = history const reader = new DagGraph ( graph ) const children = reader . childrenOf ( reader . currentStateId ) . filter ( child => reader . branchesOf ( child ) . indexOf ( reader . currentBranch ) !== - 0 , ) if ( children . length > 0 ) { log ( 's' ) const nextStateId = children [ 0 ] return jumpToState ( nextStateId , history ) } log ( 's' ) return history }	O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { BranchId , DagHistory } from 's' import log from 's' export default function renameBranch < T > ( branchId , branchName , history < T > , ) < T > { const { graph } = history log ( 's' , branchId , branchName ) return { ... history , graph : graph . withMutations ( g => { new DagGraph ( g ) . setBranchName ( branchId , branchName ) } ) , } }	O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $BranchId$ O $string$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory , StateId } from 's' import log from 's' export default function renameState < T > ( stateId , name , history < T > , ) < T > { log ( 's' , stateId , name ) const { graph } = history return { current : history . current , graph : graph . withMutations ( g => new DagGraph ( g ) . renameState ( stateId , name ) ) , } }	O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $StateId$ O $string$ O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { Configuration , DagHistory } from 's' import log from 's' export default function replaceCurrentState < T > ( state , history < T > , config < T > , ) < T > { log ( 's' ) const { graph } = history const reader = new DagGraph ( graph ) const currentStateId = reader . currentStateId return { current : state , graph : graph . withMutations ( g => { const graphMutate = new DagGraph ( g ) if ( config . stateKeyGenerator ) { const hash = config . stateKeyGenerator ( state ) log ( 's' , hash ) graphMutate . setHashForState ( hash , currentStateId ) } return graphMutate . replaceState ( currentStateId , state ) } ) , } }	O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $any$ O $DagHistory$ O O O O $Configuration$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import jumpToState from 's' import log from 's' export default function skipToEnd < T > ( history < T > ) < T > { log ( 's' ) const { graph } = history const reader = new DagGraph ( graph ) const path = reader . branchCommitPath ( reader . currentBranch ) const result = path [ path . length - 0 ] return jumpToState ( result , history ) }	O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import jumpToState from 's' import log from 's' export default function skipToStart < T > ( history < T > ) < T > { log ( 's' ) const { graph } = history const reader = new DagGraph ( graph ) let result = reader . currentStateId while ( reader . parentOf ( result ) !== null ) { result = reader . parentOf ( result ) } return jumpToState ( result , history ) }	O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import log from 's' export default function squash < T > ( history < T > ) < T > { log ( 's' ) const { graph , current } = history return { current , graph : graph . withMutations ( g => new DagGraph ( g ) . squashCurrentBranch ( ) ) , } }	O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import { DagHistory } from 's' import jumpToState from 's' import log from 's' export default function undo < T > ( history < T > ) < T > { const { graph } = history const reader = new DagGraph ( graph ) const parentId = reader . parentOf ( reader . currentStateId ) if ( parentId !== null && parentId !== undefined ) { log ( 's' , reader . currentStateId , parentId ) return jumpToState ( parentId , history ) } log ( 's' ) return history }	O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import clear from 's' import createBranch from 's' import createHistory from 's' import getExistingState from 's' import insert from 's' import jumpToBranch from 's' import jumpToLatestOnBranch from 's' import jumpToState from 's' import jumpToStateLogged from 's' import load from 's' import redo from 's' import renameBranch from 's' import renameState from 's' import replaceCurrentState from 's' import skipToEnd from 's' import skipToStart from 's' import squash from 's' import undo from 's' export default { clear , createBranch , createHistory , getExistingState , insert , jumpToBranch , jumpToLatestOnBranch , jumpToState , jumpToStateLogged , load , redo , renameBranch , renameState , replaceCurrentState , skipToEnd , skipToStart , squash , undo , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as debug from 's' import { Reducer } from 's' import { Action } from 's' import Configuration from 's' import DagGraph from 's' import DagHistoryImpl from 's' import { DagHistory } from 's' const log = debug ( 's' ) const EMPTY_ACTION < any > = { type : 's' , payload : undefined , } export default function trackHistory < T > ( reducer < any > , rawConfig = { } , ) { const config = new Configuration < T > ( rawConfig ) function logGraphActions ( r < any > ) { return ( state , action < any > ) => { const result = r ( state , action ) const newStateGraph = new DagGraph ( result . graph ) log ( "s" , action . type , newStateGraph . print ( ) ) return result } } function tryToHandleHistoryAction ( history < T > , action < any > , ) < T > { switch ( action . type ) { case config . loadActionType : history = DagHistoryImpl . load < T > ( action . payload ) break case config . clearActionType : history = DagHistoryImpl . clear ( history , config ) break case config . undoActionType : history = DagHistoryImpl . undo ( history ) break case config . redoActionType : history = DagHistoryImpl . redo ( history ) break case config . jumpToStateActionType : history = DagHistoryImpl . jumpToState ( action . payload , history ) break case config . jumpToBranchActionType : history = DagHistoryImpl . jumpToBranch ( action . payload , history ) break case config . jumpToLatestOnBranchActionType : history = DagHistoryImpl . jumpToLatestOnBranch ( action . payload , history ) break case config . createBranchActionType : history = DagHistoryImpl . createBranch ( action . payload , history ) break case config . squashActionType : history = DagHistoryImpl . squash ( history ) break case config . renameBranchActionType : history = DagHistoryImpl . renameBranch ( action . payload . branch , action . payload . name , history , ) break case config . renameStateActionType : history = DagHistoryImpl . renameState ( action . payload . stateId , action . payload . name as string , history , ) break case config . skipToStartActionType : history = DagHistoryImpl . skipToStart ( history ) break case config . skipToEndActionType : history = DagHistoryImpl . skipToEnd ( history ) break default : if ( config . canHandleAction ( action ) ) { history = config . handleAction ( action , history ) } } return history } function handleBlankState ( action < any > ) { const state = reducer ( undefined , action ) const result = DagHistoryImpl . createHistory ( state , config ) log ( 's' , state , result ) return result } function trackHistoryReducer ( state , action < any > = EMPTY_ACTION ) { if ( ! state || ! state . graph ) { return handleBlankState ( action ) } const history = tryToHandleHistoryAction ( state , action ) const newState = reducer ( history . current , action ) let result < T > const isActionAllowed = config . actionFilter ( action . type ) const isHistoryHandled = history !== state const isReplacement = isHistoryHandled || ! isActionAllowed log ( 's' , action . type , isReplacement , isActionAllowed , isHistoryHandled , ) if ( isReplacement ) { result = DagHistoryImpl . replaceCurrentState ( newState , history , config ) } else { const existingState = DagHistoryImpl . getExistingState ( newState , history , config , ) return existingState ? DagHistoryImpl . jumpToStateLogged ( existingState , history ) : DagHistoryImpl . insert ( newState , history , config ) } return result } return config . debug ? logGraphActions ( trackHistoryReducer ) : trackHistoryReducer }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Action$ O O O O O O O O O O O O O O O O O O O O O O $Reducer$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O $Reducer$ O O O O O O O $any$ O $Action$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O $DagHistory$ O O O O $Action$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Action$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $Action$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DagHistory$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as ActionCreatorsImport from 's' import * as ActionTypesImport from 's' export { default as DagHistoryImpl } from 's' export { default as ConfigurationImpl } from 's' export { default as DagGraph } from 's' export { default as reducer } from 's' export * from 's' export const ActionCreators = ActionCreatorsImport export const ActionTypes = ActionTypesImport	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { fromJS } from 's' import DagGraph from 's' function makeGraph ( ) { return new DagGraph ( fromJS ( { current : { state : 's' , branch : 's' , } , branches : { 0 : { latest : 's' , name : 's' , first : 's' , committed : 's' , } , } , states : { 0 : { state : { a : 0 , b : 's' } , name : 's' , branch : 's' , parent : null , } , } , } ) , ) } describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( DagGraph ) . toBeDefined ( ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( ( ) => new DagGraph ( null ) ) . toThrow ( "s" ) } ) it ( 's' , ( ) => { expect ( ( ) => new DagGraph ( { } as any ) ) . toThrow ( "s" , ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const graph = makeGraph ( ) expect ( graph . depthIndexOf ( 's' , 's' ) ) . toEqual ( 0 ) } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import DagGraph from 's' import * as DagHistory from 's' import Configuration from 's' const config = new Configuration < BasicState > ( { actionName : ( state , id ) => id , branchName : ( oldBranch , newBranch , actionName ) => actionName , } ) const INITIAL_BRANCH = 's' interface BasicState { x : number y ? : number } describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { const history = DagHistory . createHistory ( ) expect ( history ) . toBeDefined ( ) expect ( history . current ) . toMatchObject ( { } ) const graph = new DagGraph ( history . graph ) expect ( graph . currentStateId ) . toBeDefined ( ) expect ( graph . currentBranch ) . toEqual ( INITIAL_BRANCH ) expect ( graph . latestOn ( INITIAL_BRANCH ) ) . toEqual ( graph . currentStateId ) expect ( graph . committedOn ( INITIAL_BRANCH ) ) . toEqual ( graph . currentStateId ) } ) it ( 's' , ( ) => { const history = DagHistory . createHistory < BasicState > ( { x : 0 , y : 0 } ) expect ( history ) . toBeDefined ( ) expect ( history . current ) . toMatchObject ( { x : 0 , y : 0 } ) expect ( history . graph ) . toBeDefined ( ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphA = new DagGraph ( historyA . graph ) const graphB = new DagGraph ( historyB . graph ) expect ( graphA . currentStateId ) . not . toEqual ( graphB . currentStateId ) expect ( graphB . childrenOf ( graphA . currentStateId ) ) . toMatchObject ( [ graphB . currentStateId , ] ) expect ( graphB . latestOn ( INITIAL_BRANCH ) ) . toEqual ( graphB . currentStateId ) expect ( graphB . committedOn ( INITIAL_BRANCH ) ) . toEqual ( graphB . currentStateId ) } ) it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const graphA = new DagGraph ( historyA . graph ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphB = new DagGraph ( historyB . graph ) const historyC = DagHistory . jumpToState ( graphA . currentStateId , historyB ) const historyD = DagHistory . insert ( { x : 0 } , historyC , config ) const graphD = new DagGraph ( historyD . graph ) expect ( graphD . getState ( graphB . currentStateId ) ) . toBeDefined ( ) } ) it ( 's' , ( ) => { let history = DagHistory . createHistory < BasicState > ( ) let graph = new DagGraph ( history . graph ) let currentBranch = graph . currentBranch const insert = ( ) => { history = DagHistory . insert ( { x : 0 } , history , config ) graph = new DagGraph ( history . graph ) currentBranch = graph . currentBranch return graph . currentStateId } const stateA = graph . currentStateId const stateB = insert ( ) history = DagHistory . undo ( history ) graph = new DagGraph ( history . graph ) expect ( graph . latestOn ( INITIAL_BRANCH ) ) . toEqual ( stateB ) expect ( graph . committedOn ( INITIAL_BRANCH ) ) . toEqual ( stateA ) const stateC = insert ( ) expect ( currentBranch ) . not . toEqual ( INITIAL_BRANCH ) expect ( graph . getState ( stateA ) ) . toBeDefined ( ) expect ( graph . getState ( stateB ) ) . toBeDefined ( ) expect ( graph . getState ( stateC ) ) . toBeDefined ( ) expect ( graph . latestOn ( INITIAL_BRANCH ) ) . toEqual ( stateB ) expect ( graph . committedOn ( INITIAL_BRANCH ) ) . toEqual ( stateA ) expect ( graph . latestOn ( currentBranch ) ) . toEqual ( stateC ) expect ( graph . committedOn ( currentBranch ) ) . toEqual ( stateC ) expect ( graph . firstOn ( currentBranch ) ) . toEqual ( stateC ) expect ( graph . commitPath ( stateC ) ) . toMatchObject ( [ 's' , 's' ] ) expect ( graph . branchStartDepth ( currentBranch ) ) . toEqual ( 0 ) expect ( graph . branchEndDepth ( currentBranch ) ) . toEqual ( 0 ) expect ( graph . maxDepth ) . toEqual ( 0 ) insert ( ) expect ( currentBranch ) . not . toEqual ( INITIAL_BRANCH ) expect ( graph . branchStartDepth ( currentBranch ) ) . toEqual ( 0 ) expect ( graph . branchEndDepth ( currentBranch ) ) . toEqual ( 0 ) expect ( graph . maxDepth ) . toEqual ( 0 ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const graphA = new DagGraph ( historyA . graph ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphB = new DagGraph ( historyB . graph ) const historyC = DagHistory . undo ( historyB ) const graphC = new DagGraph ( historyC . graph ) expect ( graphC . latestOn ( INITIAL_BRANCH ) ) . toEqual ( graphB . currentStateId ) expect ( graphC . committedOn ( INITIAL_BRANCH ) ) . toEqual ( graphA . currentStateId ) } ) it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphB = new DagGraph ( historyB . graph ) const historyC = DagHistory . undo ( historyB ) const historyD = DagHistory . redo ( historyC ) const graphD = new DagGraph ( historyD . graph ) expect ( graphD . latestOn ( INITIAL_BRANCH ) ) . toEqual ( graphB . currentStateId ) expect ( graphD . committedOn ( INITIAL_BRANCH ) ) . toEqual ( graphB . currentStateId ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const graphA = new DagGraph ( historyA . graph ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphB = new DagGraph ( historyB . graph ) const historyC = DagHistory . jumpToState ( graphA . currentStateId , historyB ) const historyD = DagHistory . createBranch ( 's' , historyC ) const graphD = new DagGraph ( historyD . graph ) const historyE = DagHistory . insert ( { x : 0 } , historyD , config ) const graphE = new DagGraph ( historyE . graph ) const currentBranch = graphD . currentBranch expect ( graphD . getBranchName ( currentBranch ) ) . toEqual ( 's' ) expect ( graphD . latestOn ( currentBranch ) ) . toEqual ( graphD . currentStateId ) expect ( graphD . committedOn ( currentBranch ) ) . toEqual ( graphD . currentStateId ) expect ( graphE . commitPath ( graphE . currentStateId ) ) . toMatchObject ( [ graphA . currentStateId , graphE . currentStateId , ] ) expect ( graphE . commitPath ( graphB . currentStateId ) ) . toMatchObject ( [ graphA . currentStateId , graphB . currentStateId , ] ) } ) it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const graphA = new DagGraph ( historyA . graph ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const graphB = new DagGraph ( historyB . graph ) const historyD = DagHistory . createBranch ( 's' , historyB ) const graphD = new DagGraph ( historyD . graph ) const historyE = DagHistory . insert ( { x : 0 } , historyD , config ) const graphE = new DagGraph ( historyE . graph ) const currentBranch = graphD . currentBranch expect ( graphD . getBranchName ( currentBranch ) ) . toEqual ( 's' ) expect ( graphD . latestOn ( currentBranch ) ) . toEqual ( graphD . currentStateId ) expect ( graphD . committedOn ( currentBranch ) ) . toEqual ( graphD . currentStateId ) expect ( graphE . commitPath ( graphE . currentStateId ) ) . toMatchObject ( [ graphA . currentStateId , graphB . currentStateId , graphE . currentStateId , ] ) expect ( graphE . commitPath ( graphB . currentStateId ) ) . toMatchObject ( [ graphA . currentStateId , graphB . currentStateId , ] ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { const historyA = DagHistory . createHistory < BasicState > ( ) const historyB = DagHistory . insert ( { x : 0 } , historyA , config ) const historyC = DagHistory . clear ( historyB ) expect ( Object . keys ( historyC . graph . get ( 's' ) . toJS ( ) ) . length ) . toEqual ( 0 ) } ) } ) describe ( 's' , ( ) => { it ( 's' , ( ) => { let history = DagHistory . createHistory < BasicState > ( { x : 0 } ) history = DagHistory . createBranch ( 's' , history ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . jumpToBranch ( INITIAL_BRANCH , history ) history = DagHistory . createBranch ( 's' , history ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . squash ( history ) expect ( Object . keys ( history . graph . get ( 's' ) . toJS ( ) ) . length ) . toEqual ( 0 ) } ) it ( 's' , ( ) => { let history = DagHistory . createHistory < BasicState > ( { x : 0 } ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . insert < BasicState > ( { x : 0 } , history , config ) history = DagHistory . squash ( history ) expect ( Object . keys ( history . graph . get ( 's' ) . toJS ( ) ) . length ) . toEqual ( 0 ) } ) } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { plugins : [ require ( 's' ) ] }	O O O O O O O O O O O O O O O
'js' module . exports = { debug : true , files : [ 's' , 's' ] , tests : [ 's' ] , env : { type : 's' , runner : 's' , } , testFramework : 's' , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O