export class Globals { public static isTesting = false ; public static WhitespaceRegExp = new RegExp ( "s" ) ; public static active = true ; }	O O $any$ O O O $boolean$ O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O $boolean$ O O O O
's' ; import * as vscode from 's' ; import { Position , PositionDiff } from 's' ; import { Globals } from 's' ; export class TextEditor { static async insert ( text , at : Position | undefined = undefined , letVSCodeHandleKeystrokes : boolean | undefined = undefined ) < boolean > { if ( letVSCodeHandleKeystrokes === undefined ) { letVSCodeHandleKeystrokes = text . length === 0 ; } if ( ! letVSCodeHandleKeystrokes ) { await vscode . window . activeTextEditor ! . edit ( editBuilder => { if ( ! at ) { at = Position . FromVSCodePosition ( vscode . window . activeTextEditor ! . selection . active ) ; } editBuilder . insert ( at ! , text ) ; } ) ; } else { await vscode . commands . executeCommand ( 's' , { text } ) ; } return true ; } static async insertAt ( text , position : vscode . Position ) < boolean > { return vscode . window . activeTextEditor ! . edit ( editBuilder => { editBuilder . insert ( position , text ) ; } ) ; } static async delete ( range : vscode . Range ) < boolean > { return vscode . window . activeTextEditor ! . edit ( editBuilder => { editBuilder . delete ( range ) ; } ) ; } static getDocumentVersion ( ) { return vscode . window . activeTextEditor ! . document . version ; } static getDocumentName ( ) { return vscode . window . activeTextEditor ! . document . fileName ; } static async deleteDocument ( ) < boolean > { const start = new vscode . Position ( 0 , 0 ) ; const lastLine = vscode . window . activeTextEditor ! . document . lineCount - 0 ; const end = vscode . window . activeTextEditor ! . document . lineAt ( lastLine ) . range . end ; const range = new vscode . Range ( start , end ) ; return vscode . window . activeTextEditor ! . edit ( editBuilder => { editBuilder . delete ( range ) ; } ) ; } static async replace ( range : vscode . Range , text ) < boolean > { return vscode . window . activeTextEditor ! . edit ( editBuilder => { editBuilder . replace ( range , text ) ; } ) ; } static readLine ( ) { const lineNo = vscode . window . activeTextEditor ! . selection . active . line ; return vscode . window . activeTextEditor ! . document . lineAt ( lineNo ) . text ; } static readLineAt ( lineNo ) { if ( lineNo === null ) { lineNo = vscode . window . activeTextEditor ! . selection . active . line ; } if ( lineNo >= vscode . window . activeTextEditor ! . document . lineCount ) { throw new RangeError ( ) ; } return vscode . window . activeTextEditor ! . document . lineAt ( lineNo ) . text ; } static getLineCount ( ) { return vscode . window . activeTextEditor ! . document . lineCount ; } static getLineAt ( position : vscode . Position ) : vscode . TextLine { return vscode . window . activeTextEditor ! . document . lineAt ( position ) ; } static getCharAt ( position ) { const line = TextEditor . getLineAt ( position ) ; return line . text [ position . character ] ; } static getLineMaxColumn ( lineNumber ) { if ( lineNumber < 0 || lineNumber > TextEditor . getLineCount ( ) ) { throw new Error ( 's' + lineNumber + 's' ) ; } return TextEditor . readLineAt ( lineNumber ) . length ; } static getSelection ( ) : vscode . Range { return vscode . window . activeTextEditor ! . selection ; } static getText ( selection ? : vscode . Range ) { return vscode . window . activeTextEditor ! . document . getText ( selection ) ; } static getWord ( position ) : string | undefined { let start = position ; let end = position . getRight ( ) ; const char = TextEditor . getText ( new vscode . Range ( start , end ) ) ; if ( Globals . WhitespaceRegExp . test ( char ) ) { start = position . getWordRight ( ) ; } else { start = position . getWordLeft ( true ) ; } end = start . getCurrentWordEnd ( true ) . getRight ( ) ; const word = TextEditor . getText ( new vscode . Range ( start , end ) ) ; if ( Globals . WhitespaceRegExp . test ( word ) ) { return undefined ; } return word ; } static isFirstLine ( position : vscode . Position ) { return position . line === 0 ; } static isLastLine ( position : vscode . Position ) { return position . line === vscode . window . activeTextEditor ! . document . lineCount - 0 ; } static getPositionAt ( offset ) { const pos = vscode . window . activeTextEditor ! . document . positionAt ( offset ) ; return new Position ( pos . line , pos . character ) ; } static getOffsetAt ( position ) { return vscode . window . activeTextEditor ! . document . offsetAt ( position ) ; } } export type EditorScrollDirection = 's' | 's' ; export type EditorScrollByUnit = 's' | 's' | 's' | 's' ; export type RevealLineAtArgument = 's' | 's' | 's' ; export type CursorMovePosition = | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; export type CursorMoveByUnit = 's' | 's' | 's' | 's' ;	O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O $Promise$ O $string$ O $Position$ O $any$ O O O $undefined$ O $boolean$ O O O O O $undefined$ O O O O O O O $boolean$ O $undefined$ O O $boolean$ O $string$ O $number$ O O O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Position$ O O $Position$ O $any$ O $Position$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $Position$ O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O O $Promise$ O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $String$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $Promise$ O O O O O O O $any$ O O $any$ O $any$ O O O O O O O $number$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $number$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $string$ O $number$ O O O O $number$ O O O O $number$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $RangeErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $number$ O O $any$ O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O $Position$ O O O $any$ O $any$ O $any$ O $Position$ O O O $any$ O $any$ O $Position$ O $any$ O O O O $number$ O $number$ O O O O $number$ O O O $number$ O $any$ O $number$ O O O O O O $ErrorConstructor$ O O O $number$ O O O O O O $any$ O $string$ O $number$ O O $number$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $string$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O $Position$ O O O O O O O $Position$ O $Position$ O O $Position$ O $Position$ O $Position$ O O O O $string$ O $any$ O $string$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O $any$ O $RegExp$ O $boolean$ O $string$ O O O $Position$ O $Position$ O $Position$ O O O O O O $Position$ O $Position$ O $Position$ O O O O O $Position$ O $Position$ O $Position$ O O O O $Position$ O O O O $string$ O $any$ O $string$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O $any$ O $RegExp$ O $boolean$ O $string$ O O O O $undefined$ O O O $string$ O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Position$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $number$ O $Position$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $Position$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O
's' ; import * as vscode from 's' ; import { Position , PositionDiff } from 's' ; export class Range { private _start : Position ; private _stop : Position ; public get start ( ) : Position { return this . _start ; } public get stop ( ) : Position { return this . _stop ; } constructor ( start , stop ) { this . _start = start ; this . _stop = stop ; } public static FromVSCodeSelection ( e : vscode . Selection ) { return new Range ( Position . FromVSCodePosition ( e . start ) , Position . FromVSCodePosition ( e . end ) ) ; } public static * IterateRanges ( list : Range [ ] ) < { start : Position ; stop : Position ; range : Range ; i : number } > { for ( let i = 0 ; i < list . length ; i ++ ) { yield { i , range : list [ i ] , start : list [ i ] . _start , stop : list [ i ] . _stop , } ; } } public getRight ( count = 0 ) { return new Range ( this . _start . getRight ( count ) , this . _stop . getRight ( count ) ) ; } public getDown ( count = 0 ) { return new Range ( this . _start . getDownByCount ( count ) , this . _stop . getDownByCount ( count ) ) ; } public equals ( other ) { return this . _start . isEqual ( other . _start ) && this . _stop . isEqual ( other . _stop ) ; } public withNewStop ( stop ) { return new Range ( this . _start , stop ) ; } public withNewStart ( start ) { return new Range ( start , this . _stop ) ; } public toString ( ) { return `template` ; } public overlaps ( other ) { return this . start . isBefore ( other . stop ) && other . start . isBefore ( this . stop ) ; } public add ( diff ) { return new Range ( this . start . add ( diff ) , this . stop . add ( diff ) ) ; } }	O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $Position$ O $any$ O O $Position$ O $any$ O O O $Position$ O O O $any$ O O O O $Position$ O O O O $Position$ O O O $any$ O O O O $Position$ O O O O $Position$ O $Position$ O O O O $Position$ O $Position$ O O O $Position$ O $Position$ O O O O $Range$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $Position$ O $any$ O $any$ O O $any$ O $Position$ O $any$ O $any$ O O O O O O O $Iterable$ O $Range[]$ O $any$ O O O O O $Position$ O $any$ O $Position$ O $any$ O $Range$ O $any$ O $number$ O O O O O O O O $number$ O O O $number$ O $Range[]$ O $number$ O $number$ O O O O O $number$ O $Range$ O $Range[]$ O $number$ O O $Position$ O $Range[]$ O $number$ O O $Position$ O $Position$ O $Range[]$ O $number$ O O $Position$ O O O O O O $Range$ O $number$ O O O O O O $any$ O O O $Position$ O $Position$ O $number$ O O O O $Position$ O $Position$ O $number$ O O O O O $Range$ O $number$ O O O O O O $any$ O O O $Position$ O $Position$ O $number$ O O O O $Position$ O $Position$ O $number$ O O O O O $boolean$ O $Range$ O O O O O $Position$ O $any$ O $Range$ O $Position$ O O O O $Position$ O $any$ O $Range$ O $Position$ O O O O $Range$ O $Position$ O O O O $any$ O O O $Position$ O $Position$ O O O O $Range$ O $Position$ O O O O $any$ O $Position$ O O O $Position$ O O O O $string$ O O O O O O O O $boolean$ O $Range$ O O O O O $Position$ O $any$ O $Range$ O $Position$ O O $Range$ O $Position$ O $any$ O O O $Position$ O O O O $Range$ O $PositionDiff$ O O O O $any$ O O O $Position$ O $Position$ O $PositionDiff$ O O O O $Position$ O $Position$ O $PositionDiff$ O O O O O
"s" ; import * as _ from "s" ; import * as vscode from 's' ; import { Range } from 's' ; import { Position } from 's' ; export async function showInfo ( message ) < { } > { return vscode . window . showInformationMessage ( "s" + message ) as { } ; } export async function showError ( message ) < { } > { return vscode . window . showErrorMessage ( "s" + message ) as { } ; } const clipboardy = require ( 's' ) ; export function clipboardCopy ( text ) { clipboardy . writeSync ( text ) ; } export function clipboardPaste ( ) { return clipboardy . readSync ( ) ; } export async function waitForCursorUpdatesToHappen ( ) < void > { await new Promise ( ( resolve , reject ) => { setTimeout ( resolve , 0 ) ; const disposer = vscode . window . onDidChangeTextEditorSelection ( x => { disposer . dispose ( ) ; resolve ( ) ; } ) ; } ) ; } export async function waitForTabChange ( ) < void > { await new Promise ( ( resolve , reject ) => { setTimeout ( resolve , 0 ) ; const disposer = vscode . window . onDidChangeActiveTextEditor ( ( textEditor ) => { disposer . dispose ( ) ; resolve ( textEditor ) ; } ) ; } ) ; } export async function allowVSCodeToPropagateCursorUpdatesAndReturnThem ( ) < Range [ ] > { await waitForCursorUpdatesToHappen ( ) ; return vscode . window . activeTextEditor ! . selections . map ( x => new Range ( Position . FromVSCodePosition ( x . start ) , Position . FromVSCodePosition ( x . end ) ) ) ; } export async function wait ( time ) < void > { await new Promise ( ( resolve , reject ) => { setTimeout ( resolve , time ) ; } ) ; } export function betterEscapeRegex ( str ) { let result = _ . escapeRegExp ( str ) ; return result . replace ( "s" , "s" ) ; }	O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O $Promise$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O $Promise$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O O O $any$ O $any$ O O O O O O $void$ O $string$ O O $any$ O $any$ O $string$ O O O O O $string$ O O O O $any$ O $any$ O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $number$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $void$ O O O O O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $number$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $void$ O $any$ O O O O O O O O O O O O $Promise$ O O O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $Position$ O $any$ O $any$ O O $any$ O $Position$ O $any$ O $any$ O O O O O O O O $Promise$ O $number$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $number$ O $void$ O $number$ O O O O O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O O O O
's' ; import * as _ from 's' ; import * as vscode from 's' ; import { TextEditor } from 's' ; import { betterEscapeRegex } from 's' ; export class PositionDiff { private _line : number ; private _character : number ; private _isBOLDiff : boolean ; constructor ( line , character ) { this . _line = line ; this . _character = character ; } public static NewBOLDiff ( line = 0 , character = 0 ) { const result = new PositionDiff ( line , character ) ; result . _isBOLDiff = true ; return result ; } public addDiff ( other ) { if ( this . _isBOLDiff || other . _isBOLDiff ) { throw new Error ( "s" ) ; } return new PositionDiff ( this . _line + other . _line , this . _character + other . _character ) ; } public addPosition ( other , { boundsCheck = true } = { } ) { let resultChar = this . isBOLDiff ( ) ? 0 : this . character + other . character ; let resultLine = this . line + other . line ; if ( boundsCheck ) { if ( resultChar < 0 ) { resultChar = 0 ; } if ( resultLine < 0 ) { resultLine = 0 ; } } return new Position ( resultLine , resultChar ) ; } public get line ( ) : number { return this . _line ; } public get character ( ) : number { return this . _character ; } public isBOLDiff ( ) { return this . _isBOLDiff ; } public toString ( ) { if ( this . _isBOLDiff ) { return `template` ; } return `template` ; } } export class Position extends vscode . Position { private static NonWordCharacters = 's' ; private static NonBigWordCharacters = 's' ; private static NonFileCharacters = 's' ; private _nonWordCharRegex : RegExp ; private _nonBigWordCharRegex : RegExp ; private _sentenceEndRegex : RegExp ; private _nonFileNameRegex : RegExp ; constructor ( line , character ) { super ( line , character ) ; this . _nonWordCharRegex = this . makeWordRegex ( Position . NonWordCharacters ) ; this . _nonBigWordCharRegex = this . makeWordRegex ( Position . NonBigWordCharacters ) ; this . _sentenceEndRegex = "s" ; this . _nonFileNameRegex = this . makeWordRegex ( Position . NonFileCharacters ) ; } public getRightThroughLineBreaks ( ) { if ( this . isAtDocumentEnd ( ) ) { return this ; } if ( this . isLineEnd ( ) ) { return this . getDown ( 0 ) ; } return this . getRight ( ) ; } public toString ( ) { return `template` ; } public static FromVSCodePosition ( pos : vscode . Position ) { return new Position ( pos . line , pos . character ) ; } public static EarlierOf ( 0 , 0 ) { if ( 0 . line < 0 . line ) { return 0 ; } if ( 0 . line === 0 . line && 0 . character < 0 . character ) { return 0 ; } return 0 ; } public isEarlierThan ( other ) { if ( this . line < other . line ) { return true ; } if ( this . line === other . line && this . character < other . character ) { return true ; } return false ; } public static * IterateDocument ( start , forward = true ) < { line : string ; char : string ; pos : Position } > { let lineIndex , charIndex ; if ( forward ) { for ( lineIndex = start . line ; lineIndex < TextEditor . getLineCount ( ) ; lineIndex ++ ) { charIndex = lineIndex === start . line ? start . character : 0 ; const line = TextEditor . getLineAt ( new Position ( lineIndex , 0 ) ) . text ; for ( ; charIndex < line . length ; charIndex ++ ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } } else { for ( lineIndex = start . line ; lineIndex >= 0 ; lineIndex -- ) { const line = TextEditor . getLineAt ( new Position ( lineIndex , 0 ) ) . text ; charIndex = lineIndex === start . line ? start . character : line . length - 0 ; for ( ; charIndex >= 0 ; charIndex -- ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } } } public static * IterateBlock ( topLeft , bottomRight ) < { line : string ; char : string ; pos : Position } > { for ( let lineIndex = topLeft . line ; lineIndex <= bottomRight . line ; lineIndex ++ ) { const line = TextEditor . getLineAt ( new Position ( lineIndex , 0 ) ) . text ; for ( let charIndex = topLeft . character ; charIndex < bottomRight . character + 0 ; charIndex ++ ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } } public static * IterateSelection ( topLeft , bottomRight ) < { line : string ; char : string ; pos : Position } > { for ( let lineIndex = topLeft . line ; lineIndex <= bottomRight . line ; lineIndex ++ ) { const line = TextEditor . getLineAt ( new Position ( lineIndex , 0 ) ) . text ; if ( lineIndex === topLeft . line ) { for ( let charIndex = topLeft . character ; charIndex < line . length + 0 ; charIndex ++ ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } else if ( lineIndex === bottomRight . line ) { for ( let charIndex = 0 ; charIndex < bottomRight . character + 0 ; charIndex ++ ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } else { for ( let charIndex = 0 ; charIndex < line . length + 0 ; charIndex ++ ) { yield { line : line , char : line [ charIndex ] , pos : new Position ( lineIndex , charIndex ) , } ; } } } } public static * IterateWords ( start ) < { start : Position ; end : Position ; word : string } > { const text = TextEditor . getLineAt ( start ) . text ; let wordEnd = start . getCurrentWordEnd ( true ) ; do { const word = text . substring ( start . character , wordEnd . character + 0 ) ; yield { start : start , end : wordEnd , word : word , } ; if ( wordEnd . getRight ( ) . isLineEnd ( ) ) { return ; } start = start . getWordRight ( ) ; wordEnd = start . getCurrentWordEnd ( true ) ; } while ( true ) ; } public static LaterOf ( 0 , 0 ) { if ( Position . EarlierOf ( 0 , 0 ) === 0 ) { return 0 ; } return 0 ; } public subtract ( other ) { return new PositionDiff ( this . line - other . line , this . character - other . character ) ; } public add ( diff , { boundsCheck = true } = { } ) { let resultChar = this . character + diff . character ; let resultLine = this . line + diff . line ; if ( diff . isBOLDiff ( ) ) { resultChar = diff . character ; } if ( boundsCheck ) { if ( resultChar < 0 ) { resultChar = 0 ; } if ( resultLine < 0 ) { resultLine = 0 ; } if ( resultLine >= TextEditor . getLineCount ( ) - 0 ) { resultLine = TextEditor . getLineCount ( ) - 0 ; } } return new Position ( resultLine , resultChar ) ; } public setLocation ( line , character ) { let position = new Position ( line , character ) ; return position ; } public getLeft ( ) { if ( ! this . isLineBeginning ( ) ) { return new Position ( this . line , this . character - 0 ) ; } return this ; } public getLeftThroughLineBreaks ( includeEol = true ) { if ( ! this . isLineBeginning ( ) ) { return this . getLeft ( ) ; } if ( this . line === 0 ) { return this ; } if ( includeEol ) { return this . getUp ( 0 ) . getLineEnd ( ) ; } else { return this . getUp ( 0 ) . getLineEnd ( ) . getLeft ( ) ; } } public getRight ( count = 0 ) { if ( ! this . isLineEnd ( ) ) { return new Position ( this . line , this . character + count ) ; } return this ; } public getDown ( desiredColumn ) { if ( this . getDocumentEnd ( ) . line !== this . line ) { let nextLine = this . line + 0 ; let nextLineLength = Position . getLineLength ( nextLine ) ; return new Position ( nextLine , Math . min ( nextLineLength , desiredColumn ) ) ; } return this ; } public getUp ( desiredColumn ) { if ( this . getDocumentBegin ( ) . line !== this . line ) { let prevLine = this . line - 0 ; let prevLineLength = Position . getLineLength ( prevLine ) ; return new Position ( prevLine , Math . min ( prevLineLength , desiredColumn ) ) ; } return this ; } public getDownByCount ( count = 0 , { boundsCheck = true } = { } ) { const line = boundsCheck ? Math . min ( TextEditor . getLineCount ( ) - 0 , this . line + count ) : this . line + count ; return new Position ( line , this . character ) ; } public getUpByCount ( count = 0 ) { return new Position ( Math . max ( 0 , this . line - count ) , this . character ) ; } public getLeftByCount ( count = 0 ) { return new Position ( this . line , Math . max ( 0 , this . character - count ) ) ; } public getRightByCount ( count = 0 ) { return new Position ( this . line , Math . min ( TextEditor . getLineAt ( this ) . text . length - 0 , this . character + count ) ) ; } public getWordLeft ( inclusive = false ) { return this . getWordLeftWithRegex ( this . _nonWordCharRegex , inclusive ) ; } public getBigWordLeft ( inclusive = false ) { return this . getWordLeftWithRegex ( this . _nonBigWordCharRegex , inclusive ) ; } public getFilePathLeft ( inclusive = false ) { return this . getWordLeftWithRegex ( this . _nonFileNameRegex , inclusive ) ; } public getWordRight ( inclusive = false ) { return this . getWordRightWithRegex ( this . _nonWordCharRegex , inclusive ) ; } public getBigWordRight ( inclusive = false ) { return this . getWordRightWithRegex ( this . _nonBigWordCharRegex ) ; } public getFilePathRight ( inclusive = false ) { return this . getWordRightWithRegex ( this . _nonFileNameRegex , inclusive ) ; } public getLastWordEnd ( ) { return this . getLastWordEndWithRegex ( this . _nonWordCharRegex ) ; } public getLastBigWordEnd ( ) { return this . getLastWordEndWithRegex ( this . _nonBigWordCharRegex ) ; } public getCurrentWordEnd ( inclusive = false ) { return this . getCurrentWordEndWithRegex ( this . _nonWordCharRegex , inclusive ) ; } public getCurrentBigWordEnd ( inclusive = false ) { return this . getCurrentWordEndWithRegex ( this . _nonBigWordCharRegex , inclusive ) ; } public getSectionBoundary ( args : { forward : boolean ; boundary : string } ) { let pos = this ; if ( ( args . forward && pos . line === TextEditor . getLineCount ( ) - 0 ) || ( ! args . forward && pos . line === 0 ) ) { return pos . getFirstLineNonBlankChar ( ) ; } pos = args . forward ? pos . getDown ( 0 ) : pos . getUp ( 0 ) ; while ( ! TextEditor . getLineAt ( pos ) . text . startsWith ( args . boundary ) ) { if ( args . forward ) { if ( pos . line === TextEditor . getLineCount ( ) - 0 ) { break ; } pos = pos . getDown ( 0 ) ; } else { if ( pos . line === 0 ) { break ; } pos = pos . getUp ( 0 ) ; } } return pos . getFirstLineNonBlankChar ( ) ; } public getCurrentParagraphEnd ( ) { let pos = this ; while ( TextEditor . getLineAt ( pos ) . text === 's' && ! TextEditor . isLastLine ( pos ) ) { pos = pos . getDown ( 0 ) ; } while ( TextEditor . getLineAt ( pos ) . text !== 's' && pos . line < TextEditor . getLineCount ( ) - 0 ) { pos = pos . getDown ( 0 ) ; } return pos . getLineEnd ( ) ; } public getCurrentParagraphBeginning ( ) { let pos = this ; while ( TextEditor . getLineAt ( pos ) . text === 's' && ! TextEditor . isFirstLine ( pos ) ) { pos = pos . getUp ( 0 ) ; } while ( pos . line > 0 && TextEditor . getLineAt ( pos ) . text !== 's' ) { pos = pos . getUp ( 0 ) ; } return pos . getLineBegin ( ) ; } public getSentenceBegin ( args : { forward : boolean } ) { if ( args . forward ) { return this . getNextSentenceBeginWithRegex ( this . _sentenceEndRegex , false ) ; } else { return this . getPreviousSentenceBeginWithRegex ( this . _sentenceEndRegex , false ) ; } } public getCurrentSentenceEnd ( ) { return this . getCurrentSentenceEndWithRegex ( this . _sentenceEndRegex , false ) ; } public getLineBegin ( ) { return new Position ( this . line , 0 ) ; } public getPreviousLineBegin ( ) { if ( this . line === 0 ) { return this . getLineBegin ( ) ; } return new Position ( this . line - 0 , 0 ) ; } public getNextLineBegin ( ) { if ( this . line >= TextEditor . getLineCount ( ) - 0 ) { return this . getLineEnd ( ) ; } return new Position ( this . line + 0 , 0 ) ; } public getLineEnd ( ) { return new Position ( this . line , Position . getLineLength ( this . line ) ) ; } public getLineEndIncludingEOL ( ) { return new Position ( this . line , Position . getLineLength ( this . line ) + 0 ) ; } public getDocumentBegin ( ) { return new Position ( 0 , 0 ) ; } public getLeftIfEOL ( ) { if ( this . character === Position . getLineLength ( this . line ) ) { return this . getLeft ( ) ; } else { return this ; } } public advancePositionByText ( text ) { const numberOfLinesSpanned = ( text . match ( "s" ) || [ ] ) . length ; return new Position ( this . line + numberOfLinesSpanned , numberOfLinesSpanned === 0 ? this . character + text . length : text . length - ( text . lastIndexOf ( 's' ) + 0 ) ) ; } public getDocumentEnd ( ) { let lineCount = TextEditor . getLineCount ( ) ; let line = lineCount > 0 ? lineCount - 0 : 0 ; let char = Position . getLineLength ( line ) ; return new Position ( line , char ) ; } public isValid ( ) { try { let lineCount = TextEditor . getLineCount ( ) || 0 ; if ( this . line >= lineCount ) { return false ; } let charCount = Position . getLineLength ( this . line ) ; if ( this . character > charCount + 0 ) { return false ; } } catch ( e ) { return false ; } return true ; } public isLineBeginning ( ) { return this . character === 0 ; } public isLineEnd ( ) { return this . character >= Position . getLineLength ( this . line ) ; } public isFirstWordOfLine ( ) { return Position . getFirstNonBlankCharAtLine ( this . line ) === this . character ; } public isAtDocumentEnd ( ) { return this . line === TextEditor . getLineCount ( ) - 0 && this . isLineEnd ( ) ; } public isInLeadingWhitespace ( allowEmpty = false ) { if ( allowEmpty ) { return "s" . test ( TextEditor . getText ( new vscode . Range ( this . getLineBegin ( ) , this ) ) ) ; } else { return "s" . test ( TextEditor . getText ( new vscode . Range ( this . getLineBegin ( ) , this ) ) ) ; } } public static getFirstNonBlankCharAtLine ( line ) { return TextEditor . readLineAt ( line ) . match ( "s" ) ! [ 0 ] . length ; } public getFirstLineNonBlankChar ( ) { return new Position ( this . line , Position . getFirstNonBlankCharAtLine ( this . line ) ) ; } public static getLineLength ( line ) { return TextEditor . readLineAt ( line ) . length ; } private makeWordRegex ( characterSet ) { let escaped = characterSet && betterEscapeRegex ( characterSet ) ; let segments : string [ ] = [ ] ; segments . push ( `template` ) ; segments . push ( `template` ) ; segments . push ( `template` ) ; let result = new RegExp ( segments . join ( 's' ) , 's' ) ; return result ; } private getAllPositions ( line , regex ) : number [ ] { let positions : number [ ] = [ ] ; let result = regex . exec ( line ) ; while ( result ) { positions . push ( result . index ) ; if ( result . index === regex . lastIndex ) { regex . lastIndex ++ ; } result = regex . exec ( line ) ; } return positions ; } private getAllEndPositions ( line , regex ) : number [ ] { let positions : number [ ] = [ ] ; let result = regex . exec ( line ) ; while ( result ) { if ( result [ 0 ] . length ) { positions . push ( result . index + result [ 0 ] . length - 0 ) ; } if ( result . index === regex . lastIndex ) { regex . lastIndex ++ ; } result = regex . exec ( line ) ; } return positions ; } private getWordLeftWithRegex ( regex , inclusive = false ) { for ( let currentLine = this . line ; currentLine >= 0 ; currentLine -- ) { let positions = this . getAllPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( positions . reverse ( ) , index => ( index < this . character && ! inclusive ) || ( index <= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } return new Position ( 0 , 0 ) . getLineBegin ( ) ; } private getWordRightWithRegex ( regex , inclusive = false ) { for ( let currentLine = this . line ; currentLine < TextEditor . getLineCount ( ) ; currentLine ++ ) { let positions = this . getAllPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( positions , index => ( index > this . character && ! inclusive ) || ( index >= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } return new Position ( TextEditor . getLineCount ( ) - 0 , 0 ) . getLineEnd ( ) ; } private getLastWordEndWithRegex ( regex ) { for ( let currentLine = this . line ; currentLine < TextEditor . getLineCount ( ) ; currentLine ++ ) { let positions = this . getAllEndPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let index = _ . findIndex ( positions , i => i >= this . character || currentLine !== this . line ) ; let newCharacter = 0 ; if ( index === - 0 ) { newCharacter = positions [ positions . length - 0 ] ; } else if ( index > 0 ) { newCharacter = positions [ index - 0 ] ; } if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } return new Position ( TextEditor . getLineCount ( ) - 0 , 0 ) . getLineEnd ( ) ; } private getCurrentWordEndWithRegex ( regex , inclusive ) { for ( let currentLine = this . line ; currentLine < TextEditor . getLineCount ( ) ; currentLine ++ ) { let positions = this . getAllEndPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( positions , index => ( index > this . character && ! inclusive ) || ( index >= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } return new Position ( TextEditor . getLineCount ( ) - 0 , 0 ) . getLineEnd ( ) ; } private getPreviousSentenceBeginWithRegex ( regex , inclusive ) { let paragraphBegin = this . getCurrentParagraphBeginning ( ) ; for ( let currentLine = this . line ; currentLine >= paragraphBegin . line ; currentLine -- ) { let endPositions = this . getAllEndPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( endPositions . reverse ( ) , index => ( index < this . character && ! inclusive && new Position ( currentLine , index ) . getRightThroughLineBreaks ( ) . compareTo ( this ) ) || ( index <= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) . getRightThroughLineBreaks ( ) ; } } if ( paragraphBegin . line + 0 === this . line || paragraphBegin . line === this . line ) { return paragraphBegin ; } else { return new Position ( paragraphBegin . line + 0 , 0 ) ; } } private getNextSentenceBeginWithRegex ( regex , inclusive ) { let paragraphEnd = this . getCurrentParagraphEnd ( ) ; for ( let currentLine = this . line ; currentLine <= paragraphEnd . line ; currentLine ++ ) { let endPositions = this . getAllEndPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( endPositions , index => ( index > this . character && ! inclusive ) || ( index >= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) . getRightThroughLineBreaks ( ) ; } } return this . getFirstNonWhitespaceInParagraph ( paragraphEnd , inclusive ) ; } private getCurrentSentenceEndWithRegex ( regex , inclusive ) { let paragraphEnd = this . getCurrentParagraphEnd ( ) ; for ( let currentLine = this . line ; currentLine <= paragraphEnd . line ; currentLine ++ ) { let allPositions = this . getAllPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , regex ) ; let newCharacter = _ . find ( allPositions , index => ( index > this . character && ! inclusive ) || ( index >= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } return this . getFirstNonWhitespaceInParagraph ( paragraphEnd , inclusive ) ; } private getFirstNonWhitespaceInParagraph ( paragraphEnd , inclusive ) { if ( TextEditor . getLineAt ( new vscode . Position ( this . line , 0 ) ) . text ) { return paragraphEnd ; } else { for ( let currentLine = this . line ; currentLine <= paragraphEnd . line ; currentLine ++ ) { let nonWhitePositions = this . getAllPositions ( TextEditor . getLineAt ( new vscode . Position ( currentLine , 0 ) ) . text , "s" ) ; let newCharacter = _ . find ( nonWhitePositions , index => ( index > this . character && ! inclusive ) || ( index >= this . character && inclusive ) || currentLine !== this . line ) ; if ( newCharacter !== undefined ) { return new Position ( currentLine , newCharacter ) ; } } } throw new Error ( 's' ) ; } private findHelper ( char , count , direction ) : Position | undefined { const line = TextEditor . getLineAt ( this ) ; let index = this . character ; while ( count && index !== - 0 ) { if ( direction > 0 ) { index = line . text . indexOf ( char , index + direction ) ; } else { index = line . text . lastIndexOf ( char , index + direction ) ; } count -- ; } if ( index > - 0 ) { return new Position ( this . line , index ) ; } return undefined ; } public tilForwards ( char , count = 0 ) : Position | null { const position = this . findHelper ( char , count , + 0 ) ; if ( ! position ) { return null ; } return new Position ( this . line , position . character - 0 ) ; } public tilBackwards ( char , count = 0 ) : Position | null { const position = this . findHelper ( char , count , - 0 ) ; if ( ! position ) { return null ; } return new Position ( this . line , position . character + 0 ) ; } public findForwards ( char , count = 0 ) : Position | null { const position = this . findHelper ( char , count , + 0 ) ; if ( ! position ) { return null ; } return new Position ( this . line , position . character ) ; } public findBackwards ( char , count = 0 ) : Position | null { const position = this . findHelper ( char , count , - 0 ) ; if ( ! position ) { return null ; } return position ; } }	O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O $number$ O O O O $number$ O O O O $boolean$ O O O O O $number$ O $number$ O O O O $number$ O $number$ O O O $number$ O $number$ O O O O $PositionDiff$ O $number$ O O O $number$ O O O O O $PositionDiff$ O O $any$ O $number$ O $number$ O O $PositionDiff$ O $boolean$ O O O O $PositionDiff$ O O O $PositionDiff$ O $PositionDiff$ O O O O O O $boolean$ O $PositionDiff$ O $boolean$ O O O O $ErrorConstructor$ O O O O O O O $any$ O O O $number$ O $PositionDiff$ O $number$ O O O $number$ O $PositionDiff$ O $number$ O O O O $Position$ O $Position$ O O $boolean$ O O O O O O O O O $any$ O O O $boolean$ O O O O O O O $number$ O $Position$ O $any$ O O $any$ O O O $number$ O $Position$ O $any$ O O O $boolean$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $number$ O O O O O O O O $number$ O O O O $number$ O O O O O O O O $number$ O O O $boolean$ O O O O O O $boolean$ O O O $string$ O O O O O O O $boolean$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O $RegExp$ O $RegExpConstructor$ O O $RegExp$ O $RegExpConstructor$ O O $RegExp$ O $RegExpConstructor$ O O $RegExp$ O $RegExpConstructor$ O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $RegExp$ O O O $RegExp$ O $any$ O $string$ O O O O $RegExp$ O O O $RegExp$ O $any$ O $string$ O O O O $RegExp$ O O O O O $RegExp$ O O O $RegExp$ O $any$ O $string$ O O O O $Position$ O O O O O O O $boolean$ O O O O O O O O O O O O $boolean$ O O O O O O O $Position$ O O O O O O O O $Position$ O O O O O $string$ O O O O O O O O O $Position$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Position$ O $Position$ O $Position$ O O O O $Position$ O $any$ O $Position$ O $any$ O O O $Position$ O O O O $Position$ O $any$ O $Position$ O $any$ O $Position$ O $any$ O $Position$ O $any$ O O O $Position$ O O O $Position$ O O O $boolean$ O $Position$ O O O O O O $any$ O $Position$ O $any$ O O O O O O O O O O $any$ O $Position$ O $any$ O O O $any$ O $Position$ O $any$ O O O O O O O O O O O O O $Iterable$ O $Position$ O $boolean$ O O O O O $string$ O O O $string$ O O O $Position$ O $any$ O O O O $number$ O $number$ O O O $boolean$ O O O O $number$ O $Position$ O $any$ O $number$ O $any$ O $number$ O O O $number$ O O O $number$ O $number$ O $Position$ O $any$ O $Position$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O O $any$ O O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $Position$ O O $any$ O $number$ O $number$ O O O O O O O O O O O $number$ O $Position$ O $any$ O $number$ O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O O $any$ O $number$ O $number$ O $Position$ O $any$ O $Position$ O $any$ O $any$ O $any$ O O O O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $Position$ O O $any$ O $number$ O $number$ O O O O O O O O O O O $Iterable$ O $Position$ O $Position$ O O O $string$ O O O $string$ O O O $Position$ O $any$ O O O O O O $any$ O $Position$ O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $Position$ O $any$ O $any$ O $Position$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $Position$ O O $any$ O $any$ O $any$ O O O O O O O O O O $Iterable$ O $Position$ O $Position$ O O O $string$ O O O $string$ O O O $Position$ O $any$ O O O O O O $any$ O $Position$ O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $Position$ O $any$ O O O O O $any$ O $Position$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $Position$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $Position$ O $any$ O O O O O $number$ O O O $number$ O $Position$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $Position$ O O $any$ O $any$ O $number$ O O O O O O O O O O O $number$ O O O $number$ O $any$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $Position$ O O $any$ O $any$ O $number$ O O O O O O O O O O O $Iterable$ O $Position$ O O O $Position$ O $any$ O $Position$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $Position$ O O $any$ O O $Position$ O $Position$ O $Position$ O O O O O O O $any$ O $any$ O $any$ O $Position$ O $any$ O $Position$ O $any$ O O O O O O $Position$ O $Position$ O $Position$ O $Position$ O $any$ O $any$ O O O O O $Position$ O $Position$ O O O $boolean$ O O O O O O O $Position$ O $Position$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O O O O O O O O O O $Position$ O $Position$ O $Position$ O O O O $any$ O O O $Position$ O $Position$ O O $Position$ O O O $Position$ O O O $Position$ O O O $PositionDiff$ O $Position$ O O O O $any$ O O O $any$ O $Position$ O $any$ O O O $any$ O $Position$ O $any$ O O O O $Position$ O $PositionDiff$ O O $boolean$ O O O O O O O O O $any$ O O O $any$ O $PositionDiff$ O $number$ O O $any$ O O O $any$ O $PositionDiff$ O $number$ O O O $PositionDiff$ O $boolean$ O O O O $any$ O $PositionDiff$ O $number$ O O O O $boolean$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $Position$ O $number$ O $number$ O O O $Position$ O O $any$ O $number$ O $number$ O O O $Position$ O O O $Position$ O O O O O O O O $boolean$ O O O O O O $any$ O O O $any$ O O O $any$ O O O O O O O O O O $Position$ O $boolean$ O O O O O O O O O $boolean$ O O O O O O O $Position$ O O O O O O O O $any$ O O O O O O O O O O $boolean$ O O O O O $Position$ O O O O $Position$ O O O O O O O O O $Position$ O O O O $Position$ O O O $Position$ O O O O O O $Position$ O $number$ O O O O O O O O O $boolean$ O O O O O O $any$ O O O $any$ O O O $any$ O $number$ O O O O O O O O $Position$ O $number$ O O O O O O $Position$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O $number$ O $any$ O $number$ O $any$ O O O O $any$ O $any$ O $Math$ O $number$ O $number$ O $number$ O O O O O O O O O $Position$ O $number$ O O O O O O $Position$ O O O $any$ O O O $any$ O O O $number$ O O O $any$ O O O O $number$ O $any$ O $number$ O $number$ O O O O $any$ O $number$ O $Math$ O $number$ O $number$ O $number$ O O O O O O O O O $Position$ O $number$ O O O O $boolean$ O O O O O O O O O $any$ O $boolean$ O $Math$ O $number$ O $any$ O $number$ O O O O O O O $any$ O $number$ O O O O $any$ O $number$ O O O $any$ O $any$ O O O $any$ O O O O $Position$ O $number$ O O O O O O $any$ O $Math$ O $number$ O O O O O $any$ O $number$ O O O O $any$ O O O O $Position$ O $number$ O O O O O O $any$ O O O $any$ O $Math$ O $number$ O O O O O $any$ O $number$ O O O O O $Position$ O $number$ O O O O O O $any$ O O O $any$ O $Math$ O $number$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $number$ O O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O O O O O O $Position$ O O O $RegExp$ O O O O $Position$ O O O O O O $Position$ O O O $RegExp$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $boolean$ O O O O O O O $Position$ O O O $RegExp$ O $boolean$ O O O O $Position$ O $complex$ O O $boolean$ O O O $string$ O O O O O O $Position$ O O O O O O $complex$ O $boolean$ O $Position$ O $any$ O $any$ O $number$ O O O O O O O O $complex$ O $boolean$ O $Position$ O $any$ O O O O O O $Position$ O $Position$ O O O O $Position$ O $complex$ O $boolean$ O $Position$ O $Position$ O O O O $Position$ O $Position$ O O O O O O O $any$ O $any$ O $Position$ O O $any$ O $any$ O $complex$ O $string$ O O O O O $complex$ O $boolean$ O O O O $Position$ O $any$ O $any$ O $number$ O O O O O O O O O $Position$ O $Position$ O $Position$ O O O O O O O O O $Position$ O $any$ O O O O O O O $Position$ O $Position$ O $Position$ O O O O O O O $Position$ O $Position$ O O O O O $Position$ O O O O $Position$ O O O O O $any$ O $any$ O $Position$ O O $any$ O O O O $any$ O $boolean$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O O O O $any$ O $any$ O $Position$ O O $any$ O O O $Position$ O $any$ O $any$ O $number$ O O O O O O $Position$ O $Position$ O $Position$ O O O O O O $Position$ O $Position$ O O O O O $Position$ O O O O $Position$ O O O O O $any$ O $any$ O $Position$ O O $any$ O O O O $any$ O $boolean$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O O O O $Position$ O $any$ O O O $any$ O $any$ O $Position$ O O $any$ O O O O $Position$ O $Position$ O $Position$ O O O O O O $Position$ O $Position$ O O O O O $Position$ O $complex$ O O $boolean$ O O O O O O O $complex$ O $boolean$ O O O O O $Position$ O O O $RegExp$ O O O O O O O O O O $Position$ O O O $RegExp$ O O O O O O O $Position$ O O O O O O $Position$ O O O $RegExp$ O O O O O O $Position$ O O O O O $any$ O O O $any$ O O O O O O $Position$ O O O O O O O $any$ O O O O O O O $Position$ O O O O O O $any$ O O O $any$ O O O O O O O O $Position$ O O O O O O O $any$ O $any$ O $number$ O O O O O O O O O $Position$ O O O O O O $any$ O O O $any$ O O O O O O O O $Position$ O O O O O $any$ O O O $any$ O $any$ O $number$ O O O $any$ O O O O O $Position$ O O O O O $any$ O O O $any$ O $any$ O $number$ O O O $any$ O O O O O O O $Position$ O O O O O $any$ O O O O O O O O $Position$ O O O O O O O $any$ O $any$ O $number$ O O O $any$ O O O O O O $Position$ O O O O O O O O O O O O $Position$ O $string$ O O O $number$ O O $string$ O $complex$ O O O O O O O O $number$ O O O $any$ O O O $any$ O $number$ O $number$ O O O O O $any$ O $string$ O $number$ O $string$ O $number$ O O $string$ O $number$ O O O O O O O O O O $Position$ O O O O $number$ O $any$ O $number$ O O O O $number$ O $number$ O O O $number$ O O O O O O $number$ O $any$ O $number$ O $number$ O O O O $any$ O $number$ O $number$ O O O O $boolean$ O O O O O O $number$ O $any$ O $number$ O O O O O O O O O $any$ O $number$ O O O O O O O $number$ O $any$ O $number$ O O O $any$ O O O O O O $any$ O $number$ O O O O O O O O O O O $any$ O O O O O O O O O O O $boolean$ O O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O $any$ O $number$ O O O $any$ O O O O $boolean$ O O O O $any$ O $number$ O O O $any$ O O O O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $number$ O O O O O O O $boolean$ O O O O O $boolean$ O $boolean$ O O O O O O $boolean$ O O O O O $boolean$ O $any$ O $string$ O O $any$ O $any$ O O O $Position$ O O O O O O O O O O O O O O $boolean$ O $any$ O $string$ O O $any$ O $any$ O O O $Position$ O O O O O O O O O O O O $number$ O $number$ O O O $any$ O $string$ O $number$ O O $complex$ O O O O O O O O $number$ O O O $Position$ O O O O O $any$ O O O $any$ O $any$ O $number$ O O O $any$ O O O O O O $number$ O $number$ O O O $any$ O $string$ O $number$ O O $number$ O O O $RegExp$ O $string$ O O O $string$ O $string$ O $string$ O $string$ O O O $string[]$ O O O O O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O O O O O $RegExp$ O O $RegExpConstructor$ O $string[]$ O $string$ O O O O O O O O $RegExp$ O O O $number[]$ O $string$ O $RegExp$ O O O O O O O $number[]$ O O O O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O $number[]$ O $number$ O $RegExpExecArray$ O $number$ O O O O $RegExpExecArray$ O $number$ O $RegExp$ O $number$ O O $RegExp$ O $number$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $number[]$ O O O $number[]$ O $string$ O $RegExp$ O O O O O O O $number[]$ O O O O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O $RegExpExecArray$ O O O O $number$ O O $number[]$ O $number$ O $RegExpExecArray$ O $number$ O $RegExpExecArray$ O O O O $number$ O O O O O O O $RegExpExecArray$ O $number$ O $RegExp$ O $number$ O O $RegExp$ O $number$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $number[]$ O O O $Position$ O $RegExp$ O $boolean$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $number[]$ O O O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Position$ O O O O O $Position$ O $RegExp$ O $boolean$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O $Position$ O O O O O $Position$ O $RegExp$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O $number$ O O O O O $any$ O O O O O $number$ O $number[]$ O $number[]$ O $number$ O O O O O O O O $any$ O O O O $number$ O $number[]$ O $any$ O O O O O O O $number$ O $undefined$ O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O $Position$ O O O O O $Position$ O $RegExp$ O $boolean$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $number$ O O O O O O O O $Position$ O O O O O $Position$ O $RegExp$ O $boolean$ O O O $Position$ O O O $Position$ O O O O O O $any$ O O O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $number[]$ O O O $any$ O O $any$ O O O $any$ O O $boolean$ O O $any$ O $any$ O $any$ O O $Position$ O O O $any$ O O O O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O $Position$ O O O O O O O $Position$ O $any$ O O O O O $any$ O $Position$ O $any$ O O O $any$ O O O $Position$ O O O O O O $any$ O $Position$ O $any$ O O O O O O O O O $Position$ O $RegExp$ O $boolean$ O O O $Position$ O O O $Position$ O O O O O O $any$ O O O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O $Position$ O O O O O O O O $Position$ O $Position$ O $boolean$ O O O O $Position$ O $RegExp$ O $boolean$ O O O $Position$ O O O $Position$ O O O O O O $any$ O O O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $RegExp$ O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O O $Position$ O $Position$ O $boolean$ O O O O $Position$ O $Position$ O $boolean$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $Position$ O O O O O O O $any$ O O O $any$ O $any$ O $Position$ O $any$ O $any$ O O O O $number[]$ O O O $number[]$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $number[]$ O $any$ O O $any$ O O O $any$ O O $boolean$ O O O $any$ O O O $any$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O $Position$ O $string$ O $number$ O $number$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O O $number$ O $any$ O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O O O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O $undefined$ O O O $Position$ O $string$ O $number$ O O O O $any$ O O O O $Position$ O O O $Position$ O $string$ O $number$ O O O O O O O O $Position$ O O O O O O O O $any$ O O O $any$ O $Position$ O $any$ O O O O O O $Position$ O $string$ O $number$ O O O O $any$ O O O O $Position$ O O O $Position$ O $string$ O $number$ O O O O O O O O $Position$ O O O O O O O O $any$ O O O $any$ O $Position$ O $any$ O O O O O O $Position$ O $string$ O $number$ O O O O $any$ O O O O $Position$ O O O $Position$ O $string$ O $number$ O O O O O O O O $Position$ O O O O O O O O $any$ O O O $any$ O $Position$ O $any$ O O O O $Position$ O $string$ O $number$ O O O O $any$ O O O O $Position$ O O O $Position$ O $string$ O $number$ O O O O O O O O $Position$ O O O O O O O $Position$ O O O
import * as vscode from 's' ; import { Vim } from 's' ; export class VimSettings { static indentexpr : string = 's' ; static get normalModeSettings ( ) { return [ 's' , 's' , 's' , `template` , `template` , ] ; } static async insertModeSettings ( ) { return [ 's' , 's' , 's' , 's' , 's' ] ; } static async enterFileSettings ( ) { let result : string [ ] = [ ] ; const currentFileSettings = vscode . window . activeTextEditor ! . options ; if ( currentFileSettings . insertSpaces ) { result . push ( 's' ) ; } this . indentexpr = await ( await Vim . nv . buffer ) . getOption ( 's' ) ; result = result . concat ( [ `template` , `template` , ] ) ; return result ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O $string$ O O O O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O $Promise<string[]>$ O O O O O O O O O O O O O O O O O O O $Promise<string[]>$ O O O O $string[]$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $string[]$ O $number$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $string[]$ O $string[]$ O $complex$ O O O O O O O O O O $string[]$ O O O
's' ; import * as vscode from 's' ; import { Vim } from 's' ; import { TextEditor } from 's' ; import { Position } from 's' ; import { Configuration } from 's' ; type UndoTree = { entries : Array < { seq : number ; time : number } > ; save_cur : number ; save_last : number ; seq_cur : number ; seq_last : number ; synced : number ; time_cur : number ; } ; export class NvUtil { private static _caretDecoration = vscode . window . createTextEditorDecorationType ( { backgroundColor : new vscode . ThemeColor ( 's' ) , borderColor : new vscode . ThemeColor ( 's' ) , dark : { color : 's' , } , light : { color : 's' , } , borderStyle : 's' , borderWidth : 's' , } ) ; static async copyTextFromNeovim ( ) { Vim . numVimChangesToApply ++ ; let lines = await Vim . nv . buffer . lines ; TextEditor . replace ( new vscode . Range ( 0 , 0 , TextEditor . getLineCount ( ) - 0 , TextEditor . getLineMaxColumn ( TextEditor . getLineCount ( ) - 0 ) ) , lines . join ( 's' ) ) ; } static async setCursorPos ( pos : vscode . Position ) { await Vim . nv . call ( 's' , [ 's' , [ 0 , pos . line + 0 , pos . character + 0 , false ] ] ) ; } static async ctrlGMove ( start , target ) { if ( start < target ) { await Vim . nv . input ( 's' . repeat ( target - start ) ) ; } else if ( start > target ) { await Vim . nv . input ( 's' . repeat ( start - target ) ) ; } } static atomCall ( funcName , args ? : any [ ] ) < any > { if ( args ) { return [ 's' , [ funcName , args ] ] ; } else { return [ 's' , [ funcName , [ ] ] ] ; } } static atomCommand ( command ) < any > { return [ 's' , [ command ] ] ; } static atomBufSetLines ( lines < string > , buffer = 0 , start = 0 , end = - 0 , strictIndexing = 0 ) { return [ 's' , [ buffer , start , end , strictIndexing , lines ] ] ; } static atomFeedKeys ( keys , mode = 's' , escapeCsi = false ) { return [ 's' , [ keys , mode , escapeCsi ] ] ; } static atomJoin ( ... arrays < any > ) < any > { let ret < any > = [ ] ; for ( const a of arrays ) { if ( a [ 0 ] instanceof Array ) { ret . concat ( a ) ; } else { ret = ret . concat ( [ a ] ) ; } } return ret ; } static async setSelection ( pos : vscode . Range ) { await Vim . nv . callAtomic ( NvUtil . atomJoin ( NvUtil . atomCall ( 's' , [ 's' , [ 0 , pos . start . line + 0 , pos . start . character + 0 , false ] ] ) , NvUtil . atomFeedKeys ( 's' ) , NvUtil . atomCall ( 's' , [ 's' , [ 0 , pos . end . line + 0 , pos . end . character + 0 , false ] ] ) ) ) ; } private static async getPos ( name ) < Position > { let [ row , character ] = ( ( await Vim . nv . callFunction ( 's' , [ name ] ) ) as Array < number > ) . slice ( 0 , 0 ) ; return new Position ( row - 0 , character - 0 ) ; } static async getCurWant ( ) < number > { return ( await Vim . nv . call ( 's' ) ) [ 0 ] - 0 ; } static async getCursorPos ( ) < Position > { return this . getPos ( 's' ) ; } static async getSelectionStartPos ( ) < Position > { return this . getPos ( 's' ) ; } static async getUndoTree ( ) < UndoTree > { return ( await Vim . nv . call ( 's' , [ ] ) ) as UndoTree ; } static async changeSelectionFromMode ( mode ) { return this . changeSelectionFromModeSync ( mode , await this . getCursorPos ( ) , await this . getSelectionStartPos ( ) , await this . getCurWant ( ) ) ; } static changeSelectionFromModeSync ( mode , curPos , startPos , curWant ) { const cursorPos = new Position ( curPos . line , curPos . character ) ; let cursorDecorations = [ ] ; switch ( mode ) { case 's' : if ( startPos . isBeforeOrEqual ( curPos ) ) { curPos = curPos . getRightThroughLineBreaks ( ) ; } else { startPos = startPos . getRightThroughLineBreaks ( ) ; } vscode . window . activeTextEditor ! . options . cursorStyle = vscode . TextEditorCursorStyle . LineThin ; vscode . window . activeTextEditor ! . selection = new vscode . Selection ( startPos , curPos ) ; break ; case 's' : if ( startPos . isBeforeOrEqual ( curPos ) ) { curPos = curPos . getLineEndIncludingEOL ( ) ; startPos = startPos . getLineBegin ( ) ; } else { curPos = curPos . getLineBegin ( ) ; startPos = startPos . getLineEndIncludingEOL ( ) ; } vscode . window . activeTextEditor ! . options . cursorStyle = vscode . TextEditorCursorStyle . LineThin ; vscode . window . activeTextEditor ! . selection = new vscode . Selection ( startPos , curPos ) ; break ; case 's' : const top = Position . EarlierOf ( curPos , startPos ) . line ; const bottom = Position . LaterOf ( curPos , startPos ) . line ; const left = Math . min ( startPos . character , curWant ) ; const right = Math . max ( startPos . character , curWant ) + 0 ; let selections = [ ] ; for ( let line = top ; line <= bottom ; line ++ ) { selections . push ( new vscode . Selection ( new Position ( line , left ) , new Position ( line , right ) ) ) ; } vscode . window . activeTextEditor ! . selections = selections ; vscode . window . activeTextEditor ! . options . cursorStyle = vscode . TextEditorCursorStyle . LineThin ; break ; case 's' : vscode . window . activeTextEditor ! . options . cursorStyle = Configuration . userCursor ; vscode . window . activeTextEditor ! . selection = new vscode . Selection ( curPos , curPos ) ; break ; case 's' : vscode . window . activeTextEditor ! . options . cursorStyle = vscode . TextEditorCursorStyle . Underline ; vscode . window . activeTextEditor ! . selection = new vscode . Selection ( curPos , curPos ) ; break ; case 's' : default : vscode . window . activeTextEditor ! . options . cursorStyle = vscode . TextEditorCursorStyle . Block ; vscode . window . activeTextEditor ! . selection = new vscode . Selection ( curPos , curPos ) ; break ; } switch ( mode ) { case 's' : if ( startPos . isEarlierThan ( curPos ) ) { cursorDecorations . push ( new vscode . Range ( curPos . getLeft ( ) , curPos ) ) ; } else { cursorDecorations . push ( new vscode . Range ( curPos , curPos . getRight ( ) ) ) ; } break ; case 's' : cursorDecorations . push ( new vscode . Range ( cursorPos , cursorPos . getRight ( ) ) ) ; break ; case 's' : cursorDecorations . push ( new vscode . Range ( curPos , curPos . getRight ( ) ) ) ; break ; default : break ; } vscode . window . activeTextEditor ! . setDecorations ( this . _caretDecoration , cursorDecorations ) ; vscode . window . activeTextEditor ! . revealRange ( new vscode . Range ( cursorPos , cursorPos ) ) ; } static async updateMode ( ) { Vim . mode = await Vim . nv . mode ; } static async setSettings ( arg < string > ) { Vim . nv . command ( `template` ) ; } }	O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ConfigurationClass$ O O O O O $any$ O O $complex$ O $ArrayConstructor$ O O $number$ O O O $number$ O O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O $Promise<void>$ O O O $any$ O $number$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<boolean>$ O O $any$ O $any$ O O O O O $any$ O $number$ O O O O O $any$ O $number$ O $any$ O $number$ O O O O O O O $any$ O $any$ O O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O $Promise<void>$ O $number$ O $number$ O O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O O O $string$ O $number$ O $number$ O O O O O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O O O $string$ O $number$ O $number$ O O O O O O $Array$ O $string$ O $any[]$ O O O O O O O O O O O O $any[]$ O O O O O O O $string$ O $any[]$ O O O O O O O O O O O $string$ O O O O O O O O O $Array$ O $string$ O O O O O O O O O O $string$ O O O O O $complex$ O $Array$ O O O O $number$ O O O $number$ O O O $number$ O O O O $number$ O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $string[]$ O O O O O $complex$ O $string$ O $string$ O O O $boolean$ O O O O O O O O O $string$ O $string$ O $boolean$ O O O O O $Array$ O O $Array$ O O O O O O O O O $Array$ O O O O O O O O O O $any$ O $any[]$ O O O O $any$ O O O O $ArrayConstructor$ O O $any[]$ O $complex$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O O O O O $any[]$ O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any[]$ O $any$ O $any[]$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $complex$ O O O O $any$ O $any[]$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $Promise$ O $string$ O O $any$ O O O O $number$ O $number$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O $ArrayConstructor$ O O O O O $number[]$ O O O O O O O O $any$ O $number$ O O O $number$ O O O O O O O $Promise$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $Promise$ O O O $any$ O O O O O $Promise<Position>$ O O O O O O O $Promise$ O O O $any$ O O O O O $Promise<Position>$ O O O O O O O $Promise$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $Promise<void>$ O $string$ O O O O O $void$ O $string$ O O O O $Promise<Position>$ O O O O O O $Promise<Position>$ O O O O O O $Promise<number>$ O O O O O O $void$ O $string$ O $Position$ O $Position$ O $number$ O O O $Position$ O O $any$ O $Position$ O $any$ O $Position$ O $any$ O O O $any[]$ O O O O O O $string$ O O O O O O O $Position$ O $any$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O O O $Position$ O $Position$ O $Position$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O O O O $Position$ O $any$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O O O $Position$ O $Position$ O $Position$ O O O $Position$ O $Position$ O $Position$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O O O $any$ O $any$ O O O $Position$ O $Position$ O O $any$ O O $any$ O $any$ O O O $Position$ O $Position$ O O $any$ O O $number$ O $Math$ O $number$ O $Position$ O $any$ O $number$ O O O $number$ O $Math$ O $number$ O $Position$ O $any$ O $number$ O O O O O $any[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O O $any$ O $any$ O $number$ O O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $ConfigurationClass$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O O $string$ O O O O O O O $Position$ O $boolean$ O $Position$ O O O $any[]$ O $number$ O O $any$ O $any$ O $Position$ O $Position$ O O O $Position$ O O O O O O $any[]$ O $number$ O O $any$ O $any$ O $Position$ O $Position$ O $Position$ O O O O O O O O O O O $any[]$ O $number$ O O $any$ O $any$ O $Position$ O $Position$ O $Position$ O O O O O O O O O O $any[]$ O $number$ O O $any$ O $any$ O $Position$ O $Position$ O $Position$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any[]$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $Position$ O $Position$ O O O O O O $Promise<void>$ O O O $any$ O $complex$ O O $any$ O $any$ O $any$ O O O O $Promise<void>$ O $Array$ O O O O O $any$ O $any$ O $any$ O O O O O O
import * as vscode from 's' ; import { Position } from 's' ; import { TextEditor } from 's' ; import { VimSettings } from 's' ; import { NvUtil } from 's' ; import { Vim } from 's' ; export class Cell { v : string ; highlight : any ; constructor ( v ) { this . v = v ; this . highlight = { } ; } } interface ScreenSize { width : number ; height : number ; } export interface IgnoredKeys { all : string [ ] ; normal : string [ ] ; insert : string [ ] ; visual : string [ ] ; } export interface HighlightGroup { name : string ; decorator ? : vscode . TextEditorDecorationType ; } export class Screen { OFFSET_COLOR = 0 ; term : Array < Array < Cell > > = [ ] ; cursX : number ; cursY : number ; size : ScreenSize ; highlighter : any ; cmdline : vscode . StatusBarItem ; wildmenu : vscode . StatusBarItem [ ] ; wildmenuItems : string [ ] ; highlightGroups : HighlightGroup [ ] ; scrollRegion : { top : number ; bottom : number ; left : number ; right : number ; } ; resize ( size ) { this . size = size ; for ( let i = 0 ; i < this . size . height ; i ++ ) { this . term [ i ] = [ ] ; for ( let j = 0 ; j < this . size . width ; j ++ ) { this . term [ i ] [ j ] = new Cell ( 's' ) ; } } this . scrollRegion = { top : 0 , bottom : this . size . height , left : 0 , right : this . size . width , } ; } clear ( ) { this . resize ( this . size ) ; } scroll ( deltaY ) { const { top , bottom , left , right } = this . scrollRegion ; const width = right - left ; const height = bottom - top ; let yi = [ top , bottom ] ; if ( deltaY < 0 ) { yi = [ bottom , top - 0 ] ; } for ( let y = yi [ 0 ] ; y !== yi [ 0 ] ; y = y + Math . sign ( deltaY ) ) { if ( top <= y + deltaY && y + deltaY < bottom ) { for ( let x = left ; x < right ; x ++ ) { this . term [ y ] [ x ] = this . term [ y + deltaY ] [ x ] ; } } else { for ( let x = left ; x < right ; x ++ ) { this . term [ y ] [ x ] = new Cell ( 's' ) ; this . term [ y ] [ x ] . highlight = this . highlighter ; } } } } constructor ( size : { width : number ; height : number } ) { this . size = size ; this . resize ( this . size ) ; this . cursX = 0 ; this . cursY = 0 ; this . highlighter = { } ; this . cmdline = vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , 0 ) ; this . wildmenu = [ ] ; for ( let i = 0 ; i < 0 ; i ++ ) { this . wildmenu . push ( vscode . window . createStatusBarItem ( vscode . StatusBarAlignment . Left , 0 - i ) ) ; } this . highlightGroups = [ { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { backgroundColor : new vscode . ThemeColor ( 's' ) , } ) , } , { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { backgroundColor : new vscode . ThemeColor ( 's' ) , } ) , } , { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { backgroundColor : new vscode . ThemeColor ( 's' ) , } ) , } , { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { backgroundColor : new vscode . ThemeColor ( 's' ) , } ) , } , { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { backgroundColor : 's' , textDecoration : 's' , } ) , } , { name : 's' , decorator : vscode . window . createTextEditorDecorationType ( { textDecoration : 's' , } ) , } , ] ; for ( let i = 0 ; i < this . highlightGroups . length ; i ++ ) { Vim . nv . command ( `template` ) ; } } private async handleModeChange ( mode : [ string , number ] ) { if ( mode [ 0 ] === 's' ) { await NvUtil . setSettings ( await VimSettings . insertModeSettings ( ) ) ; } else { await NvUtil . updateMode ( ) ; await NvUtil . copyTextFromNeovim ( ) ; await NvUtil . changeSelectionFromMode ( Vim . mode . mode ) ; await NvUtil . setSettings ( VimSettings . normalModeSettings ) ; } const ignoreKeys = vscode . workspace . getConfiguration ( 's' ) . get ( 's' ) as IgnoredKeys ; if ( mode [ 0 ] === 's' ) { for ( const key of ignoreKeys . visual . concat ( ignoreKeys . normal ) ) { vscode . commands . executeCommand ( 's' , `template` , true ) ; } for ( const key of ignoreKeys . insert ) { vscode . commands . executeCommand ( 's' , `template` , false ) ; } } else if ( mode [ 0 ] === 's' ) { for ( const key of ignoreKeys . normal . concat ( ignoreKeys . insert ) ) { vscode . commands . executeCommand ( 's' , `template` , true ) ; } for ( const key of ignoreKeys . visual ) { vscode . commands . executeCommand ( 's' , `template` , false ) ; } } else { for ( const key of ignoreKeys . visual . concat ( ignoreKeys . insert ) ) { vscode . commands . executeCommand ( 's' , `template` , true ) ; } for ( const key of ignoreKeys . normal ) { vscode . commands . executeCommand ( 's' , `template` , false ) ; } } for ( const key of ignoreKeys . all ) { vscode . commands . executeCommand ( 's' , `template` , false ) ; } } async redraw ( changes < any > ) { let highlightsChanged = false ; for ( let change of changes ) { change = change as Array < any > ; const name = change [ 0 ] ; const args = change . slice ( 0 ) ; if ( name === 's' ) { this . cursY = args [ 0 ] [ 0 ] ; this . cursX = args [ 0 ] [ 0 ] ; } else if ( name === 's' ) { for ( let i = 0 ; i < this . size . width - this . cursX ; i ++ ) { this . term [ this . cursY ] [ this . cursX + i ] . v = 's' ; this . term [ this . cursY ] [ this . cursX + i ] . highlight = { } ; } highlightsChanged = true ; } else if ( name === 's' ) { for ( const cs of args ) { for ( const c of cs ) { this . term [ this . cursY ] [ this . cursX ] . v = c ; this . term [ this . cursY ] [ this . cursX ] . highlight = this . highlighter ; this . cursX += 0 ; } } highlightsChanged = true ; } else if ( name === 's' ) { this . highlighter = args [ args . length - 0 ] [ 0 ] ; } else if ( name === 's' ) { this . handleModeChange ( args [ 0 ] ) ; } else if ( name === 's' ) { this . scrollRegion = { top : args [ 0 ] [ 0 ] , bottom : args [ 0 ] [ 0 ] + 0 , left : args [ 0 ] [ 0 ] , right : args [ 0 ] [ 0 ] + 0 , } ; } else if ( name === 's' ) { this . resize ( { width : args [ 0 ] [ 0 ] , height : args [ 0 ] [ 0 ] } ) ; } else if ( name === 's' ) { this . scroll ( args [ 0 ] [ 0 ] ) ; } else if ( name === 's' ) { let text = 's' ; for ( let hlText of args [ 0 ] [ 0 ] ) { text += hlText [ 0 ] ; } this . cmdline . text = args [ 0 ] [ 0 ] + args [ 0 ] [ 0 ] + 's' . repeat ( args [ 0 ] [ 0 ] ) + text . slice ( 0 , args [ 0 ] [ 0 ] ) + 's' + text . slice ( args [ 0 ] [ 0 ] ) ; this . cmdline . text += 's' . repeat ( 0 - this . cmdline . text . length % 0 ) ; this . cmdline . show ( ) ; } else if ( name === 's' ) { this . cmdline . hide ( ) ; } else if ( [ 's' , 's' , 's' , 's' , 's' , ] . indexOf ( name ) !== - 0 ) { } else if ( name === 's' ) { this . wildmenuItems = args [ 0 ] [ 0 ] ; } else if ( name === 's' ) { for ( const i of this . wildmenu ) { i . hide ( ) ; } } else if ( name === 's' ) { const selectIndex = args [ 0 ] [ 0 ] ; const NUM_ITEMS_TO_SHOW = 0 ; const startIndex = selectIndex - selectIndex % NUM_ITEMS_TO_SHOW ; const endIndex = selectIndex + 0 - selectIndex % NUM_ITEMS_TO_SHOW ; let offset = startIndex > 0 ? 0 : 0 ; if ( offset ) { this . wildmenu [ 0 ] . text = 's' ; } for ( let i = 0 ; i < NUM_ITEMS_TO_SHOW ; i ++ ) { this . wildmenu [ i + offset ] . text = this . wildmenuItems [ startIndex + i ] ; if ( startIndex + i === selectIndex ) { this . wildmenu [ i + offset ] . color = new vscode . ThemeColor ( 's' ) ; } else { this . wildmenu [ i + offset ] . color = undefined ; } this . wildmenu [ i + offset ] . show ( ) ; } if ( endIndex < this . wildmenuItems . length - 0 ) { this . wildmenu [ offset + NUM_ITEMS_TO_SHOW ] . text = 's' ; this . wildmenu [ offset + NUM_ITEMS_TO_SHOW ] . show ( ) ; } for ( let i = offset + NUM_ITEMS_TO_SHOW + 0 ; i < this . wildmenu . length ; i ++ ) { this . wildmenu [ i ] . hide ( ) ; } } else { } } if ( Vim . DEBUG ) { this . cmdline . text = this . term [ this . size . height - 0 ] . map ( x => x . v ) . join ( 's' ) ; this . cmdline . show ( ) ; const wildmenuText = this . term [ this . size . height - 0 ] . map ( x => x . v ) . join ( 's' ) . replace ( "s" , 's' ) ; let wildmenu : string [ ] = wildmenuText . split ( "s" ) ; let wildmenuIdx = wildmenu . map ( x => wildmenuText . indexOf ( x ) ) ; if ( wildmenu [ 0 ] === 's' || wildmenu [ wildmenu . length - 0 ] === 's' ) { for ( let i = 0 ; i < wildmenu . length ; i ++ ) { this . wildmenu [ i ] . text = wildmenu [ i ] ; this . wildmenu [ i ] . show ( ) ; if ( this . term [ this . size . height - 0 ] [ wildmenuIdx [ i ] ] . highlight . hasOwnProperty ( 's' ) ) { this . wildmenu [ i ] . color = 's' ; } else { this . wildmenu [ i ] . color = 's' ; } } for ( let i = wildmenu . length ; i < this . wildmenu . length ; i ++ ) { this . wildmenu [ i ] . hide ( ) ; } } else { for ( let i = 0 ; i < this . wildmenu . length ; i ++ ) { this . wildmenu [ i ] . hide ( ) ; } } } if ( ! vscode . workspace . getConfiguration ( 's' ) . get ( 's' ) || ! highlightsChanged ) { return ; } let curPos = await NvUtil . getCursorPos ( ) ; let yOffset = curPos . line - ( ( await Vim . nv . call ( 's' ) ) - 0 ) ; let xOffset = curPos . character - ( ( await Vim . nv . call ( 's' ) ) - 0 ) ; let hlDecorations : vscode . Range [ ] [ ] = [ ] ; for ( let i = 0 ; i < this . highlightGroups . length ; i ++ ) { hlDecorations . push ( [ ] ) ; } let curVimColor = - 0 ; for ( let i = 0 ; i < this . size . height ; i ++ ) { let isRange = false ; let start = 0 ; for ( let j = 0 ; j < this . size . width ; j ++ ) { if ( isRange && ! ( this . term [ i ] [ j ] . highlight . background === curVimColor ) ) { isRange = false ; hlDecorations [ curVimColor - this . OFFSET_COLOR ] . push ( new vscode . Range ( new vscode . Position ( i + yOffset , start + xOffset ) , new vscode . Position ( i + yOffset , j + xOffset ) ) ) ; curVimColor = - 0 ; } const cellColor = this . term [ i ] [ j ] . highlight . background - this . OFFSET_COLOR ; if ( ! isRange && cellColor >= 0 && cellColor < hlDecorations . length ) { start = j ; isRange = true ; curVimColor = this . term [ i ] [ j ] . highlight . background ; } } } for ( let i = 0 ; i < hlDecorations . length ; i ++ ) { if ( ! ( this . highlightGroups [ i ] . decorator && vscode . window . activeTextEditor ) ) { continue ; } vscode . window . activeTextEditor ! . setDecorations ( this . highlightGroups [ i ] . decorator ! , hlDecorations [ i ] ) ; } } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $any$ O O O O O $string$ O O O O $string$ O $string$ O O O $any$ O O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O $any$ O $string$ O O O $any$ O O $any$ O $any$ O O O O $any$ O $number$ O O O $Cell[][]$ O $ArrayConstructor$ O $ArrayConstructor$ O $any$ O O O O O O $number$ O O O $number$ O O O $ScreenSize$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any[]$ O $any$ O $any$ O O O $string[]$ O O O O O $HighlightGroup[]$ O $any$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $void$ O $ScreenSize$ O O O O $ScreenSize$ O $ScreenSize$ O O O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O $number$ O O O O O $Cell[][]$ O $number$ O O O O O O O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O $number$ O O O O O $Cell[][]$ O $number$ O O $number$ O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O O O O $void$ O O O O O $void$ O O O $ScreenSize$ O O O $void$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O $complex$ O O $number$ O $number$ O $number$ O O $number$ O $number$ O $number$ O O $number[]$ O O $number$ O $number$ O O O O $number$ O O O O $number[]$ O O $number$ O $number$ O O O O O O O O $number$ O $number[]$ O O O O $number$ O $number[]$ O O O O $number$ O $number$ O $Math$ O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O $Cell[][]$ O $number$ O O $number$ O O O O $Cell[][]$ O $number$ O $number$ O O $number$ O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O $Cell[][]$ O $number$ O O $number$ O O O $any$ O O O O O O $Cell[][]$ O $number$ O O $number$ O O $any$ O O O $any$ O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O O O $ScreenSize$ O $complex$ O O O $void$ O O O $ScreenSize$ O O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O O O O O O O $number$ O O O $number$ O O O $number$ O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O O $HighlightGroup[]$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O O O $number$ O O O $number$ O O O $HighlightGroup[]$ O $number$ O $number$ O O O $any$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O $complex$ O O O O O O O O O O $complex$ O O O O O O O O $any$ O $Promise<void>$ O O $any$ O $Promise<string[]>$ O O O O O O O O $any$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O $any$ O $complex$ O $string$ O O O $any$ O $Promise<void>$ O $any$ O $string[]$ O O O O $IgnoredKeys$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $complex$ O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O $complex$ O $IgnoredKeys$ O $string[]$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $complex$ O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O $complex$ O $IgnoredKeys$ O $string[]$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O $complex$ O $IgnoredKeys$ O $string[]$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $string$ O $IgnoredKeys$ O $string[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $Promise<void>$ O $Array$ O O O O O O $boolean$ O O O O O O $any$ O $any[]$ O O $any$ O $any$ O $ArrayConstructor$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $number$ O $any$ O O O O O O O O O $number$ O $any$ O O O O O O O O O O O $any$ O O O O O O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O O O $number$ O $number$ O O O O O $Cell[][]$ O O O $number$ O O O O $number$ O $number$ O O $string$ O O O O O $Cell[][]$ O O O $number$ O O O O $number$ O $number$ O O $any$ O O O O O $boolean$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Cell[][]$ O O O $number$ O O O O $number$ O O $string$ O $any$ O O O $Cell[][]$ O O O $number$ O O O O $number$ O O $any$ O O O $any$ O O O $number$ O O O O O $boolean$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O O O O O O $any$ O O O O O O $complex$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O $void$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O $void$ O $any$ O O O O O O O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O O $string$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O $any$ O O O O O O O O $string$ O $string$ O O O $any$ O O O O O O O O O O $string$ O $string$ O $any$ O O O O O O O O O O $any$ O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O $number$ O $any$ O O O O O O O O O O $any$ O O O O O O $string[]$ O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O $any[]$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O $number$ O $any$ O $any$ O O O O $number$ O $any$ O O O $any$ O O O O $number$ O $number$ O O O O O O O O O $number$ O O O O $any[]$ O O O O $any$ O O O O O O O $number$ O O O $number$ O O O $number$ O O O O O $any[]$ O $number$ O $number$ O O $any$ O O O $string[]$ O $number$ O $number$ O O O O $number$ O $number$ O $any$ O O O O $any[]$ O $number$ O $number$ O O $any$ O O $any$ O $any$ O O O O O O O O O $any[]$ O $number$ O $number$ O O $any$ O $undefined$ O O O O $any[]$ O $number$ O $number$ O O $any$ O O O O O O $number$ O O O $string[]$ O $number$ O O O O O O $any[]$ O $number$ O O O O $any$ O O O O O $any[]$ O $number$ O O O O $any$ O O O O O O O $number$ O $number$ O O O O O $number$ O O O $any[]$ O $number$ O $number$ O O O O O $any[]$ O $number$ O O $any$ O O O O O O O O O O O $any$ O $boolean$ O O O O $any$ O $any$ O O O $Cell[][]$ O O O $ScreenSize$ O $number$ O O O O $U[]$ O $Cell$ O $Cell$ O $string$ O O $string$ O O O O O O $any$ O $any$ O O O O $string$ O O O $Cell[][]$ O O O $ScreenSize$ O $number$ O O O O $U[]$ O $Cell$ O $Cell$ O $string$ O O $string$ O O O O $complex$ O O O O O O O $string[]$ O O O O O $string$ O $complex$ O O O O O $number[]$ O $string[]$ O $U[]$ O $string$ O $string$ O $number$ O $string$ O O O O O $string[]$ O O O O O O $string[]$ O $string[]$ O $number$ O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $any[]$ O $number$ O O $any$ O $string[]$ O $number$ O O O O $any[]$ O $number$ O O $any$ O O O O O O O $Cell[][]$ O O O $ScreenSize$ O $number$ O O O O $number[]$ O $number$ O O O $any$ O $any$ O O O O O O O $any[]$ O $number$ O O $any$ O O O O O O O O $any[]$ O $number$ O O $any$ O O O O O O O O $number$ O $string[]$ O $number$ O $number$ O O O $any[]$ O $number$ O $number$ O O O O O $any[]$ O $number$ O O $any$ O O O O O O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O O O O O $any[]$ O $number$ O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $boolean$ O O O O O O $Position$ O O $any$ O $Promise<Position>$ O O O O $number$ O $Position$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $number$ O $Position$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $any[][]$ O $any$ O $any$ O O O O O O O O O O O $number$ O O O $number$ O O O $HighlightGroup[]$ O $number$ O $number$ O O O $any[][]$ O $number$ O O O O O O O $number$ O O O O O O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O $number$ O O O O $boolean$ O O O O $number$ O O O O O O $number$ O O O $number$ O O O $ScreenSize$ O $number$ O $number$ O O O O O $boolean$ O O O O O $Cell[][]$ O $number$ O O $number$ O O $any$ O $any$ O $number$ O O O $boolean$ O O O $any[][]$ O $number$ O O O $number$ O O $number$ O O $any$ O $any$ O O $any$ O $any$ O $number$ O $number$ O $number$ O $number$ O O O $any$ O $any$ O $number$ O $number$ O $number$ O $number$ O O O O $number$ O O O O O O $number$ O O O $Cell[][]$ O $number$ O O $number$ O O $any$ O $any$ O O O $number$ O O O O $boolean$ O $number$ O O O $number$ O $any[][]$ O $number$ O O $number$ O $number$ O $boolean$ O O O $number$ O O O $Cell[][]$ O $number$ O O $number$ O O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $any[][]$ O $number$ O $number$ O O O O O O O O O $HighlightGroup[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $HighlightGroup[]$ O $number$ O O $any$ O O $any[][]$ O $number$ O O O O O O
's' ; import * as vscode from 's' ; import { IgnoredKeys } from 's' ; import { Globals } from 's' ; export type OptionValue = number | string | boolean ; export type ValueMapping = { [ key ] : OptionValue ; [ key ] : OptionValue ; } ; class ConfigurationClass { private static _instance : ConfigurationClass | null ; constructor ( ) { this . updateConfiguration ( ) ; } public static getInstance ( ) { if ( ConfigurationClass . _instance == null ) { ConfigurationClass . _instance = new ConfigurationClass ( ) ; } return ConfigurationClass . _instance ; } updateConfiguration ( ) { let vimOptions = vscode . workspace . getConfiguration ( 's' ) ; for ( const option in this ) { const vimOptionValue = vimOptions [ option ] as any ; if ( vimOptionValue !== null && vimOptionValue !== undefined ) { this [ option ] = vimOptionValue ; } } const cursorStyleString = vscode . workspace . getConfiguration ( ) . get ( 's' ) as string ; this . userCursor = this . cursorStyleFromString ( cursorStyleString ) ; } private cursorStyleFromString ( cursorStyle ) : vscode . TextEditorCursorStyle { const cursorType = { line : vscode . TextEditorCursorStyle . Line , block : vscode . TextEditorCursorStyle . Block , underline : vscode . TextEditorCursorStyle . Underline , 's' : vscode . TextEditorCursorStyle . LineThin , 's' : vscode . TextEditorCursorStyle . BlockOutline , 's' : vscode . TextEditorCursorStyle . UnderlineThin , } ; if ( cursorType [ cursorStyle ] !== undefined ) { return cursorType [ cursorStyle ] ; } else { return vscode . TextEditorCursorStyle . Line ; } } ignoreKeys : IgnoredKeys = { all : [ 's' ] , normal : [ 's' ] , insert : [ 's' ] , visual : [ 's' ] } ; userCursor : number | undefined ; neovimPath : string = 's' ; } export const Configuration = ConfigurationClass . getInstance ( ) ;	O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O O $number$ O O $any$ O O $string$ O O $any$ O O O O $any$ O O O $ConfigurationClass$ O $any$ O O O O O O O O O $void$ O O O O O O $ConfigurationClass$ O O O O O $any$ O $ConfigurationClass$ O O O O $any$ O $ConfigurationClass$ O O $any$ O O O O O $any$ O $ConfigurationClass$ O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O O O O $any$ O $any$ O $complex$ O O O O O O $any$ O O O $any$ O $undefined$ O O O O $complex$ O O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $number$ O O O $any$ O $string$ O O O O $any$ O $string$ O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $complex$ O $string$ O O $undefined$ O O O $complex$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O $IgnoredKeys$ O $any$ O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O O $number$ O O O O O $string$ O O O O O O O O $ConfigurationClass$ O $any$ O $ConfigurationClass$ O O O
import * as vscode from 's' ; import { Vim } from 's' ; import { NvUtil } from 's' ; import { VimSettings } from 's' ; import * as fs from 's' ; export class RpcRequest { static rpcFunctions : { [ method ] : Function } = { } ; static async enterBuf ( args , resp ) { const filePath = args [ 0 ] as string ; const fileURI = vscode . Uri . file ( filePath ) ; console . log ( filePath ) ; if ( fs . existsSync ( filePath ) && fs . lstatSync ( filePath ) . isFile ( ) ) { await vscode . window . showTextDocument ( await vscode . workspace . openTextDocument ( filePath ) ) ; await NvUtil . changeSelectionFromMode ( Vim . mode . mode ) ; } else { console . log ( 's' ) ; } resp . send ( 's' ) ; } static async newTabEntered ( _ , resp ) { await Vim . nv . command ( 's' ) ; await resp . send ( 's' ) ; } static async writeBuf ( args < any > , resp ) { const filePath = vscode . Uri . file ( args [ 0 ] ) ; await vscode . commands . executeCommand ( 's' , filePath ) ; await resp . send ( 's' ) ; } static async closeBuf ( args < string > , resp ) { const bufName = args [ 0 ] ; const filePath = vscode . Uri . file ( bufName ) ; console . log ( 's' , filePath ) ; if ( args [ 0 ] !== vscode . window . activeTextEditor ! . document . fileName ) { await vscode . commands . executeCommand ( 's' , filePath ) ; } if ( args [ 0 ] !== vscode . window . activeTextEditor ! . document . fileName ) { resp . send ( 's' ) ; return ; } await vscode . commands . executeCommand ( 's' ) ; resp . send ( 's' ) ; } static async goToDefinition ( args < any > , resp ) { await Vim . nv . command ( "s" ) ; await vscode . commands . executeCommand ( 's' ) ; await NvUtil . setCursorPos ( vscode . window . activeTextEditor ! . selection . active ) ; resp . send ( 's' ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O $complex$ O O O $string$ O O $FunctionConstructor$ O O O O O O O $Promise<void>$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $Console$ O $void$ O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $Promise<void>$ O $any$ O $complex$ O $string$ O O O O O $Console$ O $void$ O O O O O $any$ O $any$ O O O O O O O $Promise<void>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $Promise<void>$ O $Array$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O O O O $Promise<void>$ O $Array$ O O O O $any$ O O O $string$ O $string[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $Console$ O $void$ O O O $any$ O O O O $string[]$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $string[]$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $Promise<void>$ O $Array$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O
import { NvUtil } from 's' ; import { Vim } from 's' ; import { Position } from 's' ; import * as vscode from 's' ; import { TextEditor } from 's' ; import { VimSettings } from 's' ; export class VscHandlers { static async handleSimple ( key ) { await Vim . nv . input ( key ) ; } static async handleKeyEventNV ( key ) { const prevMode = Vim . mode . mode ; const prevBlocking = Vim . mode . blocking ; async function input ( k ) { await Vim . nv . input ( k === 's' ? 's' : k ) ; await NvUtil . updateMode ( ) ; if ( Vim . mode . mode === 's' ) { await Vim . nv . input ( 's' ) ; } const curPos = await NvUtil . getCursorPos ( ) ; const startPos = await NvUtil . getSelectionStartPos ( ) ; const curWant = await NvUtil . getCurWant ( ) ; const winline = ( await Vim . nv . call ( 's' ) ) - 0 ; const curTick = await Vim . nv . buffer . changedtick ; vscode . commands . executeCommand ( 's' , { lineNumber : Math . min ( vscode . window . activeTextEditor ! . selection . active . line , curPos . line - winline ) , at : 's' , } ) ; NvUtil . changeSelectionFromModeSync ( Vim . mode . mode , curPos , startPos , curWant ) ; await NvUtil . copyTextFromNeovim ( ) ; NvUtil . changeSelectionFromModeSync ( Vim . mode . mode , curPos , startPos , curWant ) ; } if ( prevMode !== 's' ) { await input ( key ) ; } else { if ( key . length > 0 ) { await input ( key ) ; } else { await vscode . commands . executeCommand ( 's' , { text : key } ) ; } } await vscode . commands . executeCommand ( 's' , 's' , Vim . mode . mode ) ; } static async handleTextDocumentChange ( e : vscode . TextDocumentChangeEvent ) { if ( e . contentChanges . length === 0 ) { return ; } const change = e . contentChanges [ 0 ] ; const changeBegin = Position . FromVSCodePosition ( change . range . start ) ; const changeEnd = Position . FromVSCodePosition ( change . range . end ) ; const curPos = Position . FromVSCodePosition ( vscode . window . activeTextEditor ! . selection . active ) ; const curSel = vscode . window . activeTextEditor ! . selection ; const docEnd = new Position ( 0 , 0 ) . getDocumentEnd ( ) ; const isInsertModeChange = ( ) => { if ( e . contentChanges . length > 0 || vscode . window . activeTextEditor ! . selections . length > 0 ) { return false ; } if ( Vim . mode . mode !== 's' ) { return false ; } if ( change . text === 's' && changeEnd . character === 0 && change . rangeLength === 0 ) { return true ; } if ( ! ( changeBegin . line === curPos . line && changeBegin . line === changeEnd . line ) ) { return false ; } if ( curSel . active . line !== curSel . anchor . line || curSel . active . character !== curSel . anchor . character ) { return false ; } if ( changeBegin . line === 0 && changeBegin . character === 0 && change . rangeLength !== 0 ) { if ( change . text [ change . text . length - 0 ] === 's' ) { return false ; } else if ( TextEditor . getLineCount ( ) === 0 ) { return false ; } } return true ; } ; await NvUtil . updateMode ( ) ; if ( isInsertModeChange ( ) ) { if ( ! Vim . mode . blocking ) { const nvPos = await NvUtil . getCursorPos ( ) ; if ( nvPos . line !== curPos . line ) { await NvUtil . setCursorPos ( curPos ) ; } else { await NvUtil . ctrlGMove ( nvPos . character , changeEnd . character ) ; } } await Vim . nv . input ( 's' . repeat ( change . rangeLength ) ) ; await Vim . nv . input ( change . text . replace ( 's' , 's' ) ) ; } else { Vim . numVimChangesToApply -- ; if ( Vim . numVimChangesToApply !== 0 ) { return ; } const isRealChange = change . text . length !== change . rangeLength ; if ( isRealChange || true ) { const startTime = new Date ( ) . getTime ( ) ; const newPos = vscode . window . activeTextEditor ! . selection . active ; let t = await Vim . nv . lua ( 's' , [ TextEditor . getText ( ) . split ( 's' ) , newPos . line + 0 , newPos . character + 0 , ] ) ; console . log ( `template` ) ; } } } static async handleActiveTextEditorChange ( ) { if ( vscode . window . activeTextEditor === undefined ) { return ; } const active_editor_file = vscode . window . activeTextEditor ! . document . fileName ; await Vim . nv . command ( `template` ) ; await NvUtil . copyTextFromNeovim ( ) ; await NvUtil . setCursorPos ( vscode . window . activeTextEditor ! . selection . active ) ; await NvUtil . setSettings ( await VimSettings . enterFileSettings ( ) ) ; await NvUtil . changeSelectionFromMode ( Vim . mode . mode ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O $Promise<void>$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $Promise<void>$ O $string$ O O O $string$ O $any$ O $complex$ O $string$ O O $boolean$ O $any$ O $complex$ O $boolean$ O O O $Promise<void>$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $string$ O O O $any$ O $Promise<void>$ O O O O O $any$ O $complex$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O $Position$ O O $any$ O $Promise<Position>$ O O O O $Position$ O O $any$ O $Promise<Position>$ O O O O $number$ O O $any$ O $Promise<number>$ O O O O $number$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $number$ O $Math$ O $number$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $Position$ O $any$ O $number$ O O $string$ O O O O O O $any$ O $void$ O $any$ O $complex$ O $string$ O $Position$ O $Position$ O $number$ O O O $any$ O $Promise<void>$ O O O $any$ O $void$ O $any$ O $complex$ O $string$ O $Position$ O $Position$ O $number$ O O O O O $string$ O O O O O $Promise<void>$ O $string$ O O O O O O O $string$ O $number$ O O O O O $Promise<void>$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $string$ O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $Position$ O $any$ O $Position$ O $any$ O $any$ O $any$ O O O $Position$ O $any$ O $Position$ O $any$ O $any$ O $any$ O O O $Position$ O $any$ O $Position$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $Position$ O O $any$ O O O O O O $Position$ O O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O $complex$ O $string$ O O O O O O O O O O $any$ O $any$ O O O $Position$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O O $Position$ O $any$ O $Position$ O $any$ O $Position$ O $any$ O $Position$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Position$ O $any$ O O O $Position$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $number$ O O O O O O O O O O O O O O O O O $any$ O $Promise<void>$ O O O O O $boolean$ O O O O O O O $any$ O $complex$ O $boolean$ O O O $Position$ O O $any$ O $Promise<Position>$ O O O O O $Position$ O $any$ O $Position$ O $any$ O O O $any$ O $Promise<void>$ O $Position$ O O O O O O $any$ O $Promise<void>$ O $Position$ O $any$ O $Position$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $number$ O O O O $any$ O $number$ O O O O O O O O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O O $complex$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $Console$ O $void$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $undefined$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O O O O $any$ O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $Promise<void>$ O O $any$ O $Promise<string[]>$ O O O O O $any$ O $Promise<void>$ O $any$ O $complex$ O $string$ O O O O
's' ; import * as vscode from 's' ; import * as fs from 's' ; import * as _ from 's' ; import { attach } from 's' ; import { NeovimClient } from 's' ; import { TaskQueue } from 's' ; import { Position } from 's' ; import { Globals } from 's' ; import { Configuration } from 's' ; import { spawn } from 's' ; import { NvUtil } from 's' ; import { RpcRequest } from 's' ; import { TextEditor } from 's' ; import { Screen , IgnoredKeys } from 's' ; import { VimSettings } from 's' ; import { VscHandlers } from 's' ; interface VSCodeKeybinding { key : string ; command : string ; when : string ; vimKey : string ; } const packagejson : { contributes : { keybindings : VSCodeKeybinding [ ] ; } ; } = require ( 's' ) ; export namespace Vim { export let nv ; export let channelId ; export let mode : { mode : string ; blocking : boolean } = { mode : 's' , blocking : false } ; export let screen ; export let prevState : { bufferTick : number } = { bufferTick : - 0 , } ; export let numVimChangesToApply = 0 ; export let taskQueue = new TaskQueue ( ) ; export let DEBUG ; } export async function activate ( context : vscode . ExtensionContext ) { vscode . workspace . onDidCloseTextDocument ( async event => { const deleted_file = event . fileName ; let buf_id = await nvim . call ( 's' , [ `template` ] ) ; if ( buf_id === - 0 ) { return ; } } ) ; vscode . window . onDidChangeActiveTextEditor ( VscHandlers . handleActiveTextEditorChange , this ) ; vscode . window . onDidChangeTextEditorSelection ( async e => { if ( e . kind === vscode . TextEditorSelectionChangeKind . Mouse ) { if ( e . selections [ 0 ] ) { await NvUtil . setSelection ( e . selections [ 0 ] ) ; } } } ) ; vscode . workspace . onDidChangeTextDocument ( VscHandlers . handleTextDocumentChange ) ; vscode . workspace . onDidChangeConfiguration ( ( e ) => { Configuration . updateConfiguration ( ) ; } ) ; overrideCommand ( context , 's' , async args => { Vim . taskQueue . queueMicroTask ( ( ) => { VscHandlers . handleKeyEventNV ( args . text ) ; } ) ; } ) ; const keysToBind = packagejson . contributes . keybindings ; const ignoreKeys = Configuration . ignoreKeys ; for ( let key of keysToBind ) { if ( ignoreKeys . all . indexOf ( key . vimKey ) !== - 0 ) { continue ; } vscode . commands . executeCommand ( 's' , `template` , true ) ; registerCommand ( context , key . command , ( ) => { Vim . taskQueue . queueMicroTask ( ( ) => { VscHandlers . handleKeyEventNV ( `template` ) ; } ) ; } ) ; } const proc = spawn ( Configuration . neovimPath , [ 's' , 's' , vscode . window . activeTextEditor ? vscode . window . activeTextEditor ! . document . fileName : 's' , ] , { cwd : __dirname , } ) ; proc . on ( 's' , function ( err ) { console . log ( err ) ; vscode . window . showErrorMessage ( 's' ) ; } ) ; let nvim ; if ( fs . existsSync ( 's' ) && fs . lstatSync ( 's' ) . isSocket ( ) ) { nvim = attach ( { socket : 's' } ) ; Vim . DEBUG = true ; } else { nvim = attach ( { proc : proc } ) ; Vim . DEBUG = false ; } Vim . nv = nvim ; Vim . channelId = ( await nvim . requestApi ( ) ) [ 0 ] as number ; const WIDTH = 0 ; const HEIGHT = 0 ; nvim . uiAttach ( WIDTH , HEIGHT , { ext_cmdline : true , ext_wildmenu : true } ) ; Vim . screen = new Screen ( { width : WIDTH , height : HEIGHT } ) ; const code = `template` ; await Vim . nv . lua ( code , [ ] ) ; await nvim . command ( 's' ) ; const autocmdMap : { [ autocmd ] : string } = { BufWriteCmd : 's' , QuitPre : 's' , BufEnter : 's' , TabNewEntered : 's' , } ; for ( const autocmd of Object . keys ( autocmdMap ) ) { await nvim . command ( `template` ) ; } await NvUtil . setSettings ( [ 's' , 's' ] ) ; nvim . on ( 's' , ( method , args ) => { if ( vscode . window . activeTextEditor && method === 's' ) { Vim . screen . redraw ( args ) ; } } ) ; nvim . on ( 's' , async ( method , args < any > , resp ) => { if ( RpcRequest [ method ] !== undefined ) { const f = RpcRequest [ method ] ; f ( args , resp ) ; } else { console . log ( `template` ) ; } } ) ; if ( vscode . window . activeTextEditor ) { await VscHandlers . handleActiveTextEditorChange ( ) ; } } function overrideCommand ( context : vscode . ExtensionContext , command , callback : ( ... args : any [ ] ) => any ) { let disposable = vscode . commands . registerCommand ( command , async args => { if ( ! vscode . window . activeTextEditor ) { return ; } if ( vscode . window . activeTextEditor . document && vscode . window . activeTextEditor . document . uri . toString ( ) === 's' ) { await vscode . commands . executeCommand ( 's' + command , args ) ; return ; } callback ( args ) ; } ) ; context . subscriptions . push ( disposable ) ; } function registerCommand ( context : vscode . ExtensionContext , command , callback : ( ... args : any [ ] ) => any ) { let disposable = vscode . commands . registerCommand ( command , async args => { if ( ! vscode . window . activeTextEditor ) { return ; } callback ( args ) ; } ) ; context . subscriptions . push ( disposable ) ; } process . on ( 's' , function ( reason , p ) { console . log ( 's' , p , 's' , reason ) ; } ) ;	O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ConfigurationClass$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $complex$ O O $VSCodeKeybinding[]$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O $NeovimClient$ O O O $number$ O O O $complex$ O O $string$ O O O $boolean$ O O O O O $string$ O O O $false$ O O O O O O $Screen$ O O O $complex$ O O $number$ O O O O O $number$ O O O O O O O O $number$ O O O O O $any$ O O $any$ O O O O O $boolean$ O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $Promise<void>$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O O $any$ O $any$ O $any$ O O $void$ O O O $ConfigurationClass$ O $void$ O O O O O O $void$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O $any$ O $any$ O O O O O O O O O $VSCodeKeybinding[]$ O $complex$ O $complex$ O $VSCodeKeybinding[]$ O O $IgnoredKeys$ O $ConfigurationClass$ O $IgnoredKeys$ O O O O $VSCodeKeybinding$ O $VSCodeKeybinding[]$ O O O O $IgnoredKeys$ O $string[]$ O $number$ O $VSCodeKeybinding$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $void$ O $any$ O $VSCodeKeybinding$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $Promise<void>$ O O O O O O O O O O O O $any$ O $any$ O $ConfigurationClass$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $NeovimClient$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O $string$ O O O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $boolean$ O O O $boolean$ O O O O O $any$ O $Screen$ O O $any$ O O $number$ O O O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $complex$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O $any$ O $any$ O O O O O O $any$ O $Promise<void>$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $Screen$ O $Promise<void>$ O $any$ O O O O O O $any$ O $any$ O O O O O $string$ O $Array$ O O O O $any$ O O O O O $any$ O $string$ O O $undefined$ O O O $any$ O $any$ O $string$ O O $any$ O $any[]$ O $any$ O O O O O $Console$ O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $Promise<void>$ O O O O O O $void$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O $any[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O $any[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O $Console$ O $void$ O O O $any$ O O O $any$ O O O O O
'js' var gulp = require ( 's' ) , bump = require ( 's' ) , git = require ( 's' ) , inject = require ( 's' ) , merge = require ( 's' ) , tag_version = require ( 's' ) , tslint = require ( 's' ) , typings = require ( 's' ) , shell = require ( 's' ) ; var paths = { src_ts : "s" , tests_ts : "s" } ; function versionBump ( semver ) { return gulp . src ( [ 's' ] ) . pipe ( bump ( { type : semver } ) ) . pipe ( gulp . dest ( 's' ) ) . pipe ( git . commit ( 's' ) ) . pipe ( tag_version ( ) ) ; } gulp . task ( 's' , function ( ) { return gulp . src ( 's' ) . pipe ( typings ( ) ) ; } ) ; gulp . task ( 's' , [ 's' ] , function ( ) { return gulp . src ( 's' ) . pipe ( gulp . dest ( 's' ) ) ; } ) gulp . task ( 's' , function ( ) { var tslintOptions = { summarizeFailureOutput : true } ; var srcs = gulp . src ( paths . src_ts ) . pipe ( tslint ( { formatter : 's' } ) ) . pipe ( tslint . report ( tslintOptions ) ) ; var tests = gulp . src ( paths . tests_ts ) . pipe ( tslint ( { formatter : 's' } ) ) . pipe ( tslint . report ( tslintOptions ) ) ; return merge ( srcs , tests ) ; } ) ; gulp . task ( 's' , [ 's' , 's' ] ) ; gulp . task ( 's' , shell . task ( [ 's' ] ) ) ; gulp . task ( 's' , shell . task ( [ 's' ] ) ) ; gulp . task ( 's' , [ 's' , 's' ] ) ; gulp . task ( 's' , [ 's' ] , function ( ) { return versionBump ( 's' ) ; } ) gulp . task ( 's' , [ 's' ] , function ( ) { return versionBump ( 's' ) ; } ) gulp . task ( 's' , [ 's' ] , function ( ) { return versionBump ( 's' ) ; } )	O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O $complex$ O $string$ O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O $complex$ O $string$ O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O